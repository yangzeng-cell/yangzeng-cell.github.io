

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="目前是4.x版本 什么是 Socket.IOSocket.IO 是一个库，可以在客户端和服务器之间实现 低延迟, 双向 和 基于事件的 通信。  它建立在 WebSocket 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。 这里只介绍socket.io在web端的使用 这是一个websocket的实例 服务器 (基于 ws) npm i ws    import &amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="secket.io笔记">
<meta property="og:url" content="http://example.com/2022/09/24/secket-io%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="目前是4.x版本 什么是 Socket.IOSocket.IO 是一个库，可以在客户端和服务器之间实现 低延迟, 双向 和 基于事件的 通信。  它建立在 WebSocket 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。 这里只介绍socket.io在web端的使用 这是一个websocket的实例 服务器 (基于 ws) npm i ws    import &amp;#12">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://socket.io/zh-CN/images/bidirectional-communication2.png">
<meta property="og:image" content="https://socket.io/zh-CN/assets/images/network-monitor-2e47dbe233100aa290595f8687a9fcba.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/bidirectional-communication-socket.png">
<meta property="og:image" content="https://socket.io/zh-CN/assets/images/mutiple-nodes-no-sticky-babd7860f217e09eefc2db73e5012f91.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/bidirectional-communication-socket.png">
<meta property="og:image" content="https://socket.io/images/client_socket_events.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/broadcasting.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/broadcasting2.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/broadcasting-redis.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/broadcasting-redis-local.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/rooms.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/rooms2.png">
<meta property="og:image" content="https://socket.io/zh-CN/images/rooms-redis.png">
<meta property="article:published_time" content="2022-09-24T15:31:44.000Z">
<meta property="article:modified_time" content="2022-11-06T07:30:12.539Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="socket.io">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://socket.io/zh-CN/images/bidirectional-communication2.png">
  
  
  
  <title>secket.io笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Piggy的记录版</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="secket.io笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-24 15:31" pubdate>
          2022年9月24日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          49k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          412 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">secket.io笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>目前是4.x版本</p>
<h2 id="什么是-Socket-IO"><a href="#什么是-Socket-IO" class="headerlink" title="什么是 Socket.IO"></a>什么是 Socket.IO</h2><p>Socket.IO 是一个库，可以在客户端和服务器之间实现 <strong>低延迟</strong>, <strong>双向</strong> 和 <strong>基于事件的</strong> 通信。</p>
<p><img src="https://socket.io/zh-CN/images/bidirectional-communication2.png" srcset="/img/loading.gif" lazyload alt="Diagram of a communication between a server and a client"></p>
<p>它建立在 <a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/WebSocket">WebSocket</a> 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。</p>
<p>这里只介绍socket.io在web端的使用</p>
<p>这是一个websocket的实例</p>
<p><em>服务器</em> (基于 <a target="_blank" rel="noopener" href="https://github.com/websockets/ws">ws</a>)</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i ws</code></pre></div>



<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">WebSocketServer</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ws&quot;</span>;

<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServer</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span> &#125;);

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// 向客户端发送消息</span>
  socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;
    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;hello from server&quot;</span>,
    <span class="hljs-attr">content</span>: [ <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span> ]
  &#125;));

  <span class="hljs-comment">// 从客户端接收消息</span>
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> packet = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);

    <span class="hljs-keyword">switch</span> (packet.<span class="hljs-property">type</span>) &#123;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello from server&quot;</span>:
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">break</span>;
    &#125;
  &#125;);
&#125;);</code></pre></div>

<p>客户端</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">WebSocket</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ws&quot;</span>;

<span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:3000&quot;</span>);

socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-comment">// 向服务器发送消息</span>
  socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;
    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;hello from server&quot;</span>,
    <span class="hljs-attr">content</span>: [ <span class="hljs-number">3</span>, <span class="hljs-string">&quot;4&quot;</span> ]
  &#125;));
&#125;);

<span class="hljs-comment">// 从服务器接收消息</span>
socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> packet = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);

  <span class="hljs-keyword">switch</span> (packet.<span class="hljs-property">type</span>) &#123;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello from server&quot;</span>:
      <span class="hljs-comment">// ...</span>
      <span class="hljs-keyword">break</span>;
  &#125;
&#125;);</code></pre></div>

<p>socket.io的示例,需要先安装socket.io和socket.io-client</p>
<p>服务端</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(<span class="hljs-number">3000</span>);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// 向客户端发送消息</span>
  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">4</span>]) &#125;);

  <span class="hljs-comment">// 从客户端接收消息</span>
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;);
&#125;);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;

<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;ws://localhost:3000&quot;</span>);

<span class="hljs-comment">// 向服务器发送消息</span>
socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;6&quot;</span>, &#123; <span class="hljs-number">7</span>: <span class="hljs-title class_">Uint8Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">8</span>]) &#125;);

<span class="hljs-comment">// 从服务器接收消息</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>

<h2 id="Socket-IO-不是什么"><a href="#Socket-IO-不是什么" class="headerlink" title="Socket.IO 不是什么"></a>Socket.IO 不是什么</h2><p>Socket.IO <strong>不是</strong> WebSocket实现。是基于WebSocket协议</p>
<p>尽管 Socket.IO 确实在可能的情况下使用 WebSocket 进行传输，但它为每个数据包添加了额外的元数据。这就是为什么 WebSocket 客户端将无法成功连接到 Socket.IO 服务器，而 Socket.IO 客户端也将无法连接到普通 WebSocket 服务器。</p>
<div class="code-wrapper"><pre><code class="hljs abnf">// 警告：客户端将无法连接！
const socket <span class="hljs-operator">=</span> io(<span class="hljs-string">&quot;ws://echo.websocket.org&quot;</span>)<span class="hljs-comment">;</span></code></pre></div>

<h2 id="Socket-IO特点"><a href="#Socket-IO特点" class="headerlink" title="Socket.IO特点"></a>Socket.IO特点</h2><h3 id="HTTP-长轮询回退"><a href="#HTTP-长轮询回退" class="headerlink" title="HTTP 长轮询回退"></a>HTTP 长轮询回退</h3><p>如果无法建立 WebSocket 连接，连接将回退到 HTTP 长轮询。</p>
<h3 id="自动重新连接"><a href="#自动重新连接" class="headerlink" title="自动重新连接"></a>自动重新连接</h3><p>在某些特定情况下，服务器和客户端之间的 WebSocket 连接可能会中断，而双方都不知道链接的断开状态。</p>
<p>这就是为什么 Socket.IO 包含一个心跳机制，它会定期检查连接的状态。</p>
<p>当客户端最终断开连接时，它会以指数回退延迟自动重新连接，以免使服务器不堪重负。</p>
<h3 id="数据包缓冲"><a href="#数据包缓冲" class="headerlink" title="数据包缓冲"></a>数据包缓冲</h3><p>当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送</p>
<h3 id="收到后的回调"><a href="#收到后的回调" class="headerlink" title="收到后的回调"></a>收到后的回调</h3><p>Socket.IO 提供了一种方便的方式来发送事件和接收响应    </p>
<p><em>发件人</em></p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response); <span class="hljs-comment">// &quot;got it&quot;</span>
&#125;);</code></pre></div>

<p><em>接收者</em></p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg, callback</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// &quot;world&quot;</span>
  <span class="hljs-title function_">callback</span>(<span class="hljs-string">&quot;got it!&quot;</span>);
&#125;);</code></pre></div>

<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/broadcasting-events/">在服务器端，您可以向所有连接的客户端</a>或<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/">客户端的子集</a>发送事件：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 到所有连接的客户端</span>
io.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);

<span class="hljs-comment">// 致“news”房间中的所有连接客户端</span>
io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;news&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);</code></pre></div>

<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>命名空间允许您在单个共享连接上拆分应用程序的逻辑。例如，如果您想创建一个只有授权用户才能加入的“管理员”频道，这可能很有用。</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// 普通用户</span>
&#125;);

io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// 管理员用户</span>
&#125;);</code></pre></div>

<h2 id="运作原理"><a href="#运作原理" class="headerlink" title="运作原理"></a>运作原理</h2><p>Socket.IO 服务器 (Node.js) 和 Socket.IO 客户端（浏览器, Node.js, or <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/#what-socketio-is">其他编程语言</a>）之间的双向通道尽可能使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket 连接</a>建立，并将使用 HTTP 长轮询作为后备。</p>
<p>Socket.IO 代码库分为两个不同的层：</p>
<ul>
<li>底层通道：我们称之为Engine.IO，Socket.IO内部的引擎</li>
<li>高级 API：Socket.IO 本身</li>
</ul>
<h2 id="Engine-IO"><a href="#Engine-IO" class="headerlink" title="Engine.IO"></a>Engine.IO</h2><p>Engine.IO 负责建立服务器和客户端之间的低级连接。它处理：</p>
<ul>
<li>各种<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/how-it-works/#transports">传输</a>和<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/how-it-works/#upgrade-mechanism">升级机制</a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/how-it-works/#disconnection-detection">断线检测</a></li>
</ul>
<p>源代码可以在这里找到：</p>
<ul>
<li>服务器：<a target="_blank" rel="noopener" href="https://github.com/socketio/engine.io">https://github.com/socketio/engine.io</a></li>
<li>客户端：<a target="_blank" rel="noopener" href="https://github.com/socketio/engine.io-client">https://github.com/socketio/engine.io-client</a></li>
<li>解析器：<a target="_blank" rel="noopener" href="https://github.com/socketio/engine.io-parser">https://github.com/socketio/engine.io-parser</a></li>
<li>协议说明：<a target="_blank" rel="noopener" href="https://github.com/socketio/engine.io-protocol">https://github.com/socketio/engine.io-protocol</a></li>
</ul>
<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>目前有两种实现的传输:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/how-it-works/#http-long-polling">HTTP 长轮询</a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/how-it-works/#websocket">WebSocket</a></li>
</ul>
<h4 id="HTTP-长轮询"><a href="#HTTP-长轮询" class="headerlink" title="HTTP 长轮询"></a>HTTP 长轮询</h4><p>THTTP 长轮询传输（也简称为“轮询”）由连续的 HTTP 请求组成：</p>
<ul>
<li>长时间运行的 <code>GET</code> 请求，用于从服务器接收数据</li>
<li>短时 <code>POST</code> 请求，用于向服务器发送数据</li>
</ul>
<p>由于传输的性质，可能会在同一个 HTTP 请求中连接并发送连续的请求。</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 传输由<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocket 连接</a>组成，它在服务器和客户端之间提供双向和低延迟的通信通道。</p>
<p>由于传输的性质，每个发射都在其自己的 WebSocket 帧中发送（有些发射甚至可能导致两个不同的 WebSocket 帧，更多信息<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/custom-parser/#the-default-parser">在这里</a>).</p>
<h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>在 Engine.IO 连接开始时，服务器发送一些信息：</p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
  <span class="hljs-attr">&quot;sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FSDjX-WRwSA4zTZMALqx&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;upgrades&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;websocket&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;pingInterval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25000</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;pingTimeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20000</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>

<p>复制</p>
<ul>
<li><code>sid</code> 是会话的ID，它必须包含在sid所有后续HTTP请求的查询参数中</li>
<li><code>upgrades</code> 数组包含服务器支持的所有“更好”传输的列表</li>
<li><code>pingInterval</code> 和 <code>pingTimeout</code> 值用于心跳</li>
</ul>
<h3 id="升级机制"><a href="#升级机制" class="headerlink" title="升级机制"></a>升级机制</h3><p>默认情况下，客户端使用 HTTP 长轮询传输建立连接。</p>
<p><strong>为什么呢?</strong></p>
<p>虽然 WebSocket 显然是建立双向通信的最佳方式，但经验表明，由于企业代理、个人防火墙、防病毒软件…</p>
<p>从用户的角度来看，一个不成功的 WebSocket 连接可以转化为等待实时应用程序开始交换数据的至少 10 秒。 这在<strong>感知</strong>上会损害用户体验。</p>
<p>总而言之，Engine.io首先关注可靠性和用户体验，其次关注潜在的 UX 改进和提高服务器性能。</p>
<p>要升级，客户端将：</p>
<ul>
<li>确保其传出缓冲区为空</li>
<li>将当前传输设置为只读模式</li>
<li>尝试与其他传输建立连接</li>
<li>如果成功，关闭第一个传输</li>
</ul>
<p>您可以在浏览器的网络监视器中查看：</p>
<p><img src="https://socket.io/zh-CN/assets/images/network-monitor-2e47dbe233100aa290595f8687a9fcba.png" srcset="/img/loading.gif" lazyload alt="Successful upgrade"></p>
<ol>
<li>握手 (包含会话 ID — 此处, <code>zBjrh...AAAK</code> — 用于后续请求)</li>
<li>发送数据 (HTTP 长轮询)</li>
<li>接收数据 (HTTP 长轮询)</li>
<li>升级 (WebSocket)</li>
<li>接收数据 (HTTP 长轮询, WebSocket连接建立成功后关闭)</li>
</ol>
<h3 id="断线检测"><a href="#断线检测" class="headerlink" title="断线检测"></a>断线检测</h3><p>Engine.IO 连接在以下情况下被视为关闭：</p>
<ul>
<li>一个 HTTP 请求（GET 或 POST）失败（例如，当服务器关闭时）</li>
<li>WebSocket 连接关闭（例如，当用户关闭其浏览器中的选项卡时）</li>
<li><code>socket.disconnect()</code> 在服务器端或客户端调用</li>
</ul>
<p>还有一个心跳机制检查服务器和客户端之间的连接是否仍然正常运行：</p>
<p>在给定的时间间隔（ <code>pingInterval</code>握手中发送的值），服务器发送一个 PING 数据包，客户端有几秒钟（该<code>pingTimeout</code>值）发送一个 PONG 数据包。如果服务器没有收到返回的 PONG 数据包，则认为连接已关闭。反之，如果客户端在 内没有收到 PING 包<code>pingInterval + pingTimeout</code>，则认为连接已关闭。</p>
<h2 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h2><p>Socket.IO 通过 Engine.IO 连接提供了一些附加功能：</p>
<ul>
<li>自动重连</li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-offline-behavior/#buffered-events">数据包缓冲</a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">收到后的回调</a></li>
<li>广播 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/broadcasting-events/">到所有客户端</a> 或 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/">客户端的子集</a>（我们称之为“房间”）</li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/namespaces/">多路复用</a>（我们称之为“命名空间”）</li>
</ul>
<p>源代码可以在这里找到：</p>
<ul>
<li>服务器：<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io">https://github.com/socketio/socket.io</a></li>
<li>客户端：<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io-client">https://github.com/socketio/socket.io-client</a></li>
<li>解析器：<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io-parser">https://github.com/socketio/socket.io-parser</a></li>
<li>协议说明：<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io-protocol">https://github.com/socketio/socket.io-protocol</a></li>
</ul>
<h1 id="服务器安装"><a href="#服务器安装" class="headerlink" title="服务器安装"></a>服务器安装</h1><div class="code-wrapper"><pre><code class="hljs sh">npm install socket.io</code></pre></div>

<p>安装特定版本：</p>
<div class="code-wrapper"><pre><code class="hljs sh">npm install socket.io@version</code></pre></div>

<p>默认情况下，Socket.IO 使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/ws">ws</a>包提供的 WebSocket 服务器。</p>
<h1 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a>服务器初始化</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="只使用Socket"><a href="#只使用Socket" class="headerlink" title="只使用Socket"></a>只使用Socket</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//commonjs</span>
<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Server</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>);

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//esmodule</span>
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<p>您还可以将端口作为第一个参数传递：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(<span class="hljs-number">3000</span>, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>

<p>这隐式启动了一个 Node.js<a target="_blank" rel="noopener" href="https://nodejs.org/docs/latest/api/http.html#http_class_http_server">HTTP 服务器</a>，可以通过 <code>io.httpServer</code>。</p>
<h3 id="使用HTTP服务器"><a href="#使用HTTP服务器" class="headerlink" title="使用HTTP服务器"></a>使用HTTP服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<h3 id="使用HTTPS服务器"><a href="#使用HTTPS服务器" class="headerlink" title="使用HTTPS服务器"></a>使用HTTPS服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;
<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(&#123;
  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/key.pem&quot;</span>),
  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/cert.pem&quot;</span>)
&#125;);

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<p>使用客户端证书身份验证：</p>
<p><em>服务器</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;
<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(&#123;
  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-key.pem&quot;</span>),
  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-cert.pem&quot;</span>),
  <span class="hljs-attr">requestCert</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">ca</span>: [
    <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-cert.pem&quot;</span>)
  ]
&#125;);

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">rawSocket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// if you need the certificate details (it is no longer available once the handshake is completed)</span>
  rawSocket.<span class="hljs-property">peerCertificate</span> = rawSocket.<span class="hljs-property">request</span>.<span class="hljs-property">client</span>.<span class="hljs-title function_">getPeerCertificate</span>();
&#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">conn</span>.<span class="hljs-property">peerCertificate</span>);
  <span class="hljs-comment">// ...</span>
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;
<span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;

<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://example.com&quot;</span>, &#123;
  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-key.pem&quot;</span>),
  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-cert.pem&quot;</span>),
  <span class="hljs-attr">ca</span>: [
    <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-cert.pem&quot;</span>)
  ]
&#125;);</code></pre></div>

<h3 id="使用HTTP-2服务器"><a href="#使用HTTP-2服务器" class="headerlink" title="使用HTTP/2服务器"></a>使用HTTP/2服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;
<span class="hljs-keyword">import</span> &#123; createSecureServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http2&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createSecureServer</span>(&#123;
  <span class="hljs-attr">allowHTTP1</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/key.pem&quot;</span>),
  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/cert.pem&quot;</span>)
&#125;);

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<h3 id="使用-Express"><a href="#使用-Express" class="headerlink" title="使用 Express"></a>使用 Express</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//esmodule</span>
<span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;
<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app);
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//ts</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;
<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app);
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<p><u>在这里使用<code>app.listen(3000)</code>将不起作用，因为它会创建一个新的 HTTP 服务器。</u></p>
<h3 id="使用-Koa"><a href="#使用-Koa" class="headerlink" title="使用 Koa"></a>使用 Koa</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;
<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();
<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app.<span class="hljs-title function_">callback</span>());
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;
<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();
<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app.<span class="hljs-title function_">callback</span>());
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<h3 id="使用-µWebSockets-js"><a href="#使用-µWebSockets-js" class="headerlink" title="使用 µWebSockets.js"></a>使用 µWebSockets.js</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">App</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;uWebSockets.js&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();

io.<span class="hljs-title function_">attachApp</span>(app);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (!token) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;port already in use&quot;</span>);
  &#125;
&#125;);</code></pre></div>

<h3 id="使用-Fastify"><a href="#使用-Fastify" class="headerlink" title="使用 Fastify"></a>使用 Fastify</h3><p>您需要注册<a target="_blank" rel="noopener" href="https://github.com/alemagio/fastify-socket.io"><code>fastify-socket.io</code></a>插件：</p>
<ul>
<li><p>CommonJS</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fastify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fastify&quot;</span>);
<span class="hljs-keyword">const</span> fastifyIO = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fastify-socket.io&quot;</span>);

<span class="hljs-keyword">const</span> server = <span class="hljs-title function_">fastify</span>();
server.<span class="hljs-title function_">register</span>(fastifyIO);

server.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, reply</span>) =&gt;</span> &#123;
  server.<span class="hljs-property">io</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);
&#125;);

server.<span class="hljs-title function_">ready</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-comment">// we need to wait for the server to be ready, else `server.io` is undefined</span>
  server.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;);
&#125;);

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div></li>
<li><p>ES modules</p>
</li>
<li><p>```js<br>import fastify from “fastify”;<br>import fastifyIO from “fastify-socket.io”;</p>
<p>const server = fastify();<br>server.register(fastifyIO);</p>
<p>server.get(“/“, (req, reply) =&gt; {<br>  server.io.emit(“hello”);<br>});</p>
<p>server.ready().then(() =&gt; {<br>  // we need to wait for the server to be ready, else <code>server.io</code> is undefined<br>  server.io.on(“connection”, (socket) =&gt; {</p>
<div class="code-wrapper"><pre><code class="hljs">// ...
</code></pre></div>
<p>  });<br>});</p>
<p>server.listen(3000);</p>
<div class="code-wrapper"><pre><code class="hljs moonscript">
  

- TypeScript

```ts
<span class="hljs-keyword">import</span> fastify <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fastify&quot;</span>;
<span class="hljs-keyword">import</span> fastifyIO <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fastify-socket.io&quot;</span>;

const server = fastify();
server.register(fastifyIO);

server.get(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-params">(req, reply)</span> =&gt;</span> &#123;
  server.<span class="hljs-built_in">io</span>.emit(<span class="hljs-string">&quot;hello&quot;</span>);
&#125;);

server.ready().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
  // we need to wait <span class="hljs-keyword">for</span> the server to be ready, <span class="hljs-keyword">else</span> `server.<span class="hljs-built_in">io</span>` is undefined
  server.<span class="hljs-built_in">io</span>.on(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">(socket)</span> =&gt;</span> &#123;
    // ...
  &#125;);
&#125;);

server.listen(<span class="hljs-number">3000</span>);</code></pre></div></li>
</ul>
<h1 id="服务器实例"><a href="#服务器实例" class="headerlink" title="服务器实例"></a>服务器实例</h1><p>服务器实例（通常<code>io</code>在代码示例中调用）具有一些可能在您的应用程序中使用的属性。</p>
<p>它还继承了<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/namespaces/#main-namespace">主命名空间</a>的所有方法，例如<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#namespaceusefn"><code>namespace.use()</code></a>（参见<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/middlewares/">此处</a>）或 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#namespaceallsockets"><code>namespace.allSockets()</code></a>.</p>
<h2 id="服务器-engine"><a href="#服务器-engine" class="headerlink" title="服务器#engine"></a>服务器#engine</h2><p>对底层 Engine.IO 服务器的引用。</p>
<p>它可用于获取当前连接的客户端数量：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = io.<span class="hljs-property">engine</span>.<span class="hljs-property">clientsCount</span>;
<span class="hljs-comment">// 根据您的用法，可能与主命名空间中的Socket实例计数相似或不相似</span>
<span class="hljs-keyword">const</span> count2 = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">sockets</span>.<span class="hljs-property">size</span>;</code></pre></div>

<p>或者生成自定义会话 ID（<code>sid</code>查询参数）：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> uuid = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;uuid&quot;</span>);

io.<span class="hljs-property">engine</span>.<span class="hljs-property">generateId</span> = <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> uuid.<span class="hljs-title function_">v4</span>(); <span class="hljs-comment">// 必须在所有socket.io服务器上都是唯一的</span>
&#125;</code></pre></div>

<p>从<code>socket.io@4.1.0</code>开始，Engine.IO 服务器发出三个特殊事件：</p>
<ul>
<li><code>initial_headers</code>: 将在编写会话的第一个 HTTP 请求（握手）的响应标头之前发出，允许您自定义它们。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;initial_headers&quot;</span>, <span class="hljs-function">(<span class="hljs-params">headers, req</span>) =&gt;</span> &#123;
  headers[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-string">&quot;123&quot;</span>;
  headers[<span class="hljs-string">&quot;set-cookie&quot;</span>] = <span class="hljs-string">&quot;mycookie=456&quot;</span>;
&#125;);</code></pre></div>

<ul>
<li><code>headers</code>: 将在编写会话的每个 HTTP 请求的响应头之前发出（包括 WebSocket 升级），允许您自定义它们。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;headers&quot;</span>, <span class="hljs-function">(<span class="hljs-params">headers, req</span>) =&gt;</span> &#123;
  headers[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-string">&quot;789&quot;</span>;
&#125;);</code></pre></div>

<ul>
<li><code>connection_error</code>: 当连接异常关闭时发出</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">req</span>);      <span class="hljs-comment">// the request object</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">code</span>);     <span class="hljs-comment">// the error code, for example 1</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>);  <span class="hljs-comment">// the error message, for example &quot;Session ID unknown&quot;</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">context</span>);  <span class="hljs-comment">// some additional error context</span>
&#125;);</code></pre></div>

<p>以下是可能的错误代码列表：</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Message</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>“Transport unknown”</td>
</tr>
<tr>
<td>1</td>
<td>“Session ID unknown”</td>
</tr>
<tr>
<td>2</td>
<td>“Bad handshake method”</td>
</tr>
<tr>
<td>3</td>
<td>“Bad request”</td>
</tr>
<tr>
<td>4</td>
<td>“Forbidden”</td>
</tr>
<tr>
<td>5</td>
<td>“Unsupported protocol version”</td>
</tr>
</tbody></table>
<h3 id="socketsJoin"><a href="#socketsJoin" class="headerlink" title="socketsJoin"></a><code>socketsJoin</code></h3><p>此方法使匹配的 Socket 实例加入指定的房间：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances join the &quot;room1&quot; room</span>
io.<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room1&quot;</span>);

<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room join the &quot;room2&quot; and &quot;room3&quot; rooms</span>
io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsJoin</span>([<span class="hljs-string">&quot;room2&quot;</span>, <span class="hljs-string">&quot;room3&quot;</span>]);

<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace join the &quot;room2&quot; room</span>
io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room2&quot;</span>);

<span class="hljs-comment">// this also works with a single socket ID</span>
io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room1&quot;</span>);</code></pre></div>

<h3 id="socketsLeave"><a href="#socketsLeave" class="headerlink" title="socketsLeave"></a><code>socketsLeave</code></h3><p>该方法使匹配的 Socket 实例离开指定房间：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances leave the &quot;room1&quot; room</span>
io.<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room1&quot;</span>);

<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room leave the &quot;room2&quot; and &quot;room3&quot; rooms</span>
io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsLeave</span>([<span class="hljs-string">&quot;room2&quot;</span>, <span class="hljs-string">&quot;room3&quot;</span>]);

<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace leave the &quot;room2&quot; room</span>
io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room2&quot;</span>);

<span class="hljs-comment">// this also works with a single socket ID</span>
io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room1&quot;</span>);</code></pre></div>

<h3 id="disconnectSockets"><a href="#disconnectSockets" class="headerlink" title="disconnectSockets"></a><code>disconnectSockets</code></h3><p>此方法使匹配的 Socket 实例断开连接：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances disconnect</span>
io.<span class="hljs-title function_">disconnectSockets</span>();

<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room disconnect (and discard the low-level connection)</span>
io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">disconnectSockets</span>(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace disconnect</span>
io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">disconnectSockets</span>();

<span class="hljs-comment">// this also works with a single socket ID</span>
io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">disconnectSockets</span>();</code></pre></div>

<h3 id="fetchSockets"><a href="#fetchSockets" class="headerlink" title="fetchSockets"></a><code>fetchSockets</code></h3><p>此方法返回匹配的 Socket 实例：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// return all Socket instances of the main namespace</span>
<span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();

<span class="hljs-comment">// return all Socket instances in the &quot;room1&quot; room of the main namespace</span>
<span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">fetchSockets</span>();

<span class="hljs-comment">// return all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace</span>
<span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">fetchSockets</span>();

<span class="hljs-comment">// this also works with a single socket ID</span>
<span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">fetchSockets</span>();</code></pre></div>

<p>上例中的<code>sockets</code>变量是一个对象数组，暴露了通常的 Socket 类的一个子集：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> socket <span class="hljs-keyword">of</span> sockets) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">handshake</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">data</span>);
  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-comment">/* ... */</span>);
  socket.<span class="hljs-title function_">join</span>(<span class="hljs-comment">/* ... */</span>);
  socket.<span class="hljs-title function_">leave</span>(<span class="hljs-comment">/* ... */</span>);
  socket.<span class="hljs-title function_">disconnect</span>(<span class="hljs-comment">/* ... */</span>);
&#125;</code></pre></div>

<p><code>data</code>属性是一个任意对象，可用于在 Socket.IO 服务器之间共享信息：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>
io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-property">data</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;alice&quot;</span>;
&#125;);

<span class="hljs-comment">// server B</span>
<span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sockets[<span class="hljs-number">0</span>].<span class="hljs-property">data</span>.<span class="hljs-property">username</span>); <span class="hljs-comment">// &quot;alice&quot;</span></code></pre></div>

<h3 id="serverSideEmit"><a href="#serverSideEmit" class="headerlink" title="serverSideEmit"></a><code>serverSideEmit</code></h3><p>此方法允许在<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">多服务器设置</a>中向集群的其他 Socket.IO 服务器发出事件。</p>
<p>语法：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div>

<p>在接收方：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// prints &quot;world&quot;</span>
&#125;);</code></pre></div>

<p>也支持确认：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>
io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, responses</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(responses[<span class="hljs-number">0</span>]); <span class="hljs-comment">// prints &quot;pong&quot;</span>
&#125;);

<span class="hljs-comment">// server B</span>
io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;
  <span class="hljs-title function_">cb</span>(<span class="hljs-string">&quot;pong&quot;</span>);
&#125;);</code></pre></div>

<p>笔记：</p>
<ul>
<li><code>connection</code>，<code>connect</code> 和 <code>new_namespace</code> 字符串是保留的，不能在您的应用程序中使用。</li>
<li>您可以发送任意数量的参数，但目前不支持二进制结构（参数数组将被<code>JSON.stringify</code>-ed）</li>
</ul>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-string">&quot;4&quot;</span> &#125;);</code></pre></div>

<ul>
<li>如果其他 Socket.IO 服务器在给定延迟后没有响应，则调用确认回调可能会出错</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, responses</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (err) &#123;
    <span class="hljs-comment">// at least one Socket.IO server has not responded</span>
    <span class="hljs-comment">// the &#x27;responses&#x27; array contains all the responses already received though</span>
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// success! the &#x27;responses&#x27; array contains one object per other Socket.IO server in the cluster</span>
  &#125;
&#125;);</code></pre></div>

<h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><p>Server 实例发出一个事件（好吧，从技术上讲是两个，但<code>connect</code>它是<code>connection</code>的别名）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-instance/#connection"><code>connection</code></a></li>
</ul>
<h3 id="connection"><a href="#connection" class="headerlink" title="connection"></a><code>connection</code></h3><p>此事件在新连接时触发。第一个参数是一个<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/">Socket实例</a>.</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>

<h1 id="Socket-实例（服务器端）"><a href="#Socket-实例（服务器端）" class="headerlink" title="Socket 实例（服务器端）"></a>Socket 实例（服务器端）</h1><p><code>Socket</code>是与客户端交互的基础类。它继承了 Node.js<a target="_blank" rel="noopener" href="https://nodejs.org/api/events.html#class-eventemitter">EventEmitter</a>的所有方法，例如<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#socketemiteventname-args">emit</a>, <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#socketoneventname-callback">on</a>, <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#socketonceeventname-listener">once</a> 或 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#socketremovelistenereventname-listener">removeListener</a>.</p>
<p><img src="https://socket.io/zh-CN/images/bidirectional-communication-socket.png" srcset="/img/loading.gif" lazyload alt="Bidirectional communication between server and client"></p>
<p>除了：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#basic-emit">发出</a> 和 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/">监听</a> 事件</li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients-except-the-sender">广播事件</a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/#joining-and-leaving">加入和离开房间</a></li>
</ul>
<p>Socket 实例有一些可能在您的应用程序中使用的属性：</p>
<h2 id="Socket-id"><a href="#Socket-id" class="headerlink" title="Socket#id"></a>Socket#id</h2><p>每个新连接都分配有一个随机的 20 个字符的标识符。</p>
<p>此标识符与客户端的值同步。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>
io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// ojIckSD2jqNzOqIrAGzL</span>
&#125;);

<span class="hljs-comment">// client-side</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// ojIckSD2jqNzOqIrAGzL</span>
&#125;);</code></pre></div>

<p>创建后，Socket 会加入由其自己的 id 标识的房间，这意味着您可以将其用于私人消息传递：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;private message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">anotherSocketId, msg</span>) =&gt;</span> &#123;
    socket.<span class="hljs-title function_">to</span>(anotherSocketId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;private message&quot;</span>, socket.<span class="hljs-property">id</span>, msg);
  &#125;);
&#125;);</code></pre></div>

<p>注意：您不能覆盖此标识符，因为它在 Socket.IO 代码库的多个部分中使用。</p>
<h2 id="Socket-handshake"><a href="#Socket-handshake" class="headerlink" title="Socket#handshake"></a>Socket#handshake</h2><p>此对象包含有关在 Socket.IO 会话开始时发生的握手的一些详细信息。</p>
<div class="code-wrapper"><pre><code class="hljs text">&#123;
  headers: /* the headers of the initial request */
  query: /* the query params of the initial request */
  auth: /* the authentication payload */
  time: /* the date of creation (as string) */
  issued: /* the date of creation (unix timestamp) */
  url: /* the request URL string */
  address: /* the ip of the client */
  xdomain: /* whether the connection is cross-domain */
  secure: /* whether the connection is secure */
&#125;</code></pre></div>

<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
  <span class="hljs-attr">&quot;headers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;user-agent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxx&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;accept&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*/*&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;example.com&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;connection&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;close&quot;</span>
  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;EIO&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;transport&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;polling&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;t&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NNjNltH&quot;</span>
  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123&quot;</span>
  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;issued&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1606005226969</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/socket.io/?EIO=4&amp;transport=polling&amp;t=NNjNltH&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;::ffff:1.2.3.4&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;xdomain&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;secure&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>

<h2 id="Socket-rooms"><a href="#Socket-rooms" class="headerlink" title="Socket#rooms"></a>Socket#rooms</h2><p>这是对 Socket 当前所在<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/">房间</a>的引用。</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// Set &#123; &lt;socket.id&gt; &#125;</span>
  socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;room1&quot;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// Set &#123; &lt;socket.id&gt;, &quot;room1&quot; &#125;</span>
&#125;);</code></pre></div>

<h2 id="Socket-data"><a href="#Socket-data" class="headerlink" title="Socket#data"></a>Socket#data</h2><p>可以与<code>fetchSockets()</code>实用程序方法结合使用的任意对象：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>
io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-property">data</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;alice&quot;</span>;
&#125;);

<span class="hljs-comment">// server B</span>
<span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sockets[<span class="hljs-number">0</span>].<span class="hljs-property">data</span>.<span class="hljs-property">username</span>); <span class="hljs-comment">// &quot;alice&quot;</span></code></pre></div>

<h2 id="Socket-conn"><a href="#Socket-conn" class="headerlink" title="Socket#conn"></a>Socket#conn</h2><p>对底层 Engine.IO 套接字的引用（参见<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/how-it-works/">此处</a>）。</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;initial transport&quot;</span>, socket.<span class="hljs-property">conn</span>.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// prints &quot;polling&quot;</span>

  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;upgrade&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;upgraded transport&quot;</span>, socket.<span class="hljs-property">conn</span>.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// prints &quot;websocket&quot;</span>
  &#125;);

  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packet&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// called for each packet received</span>
  &#125;);

  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packetCreate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// called for each packet sent</span>
  &#125;);

  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;drain&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// called when the write buffer is drained</span>
  &#125;);

  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// called when the underlying connection is closed</span>
  &#125;);
&#125;);</code></pre></div>

<h2 id="Additional-attributes"><a href="#Additional-attributes" class="headerlink" title="Additional attributes"></a>Additional attributes</h2><p>只要您不覆盖任何现有属性，您就可以将任何属性附加到 Socket 实例并在以后使用它：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// in a middleware</span>
io.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (socket, next) =&gt; &#123;
  <span class="hljs-keyword">try</span> &#123;
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(socket);
    socket.<span class="hljs-property">user</span> = user;
  &#125; <span class="hljs-keyword">catch</span> (e) &#123;
    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unknown user&quot;</span>));
  &#125;
&#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">user</span>);

  <span class="hljs-comment">// in a listener</span>
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;set username&quot;</span>, <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> &#123;
    socket.<span class="hljs-property">username</span> = username;
  &#125;);
&#125;);
</code></pre></div>

<h2 id="Socket-middlewares"><a href="#Socket-middlewares" class="headerlink" title="Socket middlewares"></a>Socket middlewares</h2><p>这些中间件看起来很像通常的<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/middlewares/">中间价</a>，除了它们是为每个传入的数据包调用的：</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">[event, ...args], next</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// do something with the packet (logging, authorization, rate limiting...)</span>
  <span class="hljs-comment">// do not forget to call next() at the end</span>
  <span class="hljs-title function_">next</span>();
&#125;);</code></pre></div>

<p>复制</p>
<p><code>next</code>也可以使用错误对象调用该方法。在这种情况下，事件将不会到达注册的事件处理程序，而<code>error</code>是会发出一个事件：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">[event, ...args], next</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUnauthorized</span>(event)) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unauthorized event&quot;</span>));
    &#125;
    <span class="hljs-title function_">next</span>();
  &#125;);

  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (err &amp;&amp; err.<span class="hljs-property">message</span> === <span class="hljs-string">&quot;unauthorized event&quot;</span>) &#123;
      socket.<span class="hljs-title function_">disconnect</span>();
    &#125;
  &#125;);
&#125;);</code></pre></div>

<p>复制</p>
<p>注意：此功能仅存在于服务器端。对于客户端，您可能对<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#catch-all-listeners">catch-all listeners</a>感兴趣。</p>
<h2 id="Events-1"><a href="#Events-1" class="headerlink" title="Events"></a>Events<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#events"></a></h2><p>在服务器端，Socket 实例发出两个特殊事件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnect"><code>disconnect</code></a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnecting"><code>disconnecting</code></a></li>
</ul>
<h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a><code>disconnect</code><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnect"></a></h3><p>此事件由 Socket 实例在断开连接时触发。</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// ...</span>
  &#125;);
&#125;);</code></pre></div>

<p>复制</p>
<p>以下是可能的原因列表：</p>
<table>
<thead>
<tr>
<th>Reason</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>server namespace disconnect</code></td>
<td>socket被<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#socketdisconnectclose">socket.disconnect</a>强行断开</td>
</tr>
<tr>
<td><code>client namespace disconnect</code></td>
<td>客户端使用<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-api/#socketdisconnect">socket.disconnect()</a>手动断开socket</td>
</tr>
<tr>
<td><code>server shutting down</code></td>
<td>服务器正在关闭</td>
</tr>
<tr>
<td><code>ping timeout</code></td>
<td><code>pingTimeout</code> 客户端在延迟中没有发送 PONG 数据包</td>
</tr>
<tr>
<td><code>transport close</code></td>
<td>连接已关闭（例如：用户失去连接，或网络从 WiFi 更改为 4G）</td>
</tr>
<tr>
<td><code>transport error</code></td>
<td>连接遇到错误</td>
</tr>
</tbody></table>
<h3 id="disconnecting"><a href="#disconnecting" class="headerlink" title="disconnecting"></a><code>disconnecting</code><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnecting"></a></h3><p>当<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#socketrooms">Socket#rooms</a>集不为空时，此事件类似于<code>disconnect</code>但更早触发。</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnecting&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> room <span class="hljs-keyword">of</span> socket.<span class="hljs-property">rooms</span>) &#123;
      <span class="hljs-keyword">if</span> (room !== socket.<span class="hljs-property">id</span>) &#123;
        socket.<span class="hljs-title function_">to</span>(room).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;user has left&quot;</span>, socket.<span class="hljs-property">id</span>);
      &#125;
    &#125;
  &#125;);
&#125;);</code></pre></div>

<p>注意：这些事件以及<code>connect</code>, <code>connect_error</code>, <code>newListener</code> 和 <code>removeListener</code>是不应在您的应用程序中使用的特殊事件:</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD, will throw an error</span>
socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;disconnect&quot;</span>);</code></pre></div>

<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件函数是为每个传入连接执行的函数。</p>
<p>中间件函数可用于：</p>
<ul>
<li>logging</li>
<li>authentication / authorization</li>
<li>rate limiting</li>
</ul>
<p>Note: this function will be executed only once per connection (even if the connection consists in multiple HTTP requests).</p>
<h2 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h2><p>中间件函数可以访问<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/">Socket 实例</a>和下一个注册的中间件函数。</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValid</span>(socket.<span class="hljs-property">request</span>)) &#123;
    <span class="hljs-title function_">next</span>();
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;invalid&quot;</span>));
  &#125;
&#125;);</code></pre></div>

<p>您可以注册几个中间件函数，它们将按顺序执行：</p>
<div class="code-wrapper"><pre><code class="hljs moonscript"><span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;
  <span class="hljs-built_in">next</span>();
&#125;);

<span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;
  <span class="hljs-built_in">next</span>(new Error(<span class="hljs-string">&quot;thou shall not pass&quot;</span>));//<span class="hljs-built_in">error</span>可以作为参数传递到下一层，其他不可以	
&#125;);

<span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;
  // <span class="hljs-keyword">not</span> executed, since the previous middleware has returned an <span class="hljs-built_in">error</span>
  <span class="hljs-built_in">next</span>();
&#125;);</code></pre></div>

<p>请确保在任何情况下都调用<code>next（）</code>。 否则，连接将一直挂起，直到在给定超时后关闭。</p>
<p><strong>重要提示</strong>：执行中间件时，Socket 实例实际上并未连接，这意味着<code>disconnect</code>如果连接最终失败，则不会发出任何事件。</p>
<p>例如，如果客户端手动关闭连接：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>
io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// next is called after the client disconnection</span>
    <span class="hljs-title function_">next</span>();
  &#125;, <span class="hljs-number">1000</span>);

  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// not triggered</span>
  &#125;);
&#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// not triggered</span>
&#125;);

<span class="hljs-comment">// client-side</span>
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
  socket.<span class="hljs-title function_">disconnect</span>();
&#125;, <span class="hljs-number">500</span>);</code></pre></div>

<h2 id="发送凭据"><a href="#发送凭据" class="headerlink" title="发送凭据"></a>发送凭据</h2><p><code>auth</code>客户端可以使用以下选项发送凭据：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// plain object</span>
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;
  <span class="hljs-attr">auth</span>: &#123;
    <span class="hljs-attr">token</span>: <span class="hljs-string">&quot;abc&quot;</span>
  &#125;
&#125;);

<span class="hljs-comment">// or with a function</span>
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;
  <span class="hljs-attr">auth</span>: <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;
    <span class="hljs-title function_">cb</span>(&#123;
      <span class="hljs-attr">token</span>: <span class="hljs-string">&quot;abc&quot;</span>
    &#125;);
  &#125;
&#125;);</code></pre></div>

<p>可以在服务器端的<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#sockethandshake">握手</a>对象中访问这些凭据：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> token = socket.<span class="hljs-property">handshake</span>.<span class="hljs-property">auth</span>.<span class="hljs-property">token</span>;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>

<h2 id="处理中间件错误"><a href="#处理中间件错误" class="headerlink" title="处理中间件错误"></a>处理中间件错误</h2><p>如果<code>next</code>使用 Error 对象调用该方法，则连接将被拒绝并且客户端将收到一个<code>connect_error</code>事件。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// client-side</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// prints the message associated with the error</span>
&#125;);</code></pre></div>

<p>您可以将其他详细信息附加到错误对象：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>
io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;not authorized&quot;</span>);
  err.<span class="hljs-property">data</span> = &#123; <span class="hljs-attr">content</span>: <span class="hljs-string">&quot;Please retry later&quot;</span> &#125;; <span class="hljs-comment">// additional details</span>
  <span class="hljs-title function_">next</span>(err);
&#125;);

<span class="hljs-comment">// client-side</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>); <span class="hljs-comment">// true</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// not authorized</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">data</span>); <span class="hljs-comment">// &#123; content: &quot;Please retry later&quot; &#125;</span>
&#125;);</code></pre></div>

<h2 id="与Express中间件的兼容性"><a href="#与Express中间件的兼容性" class="headerlink" title="与Express中间件的兼容性"></a>与Express中间件的兼容性</h2><p>大多数现有的<a target="_blank" rel="noopener" href="http://expressjs.com/en/resources/middleware.html">Express 中间件</a>模块应该与 Socket.IO 兼容，您只需要一个小包装函数来使方法签名匹配：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = middleware =&gt; <span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> <span class="hljs-title function_">middleware</span>(socket.<span class="hljs-property">request</span>, &#123;&#125;, next);</code></pre></div>

<p>复制</p>
<p>结束请求-响应周期并且不调用的中间件函数<code>next()</code>将不起作用。</p>
<p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/express-session">express-session</a>示例：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);

io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(<span class="hljs-title function_">session</span>(&#123; <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;cats&quot;</span> &#125;)));

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> session = socket.<span class="hljs-property">request</span>.<span class="hljs-property">session</span>;
&#125;);</code></pre></div>

<p><a target="_blank" rel="noopener" href="http://www.passportjs.org/">Passport</a>示例：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);
<span class="hljs-keyword">const</span> passport = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;passport&quot;</span>);

io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(<span class="hljs-title function_">session</span>(&#123; <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;cats&quot;</span> &#125;)));
io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(passport.<span class="hljs-title function_">initialize</span>()));
io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(passport.<span class="hljs-title function_">session</span>()));

io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">request</span>.<span class="hljs-property">user</span>) &#123;
    <span class="hljs-title function_">next</span>();
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unauthorized&quot;</span>))
  &#125;
&#125;);</code></pre></div>

<p>可以在<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io/tree/master/examples/passport-example">此处</a>找到 Passport 的完整示例。</p>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>您将在下面找到在反向代理解决方案后面部署 Socket.IO 服务器所需的配置，例如：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nginx">NginX</a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#apache-httpd">Apache HTTPD</a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nodejs-http-proxy">Node.js <code>http-proxy</code></a></li>
</ul>
<p>在多服务器设置中，请查看<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">此处</a>的文档。</p>
<h2 id="NginX"><a href="#NginX" class="headerlink" title="NginX"></a>NginX</h2><p><code>/etc/nginx/nginx.conf</code>内容：</p>
<div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;
  <span class="hljs-section">server</span> &#123;
    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
    <span class="hljs-attribute">server_name</span> example.com;

    <span class="hljs-section">location</span> / &#123;
      <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
      <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;

      <span class="hljs-attribute">proxy_pass</span> http://localhost:3000;

      <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;
      <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;
      <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;
    &#125;
  &#125;
&#125;</code></pre></div>

<p>有关的：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass">proxy_pass 稳定</a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#nginx-configuration">多服务器设置中的配置</a></li>
</ul>
<p>如果您只想转发 Socket.IO 请求（例如当 NginX 处理静态内容时）：</p>
<div class="code-wrapper"><pre><code class="hljs text">http &#123;
  server &#123;
    listen 80;
    root /var/www/html;

    location /socket.io/ &#123;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $host;

      proxy_pass http://localhost:3000;

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection &quot;upgrade&quot;;
    &#125;
  &#125;
&#125;</code></pre></div>

<p>或使用自定义<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-options/#path">路径</a>:</p>
<div class="code-wrapper"><pre><code class="hljs text">http &#123;
  server &#123;
    listen 80;
    root /var/www/html;

    location /my-custom-path/ &#123;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Host $host;

      proxy_pass http://localhost:3000;

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection &quot;upgrade&quot;;
    &#125;
  &#125;
&#125;</code></pre></div>

<p>在这种情况下，必须相应地配置服务器和客户端：</p>
<p><em>服务器</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123;
  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/my-custom-path/&quot;</span>
&#125;);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;

<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;
  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/my-custom-path/&quot;</span>
&#125;);</code></pre></div>

<h2 id="Apache-HTTPD"><a href="#Apache-HTTPD" class="headerlink" title="Apache HTTPD"></a>Apache HTTPD</h2><p><code>/usr/local/apache2/conf/httpd.conf</code>内容：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Listen</span> <span class="hljs-number">80</span>

<span class="hljs-attribute">ServerName</span> example.com

<span class="hljs-attribute">LoadModule</span> mpm_event_module             modules/mod_mpm_event.so

<span class="hljs-attribute">LoadModule</span> authn_file_module            modules/mod_authn_file.so
<span class="hljs-attribute">LoadModule</span> authn_core_module            modules/mod_authn_core.so
<span class="hljs-attribute">LoadModule</span> authz_host_module            modules/mod_authz_host.so
<span class="hljs-attribute">LoadModule</span> authz_groupfile_module       modules/mod_authz_groupfile.so
<span class="hljs-attribute">LoadModule</span> authz_user_module            modules/mod_authz_user.so
<span class="hljs-attribute">LoadModule</span> authz_core_module            modules/mod_authz_core.so

<span class="hljs-attribute">LoadModule</span> headers_module               modules/mod_headers.so
<span class="hljs-attribute">LoadModule</span> lbmethod_byrequests_module   modules/mod_lbmethod_byrequests.so
<span class="hljs-attribute">LoadModule</span> proxy_module                 modules/mod_proxy.so
<span class="hljs-attribute">LoadModule</span> proxy_balancer_module        modules/mod_proxy_balancer.so
<span class="hljs-attribute">LoadModule</span> proxy_http_module            modules/mod_proxy_http.so
<span class="hljs-attribute">LoadModule</span> proxy_wstunnel_module        modules/mod_proxy_wstunnel.so
<span class="hljs-attribute">LoadModule</span> rewrite_module               modules/mod_rewrite.so
<span class="hljs-attribute">LoadModule</span> slotmem_shm_module           modules/mod_slotmem_shm.so
<span class="hljs-attribute">LoadModule</span> unixd_module                 modules/mod_unixd.so

<span class="hljs-attribute">User</span> daemon
<span class="hljs-attribute">Group</span> daemon

<span class="hljs-attribute">ProxyPass</span> / http://localhost:<span class="hljs-number">3000</span>/
<span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">on</span>
<span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> websocket<span class="hljs-meta"> [NC]</span>
<span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Connection&#125;</span> upgrade<span class="hljs-meta"> [NC]</span>
<span class="hljs-attribute">RewriteRule</span> ^/?(.*) <span class="hljs-string">&quot;ws://localhost:3000/$1&quot;</span><span class="hljs-meta"> [P,L]</span>

<span class="hljs-attribute">ProxyTimeout</span> <span class="hljs-number">3</span></code></pre></div>

<p>有关的：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://httpd.apache.org/docs/2.4/en/mod/mod_proxy_wstunnel.html">mod_proxy_wstunnel 文档</a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration">多服务器设置中的配置</a></li>
</ul>
<h2 id="Node-js-http-proxy"><a href="#Node-js-http-proxy" class="headerlink" title="Node.js http-proxy"></a>Node.js <code>http-proxy</code><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nodejs-http-proxy"></a></h2><p>安装： <code>npm i http-proxy</code></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> httpProxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http-proxy&quot;</span>);

httpProxy
  .<span class="hljs-title function_">createProxyServer</span>(&#123;
    <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,
    <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,
  &#125;)
  .<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>);</code></pre></div>

<p>复制</p>
<p><a target="_blank" rel="noopener" href="https://github.com/http-party/node-http-proxy#readme">Documentation</a></p>
<h2 id="Caddy-2"><a href="#Caddy-2" class="headerlink" title="Caddy 2"></a>Caddy 2</h2><p><a target="_blank" rel="noopener" href="https://caddyserver.com/v2">Caddy 2</a>中<code>Caddyfile</code>的内容</p>
<div class="code-wrapper"><pre><code class="hljs text">example.com &#123;
  rewrite /path /path/
  handle /path/* &#123;
    uri strip_prefix /path
    rewrite * /socket.io&#123;path&#125;
    reverse_proxy localhost:3000 &#123;
      header_up Host &#123;host&#125;
      header_up X-Real-IP &#123;remote&#125;
    &#125;
  &#125;
&#125;</code></pre></div>

<p>有关的：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://caddy.community/t/i-cant-get-socket-io-proxy-to-work-on-v2/8703/2">解决方案论坛帖子</a></li>
<li><a target="_blank" rel="noopener" href="https://caddyserver.com/docs/caddyfile/directives">Caddyfile 指令</a></li>
</ul>
<h1 id="使用多个节点"><a href="#使用多个节点" class="headerlink" title="使用多个节点"></a>使用多个节点</h1><p>部署多个 Socket.IO 服务器时，需要注意两件事：</p>
<ul>
<li>如果启用了 HTTP 长轮询（这是默认设置），则启用粘性会话：见<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#enabling-sticky-session">下文</a></li>
<li>使用兼容的适配器，请参见<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/adapter/">此处</a></li>
</ul>
<h2 id="粘性负载平衡"><a href="#粘性负载平衡" class="headerlink" title="粘性负载平衡"></a>粘性负载平衡</h2><p>如果您计划在不同的进程或机器之间分配连接负载，则必须确保与特定会话 ID 关联的所有请求都到达发起它们的进程。</p>
<h3 id="为什么需要粘性会话"><a href="#为什么需要粘性会话" class="headerlink" title="为什么需要粘性会话"></a>为什么需要粘性会话</h3><p>这是因为 HTTP 长轮询传输在 Socket.IO 会话的生命周期内发送多个 HTTP 请求。</p>
<p>事实上，Socket.IO 在技术上可以在没有粘性会话的情况下工作，具有以下同步（虚线）：</p>
<p><img src="https://socket.io/zh-CN/assets/images/mutiple-nodes-no-sticky-babd7860f217e09eefc2db73e5012f91.png" srcset="/img/loading.gif" lazyload alt="Using multiple nodes without sticky sessions"></p>
<p>虽然显然可以实现，但我们认为 Socket.IO 服务器之间的这种同步过程会对您的应用程序造成很大的性能影响。</p>
<p>评论：</p>
<ul>
<li>如果不启用粘性会话，由于“会话 ID 未知”，您将遇到 HTTP 400 错误</li>
<li>WebSocket 传输没有这个限制，因为它依赖于整个会话的单个 TCP 连接。这意味着如果您禁用 HTTP 长轮询传输，您将不需要粘性会话：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://io.yourhost.com&quot;</span>, &#123;
  <span class="hljs-comment">// WARNING: in that case, there is no fallback to long-polling</span>
  <span class="hljs-attr">transports</span>: [ <span class="hljs-string">&quot;websocket&quot;</span> ] <span class="hljs-comment">// or [ &quot;websocket&quot;, &quot;polling&quot; ] (the order matters)</span>
&#125;);</code></pre></div>

<p>文档：<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-options/#transports"><code>transports</code></a></p>
<h3 id="启用粘性会话的方式"><a href="#启用粘性会话的方式" class="headerlink" title="启用粘性会话的方式"></a>启用粘性会话的方式</h3><p>要实现粘性会话，主要有两种解决方案：</p>
<ul>
<li>基于 cookie 路由客户端（推荐解决方案）</li>
<li>根据客户端的原始地址路由客户端</li>
</ul>
<p>您将在下面找到一些常见负载平衡解决方案的示例：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#nginx-configuration">NginX</a> (基于IP)</li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration">Apache HTTPD</a> (基于cookie)</li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#haproxy-configuration">HAProxy</a> (基于cookie)</li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#traefik">Traefik</a> (基于cookie)</li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#using-nodejs-cluster">Node.js <code>cluster</code> module</a></li>
</ul>
<p><strong>重要提示</strong>：如果您处于 CORS 情况（前端域与服务器域不同）并且会话亲和性是通过 cookie 实现的，则需要允许凭据：</p>
<p><em>服务器</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>)(httpServer, &#123;
  <span class="hljs-attr">cors</span>: &#123;
    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://front-domain.com&quot;</span>,
    <span class="hljs-attr">methods</span>: [<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>],
    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>
  &#125;
&#125;);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io-client&quot;</span>);
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>, &#123;
  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>
&#125;);</code></pre></div>

<p>没有它，浏览器将不会发送 cookie，您将遇到 HTTP 400“会话 ID 未知”响应。更多信息<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">在这里</a>.</p>
<h3 id="NginX-配置"><a href="#NginX-配置" class="headerlink" title="NginX 配置"></a>NginX 配置</h3><p>在文件的<code>http &#123; &#125;</code>部分中<code>nginx.conf</code>，您可以声明一个<code>upstream</code>包含要平衡负载的 Socket.IO 进程列表的部分：</p>
<div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;
  <span class="hljs-section">server</span> &#123;
    <span class="hljs-attribute">listen</span> <span class="hljs-number">3000</span>;
    <span class="hljs-attribute">server_name</span> io.yourhost.com;

    <span class="hljs-section">location</span> / &#123;
      <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
      <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;

      <span class="hljs-attribute">proxy_pass</span> http://nodes;

      <span class="hljs-comment"># enable WebSockets</span>
      <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;
      <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;
      <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;
    &#125;
  &#125;

  <span class="hljs-section">upstream</span> nodes &#123;
    <span class="hljs-comment"># enable sticky session with either &quot;hash&quot; (uses the complete IP address)</span>
    <span class="hljs-attribute">hash</span> <span class="hljs-variable">$remote_addr</span> consistent;
    <span class="hljs-comment"># or &quot;ip_hash&quot; (uses the first three octets of the client IPv4 address, or the entire IPv6 address)</span>
    <span class="hljs-comment"># ip_hash;</span>
    <span class="hljs-comment"># or &quot;sticky&quot; (needs commercial subscription)</span>
    <span class="hljs-comment"># sticky cookie srv_id expires=1h domain=.example.com path=/;</span>

    <span class="hljs-attribute">server</span> app01:<span class="hljs-number">3000</span>;
    <span class="hljs-attribute">server</span> app02:<span class="hljs-number">3000</span>;
    <span class="hljs-attribute">server</span> app03:<span class="hljs-number">3000</span>;
  &#125;
&#125;</code></pre></div>

<p>请注意<code>hash</code>指示连接将是粘性的说明。</p>
<p>确保您还在<code>worker_processes</code>最顶层配置以指示 NginX 应该使用多少工作人员。您可能还想研究调整块<code>worker_connections</code>内的设置<code>events &#123; &#125;</code>。</p>
<h3 id="Apache-HTTPD-配置"><a href="#Apache-HTTPD-配置" class="headerlink" title="Apache HTTPD 配置"></a>Apache HTTPD 配置<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration"></a></h3><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Header</span> add Set-Cookie <span class="hljs-string">&quot;SERVERID=sticky.%&#123;BALANCER_WORKER_ROUTE&#125;e; path=/&quot;</span> env=BALANCER_ROUTE_CHANGED

<span class="hljs-section">&lt;Proxy <span class="hljs-string">&quot;balancer://nodes_polling&quot;</span>&gt;</span>
    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app01:3000&quot;</span> route=app01
    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app02:3000&quot;</span> route=app02
    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app03:3000&quot;</span> route=app03
    <span class="hljs-attribute">ProxySet</span> stickysession=SERVERID
<span class="hljs-section">&lt;/Proxy&gt;</span>

<span class="hljs-section">&lt;Proxy <span class="hljs-string">&quot;balancer://nodes_ws&quot;</span>&gt;</span>
    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app01:3000&quot;</span> route=app01
    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app02:3000&quot;</span> route=app02
    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app03:3000&quot;</span> route=app03
    <span class="hljs-attribute">ProxySet</span> stickysession=SERVERID
<span class="hljs-section">&lt;/Proxy&gt;</span>

<span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">On</span>
<span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> =websocket<span class="hljs-meta"> [NC]</span>
<span class="hljs-attribute">RewriteRule</span> /(.*) balancer://nodes_ws/$<span class="hljs-number">1</span><span class="hljs-meta"> [P,L]</span>
<span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> !=websocket<span class="hljs-meta"> [NC]</span>
<span class="hljs-attribute">RewriteRule</span> /(.*) balancer://nodes_polling/$<span class="hljs-number">1</span><span class="hljs-meta"> [P,L]</span>

<span class="hljs-attribute">ProxyTimeout</span> <span class="hljs-number">3</span></code></pre></div>

<p>链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io/tree/master/examples/cluster-httpd">例子</a></li>
<li><a target="_blank" rel="noopener" href="https://httpd.apache.org/docs/2.4/en/mod/mod_proxy.html#proxypass">文档</a></li>
</ul>
<h3 id="HAProxy-配置"><a href="#HAProxy-配置" class="headerlink" title="HAProxy 配置"></a>HAProxy 配置</h3><div class="code-wrapper"><pre><code class="hljs text"># Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/

listen chat
  bind *:80
  default_backend nodes

backend nodes
  option httpchk HEAD /health
  http-check expect status 200
  cookie io prefix indirect nocache # using the `io` cookie set upon handshake
  server app01 app01:3000 check cookie app01
  server app02 app02:3000 check cookie app02
  server app03 app03:3000 check cookie app03</code></pre></div>

<p>链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io/tree/master/examples/cluster-haproxy">例子</a></li>
<li><a target="_blank" rel="noopener" href="http://cbonte.github.io/haproxy-dconv/2.4/configuration.html#cookie">文档</a></li>
</ul>
<h3 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h3><p>使用容器标签：</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># docker-compose.yml</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">traefik:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">traefik:2.4</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span>
    <span class="hljs-attr">links:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">server</span>

  <span class="hljs-attr">server:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:latest</span>
    <span class="hljs-attr">labels:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.http.routers.my-service.rule=PathPrefix(`/`)&quot;</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true</span></code></pre></div>

<p>使用<a target="_blank" rel="noopener" href="https://doc.traefik.io/traefik/v2.0/providers/file/">文件提供程序</a>：</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">## Dynamic configuration</span>
<span class="hljs-attr">http:</span>
  <span class="hljs-attr">services:</span>
    <span class="hljs-attr">my-service:</span>
      <span class="hljs-attr">rule:</span> <span class="hljs-string">&quot;PathPrefix(`/`)&quot;</span>
      <span class="hljs-attr">loadBalancer:</span>
        <span class="hljs-attr">sticky:</span>
          <span class="hljs-attr">cookie:</span>
            <span class="hljs-attr">name:</span> <span class="hljs-string">server_id</span>
            <span class="hljs-attr">httpOnly:</span> <span class="hljs-literal">true</span></code></pre></div>

<p>链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io/tree/master/examples/cluster-traefik">例子</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.traefik.io/traefik/v2.0/routing/services/#sticky-sessions">文档</a></li>
</ul>
<h3 id="使用-Node-js-集群"><a href="#使用-Node-js-集群" class="headerlink" title="使用 Node.js 集群"></a>使用 Node.js 集群</h3><p>就像 NginX 一样，Node.js 通过<code>cluster</code>模块提供了内置的集群支持。</p>
<p>有几种解决方案，具体取决于您的用例：</p>
<table>
<thead>
<tr>
<th>NPM 包</th>
<th>这个怎么运作</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/darrachequesne/socket.io-sticky"><code>@socket.io/sticky</code></a></td>
<td>路由基于<code>sid</code>查询参数</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/indutny/sticky-session"><code>sticky-session</code></a></td>
<td>路由是基于<code>connection.remoteAddress</code></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/wzrdtales/socket-io-sticky-session"><code>socketio-sticky-session</code></a></td>
<td>基于<code>x-forwarded-for</code>报头的路由）</td>
</tr>
</tbody></table>
<p>示例<code>@socket.io/sticky</code>:</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cluster&quot;</span>);
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);
<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Server</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>);
<span class="hljs-keyword">const</span> numCPUs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;os&quot;</span>).<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span>;
<span class="hljs-keyword">const</span> &#123; setupMaster, setupWorker &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/sticky&quot;</span>);
<span class="hljs-keyword">const</span> &#123; createAdapter, setupPrimary &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/cluster-adapter&quot;</span>);

<span class="hljs-keyword">if</span> (cluster.<span class="hljs-property">isMaster</span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Master <span class="hljs-subst">$&#123;process.pid&#125;</span> is running`</span>);

  <span class="hljs-keyword">const</span> httpServer = http.<span class="hljs-title function_">createServer</span>();

  <span class="hljs-comment">// setup sticky sessions</span>
  <span class="hljs-title function_">setupMaster</span>(httpServer, &#123;
    <span class="hljs-attr">loadBalancingMethod</span>: <span class="hljs-string">&quot;least-connection&quot;</span>,
  &#125;);

  <span class="hljs-comment">// setup connections between the workers</span>
  <span class="hljs-title function_">setupPrimary</span>();

  <span class="hljs-comment">// needed for packets containing buffers (you can ignore it if you only send plaintext objects)</span>
  <span class="hljs-comment">// Node.js &lt; 16.0.0</span>
  cluster.<span class="hljs-title function_">setupMaster</span>(&#123;
    <span class="hljs-attr">serialization</span>: <span class="hljs-string">&quot;advanced&quot;</span>,
  &#125;);
  <span class="hljs-comment">// Node.js &gt; 16.0.0</span>
  <span class="hljs-comment">// cluster.setupPrimary(&#123;</span>
  <span class="hljs-comment">//   serialization: &quot;advanced&quot;,</span>
  <span class="hljs-comment">// &#125;);</span>

  httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numCPUs; i++) &#123;
    cluster.<span class="hljs-title function_">fork</span>();
  &#125;

  cluster.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-function">(<span class="hljs-params">worker</span>) =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Worker <span class="hljs-subst">$&#123;worker.process.pid&#125;</span> died`</span>);
    cluster.<span class="hljs-title function_">fork</span>();
  &#125;);
&#125; <span class="hljs-keyword">else</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Worker <span class="hljs-subst">$&#123;process.pid&#125;</span> started`</span>);

  <span class="hljs-keyword">const</span> httpServer = http.<span class="hljs-title function_">createServer</span>();
  <span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer);

  <span class="hljs-comment">// use the cluster adapter</span>
  io.<span class="hljs-title function_">adapter</span>(<span class="hljs-title function_">createAdapter</span>());

  <span class="hljs-comment">// setup connection with the primary process</span>
  <span class="hljs-title function_">setupWorker</span>(io);

  io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
    <span class="hljs-comment">/* ... */</span>
  &#125;);
&#125;</code></pre></div>

<h2 id="在节点之间传递事件"><a href="#在节点之间传递事件" class="headerlink" title="在节点之间传递事件"></a>在节点之间传递事件</h2><p>既然您有多个接受连接的Socket.IO 节点，如果您想向所有客户端（或某个<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/">房间</a>中的客户端）广播事件，您将需要某种方式在进程或计算机之间传递消息。</p>
<p>负责路由消息的接口就是我们所说的<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/adapter/">Adapter</a>。</p>
<h1 id="处理-CORS"><a href="#处理-CORS" class="headerlink" title="处理 CORS"></a>处理 CORS</h1><p>从 Socket.IO v3 开始，您需要显式启用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">跨域资源共享</a>(CORS)。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;
  <span class="hljs-attr">cors</span>: &#123;
    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://example.com&quot;</span>
  &#125;
&#125;);</code></pre></div>

<p>所有选项都将转发到<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/cors">cors</a>包。可以在<a target="_blank" rel="noopener" href="https://github.com/expressjs/cors#configuration-options">此处</a>找到完整的选项列表。</p>
<p>带有 cookie ( <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">withCredentials</a>) 和附加标头的示例：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;
  <span class="hljs-attr">cors</span>: &#123;
    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://example.com&quot;</span>,
    <span class="hljs-attr">allowedHeaders</span>: [<span class="hljs-string">&quot;my-custom-header&quot;</span>],
    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>
  &#125;
&#125;);

<span class="hljs-comment">// client-side</span>
<span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://api.example.com&quot;</span>, &#123;
  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">extraHeaders</span>: &#123;
    <span class="hljs-string">&quot;my-custom-header&quot;</span>: <span class="hljs-string">&quot;abcd&quot;</span>
  &#125;
&#125;);</code></pre></div>

<p>注意：如果您的 Web 应用程序和服务器不是从同一个端口提供服务，这也适用于 localhost</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;
  <span class="hljs-attr">cors</span>: &#123;
    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;http://localhost:8080&quot;</span>
  &#125;
&#125;);

httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div>

<p>您可以使用以下选项禁止所有跨域请求<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-options/#allowrequest"><code>allowRequest</code></a> option:</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;
  <span class="hljs-attr">allowRequest</span>: <span class="hljs-function">(<span class="hljs-params">req, callback</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">const</span> noOriginHeader = req.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span> === <span class="hljs-literal">undefined</span>;
    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, noOriginHeader);
  &#125;
&#125;);</code></pre></div>

<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/handling-cors/#troubleshooting"></a></h2><h3 id="缺少-CORS-标头“Access-Control-Allow-Origin”"><a href="#缺少-CORS-标头“Access-Control-Allow-Origin”" class="headerlink" title="缺少 CORS 标头“Access-Control-Allow-Origin”"></a>缺少 CORS 标头“Access-Control-Allow-Origin”<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/handling-cors/#cors-header-access-control-allow-origin-missing"></a></h3><p>完整的错误信息：</p>
<blockquote>
<p><em>跨域请求被阻止：同源策略不允许读取位于 …/socket.io/?EIO=4&amp;transport=polling&amp;t=NMnp2WI 的远程资源。（原因：缺少 CORS 标头“Access-Control-Allow-Origin”）。</em></p>
</blockquote>
<p>如果您已正确配置您的服务器（见<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/handling-cors/#configuration">上文</a>），这可能意味着您的浏览器无法访问 Socket.IO 服务器。</p>
<p>以下命令：</p>
<div class="code-wrapper"><pre><code class="hljs text">curl &quot;https://api.example.com/socket.io/?EIO=4&amp;transport=polling&quot;</code></pre></div>

<p>应该返回类似：</p>
<div class="code-wrapper"><pre><code class="hljs text">0&#123;&quot;sid&quot;:&quot;Lbo5JLzTotvW3g2LAAAA&quot;,&quot;upgrades&quot;:[&quot;websocket&quot;],&quot;pingInterval&quot;:25000,&quot;pingTimeout&quot;:20000&#125;</code></pre></div>

<p>如果不是这种情况，请检查您的服务器是否正在侦听并且实际上可以在给定端口上访问。</p>
<h3 id="如果-CORS-标头“Access-Control-Allow-Origin”为“-”，则不支持凭据"><a href="#如果-CORS-标头“Access-Control-Allow-Origin”为“-”，则不支持凭据" class="headerlink" title="如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭据"></a>如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭据<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/handling-cors/#credential-is-not-supported-if-the-cors-header-access-control-allow-origin-is-"></a></h3><p>完整的错误信息：</p>
<blockquote>
<p><em>跨域请求被阻止：同源策略不允许读取位于“…/socket.io/?EIO=4&amp;transport=polling&amp;t=NvQfU77”的远程资源。（原因：如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭证）</em></p>
</blockquote>
<p>您不能同时设置<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-options/#withcredentials"><code>withCredentials</code></a> 为 <code>true</code> 和 <code>origin: *</code>，您需要使用特定的来源：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;

<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();
<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;
  <span class="hljs-attr">cors</span>: &#123;
    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://my-frontend.com&quot;</span>,
    <span class="hljs-comment">// or with an array of origins</span>
    <span class="hljs-comment">// origin: [&quot;https://my-frontend.com&quot;, &quot;https://my-other-frontend.com&quot;, &quot;http://localhost:3000&quot;],</span>
    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>
  &#125;
&#125;);</code></pre></div>

<h3 id="CORS-标头“Access-Control-Allow-Credentials”中预期为“true”"><a href="#CORS-标头“Access-Control-Allow-Credentials”中预期为“true”" class="headerlink" title="CORS 标头“Access-Control-Allow-Credentials”中预期为“true”"></a>CORS 标头“Access-Control-Allow-Credentials”中预期为“true”<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/handling-cors/#expected-true-in-cors-header-access-control-allow-credentials"></a></h3><p>完整的错误信息：</p>
<blockquote>
<p><em>跨域请求被阻止：同源策略不允许读取位于 …/socket.io/?EIO=4&amp;transport=polling&amp;t=NvQny19 的远程资源。（原因：CORS 标头“Access-Control-Allow-Credentials”中预期为“true”）</em></p>
</blockquote>
<p>在这种情况下，在客户端上<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-options/#withcredentials"><code>withCredentials</code></a>设置为<code>true</code>，但服务器缺少选项<code>credentials</code>中的属性<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-options/#cors"><code>cors</code></a> 。请参见上面的示例。</p>
<h1 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h1><p>在下面的示例中，<code>io</code>对象来自：</p>
<ul>
<li>使用 <code>&lt;script&gt;</code> 引入</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>复制</p>
<ul>
<li>使用 ESM 引入</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://cdn.socket.io/4.3.2/socket.io.esm.min.js&quot;</span>;</span>
<span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>

<p>复制</p>
<ul>
<li>NPM</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;</code></pre></div>

<h2 id="来自同一域"><a href="#来自同一域" class="headerlink" title="来自同一域"></a>来自同一域<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-initialization/#from-the-same-domain"></a></h2><p>如果您的前端与您的服务器在同一个域上提供服务，您可以简单地使用：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>();</code></pre></div>

<p>服务器 URL 将从 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location">window.location</a>对象中推导出来</p>
<h2 id="来自不同的域"><a href="#来自不同的域" class="headerlink" title="来自不同的域"></a>来自不同的域<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-initialization/#from-a-different-domain"></a></h2><p>如果您的前端不是来自与服务器相同的域，则必须传递服务器的 URL。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>);</code></pre></div>

<p>在这种情况下，请确保在服务器上启用 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/handling-cors/">跨域资源共享 (CORS)</a>。</p>
<h5 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h5><p>您可以使用<code>https</code> 或 <code>wss</code> (分别为, <code>http</code> 或 <code>ws</code>).</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// the following forms are similar</span>
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>);
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;wss://server-domain.com&quot;</span>);
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;server-domain.com&quot;</span>); <span class="hljs-comment">// only in the browser when the page is served over https (will not work in Node.js)</span></code></pre></div>

<h2 id="自定义命名空间"><a href="#自定义命名空间" class="headerlink" title="自定义命名空间"></a>自定义命名空间<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-initialization/#custom-namespace"></a></h2><p>在上面的示例中，客户端将连接到主命名空间。对于大多数用例来说，仅使用主命名空间就足够了，但您可以使用以下命令指定命名空间：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// same origin version</span>
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;/admin&quot;</span>);
<span class="hljs-comment">// cross origin version</span>
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com/admin&quot;</span>);</code></pre></div>

<p>您可以<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/namespaces/">在此处</a>找到有关名称空间的更多详细信息。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-initialization/#options"></a></h2><p>可在<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-options/">此处</a>找到可用配置的完整列表</p>
<h1 id="Socket-实例（客户端）"><a href="#Socket-实例（客户端）" class="headerlink" title="Socket 实例（客户端）"></a>Socket 实例（客户端）</h1><p><code>Socket</code>是与服务器交互的基础类。它继承了 Node.js<a target="_blank" rel="noopener" href="https://nodejs.org/api/events.html#class-eventemitter">EventEmitter</a>的大部分方法，例如 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-api/#socketemiteventname-args">emit</a>, <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-api/#socketoneventname-callback">on</a>, <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-api/#socketonceeventname-callback">once</a> 或 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-api/#socketoffeventname">off</a>。</p>
<p><img src="https://socket.io/zh-CN/images/bidirectional-communication-socket.png" srcset="/img/loading.gif" lazyload alt="Bidirectional communication between server and client"></p>
<p>除了<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/">emitting</a> 和 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/">listening to</a>事件之外，Socket 实例还有一些可能在您的应用程序中使用的属性：</p>
<h2 id="Socket-id-1"><a href="#Socket-id-1" class="headerlink" title="Socket#id"></a>Socket#id<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketid"></a></h2><p>每个新连接都分配有一个随机的 20 个字符的标识符。</p>
<p>此标识符与服务器端的值同步。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>
io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// x8WIv7-mJelg7on_ALbx</span>
&#125;);

<span class="hljs-comment">// client-side</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// x8WIv7-mJelg7on_ALbx</span>
&#125;);

socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// undefined</span>
&#125;);</code></pre></div>

<h2 id="Socket-connected"><a href="#Socket-connected" class="headerlink" title="Socket#connected"></a>Socket#connected<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketconnected"></a></h2><p>该属性描述套接字当前是否连接到服务器。</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">connected</span>); <span class="hljs-comment">// true</span>
&#125;);

socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">connected</span>); <span class="hljs-comment">// false</span>
&#125;);</code></pre></div>

<h2 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket#io"></a>Socket#io<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketio"></a></h2><p>对基础<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-api/#manager">Manager</a>的引用。</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> engine = socket.<span class="hljs-property">io</span>.<span class="hljs-property">engine</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(engine.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// in most cases, prints &quot;polling&quot;</span>

  engine.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;upgrade&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(engine.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// in most cases, prints &quot;websocket&quot;</span>
  &#125;);

  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packet&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// called for each packet received</span>
  &#125;);

  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packetCreate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// called for each packet sent</span>
  &#125;);

  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;drain&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// called when the write buffer is drained</span>
  &#125;);

  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;
    <span class="hljs-comment">// called when the underlying connection is closed</span>
  &#125;);
&#125;);</code></pre></div>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#lifecycle"></a></h2><p><img src="https://socket.io/images/client_socket_events.png" srcset="/img/loading.gif" lazyload alt="Lifecycle diagram"></p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#events"></a></h2><p>Socket 实例发出三个特殊事件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect"><code>connect</code></a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect-error"><code>connect_error</code></a></li>
<li><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#disconnect"><code>disconnect</code></a></li>
</ul>
<p>请注意，从 Socket.IO v3 开始，Socket 实例不再发出任何与重新连接逻辑相关的事件。您可以直接监听 Manager 实例上的事件：</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;reconnect_attempt&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

socket.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;reconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>

<p>更多信息可以在<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/migrating-from-2-x-to-3-0/#the-socket-instance-will-no-longer-forward-the-events-emitted-by-its-manager">迁移指南</a>中找到</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a><code>connect</code><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect"></a></h3><p>此事件由 Socket 实例在连接<strong>和</strong>重新连接时触发。</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>

<p>请注意，您不应在<code>connect</code>处理程序本身中注册事件处理程序，因为每次 Socket 重新连接时都会注册一个新的处理程序：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;);
&#125;);

<span class="hljs-comment">// GOOD</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);

socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;);</code></pre></div>

<h3 id="connect-error"><a href="#connect-error" class="headerlink" title="connect_error"></a><code>connect_error</code><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect_error"></a></h3><p>在以下情况下触发此事件：</p>
<ul>
<li>低级连接无法建立</li>
<li>服务器在<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/middlewares/">中间件功能</a>中拒绝连接</li>
</ul>
<p>在第一种情况下，Socket 会在 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-options/#reconnectiondelay">给定的延迟</a>之后自动尝试重新连接。</p>
<p>在后一种情况下，您需要手动重新连接。您可能需要更新凭据：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// either by directly modifying the `auth` attribute</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  socket.<span class="hljs-property">auth</span>.<span class="hljs-property">token</span> = <span class="hljs-string">&quot;abcd&quot;</span>;
  socket.<span class="hljs-title function_">connect</span>();
&#125;);

<span class="hljs-comment">// or if the `auth` attribute is a function</span>
<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;
  <span class="hljs-attr">auth</span>: <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;
    <span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>));
  &#125;
&#125;);

socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
    socket.<span class="hljs-title function_">connect</span>();
  &#125;, <span class="hljs-number">1000</span>);
&#125;);</code></pre></div>

<h3 id="disconnect-1"><a href="#disconnect-1" class="headerlink" title="disconnect"></a><code>disconnect</code><a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#disconnect"></a></h3><p>此事件在断开连接时触发。</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>

<p>复制</p>
<p>以下是可能的原因列表：</p>
<table>
<thead>
<tr>
<th>Reason</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>io server disconnect</code></td>
<td>服务器已使用<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#socketdisconnectclose">socket.disconnect()</a>强制断开socket</td>
</tr>
<tr>
<td><code>io client disconnect</code></td>
<td>使用<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-api/#socketdisconnect">socket.disconnect()</a>手动断开socket</td>
</tr>
<tr>
<td><code>ping timeout</code></td>
<td>服务器未在该<code>pingInterval + pingTimeout</code>范围内发送 PING</td>
</tr>
<tr>
<td><code>transport close</code></td>
<td>连接已关闭（例如：用户失去连接，或网络从 WiFi 更改为 4G）</td>
</tr>
<tr>
<td><code>transport error</code></td>
<td>连接遇到错误（例如：服务器在 HTTP 长轮询周期中被杀死）</td>
</tr>
</tbody></table>
<p>前两种情况（显式断开），客户端不会尝试重新连接，需要手动调用<code>socket.connect()</code>.</p>
<p>在所有其他情况下，客户端将等待一个小的<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-options/#reconnectiondelay">随机延迟</a>，然后尝试重新连接：</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (reason === <span class="hljs-string">&quot;io server disconnect&quot;</span>) &#123;
    <span class="hljs-comment">// the disconnection was initiated by the server, you need to reconnect manually</span>
    socket.<span class="hljs-title function_">connect</span>();<span class="hljs-comment">//服务器断开的，需要手动执行重连</span>
  &#125;
  <span class="hljs-comment">// else the socket will automatically try to reconnect</span>
&#125;);</code></pre></div>

<p>注意：这些事件以及<code>disconnecting</code>, <code>newListener</code> 和 <code>removeListener</code>是不应在您的应用程序中使用的特殊事件：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD, will throw an error</span>
socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;disconnect&quot;</span>);</code></pre></div>

<h1 id="离线行为"><a href="#离线行为" class="headerlink" title="离线行为"></a>离线行为</h1><h2 id="缓冲事件"><a href="#缓冲事件" class="headerlink" title="缓冲事件"></a>缓冲事件<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-offline-behavior/#buffered-events"></a></h2><p>默认情况下，在 Socket 未连接时发出的任何事件都将被缓冲，直到重新连接。</p>
<p>虽然在大多数情况下很有用（当重新连接延迟很短时），但它可能会在连接恢复时导致大量事件。</p>
<p>有几种解决方案可以防止这种行为，具体取决于您的用例：</p>
<ul>
<li>使用Socket 实例的<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketconnected">connected 属性</a> attribute of the Socket instance</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (socket.<span class="hljs-property">connected</span>) &#123;
  socket.<span class="hljs-title function_">emit</span>( <span class="hljs-comment">/* ... */</span> );
&#125; <span class="hljs-keyword">else</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;</code></pre></div>

<ul>
<li>使用 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#volatile-events">volatile 事件</a></li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>( <span class="hljs-comment">/* ... */</span> );</code></pre></div>

<h1 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h1><p>有几种方法可以在服务器和客户端之间发送事件。</p>
<h2 id="基本的-emit"><a href="#基本的-emit" class="headerlink" title="基本的 emit"></a>基本的 emit<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E5%9F%BA%E6%9C%AC%E7%9A%84-emit"></a></h2><p>Socket.IO API 的灵感来自 Node.js <a target="_blank" rel="noopener" href="https://nodejs.org/docs/latest/api/events.html#events_events">EventEmitter</a>，这意味着您可以在一侧发出事件并在另一侧注册侦听器：</p>
<p><em>服务器</em></p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);
&#125;);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// world</span>
&#125;);</code></pre></div>

<p>这也适用于另一个方向：</p>
<p><em>服务器</em></p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// world</span>
  &#125;);
&#125;);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div>

<p>您可以发送任意数量的参数，并且支持所有可序列化的数据结构，包括像<a target="_blank" rel="noopener" href="https://nodejs.org/docs/latest/api/buffer.html#buffer_buffer">Buffer</a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">TypedArray</a>这样的二进制对象。</p>
<p><em>服务器</em></p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">5</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">6</span>]) &#125;);
&#125;);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// client-side</span>
socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1, arg2, arg3</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// 1</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg2); <span class="hljs-comment">// &quot;2&quot;</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg3); <span class="hljs-comment">// &#123; 3: &#x27;4&#x27;, 5: ArrayBuffer (1) [ 6 ] &#125;</span>
&#125;);</code></pre></div>

<p>无需<code>JSON.stringify()</code>，因为它会为您完成。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD</span>
socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;));

<span class="hljs-comment">// GOOD</span>
socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;);</code></pre></div>

<p>笔记：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a>对象将被转换为（并作为）它们的字符串表示形式，例如<code>1970-01-01T00:00:00.000Z</code></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>必须手动序列化：</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> serializedMap = [...myMap.<span class="hljs-title function_">entries</span>()];
<span class="hljs-keyword">const</span> serializedSet = [...mySet.<span class="hljs-title function_">keys</span>()];</code></pre></div>

<ul>
<li>您可以使用该<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#tojson_behavior"><code>toJSON()</code></a>方法自定义对象的序列化</li>
</ul>
<p>一个类的例子：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;
  #hp;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-variable language_">this</span>.#hp = <span class="hljs-number">42</span>;
  &#125;

  <span class="hljs-title function_">toJSON</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hp</span>: <span class="hljs-variable language_">this</span>.#hp &#125;;
  &#125;
&#125;

socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;here&#x27;s a hero&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>());</code></pre></div>

<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E5%9B%9E%E8%B0%83"></a></h2><p>事件很棒，但在某些情况下，您可能需要更经典的请求-响应 API。在 Socket.IO 中，此功能称为确认。</p>
<p>您可以添加一个回调作为<code>emit()</code>的最后一个参数，一旦对方确认事件，就会调用此回调：</p>
<p><em>服务器</em></p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;update item&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1, arg2, callback</span>) =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// 1</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg2); <span class="hljs-comment">// &#123; name: &quot;updated&quot; &#125;</span>
    <span class="hljs-title function_">callback</span>(&#123;
      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;ok&quot;</span>
    &#125;);
  &#125;);
&#125;);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;update item&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;updated&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>); <span class="hljs-comment">// ok</span>
&#125;);</code></pre></div>

<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E8%B6%85%E6%97%B6"></a></h2><p>从 Socket.IO v4.4.0 开始，您现在可以为每个发射分配超时：</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">timeout</span>(<span class="hljs-number">5000</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;my-event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (err) &#123;
    <span class="hljs-comment">// the other side did not acknowledge the event in the given delay</span>
  &#125;
&#125;);</code></pre></div>

<p>You can also use both a timeout and an <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">acknowledgement</a>:</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">timeout</span>(<span class="hljs-number">5000</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;my-event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, response</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">if</span> (err) &#123;
    <span class="hljs-comment">// the other side did not acknowledge the event in the given delay</span>
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);
  &#125;
&#125;);</code></pre></div>

<h2 id="易失性事件"><a href="#易失性事件" class="headerlink" title="易失性事件"></a>易失性事件<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E6%98%93%E5%A4%B1%E6%80%A7%E4%BA%8B%E4%BB%B6"></a></h2><p>易失性事件是在底层连接未准备好时不会发送的事件（有点像<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>，在可靠性方面）。</p>
<p>例如，如果您需要发送在线游戏中角色的位置（因为只有最新的值才有用），这可能会很有趣。</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;might or might not be received&quot;</span>);</code></pre></div>

<p>另一个用例是在客户端未连接时丢弃事件（默认情况下，事件会被缓冲直到重新连接）。</p>
<p>例子：</p>
<p><em>服务器</em></p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;connect&quot;</span>);

  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);
  &#125;);
&#125;);</code></pre></div>

<p><em>客户端</em></p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;
  socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;ping&quot;</span>, ++count);
&#125;, <span class="hljs-number">1000</span>);</code></pre></div>

<p>如果重新启动服务器，您将在控制台中看到：</p>
<div class="code-wrapper"><pre><code class="hljs text">connect
1
2
3
4
# the server is restarted, the client automatically reconnects
connect
9
10
11</code></pre></div>



<p>如果没有<code>volatile</code>标志，您将看到：</p>
<div class="code-wrapper"><pre><code class="hljs text">connect
1
2
3
4
# the server is restarted, the client automatically reconnects and sends its buffered events
connect
5
6
7
8
9
10
11</code></pre></div>

<h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><p>有几种方法可以处理在服务器和客户端之间传输的事件。</p>
<h2 id="EventEmitter-方法"><a href="#EventEmitter-方法" class="headerlink" title="EventEmitter 方法"></a>EventEmitter 方法<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#eventemitter-methods"></a></h2><p>在服务器端，Socket 实例扩展了 Node.js <a target="_blank" rel="noopener" href="https://nodejs.org/docs/latest/api/events.html#events_events">EventEmitter</a>类。</p>
<p>在客户端，Socket 实例使用<a target="_blank" rel="noopener" href="https://github.com/component/emitter">component-emitter</a>库提供的事件发射器，它公开了 EventEmitter 方法的子集。</p>
<h3 id="socket-on-eventName-listener"><a href="#socket-on-eventName-listener" class="headerlink" title="socket.on(eventName, listener)"></a>socket.on(eventName, listener)<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoneventname-listener"></a></h3><p>将<em>侦听器</em>函数添加到名为<em>eventName</em>的事件的侦听器数组的末尾。</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;details&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>



<h3 id="socket-once-eventName-listener"><a href="#socket-once-eventName-listener" class="headerlink" title="socket.once(eventName, listener)"></a>socket.once(eventName, listener)<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketonceeventname-listener"></a></h3><p>为名为<em>eventName</em>的事件添加<strong>一次性</strong>监听函数</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;details&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>



<h3 id="socket-off-eventName-listener"><a href="#socket-off-eventName-listener" class="headerlink" title="socket.off(eventName, listener)"></a>socket.off(eventName, listener)<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoffeventname-listener"></a></h3><p>从名为<em>eventName</em>的事件的侦听器数组中移除指定的<em>侦听器</em>。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args);
&#125;

socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;details&quot;</span>, listener);

<span class="hljs-comment">// and then later...</span>
socket.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;details&quot;</span>, listener);</code></pre></div>



<h3 id="socket-removeAllListeners-eventName"><a href="#socket-removeAllListeners-eventName" class="headerlink" title="socket.removeAllListeners([eventName])"></a>socket.removeAllListeners([eventName])<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketremovealllistenerseventname"></a></h3><p>删除所有侦听器，或指定<em>eventName</em>的侦听器。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// for a specific event</span>
socket.<span class="hljs-title function_">removeAllListeners</span>(<span class="hljs-string">&quot;details&quot;</span>);
<span class="hljs-comment">// for all events</span>
socket.<span class="hljs-title function_">removeAllListeners</span>();</code></pre></div>



<h2 id="Catch-all-侦听器"><a href="#Catch-all-侦听器" class="headerlink" title="Catch-all 侦听器"></a>Catch-all 侦听器<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#catch-all-listeners"></a></h2><p>从 Socket.IO v3 开始，受<a target="_blank" rel="noopener" href="https://github.com/EventEmitter2/EventEmitter2">EventEmitter2</a>库启发的新 API 允许声明 Catch-all 侦听器。</p>
<p>此功能在客户端和服务器上均可用。</p>
<h3 id="socket-onAny-listener"><a href="#socket-onAny-listener" class="headerlink" title="socket.onAny(listener)"></a>socket.onAny(listener)<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketonanylistener"></a></h3><p>添加一个监听器，当任何事件发出时将被触发。</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">onAny</span>(<span class="hljs-function">(<span class="hljs-params">eventName, ...args</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>



<h3 id="socket-prependAny-listener"><a href="#socket-prependAny-listener" class="headerlink" title="socket.prependAny(listener)"></a>socket.prependAny(listener)<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketprependanylistener"></a></h3><p>添加一个监听器，当任何事件发出时将被触发。侦听器被添加到侦听器数组的开头。</p>
<div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">prependAny</span>(<span class="hljs-function">(<span class="hljs-params">eventName, ...args</span>) =&gt;</span> &#123;
  <span class="hljs-comment">// ...</span>
&#125;);</code></pre></div>



<h3 id="socket-offAny-listener"><a href="#socket-offAny-listener" class="headerlink" title="socket.offAny([listener])"></a>socket.offAny([listener])<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoffanylistener"></a></h3><p>删除所有catch-all侦听器或给定的侦听器。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params">eventName, ...args</span>) =&gt; &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventName, args);
&#125;

socket.<span class="hljs-title function_">onAny</span>(listener);

<span class="hljs-comment">// and then later...</span>
socket.<span class="hljs-title function_">offAny</span>(listener);

<span class="hljs-comment">// or all listeners</span>
socket.<span class="hljs-title function_">offAny</span>();</code></pre></div>



<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#validation"></a></h2><p>事件参数的验证超出了 Socket.IO 库的范围。</p>
<p>JS 生态系统中有许多包涵盖了这个用例，其中包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/joi">joi</a></li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/ajv">ajv</a></li>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/validatorjs">validatorjs</a></li>
</ul>
<p>带有<a target="_blank" rel="noopener" href="https://joi.dev/api/">joi</a>和<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">acknowledgements</a>的示例：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Joi</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;joi&quot;</span>);

<span class="hljs-keyword">const</span> userSchema = <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">object</span>(&#123;
  <span class="hljs-attr">username</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">max</span>(<span class="hljs-number">30</span>).required(),
  <span class="hljs-attr">email</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">email</span>().required()
&#125;);

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;create user&quot;</span>, <span class="hljs-function">(<span class="hljs-params">payload, callback</span>) =&gt;</span> &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;
      <span class="hljs-comment">// not an acknowledgement</span>
      <span class="hljs-keyword">return</span> socket.<span class="hljs-title function_">disconnect</span>();
    &#125;
    <span class="hljs-keyword">const</span> &#123; error, value &#125; = userSchema.<span class="hljs-title function_">validate</span>(payload);
    <span class="hljs-keyword">if</span> (error) &#123;
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(&#123;
        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;KO&quot;</span>,
        error
      &#125;);
    &#125;
    <span class="hljs-comment">// do something with the value, and then</span>
    <span class="hljs-title function_">callback</span>(&#123;
      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;OK&quot;</span>
    &#125;);
  &#125;);

&#125;);</code></pre></div>



<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/listening-to-events/#error-handling"></a></h2><p>Socket.IO 库中目前没有内置的错误处理，这意味着您必须捕获任何可能在侦听器中引发的错误。</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;list items&quot;</span>, <span class="hljs-keyword">async</span> (callback) =&gt; &#123;
    <span class="hljs-keyword">try</span> &#123;
      <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">await</span> <span class="hljs-title function_">findItems</span>();
      <span class="hljs-title function_">callback</span>(&#123;
        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;OK&quot;</span>,
        items
      &#125;);
    &#125; <span class="hljs-keyword">catch</span> (e) &#123;
      <span class="hljs-title function_">callback</span>(&#123;
        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;NOK&quot;</span>
      &#125;);
    &#125;
  &#125;);
&#125;);</code></pre></div>



<p>在服务器端，使用<code>EventEmitter.captureRejections = true</code>（实验性，请参见<a target="_blank" rel="noopener" href="https://nodejs.org/api/events.html#events_capture_rejections_of_promises">此处</a>）也可能很有趣，具体取决于您的用例。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>).<span class="hljs-property">captureRejections</span> = <span class="hljs-literal">true</span>;

io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;list products&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;
    <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">findProducts</span>();
    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;products&quot;</span>, products);
  &#125;);

  socket[<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;nodejs.rejection&#x27;</span>)] = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;
    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;error&quot;</span>, err);
  &#125;;
&#125;);</code></pre></div>

<h1 id="广播事件"><a href="#广播事件" class="headerlink" title="广播事件"></a>广播事件</h1><p>Socket.IO 使向所有连接的客户端发送事件变得容易。</p>
<h5 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h5><p>请注意，广播是<strong>仅服务器</strong>功能。</p>
<h2 id="给所有连接的客户端"><a href="#给所有连接的客户端" class="headerlink" title="给所有连接的客户端"></a>给所有连接的客户端<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients"></a></h2><p><img src="https://socket.io/zh-CN/images/broadcasting.png" srcset="/img/loading.gif" lazyload alt="Broadcasting to all connected clients"></p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div>



<h5 id="CAUTION"><a href="#CAUTION" class="headerlink" title="CAUTION"></a>CAUTION</h5><p>当前断开连接（或正在重新连接）的客户端将不会收到该事件。将此事件存储在某处（例如在数据库中）取决于您的用例。</p>
<h2 id="除发送者外的所有连接的客户端"><a href="#除发送者外的所有连接的客户端" class="headerlink" title="除发送者外的所有连接的客户端"></a>除发送者外的所有连接的客户端<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients-except-the-sender"></a></h2><p><img src="https://socket.io/zh-CN/images/broadcasting2.png" srcset="/img/loading.gif" lazyload alt="Broadcasting to all connected clients excepting the sender"></p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-property">broadcast</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);
&#125;);</code></pre></div>

<h5 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h5><p>在上面的示例中，使用<code>socket.emit(&quot;hello&quot;, &quot;world&quot;)</code>（不带<code>broadcast</code>标志）会将事件发送到“客户端 A”。您可以在<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/emit-cheatsheet/">备忘单</a>中找到发送事件的所有方式的列表。</p>
<h2 id="使用多个-Socket-IO-服务器"><a href="#使用多个-Socket-IO-服务器" class="headerlink" title="使用多个 Socket.IO 服务器"></a>使用多个 Socket.IO 服务器<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#with-multiple-socketio-servers"></a></h2><p>广播也适用于多个 Socket.IO 服务器。</p>
<p>您只需将默认适配器替换为<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/adapter/">Redis 适配器</a>或其他<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/redis-adapter/">兼容的适配器</a>。</p>
<p><img src="https://socket.io/zh-CN/images/broadcasting-redis.png" srcset="/img/loading.gif" lazyload alt="Broadcasting with Redis"></p>
<p>在某些情况下，您可能只想向连接到当前服务器的客户端广播。您可以使用<code>local</code>标志实现此目的：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">local</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div>

<p>复制</p>
<p><img src="https://socket.io/zh-CN/images/broadcasting-redis-local.png" srcset="/img/loading.gif" lazyload alt="Broadcasting with Redis but local"></p>
<p>为了在广播时针对特定客户，请参阅有关<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/">Rooms</a>的文档。</p>
<h1 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h1><p>sockets可以<code>join</code> 和 <code>leave</code><em>房间</em>。它可用于向一部分客户端广播事件：</p>
<p><img src="https://socket.io/zh-CN/images/rooms.png" srcset="/img/loading.gif" lazyload alt="Broadcasting to all clients in a room"></p>
<h5 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h5><p>请注意，房间是一个<strong>仅限服务器</strong>的概念（即客户端无权访问它已加入的房间列表）。</p>
<h2 id="加入和离开"><a href="#加入和离开" class="headerlink" title="加入和离开"></a>加入和离开<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/#joining-and-leaving"></a></h2><p>您可以调用<code>join</code>以将socket订阅到给定的频道：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;some room&quot;</span>);
&#125;);</code></pre></div>



<p>然后在广播或发射时简单地使用<code>to</code> 或 <code>in</code>（它们是相同的）：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;some room&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);</code></pre></div>



<p>您可以同时发射到多个房间：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room2&quot;</span>).<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room3&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);</code></pre></div>



<p>在这种情况下，将执行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_(set_theory)">联合</a>：至少在其中一个房间中的每个socket都将获得<strong>一次</strong>事件（即使socket在两个或更多房间中）。</p>
<p>您还可以从给定的socket广播到房间：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;some room&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);
&#125;);</code></pre></div>



<p>在这种情况下，房间中<strong>除</strong>发送者之外的每个socket都会收到该事件。</p>
<p><img src="https://socket.io/zh-CN/images/rooms2.png" srcset="/img/loading.gif" lazyload alt="Broadcasting to all clients in a room excepting the sender"></p>
<p>要离开频道，您调用<code>leave</code>的方式与<code>join</code>相同。</p>
<h2 id="默认房间"><a href="#默认房间" class="headerlink" title="默认房间"></a>默认房间<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/#default-room"></a></h2><p>Socket.IO 中的每一个<code>socket</code>都由一个随机的、不可猜测的、唯一的标识符<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#socketid">Socket#id</a>。为了您的方便，每个socket都会自动加入一个由其自己的 id 标识的房间。</p>
<p>这使得实现私人消息变得容易：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;private message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">anotherSocketId, msg</span>) =&gt;</span> &#123;
    socket.<span class="hljs-title function_">to</span>(anotherSocketId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;private message&quot;</span>, socket.<span class="hljs-property">id</span>, msg);
  &#125;);
&#125;);</code></pre></div>



<h2 id="示例用例"><a href="#示例用例" class="headerlink" title="示例用例"></a>示例用例<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/#sample-use-cases"></a></h2><ul>
<li>向给定用户的每个设备/选项卡广播数据</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">async</span> (socket) =&gt; &#123;
  <span class="hljs-keyword">const</span> userId = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserId</span>(socket);

  socket.<span class="hljs-title function_">join</span>(userId);

  <span class="hljs-comment">// and then later</span>
  io.<span class="hljs-title function_">to</span>(userId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hi&quot;</span>);
&#125;);</code></pre></div>

<p>复制</p>
<ul>
<li>发送有关给定实体的通知</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">async</span> (socket) =&gt; &#123;
  <span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchProjects</span>(socket);

  projects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">project</span> =&gt;</span> socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;project:&quot;</span> + project.<span class="hljs-property">id</span>));

  <span class="hljs-comment">// and then later</span>
  io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;project:4321&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;project updated&quot;</span>);
&#125;);</code></pre></div>



<h2 id="断开"><a href="#断开" class="headerlink" title="断开"></a>断开<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/#disconnection"></a></h2><p>断开连接后，<code>leave</code>会自动将它们所属的所有通道连接起来，您不需要进行特殊的拆卸。</p>
<p>您可以通过监听<code>disconnecting</code>事件来获取 Socket 所在的房间：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnecting&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// the Set contains at least the socket ID</span>
  &#125;);

  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// socket.rooms.size === 0</span>
  &#125;);
&#125;);</code></pre></div>



<h2 id="使用多个-Socket-IO-服务器-1"><a href="#使用多个-Socket-IO-服务器-1" class="headerlink" title="使用多个 Socket.IO 服务器"></a>使用多个 Socket.IO 服务器<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/#with-multiple-socketio-servers"></a></h2><p>与<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#with-multiple-socketio-servers">全局广播</a>一样，向房间广播也适用于多个 Socket.IO 服务器。</p>
<p>您只需要将默认的<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/glossary/#adapter">Adapter</a>替换为 Redis Adapter。更多关于它的信息在<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/redis-adapter/">这里</a>。</p>
<p><img src="https://socket.io/zh-CN/images/rooms-redis.png" srcset="/img/loading.gif" lazyload alt="Broadcasting to all clients in a room with Redis"></p>
<h2 id="实施细节"><a href="#实施细节" class="headerlink" title="实施细节"></a>实施细节<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/#implementation-details"></a></h2><p>“房间”功能由我们称为适配器的东西实现。该适配器是一个服务器端组件，负责：</p>
<ul>
<li>存储 Socket 实例和房间之间的关系</li>
<li>向所有（或部分）客户端广播事件</li>
</ul>
<p>您可以在<a target="_blank" rel="noopener" href="https://github.com/socketio/socket.io-adapter">此处</a>找到默认内存适配器的代码。</p>
<p>基本上，它包含两个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">ES6 Maps</a>:</p>
<ul>
<li><code>sids</code>: <code>Map&lt;SocketId, Set&lt;Room&gt;&gt;</code></li>
<li><code>rooms</code>: <code>Map&lt;Room, Set&lt;SocketId&gt;&gt;</code></li>
</ul>
<p>调用<code>socket.join(&quot;the-room&quot;)</code>将导致：</p>
<ul>
<li>在<code>sids</code> Map中，将“the-room”添加到由Socket ID 标识的 Set</li>
<li>在<code>rooms</code> Map 中，将Socket ID 添加到由字符串“the-room”标识的 Set 中</li>
</ul>
<p>然后在广播时使用这两个地图：</p>
<ul>
<li>对所有套接字的广播（<code>io.emit()</code>）循环通过<code>sids</code>Map，并将数据包发送到所有sockets</li>
<li>对给定房间的广播 ( <code>io.to(&quot;room21&quot;).emit()</code>）循环通过<code>rooms</code>Map 中的 Set，并将数据包发送到所有匹配的sockets</li>
</ul>
<p>您可以通过以下方式访问这些对象：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// main namespace</span>
<span class="hljs-keyword">const</span> rooms = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">rooms</span>;
<span class="hljs-keyword">const</span> sids = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">sids</span>;

<span class="hljs-comment">// custom namespace</span>
<span class="hljs-keyword">const</span> rooms = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/my-namespace&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">rooms</span>;
<span class="hljs-keyword">const</span> sids = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/my-namespace&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">sids</span>;</code></pre></div>



<p>笔记：</p>
<ul>
<li>这些对象并不意味着直接修改，您应该始终使用<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#socketjoinroom"><code>socket.join(...)</code></a> 和 <a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/server-api/#socketleaveroom"><code>socket.leave(...)</code></a>来代替。</li>
<li>在<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">多服务器</a>设置中，<code>rooms</code> 和 <code>sids</code>对象不会在 Socket.IO 服务器之间共享（房间可能只“存在”在一个服务器上而不是另一个服务器上）。</li>
</ul>
<h2 id="房间事件"><a href="#房间事件" class="headerlink" title="房间事件"></a>房间事件<a target="_blank" rel="noopener" href="https://socket.io/zh-CN/docs/v4/rooms/#room-events"></a></h2><p>从<code>socket.io@3.1.0</code>开始，底层适配器将发出以下事件：</p>
<ul>
<li><code>create-room</code> (argument: room)</li>
<li><code>delete-room</code> (argument: room)</li>
<li><code>join-room</code> (argument: room, id)</li>
<li><code>leave-room</code> (argument: room, id)</li>
</ul>
<p>例子：</p>
<div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;create-room&quot;</span>, <span class="hljs-function">(<span class="hljs-params">room</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`room <span class="hljs-subst">$&#123;room&#125;</span> was created`</span>);
&#125;);

io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;join-room&quot;</span>, <span class="hljs-function">(<span class="hljs-params">room, id</span>) =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`socket <span class="hljs-subst">$&#123;id&#125;</span> has joined room <span class="hljs-subst">$&#123;room&#125;</span>`</span>);
&#125;);</code></pre></div>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="category-chain-item">计算机网络</a>
  
  
    <span>></span>
    
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/websocket/" class="category-chain-item">websocket</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/socket-io/">#socket.io</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>secket.io笔记</div>
      <div>http://example.com/2022/09/24/secket-io笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/25/Enzyme-react-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" title="Enzyme react 单元测试">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Enzyme react 单元测试</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/24/%E4%BB%80%E4%B9%88%E6%98%AFwebsocket/" title="什么是websocket">
                        <span class="hidden-mobile">什么是websocket</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
