

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="React开发依赖react开发必须依赖三个库：  react   包含react所有必须的核心代码  react-dom react渲染在不同平台所需要的核心代码  babel  将jsx转换成React代码的工具 react 包含react web和react-native所拥有的核心代码 react-dom针对web和native完成的事情不同 ​    web端react-dom会将jsx">
<meta property="og:type" content="article">
<meta property="og:title" content="react18 学习笔记">
<meta property="og:url" content="http://example.com/2022/08/30/react18-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="React开发依赖react开发必须依赖三个库：  react   包含react所有必须的核心代码  react-dom react渲染在不同平台所需要的核心代码  babel  将jsx转换成React代码的工具 react 包含react web和react-native所拥有的核心代码 react-dom针对web和native完成的事情不同 ​    web端react-dom会将jsx">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/pgiZpbQL.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/X4cHBQk6.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/ACO5RXp5.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/JXSSiW1v.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/7N1MVzzM.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/YMPGqZBu.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/9Z0ICdSV.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/dwdJVSSg.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/emUNGaLF.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/Ey8AqNSp.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/crDRrvA5.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/Zgl2puzy.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/a6VmoNdR.png">
<meta property="og:image" content="c:/Users/10152/Desktop/study/memo/React/QQ截图20220620161818.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/DaBjyVoU.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/QsLGVWW4.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/09/12/lfwbA1yr.png">
<meta property="article:published_time" content="2022-08-30T15:44:55.000Z">
<meta property="article:modified_time" content="2023-03-29T14:38:02.312Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img1.imgtp.com/2022/09/12/pgiZpbQL.png">
  
  
  
  <title>react18 学习笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Piggy的记录版</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="react18 学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-30 15:44" pubdate>
          2022年8月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          43k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          359 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">react18 学习笔记</h1>
            
            
              <div class="markdown-body">
                
                <h4 id="React开发依赖"><a href="#React开发依赖" class="headerlink" title="React开发依赖"></a>React开发依赖</h4><p>react开发必须依赖三个库：</p>
<ul>
<li><p>react   包含react所有必须的核心代码</p>
</li>
<li><p>react-dom react渲染在不同平台所需要的核心代码</p>
</li>
<li><p>babel  将jsx转换成React代码的工具</p>
<p>react 包含react web和react-native所拥有的核心代码</p>
<p>react-dom针对web和native完成的事情不同</p>
<p>​    web端react-dom会将jsx最终渲染成真实的DOM，显示在浏览器</p>
<p>​    native端 react-dom会将jsx最终渲染成原生的控件</p>
<p>babel是将jsx代码转成react.createElement</p>
</li>
</ul>
<h4 id="React组件化开发"><a href="#React组件化开发" class="headerlink" title="React组件化开发"></a>React组件化开发</h4><p>​    react中数据依赖来自两方面</p>
<p>​        参与界面更新的数据   当数据变量时，需要更新组件渲染的内容</p>
<p>​        不参与界面更新的数据  当数据变量时，不需要更新将组建渲染的内容，参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中，我们可以通过在构造函数中 this.state = {定义的数据}</p>
<p> 当我们的数据发生变化时，我们可以调用 this.setState 来更新数据，并且通知React进行update操作；在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面</p>
<ul>
<li><p>根据组件的定义方式，可以分为：函数组件(Functional Component )和类组件(Class Component)；</p>
</li>
<li><p>根据组件内部是否有状态需要维护，可以分成：无状态组件(Stateless Component )和有状态组件(Stateful Component)；</p>
</li>
<li><p>根据组件的不同职责，可以分成：展示型组件(Presentational Component)和容器型组件(Container Component)；</p>
</li>
<li><p>函数组件、无状态组件、展示型组件主要关注UI的展示；</p>
</li>
<li><p>类组件、有状态组件、容器型组件主要关注数据逻辑</p>
</li>
</ul>
<h4 id="JSX的条件渲染"><a href="#JSX的条件渲染" class="headerlink" title="JSX的条件渲染"></a>JSX的条件渲染</h4><p>​    在react中，所有条件判断都和普通的js代码一致，而vue中会使用v-if/v-show等来控制，react中没有这样封装好的指令</p>
<p>​    react常见的条件渲染方式</p>
<ul>
<li><p>条件判断语句</p>
</li>
<li><p>三元运算符</p>
</li>
<li><p>与运算符&amp;&amp;</p>
</li>
<li><p>display来控制</p>
<div class="code-wrapper"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;
    <span class="hljs-comment">// 1.定义App根组件</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-variable language_">super</span>()
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;
          <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,

          <span class="hljs-attr">isReady</span>: <span class="hljs-literal">false</span>,

          <span class="hljs-attr">friend</span>: <span class="hljs-literal">undefined</span>
        &#125;
      &#125;

      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">const</span> &#123; isReady, friend &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>

        <span class="hljs-comment">// 1.条件判断方式一: 使用if进行条件判断</span>
        <span class="hljs-keyword">let</span> showElement = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">if</span> (isReady) &#123;
          showElement = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>准备开始比赛吧<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
        &#125; <span class="hljs-keyword">else</span> &#123;
          showElement = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>请提前做好准备!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
        &#125;

        <span class="hljs-keyword">return</span> (
          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">            &#123;/* 1.方式一: 根据条件给变量赋值不同的内容 */&#125;</span>
<span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;showElement&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">            &#123;/* 2.方式二: 三元运算符 */&#125;</span>
<span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; isReady ? <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>开始战斗!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>赶紧准备<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span> &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">            &#123;/* 3.方式三: &amp;&amp;逻辑与运算 */&#125;</span>
<span class="language-xml">            &#123;/* 场景: 当某一个值, 有可能为undefined时, 使用&amp;&amp;进行条件判断 */&#125;</span>
<span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; friend &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;friend.name + &quot; &quot; + friend.desc&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        )
      &#125;
    &#125;

    <span class="hljs-comment">// 2.创建root并且渲染App组件</span>
    <span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>))
    root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>)
  &lt;/script&gt;</code></pre></div></li>
</ul>
<p>1.react中，方法中this的默认是指向undefined的，</p>
<p>  2.vscode创建用户代码片段<br>3.<br> <div class="code-wrapper"><pre><code class="hljs js">jsx写注释&#123;<span class="hljs-comment">/* */</span>&#125;
 <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">        &#123;/*这是一段注释*/&#125;</span>
<span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  &#125;
&#125;</code></pre></div></p>
<p>​    4.</p>
<div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">//这三个值无法在jsx中渲染出来</span>
   test1:<span class="hljs-literal">undefined</span>
   test2:<span class="hljs-literal">null</span>
   text3:<span class="hljs-literal">false</span></code></pre></div>

<p>5.在jsx中对象类型不可以作为子元素,进行直接展示</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.state.obj&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<p>6.jsx嵌入表达式<br>    运算表达式<br>    三元运算符<br>    执行一个函数</p>
<p>7.jsx中的class用className<br>8.jsx中style的写法</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&quot;<span class="hljs-attr">red</span>&quot;,<span class="hljs-attr">fontSzie:</span>&quot;<span class="hljs-attr">24px</span>&quot;&#125;&#125;&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div>

<p>9.react的事件绑定<br>    react的事件绑定方法中this默认是undefined<br>    this的绑定的三种方式</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;
    <span class="hljs-comment">// class fields</span>
    name = <span class="hljs-string">&quot;App&quot;</span>

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-comment">//类组件继承一定要加super()并且必须写在最上面</span>
      <span class="hljs-variable language_">super</span>()
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;
        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,
        <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span>
      &#125;

      <span class="hljs-variable language_">this</span>.<span class="hljs-property">btn1Click</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">btn1Click</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)
    &#125;

    <span class="hljs-title function_">btn1Click</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn1Click&quot;</span>, <span class="hljs-variable language_">this</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span> &#125;)
    &#125;

    btn2Click = <span class="hljs-function">() =&gt;</span> &#123;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn2Click&quot;</span>, <span class="hljs-variable language_">this</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">1000</span> &#125;)
    &#125;

    <span class="hljs-title function_">btn3Click</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn3Click&quot;</span>, <span class="hljs-variable language_">this</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">9999</span> &#125;)
    &#125;

    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-keyword">const</span> &#123; message &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>

      <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">          &#123;/* 1.this绑定方式一: bind绑定 */&#125;</span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btn1Click&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">          </span>
<span class="language-xml">          &#123;/* 2.this绑定方式二: ES6 class fields */&#125;</span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btn2Click&#125;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml"></span>
<span class="language-xml">          &#123;/* 3.this绑定方式三: 直接传入一个箭头函数(重要) */&#125;</span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> console.log(&quot;btn3Click&quot;)&#125;&gt;按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.btn3Click()&#125;&gt;按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml"></span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前计数: &#123;this.state.counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      )
    &#125;
  &#125;

  <span class="hljs-comment">// 2.创建root并且渲染App组件</span>
  <span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>))
  root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>)</code></pre></div>

<p> 10.react事件的传参</p>
<div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(e)</span>=&gt;</span>&#123;
         this.click3(e,item,name)
       &#125;&#125;&gt;点击3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div>

<p>​        可以用来传递event<br>​<br> 在执行事件函数时，有可能我们需要获取一些参数信息：比如event对象、其他参数<br> 情况一：获取event对象<br> 很多时候我们需要拿到event对象来做一些事情（比如阻止默认行为）<br> 假如我们用不到this，那么直接传入函数就可以获取到event对象；<br> 情况二：获取更多参数<br> 有更多参数时，我们最好的方式就是传入一个箭头函数，主动执行的事件函数，并且传入相关的其他参数</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-keyword">const</span> &#123; message &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>

      <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">          &#123;/* 1.event参数的传递 */&#125;</span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick.bind(this)&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event)</span> =&gt;</span> this.btnClick(event)&#125;&gt;按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">          </span>
<span class="language-xml">          &#123;/* 2.额外的参数传递 */&#125;</span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick.bind(this,</span> &quot;<span class="hljs-attr">kobe</span>&quot;, <span class="hljs-attr">30</span>)&#125;&gt;</span>按钮3(不推荐)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event)</span> =&gt;</span> this.btnClick(event, &quot;why&quot;, 18)&#125;&gt;按钮4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      )
    &#125;</code></pre></div>

<p> 11.react的列表渲染使用最多的是使用map<br>     过滤filter<br>     截取slice<br> 12.React.createElement() jsx是他的语法糖</p>
<p>​    createElement需要传递三个参数</p>
<ul>
<li><p>type      当前ReactElement的类型，如果是标签元素，那么就使用字符串表示div,如果是组件元素就用组件的名称</p>
</li>
<li><p>config    所有jsx中的属性在config中都是对象的属性和值的形式存在，例如className作为class</p>
</li>
<li><p>children  存放在标签中的内容都是以children数组的形式存储</p>
<p><img src="https://img1.imgtp.com/2022/09/12/pgiZpbQL.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220912114717.png"></p>
</li>
</ul>
<p> 13.render() 将virtual Dom=&gt;Dom<br> 14.频繁的操作DOM，会产生回流和重绘<br> 15.React 组件名称首字母必须大写 html标签必须小写<br>     类组件需要继承自 React.Component<br>      类组件必须实现render函数<br> 16.函数式组件<br>      没有生命周期，也会被更新并挂载，但是没有生命周期函数；<br>      没有this(组件实例）；<br>     没有内部状态（state）<br> 17.render函数、函数式组件的返回类型<br>         组件，html元素<br>         数组、fragments<br>         Portals<br>         字符串或者数值类型<br>         Boolean，null<br> 18.react的生命周期</p>
<p>生命周期图谱</p>
<img src="https://img1.imgtp.com/2022/09/12/X4cHBQk6.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220912132938.png" style="zoom:200%;" />

<img src="https://img1.imgtp.com/2022/09/12/ACO5RXp5.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220912133029.png" style="zoom:200%;" />

<p> 常用的生命周期函数     </p>
<div class="code-wrapper"><pre><code class="hljs">    1.contructor()&#123;
    &#125;
     如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。
     constructor中通常只做两件事情：
     通过给 this.state 赋值对象来初始化内部的state；
     为事件绑定实例（this）；
    2.componentDidMount()
      componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用    
      可以进行网络请求，添加订阅，DOM操作
    3.componentDidUpdate(prevProps, prevState, snapshot)
      会在更行后立即调用，首次渲染不会执行，可以使用setState方法，但是必须用于条件语句，当组件更新后，可以在此处对 DOM 进行操作，如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求
    4.componentWillUnmount()
      可以用于清楚timer,取消网络请求，取消订阅
    5.不常用的生命周期
      getDerivedStateFromProps：state 的值在任何时候都依赖于 props时使用；该方法返回一个对象来更新state；
      getSnapshotBeforeUpdate：在React更新DOM之前回调的一个函数，可以获取DOM更新前的一些信息（比如说滚动位置）
      shouldComponentUpdate：当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。
</code></pre></div>
<p>   19.组件通信<br>         1.父组件向子组件传递数据 传递参数是常量非string的时候要将其当作变量用{}</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Children2</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;里斯&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&#123;55&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children2</span>&gt;</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs">     2.子组件向父组件传递数据，定义回调函数传递给子组件调用
</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;
import AddCounter from &#x27;./AddCounter&#x27;
import SubCounter from &#x27;./SubCounter&#x27;

export class App extends Component &#123;
  constructor() &#123;
    super()

    this.state = &#123;
      counter: 100
    &#125;
  &#125;

  changeCounter(count) &#123;
    this.setState(&#123; counter: this.state.counter + count &#125;)
  &#125;

  render() &#123;
    const &#123; counter &#125; = this.state

    return (
      &lt;div&gt;
        &lt;h2&gt;当前计数: &#123;counter&#125;&lt;/h2&gt;
        &lt;AddCounter addClick=&#123;(count) =&gt; this.changeCounter(count)&#125;/&gt;
        &lt;SubCounter subClick=&#123;(count) =&gt; this.changeCounter(count)&#125;/&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;

export default App</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;
// import PropTypes from &quot;prop-types&quot;

export class AddCounter extends Component &#123;
  addCount(count) &#123;
    this.props.addClick(count)
  &#125;

  render() &#123;

    return (
      &lt;div&gt;
        &lt;button onClick=&#123;e =&gt; this.addCount(1)&#125;&gt;+1&lt;/button&gt;
        &lt;button onClick=&#123;e =&gt; this.addCount(5)&#125;&gt;+5&lt;/button&gt;
        &lt;button onClick=&#123;e =&gt; this.addCount(10)&#125;&gt;+10&lt;/button&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;

// AddCounter.propTypes = &#123;
//   addClick: PropTypes.func
// &#125;

export default AddCounter</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs">    3.跨组件通信Context，可以使用组件的组合来替代Context        
</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> React from <span class="hljs-string">&quot;react&quot;</span>
<span class="hljs-comment">// 1.创建一个Context并且设置默认值</span>
<span class="hljs-type">const</span> ThemeContext = React.<span class="hljs-built_in">createContext</span>(&#123; color: <span class="hljs-string">&quot;blue&quot;</span>, size: <span class="hljs-number">10</span> &#125;)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ThemeContext</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>
<span class="hljs-comment">// 1.创建一个Context</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UserContext</span>
</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">//App.js
//多个context传递数据的方式
&lt;UserContext.Provider value=&#123;&#123;nickname: &quot;kobe&quot;, age: 30&#125;&#125;&gt;
          &lt;ThemeContext.Provider value=&#123;&#123;color: &quot;red&quot;, size: &quot;30&quot;&#125;&#125;&gt;
            &lt;Home &#123;...info&#125;/&gt;
          &lt;/ThemeContext.Provider&gt;
 &lt;/UserContext.Provider&gt;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">//类组件的接受方式
import React, &#123; Component &#125; from &#x27;react&#x27;
import ThemeContext from &#x27;./context/theme-context&#x27;

export class Profile extends Component &#123;
  render() &#123;
    console.log(this.context)

    return (
      &lt;div&gt;Profile&lt;/div&gt;
    )
  &#125;
&#125;

Profile.contextType = ThemeContext

export default Profile</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">//函数式组件的接收方式
import ThemeContext from &quot;./context/theme-context&quot;
function HomeBanner() &#123;
  return &lt;div&gt;
    &#123;/* 函数式组件中使用Context共享的数据 */&#125;
    &lt;ThemeContext.Consumer&gt;
      &#123;
        value =&gt; &#123;
          return &lt;h2&gt; Banner theme:&#123;value.color&#125;&lt;/h2&gt;
        &#125;
      &#125;
    &lt;/ThemeContext.Consumer&gt;
  &lt;/div&gt;
&#125;

export default HomeBanner</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;
import ThemeContext from &#x27;./context/theme-context&#x27;
import UserContext from &#x27;./context/user-context&#x27;

export class HomeInfo extends Component &#123;
  //static contextType=ThemeContext 这种写法也可以
  render() &#123;
    // 4.第四步操作: 获取数据, 并且使用数据
    console.log(this.context)

    return (
      &lt;div&gt;
        &lt;h2&gt;HomeInfo: &#123;this.context.color&#125;&lt;/h2&gt;
        &lt;UserContext.Consumer&gt;
          &#123;
            value =&gt; &#123;
              return &lt;h2&gt;Info User: &#123;value.nickname&#125;&lt;/h2&gt;
            &#125;
          &#125;
        &lt;/UserContext.Consumer&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;

// 3.第三步操作: 设置组件的contextType为某一个Context
HomeInfo.contextType = ThemeContext
HomeInfo.displayName = &#x27;MyDisplayName&#x27;;//设置在devtool的显示名字
export default HomeInfo</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">//多个context的使用
// Theme context，默认的 theme 是 “light” 值
const ThemeContext = React.createContext(&#x27;light&#x27;);
// 用户登录 context
const UserContext = React.createContext(&#123;
  name: &#x27;Guest&#x27;,
&#125;);
class App extends React.Component &#123;
  render() &#123;
    const &#123;signedInUser, theme&#125; = this.props;
    // 提供初始 context 值的 App 组件
    return (
      &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;
        &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt;
          &lt;Layout /&gt;
        &lt;/UserContext.Provider&gt;
      &lt;/ThemeContext.Provider&gt;
    );
  &#125;
&#125;
function Layout() &#123;
  return (
    &lt;div&gt;
      &lt;Sidebar /&gt;
      &lt;Content /&gt;
    &lt;/div&gt;
  );
&#125;
// 一个组件可能会消费多个 context
function Content() &#123;
  return (
    &lt;ThemeContext.Consumer&gt;
      &#123;theme =&gt; (
        &lt;UserContext.Consumer&gt;
          &#123;user =&gt; (
            &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt;
          )&#125;
        &lt;/UserContext.Consumer&gt;
      )&#125;
    &lt;/ThemeContext.Consumer&gt;
  );
&#125;</code></pre></div>

<p>**什么时候使用Context.Consumer呢？</p>
<p>.当使用value的组件是一个函数式组件时；</p>
<p>.当组件中需要使用多个Context时；</p>
<p> 4.使用事件总线<br>   20.对props进行类型检查 propTypes</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;prop-types&quot;</span>	

<span class="hljs-title class_">Children2</span>.<span class="hljs-property">propTypes</span> = &#123;
          <span class="hljs-comment">// 必填属性</span>
          <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,
          <span class="hljs-attr">age</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,
          <span class="hljs-attr">time</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">array</span>
        &#125;;
        <span class="hljs-comment">// 可以定义默认·值</span>
<span class="hljs-title class_">Children2</span>.<span class="hljs-property">defaultProps</span>=&#123;
          <span class="hljs-attr">time</span>:[<span class="hljs-string">&quot;2022/5/11&quot;</span>,<span class="hljs-string">&quot;2022/5/6&quot;</span>]
        &#125;</code></pre></div>

<p> 21.props为什么不写也是可以的   </p>
<div class="code-wrapper"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span>
<span class="hljs-comment"><span class="hljs-function">      super()</span></span>
<span class="hljs-comment"><span class="hljs-function">      this.state=&#123;&#125;</span></span>
<span class="hljs-function">    &#125;</span>
<span class="hljs-function"> 因为<span class="hljs-title">react</span>内部会强制性给当前实例复制<span class="hljs-title">props</span></span>
<span class="hljs-function"> <span class="hljs-title">this</span>.<span class="hljs-title">instance</span>=<span class="hljs-title">element</span>.<span class="hljs-title">props</span></span></code></pre></div>

<p>22.组件插槽的实现</p>
<div class="code-wrapper"><pre><code class="hljs html"> //App.js
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        &#123;/* 1.使用children实现插槽 */&#125;
        <span class="hljs-tag">&lt;<span class="hljs-name">NavBar</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体文本<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">NavBar</span>&gt;</span>

        &#123;/* 2.使用props实现插槽 */&#125;
        <span class="hljs-tag">&lt;<span class="hljs-name">NavBarTwo</span> </span>
<span class="hljs-tag">          <span class="hljs-attr">leftSlot</span>=<span class="hljs-string">&#123;btn&#125;</span></span>
<span class="hljs-tag">          <span class="hljs-attr">centerSlot</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">h2</span>&gt;</span>呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>&#125;
          rightSlot=&#123;<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体2<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#125;
        /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">//NavBar.js
export class NavBar extends Component &#123;
  render() &#123;
    const &#123; children &#125; = this.props
    console.log(children)

    return (
      &lt;div className=&#x27;nav-bar&#x27;&gt;
        &lt;div className=&quot;left&quot;&gt;&#123;children[0]&#125;&lt;/div&gt;
        &lt;div className=&quot;center&quot;&gt;&#123;children[1]&#125;&lt;/div&gt;
        &lt;div className=&quot;right&quot;&gt;&#123;children[2]&#125;&lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">//NavBarTwo.js
import React, &#123; Component &#125; from &#x27;react&#x27;
export class NavBarTwo extends Component &#123;
  render() &#123;
    const &#123; leftSlot, centerSlot, rightSlot &#125; = this.props

    return (
      &lt;div className=&#x27;nav-bar&#x27;&gt;
        &lt;div className=&quot;left&quot;&gt;&#123;leftSlot&#125;&lt;/div&gt;
        &lt;div className=&quot;center&quot;&gt;&#123;centerSlot&#125;&lt;/div&gt;
        &lt;div className=&quot;right&quot;&gt;&#123;rightSlot&#125;&lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;</code></pre></div>

<p>通过children实现的方案虽然可行，但是有一个弊端：通过索引值获取传入的元素很容易出错，不能精准的获取传入的原生</p>
<p>23.setState<br>   setState是异步更新，可以显著提升性能<br>   如果每一次调用setState都进行一次更新，那么意味着render函数需要频繁的调用<br>   最好的办法是获取多个更新，之后进行批量更新<br>   如果同步更新了state,但是还没执行render函数，那么state和props不能保持同步<br>   state和props不能保持一致性，会在开发中产生很多问题</p>
<p>   为了拿到异步更新后的数据</p>
<p>​    setState的三种写法</p>
<p>​    </p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) &#123;
   <span class="hljs-comment">// 1.setState更多用法</span>
   <span class="hljs-comment">// 1.基本使用</span>
   <span class="hljs-comment">// this.setState(&#123;</span>
   <span class="hljs-comment">//   message: &quot;你好啊, 李银河&quot;</span>
   <span class="hljs-comment">// &#125;)</span>

   <span class="hljs-comment">// 2.setState可以传入一个回调函数,回调 函数中接收的 state 和 props 都保证为最新。回调函数 的返回值会与 state 进行浅合并。</span>
   <span class="hljs-comment">// 好处一: 可以在回调函数中编写新的state的逻辑</span>
   <span class="hljs-comment">// 好处二: 当前的回调函数会将之前的state和props传递进来</span>
   <span class="hljs-comment">// this.setState((state, props) =&gt; &#123;</span>
   <span class="hljs-comment">//   // 1.编写一些对新的state处理逻辑</span>
   <span class="hljs-comment">//   // 2.可以获取之前的state和props值</span>
   <span class="hljs-comment">//   console.log(this.state.message, this.props)</span>
    <span class="hljs-comment">//获得最新的state和props</span>
<span class="hljs-comment">//   console.log(state, props)</span>
   <span class="hljs-comment">//   return &#123;</span>
   <span class="hljs-comment">//     message: &quot;你好啊, 李银河&quot;</span>
   <span class="hljs-comment">//   &#125;</span>
   <span class="hljs-comment">// &#125;)</span>

   <span class="hljs-comment">// 3.setState在React的事件处理中是一个异步调用</span>
   <span class="hljs-comment">// 如果希望在数据更新之后(数据合并), 获取到对应的结果执行一些逻辑代码</span>
   <span class="hljs-comment">// 那么可以在setState中传入第二个参数: callback</span>
   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊, 李银河&quot;</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;
     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;++++++:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>)
   &#125;)
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;------:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>)
 &#125;</code></pre></div>

<h5 id="setState都是异步的吗"><a href="#setState都是异步的吗" class="headerlink" title="setState都是异步的吗"></a>setState都是异步的吗</h5><p>在React18以前，在组件的生命周期或者React合成事件中，setState是异步的，在setTimeout以及原生事件中是同步的，react18以后所有都是异步的，如果需要同步操作需要使用flushSync()</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-comment">// 在react18之前, setTimeout中setState操作, 是同步操作</span>
    <span class="hljs-comment">// 在react18之后, setTimeout中setState异步操作(批处理)</span>
    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊, 李银河&quot;</span> &#125;)
    &#125;)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>)
  &#125;, <span class="hljs-number">0</span>);</code></pre></div>

<p> 24.组件创建的时候会被调用一次<br> 25.render函数，组件更新时调用render函数会让所有子组件都会进行一次更新。使用shouldComponentUpdate这个生命周期函数可以控制state和props发生变化时是否重新调用render函数         </p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps,nextState</span>)&#123;
    <span class="hljs-comment">//next...是最新的数据</span>
       <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">num</span>!==nextState.<span class="hljs-property">num</span>)&#123;
         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
       &#125;
       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
     &#125;</code></pre></div>

<p>​    在开发中每个组件都写shouldComponentUpdate比较麻烦，可以在使用PureComponent</p>
<div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span></span></code></pre></div>

<p> 26.PureComponent不能用于函数式组件，需要用memo</p>
<p>​     PureComponent就是对组件进行优化，避免频繁的调用render函数进行渲染，这个方法中调用!shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)，进行浅层比较</p>
<p> 27.state中的属性的不可变性<br> 28.react不建议直接在操作dom，可以使用ref<br>     使用ref的三种方式</p>
<div class="code-wrapper"><pre><code class="hljs react">import React,&#123;createRef&#125; from &quot;react&quot;;
class RefDemo extends React.Component&#123;
  constructor(props)&#123;
    super(props)
    this.state=&#123;&#125;
    this.titleRef=createRef()
    // 第三种使用函数
    this.textInput = null;
  &#125;
  componentDidMount()&#123;
   
  &#125;
  componentWillUnmount()&#123;
    
  &#125;
  changeRef1()&#123;
    // 方式一已经被淘汰了
    this.refs.refTitle.innerHTML=&quot;hello ref&quot;
  &#125;
  changeRef2()&#123;
    // 官方推荐以这种方式
     this.titleRef.current.innerHTML=&quot;hello big&quot;
    console.log(this.titleRef.current)
  &#125;
  focusTextInput()&#123;
    this.textInput.focus()
    console.log(this.textInput)
  &#125;
  render()&#123;
    return (
      &lt;div&gt;
        &lt;h1 ref=&quot;refTitle&quot;&gt;hello react&lt;/h1&gt;
        &lt;button onClick=&#123;()=&gt;this.changeRef1()&#125;&gt;按钮1&lt;/button&gt;
        &lt;h1 ref=&#123;this.titleRef&#125;&gt;hello world&lt;/h1&gt;
        &lt;button onClick=&#123;()=&gt;this.changeRef2()&#125;&gt;按钮2&lt;/button&gt;
        &lt;button onClick=&#123;()=&gt;this.focusTextInput()&#125;&gt;focus&lt;/button&gt;
        &lt;div&gt;&lt;input ref=&#123;element=&gt;this.textInput=element&#125; type=&quot;text&quot; /&gt;&lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;


export default RefDemo</code></pre></div>

<p>函数式组件中没有ref属性，要使用const textInput = useRef(null);<br>可以通过ref访问子组件的方法和属性和vue一样</p>
<h4 id="key的注意事项"><a href="#key的注意事项" class="headerlink" title="key的注意事项"></a>key的注意事项</h4><p>key必须唯一</p>
<p>key不能够使用随机数（因为随机数在下一次render时会重新生成一个数字）</p>
<p>使用index作为key,对性能没有优化</p>
<p>26.受控组件</p>
<p>​    受控组件就是通过setState来控制值，state成为唯一的数据源</p>
<p>​    </p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">inputChange</span>(<span class="hljs-params">event</span>) &#123;
   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inputChange:&quot;</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)
   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">username</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span> &#125;)
 &#125;

 <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;
   <span class="hljs-keyword">const</span> &#123; username &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>

   <span class="hljs-keyword">return</span> (
     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">       &#123;/* 受控组件 */&#125;</span>
<span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;username&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.inputChange(e)&#125;/&gt;</span>
<span class="language-xml"></span>
<span class="language-xml">       &#123;/* 非受控组件 */&#125;</span>
<span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span>
<span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>username: &#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
   )
 &#125;</code></pre></div>

<p>当type为text/textarea/select的时候绑定的是value,需要使用事件onChange</p>
<p>当type为checkbox/radio的时候，绑定的是checked，使用onChange事件</p>
<div class="code-wrapper"><pre><code class="hljs lua">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;始终是非受控组件</code></pre></div>

<p>使用form进行表单提交</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlavorForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;coconut&#x27;</span>&#125;;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
  &#125;

  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);
  &#125;

  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你喜欢的风味是: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);
    event.<span class="hljs-title function_">preventDefault</span>();
  &#125;

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span>
<span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span>
<span class="language-xml">          选择你喜欢的风味:</span>
<span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span>&gt;</span></span>
<span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;grapefruit&quot;</span>&gt;</span>葡萄柚<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span>
<span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lime&quot;</span>&gt;</span>酸橙<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span>
<span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;coconut&quot;</span>&gt;</span>椰子<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span>
<span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mango&quot;</span>&gt;</span>芒果<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span>
<span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span>
<span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>
<span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
    );
  &#125;
&#125;</code></pre></div>

<p>当针对多个输入的时候</p>
<p>可以给每个input绑定唯一的name,然后利用计算属性名来进行赋值操作</p>
<div class="code-wrapper"><pre><code class="hljs react">handleSubmitClick(event) &#123;
    // 1.阻止默认的行为
    event.preventDefault()

    // 2.获取到所有的表单数据, 对数据进行组件
    console.log(&quot;获取所有的输入内容&quot;)
    console.log(this.state.username, this.state.password)

    // 3.以网络请求的方式, 将数据传递给服务器(ajax/fetch/axios)
  &#125;

  // handleUsernameChange(event) &#123;
  //   this.setState(&#123; username: event.target.value &#125;)
  // &#125;

  // handlePasswordChange(event) &#123;
  //   this.setState(&#123; password: event.target.value &#125;)
  // &#125;

  handleInputChange(event) &#123;
    this.setState(&#123;
      [event.target.name]: event.target.value
    &#125;)
  &#125;

  render() &#123;
    const &#123; username, password &#125; = this.state

    return (
      &lt;div&gt;
        &lt;form onSubmit=&#123;e =&gt; this.handleSubmitClick(e)&#125;&gt;
          &#123;/* 1.用户名和密码 */&#125;
          &lt;label htmlFor=&quot;username&quot;&gt;
            用户: 
            &lt;input 
              id=&#x27;username&#x27; 
              type=&quot;text&quot; 
              name=&#x27;username&#x27; 
              value=&#123;username&#125; 
              onChange=&#123;e =&gt; this.handleInputChange(e)&#125;
            /&gt;
          &lt;/label&gt;
          &lt;label htmlFor=&quot;password&quot;&gt;
            密码: 
            &lt;input 
              id=&#x27;password&#x27; 
              type=&quot;password&quot; 
              name=&#x27;password&#x27; 
              value=&#123;password&#125; 
              onChange=&#123;e =&gt; this.handleInputChange(e)&#125;
            /&gt;
          &lt;/label&gt;

          &lt;button type=&#x27;submit&#x27;&gt;注册&lt;/button&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    )
  &#125;</code></pre></div>

<p>27.非受控组件</p>
<p>非受控组件就是将表单数据交给DOM节点来处理，</p>
<div class="code-wrapper"><pre><code class="hljs react">class NameForm extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  &#125;

  handleSubmit(event) &#123;
    alert(&#x27;A name was submitted: &#x27; + this.input.current.value);
    event.preventDefault();
  &#125;

  render() &#123;、
  //defaultValue是默认值
    return (
      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
        &lt;label&gt;
          Name:
          &lt;input  defaultValue=&quot;Bob&quot; type=&quot;text&quot; ref=&#123;this.input&#125; /&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
      &lt;/form&gt;
    );
  &#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs vim">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt; 和 &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt; 支持 defaultChecked，<span class="hljs-symbol">&lt;select&gt;</span> 和 <span class="hljs-symbol">&lt;textarea&gt;</span> 支
持 defaultValue。</code></pre></div>

<p>28.高阶组件</p>
<p>高阶组件是一个函数，高阶组件的参数是一个组件，返回值也是一个组件。高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。HOC 是纯函数，没有副作用，高阶组件适用于抽取公共的逻辑</p>
<div class="code-wrapper"><pre><code class="hljs react">import &#123; PureComponent &#125; from &#x27;react&#x27;
//props增强
// 定义组件: 给一些需要特殊数据的组件, 注入props
function enhancedUserInfo(OriginComponent) &#123;
  class NewComponent extends PureComponent &#123;
    constructor(props) &#123;
      super(props)
      this.state = &#123;
        userInfo: &#123;
          name: &quot;coderwhy&quot;,
          level: 99
        &#125;
      &#125;
    &#125;
    render() &#123;
      return &lt;OriginComponent &#123;...this.props&#125; &#123;...this.state.userInfo&#125;/&gt;
    &#125;
  &#125;
  return NewComponent
&#125;
export default enhancedUserInfo</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//我们也可以利用高阶函数来劫持生命周期，在生命周期中完成自己的逻辑</span>
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">logRenderTime</span>(<span class="hljs-params">OriginComponent</span>) &#123;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">PureComponent</span> &#123;
    <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">beginTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()  
    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">endTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()
      <span class="hljs-keyword">const</span> interval = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endTime</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">beginTime</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前<span class="hljs-subst">$&#123;OriginComponent.name&#125;</span>页面花费了<span class="hljs-subst">$&#123;interval&#125;</span>ms渲染完成!`</span>)
    &#125;
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;
      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">OriginComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125;/&gt;</span></span>
    &#125;
  &#125;
&#125;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> logRenderTime</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">//渲染鉴权，可以判断用户有没有登录，如果没有登录则渲染其他组件
function loginAuth(OriginComponent) &#123;
  return props =&gt; &#123;
    // 从localStorage中获取token
    const token = localStorage.getItem(&quot;token&quot;)
    if (token) &#123;
      return &lt;OriginComponent &#123;...props&#125;/&gt;
    &#125; else &#123;
      return &lt;h2&gt;请先登录, 再进行跳转到对应的页面中&lt;/h2&gt;
    &#125;
  &#125;
&#125;
export default loginAuth
</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs react">import ThemeContext from &quot;../context/theme_context&quot;
//和context结合
function withTheme(OriginComponment) &#123;
  return (props) =&gt; &#123;
    return (
      &lt;ThemeContext.Consumer&gt;
        &#123;
          value =&gt; &#123;
            return &lt;OriginComponment &#123;...value&#125; &#123;...props&#125;/&gt;
          &#125;
        &#125;
      &lt;/ThemeContext.Consumer&gt;
    )
  &#125;
&#125;
export default withTheme</code></pre></div>

<p>不要在 render 方法中使用 HOC</p>
<p>HOC也有自己的一些缺陷：</p>
<p> HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难； HOC可以劫持props，在不遵守约定的情况下也可能造成冲突；</p>
<p>Hooks的出现，是开创性的，它解决了很多React之前的存在的问题</p>
<p>比如this指向问题、比如hoc的嵌套复杂度问题等等</p>
<p>29.ref的转发，获取函数式组件内部的ref 可以使用forwardRef高阶函数<br>30.Portals的使用，用于将渲染元素独立于父组件，渲染到其他元素之上。使用React.createPortal(child,container)<br>31.fragment的使用，相当于vue的template在实际的dom中不渲染，带key的时候不能使用短语法<br>    还可以使用短语发    </p>
<div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Columns</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  render() &#123;
    <span class="hljs-keyword">return</span> (
      &lt;&gt;
        &lt;td&gt;<span class="hljs-type">Hello</span>&lt;/td&gt;
        &lt;td&gt;<span class="hljs-type">World</span>&lt;/td&gt;
      &lt;/&gt;
    );
  &#125;
&#125;</code></pre></div>

<p> 32.StrictMode 开启react的严格模式，只有开发环境下起作用</p>
<p>​    StrictMode是用来突显应用程序中的潜在问题的工具</p>
<p>​    它为其后代元素触发额外的检查和警告</p>
<div class="code-wrapper"><pre><code class="hljs"> 可以识别不安全的生命周期
 使用过时的ref的API
 检测意外的副作用。
</code></pre></div>
<p>​            组件的constructor会调用两次</p>
<p>​            生产环境终不悔调用两次</p>
<p>​    j检测使用废弃的findDOMNode方法</p>
<div class="code-wrapper"><pre><code class="hljs"> 检测过时的context api 
</code></pre></div>
<p>​            早期的Context是通过static属性声明Context对象属性，通过getChildContext返回Context对象等方式来使用Context的</p>
<p> 33.react中的css<br>     1.内联样式</p>
<p>​            style 接受一个采用小驼峰命名属性的 JavaScript 对象，，而不是 CSS 字符串</p>
<p>​            并且可以引用state中的状态来设置相关的样式</p>
<p>​            .内联样式, 样式之间不会有冲突</p>
<p>​             可以动态获取当前state中的状态</p>
<p>​             写法上都需要使用驼峰标识</p>
<p>​            某些样式没有提示</p>
<p>​            大量的样式, 代码混乱</p>
<p>​            某些样式无法编写(比如伪类/伪元素</p>
<div class="code-wrapper"><pre><code class="hljs"> 2.css modules
     不是react特有的决绝方案，所有类似webpack配置环境都可以使用，在react中已经配置，在其他项目中使用需要在webpack.config.js中module:true
      要创建xxx.moudle.css文件
      不能使用连接符创建类名(.home-title)，js不支持，需要使用&#123;引入名字style.className&#125;来编写
      不方便更改样式.不方便动态修改某些样式，依然需要使用内联样式
  3.css in js
      常用的 css in js库
          styled-components
              在多人协作中，css必定会出现命名冲突，与vue的scoped解决方案不同，react用styled-                    components的给类名加了随机字符的方式实现了css的私有化，它也是全局的
          styled-components其实是一个组件，可以传入props
          emotion
          glamorous
</code></pre></div>
<p>​        styled-components的本质是通过函数的调用，最终创建出一个组件，这个组件会自动添加上一个不重复的class</p>
<p>​        styled-components会给该class添加相关的样式，它支持css预处理器一样嵌套，支持直接子代选择器或者后代选择器，并且编写样式，可以通过&amp;符号获取当前元素，直接伪类选择器，伪元素等</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span>
<span class="hljs-keyword">import</span> &#123;
  primaryColor,
  largeSize
&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./style/variables&quot;</span>

<span class="hljs-comment">// 1.基本使用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">AppWrapper</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`</span>
<span class="hljs-string">  .footer &#123;</span>
<span class="hljs-string">    border: 1px solid orange;</span>
<span class="hljs-string">  &#125;</span>
<span class="hljs-string">// const obj = &#123;</span>
<span class="hljs-string">//   name: (props) =&gt; props.name || &quot;why&quot;</span>
<span class="hljs-string">// &#125;</span>
<span class="hljs-string">// 2.子元素单独抽取到一个样式组件</span>
<span class="hljs-string">// 3.可以接受外部传入的props</span>
<span class="hljs-string">// 4.可以通过attrs给标签模板字符串中提供的属性</span>
<span class="hljs-string">// 5.从一个单独的文件中引入变量</span>
<span class="hljs-string">export const SectionWrapper = styled.div.attrs(props =&gt; (&#123;</span>
<span class="hljs-string">  tColor: props.color || &quot;blue&quot;</span>
<span class="hljs-string">&#125;))`</span>
  <span class="hljs-attr">border</span>: 1px solid red;

  .<span class="hljs-property">title</span> &#123;
    font-<span class="hljs-attr">size</span>: $&#123;<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> props.<span class="hljs-property">size</span>&#125;px;
    <span class="hljs-attr">color</span>: $&#123;<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> props.<span class="hljs-property">tColor</span>&#125;;

    &amp;:hover &#123;
      background-<span class="hljs-attr">color</span>: purple;
    &#125;
  &#125;
  .<span class="hljs-property">content</span> &#123;
    font-<span class="hljs-attr">size</span>: $&#123;largeSize&#125;px;
    <span class="hljs-attr">color</span>: $&#123;primaryColor&#125;;
  &#125;
<span class="hljs-string">`</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HYButton</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`</span>
<span class="hljs-string">  border: 1px solid red;</span>
<span class="hljs-string">  border-radius: 5px;</span>
<span class="hljs-string">`</span>
<span class="hljs-comment">// css样式的继承</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HYButtonWrapper</span> = <span class="hljs-title function_">styled</span>(<span class="hljs-title class_">HYButton</span>)<span class="hljs-string">`</span>
<span class="hljs-string">  background-color: #0f0;</span>
<span class="hljs-string">  color: #fff;</span>
<span class="hljs-string">`</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeWrapper</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`</span>
<span class="hljs-string">  .top &#123;</span>
<span class="hljs-string">    .banner &#123;</span>
<span class="hljs-string">      color: red;</span>
<span class="hljs-string">    &#125;</span>
<span class="hljs-string">  &#125;</span>
<span class="hljs-string">  .bottom &#123;</span>
<span class="hljs-string">    .header &#123;</span>
<span class="hljs-string">      color: <span class="hljs-subst">$&#123;props =&gt; props.theme.color&#125;</span>;</span>
<span class="hljs-string">      font-size: <span class="hljs-subst">$&#123;props =&gt; props.theme.size&#125;</span>;</span>
<span class="hljs-string">    &#125;</span>
<span class="hljs-string"></span>
<span class="hljs-string">    .product-list &#123;</span>
<span class="hljs-string">      .item &#123;</span>
<span class="hljs-string">        color: blue;</span>
<span class="hljs-string">      &#125;</span>
<span class="hljs-string">    &#125;</span>
<span class="hljs-string">  &#125;</span>
<span class="hljs-string">`</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs"> 4.普通的csc会相互层叠，都会合并到全局的css中去，遭成影响到其他模块
 5.less的编写方式  需要配置webpack
   需要使用craco  目前针对creat-react-app 5 的配置 npm i @craco/craco@alpha
</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
   <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco start&quot;</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco build&quot;</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco test&quot;</span><span class="hljs-punctuation">,</span>
   <span class="hljs-attr">&quot;eject&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts eject&quot;</span>
 <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></div>

<p>​    </p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//craco.config.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">CracoLessPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;craco-less&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  <span class="hljs-attr">plugins</span>: [
    &#123;
      <span class="hljs-attr">plugin</span>: <span class="hljs-title class_">CracoLessPlugin</span>,
      <span class="hljs-attr">options</span>: &#123;
        <span class="hljs-attr">lessLoaderOptions</span>: &#123;
          <span class="hljs-attr">lessOptions</span>: &#123;
            <span class="hljs-attr">modifyVars</span>: &#123; <span class="hljs-string">&#x27;@primary-color&#x27;</span>: <span class="hljs-string">&#x27;#1DA57A&#x27;</span> &#125;,
            <span class="hljs-attr">javascriptEnabled</span>: <span class="hljs-literal">true</span>,
          &#125;,
        &#125;,
      &#125;,
    &#125;,
  ],
&#125;;
</code></pre></div>

<h4 id="React中添加class"><a href="#React中添加class" class="headerlink" title="React中添加class"></a>React中添加class</h4><p>可以借助第三方库classnames</p>
<p> 34.axios中，axios({})这样是使用他默认创建的实例，如果要自己创建一个实例要使用axios.create({})</p>
<h4 id="react-transition-group"><a href="#react-transition-group" class="headerlink" title="react-transition-group"></a>react-transition-group</h4><p>  这个库可以帮助我们方便的实现组件的 入场 和 离场 动画，使用时需要进行额外的安装</p>
<div class="code-wrapper"><pre><code class="hljs sql">npm install react<span class="hljs-operator">-</span>transition<span class="hljs-operator">-</span><span class="hljs-keyword">group</span> <span class="hljs-comment">--save</span>
yarn <span class="hljs-keyword">add</span> react<span class="hljs-operator">-</span>transition<span class="hljs-operator">-</span><span class="hljs-keyword">group</span></code></pre></div>

<p>react-transition-group主要包括四个组件</p>
<p>Tansition</p>
<p>​        该组件是一个和平台无关的组件（不一定要结合CSS）</p>
<p>​        在前端开发中，我们一般是结合CSS来完成样式，所以比较常用的是CSSTransition</p>
<p>CSSTransition</p>
<p>​        在前端开发中，通常使用CSSTransition来完成过渡动画</p>
<p>​        CSSTransition是基于Transition组件构建的</p>
<p>​        CSSTransition执行过程中，有三个状态：appear、enter、exit；</p>
<p>​        它们有三种状态，需要定义对应的CSS样式：</p>
<p>​        第一类，开始状态：对于的类是-appear、-enter、exit； </p>
<p>​        第二类：执行动画：对应的类是-appear-active、-enter-active、-exit-active； </p>
<p>​        第三类：执行结束：对应的类是-appear-done、-enter-done、-exit-done；</p>
<p>​        CSSTransition常用属性</p>
<p>​        in</p>
<p>​        classNames</p>
<p>​        timeout</p>
<p>​        appear</p>
<p>​        unmountOnExit</p>
<h6 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数:"></a>钩子函数:</h6><p>​                onEnter</p>
<p>​                onEntering</p>
<p>​                onEntered</p>
<div class="code-wrapper"><pre><code class="hljs react">import React, &#123; createRef, PureComponent &#125; from &#x27;react&#x27;
import &#123; CSSTransition &#125; from &quot;react-transition-group&quot;
import &quot;./style.css&quot;
export class App extends PureComponent &#123;
  constructor(props) &#123;
    super(props)
    this.state = &#123;
      isShow: true
    &#125;
    this.sectionRef = createRef()
  &#125;
  render() &#123;
    const &#123; isShow &#125; = this.state
    return (
      &lt;div&gt;
        &lt;button onClick=&#123;e =&gt; this.setState(&#123;isShow: !isShow&#125;)&#125;&gt;切换&lt;/button&gt;
        &#123;/* &#123; isShow &amp;&amp; &lt;h2&gt;哈哈哈&lt;/h2&gt; &#125; */&#125;
        &lt;CSSTransition 
          nodeRef=&#123;this.sectionRef&#125;
          in=&#123;isShow&#125; 
          unmountOnExit=&#123;true&#125; 
          classNames=&quot;why&quot; 
          timeout=&#123;2000&#125;
          appear
          onEnter=&#123;e =&gt; console.log(&quot;开始进入动画&quot;)&#125;
          onEntering=&#123;e =&gt; console.log(&quot;执行进入动画&quot;)&#125;
          onEntered=&#123;e =&gt; console.log(&quot;执行进入结束&quot;)&#125;
          onExit=&#123;e =&gt; console.log(&quot;开始离开动画&quot;)&#125;
          onExiting=&#123;e =&gt; console.log(&quot;执行离开动画&quot;)&#125;
          onExited=&#123;e =&gt; console.log(&quot;执行离开结束&quot;)&#125;
        &gt;
          &lt;div className=&#x27;section&#x27; ref=&#123;this.sectionRef&#125;&gt;
            &lt;h2&gt;哈哈哈&lt;/h2&gt;
            &lt;p&gt;我是内容, 哈哈哈&lt;/p&gt;
          &lt;/div&gt;
        &lt;/CSSTransition&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
export default App</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.why-appear</span>, <span class="hljs-selector-class">.why-enter</span> &#123;
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
&#125;
<span class="hljs-selector-class">.why-appear-active</span>, <span class="hljs-selector-class">.why-enter-active</span> &#123;
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">2s</span> ease;
&#125;
<span class="hljs-comment">/* 离开动画 */</span>
<span class="hljs-selector-class">.why-exit</span> &#123;
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
&#125;

<span class="hljs-selector-class">.why-exit-active</span> &#123;
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">2s</span> ease;
&#125;</code></pre></div>

<p>SwitchTransition</p>
<p>​        两个组件显示和切换时，使用该组件</p>
<p>​        SwitchTransition中主要有一个属性：mode，有两个值</p>
<p>​            in-out：表示新组件先进入，旧组件再移除；</p>
<p>​            out-in：表示就组件先移除，新组建再进入</p>
<p>​        SwitchTransition组件里面要有CSSTransition或者Transition组件，不能直接包裹你想要切换的组件</p>
<p>​        SwitchTransition里面的CSSTransition或Transition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是 key属性</p>
<div class="code-wrapper"><pre><code class="hljs react">import React, &#123; PureComponent &#125; from &#x27;react&#x27;
import &#123; SwitchTransition, CSSTransition &#125; from &#x27;react-transition-group&#x27;
import &quot;./style.css&quot;
export class App extends PureComponent &#123;
  constructor() &#123;
    super() 
    this.state = &#123;
      isLogin: true
    &#125;
  &#125;
  render() &#123;
    const &#123; isLogin &#125; = this.state

    return (
      &lt;div&gt;
        &lt;SwitchTransition mode=&#x27;out-in&#x27;&gt;
          &lt;CSSTransition
            key=&#123;isLogin ? &quot;exit&quot;: &quot;login&quot;&#125;
            classNames=&quot;login&quot;
            timeout=&#123;1000&#125;
          &gt;
            &lt;button onClick=&#123;e =&gt; this.setState(&#123; isLogin: !isLogin &#125;)&#125;&gt;
              &#123; isLogin ? &quot;退出&quot;: &quot;登录&quot; &#125;
            &lt;/button&gt;
          &lt;/CSSTransition&gt;
        &lt;/SwitchTransition&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;
export default App</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.login-enter</span> &#123;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
&#125;

<span class="hljs-selector-class">.login-enter-active</span> &#123;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;
&#125;

<span class="hljs-selector-class">.login-exit</span> &#123;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
&#125;

<span class="hljs-selector-class">.login-exit-active</span> &#123;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100px</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;
&#125;</code></pre></div>

<p>TransitionGroup</p>
<p>​        将多个组件包裹在其中，一般用于列表中的元素的动画</p>
<p>​        ◼ 当我们有一组动画时，需要将这些CSSTransition放入到一个TransitionGroup中来完成动画：</p>
<div class="code-wrapper"><pre><code class="hljs react">&lt;TransitionGroup component=&quot;ul&quot;&gt;
         &#123;
           books.map((item, index) =&gt; &#123;
             return (
               &lt;CSSTransition key=&#123;item.id&#125; classNames=&quot;book&quot; timeout=&#123;1000&#125;&gt;
                 &lt;li&gt;
                   &lt;span&gt;&#123;item.name&#125;-&#123;item.price&#125;&lt;/span&gt;
                   &lt;button onClick=&#123;e =&gt; this.removeBook(index)&#125;&gt;删除&lt;/button&gt;
                 &lt;/li&gt;
               &lt;/CSSTransition&gt;
             )
           &#125;)
         &#125;
       &lt;/TransitionGroup&gt;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.book-enter</span> &#123;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">150px</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
&#125;

<span class="hljs-selector-class">.book-enter-active</span> &#123;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;
&#125;

<span class="hljs-selector-class">.book-exit</span> &#123;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
&#125;

<span class="hljs-selector-class">.book-exit-active</span> &#123;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">150px</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;
&#125;
</code></pre></div>

<p>36.react纯函数<br> 37.node中对ES6模块化的支持 在13.2.0以后对es6的支持，需要在package.json中添加属性”type”:”module”,导入文件时要跟上.js后缀名<br> 38.redux<br>     redux主要是负责状态管理<br>     store:createStore(reducer,..)<br>     state:通过store.getState()来获取当前state<br>     react的组成<br>         action:是用来更新数据，所有的数据变化，必须通过dispatch来派发action来更新，action可以是一个对象，也可以是一个函数，函数必须返回一个对象<br>         reducer：是将state和action连接起来，reducer是一个纯函数，reducer是将传入的reducer和action整和成为一个新的state<br>         dispatch:用来派发action<br>     redux的三大原则<br>         1.单一数据源<br>         2.state是只读的<br>         3.使用纯函数来执行修改<br> 39.单向数据流<br> 40.react动画中<TransitionGroup>中需要再用<cssTransition>包裹,否则会报错<br> 41.react-router<br>     默认是模糊匹配<br> 42.react-hook<br>     import React from “react”//这个是在函数式组件和类组件都要写，因为jsx是React.createElement()的语法糖，会在内部调用<br>     useState()<br>     Hook的使用规则：<br>         只能在函数最外层调用Hook,不要在循环，条件判断或者子函数中调用<br>         只能在React的函数组件中调用Hook,不要再其他js函数中使用</p>
<div class="code-wrapper"><pre><code class="hljs">  const [count, setCount] = useState(() =&gt; 10);//useState可以传入一个函数
</code></pre></div>
<p>  console.log(“CounterHook渲染”);</p>
<p>  function handleBtnClick() {<br>    // setCount(count + 10);</p>
<p>​    setCount((prevCount) =&gt; prevCount + 10);//preCount是上一个count<br>​<br>​    如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。<br>​    与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的     setState 结合展开运算符来达到合并更新对象的效果。<br>​    setState(prevState =&gt; {<br>​      // 也可以使用 Object.assign<br>​      return {…prevState, …updatedValues};<br>​    });<br>​    useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p>
<p> 43.useEffect()<br>     useEffect(() =&gt; {<br>    console.log(“订阅一些事件”);</p>
<p>​    return () =&gt; {<br>​      console.log(“取消订阅事件”)<br>​    }<br>  }, []);//通过返回一个函数来执行类似componmentwillumnount来清除副作用，[]这个可以作为优化，只有在组件切换时才执行，[]只会执行一次，相当于是componentDiMount,componentWillUnmount<br>  44.useEffect第二个参数<br>   useEffect(() =&gt; {<br>​    console.log(“修改DOM”, count);<br>  }, [count]);//useEffect可以让某个属性发生改变时才执行，这个属性必须在useEffect的回调函数中有使用到<br>  如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。</p>
<p>使用多个useEffect可以分开使用，执行的时候会挨个执行</p>
<h4 id="45-useContext的使用"><a href="#45-useContext的使用" class="headerlink" title="45.useContext的使用"></a>45.useContext的使用</h4><p>​    useContext可以让多个Context传递给函数式组件的时候减少consumer的嵌套</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));
root.<span class="hljs-title function_">render</span>(
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;name:</span> &quot;<span class="hljs-attr">why</span>&quot;, <span class="hljs-attr">level:</span> <span class="hljs-attr">99</span>&#125;&#125;&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">TokenContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">coderwhy</span>&#x27;&#125;&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">TokenContext.Provider</span>&gt;</span></span>
<span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span>
);</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserContext</span>, <span class="hljs-title class_">ThemeContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./context&quot;</span>

<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-comment">// 使用Context</span>
  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>)
  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>)

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>User: &#123;user.name&#125;-&#123;user.level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span> <span class="hljs-attr">theme.color</span>, <span class="hljs-attr">fontSize:</span> <span class="hljs-attr">theme.size</span>&#125;&#125;&gt;</span>Theme<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
&#125;)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div>

<h4 id="46-useCallback的使用"><a href="#46-useCallback的使用" class="headerlink" title="46.useCallback的使用"></a>46.useCallback的使用</h4><p>useReducer不是redux的替代品，useReducer仅仅是useState的一种替代方案。在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分，或者这次修改的state需要依赖之前的state时，也可以使用。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;
  <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) &#123;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:
      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span> &#125;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:
      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> - <span class="hljs-number">1</span> &#125;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add_number&quot;</span>:
      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + action.<span class="hljs-property">num</span> &#125;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sub_number&quot;</span>:
      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> - action.<span class="hljs-property">num</span> &#125;
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state
  &#125;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs html">const [state, dispatch] = useReducer(reducer, &#123; counter: 0, friends: [], user: &#123;&#125; &#125;)

     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;increment&quot;&#125;)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;decrement&quot;&#125;)&#125;&gt;-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;add_number&quot;, num: 5&#125;)&#125;&gt;+5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;sub_number&quot;, num: 5&#125;)&#125;&gt;-5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;add_number&quot;, num: 100&#125;)&#125;&gt;+100<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div>



<h4 id="47-useMemo的使用"><a href="#47-useMemo的使用" class="headerlink" title="47.useMemo的使用"></a>47.useMemo的使用</h4><p>在进行大量的计算的时候，使用useMemo可以避免重复的渲染</p>
<p>可以对子组件传递相同内容的对象的时候避免重新渲染</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> &#123; useMemo, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>


<span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HelloWorld被渲染~&quot;</span>)
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
&#125;)


<span class="hljs-keyword">function</span> <span class="hljs-title function_">calcNumTotal</span>(<span class="hljs-params">num</span>) &#123;
  <span class="hljs-comment">// console.log(&quot;calcNumTotal的计算过程被调用~&quot;)</span>
  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;
    total += i
  &#125;
  <span class="hljs-keyword">return</span> total
&#125;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)

  <span class="hljs-comment">// const result = calcNumTotal(50)</span>

  <span class="hljs-comment">// 1.不依赖任何的值, 进行计算</span>
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">calcNumTotal</span>(<span class="hljs-number">50</span>)
  &#125;, [])

  <span class="hljs-comment">// 2.依赖count</span>
  <span class="hljs-comment">// const result = useMemo(() =&gt; &#123;</span>
  <span class="hljs-comment">//   return calcNumTotal(count*2)</span>
  <span class="hljs-comment">// &#125;, [count])</span>

  <span class="hljs-comment">// 3.useMemo和useCallback的对比</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;&#125;
  <span class="hljs-comment">// const increment = useCallback(fn, [])</span>
  <span class="hljs-comment">// const increment2 = useMemo(() =&gt; fn, [])</span>


  <span class="hljs-comment">// 4.使用useMemo对子组件渲染进行优化</span>
  <span class="hljs-comment">// const info = &#123; name: &quot;why&quot;, age: 18 &#125;</span>
  <span class="hljs-keyword">const</span> info = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;), [])

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计算结果: &#123;result&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计数器: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setCount(count+1)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">result</span>=<span class="hljs-string">&#123;result&#125;</span> <span class="hljs-attr">info</span>=<span class="hljs-string">&#123;info&#125;</span> /&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
&#125;)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div>

<p>48.useCallback是针对回调函数进行优化，useMemo是对返回值进行优化。userCallback可以用于传递给被pureComponent或者memo包裹的子组件的函数</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useState, useCallback, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>

<span class="hljs-comment">// useCallback性能优化的点:</span>
<span class="hljs-comment">// 1.当需要将一个函数传递给子组件时, 最好使用useCallback进行优化, 将优化之后的函数, 传递给子组件</span>
<span class="hljs-comment">//如果没有使用usecallback，函数式组件在发生更新的时候，所有代码都会重新执行，传递给子组件的函数会重新生成，如果使用usecallback,会根据第二个参数数组中的值，是否生成新的函数，使子组件是否重新渲染</span>
<span class="hljs-comment">// props中的属性发生改变时, 组件本身就会被重新渲染，</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HYHome</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;
  <span class="hljs-keyword">const</span> &#123; increment &#125; = props
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HYHome被渲染&quot;</span>)
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>increment+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">      &#123;/* 100个子组件 */&#125;</span>
<span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
&#125;)

<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)
  <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;hello&quot;</span>)

  <span class="hljs-comment">// 闭包陷阱: useCallback  解决闭包陷阱方式一，但是会生成新的函数</span>
  <span class="hljs-comment">// const increment = useCallback(function foo() &#123;</span>
  <span class="hljs-comment">//   console.log(&quot;increment&quot;)</span>
  <span class="hljs-comment">//   setCount(count+1)</span>
  <span class="hljs-comment">// &#125;, [count])</span>

  <span class="hljs-comment">// 进一步的优化: 当count发生改变时, 也使用同一个函数(了解)</span>
  <span class="hljs-comment">// 做法一: 将count依赖移除掉, 缺点: 闭包陷阱,因为此时的foo和原来的foo不是同一个foo,而原来的foo依然使用之前的count</span>
  <span class="hljs-comment">// const increment = useCallback(function foo() &#123;</span>
  <span class="hljs-comment">//   console.log(&quot;increment&quot;)</span>
  <span class="hljs-comment">//   setCount(count+1)</span>
  <span class="hljs-comment">// &#125;, [])</span>

  <span class="hljs-comment">// 做法二: useRef, 在组件多次渲染时, 返回的是同一个值</span>
  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>()
  countRef.<span class="hljs-property">current</span> = count
  <span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;increment&quot;</span>)
    <span class="hljs-title function_">setCount</span>(countRef.<span class="hljs-property">current</span> + <span class="hljs-number">1</span>)
  &#125;, [])

  <span class="hljs-comment">// 普通的函数</span>
  <span class="hljs-comment">// const increment = () =&gt; &#123;</span>
  <span class="hljs-comment">//   setCount(count+1)</span>
  <span class="hljs-comment">// &#125;</span>

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计数: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HYHome</span> <span class="hljs-attr">increment</span>=<span class="hljs-string">&#123;increment&#125;/</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>message:&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setMessage(Math.random())&#125;&gt;修改message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
&#125;)


<span class="hljs-comment">// function foo(name) &#123;</span>
<span class="hljs-comment">//   function bar() &#123;</span>
<span class="hljs-comment">//     console.log(name)</span>
<span class="hljs-comment">//   &#125;</span>
<span class="hljs-comment">//   return bar</span>
<span class="hljs-comment">// &#125;</span>

<span class="hljs-comment">// const bar1 = foo(&quot;why&quot;)</span>
<span class="hljs-comment">// bar1() // why</span>
<span class="hljs-comment">// bar1() // why</span>

<span class="hljs-comment">// const bar2 = foo(&quot;kobe&quot;)</span>
<span class="hljs-comment">// bar2() // kobe</span>

<span class="hljs-comment">// bar1() // why</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div>

<p>useCallback会返回一个函数的memoized(记忆的)，在依赖不变的情况下，多次定义的时候，返回的值是相同的。通常使用useCallback的目的是不希望子组件进行多次渲染，并不是为了函数继续缓存</p>
<h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>useRef返回一个ref对象，返回的ref对象再组件的整个生命周期保持不变，会指向同一个对象</p>
<p>useRef的两种用法：</p>
<p>​    用法一：引入DOM(或者组件，但是需要class组件)元素</p>
<p>​    用法二： 保存一个数据，这个对象在整个生命周期可以保持不变</p>
<p>49.Refs的转发<br>      就是父组件想获取到子组件的ref,在高阶组件中转发refs<br>      可以使用React.forwardRef()<br>      const ref=useRef(initialValue)//初始化值后不会发生改变    </p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RefHookDemo02</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> numRef = <span class="hljs-title function_">useRef</span>(count);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;
    numRef.<span class="hljs-property">current</span> = count;
  &#125;, [count])

  <span class="hljs-keyword">return</span> (

    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">      &#123;/* <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>numRef中的值: &#123;numRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count中的值: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> */&#125;</span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count上一次的值: &#123;numRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count这一次的值: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setCount(count + 10)&#125;&gt;+10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>

  )
&#125;<span class="hljs-comment">//useEffect和useRef结合使用可以修改numRef.current</span></code></pre></div>

<p>50.useImperativeHandle要和React.forwardRef()一起使用</p>
<p>通过forwardRef可以将ref转发到子组件，获取到子组件内部的ref,子组件拿到父组件创建的ref绑定到某个元素上，forwordRef会将子组件的DOM暴露给父组件，父组件拿到DOM之后可以任意操作，可以使用useImperativeHandle暴露固定的操作</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useRef, forwardRef, useImperativeHandle &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>

<span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;

  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>()

  <span class="hljs-comment">// 子组件对父组件传入的ref进行处理</span>
  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-keyword">return</span> &#123;
      <span class="hljs-title function_">focus</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;focus&quot;</span>)
        inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()
      &#125;,
      <span class="hljs-title function_">setValue</span>(<span class="hljs-params">value</span>) &#123;
        inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span> = value
      &#125;
    &#125;
  &#125;)

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;/</span>&gt;</span></span>
&#125;))


<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-keyword">const</span> titleRef = <span class="hljs-title function_">useRef</span>()
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>()

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDOM</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-comment">// console.log(inputRef.current)</span>
    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()
    <span class="hljs-comment">// inputRef.current.value = &quot;&quot;</span>
    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">setValue</span>(<span class="hljs-string">&quot;哈哈哈&quot;</span>)
  &#125;

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;titleRef&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;/</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleDOM&#125;</span>&gt;</span>DOM操作<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
&#125;)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>
</code></pre></div>

<p>51.自定义hook：就是将react的hook封装成函数<br>52.fiber的原理<br>53.不要在条件表达式中使用hook<br>54.使用normailze.css对项目进行初始化<br>    使用@craco/craco修改react 配置<br>        修改webpack的alias<br>    使用react-config-router进行路由配置<br>    使用styled-compoments进行写css样式<br>        background:url(${reuire()})//需要使用require来引入图片<br>        搜索框使用antDesign<br>        数据都是用redux来管理<br>        用redux-thunk进行异步请求<br>        配置redux-devtool<br>        将各个模块的redux分开写再各个文件中，然后进行合并，使用combineReducers<br>        store使用Provider进行传递<br>        所有组件用memo()包裹管理<br>        使用redux的hook:useDispatch()<br>                       useSelector(state=&gt;({}),shallowEqual)<br>                       shallowEqual//进行浅层比较,做优化<br>        Immutablejs可以解决使用拷贝来决绝数据可变性的问题，带来的性能问题        </p>
<div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> im=immutable
			<span class="hljs-keyword">const</span> info=&#123;&#125;
			<span class="hljs-keyword">const</span> imfoIM=im(info)
			imfoIm.<span class="hljs-keyword">set</span>()
			imfoIM.<span class="hljs-keyword">get</span>()
			imfoIm.list()
			imfoim.fromJS()<span class="hljs-comment">//深层次转换</span></code></pre></div>

<p>​        2.只能再react函数中调用成immutable类型<br>​            state.getIn([“a”,”b”])//相当于a.b<br>​            styled-components的传参<br>​            使用useCallback对需要传给子组件的函数进行包裹，可以有缓存，并提高性能<br>​<br>​            使用 redux-immutable中的commineReducer来优化combineReducer,提高性能</p>
<p>55 Hook的本质就是javascript函数，他要遵循两条规则<br>    1.只在最顶层使用hook<br>        不要再循环，条件或者嵌套函数中调用hook,确保总是再你的react函数的最顶层去调用他们<br>        遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确<br>    2.只能再react函数中调用Hook<br>      不要在普通的javascript中调用hook,可以在reat函数组件中调用hook,也可以在在定义hook中调用其他hook<br>56.自定义HOOK一定要以use开头<br>57.在两个组件中使用相同的 Hook 会共享 state 吗？不会。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。<br>58.自定义 Hook 如何获取独立的 state？每次调用 Hook，它都会获取独立的 state<br>    由于我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect<br>59.惰性初始化state</p>
<p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p>
<div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, <span class="hljs-built_in">set</span>State] = useState(() =&gt; &#123;
  <span class="hljs-keyword">const</span> initialState = someExpensiveComputation(props);
  return initialState;
&#125;);</code></pre></div>

<h4 id="60-useEffect是在每一轮渲染结束后执行"><a href="#60-useEffect是在每一轮渲染结束后执行" class="headerlink" title="60.useEffect是在每一轮渲染结束后执行"></a>60.useEffect是在每一轮渲染结束后执行</h4><p>61.组件卸载时需要清除effect创建的订阅，定时器等，useEffect函数需要返回一个清理函数</p>
<div class="code-wrapper"><pre><code class="hljs abnf">useEffect(() <span class="hljs-operator">=</span>&gt; &#123;
  const subscription <span class="hljs-operator">=</span> props.source.subscribe()<span class="hljs-comment">;</span>
  return () <span class="hljs-operator">=</span>&gt; &#123;
    // 清除订阅
    subscription.unsubscribe()<span class="hljs-comment">;</span>
  &#125;<span class="hljs-comment">;</span>
&#125;)<span class="hljs-comment">;</span></code></pre></div>

<p>为防止内存泄漏，清除函数会在组件卸载之前执行。另外，如果组件多次渲染，则会在子啊个effect之前，上一个effect就会被清除</p>
<h6 id="62-effect的执行时机"><a href="#62-effect的执行时机" class="headerlink" title="62.effect的执行时机"></a>62.effect的执行时机</h6><p>与componentDidMount,cimponentDidUpadate不同的是，在浏览器完成布局与绘制之后，</p>
<p>传给useEffect的函数会延迟调用，这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理情况，因此不应在函数值执行阻塞浏览器更新的操作</p>
<h6 id="63-useContext"><a href="#63-useContext" class="headerlink" title="63.useContext"></a>63.useContext</h6><div class="code-wrapper"><pre><code class="hljs reasonml">const MyContext= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>create<span class="hljs-constructor">Context(<span class="hljs-params">value</span>)</span>

const value = use<span class="hljs-constructor">Context(MyContext)</span>;
</code></pre></div>

<p>myContext是React.createContext的返回值，并返回该context的当前值，当前的value值由</p>
<p>他的上层组件距离当前组件最近的&lt;MyContext.Provider&gt;的value prop决定的</p>
<p>当Provider中的value发生更新的时候，useContext就会出发重新渲染，即使组件时使用React.emo包裹，或者使用shouldComponentUpdat生命周期，该组件都会重新渲染</p>
<p>只要MyConetext里面的值发生改变，使用了useContext的组件都会重新渲染，如果重新渲染开销大，可以使用memoization来优化</p>
<p>useContext(MyContext)===&gt;class中的static contextType=MyContext或者&lt;MyContext.Consumer&gt;</p>
<p><code>useContext(MyContext)</code> 只是让你能够<em>读取</em> context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件<em>提供</em> context。</p>
<h6 id="64-useReducer"><a href="#64-useReducer" class="headerlink" title="64.useReducer"></a>64.<code>useReducer</code></h6><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init);

useState的替代方案
在某些场合会比useState更加适用，例如 <span class="hljs-keyword">state</span> 逻辑较复杂且包含多个子值，或者下一个 <span class="hljs-keyword">state</span> 依赖于之前的 <span class="hljs-keyword">state</span> 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> initialState = &#123;count: <span class="hljs-number">0</span>&#125;;

function reducer(<span class="hljs-keyword">state</span>, action) &#123;
  switch (action.type) &#123;
    case &#x27;increment&#x27;:
      return &#123;count: <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span>&#125;;
    case &#x27;decrement&#x27;:
      return &#123;count: <span class="hljs-keyword">state</span>.count - <span class="hljs-number">1</span>&#125;;
    <span class="hljs-keyword">default</span>:
      throw new Error();
  &#125;
&#125;

function Counter() &#123;
  <span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialState);
  return (
    <span class="hljs-variable">&lt;&gt;</span>
      Count: &#123;<span class="hljs-keyword">state</span>.count&#125;
      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;
      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
&#125;</code></pre></div>

<h4 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h4><p>useReducer的第三个参数传入一个函数，这样初始state将设置为传入函数的返回值</p>
<p>可以通过外部来传入</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">initialCount</span>) &#123;
  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: initialCount&#125;;
&#125;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:
      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:
      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">init</span>(action.<span class="hljs-property">payload</span>);
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();
  &#125;
&#125;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) &#123;
  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialCount, init);
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span>
<span class="language-xml">      Count: &#123;state.count&#125;</span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span>
<span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;</span>
<span class="language-xml">        Reset</span>
<span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
&#125;
</code></pre></div>

<p>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）</p>
<p>如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p>
<p>useReducer不可以作为redux的替代方案，不可以进行数据共享</p>
<p>65.使用memo包裹函数，可以进行性能优化，会对props进行浅层比较，如果props没有发生更新，则不会重新渲染</p>
<p>66.没有优化以前。父组件发生改变子组件也会重新渲染</p>
<p>67.useCallback</p>
<p>返回一个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数。</p>
<p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p>
<p><img src="https://img1.imgtp.com/2022/09/12/JXSSiW1v.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620112711.png"></p>
<p><img src="https://img1.imgtp.com/2022/09/12/7N1MVzzM.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620112901.png"></p>
<p>68.useMeno</p>
<p>​    <code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p>
<p>useCallback是返回<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数。useMeno是返回一个memoized值</p>
<p>useMemo只会在依赖项发生改变时才会重新计算执行，返回新的值，避免每次渲染时都进行高开销的计算</p>
<p>记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p>
<p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值</p>
<p><img src="https://img1.imgtp.com/2022/09/12/YMPGqZBu.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620131653.png"></p>
<p><img src="https://img1.imgtp.com/2022/09/12/9Z0ICdSV.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620131701.png"></p>
<p>69.useRef</p>
<p>useRef返回一个ref对象，返回的ref对象在组件的整个生命周期保持不变</p>
<p>最常用的ref是两种用法</p>
<p>​    1.引入DOM(或者是class组件)元素，不可以用在函数组件中</p>
<p>​    2.保存一个数据，这个对象在整个生命周期中可以保持不变</p>
<p><img src="https://img1.imgtp.com/2022/09/12/dwdJVSSg.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620143141.png"></p>
<p><img src="https://img1.imgtp.com/2022/09/12/emUNGaLF.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620143158.png"></p>
<p>70.<code>useImperativeHandle</code></p>
<p>useImperativeHandle要和forwardRef结合使用，使用useImperativeHandle可以使父元素不可以对子组件中的ref进行随意操作</p>
<p><img src="https://img1.imgtp.com/2022/09/12/Ey8AqNSp.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620143648.png"></p>
<p><img src="https://img1.imgtp.com/2022/09/12/crDRrvA5.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620143735.png"></p>
<p>71.useLayoutEffect</p>
<p>​    和useEffect的区别是</p>
<p>​    useEffect会在渲染的内容更新到DOM之后再执行，而不会阻塞DOM的更新</p>
<p>​    useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新</p>
<p>​    <img src="https://img1.imgtp.com/2022/09/12/Zgl2puzy.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620144244.png"></p>
<p><img src="https://img1.imgtp.com/2022/09/12/a6VmoNdR.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620144253.png"></p>
<p>72.redux-thunk</p>
<p>​     使用中间件目的是再dispatch的action和reducer之间扩展自己的代码，例如日志记录，调用异步接口，添加代码调试功能等等</p>
<p>​    可以使用redux-thunk发送异步请求</p>
<p>​    1.通常情况下。dispatch(action),actionn余姚是一个javascript对象</p>
<p>​    2.redux-thunk可以让dispatch(action函数)，action可以是一个函数</p>
<p>​    3.这个函数被调用的时候，会返回一个函数并给这个函数传一个patch,getState函数</p>
<p>​                dispatch函数用于再次派发action</p>
<p>​                getState函数获取到之前的状态</p>
<p><img src="C:\Users\10152\Desktop\study\memo\React\QQ截图20220620161818.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://img1.imgtp.com/2022/09/12/DaBjyVoU.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620162945.png"></p>
<h6 id="73-redux-devtools"><a href="#73-redux-devtools" class="headerlink" title="73.redux-devtools"></a>73.redux-devtools</h6><p>是用来对redux中的状态进行跟踪调试</p>
<p><img src="https://img1.imgtp.com/2022/09/12/QsLGVWW4.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620163435.png"></p>
<h5 id="74-combineReducers"><a href="#74-combineReducers" class="headerlink" title="74.combineReducers"></a>74.combineReducers</h5><p>redux中提供了一个函数combineReducers来合并多个reducer</p>
<p>combinerReducer的实现</p>
<p>​    它会将reducer合并，并且返回一个combation函数相当于是新的reducer</p>
<p>​    在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state；</p>
<p>   新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新；</p>
<p><img src="https://img1.imgtp.com/2022/09/12/lfwbA1yr.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220620163958.png"></p>
<h5 id="75-useSelector"><a href="#75-useSelector" class="headerlink" title="75.useSelector()"></a>75.useSelector()</h5><div class="code-wrapper"><pre><code class="hljs pf">import React <span class="hljs-keyword">from</span> &#x27;react&#x27;
import &#123; shallowEqual, useSelector &#125; <span class="hljs-keyword">from</span> &#x27;react-redux&#x27;

export <span class="hljs-keyword">const</span> CounterComponent = () =&gt; &#123;
  <span class="hljs-keyword">const</span> counter = useSelector((<span class="hljs-keyword">state</span>) =&gt; <span class="hljs-keyword">state</span>.counter,shallowEqual)
  return <span class="hljs-variable">&lt;div&gt;</span>&#123;counter&#125;&lt;/div&gt;
&#125;
//在hook中使用redux,使用useSlectore来获取<span class="hljs-keyword">state</span></code></pre></div>

<h5 id="76-useDispatch"><a href="#76-useDispatch" class="headerlink" title="76.useDispatch()"></a>76.<code>useDispatch()</code></h5><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> dispatch = useDispatch()<span class="hljs-comment">//派发action</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs smali">export<span class="hljs-built_in"> const </span>Todos = () =&gt; &#123;
 <span class="hljs-built_in"> const </span>dispatch = useDispatch()

  useEffect(() =&gt; &#123;
    dispatch(fetchTodos())
    // Safe to<span class="hljs-built_in"> add </span>dispatch to the dependencies<span class="hljs-built_in"> array</span>
<span class="hljs-built_in"></span>  &#125;, [dispatch])
&#125;</code></pre></div>

<h5 id="77-useStore"><a href="#77-useStore" class="headerlink" title="77.useStore()"></a>77.<code>useStore()</code></h5><p>替代createStore()</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/react/" class="category-chain-item">react</a>
  
  
    <span>></span>
    
  <a href="/categories/react/note/" class="category-chain-item">note</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>react18 学习笔记</div>
      <div>http://example.com/2022/08/30/react18-学习笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-html-css/" title="前端八股文-html-css">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">前端八股文-html-css</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/23/pinia%E7%AC%94%E8%AE%B0/" title="pinia笔记">
                        <span class="hidden-mobile">pinia笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
