

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="1.margin-left的值如果是百分比时，相对于他的包含块的宽度的百分比，即他的父元素  2.性能优化点：link ref&#x3D;&#96;dns-prefetch&#96;dns预获取，在资源加载之前获取到真实的ip地址  3.rgb R红 G绿 B蓝  \#ff0000 十六进制表示法  rgb(0，0，0) 十进制表示  4.image&#x2F;vedio是行内可替换元素，不是行内块级元素  5.line-hight">
<meta property="og:type" content="article">
<meta property="og:title" content="前端系统课笔记">
<meta property="og:url" content="http://example.com/2022/08/14/%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.margin-left的值如果是百分比时，相对于他的包含块的宽度的百分比，即他的父元素  2.性能优化点：link ref&#x3D;&#96;dns-prefetch&#96;dns预获取，在资源加载之前获取到真实的ip地址  3.rgb R红 G绿 B蓝  \#ff0000 十六进制表示法  rgb(0，0，0) 十进制表示  4.image&#x2F;vedio是行内可替换元素，不是行内块级元素  5.line-hight">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/ehewKeMN.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/B3g8Atxi.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/lwe19xZA.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/hbsvpJ1A.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/YJJTxHz8.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/frDfleO9.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/3FHLdHM8.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/EzcYmE14.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/cVkjgfjQ.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/EQg1fUBC.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/aIkHlWXU.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/KQev7yPJ.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/0fcGhnc0.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/MDMfI710.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/BXFFyjjm.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/OJQOJUb1.png">
<meta property="og:image" content="https://img1.imgtp.com/2022/08/14/ws0WolVm.png">
<meta property="article:published_time" content="2022-08-14T00:48:18.000Z">
<meta property="article:modified_time" content="2022-11-02T08:58:40.077Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img1.imgtp.com/2022/08/14/ehewKeMN.png">
  
  
  
  <title>前端系统课笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Piggy的记录版</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端系统课笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-14 00:48" pubdate>
          2022年8月14日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          34k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          287 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端系统课笔记</h1>
            
            
              <div class="markdown-body">
                
                <div class="code-wrapper"><pre><code class="hljs stata">1.margin-left的值如果是百分比时，相对于他的包含块的宽度的百分比，即他的父元素

2.性能优化点：link ref=`dns-prefetch`dns预获取，在资源加载之前获取到真实的ip地址

3.rgb R红 <span class="hljs-keyword">G</span>绿 B蓝  \#ff0000 十六进制表示法  rgb(0，0，0) 十进制表示

4.image/vedio是行内可替换元素，不是行内块级元素

5.<span class="hljs-keyword">line</span>-hight是继承属性

6.#表示多个属性是以逗号分隔

7.+表示多个属性是以空格分隔

8.text-align 时将行内元素相对于父级块元素进行居中例如img 文本 <span class="hljs-keyword">input</span>等

9.text-ident和width以em为单位的时候是相对于自身的，font-size可以从父元素继承，如果父元素设置了font-size则会继承下来并相对于自身

10.普遍兄弟选择器只能选中下面的所有兄弟元素

11.script标签放到html的头部时要加<span class="hljs-keyword">window</span>.onload

12.伪类hover,link,visited,active的执行顺序 LVHA

13.除了a标签，hover和active也可以用在其他元素上

14.a元素没有设置伪类，默认所有伪类都是相同的设置

15.::first-<span class="hljs-keyword">line</span>选中首行元素
::first-letter选中首字母
元素之间的间隙默认是换行符，去掉换行符可以

::after&#123;
content:url(<span class="hljs-string">&quot;./image/icon.svg&quot;</span>);<span class="hljs-comment">//可以这样来添加图片</span>
color:green
&#125;


&lt;p&gt;这是上面代码的实现&lt;<span class="hljs-keyword">br</span> /&gt;
  我们有一些 &lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;collection of words and punctuation&quot;</span>&gt;文字&lt;/span&gt; 有一些
  &lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;small popups which also hide again&quot;</span>&gt;提示&lt;/span&gt;。&lt;<span class="hljs-keyword">br</span> /&gt;
  把鼠标放上去&lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;not to be taken literally&quot;</span>&gt;看看&lt;/span&gt;。
&lt;/p&gt;
<span class="hljs-comment">//自定义属性</span>
::after伪元素，attr()CSS表达式和一个自定义数据属性 data-<span class="hljs-keyword">descr</span> 创建一个纯CSS
 content: attr(data-<span class="hljs-keyword">descr</span>);
 
 
 16.怎么画0.5px的线
 17.常见的继承属性：font-size,font-weight,font-family,<span class="hljs-keyword">line</span>-height,color,text-align一般和文本有关的
 
1.  css的权重
 important 10000
 内联选择器 1000
 id选择器 100
 类选择器，属性选择器，伪类 10
 元素选择器，伪元素 1
 通配选择器  0
19.img，vedio,<span class="hljs-keyword">input</span>是行内替换元素  和其他行内元素在一行显示，可以设置宽高
	行内非替换元素不可以设置宽高
20.伪元素是行内非替换元素，不可以设置宽高，必须转成行内块级元素和块级元素，在使用伪元素过程中必须加content
21.不要在p元素里面放块元素
22.行内元素不要放块级元素，只能放行内元素
23.设置元素不可见的方式
	1.<span class="hljs-keyword">display</span>:none 不占据任何空间
	2.visibility:hidden占据空间不可见
	3.设置颜色透明度
	4.background:transparent可以是背景颜色透明
	5.opacity:1,可以设置透明度，但是会使子元素也会变透明，具有穿透性
24.padding:10px 20px 30px 写三个值得时候，左边没有值，用右边的替代
25.border-radius百分比圆角水平方向是width+border的百分比，圆角垂直方向是height+border的百分比
	border-radius:50%是个圆，超过百分之50%也是圆，超过50%，无效
26.margin
	margin的传递 左右margin不传递
	margin-top的传递 如果块级元素顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top就会传递给父元素
	margin-bottom
	如果块级元素的底部线和父元素的底部线出现重叠，且父元素高度为auto时，会传递
	解决：1.父元素设置border
		 2.父元素使用padding
		 3.触发bfc
	上下margin的折叠 
	兄弟块元素上下两个margin合并成一个margin，折叠后取较大的值。解决方法只设置一个
	父子之间折叠，也会出线相同的情况
27.outline  外轮廓不占据空间，默认显示在border外面 outlone:none		可以去除a元素，<span class="hljs-keyword">input</span>元素focus状态下的默认外轮廓	
28.box-shadow:offset-x offset-y blur(模糊度) 向外扩散的值 color ，多个阴影以逗号分隔，会叠加
29.text-shadow:文字添加阴影
27.行内非替换元素的注意事项
	1.不可以设置width和height
	2.设置margin-top.margin-bottom不生效，margi-left和margin-right生效
	3.设置padding-top,padding-bottom会不等高，且不占据空间，设置padding-right和padding-left生效
	4.设置border和padding给相同效果
28.html5语义化标签
	&lt;header&gt;
	&lt;nav&gt;
	&lt;section&gt;
	&lt;artical&gt;
	&lt;aside&gt;
	&lt;footer&gt;
29.vedio和audio时行内替换元素
   在针对不同的播放格式写法
   &lt;vedio src=<span class="hljs-string">&quot;&quot;</span>&gt;
   		&lt;source src=<span class="hljs-string">&quot;.../....mp4&quot;</span>&gt;&lt;/source&gt;
   		&lt;source src=<span class="hljs-string">&quot;.avi&quot;</span>&gt;&lt;/source&gt;
   		&lt;source src=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/source&gt;
   		&lt;p&gt;该浏览器不支持&lt;/p&gt;
   &lt;/vedio&gt;
30.data-*自定义属性，可以html和js中进行数据传递
31.white-space:normal|nowrap|pre|.....
32.text-overflow:clip|esclip text-overflow必须在overflow不是visible才生效
33.css函数
	1.<span class="hljs-keyword">var</span> 定义CSS变量
		属性名要以--开头
		html&#123;
			--main-color:#fffff
		&#125;
		div&#123;
			color:<span class="hljs-keyword">var</span>(--main-color)
		&#125;
	2.calc 计算CSS值，
	3.blur  高斯模糊--毛玻璃效果  blur(radius)可以应用于图片或者元素，radius模糊半径
			可以和filter一起使用。filter:blur(5px)，会使所有子元素都有高斯模糊
			图片的高斯模糊也可以在图片上添加一个遮盖层，用定位元素
			父元素：position:relative
			.cover&#123;
				position:absolute
				top:0
				left:0
				right:0
				bottom:0
				background:rgba(0,0,0,.5)<span class="hljs-comment">//透明效果</span>
				background-filter:blur(5px)<span class="hljs-comment">//高斯模糊</span>
			&#125;
	4.gradient 颜色渐变函数 是一种&lt;image&gt;css数据类型的子类型，用于图片颜色的过度转变
	  liner-gradient 线性渐变 background-image:linear-gradient(to right top ,red,blue)     
34.background背景色对也border,padding有效
   color前景色对border也是有效的，border没有设置颜色时，会使用color的值
  35.浏览器前缀：-o-,-xv-,-ms-,-mso-,0moz-.-webkit-
36.bfc 兄弟块元素margin折叠
35.媒体查询
36.css单位
	em 
	rem
	px
	vw/vh
	%
37.less
	定义变量 @mainColor:#ffff
	使用变量 @mainColor
	兼容css
	
	&amp;:hover &amp;::after
	less的运算
	less的混合(Mixins)
	    .box2(@borderwidth:1px,@borderColor:red)&#123;
	    	border:@borderwidth solid @borderColor
	    &#125;
	    .box-size&#123;
	    	width:100px;
	    	height:200px
	    &#125;
		.box&#123;
		<span class="hljs-comment">//混入方式,可以传参</span>
			.box2(2px,green)
			width:.box-size[width]<span class="hljs-comment">//混入和映射结合使用</span>
			&amp;:extend(.box-size) <span class="hljs-comment">//继承</span>
		&#125;
		
	less内置函数
		.box&#123;
			color:color(red)<span class="hljs-comment">//将转换成16进制</span>
			width:convert(100px,<span class="hljs-string">&quot;in&quot;</span>)单位准换，转成英寸
			<span class="hljs-built_in">floor</span>()向下取整
			<span class="hljs-built_in">ceil</span>()向上取整
		&#125;
	less的作用域：查找一个变量时，会在本地和混入先查找，然后再父级查找
	less的注释
	less的导入 import
	
38.移动端适配
   视口viewport
   	布局视口
   	视觉视口
   	理想视口
   	&lt;<span class="hljs-keyword">meta</span> name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=980px&quot;</span>&gt;<span class="hljs-comment">//修改布局视口的宽度，对pc端无效</span>
   	&lt;<span class="hljs-keyword">meta</span> name=<span class="hljs-string">&quot;viewport&quot;</span> content=&quot;device-width，initial-<span class="hljs-keyword">scal</span>=1.0,user-scalable=<span class="hljs-keyword">no</span>
   	minimun-<span class="hljs-keyword">scal</span>=1.0,maximun-scale=1.0
   	&gt;
39.	css的相对单位em,是相对于自身的font-size来进行定位的，如果自己已经定义了font-size的px，则用自身的font-size,否则就继承自父元素的font-size
	rem是基于根元素的字体的大小
	vw是视窗宽度的1%
	vh是视窗高度的1%
40.再pc端，布局视口和视觉视口是同一个，不用区分
	默认情况下，一个在PC端的网页在移动端会如何显示呢？
 第一，它会按照宽度为980px来布局一个页面的盒子和内容；
 第二，为了显示可以完整的显示在页面中，对整个页面进行缩小
我们相对于980px布局的这个视口，称之为布局视口（layout 
viewport）；
 布局视口的默认宽度是980px；
	视觉视口（visual viewport）
 如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域
就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用
户的可见区域中；
 那么显示在可见区域的这个视口，就是视觉视口（visual viewport）
41.适配方案 – rem+动态html的font-size
   使用该方案有两个问题
   	 问题一：针对不同的屏幕，设置html不同的font-size；
     问题二：将原来要设置的尺寸，转化成rem单位；
    方案一：媒体查询
     可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸；
     缺点：
    ✓ 1.我们需要针对不同的屏幕编写大量的媒体查询；
    ✓ 2.如果动态改变尺寸，不会实时的进行更新；
    ◼ 方案二：编写js代码
     如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码；
     方法：
    ✓ 1.根据html的宽度计算出font-size的大小，并且设置到html上；
    ✓ 2.监听页面的实时改变，并且重新设置font-size的大小到html上；
    
    rem的单位换算
	方案一：手动换算
	方案二：less/scss函数
	◼ 方案四：VSCode插件
	 px to rem 的插件，在编写时自动转化
	◼ 方案四：VSCode插件
	 px to rem 的插件，在编写时自动转化三：postcss-pxtorem
	
42。<span class="hljs-keyword">meta</span>标签的作用
	可以在head中定义元信息，例如 比如标题title、样式style、link外部资源等；
     <span class="hljs-keyword">meta</span>用于定义那些不能使用其他定元相关（<span class="hljs-keyword">meta</span>-related）元素定义的任何元数据信息；
    	<span class="hljs-keyword">meta</span> 元素定义的元数据的类型包括以下几种：
             如果设置了 charset 属性，<span class="hljs-keyword">meta</span> 元素是一个字符集声明，告诉文档使用哪种字符编码。
             如果设置了 http-equiv 属性，<span class="hljs-keyword">meta</span> 元素则是编译指令。
             如果设置了 name 属性，<span class="hljs-keyword">meta</span> 元素提供的是文档级别（document-level）的元数据，应用于整个页面。
            	例如：robots，author，<span class="hljs-keyword">Copyright</span>，description，keywords
            	
 43.link图标
 	&lt;link rel=<span class="hljs-string">&quot;icon&quot;</span> href=<span class="hljs-string">&quot;https:;;;;&quot;</span> /&gt;
 	也可以直接将该favicon.ico直接置于根目录下，不需要使用link来引入，因为大部分浏览器都可以识别
 	
 	
 44.CSS样式的字符编码
 	开发中推荐在CSS的开头编写@charset指定编码：@import <span class="hljs-string">&quot;utf-8&quot;</span>
 45.全局属性data-*
 	data设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到；
	通常用于HTML和JavaScript数据之间的传递；
46.<span class="hljs-string">&quot;&quot;</span>==null <span class="hljs-comment">//false</span>
	null和undefined不能转换成任何数据类型进行比较
	
47.<span class="hljs-keyword">const</span> obj=&#123;
	[Symbol.toPrimitive]()&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span>
	&#125;
&#125;

48.转换成boolean的方式
	Boolean(a)
	!!a
49.switch case 是严格匹配===，还要防止case穿透

50.npx
npx 是 npm v5.2.0 引入的一条命令（ npx ），是一个 npm 包执行器。我们可以使用 npx 来执行各种命令。

主要有以下特点：

临时安装可执行依赖包，不用全局安装，不用担心长期的污染。

可以执行依赖包中的命令，安装完成自动运行。

自动加载 node_modules 中依赖包，不用指定 <span class="hljs-variable">$PATH</span> 。

可以指定 node 版本、命令的版本，解决了不同项目使用不同

npx 执行流程如下：

到 node_modules/.bin 路径检查对应的命令是否存在，找到之后执行；

没有找到，就去环境变量 <span class="hljs-variable">$PATH</span> 里面，检查对应命令是否存在，找到之后执行;

还是没有找到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。
51.函数默认的返回值是undefined
52.递归
53.斐波那契数列
	function fibonacci(<span class="hljs-keyword">n</span>)&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">n</span>===1||<span class="hljs-keyword">n</span>===2) <span class="hljs-keyword">return</span> 1
    <span class="hljs-keyword">return</span> fibonacci(<span class="hljs-keyword">n</span>-1)+fibonacci(<span class="hljs-keyword">n</span>-2)
  &#125;
54.立即执行函数
	1.会立即执行
	2.函数有独立的作用域，可以避免外界访问或者修改内部的变量，
	3.可以有参数和返回值
	4.匿名函数多种写法
			(function()&#123;
			
			&#125;)()
            <span class="hljs-comment">// 匿名函数多种写法</span>
            (function (fn) &#123;
              console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;立即执行函数&quot;</span>);
            &#125;)();

            <span class="hljs-comment">// + - ！都可以，但是不要这样用</span>
            +(function foo() &#123;
              console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;立即执行函数&quot;</span>);
            &#125;)();
	5.应用：。
		1.解决命名冲突的问题，防止全局变量的命名冲突
		2.<span class="hljs-keyword">const</span> btnRtm1 = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = 0; i &lt; btnRtm.length; i++) &#123;
  <span class="hljs-keyword">var</span> btn = btnRtm[i];
  (function (<span class="hljs-keyword">m</span>) &#123;
    btn.onclick = function () &#123;
      console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">m</span>);
    &#125;;
  &#125;)(i);
&#125;
<span class="hljs-comment">// 打印 4 4 4 4 .....</span>
<span class="hljs-comment">// 立即执行函数可以解决上述问题还有for循环中有异步代码例如setTimeout，也可以用let解决</span>
<span class="hljs-comment">// 因为在如下代码中，但执行onclick执行的时候，此时for循环已经执行完，i已经变成btnRtm.length 所以执行代码永远是4 4 4 ，而使用立即执行函数，会每次将i作为参数传入立即执行函数中，尽管i执行完之后已经变成4，但是m存储这0 1 2 3 </span>
<span class="hljs-keyword">const</span> btnRtm = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = 0; i &lt; btnRtm.length; i++) &#123;
  <span class="hljs-keyword">var</span> btn = btnRtm[i];
  (function (<span class="hljs-keyword">m</span>) &#123;
    btn.onclick = function () &#123;
      console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">m</span>);
    &#125;;
  &#125;)(i);
&#125;
<span class="hljs-comment">// 打印 1 2 3 4....</span>
<span class="hljs-keyword">const</span> btnRtm3 = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);
<span class="hljs-keyword">for</span> (let i = 0; i &lt; btnRtm.length; i++) &#123;
  <span class="hljs-keyword">var</span> btn = btnRtm[i];

  btn.onclick = function () &#123;
    console.<span class="hljs-built_in">log</span>(i);
  &#125;;
&#125;
<span class="hljs-comment">// 打印1 2 3 4 .....</span>

55.js代码规范
56.Object的key是字符串
57.Object可以使用delete来删除属性，Object.name/Object[<span class="hljs-string">&quot;name&quot;</span>]来获取，或者修改属性，obj[name]是计算属性，name是一个变量
58.Object 遍历可以使用forin,或者Object.keys()   
59.栈内存和堆内存
	原始数据类型是在栈内存
	引用类型实在堆内存
60.包装类型，
   当有包装类型的原始数据类型可以调用方法，是因为js引擎会将原始类型转换成包装类调用对应的方法
   123..<span class="hljs-keyword">toString</span>(2)<span class="hljs-comment">//转换成二进制</span>
   toFixed(2)保留两位小数。是四舍五入
   parseInt===Number.parseInt
  
   String类
   length
   str[0]
   charAt(0)<span class="hljs-comment">//字符位置</span>
   <span class="hljs-keyword">for</span>
   <span class="hljs-keyword">for</span>...of
   <span class="hljs-keyword">for</span>...<span class="hljs-keyword">in</span>
   字符串是不可变的
   	例如：<span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;name&quot;</span>;
		 str[0] = <span class="hljs-string">&quot;v&quot;</span>;
		 console.<span class="hljs-built_in">log</span>(str);<span class="hljs-comment">//name</span>
		 
		 <span class="hljs-keyword">var</span> str = str.toUpperCase();
			console.<span class="hljs-built_in">log</span>(str);<span class="hljs-comment">//这是新的字符串，不是原来的</span>
	str.indexOf(searchString,fromIndex)<span class="hljs-comment">//返回值是索引值</span>
	str.includes()
	str.startsWidth(<span class="hljs-string">&quot;1&quot;</span>)<span class="hljs-comment">//是否以1开头</span>
	str.endsWidth()
	str.<span class="hljs-keyword">replace</span>()
	str.slice()
	str.substring()
	str.<span class="hljs-built_in">substr</span>()
	字符串拼接+，cocat()
	<span class="hljs-built_in">trim</span>()
	<span class="hljs-keyword">split</span>()
	<span class="hljs-keyword">replace</span>()替换，是纯函数
61.Array
	splice()<span class="hljs-comment">//添加，删除，替换</span>
	pop
	push
	shift
	unshift
	arr.length可以获得数组的长度，修改数组的长度，删除数组
	如果arr.length为6
	arr.length=2<span class="hljs-comment">//可以删除剩余的元素</span>
	arr.length=0可以删除所有元素
	arr.length=8<span class="hljs-comment">//可以扩容</span>
	
	arr.slice()
	arr.join()
	arr.concat()
	arr.indexOf()
	arr.find(arr.find(callback[, thisArg]) callback(element,index,array) <span class="hljs-comment">//会返回匹配到的元素，匹配到多个的时候会返回第一个   find 方法不会改变数组</span>
	arr.findIndex( 	)
	<span class="hljs-comment">//实现find</span>
	Array.prototype.myFind = function (callback, thisArg) &#123;
  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;
    <span class="hljs-keyword">if</span> (callback.call(thisArg, this[i], i, this)) &#123;
      <span class="hljs-keyword">return</span> this[i];
    &#125;
  &#125;
&#125;;
<span class="hljs-comment">//实现forEach</span>
	Array.prototype.MyForEach = function (callback, thisArg) &#123;
  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;
    callback.apply(thisArg, [this[i], i, this]);
  &#125;
&#125;;
includes()
arr.<span class="hljs-keyword">sort</span>()
<span class="hljs-comment">// 默认是降序</span>
arr.<span class="hljs-keyword">sort</span>((item1, item2) =&gt; &#123;
  <span class="hljs-keyword">return</span> item1.age - item2.age;
&#125;);
console.<span class="hljs-built_in">log</span>(arr);
<span class="hljs-comment">// 升序</span>
arr.<span class="hljs-keyword">sort</span>((item1, item2) =&gt; &#123;
  <span class="hljs-keyword">return</span> item2.age - item1.age;
&#125;);
console.<span class="hljs-built_in">log</span>(arr);


arr.<span class="hljs-built_in">reverse</span>()

arr.filter()
Array.prototype.myfilter = function (callback, thisArg) &#123;
  let newArr = [];
  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;
    <span class="hljs-keyword">if</span> (callback.call(thisArg, this[i], i, this)) &#123;
      newArr.push(this[i]);
    &#125;
  &#125;
  <span class="hljs-keyword">return</span> newArr;
&#125;;
arr.map()
arr.reduce()

Date类型
new <span class="hljs-built_in">Date</span>()
Date.now()<span class="hljs-comment">//当前事件的时间戳</span>
date.getTime()<span class="hljs-comment">//将时间转换成时间戳</span>
date.valueOf()<span class="hljs-comment">//也是一样</span>
+date<span class="hljs-comment">//也可以</span>

将字符串转换成时间戳
<span class="hljs-keyword">var</span> dateString = <span class="hljs-string">&quot;2020-5-15&quot;</span>;
console.<span class="hljs-built_in">log</span>(new <span class="hljs-built_in">Date</span>(dateString).getTime());
console.<span class="hljs-built_in">log</span>(Date.<span class="hljs-keyword">parse</span>(dateString));
==================================================================================
Dom
62.所有节点都继承自EventTarget
63.document对象-可以获得整个网页node节点
	<span class="hljs-keyword">var</span> html=document.documnetElement
	<span class="hljs-keyword">var</span> body=documnet.body
	body,html,body都是documnet的属性
	获取所有节点的导航 <span class="hljs-keyword">var</span> bodyEl=document.body
	获取所有子节点 bodyEl.childNodes  换行符也属于text节点，注释是comment节点
	获取下一个兄弟节点 bodyEl.nextSibling
	前兄第节点 preSibling</code></pre></div>

<p>打印body的子节点</p>
<p><img src="https://img1.imgtp.com/2022/08/14/ehewKeMN.png" srcset="/img/loading.gif" lazyload alt="屏幕截图 2022-05-18 100006.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/14/B3g8Atxi.png" srcset="/img/loading.gif" lazyload alt="屏幕截图 2022-05-18 100042.png"></p>
<div class="code-wrapper"><pre><code class="hljs stata">64.获取子元素
	bodyEl.children
65.获取第一个子节点  bodyEl.firstElementChild    bodyEl.children[0]  
	bodyEl.nextElementSibling
66.Document和Element的关系
   没有关系。document.body,body是他的属性，不是继承类，body:document.querySelectAll(<span class="hljs-string">&quot;body&quot;</span>) ,所以Documnet和Element不是继承的关系，ELment是body的值
67.<span class="hljs-keyword">table</span>和<span class="hljs-keyword">form</span>之间的导航
68.document.getElementById(<span class="hljs-string">&quot;&quot;</span>)
   documnet.querySelector(<span class="hljs-string">&quot;&quot;</span>)
   document.querySlectorAll(<span class="hljs-string">&quot;&quot;</span>)
   document.getElementsByName(<span class="hljs-string">&quot;&quot;</span>)
   document.getElementsByTagName(<span class="hljs-string">&quot;&quot;</span>)
   document.getElementsByClassName(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//这3个是实时的</span>
69.NodeList是类数组对象，但是可以用<span class="hljs-keyword">forEach</span>,可以用Array.from()转换成array
70.节点类型判断
	通过childNodes获取的节点判断节点类型用nodeType属性 1.元素节点 3.文本 8，注释节点
71.nodeName获取节点名称，tagName元素名
72.data用于非元素节点获取数据 innerHTML 获取元素 textContent获取文本
	设置的时候，innerHTML和innerContent都可以设置文本，innerContent设置元素不会被解析为html元素，会当作普通文本
	innerHTML 将会删除所有该元素的后代并以给出的 htmlString 替代
	不是追加
73.outerHTML会获取本身及其子元素
74.常见全局属性 id style title <span class="hljs-keyword">class</span> hidden:相当于设置<span class="hljs-keyword">display</span>:none
	<span class="hljs-keyword">on</span>+事件
75.attribute
	html定义的是标准attribute
	自定义的属性是非标准attribute
		所有attribute都支持的方法
			element.hasAttribute(<span class="hljs-keyword">e</span>)
			element.getAttribure(<span class="hljs-keyword">e</span>)
			element.setAttribute(<span class="hljs-keyword">e</span>)
			element.removeAttribute(<span class="hljs-keyword">e</span>)
			element.attributes-&gt;like array
			
			这些对大小写不敏感，而且返回值都是string
76.property
对象中的属性称为property
元素中的属性称为attribute
标准的attribute中在对应的对象模型中都有对用的property
property和attribute会相互影响
使用点语法也可以获得元素的属性
77.className和classList
	classList是可迭代对象
78.style在js中要使用驼峰
	多个样式可以使用style.cssText=<span class="hljs-string">&quot;&quot;</span>这个不用写驼峰，但是会覆盖，不推荐
78.style的读取getComputedStyle()，ele.style只能读取内联样式，就是直接在元素上定义的样式，
widow.getComputedStyle(ele,[pseudoElt])可以读取所有的css属性，包括外部样式，但是getComputedStyle是只读属性
79.data-*
80.<span class="hljs-keyword">var</span> el=document.createElement(<span class="hljs-string">&quot;element&quot;</span>)<span class="hljs-comment">//创建元素</span>
	el.className=<span class="hljs-string">&quot;&quot;</span>
	el.classList.add(<span class="hljs-string">&quot;&quot;</span>)
	boxel.<span class="hljs-keyword">append</span>(el)<span class="hljs-comment">//向父元素插入创建的元素，默认是插入最后</span>
	boxel.prepend(el)<span class="hljs-comment">//添加到父元素的里面的最前面</span>
	boxel.before(el)<span class="hljs-comment">//添加到元素的前面</span>
	boxel.after(el)<span class="hljs-comment">//添加到元素后面</span>
	boxel.replacewith(...node|string)<span class="hljs-comment">//替换元素</span>
	appendChild,insertbefore这些方法比较旧了
81.el.remove()<span class="hljs-comment">//将自己移除</span>
82.克隆<span class="hljs-keyword">var</span> newEl=el.cloneNode()<span class="hljs-comment">//默认是不会克隆子节点cloneNode(true)会克隆子节点</span>
83.获取元素的宽高 ele.width ele.height
84.clientWidth:元素content+padding(不包含滚动条)
	clientTop:border-top的宽度。clientLeft
	offsetWidth:元素的完整宽度content+border+padding
	offsetLeft 距离父元素左边的距离 offsetTop
	scrollHeight 元素可滚动的高度
	scrollTop 滚动条滚动的距离
85.<span class="hljs-keyword">window</span>的大小和滚动
   <span class="hljs-keyword">window</span>.outerWidth<span class="hljs-comment">//</span>
   <span class="hljs-keyword">window</span>.innerWidth<span class="hljs-comment">//窗口的宽度，不包括调试窗口和工具栏</span>
   document.doeumnetElement.offsetWidth document.doeumnetElement.offsetHeight
   <span class="hljs-keyword">window</span>.scrollX  获取x轴的滚动位置 <span class="hljs-keyword">window</span>.scrollY Y轴的滚动位置  也可以用别名pagexOffset  pageYOffset
   设置滚动的位置 <span class="hljs-keyword">window</span>.scrollBy(x,y)<span class="hljs-comment">//在原来的位置基础上叠加滚动的位置</span>
   	<span class="hljs-keyword">window</span>.scrollTo(x,y)<span class="hljs-comment">//滚动到绝对的位置，到了位置不会变</span>
   	<span class="hljs-keyword">window</span>.onscroll<span class="hljs-comment">//监听滚动</span>
   	
86.事件
	<span class="hljs-keyword">on</span>+event
	ele.addEventListener(<span class="hljs-string">&quot;event&quot;</span>,callback)
87.事件流
	事件冒泡
	事件捕获
	捕获阶段-》目标阶段-》冒泡阶段
88.event常见属性方法
	event.<span class="hljs-keyword">type</span>:事件类型
	event.target:目标元素
	event.currentTarget:绑定事件的元素
	event.offsetX
	event.clientX
	event.pageX
	event.screenX
	target和currentTarget的区别
		target事件发生的对象，currentTarget是事件绑定的对象，如果
		如果绑定事件的元素和触发事件的元素相同时，target===currentTarget
	event.preventDefault()
	event.propagetion()
	
	<span class="hljs-keyword">on</span>+event中普通函数中this指向绑定事件的元素。addEentListener()也是一样
89.EventTarget类
	所有节点，元素都继承自eventtarget，<span class="hljs-keyword">window</span>也是
	eventTarget.removeEventListener(event,callbackName,)
	eventTarget.dispatchEvent()
90.事件委托
91.import * from 是否包含export default
	export &#123;&#125;和export <span class="hljs-keyword">const</span> a ,export <span class="hljs-keyword">const</span> b有区别吗
92.&lt;div id=<span class="hljs-string">&quot;box&quot;</span>&gt;&lt;/div&gt;
	box.click()<span class="hljs-comment">//如果是id，也可以这样写但是不推荐</span>
92.常见的鼠标事件
	onclick <span class="hljs-comment">//只能接受event作为唯一的参数，且不用再调用的时候写</span>
	oncontextmenu
	onmousedown
	onmouseup
	onmousemove
93.mouseover和mouseenter的区别
	mouseenter和mouseleave
	不支持冒泡
	进入子元素依然属于该元素只会触发子元素的mouseenter，父元素没反应
	mouseover和mouseout
	支持冒泡
94.键盘事件
	onkeydown
	onkeypress
	onkeyup
	
	event.code 
	event.key
95.onfocus和onblur
96.oninput和onchange
99.表单事件 onsubmit onreset
100.onload和DOMContentLoaded
101.onresize
102.定时器
	setTimeout和setInterval是<span class="hljs-keyword">window</span>的方法
103.ontransitioned监听动画的结束后调用
104.<span class="hljs-keyword">tab</span>切换中切换.active的方法
	1.<span class="hljs-keyword">for</span>循环
	2.使用documnet.queryslector(<span class="hljs-string">&quot;.active&quot;</span>)修改
	3.使用在外面进行变量记录
105.BOM浏览器对象模型
106.node:<span class="hljs-keyword">global</span>==lobalThis
	<span class="hljs-keyword">window</span>:<span class="hljs-keyword">window</span>==globalThis
	放到<span class="hljs-keyword">window</span>的属性全局都可访问
	用<span class="hljs-keyword">var</span>申明的全局对象都放到<span class="hljs-keyword">window</span>对像中
	<span class="hljs-keyword">var</span> openWin=<span class="hljs-keyword">window</span>.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//打开网址</span>
	<span class="hljs-keyword">window</span>.<span class="hljs-keyword">close</span>()<span class="hljs-comment">//只能关闭通过open()打开的新的窗口</span>
107.<span class="hljs-keyword">window</span>常见事件
	<span class="hljs-keyword">window</span>.onfocus
	<span class="hljs-keyword">window</span>.onblur
	<span class="hljs-keyword">window</span>.onhashchange
108.location对象属性，用于表示<span class="hljs-keyword">window</span>当前连接url信息
	location.href<span class="hljs-comment">//完整url</span>
	<span class="hljs-comment">//url信息</span>
	location.hostname
	location.host
	loaction.protocol
	location.port
	location.pathname
	location.hash
	loacation.<span class="hljs-keyword">search</span>
	<span class="hljs-comment">//location方法</span>
	loacation.assign()<span class="hljs-comment">//打开新的网页，是加入历史记录站，可以返回</span>
	location.<span class="hljs-keyword">replace</span>()<span class="hljs-comment">//替代当前url,不可以返回</span>
	loaction.reload()<span class="hljs-comment">//重新加载</span>
109.URLSearchParams
	<span class="hljs-keyword">var</span> searchParams=new URLSearchParams(str)
	<span class="hljs-built_in">get</span>(&quot;name“)
	<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;zzzz&quot;</span>)
	has()
	<span class="hljs-keyword">set</span>()
	URLSearchParams可以使用<span class="hljs-keyword">for</span>...of
	中文使用encodeURLComponment和decodeURLComponment进行编解码
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] of searchParams) &#123;&#125;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] of searchParams.entries()) &#123;&#125;
110.history
<span class="hljs-comment">//属性</span>
	history,length
	history.state
<span class="hljs-comment">//修改history</span>
	history.pushState(&#123;name:<span class="hljs-string">&quot;mike&quot;</span>,age:18&#125;)
	hsitory.back()
	history.forword()
	history.go(-2)
	replacestate()
111.json
	<span class="hljs-keyword">var</span> item=JSON.stringfy(item)
	<span class="hljs-keyword">var</span> item=JSON.<span class="hljs-keyword">parse</span>(item)
	json的方法还可以实现深拷贝<span class="hljs-keyword">var</span> obj=JSON.<span class="hljs-keyword">parse</span>(JSON.strigfy(obj1))
112.protobuf
113.&amp;gt; &amp;lt;
114.&lt;button onclick=<span class="hljs-string">&quot;add()&quot;</span>&gt;按钮&lt;/button&gt;<span class="hljs-comment">//再元素上事件的写法</span>
115.<span class="hljs-comment">/* 设置图片水平方向和垂直方向上自动居中，随着浏览器大小的变化 */</span>
.img_center&#123;
  position: relative;
  transform: <span class="hljs-keyword">translate</span>(-50%,-%50);
  left: 50%;
  top:50%;
&#125;
</code></pre></div>

<p>116.</p>
<p><img src="https://img1.imgtp.com/2022/08/14/lwe19xZA.png" srcset="/img/loading.gif" lazyload alt="屏幕截图 2022-05-25 175414.png"></p>
<div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">117.</span><span class="hljs-keyword">this</span>的指向
	<span class="hljs-number">1.</span><span class="hljs-keyword">this</span>的指向是由函数调用执行的时候决定的
	<span class="hljs-number">2.</span><span class="hljs-keyword">this</span>的绑定分为：默认绑定：独立函数调用<span class="hljs-keyword">this</span>是指向window,例如fn()
					隐式绑定：对象中<span class="hljs-keyword">this</span>的指向是指向调用的对象，例如obj.fn()
					显示绑定:通过call,apply,bind来进行显示绑定下，<span class="hljs-keyword">this</span>指向绑定的对象
					new的绑定：通过new创建的对象，<span class="hljs-keyword">this</span>会指向新创建的对象
	<span class="hljs-number">3.</span><span class="hljs-keyword">this</span>指向的优先级：new&gt;显示绑定&gt;隐式绑定&gt;默认绑定
	<span class="hljs-number">4.</span>箭头函数是没有<span class="hljs-keyword">this</span>,arguments，是由上层函数作用域来决定，一层一层作用域找
		注意：
		<span class="hljs-keyword">var</span> name=<span class="hljs-string">&quot;mike&quot;</span>
		<span class="hljs-keyword">var</span> obj=&#123;
			
			foo()&#123;
				<span class="hljs-keyword">return</span> ()=&gt;&#123;
					console.log(<span class="hljs-keyword">this</span>.name)
				&#125;
			&#125;
		&#125;<span class="hljs-comment">//this会先去foo中去找，找不到就去全局作用域，对象中没有作用域</span>
		不可以使用显示绑定改变<span class="hljs-keyword">this</span>的指向
	<span class="hljs-number">5.</span>显示绑定中如果指向的是一个基本数据类型，如果有包装类型则转换成包装类
	<span class="hljs-number">6.</span>setTimeout中的<span class="hljs-keyword">this</span>默认指向window
	<span class="hljs-number">7.</span>forEach中<span class="hljs-keyword">this</span>默认指向window，可以通过第二个参数修改
	<span class="hljs-number">8.</span>事件绑定中<span class="hljs-keyword">this</span>指向绑定的元素
	<span class="hljs-number">9.</span>new不可以和apply和call一起使用
	<span class="hljs-number">10.</span>bind的优先级高于call/apply
	<span class="hljs-number">11.</span>new的优先级高于bind
	<span class="hljs-number">12.</span>间接函数引用：
		<span class="hljs-number">1.</span>(obj1.foo=obj2.foo)()这样直接调用，<span class="hljs-keyword">this</span>是默认绑定指向window
		<span class="hljs-number">2.</span>(b=person.sauName)()   <span class="hljs-comment">//window</span>
	<span class="hljs-number">13.</span>foo.apply(<span class="hljs-literal">null</span>)/foo.apply(undefined)指向window
		
	<span class="hljs-number">14.</span>箭头函数可以替代<span class="hljs-keyword">var</span> _this=<span class="hljs-keyword">this</span>来替代，可以获得上层作用域
<span class="hljs-number">118.</span> Array.prototype.slice 来将一个类似于数组的对象（array-like <span class="hljs-keyword">object</span>）转换成一个真正的数组，Aaary.prototye.slice.apply()/bind()
<span class="hljs-number">119.</span>html解析过程中，遇到css文件会下载，但是不会阻止html的解析，但会阻塞render的渲染过程
<span class="hljs-number">120.</span>回流和重绘
<span class="hljs-number">121.</span>script
	defer js的下载和执行不阻塞Dom tree的构建
	defer代码执行的时候Dom构建完成，defer会在DomContentLoad以后执行
	多个defer顺序执行
	defer推荐放在head中
	defer仅适用于外部脚本，对script的内容会忽略
	
	async 多个async不能保证顺序执行，不会组设Dom渲染。不能保证DOMContentLoaded之前或者之后执行行
	async用于独立脚本，没有外部依赖
<span class="hljs-number">122.</span>函数的执行是在函数执行上下文中执行
<span class="hljs-number">123.</span>函数的作用域链再函数创建时就确定了。每个执行上下文都有自己的作用域链</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/hbsvpJ1A.png" srcset="/img/loading.gif" lazyload alt="屏幕截图 2022-05-29 114030.png"></p>
<p>当查找变量的时候，函数首先会在local中寻找，找不到再去上层作用作用域寻找，而这个函数的上层作用域是Window</p>
<p><img src="https://img1.imgtp.com/2022/08/14/YJJTxHz8.png" srcset="/img/loading.gif" lazyload alt="屏幕截图 2022-05-29 120154.png"></p>
<p>124.垃圾回收器</p>
<p>​        1..引用计数</p>
<p>​                    当一个对象有一个引用指向它时，那么这个对象的引用就+1</p>
<p>​                    当一个对象的引用为0时，这个对象就可以销毁掉</p>
<p>​                    这个算法有一个回答的弊端就是会产生循环引用</p>
<p>​        2.标记清除</p>
<p>​        3.标记整理</p>
<p>​        4.分代收集</p>
<p>​        5.增量收集</p>
<p>​        6.闲时收集</p>
<div class="code-wrapper"><pre><code class="hljs 130">125.闭包
	1.狭义：函数引用外层函数的自由变量就是闭包。
	2.通过返回一个函数，外部可以通过这个函数访问这个函数所在作用域链的变量，闭包可以突破作用域链
126.GUI的渲染和js的执行是在同一个线程，是互斥的
127.foo.name,获取函数名
	foo.length//获取行参个数，不会把剩余参数和默认参数计算在内，
	arguments//类数组对象，可以通过下标获取值，有length属性，是可迭代对象，但是本身不可以使用数组的方法，可以通过Array.prototype.map.call(arguments)来使用
	argument转array
	1.for循环，将argument一个个放到数组中
	2.Array.from(argumsnets)
	3.[...arguments]
	4.var arr=Array.prototype.slice.call/apply(arguments)//会截取整段，并返回新的数组
		或者var arr=[].slice.call/apply(arguments)
		箭头函数没有argments,会去上层作用域去找arguments
128.剩余参数   剩余参数必须放到最后
129.剩余参数和argument的区别
	剩余参数是数组，可以使用所有数组方法，arguments是类数组
	剩余参数只包含没有对应形参的实参，arguments包含所有参数
130.纯函数
	相同的输入产生相同的输出，
	不会产生副作用
	不依赖外部变量
	确定输出
	不能修改外部变量
	作用：
		只是单纯的实现自己的业务，不需要关注外部的数据变化
131.函数柯里化
	就是把接受多个函数的函数变成返回接受单一参数的函数
	
	var foo=x=&gt;y=&gt;z=&gt;console.log(x+y+z)shiyo
132.async默认会返回promise
	async的返回值会被promise包裹，相当于Promise.resolve()
	await 后面是一个promsie,则会返回Promise.resolve(res)的值
	如果不是promise，则用Promise.resolve(res)包裹
	await 使用trycatch捕获异常	
133.封装自动转化成柯里化函数
134.组合函数
	组合函数的封装
135.Function.prototype.name   Function.prototype.length Function.prototype.displayName
136.with(obj)&#123;
	console.log(message)//扩展一个语句的作用域链，它首先会去obj里面去找，找不到再去上层作用域找，但是不推荐使用
&#125;
137.eval()
138.严格模式
	开启严格模式的方式
	class和module会自动开启严格模式
	严格模式的限制
		1.无法意外创建全局变量
		2.引起静默模式失败
		3.不能用with
		4.this默认指向undefined,this不会装换成包装类
139.Object.defineProperty(obj,prop.descriptor)
	属性描述符的分类
		1.数据属性描述符：configurable:表示这个属性是否可删除,默认值是false，使用delete不嫩删除，如果设置为false,则不可以配置了，后续其他属性描述符也不可以使用了。就是Configurable:false,后续不可以对这个属性使用Object.defineProperty配置。
		enumerable:是否可以枚举属性，false:forin,Object.keys()这些都不可以美剧，默认是true
		writable:是否可以写入，默认是可以写入，设置为false是只读属性
		value:&quot;mike&quot;,设置属性值
		
		
		如果使用字面量创建对象，则所有属性描述符都是true,object.defineProperty()设置的属性的value
		的优先级会比字面量创建的属性设置的值高
		2.存取属性描述符
		get
		set
		
		wiritable,value和get,set不可以同时使用
140.Object.defineProperties()//同时设置多个属性描述符
141.Object.getOwnPropertyDescriptor(obj, &quot;name1&quot;)//获取某个属性描述符
142.Object.getOwnPropertyDescriptors(obj)//获取所有属性描述符
143.Object.preventExtensions(obj);//不允许扩展属性
144.object.seal(obj)//密封对象，不允许配置和删除属性，增加新的属性
145.Object.freeze(obj)//不能修该现有属性，也不能增加新的属性
146.原型和原型链
	__proto__是浏览器加，非标准的，要看各个浏览器如何实现，建议使用Object.getPrototypeOf(obj)来获取对象的原型
	__proto__隐式原型
	prototype显式原型
	所有的对象都有隐式原型，函数有隐式原型和显示原型
	
	
	当对象获取值的时候p1.address如果实例对象没没有这个属性则会到他的原型练上去寻找
	当对象属性赋值的时候，如果该属性不存在则会在当前对象中新建一个属性赋值，不会修改原型链上的属性的值
	p1.address=&quot;us&quot;//这样不会对原型链上的该属性进行修改
	如果要对原型的属性进行修改：Person.prototype.address=&quot;japan&quot;
	Person.prototype=&#123;
		message:&quot;章&quot;,
		info:&#123;&#125;,
		eating:function()&#123;
		
		&#125;,
		constructor:Person
	&#125;//修改Person的显示原型指向新的对象
	p1.__proto_===Object.prototype
	constructor应该是不可以枚举的，要用Object.deineProperty()来修改定义
	原型链：实例对象在查找某个属性的时候，他先去自己对象寻找，然后再去原型链里面去找，直到找到null为止
147.面向对象的特性:封装，继承，多态
148.使用new关键字创建对象的过程
	1.创建一个空对象
	2.让这个对象的[[prototype]]属性指向该构造函数的prototype对象
	3.让构造函数的中的this指向新创建的对象
	4.执行该构造函数
	5.如果构造函数没有返回一个非空对象，则返回新创建出来的对象
149.原型链的继承

	1.Student.prototype=Person.prototype//这种继承虽然可以继承到Person的方法，但是添加student的方法的时候，会添加到Person原型上，对Person和Student都会有影响
	2.原型链继承
	student.prototype=new Person()//改善上面一种方法，不会对Person.prototype上的方法进行干扰
	但是，如果有和Person相同的属性的时候例如
	function Student(age,gender,name,weight)&#123;
		this.age=age;
		this.gender=gender;
		this.name=name;
		this.weight=weigth
	&#125;
	age,gender属性在pERson里面也有，这样会有代码重复的问题，但是可以获取到自己的age,gender
	如果不写，调用的时候是获取到Person的age和gender,多个实例共享相同的属性了
	3.借用构造函数继承
	  function Student(age,gender,name,weight)&#123;
	  	Person.call(this,age,gender)
	  	this.name=name;
		this.weight=weigth
	  &#125;
	  使用这个方法可以实现属性的继承
	  将2，3方法结合起来就是组合继承
	  student.prototype=new Person(age,gender)//继承父类的方法
	   function Student(age,gender,name,weight)&#123;
	  	Person.call(this,age,gender)//这样没有调用父类的constructor
	  	this.name=name;
		this.weight=weigth
	  &#125;
	  缺点：new student的时候构造函数会调两次，一次Person,一次student，拥有两份父类属性，父类的静态属性和静态方法也没有继承
	  4.寄生组合继承
	  function Student(age,gender,name,weight)&#123;
	  	Person.call(this,age,gender)
	  	this.name=name;
		this.weight=weigth
	  &#125;
	  inhert(Student,Person)
	  Object.assign(Student, Person);//继承静态属性和方法(或者称为类方法或者类属性)
150.原型式继承函数
		// 使用这个方法来处理Object.create()的兼容性问题
        function createObject(o) &#123;
          function F() &#123;&#125;
          F.prototype = o;
          return new F();
        &#125;
        // 封装工具函数实现继承
        function inhert(Subtype, Supertype) &#123;
        	//Subtype.prototype.__proto__=Supertype.prototype
        	//Object.setPrototypeOf(Subtype.prototype,Supertype.prototype)
          // Subtype.prototype = createObject(Supertype.prototype);
          Subtype.prototype = Object.create(Supertype.prototype);//Object.create()不会调用constructor
          Object.defineProperty(Subtype, &quot;constructor&quot;, &#123;
            configurable: false,
            enumerable: false,
            value: Subtype,
            writable: true,
          &#125;);
        &#125;
	  
	  //对象之间的继承
	  	function object(o)&#123;
	  		var obj=&#123;&#125;
	  		obj.__proto__=o.prototype//Object,setPrototypeOf(obj,o.prototype)
	  		return obj
	  	&#125;
151.Object是所有类的父类
152.obj.hasOwnProperty()、//判断是否在自己身上
	&quot;name&quot; in obj//判断属性是否在obj的里面或者原型链上
	for in 遍历原型链可枚举属性和方法
	instanceOf
	Person.protytype.isPrototypeOf(stu)//判断实例是否在莫格原型链上，判断对象之间的继承
153.对象具备__proto__属性。函数有__proto__和prototype属性
154.Person.run()//这个调用的是类方法，protoytype上面的方法是实例方法
155.class定义类
	class会有默认的constructor
	class是的构造函数、原型链的语法糖
156.对象中访问器的写法
	var obj = &#123;
  name: &quot;mike&quot;,
&#125;;
//对象访问器的写法一
Object.defineProperty(obj, &quot;name&quot;, &#123;
  configurable: true,
  enumerable: true,
  get() &#123;
    return obj.name;
  &#125;,
  set(value) &#123;
    obj.name = value;
  &#125;,
&#125;);

//对象访问器的写法二
var obj2 = &#123;
  name: &quot;zhang&quot;,
  get getName() &#123;
    return this.name;
  &#125;,
  set setName(value) &#123;
    this.name = value;
  &#125;,
&#125;;
//三
class Person &#123;
  constructor(name) &#123;
    this._name = name;
  &#125;
  get name() &#123;
    return this._name;
  &#125;
  set name(value) &#123;
    this._name = value;
  &#125;
&#125;
157.类方法/static方法中的this指向类本身
158.class的继承 extend
159.面向对象的三大特性：封装，继承，多态
	多态的条件：1。必须实现继承
			  2.必须有父类引用指向子类对象
			  3.js中可以说到处是多态
160.对象字面量增强：
	1.属性的增强
		var name=&quot;why&quot;
		var obj=&#123;
			name
		&#125;
	2.方法的增强
		var obj=&#123;
			eating()&#123;
			
			&#125;
		&#125;
	3.计算属性名
		obj=&#123;
			[name]:
		&#125;
		
161.数组的解构和对象的解构
	const [name1,name2,name3]=arr
	const &#123;age,name,color&#125;=obj
	
	const [name1,name2,...name3]=arr//将剩下的元素放入name3数组中
	
	const [name1,name2,name3=&quot;default&quot;]=arr//设置默认值
	
	//对象的解构是没有顺序的，根据Key来进行解构
	//对象解构的重命名
	  const &#123;age:age1,name:name1&#125;=obj//重命名为age1,name1
	 //对象解构默认值默认值
	 const &#123;age:age1=18,...other&#125;=obj1//可以使用剩余运算符和默认值
162.手写apply,call,bind
163.词法环境
	词法环境由环境记录和外部词法环境两部分组成
	一个执行上下文关联两个环境
		LexicalEnvironment和VariableEnvirment
		LexicalEnvironment用于处理let和const
		VariableEnvirment用于处理var,function
164.https://262.ecma-international.org/8.0/
165.let和const
	let/const不可以重复声明
	const声明的是引用类型则可以修改const指向的地址的内部的变量，但不可以修改const的指向
	let/const不会出现变量提升，必须先声明再使用，否则会出现暂时性死区
	let/const会提前创建出来，但是不可以被访问，只有赋值的时候才可以访问
	暂时性死区取决于代码执行的顺序，和定义的位置没有关系
	
	var定义的全局变量默认会添加到window上。而let/const不会再window添加任何属性
	var 会被添加到 object environment record而const /let会被添加到decaretive environment record
166.块级作用域
	let/const/function/class声明是有块级作用域的，
	foo()//在这之前不可以访问
	&#123;
		function foo()&#123;&#125;
	&#125;
	foo()//这样可以访问
	浏览器做了特殊处理，可以让块级作用域里面的函数在块级作用域之后被访问
167.立即执行函数会形成闭包，形成自己的作用域
168.for(let i=0;i&lt;btnEls.length;i++)&#123;
	var btnEl=btnEls[i]
	btnEl.onclick=function()&#123;
	console.log(`点击了$&#123;i&#125;按钮`)
	&#125;
&#125;//会形成4个词法环境，每个词法环境都会保存着自己的i，function引用外层的词法环境，所以执行完外层词法不会被销毁，当需要i的时候，会往上层寻找，因为当前词法环境中保存着i</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/frDfleO9.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220606172932.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/14/3FHLdHM8.png" srcset="/img/loading.gif" lazyload alt="QQ截图2022060617452911.png"></p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">169.</span>模板字符串
	<span class="hljs-number">1.</span>普通模板字符串
	<span class="hljs-number">2.</span>标签模板字符串
<span class="hljs-number">170</span>,函数默认值
	<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg1,arg2</span>)&#123;
		arg1=arg1?<span class="hljs-attr">arg1</span>:<span class="hljs-number">0</span>
		arg1=arg1||<span class="hljs-number">0</span>
		arg1=(arg===<span class="hljs-literal">null</span>)||(arg1===<span class="hljs-literal">undefined</span>)?<span class="hljs-number">0</span>:arg1
		<span class="hljs-comment">//es6</span>
		arg1=arg1??<span class="hljs-string">&quot;我是默认值&quot;</span>
	&#125;
	<span class="hljs-title function_">foo</span>(<span class="hljs-params">arg1,arg2=<span class="hljs-string">&quot;why&quot;</span></span>)&#123;&#125;<span class="hljs-comment">//默认参数最好放后面</span>
	剩余参数也是放在后面，如果两个都有的话，剩余参数放后面
	<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">&#123;name,age&#125;=&#123;name=<span class="hljs-string">&quot;why&quot;</span>,age=<span class="hljs-number">18</span>&#125;</span>)&#123;
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age)<span class="hljs-comment">//对传入的对象进行解构赋值，给默认值</span>
	&#125;
	<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">&#123;name=<span class="hljs-string">&quot;why&quot;</span>,age=<span class="hljs-number">18</span>&#125;=&#123;&#125;</span>)&#123;
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age)<span class="hljs-comment">//对象参数的解构赋值，如果传入的参数</span>
		中没有该值name,age，则给name,age赋值
	&#125;
	默认参数不计算在argument内
<span class="hljs-number">171.</span>箭头函数没有显示原型，不可以作为构造函数，不能通过<span class="hljs-keyword">new</span>创建
<span class="hljs-number">172.</span>展开运算符
	<span class="hljs-keyword">var</span> obj=&#123;
		<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;why&quot;</span>,
		<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>
	&#125;
	<span class="hljs-title function_">foo</span>(...obj)<span class="hljs-comment">//这样来用是不可以的，因为函数参数必须是可迭代对象</span>
<span class="hljs-number">173.</span>浅拷贝：就是将对象里面的内容赋值到新的对象里面，如果对象里面还有对象，则只会复制对象的引用
			就是浅拷贝只会拷贝第一层对象
			浅拷贝的方法可以使用展开运算符和<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()
			
<span class="hljs-number">174.</span>ele.<span class="hljs-title function_">append</span>()和ele.<span class="hljs-title function_">appendChild</span>()的区别
	append参数可以是node/string appendChild只能是<span class="hljs-title class_">Node</span>,<span class="hljs-title function_">append</span>()没有返回值，appendChild会返回插入值本身，append可以追加多个字符串、node，而appendChild只能加一个节点
<span class="hljs-number">175.</span>数值的表示
<span class="hljs-number">176.</span><span class="hljs-title class_">Symbol</span>
	<span class="hljs-keyword">const</span> s1=<span class="hljs-title class_">Symbol</span>()
	<span class="hljs-keyword">const</span> obj=&#123;
		[s1]:<span class="hljs-string">&quot;aaaa&quot;</span>
	&#125;
	<span class="hljs-comment">//对象中key可以是string/Symbol</span>
	由<span class="hljs-title class_">Symbol</span>()生成是独一无二的
<span class="hljs-number">177.</span>set
	存储任何类型的唯一的值
	<span class="hljs-keyword">const</span> set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()
	set.<span class="hljs-title function_">add</span>(dd)
	set.<span class="hljs-title function_">has</span>(dd)
	set.<span class="hljs-property">size</span><span class="hljs-comment">//获取元素数量</span>
	set.<span class="hljs-title function_">delete</span>(value)<span class="hljs-comment">//删除元素</span>
	<span class="hljs-title function_">clear</span>(set)<span class="hljs-comment">//清空</span>
	set.<span class="hljs-title function_">forEach</span>()<span class="hljs-comment">//可以用于数组的遍历</span>
	set.<span class="hljs-title function_">keys</span>()
	set.<span class="hljs-title function_">values</span>()<span class="hljs-comment">//keys()和values的返回值是相同的</span>
	set.<span class="hljs-title function_">entry</span>()<span class="hljs-comment">//返回值为[value,value]</span>
	forof
	数组去重
	<span class="hljs-keyword">const</span> newArr=<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr))/[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]
	<span class="hljs-title class_">Set</span>中<span class="hljs-title class_">NaN</span>===<span class="hljs-title class_">NaN</span>
	
<span class="hljs-number">178.</span><span class="hljs-title class_">WeakSet</span>
	<span class="hljs-title class_">WeakSet</span>是弱引用，可以被垃圾回收器回收
	weakSet只能存储对象
	weakSet对对象都是弱引用的，所以不可以遍历
	<span class="hljs-title class_">WeakSet</span>中由<span class="hljs-title function_">has</span>(),<span class="hljs-title function_">add</span>(),<span class="hljs-title function_">delete</span>()
	它和 <span class="hljs-title class_">Set</span> 对象的区别有两点：
    与<span class="hljs-title class_">Set</span>相比，<span class="hljs-title class_">WeakSet</span> 只能是对象的集合，而不能是任何类型的任意值。
    <span class="hljs-title class_">WeakSet</span>持弱引用：集合中对象的引用为弱引用。 如果没有其他的对<span class="hljs-title class_">WeakSet</span>中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 <span class="hljs-title class_">WeakSet</span> 中没有存储当前对象的列表。 正因为这样，<span class="hljs-title class_">WeakSet</span> 是不可枚举的。</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/EzcYmE14.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220608150415.png"></p>
<div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-number">179.</span><span class="hljs-built_in">Map</span>
<span class="hljs-keyword">map</span>也是可迭代对象
<span class="hljs-keyword">map</span>可以使用任何数据类型作为key,而<span class="hljs-built_in">Object</span>只可以使用string、symbol作为key
<span class="hljs-keyword">const</span> <span class="hljs-keyword">map</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
<span class="hljs-keyword">map</span>.set(info,<span class="hljs-string">&quot;999&quot;</span>)
<span class="hljs-keyword">map</span>.<span class="hljs-keyword">delete</span>(info)
<span class="hljs-keyword">map</span>.has(info)
clear(<span class="hljs-keyword">map</span>)
forEach
<span class="hljs-keyword">map</span>.get(info)
forof
<span class="hljs-number">180.</span><span class="hljs-built_in">Map</span>和<span class="hljs-built_in">Object</span>的区别
<span class="hljs-number">181.</span><span class="hljs-built_in">WeakMap</span>
	key只能是对象，对对象的引用是弱引用，如果没有其他引用引用该对象，他就会被GC回收
	weakMap的key是不可以枚举的，不可以遍历
	不能使用forof,forEach进行遍历
	<span class="hljs-keyword">delete</span>(key)
	get(key)
	has(key)
	set(key,value)
	
	weakMap可以解决<span class="hljs-built_in">Map</span>可能导致内存泄漏的问题，因为数组会一值引用每一个key,value
	参考：https:<span class="hljs-regexp">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap</span>
<span class="hljs-regexp">182.Array.prototype.includes(item)</span>
<span class="hljs-regexp">183.Math.pow()/**</span>
<span class="hljs-regexp">184.Object.values(obj)</span>
<span class="hljs-regexp">185.Object.keys(obj)</span>
<span class="hljs-regexp">186.Object。entries(obj)//</span>obj可以是对象，数组，字符串
	获取的数组和forin遍历的顺序是一致的，但是不会遍历原型链上的属性和方法
<span class="hljs-number">187.</span><span class="hljs-built_in">String</span>.prototype.padStart(总长度,填充字符串)<span class="hljs-regexp">//字符串填充 会返回新的字符串</span>
<span class="hljs-regexp">	例如隐藏只显示身份证的部分数字，其余部分填充*</span>
<span class="hljs-regexp">188.Object.getOwnPropertyDescriptors</span>
<span class="hljs-regexp">189.Array.prototype.flat(number)//</span>将多维数组扁平化
<span class="hljs-number">190.</span><span class="hljs-built_in">Array</span>.prototype.flatMap(callback(currval,index,arr))<span class="hljs-regexp">//相当于先使用map再使用flat(1)进行扁平化</span>
<span class="hljs-regexp">191.数组扁平化的方法</span>
<span class="hljs-regexp">192.Object.fromEntries(entries)//</span>把entry转换成Obj
	将queryString转换成对象
</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/cVkjgfjQ.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220608171027.png"></p>
<div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-number">193.</span>空值合并运算符 ??
<span class="hljs-number">194.</span>str.trim()/trimStart()/trimRight()
<span class="hljs-number">195.</span>可选链操作符  ?.
	可以替代
	<span class="hljs-keyword">if</span>(obj.friend&amp;&amp;obj.friend.running)&#123;
	obj.friend.running()
	&#125;
	
	obj?.friend?.running?.()
<span class="hljs-number">196.</span>WeakRef//暂时不建议使用
<span class="hljs-number">197.</span>逻辑赋值运算符
	message=message||&quot;默认值&quot;=&gt;message||=&quot;默认值&quot;
	message??=&quot;默认值&quot;
	obj&amp;&amp;obj.friend&amp;&amp;obj.friend.running()
<span class="hljs-number">198.</span>const <span class="hljs-built_in">new</span>=str.replaceAll()//替换所有匹配到的字符串  原始字符串保持不变。
<span class="hljs-number">199.</span>str.at(<span class="hljs-keyword">index</span>)
<span class="hljs-number">200.</span><span class="hljs-keyword">Object</span>.hasOwn(obj,propKey)
//可以替代obj.hasOwnProperty(prop),因为hasOwnProperty()可能会被使用者重写
const <span class="hljs-keyword">info</span>=<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(<span class="hljs-keyword">null</span>)//这样创建的对下个原型指向<span class="hljs-keyword">null</span>
<span class="hljs-keyword">info</span>.name=&quot;why&quot;
<span class="hljs-keyword">info</span>.hasOwnProperty(<span class="hljs-type">name</span>)//由于原型指向<span class="hljs-keyword">null</span>,所以获取不到hasOwnProperty方法
需要使用<span class="hljs-keyword">Object</span>.hasOwn()替代
<span class="hljs-number">201.</span><span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>()
	创建一个新对象，使用现有的对象来提提供新创建对象的__proto__
	<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(proto,[prppertiesObject])
<span class="hljs-number">202.</span><span class="hljs-keyword">Class</span> Person&#123;
	height=<span class="hljs-number">1.88</span>//在这里写的时候，<span class="hljs-built_in">new</span>创建对象时也会被添加到新的对象里面，再<span class="hljs-keyword">class</span>内部可以通过					this来访问
	constructor(<span class="hljs-type">name</span>,age)&#123;
	this.name=<span class="hljs-type">name</span>
	this.age=age
	this.address=&quot;广州市&quot;
	&#125;
	
	static &#123;
		//静态代码块
	&#125;
&#125;	
<span class="hljs-number">203.</span>proxy
	<span class="hljs-keyword">Object</span>.defineProperty()的缺点，不可以监听到对象属性的新增和删除操作，新增的属性也没办法监听，只能监听属性，不能监听整个对象</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/EQg1fUBC.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220609114316.png"></p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Proxy</span>是监听整个对象，他有<span class="hljs-number">13</span>个捕获器，这些捕获器可以劫持对象的一些操作用proxy替代obj操作</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/aIkHlWXU.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220609115247.png"></p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">204.</span><span class="hljs-built_in">Reflect</span>的作用
<span class="hljs-built_in">Reflect</span>是为了替代<span class="hljs-built_in">Object</span>中的一些方法</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/KQev7yPJ.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220609153635.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/14/0fcGhnc0.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220609153658.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/14/MDMfI710.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220609153711.png"></p>
<div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">205</span><span class="hljs-selector-class">.Reflect</span>.construct的作用
Reflect<span class="hljs-selector-class">.construct</span>(target, argumentsList<span class="hljs-selector-attr">[, newTarget]</span>)</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/BXFFyjjm.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220609155310.png"></p>
<p>​    </p>
<div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-number">206</span><span class="hljs-selector-class">.new</span><span class="hljs-selector-class">.target</span>作用
<span class="hljs-number">207</span><span class="hljs-selector-class">.promise</span>
	三种状态：
		pending
		fulfilled
		rejected
		状态发生改变，就不可以更改
		
		<span class="hljs-built_in">resolve</span>(value)<span class="hljs-comment">//value会作为then方法中的回调函数的参数</span>
		<span class="hljs-number">1</span>.普通值则作为参数直接传过去
		<span class="hljs-number">2</span>.如果传入的是promise,则由promise的中的·resolve参数决定
		<span class="hljs-number">3</span><span class="hljs-selector-class">.thenable</span>对象则会执行then方法并且由then方法中的reslove的参数决定
		
		<span class="hljs-built_in">then</span>()<span class="hljs-comment">//可以传两个参数，成功的回调和失败的回调</span>
		<span class="hljs-built_in">catch</span>()<span class="hljs-comment">//失败的回调</span>
<span class="hljs-number">208</span><span class="hljs-selector-class">.Window</span><span class="hljs-selector-class">.getComputedStyle</span>(ele,prop?)和Element<span class="hljs-selector-class">.getBoundingClientRect</span>()的区别
	getComputedStyle是定义在window上的方法，getBoundingClientRect是Element的方法，getComputedStyle返回值是CSS属性值，而getBoundingClientRect返回的是具体的位置信息</code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/OJQOJUb1.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220611104648.png"></p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">209.</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">then</span>()<span class="hljs-comment">//返回值是一个promise,链式调用中，then会等待上一个then的返回值promise的状态来决定</span>
	<span class="hljs-keyword">const</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;
		<span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>)
	&#125;)
	promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;
		<span class="hljs-keyword">return</span> res
	&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;
	
	&#125;)
	then的返回值
		<span class="hljs-number">1.</span>普通值则会直接包裹成promise返回
		<span class="hljs-number">2.</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span> 则有这个promise的状态来决定
		<span class="hljs-number">3.</span>有thenable方法的对象，则由thenable方法的状态来决定
	then抛出异常时，就处于reject状态，则会调用后面的<span class="hljs-keyword">catch</span>
	then <span class="hljs-keyword">return</span> 时处于fulfilled
	then没有返回值则不会继续调用then
<span class="hljs-number">210.</span><span class="hljs-title class_">Promsie</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">catch</span>()
	<span class="hljs-keyword">catch</span> 里面调用<span class="hljs-keyword">return</span>的时候默认状态是fuifilled,他的返回值是一个promise
	和then一样
	如果向继续链式调用<span class="hljs-keyword">catch</span>，需要抛出异常
	当promise中调用reject的时候，会调用最近<span class="hljs-keyword">catch</span>
	没有返回值时不会继续链式调用
<span class="hljs-number">211.</span>中断函数的执行
		<span class="hljs-keyword">return</span>
		<span class="hljs-keyword">throw</span>
		前两种会直接结束函数的执行
		<span class="hljs-keyword">yield</span></code></pre></div>

<p><img src="https://img1.imgtp.com/2022/08/14/ws0WolVm.png" srcset="/img/loading.gif" lazyload alt="QQ截图20220612095542.png"></p>
<p>212.Promise.prototype.finally(callback)    </p>
<p>​        无论Promise对象变成fulfilled还是rejected状态，最终都会执行</p>
<p>​        finally方法的回调函数参数是不接受参数的</p>
<ol start="213">
<li><p>Promise.resolve()相当于new Promsie()并且执行resolve方法。</p>
<p>就是希望将变量转换成Promise来使用</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&quot;why&quot;</span>)=<span class="hljs-function">=&gt;</span><span class="hljs-keyword">new</span> Promsise(<span class="hljs-function"><span class="hljs-params">(resolve)</span>=&gt;</span>resolve(<span class="hljs-string">&quot;why&quot;</span>))
参数和resolve一样</code></pre></div></li>
<li><p>Promise.reject() reject方法类似于resolve方法，只是会将Promise对象的状态设置为reject状态</p>
<div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-string">&quot;why&quot;</span>)=&gt;<span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">_</span>,<span class="hljs-params">reject</span>)</span>=&gt;reject(<span class="hljs-string">&quot;why&quot;</span>))<span class="hljs-comment">//_不传可以这样写</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promsie</span>.</span></span>reject无论传什么参数都是rejected</code></pre></div></li>
<li><p>Promsie.all([])</p>
<div class="code-wrapper"><pre><code class="hljs arcade">他的作用是将对各promise,放入到数组中执行，<span class="hljs-built_in">all</span>方法的最终状态是由数组中的所有promisek结果决定的，如果Promise所有状态都是fulfilled状态则Pramise.<span class="hljs-built_in">all</span>的状态为fulfilled，并且将所有数组中的promise的返回值做成一个数组返回
如果数组中出现一个promise状态为rejected则<span class="hljs-built_in">all</span>的状态也会变成rejected,并将第一个reject的返回值作为参数
Promsie.<span class="hljs-built_in">all</span>([p1,p2,p3]).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>res).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>err)</code></pre></div></li>
<li><p>Promise.allSettled([])</p>
<div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promsie</span>.</span></span>all<span class="hljs-constructor">Settled([<span class="hljs-params">p1</span>,<span class="hljs-params">p2</span>,<span class="hljs-params">p3</span>])</span>.<span class="hljs-keyword">then</span>(res=&gt;res)
<span class="hljs-comment">//状态都是fulfilled,会返回一个[&#123;stattus:fulfilled/rejected,value:&quot;&quot;&#125;]</span></code></pre></div></li>
<li><p>Promsie.race([])</p>
<div class="code-wrapper"><pre><code class="hljs cpp">rece的状态由[]中的promise那个先完成的状态来决定的</code></pre></div></li>
<li><p>Promise.any([])</p>
</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs cpp">只要[]中的promise中的第一个变成fulfilled的状态来决定的，返回值也是这个promise返回值
如果所有的promsie状态都是rejected则会变成any的状态会变成reject
果所有的Promise都是reject的，那么会报一个AggregateError的错误。</code></pre></div>

<p>219.迭代器</p>
<p>220.async函数的执行</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">async</span>函数 没有<span class="hljs-keyword">await</span>的话则和普通的函数没有区别，都是会同步执行

返回值如果是普通值则会被<span class="hljs-built_in">Promise</span>.resolve()包裹
返回值是promsie时，会有promise的状态来决定
返回值是thenable对象，则由thenable的状态来决定

<span class="hljs-keyword">async</span>函数的执行函数的执行函数想返回reject状态，调用<span class="hljs-keyword">catch</span>,可以使用返回一个promsie 里面用reject(),thenable也是一样，或者使用<span class="hljs-built_in">Promise</span>.reject()
还可以用<span class="hljs-keyword">throw</span> 来抛出异常

<span class="hljs-keyword">async</span>的异常不会报错，而是会作为<span class="hljs-built_in">Promise</span>.reject来传递

<span class="hljs-keyword">await</span>关键字 只能在<span class="hljs-keyword">async</span>里面使用
<span class="hljs-keyword">await</span> 之后的代码相当于Promsie.<span class="hljs-keyword">then</span>(),<span class="hljs-keyword">await</span>要捕获错误需要使用<span class="hljs-keyword">try</span>...<span class="hljs-keyword">catch</span>	
<span class="hljs-keyword">await</span> 后面跟的代码是<span class="hljs-built_in">Promise</span>.resolve包裹，会等待promise的返回值
<span class="hljs-keyword">await</span>会阻塞代码的执行，等待promise返回值，<span class="hljs-keyword">await</span>之前都是同步的</code></pre></div>

<p>221.浏览器的事件循环</p>
<p>​        宏任务队列(marcotask queue)：</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript">ajax,<span class="hljs-built_in">setTimeout</span>,<span class="hljs-built_in">setInterval</span>,DOM监听，UI Rendering等</code></pre></div>

<p>​        微任务队列(microtask queue)</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>的<span class="hljs-keyword">then</span>回调，Mutation Obderver API queueMicrotask <span class="hljs-keyword">async</span> <span class="hljs-keyword">await</span></code></pre></div>

<p>​    执行宏任务之前，会先检查微任务队列是否为空，如果不为空，先执行微任务</p>
<p>222.错误处理方案</p>
<p>​        throw 会中断后面代码的执行</p>
<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">throw</span> <span class="hljs-title class_">String</span>/<span class="hljs-built_in">number</span>/<span class="hljs-built_in">boolean</span>/<span class="hljs-title class_">Object</span></code></pre></div>

<p>​        异常的捕获</p>
<p>​        try..catch..finally</p>
<p>223.cookie存储是由浏览器自动做的，携带cookie也是由浏览器做的</p>
<p>224.Storage</p>
<p>​        localStorage在页面关闭并重新打开时不会被清除，sessionStroage会被清除</p>
<p>​        在页面内发生跳转不打开新页面时，sessionStorage和localStorage都会被保留</p>
<p>​        在页面外发生跳转打开新的页面时，sessionStorage不保存，localStorage会保存</p>
<p>​        sessionStorage只会在本次会话中存储，不会在新页面中获取</p>
<p>225.cache工具的封装</p>
<p>226.正则表达式</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> re1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">REgExp</span>(pattern,<span class="hljs-string">&quot;ig&quot;</span>)<span class="hljs-comment">//new 创建</span>
<span class="hljs-keyword">const</span> re2=<span class="hljs-regexp">/aaaa/ig</span> <span class="hljs-comment">//字面量写法</span>

message.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/abc/ig</span>,<span class="hljs-string">&quot;cba&quot;</span>)

message.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/\d+/ig</span>,<span class="hljs-string">&quot;cba&quot;</span>)

message.<span class="hljs-title function_">test</span>(<span class="hljs-regexp">/^abc$/ig</span>)<span class="hljs-comment">//返回值是boolean值</span>

message.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/abc/ig</span>)<span class="hljs-comment">//返回匹配到的值的数组结合</span>
message.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/abc/ig</span>)<span class="hljs-comment">//必须加g,返回值是迭代器</span>
message.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/abc/ig</span>)

message.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/abc/i</span>)<span class="hljs-comment">//返回索引，没有则返回-1</span>

常见修饰符
	g 匹配全部
	i 忽略大小写
	m 多行匹配
	
规则
	\d digit 一个数字<span class="hljs-number">0</span>-<span class="hljs-number">9</span>
	\s space 一个空格字符，换行符,\t,\n
	\w word 一个拉丁字母或者数字，下划线
	.  匹配任意字符，除了换行符
	
	反向类
	\D 非数字 除\d以外字符 如字母
	\S 非空格 
	\W 非单字字符
	
	转义
	/\./ig 对.进行转义
	[,],\,^,$,.,|,?,*,+,(,),/  常见的需要进行转义
	
	<span class="hljs-keyword">const</span> jsfile=<span class="hljs-regexp">/\.jsx?$/</span>  ?表示前面的字符可选
	
	集合
		匹配到多个字符中的其中之一.用[]
		/[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]/,<span class="hljs-regexp">/[156]/</span>
		<span class="hljs-keyword">const</span> phone=<span class="hljs-regexp">/^1[3-9]\d&#123;9&#125;$/</span> <span class="hljs-comment">//匹配电话号码</span>
		
		排除范围[^...]，不匹配括号里面的
	量词
		/a&#123;<span class="hljs-number">5</span>&#125;/ 匹配<span class="hljs-number">5</span>个a /a&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;/匹配<span class="hljs-number">3</span>-<span class="hljs-number">5</span>个a
		缩写
			+:一个或者多个,&#123;<span class="hljs-number">1</span>,&#125;
			?:<span class="hljs-number">0</span>或者<span class="hljs-number">1</span>个 &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;
			*:<span class="hljs-number">0</span>个或者多个 &#123;<span class="hljs-number">0</span>,&#125;
			
			<span class="hljs-keyword">const</span> tag=<span class="hljs-regexp">/&lt;\/?[a-z][a-z0-9]*\/?/ig</span>  匹配多个元素标签
			
			贪婪模式和惰性模式
			<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《.+?》/g</span> 惰性模式
			<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《.+》/g</span> 贪婪模式
			
	捕获组
			<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《(.+?)》/g</span>
			str.<span class="hljs-title function_">matchAll</span>(name)
			
			未学完
			
<span class="hljs-number">227.</span>http 超文本传输协议  
	默认端口是<span class="hljs-number">80</span>端口，是应用层协议
<span class="hljs-number">228.</span><span class="hljs-variable constant_">HTTP</span>组成
	一次请求包括request和response
<span class="hljs-number">229.</span>http版本
	<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.0</span>
	<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> 添加了持久化连接
	<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2.0</span>
	<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">3.0</span>
<span class="hljs-number">230.</span><span class="hljs-variable constant_">HTTP</span>的请求方式
	<span class="hljs-variable constant_">GET</span>
	<span class="hljs-variable constant_">HEAD</span><span class="hljs-comment">//和get相似,但是没有响应体，例如准备下载一个文件前，先获取文件的大小，再决定是否进行下载</span>
	<span class="hljs-variable constant_">POST</span><span class="hljs-comment">//将实体提交到指定的资源</span>
	<span class="hljs-variable constant_">PUT</span><span class="hljs-comment">//替换所有数据</span>
	<span class="hljs-variable constant_">DELETE</span>
	<span class="hljs-variable constant_">PATCH</span><span class="hljs-comment">//对部分数据进行修改</span>
	<span class="hljs-variable constant_">CONNECT</span>
	<span class="hljs-variable constant_">TRACE</span>
<span class="hljs-number">231.</span>request header
	content-type是请求携带的数据类型
		application/x-www-form-urlencoded 表示被编码成以&amp;分隔name=why&amp;age=<span class="hljs-number">18</span>
		application/json 表示是一种json类型
		text/plain 表示文本类型
		application/xml
		multipart/form-data <span class="hljs-comment">//表示文件上传 ，很多浏览器会自动设置</span>
	content-length 文件长度 不需要设置
	keep-alive http/<span class="hljs-number">1.1</span> 默认为<span class="hljs-literal">true</span>
	accept-<span class="hljs-attr">encoding</span>:告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip压缩
对应.<span class="hljs-property">gz</span>文件，浏览器会自动解压，这个属性不用配，浏览器会配，在webpack中可以打包成gzip文件
	<span class="hljs-attr">accept</span>:告诉浏览器，客户端可以接受的文件的格式类型 默认是任何格式都接受
	user-<span class="hljs-attr">agent</span>:客户端相关的信息
<span class="hljs-number">232.</span>http response status
	<span class="hljs-number">200</span> ok 
	<span class="hljs-number">201</span> create post请求，创建新的资源
	<span class="hljs-number">301</span> 永久重定向
	<span class="hljs-number">400</span> bad request 客户端的错误，服务器无法或者不进行处理
	<span class="hljs-number">401</span> unauthorized 未授权 一般是没有登录的情况下 没有cookie,token或者过期
	<span class="hljs-number">403</span> forbidden 没有权限
	<span class="hljs-number">404</span> <span class="hljs-title class_">NOt</span> found 一般是接口不存在，url错误
	<span class="hljs-number">500</span> 服务器未知错误
	<span class="hljs-number">503</span> 暂时无法访问
	
	<span class="hljs-number">400</span>、<span class="hljs-number">403</span>都是浏览器返回的
	有些开发所有返回的status都是<span class="hljs-number">200</span>，在数据里面来自定义错误信息
<span class="hljs-number">233.</span>xhr
	<span class="hljs-keyword">const</span> xhr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()
	xhr.<span class="hljs-property">onload</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
		<span class="hljs-comment">//xhr.response   一般使用这个</span>
		<span class="hljs-comment">//xhr.responseText</span>
		<span class="hljs-comment">//xhr.responseXML</span>
	&#125;
	xhr.<span class="hljs-property">responseType</span>=<span class="hljs-string">&quot;json&quot;</span><span class="hljs-comment">//默认是text,一般是json</span>
	
	xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>,url)<span class="hljs-comment">//第一个参数是请求类型，第二个参数是url，第三个参数是是否同步，默认是异步</span>
	<span class="hljs-comment">//设置过期时间</span>
	xhr.<span class="hljs-property">timeout</span>=<span class="hljs-number">3000</span>
	xhr.<span class="hljs-property">ontimeout</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
	
	&#125;
	xhr.<span class="hljs-title function_">abort</span>()<span class="hljs-comment">//取消请求</span>
	<span class="hljs-comment">//发送网络请求</span>
	xhr.<span class="hljs-title function_">send</span>()
<span class="hljs-number">234.</span>ajax的封装
<span class="hljs-number">235.</span><span class="hljs-title class_">Fetch</span> 
	返回值是promise
	文件上传地址<span class="hljs-attr">http</span>:<span class="hljs-comment">//123.207.32.32:1888/02_param/upload</span>
<span class="hljs-number">236.</span>git
git add .
git commit -m <span class="hljs-string">&quot;提交描述&quot;</span>
git push
git pull origin master <span class="hljs-comment">//从远程的某个分支获取</span>
git branch --set-upstream-to=origin/master  <span class="hljs-comment">//设置上游分支就可以只写 git pull了</span>
git merge --allow-unrelated-histories  <span class="hljs-comment">//强制合并</span>
git status

git clone url<span class="hljs-comment">//克隆代码</span>

push到远程仓库
git push
git push origin master

fetch代码
git fetch 
git fetch origin master

获取到代码后默认并没有合并，需要merge
git merge

get merge origin/master

也可以使用
git pull
相当于
git fetch+git <span class="hljs-title function_">merge</span>(rebase)

链接远程仓库
geit remote add origin ....

git push origin master <span class="hljs-comment">//第一次图送会推送到main分支  第二次推送会被推送到master</span>
git push origin <span class="hljs-attr">master</span>:main

git push origin <span class="hljs-attr">head</span>:main  head默认指向main
如果要push master默认要这么写git push origin <span class="hljs-attr">master</span>:main  如果想写git push就要这么写
配置git push 指向上游路径master，就是配置好的git branch --set-upstream-to=origin/master
调用git push 就会push到master,但是这样每个分支都是push到master
git config push.<span class="hljs-property">default</span> upstream  [--<span class="hljs-variable language_">global</span>]<span class="hljs-comment">//加上global可以全局使用，否则就是当前项目使用</span>

git config push.<span class="hljs-property">default</span> current  <span class="hljs-comment">//这个会先去仓库找有没有和本地相同的分支，如果没有就在远程创建一个新的和本地相同的分支</span>

push.<span class="hljs-property">default</span> 默认是simple 就是push相同的分支

git tag 打标签
git tag v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>
git tag -a v1<span class="hljs-number">.0</span><span class="hljs-number">.1</span> -m <span class="hljs-string">&quot;注释&quot;</span>
默认情况子git tag 不会push到服务器
git push origin v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>  推送到远程
git push origin --tags 把所有tag都推送上去
git tag -d tagname  <span class="hljs-comment">//删除本地的tag</span>
git oush origin&lt;在本地定义的远程的名字，默认是origin&gt; -d或者--<span class="hljs-keyword">delete</span> v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>
git checkpout v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span> 跳转到目标tag, 回到tag版本代码 不能再当前tag修改代码，需要根据当前的tag,创建新的分支来修改


git cat-file -p 00d2  <span class="hljs-comment">//查看.git/objects/00/d2..... 就可以看到文件的内容</span>

git cat-file -t 00d2 <span class="hljs-comment">//查看文件内容</span>
<span class="hljs-comment">//blod 表示文件还没提交的文件</span>
<span class="hljs-comment">//commit 表示已经提交</span>
<span class="hljs-comment">//tag 表示是tag</span>
</code></pre></div>

<p>237.Git分支</p>
<p>创建新的分支其实创建一个新的可移动的指针</p>
<p>git branch 分支  创建分支</p>
<p>git checkout 分支 切换分支</p>
<p>git 怎么直到指向那个分支 也是使用HEAD的指针 </p>
<p>git checkout 分支  就是将head指针指向它</p>
<p>先使用 git branch 分支 创建分支 然后再使用 git checkout 分支 将切换分支指针指向该分支</p>
<p>git checkout -b <newbranchname>   //创建新的分支并且切换分支</p>
<p> 238.git flow </p>
<p>在项目开发过程中，首先会创建master主分支用于线上发布，可以打上tag作为版本，如果线上出现bug,则从master开辟分支，进行代码的修复，然后合并到master分支，和develop分支。develop分支用于开发，需要上线时会开辟release分支用于测试，并且修复测试遇到的bug,完成测试后就可以合并到master和develop,如果需要开发新的功能，则需要从develop开辟新分支进行开发</p>
<p>239.git的远程分支</p>
<p>git remote add origin url</p>
<p>git fetch origin main  //把main分支拉取</p>
<p>git branch –set-upstream-to=origin/main  //设置上游分支</p>
<p>=========================================================</p>
<p>get merge//默认合并upstream   合并必须要有共同的祖先</p>
<p>远程分支是也是一种分支结构：  以 remote/branch式命名的</p>
<p>240.跟踪远程分支</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支</p>
<p>如果你愿意的话可以设置其他的跟踪分支，可以通过运行 git checkout –track origin/分支名</p>
<p> 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支</p>
<div class="code-wrapper"><pre><code class="hljs vim">git checkout --track <span class="hljs-symbol">&lt;remote&gt;</span>/<span class="hljs-symbol">&lt;branch&gt;</span>  

相当于git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/main  跟踪origin/main  并且创建和切换mian分支

git checkout <span class="hljs-symbol">&lt;branch&gt;</span>  上面的简写
他会先检查远程有没有这个分支，然后在跟踪这个分支，并且在本地创建这个分支，在切换到这个分支
</code></pre></div>

<p>241.git checkout -b  develop</p>
<p>​        git push origin develop</p>
<p>如果需要创建一个分支，并且推送到远程，远程也会创建相同的分支</p>
<p>242.git branch -d  分支     删除本地分支</p>
<p>243.删除远程分支</p>
<div class="code-wrapper"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> &lt;branch&gt;</code></pre></div>

<p>244.查看git log</p>
<div class="code-wrapper"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--pretty=oneline</span></code></pre></div>

<p>245 git rebase</p>
<div class="code-wrapper"><pre><code class="hljs crmsh">git checkout feature
git rebase <span class="hljs-keyword">master</span>
<span class="hljs-title">git</span> checkout <span class="hljs-keyword">master</span>
<span class="hljs-title">git</span> merge  feature

//永远不要在主分支上rebase</code></pre></div>

<p>246.git rebase的原理</p>
<p>247.rebase和merge的区别</p>
<p>merge会记录git的所有历史，那么分支的历史错综复杂，也会全部记录下来</p>
<p>rebase用于简化历史记录，将两个分支的历史简化，整个历史更加简洁</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/note/" class="category-chain-item">note</a>
  
  
    <span>></span>
    
  <a href="/categories/note/%E5%89%8D%E7%AB%AF%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%AC%94%E8%AE%B0/" class="category-chain-item">前端系统课笔记</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端系统课笔记</div>
      <div>http://example.com/2022/08/14/笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年8月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/15/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84localstorage%E6%95%B0%E6%8D%AE/" title="实现可过期的localstorage数据(仅供参考)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">实现可过期的localstorage数据(仅供参考)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/" title="vue2和vue3的区别(vue2向vue3迁移)(一)">
                        <span class="hidden-mobile">vue2和vue3的区别(vue2向vue3迁移)(一)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
