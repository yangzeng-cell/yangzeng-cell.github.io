

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="web性能权威指南网络技术概览网络通信决定性影响的两个方面：延迟与带宽 延迟：分组从信息源发送到目的地所需要的时间 带宽：逻辑或者物理通信路径最大的吞吐量 延迟的构成 传播延迟：消息从发送端到接收端所需要的时间，是信号传播距离和速度的函数 传输延迟：把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数 处理延迟：处理分组首部，检查位错误及确定分组目标 排队延迟：到来的分组排队等待处">
<meta property="og:type" content="article">
<meta property="og:title" content="web性能权威指南">
<meta property="og:url" content="http://example.com/2022/12/09/web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="web性能权威指南网络技术概览网络通信决定性影响的两个方面：延迟与带宽 延迟：分组从信息源发送到目的地所需要的时间 带宽：逻辑或者物理通信路径最大的吞吐量 延迟的构成 传播延迟：消息从发送端到接收端所需要的时间，是信号传播距离和速度的函数 传输延迟：把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数 处理延迟：处理分组首部，检查位错误及确定分组目标 排队延迟：到来的分组排队等待处">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-09T08:17:27.000Z">
<meta property="article:modified_time" content="2022-12-11T07:15:11.535Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="web性能权威指南">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>web性能权威指南 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Piggy的记录版</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="web性能权威指南"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-09 08:17" pubdate>
          2022年12月9日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          60 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">web性能权威指南</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="web性能权威指南"><a href="#web性能权威指南" class="headerlink" title="web性能权威指南"></a>web性能权威指南</h1><h2 id="网络技术概览"><a href="#网络技术概览" class="headerlink" title="网络技术概览"></a>网络技术概览</h2><p>网络通信决定性影响的两个方面：延迟与带宽</p>
<p>延迟：分组从信息源发送到目的地所需要的时间</p>
<p>带宽：逻辑或者物理通信路径最大的吞吐量</p>
<p><strong>延迟的构成</strong></p>
<p>传播延迟：消息从发送端到接收端所需要的时间，是信号传播距离和速度的函数</p>
<p>传输延迟：把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数</p>
<p>处理延迟：处理分组首部，检查位错误及确定分组目标</p>
<p>排队延迟：到来的分组排队等待处理的时间</p>
<p>以上加起来的时间就是客户端到服务器的总延迟时间。传播时间取决于距离和信号通过的媒介。另外传播速度一般不超过光速，而传输时延是由传输链路上的速率来决定的，与客户端和服务器的距离无关。假设有一个 10 MB 的文件，分别通过两个链路传输，一个1Mbit/s，另一个 100 Mbit/s。在 1 Mbit/s 的链路上，需要花10 s，而在 100 Mbit/s 的链路上，只需 0.1 s。</p>
<p>接着，分组到达路由器。路由器必须检测分组的首部，以确定出站路由，并且还可能对数据进行检查，这些都要花时间。由于这些检查通常由硬件完成，因此相应的延迟一般非常短，但再短也还是存在。最后，如果分组到达的速度超过了路由器的处理能力，那么分组就要在入站缓冲区排队。数据在缓冲区排队等待的时间，当然就是排队延迟。</p>
<p>每个分组在通过网络时都会遇到这样或那样的延迟。发送端与接收端的距离越远，传播时间就越长。一路上经过的路由器越多，每个分组的处理和传输延迟就越多。最后，网络流量越拥挤，分组在入站缓冲区中被延迟的可能性就越大。</p>
<h2 id="浏览器网络概述"><a href="#浏览器网络概述" class="headerlink" title="浏览器网络概述"></a>浏览器网络概述</h2><p>现代浏览器完全包括数百个组件的操作系统，包括进程管理，安全沙箱，分层的优化缓存，javascript虚拟机，图形渲染，GPU管道，存储系统，传感器，音频与视频，网络机制，等等。</p>
<p>显然，浏览器乃至运行在其中的应用的性能，取决于若干组件：解析、布局、HTML 与 CSS 的样式计算、JavaScript 执行速度、渲染管道，当然还有网络相关各层协议的配合。其中每个组件的角色都很重要，而网络组件通常是加倍重要，因为浏览器慢就慢在等待网络资源上，等待造成后续环节被阻塞！</p>
<p>运行在浏览器中的 Web 应用并不负责管理个别网络套接字的生命周期，这是好事。通过把这个任务委托给浏览器，可以自动化很多重要的性能优化任务，包括套接字重用、请求优先级排定、晚绑定、协议协商、施加连接数限制，等等。事实上，浏览器是有意把请求管理生命周期与套接字管理分开的</p>
<p>套接字是以池的形式进行管理的（图 14-2），即按照来源，每个池都有自己的连接限制和安全约束。挂起的请求是排好队的、有优先次序的，然后再适时把它们绑定到池中个别的套接字上。除非服务器有意关闭连接，否则同一个套接字可以自动用于多个请求</p>
<p><strong>来源</strong></p>
<p>由应用协议、域名和端口三个要件构成，比如 (http, <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a>, 80) 与(https, <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a>, 443) 就是两个不同的来源。</p>
<p><strong>套接字池</strong></p>
<p>属于同一个来源的一组套接字。实践中，所有主流浏览器的最大池规模都是 6 个套接字。</p>
<p>自动化的套接字池管理会自动重用 TCP 连接，从而有效保障性能，除此之外，这种架构设计还提供了其他优化的机会：</p>
<ul>
<li>浏览器可以按照优先次序发送排队的请求；</li>
<li>浏览器可以重用套接字以最小化延迟并提升吞吐量；</li>
<li>浏览器可以预测请求提前打开套接字；</li>
<li>浏览器可以优化何时关闭空闲套接字；</li>
<li>浏览器可以优化分配给所有套接字的带宽</li>
</ul>
<h3 id="网络安全与沙箱"><a href="#网络安全与沙箱" class="headerlink" title="网络安全与沙箱"></a>网络安全与沙箱</h3><p>将个别套接字的管理任务委托给浏览器还有另一个重要的用意：可以让浏览器运用沙箱机制，对不受信任的应用代码采取一致的安全与策略限制。比如，浏览器不允许直接访问原始网络套接字 API，因为这样给恶意应用向任意主机发起任意请求（端口扫描、连接邮件服务器或发送未知消息）提供可乘之机</p>
<p><strong>连接限制</strong></p>
<p>浏览器管理所有打开的套接字池并强制施加连接数限制，保护客户端和服务器的资源不会被耗尽</p>
<p><strong>请求格式化与响应处理</strong></p>
<p>浏览器格式化所有外发请求以保证格式一致和符合协议的语义，从而保护服务器。类似地，响应解码也会自动完成，以保护用户。</p>
<p><strong>TLS协商</strong></p>
<p>浏览器执行 TLS 握手和必要的证书检查。任何证书有问题（比如服务器正在使用自已签发的证书），用户都会收到通知。</p>
<p><strong>同源策略</strong></p>
<p>浏览器会限制应用只能向哪个来</p>
<h3 id="资源与客户端状态缓存"><a href="#资源与客户端状态缓存" class="headerlink" title="资源与客户端状态缓存"></a>资源与客户端状态缓存</h3><p>最好最快的请求是没有请求。在分派请求之前，浏览器会自动检查其资源缓存，执行必要的验证，然后在满足限制条件的情况下返回资源的本地副本。类似地，如果某本地资源不在缓存中，那么浏览器就会发送网络请求，将响应自动填充到缓存中，以备后续访问使用。</p>
<p>• 浏览器针对每个资源自动执行缓存指令。</p>
<p>• 浏览器会尽可能恢复失效资源的有效性。</p>
<p>• 浏览器会自动管理缓存大小及资源回收。</p>
<p>高效、最优地管理缓存很困难。所幸，浏览器会替我们照管这一切，我们要做的，只是确保服务器返回适当的缓存指令Cache-Control、ETag 和 Last-Modified。最后，浏览器还有一个经常被人忽视的重要功能，那就是提供会话认证和 cookie 管理。浏览器为每个来源维护着独立的 cookie 容器，为读写新 cookie、会话和认证数据提供必要的应用及服务器 API，还会为我们自动追加和处理 HTTP 首部，让一切都自动化。</p>
<h3 id="应用API与协议"><a href="#应用API与协议" class="headerlink" title="应用API与协议"></a>应用API与协议</h3><table>
<thead>
<tr>
<th></th>
<th>XmlHttpRequest</th>
<th>Server-Sent Event</th>
<th>WebSocket</th>
</tr>
</thead>
<tbody><tr>
<td>请求流</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>响应流</td>
<td>受限</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分帧机制</td>
<td>HTTP</td>
<td>事件流</td>
<td>二进制分帧</td>
</tr>
<tr>
<td>二进制数据传输</td>
<td>是</td>
<td>否(base64)</td>
<td>是</td>
</tr>
<tr>
<td>压缩</td>
<td>是</td>
<td>是</td>
<td>受限</td>
</tr>
<tr>
<td>应用传输协议</td>
<td>HTTP</td>
<td>TCP</td>
<td>WebSocket</td>
</tr>
<tr>
<td>网络传输协议</td>
<td>TCP</td>
<td>TCP</td>
<td>TCP</td>
</tr>
</tbody></table>
<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>这就意味着浏览器会自动帮</p>
<p>我们完成所有底层的连接管理、协议协商、HTTP 请求格式化，以及更多工作：XHR不仅实现了浏览器的异步通信，还极大的简化的这个过程，XH R是浏览器提供的应用API.这就意味着浏览器会自动帮我们完成所有底层的连接管理、协议协商、HTTP 请求格式化，以及更多工作：</p>
<p>浏览器管理着连接建立、套接字池和连接终止；</p>
<p>浏览器决定最佳的 HTTP（S）传输协议（HTTP 1.0、1.x 和 2.0）； </p>
<p>浏览器处理 HTTP 缓存、重定向和内容类型协商；</p>
<p>浏览器保障安全、验证和隐私；</p>
<p>等等</p>
<h4 id="跨源资源共享（CORS）"><a href="#跨源资源共享（CORS）" class="headerlink" title="跨源资源共享（CORS）"></a>跨源资源共享（CORS）</h4><p>XHR 是一个浏览器层面的 API，向我们隐藏了大量底层处理，包括缓存、重定向、内容协商、认证，等等。这样做有两个目的。第一，XHR 的 API 因此非常简单，开发人员可以专注业务逻辑。其次，浏览器可以采用沙箱机制，对应用代码强制施加一套安全限制。</p>
<p>XHR 接口强制要求每个请求都严格具备 HTTP 语义：应用提供数据和 URL，浏览器格式化请求并管理每个连接的完整生命周期。类似地，虽然 XHR API 允许应用添加自定义的 HTTP 首部（通过 setRequestHeader() 方法），同时也有一些首部是应用代码不能设定的：</p>
<p>• Accept-Charset、Accept-Encoding、Access-Control-*</p>
<p>• Host、Upgrade、Connection、Referer、Origin</p>
<p>• Cookie、Sec-<em>、Proxy-</em> 以及很多其他首部</p>
<p>浏览器会拒绝对不安全首部的重写，以此保证应用不能假扮用户代理、用户或请求来源。事实上，保护来源（Origin）首部特别重要，因为这是对所有 XHR 请求应用“同源策略”的关键。</p>
<p>CORS 请求也使用相同的 XHR API，区别仅在于请求资源用的 URL 与当前脚本并不同源。</p>
<p>针对 CORS 请求的选择同意认证机制由底层处理：请求发出后，浏览器自动追加受保护的 Origin HTTP 首部，包含着发出请求的来源。相应地，远程服务器可以检查 Origin首部，决定是否接受该请求，如果接受就返回 Access-Control-Allow-Origin 响应首部：</p>
<div class="code-wrapper"><pre><code class="hljs awk">=&gt; 请求

GET <span class="hljs-regexp">/resource.js HTTP/</span><span class="hljs-number">1.1</span>

Host: thirdparty.com

Origin: http:<span class="hljs-regexp">//</span>example.com ➊<span class="hljs-regexp">//</span>Origin 首部由浏览器自动设置

...

&lt;= 响应

HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK

Access-Control-Allow-Origin: http:<span class="hljs-regexp">//</span>example.com ➋<span class="hljs-regexp">//</span> 选择同意首部由服务器设置</code></pre></div>

<p>假如它选择不同意接受这个请求，那么只要不在响应中包含 <em>Access-Control-Allow-Origin</em> 首部即可。这样，客户端的浏览器就会自动将发出的请求作废。</p>
<p>如果第三方服务器不支持 CORS，那么客户端请求同样会作废，因为客户端会验证响应中是否包含选择同意的首部。作为一个特例，CORS 还允许服务器返回一个通配值 (Access-Control-Allow-Origin: *)，表示它允许来自任何源的请求。</p>
<p><strong>因为 CORS 还会提前采取一系列安全措施，以确保服务器支持 CORS：</strong> </p>
<p>• CORS 请求会省略 cookie 和 HTTP 认证等用户凭据；</p>
<p>• 客户端被限制只能发送“简单的跨源请求”，包括只能使用特定的方法（GET、POST 和 HEAD），以及只能访问可以通过 XHR 发送并读取的 HTTP 首部。</p>
<p>要启用 cookie 和 HTTP 认证，客户端必须在发送请求时通过 XHR 对象发送额外的属性（withCredentials），而服务器也必须以适当的首部（<em>Access-Control-Allow**Credentials</em>）响应，表示它允许应用发送用户的隐私数据。</p>
<div class="code-wrapper"><pre><code class="hljs excel">=&gt; 预备请求
OPTIONS /resource.js HTTP/<span class="hljs-number">1.1</span> ➊//验证许可的预备 OPTIONS 请求
Ho<span class="hljs-symbol">st:</span> thirdparty.com
Orig<span class="hljs-symbol">in:</span> ht<span class="hljs-symbol">tp:</span>//example.com
Access-Control-Request-Meth<span class="hljs-symbol">od:</span> POST
Access-Control-Request-Heade<span class="hljs-symbol">rs:</span> My-Custom-Header
...
&lt;= 预备响应
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK ➋//第三方源的成功预备响应
Access-Control-Allow-Orig<span class="hljs-symbol">in:</span> ht<span class="hljs-symbol">tp:</span>//example.com
Access-Control-Allow-Metho<span class="hljs-symbol">ds:</span> GET, POST, PUT
Access-Control-Allow-Heade<span class="hljs-symbol">rs:</span> My-Custom-Header
...
（正式的 HTTP 请求）➌//实际的 CORS 请求</code></pre></div>

<p>W3C 官方的 CORS 规范规定了何时何地必须使用预备请求：“简单的”请求可以跳过它，但很多条件下这个请求都是必需的，因此也会为验证许可而增加仅有一次往返的网络延迟。只要完成预备请求，客户端就会将结果缓存起来，后续请求就不必重复验证了</p>
<p><strong><u>CORS 得到了所有现代浏览器支持，参见：caniuse.com/cors。要全面了解CORS 的各种策略及实现，请参考 W3C 官方标准（<a target="_blank" rel="noopener" href="http://www.w3.org/TR/cors/%EF%BC%89%E3%80%82">http://www.w3.org/TR/cors/）。</a></u></strong></p>
<h4 id="通过XHR下载数据"><a href="#通过XHR下载数据" class="headerlink" title="通过XHR下载数据"></a>通过XHR下载数据</h4><p>XHR 既可以传输文本数据，也可以传输二进制数据。事实上，浏览器可以自动为各种原生数据类型提供编码和解码服务，因此应用在直接将这些数据传给 XHR 时就已经编码 / 解码好了，反之亦然。浏览器可以自动解码的数据类型如下。</p>
<p>ArrayBuffer</p>
<p>固定长度的二进制数据缓冲区。</p>
<p>Blob</p>
<p>二进制大对象或不可变数据。</p>
<p>Document</p>
<p>解析后得到的 HTML 或 XML 文档。</p>
<p>JSON</p>
<p>表示简单数据结构的 JavaScript 对象。</p>
<p>Text</p>
<p>简单的文本字符串。</p>
<p>浏览器通过http的content-type信息，来推断出类型， 比 如 把application/json 响应解析为 JSON 对象），应用也可以在发起 XHR 请求时显式重写数据类型：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/images/photo.webp&#x27;</span>);
xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;blob&#x27;</span>; ➊<span class="hljs-comment">//将返回数据类型设置为 Blob</span>
xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;
 <span class="hljs-keyword">var</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);
 img.<span class="hljs-property">src</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>); ➋<span class="hljs-comment">//基于返回的对象创建唯一的对象 URI 并设置为图片的源</span>
 img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">src</span>); ➌<span class="hljs-comment">//图片加载完毕后立即释放对象</span>
 &#125;
 <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(img);
 &#125;
&#125;;
xhr.<span class="hljs-title function_">send</span>()</code></pre></div>

<p>注意，这里我们在以原生格式传输一张图片，没有使用 base64 编码，也没有使用数据 URI，而是在页面中添加了一个 <img> 元素。这样在 JavaScript 中处理接收到的二进制数据不会产生任何网络传输开销和编码开销！ XHR API 让我们得以通过脚本高效、动态地开发应用，无论操作什么数据类型都没问题，全部用 JavaScript搞定！</p>
<p><em><strong>这里的二进制大对象接口（Blob）属于 HTML5 的 File API，就像一个不透明的引用，可以指向任何数据块（二进制或文本）。这个对象本身没有太多功能，只能查询其大小、MIME 类型，或将它切分成更小的块。这个对象存在的真正目的，是作为各种 JavaScript API 之间的一种高效的互操作机制。</strong></em></p>
<h4 id="通过XHR上传数据"><a href="#通过XHR上传数据" class="headerlink" title="通过XHR上传数据"></a>通过XHR上传数据</h4><p>通过 XHR 上传任何类型的数据都很简单，而且高效。事实上，上传不同类型数据的代码都一样，只不过最后在调用 XHR 请求对象的 send() 方法时，要传入相应的数据对象。剩下的事就都由浏览器处理了：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-string">&#x27;/upload&#x27;</span>);
xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;
xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;text string&quot;</span>); ➊<span class="hljs-comment">//把简单的文本字符串上传到服务器</span>
<span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(); ➋<span class="hljs-comment">//通过 FormData API 动态创建表单数据</span>
formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-number">123456</span>);
formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;topic&#x27;</span>, <span class="hljs-string">&#x27;performance&#x27;</span>);
<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>);
xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;
xhr.<span class="hljs-title function_">send</span>(formData); ➌<span class="hljs-comment">//向服务器上传 multipart/form-data 对象</span>
<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>);
xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;
<span class="hljs-keyword">var</span> uInt8Array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); ➍<span class="hljs-comment">//创建无符号、8 字节整型的有类型数组（ArrayBuffer）</span>
xhr.<span class="hljs-title function_">send</span>(uInt8Array.<span class="hljs-property">buffer</span>); ➎<span class="hljs-comment">//向服务器上传字节块</span></code></pre></div>

<p>XHR 对象的 send() 方法可以接受 DOMString、Document、FormData、Blob、File 及ArrayBuffer 对象，并自动完成相应的编码，设置适当的 HTTP 内容类型 (content-type)，然后再分派请求。需要发送二进制 Blob 或上传用户提交的文件？简单，取得对该对象的引用，传给 XHR</p>
<p>如果上传文件过大，还可以将文件分块上传</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> blob = ...; ➊<span class="hljs-comment">//任意数据（二进制或文本）的二进制对象</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BYTES_PER_CHUNK</span> = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; ➋<span class="hljs-comment">//将块大小设置为 1 MB</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SIZE</span> = blob.<span class="hljs-property">size</span>;
<span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> end = <span class="hljs-variable constant_">BYTES_PER_CHUNK</span>;
<span class="hljs-keyword">while</span>(start &lt; <span class="hljs-variable constant_">SIZE</span>) &#123; ➌<span class="hljs-comment">//以 1 MB 为步长迭代数据块</span>
 <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
 xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>);
 xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;
 xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Range&#x27;</span>, start+<span class="hljs-string">&#x27;-&#x27;</span>+end+<span class="hljs-string">&#x27;/&#x27;</span>+<span class="hljs-variable constant_">SIZE</span>); ➍<span class="hljs-comment">//告诉服务器上传的数据范围（开始位置 - 结束位置 / 总大小）</span>
 xhr.<span class="hljs-title function_">send</span>(blob.<span class="hljs-title function_">slice</span>(start, end)); ➎<span class="hljs-comment">//通过 XHR 上传 1 MB 大小的数据片段</span>
 start = end;
 end = start + <span class="hljs-variable constant_">BYTES_PER_CHUNK</span>;
&#125;</code></pre></div>

<p>XHR 不支持请求流，这意味着在调用 send() 时必须提供完整的文件。不过，前面的例子示范了一个简单的解决方案：切分文件，然后通过多个 XHR 请求分段上传。这种实现方案当然不能替代真正的请求流 API，但对某些应用来说却是一个可行的方案。</p>
<p><em><strong>切分大文件上传是个不错的技巧，适合连接不稳定或经常中断的场景。此时，假如某个块由于掉线而上传失败，应用可以随后只重新上传该块，而不必重新上传整个大文件。</strong></em></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="category-chain-item">web性能优化</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">#web性能权威指南</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>web性能权威指南</div>
      <div>http://example.com/2022/12/09/web性能权威指南/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/11/hello-world/" title="Hello World">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/09/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" title="http权威指南">
                        <span class="hidden-mobile">http权威指南</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
