<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/20/hello-world/"/>
    <url>/2023/03/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C-Primer-Plus2</title>
    <link href="/2023/03/04/C-Primer-Plus2/"/>
    <url>/2023/03/04/C-Primer-Plus2/</url>
    
    <content type="html"><![CDATA[<h1 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h1><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><p>编译过程的最终产品是可执行程序——由一组机器语言指令组成。 运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环或分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 </p><p>C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数 调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本</p><p>应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代 码执行时间很短，则内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。</p><img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-04%2020.41.35.png" style="zoom:50%;" /><p>要使用这项特性，必须采取下述措施之一：</p><ul><li>在函数声明前加上关键字inline； </li><li>在函数定义前加上关键字inline。</li></ul><p>通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。</p><p>程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己（内联函数不能递 归），因此不将其作为内联函数；而有些编译器没有启用或实现这种特性。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// inline.cpp -- using an inline function</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// an inline function definition</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> a, b;    <span class="hljs-type">double</span> c = <span class="hljs-number">13.0</span>;    a = <span class="hljs-built_in">square</span>(<span class="hljs-number">5.0</span>);    b = <span class="hljs-built_in">square</span>(<span class="hljs-number">4.5</span> + <span class="hljs-number">7.5</span>);   <span class="hljs-comment">// can pass expressions</span>    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c;    cout &lt;&lt; <span class="hljs-string">&quot;, c squared = &quot;</span> &lt;&lt; <span class="hljs-built_in">square</span>(c++) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Now c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><p>C++新增了一种复合类型——引用变量。引用是已定义的变量的别 名（另一个名称）引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。</p><h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><p>前面讲过，C和C++使用&amp;符号来指示变量的地址。C++给&amp;符号赋予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量 的别名，可以这样做： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> rats;<span class="hljs-built_in">int</span> &amp; rodents = rats <span class="hljs-comment">//make rodents an alias for rats</span></code></pre></div><p>其中，&amp;不是地址运算符，而是类型标识符的一部分。就像声明中的char*指的是指向char的指针一样，int &amp;指的是指向int的引用。上述引用声明允许将rats和rodents互换——它们指向相同的值和内存单元，</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// firstref.cpp -- defining and using a reference</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> rats = <span class="hljs-number">101</span>;    <span class="hljs-type">int</span> &amp; rodents = rats;   <span class="hljs-comment">// rodents is a reference</span>    cout &lt;&lt; <span class="hljs-string">&quot;rats = &quot;</span> &lt;&lt; rats;    cout &lt;&lt; <span class="hljs-string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;    rodents++;    cout &lt;&lt; <span class="hljs-string">&quot;rats = &quot;</span> &lt;&lt; rats;    cout &lt;&lt; <span class="hljs-string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;<span class="hljs-comment">// some implementations require type casting the following</span><span class="hljs-comment">// addresses to type unsigned</span>    cout &lt;&lt; <span class="hljs-string">&quot;rats address = &quot;</span> &lt;&lt; &amp;rats;    cout &lt;&lt; <span class="hljs-string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//rats = 101, rodents = 101</span><span class="hljs-comment">//rats = 102, rodents = 102</span><span class="hljs-comment">//rats address = 0x16faef738, rodents address = 0x16faef738</span></code></pre></div><p>请注意，下述语句中的&amp;运算符不是地址运算符，而是将rodents的类型声明为int &amp;，即指向int变量的引用：  </p><div class="code-wrapper"><pre><code class="hljs 1c">int <span class="hljs-meta">&amp; rodents = rats;   <span class="hljs-comment">// rodents is a reference</span></span></code></pre></div><p>但下述语句中的&amp;运算符是地址运算符，其中&amp;rodents表示rodents引用的变量的地址：</p><div class="code-wrapper"><pre><code class="hljs 1c">cout &lt;&lt; <span class="hljs-string">&quot;, rodents address = &quot;</span> &lt;&lt; <span class="hljs-meta">&amp;rodents &lt;&lt; endl;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>rats = <span class="hljs-number">101</span>, rodents = <span class="hljs-number">101</span><span class="hljs-regexp">//</span>rats = <span class="hljs-number">102</span>, rodents = <span class="hljs-number">102</span><span class="hljs-regexp">//</span>rats address = <span class="hljs-number">0</span>x16faef738, rodents address = <span class="hljs-number">0</span>x16faef738</code></pre></div><p>从中可知，rats和rodents的值和地址都相同（具体的地址和显示格式随系统而异）。将rodents加1将影响这两个变量。更准确地说， rodents++操作将一个有两个名称的变量加1。</p><p>必须在声明引用变量时进行初始化。</p><p>引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。也就是说：</p><div class="code-wrapper"><pre><code class="hljs 1c">int <span class="hljs-meta">&amp; rodents  = rats;</span></code></pre></div><p>实际上是下述代码的伪装表示：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span> pr = &amp;rats;</code></pre></div><p>其中，引用rodents扮演的角色与表达式*pr相同。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// secref.cpp -- defining and using a reference</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> rats = <span class="hljs-number">101</span>;    <span class="hljs-type">int</span> &amp; rodents = rats;   <span class="hljs-comment">// rodents is a reference</span>    cout &lt;&lt; <span class="hljs-string">&quot;rats = &quot;</span> &lt;&lt; rats;    cout &lt;&lt; <span class="hljs-string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;rats address = &quot;</span> &lt;&lt; &amp;rats;    cout &lt;&lt; <span class="hljs-string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;    <span class="hljs-type">int</span> bunnies = <span class="hljs-number">50</span>;    rodents = bunnies;       <span class="hljs-comment">// can we change the reference?</span>    cout &lt;&lt; <span class="hljs-string">&quot;bunnies = &quot;</span> &lt;&lt; bunnies;    cout &lt;&lt; <span class="hljs-string">&quot;, rats = &quot;</span> &lt;&lt; rats;    cout &lt;&lt; <span class="hljs-string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;bunnies address = &quot;</span> &lt;&lt; &amp;bunnies;    cout &lt;&lt; <span class="hljs-string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;rats = <span class="hljs-number">101</span>, rodents = <span class="hljs-number">101</span>rats address = <span class="hljs-number">0x16d5a7738</span>, rodents address = <span class="hljs-number">0x16d5a7738</span>bunnies = <span class="hljs-number">50</span>, rats = <span class="hljs-number">50</span>, rodents = <span class="hljs-number">50</span>bunnies address = <span class="hljs-number">0x16d5a772c</span>, rodents address = <span class="hljs-number">0x16d5a7738</span></code></pre></div><p>最初，rodents引用的是rats，但随后程序试图将rodents作为bunnies的引用：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">rodents</span> <span class="hljs-operator">=</span> bunnies<span class="hljs-comment">;</span></code></pre></div><p>咋一看，这种意图暂时是成功的，因为rodents的值从101变为了50。但仔细研究将发现，rats也变成了50，同时rats和rodents的地址相 同，而该地址与bunnies的地址不同。由于rodents是rats的别名，因此上述赋值语句与下面的语句等效： </p><div class="code-wrapper"><pre><code class="hljs cpp">rats = bunnies;</code></pre></div><p>也就是说，这意味着“将bunnies变量的值赋给rat变量”。简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> rats = <span class="hljs-number">101</span>;<span class="hljs-type">int</span> *pt =&amp;rats;<span class="hljs-type">int</span> &amp; rodents = *pt;<span class="hljs-type">int</span> bunnies = <span class="hljs-number">50</span>;pt = &amp;bunnies;</code></pre></div><p>将rodents初始化为*pt使得rodents指向rats。接下来将pt改为指向bunnies，并不能改变这样的事实，即rodents引用的是rats。 </p><h3 id="将引用用作函数参数"><a href="#将引用用作函数参数" class="headerlink" title="将引用用作函数参数"></a>将引用用作函数参数</h3><p>引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被 调用的函数能够访问调用函数中的变量。C++新增的这项特性是对C语言的超越，C语言只能按值传递。按值传递导致被调用函数使用调用程序的值的拷贝（参见图8.2）。当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。</p><img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-05%2010.01.02.png" style="zoom:50%;" /><p>现在我们通过一个常见的的计算机问题——交换两个变量的值，对使用引用和使用指针做一下比较。交换函数必须能够修改调用程序中的 变量的值。这意味着按值传递变量将不管用，因为函数将交换原始变量副本的内容，而不是变量本身的内容。但传递引用时，函数将可以使用原始数据。另一种方法是，传递指针来访问原始数据。程序清单8.4演示了这三种方法，其中包括一种不可行的方法，以便您能对这些方法进行比较</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// swaps.cpp -- swapping with references and with pointers</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapr</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a, <span class="hljs-type">int</span> &amp; b)</span></span>;   <span class="hljs-comment">// a, b are aliases for ints</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapp</span><span class="hljs-params">(<span class="hljs-type">int</span> * p, <span class="hljs-type">int</span> * q)</span></span>;   <span class="hljs-comment">// p, q are addresses of ints</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;       <span class="hljs-comment">// a, b are new variables</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> wallet1 = <span class="hljs-number">300</span>;    <span class="hljs-type">int</span> wallet2 = <span class="hljs-number">350</span>;    cout &lt;&lt; <span class="hljs-string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;    cout &lt;&lt; <span class="hljs-string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Using references to swap contents:\n&quot;</span>;    <span class="hljs-built_in">swapr</span>(wallet1, wallet2);   <span class="hljs-comment">// pass variables</span>    cout &lt;&lt; <span class="hljs-string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;    cout &lt;&lt; <span class="hljs-string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Using pointers to swap contents again:\n&quot;</span>;    <span class="hljs-built_in">swapp</span>(&amp;wallet1, &amp;wallet2); <span class="hljs-comment">// pass addresses of variables</span>    cout &lt;&lt; <span class="hljs-string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;    cout &lt;&lt; <span class="hljs-string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Trying to use passing by value:\n&quot;</span>;    <span class="hljs-built_in">swapv</span>(wallet1, wallet2);   <span class="hljs-comment">// pass values of variables</span>    cout &lt;&lt; <span class="hljs-string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;    cout &lt;&lt; <span class="hljs-string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapr</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a, <span class="hljs-type">int</span> &amp; b)</span>    <span class="hljs-comment">// use references</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> temp;    temp = a;       <span class="hljs-comment">// use a, b for values of variables</span>    a = b;    b = temp;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapp</span><span class="hljs-params">(<span class="hljs-type">int</span> * p, <span class="hljs-type">int</span> * q)</span>    <span class="hljs-comment">// use pointers</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> temp;    temp = *p;      <span class="hljs-comment">// use *p, *q for values of variables</span>    *p = *q;    *q = temp;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>        <span class="hljs-comment">// try using values</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> temp;    temp = a;      <span class="hljs-comment">// use a, b for values of variables</span>    a = b;    b = temp;&#125;<span class="hljs-comment">//wallet1 = $300 wallet2 = $350</span><span class="hljs-comment">//Using references to swap contents:</span><span class="hljs-comment">//wallet1 = $350 wallet2 = $300</span><span class="hljs-comment">//Using pointers to swap contents again:</span><span class="hljs-comment">//wallet1 = $300 wallet2 = $350</span><span class="hljs-comment">//Trying to use passing by value:</span><span class="hljs-comment">//wallet1 = $300 wallet2 = $350</span></code></pre></div><p>引用和指针方法都成功地交换了两个钱夹（wallet）中的内容，而按值传递的方法没能完成这项任务。</p><p>按引用传递（swapr(wallet1, wallet2)）和按值传递（swapv(wallet1, waller2)）看起来相同。只能通过原型或函数定义才能知道swapr( )是按 引用传递的。然而，地址运算符（&amp;）使得按地址传递 （swapp(&amp;wallet1, &amp;wallet2)）一目了然（类型声明int * p表明，p是一 个int指针，因此与p对应的参数应为地址，如&amp;wallet1）。</p><p>接下来，比较函数swapr( )（按引用传递）和swapv( )（按值传递）的代码，唯一的外在区别是声明函数参数的方式不同：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">swapr</span>(wallet1, wallet2);   <span class="hljs-comment">// pass variables</span><span class="hljs-built_in">swapv</span>(wallet1, wallet2);   <span class="hljs-comment">// pass values of variables</span></code></pre></div><p>当然还有内在区别：在swapr( )中，变量a和b是wallet1和wallet2的别名，所以交换a和b的值相当于交换wallet1和wallet2的值；但在swapv( )中，变量a和b是复制了wallet1和waller2的值的新变量，因此交换a和b的,值并不会影响wallet1和wallet2的值。</p><p>最后，比较函数swapr( )（传递引用）和swapp( )（传递指针）。第一个区别是声明函数参数的方式不同：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapr</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a, <span class="hljs-type">int</span> &amp; b)</span></span>;   <span class="hljs-comment">// a, b are aliases for ints</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapp</span><span class="hljs-params">(<span class="hljs-type">int</span> * p, <span class="hljs-type">int</span> * q)</span></span>;   <span class="hljs-comment">// p, q are addresses of ints</span></code></pre></div><p>另一个区别是指针版本需要在函数使用p和q的整个过程中使用解除引用运算符*。</p><p>前面说过，应在定义引用变量时对其进行初始化。函数调用使用实参初始化形参，因此函数的引用参数被初始化为函数调用传递的实参。 也就是说，下面的函数调用将形参a和b分别初始化为wallet1和wallet2：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">swapr</span>(wallet1, wallet2);</code></pre></div><h3 id="引用的属性和特别之处"><a href="#引用的属性和特别之处" class="headerlink" title="引用的属性和特别之处"></a>引用的属性和特别之处</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// cubes.cpp -- regular and reference arguments</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span>;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">refcube</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;ra)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> x = <span class="hljs-number">3.0</span>;    cout &lt;&lt; <span class="hljs-built_in">cube</span>(x);    cout &lt;&lt; <span class="hljs-string">&quot; = cube of &quot;</span> &lt;&lt; x &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-built_in">refcube</span>(x);    cout &lt;&lt; <span class="hljs-string">&quot; = cube of &quot;</span> &lt;&lt; x &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span><span class="hljs-function"></span>&#123;    a *= a * a;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">refcube</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;ra)</span></span><span class="hljs-function"></span>&#123;    ra *= ra * ra;    <span class="hljs-keyword">return</span> ra;&#125;<span class="hljs-comment">//27 = cube of 3</span><span class="hljs-comment">//27 = cube of 27</span></code></pre></div><p>refcube( )函数修改了main( )中的x值，而cube( )没有，这提醒我们为何通常按值传递。变量a位于cube( )中，它被初始化为x的值，但修改a并不会影响x。但由于refcube( )使用了引用参数，因此修改ra实际上就是修改x。如果程序员的意图是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用。例如，在这个例子中，应在函数原型和函数头中使用const： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> <span class="hljs-built_in">ref</span>cube(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> &amp;ra);</code></pre></div><p>如果这样做，当编译器发现代码修改了ra的值时，将生成错误消息</p><p>顺便说一句，如果要编写类似于上述示例的函数（即使用基本数值类型），应采用按值传递的方式，而不要采用按引用传递的方式。当数 据比较大（如结构和类）时，引用参数将很有用</p><p>按值传递的函数，如程序清单8.5中的函数cube( )，可使用多种类型的实参。例如，下面的调用都是合法的：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">double</span> z = cube(x+<span class="hljs-number">2</span>.<span class="hljs-number">0</span>);<span class="hljs-attribute">z</span> = cube(<span class="hljs-number">8</span>.<span class="hljs-number">0</span>);<span class="hljs-attribute">int</span> k = <span class="hljs-number">10</span>;<span class="hljs-attribute">z</span> = cube(k);<span class="hljs-attribute">double</span> yo[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>.<span class="hljs-number">2</span>,<span class="hljs-number">3</span>.<span class="hljs-number">3</span>,<span class="hljs-number">4</span>.<span class="hljs-number">4</span>&#125;;<span class="hljs-attribute">z</span> = cube(yo[<span class="hljs-number">2</span>]);</code></pre></div><p>如果将与上面类似的参数传递给接受引用参数的函数，将会发现，传递引用的限制更严格。毕竟，如果ra是一个变量的别名，则实参应是 该变量。下面的代码不合理，因为表达式x + 3.0并不是变量：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> z = <span class="hljs-built_in">ref</span>cube(x+<span class="hljs-number">3.0</span>);</code></pre></div><p>例如，不能将值赋给该表达式：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>+<span class="hljs-number">3</span>.<span class="hljs-number">0</span> = <span class="hljs-number">5</span>.<span class="hljs-number">0</span>;</code></pre></div><p>如果试图使用像refcube(x + 3.0)这样的函数调用，将发生什么情况呢？在现代的C++中，这是错误的，大多数编译器都将指出这一点；</p><p>之所以做出这种比较温和的反应是由于早期的C++确实允许将表达式传递给引用变量。有些情况下，仍然是这样做的。这样做的结果如 下：由于x + 3.0不是double类型的变量，因此程序将创建一个临时的无名变量，并将其初始化为表达式x + 3.0的值。然后，ra将成为该临时变量的引用。下面详细讨论这种临时变量，看看什么时候创建它们，什么时候不创建</p><p>临时变量、引用参数和<strong>const</strong> </p><p>如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这样做，但以前不是这样。下面来看看何 种情况下，C++将生成临时变量，以及为何对const引用的限制是合理的。</p><p>首先，什么时候将创建临时变量呢？如果引用参数是const，则编译器将在下面两种情况下生成临时变量：</p><ul><li>实参的类型正确，但不是左值； </li><li>实参的类型不正确，但可以转换为正确的类型。</li></ul><p>左值是什么呢？左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面 常量（用引号括起的字符串除外，它们由其地址表示）和包含多项的表达式。在C语言中，左值最初指的是可出现在赋值语句左边的实体，但这是引入关键字const之前的情况。现在，常规变量和const变量都可视为左值，因为可通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可修改的左值。 </p><p>回到前面的示例。假设重新定义了refcube( )，使其接受一个常量引用参数：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> <span class="hljs-built_in">ref</span>cube(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> &amp;ra)&#123;    <span class="hljs-keyword">return</span> ra*ra * ra;;&#125;</code></pre></div><p>现在考虑下面的代码： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> side = <span class="hljs-number">3.0</span>;<span class="hljs-built_in">double</span> * pd = &amp;side;<span class="hljs-built_in">double</span> &amp; rd = sidelong edge = side;<span class="hljs-built_in">double</span> lens[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">2.0</span>,<span class="hljs-number">5.0</span>,<span class="hljs-number">10.0</span>,<span class="hljs-number">12.0</span>&#125;;<span class="hljs-built_in">double</span> c1 = <span class="hljs-built_in">ref</span>cube(side);<span class="hljs-built_in">double</span> c2 = <span class="hljs-built_in">ref</span>cube(lens[<span class="hljs-number">2</span>]);<span class="hljs-built_in">double</span> c3 = <span class="hljs-built_in">ref</span>cube(rd);<span class="hljs-built_in">double</span> c4 = <span class="hljs-built_in">ref</span>cube(*pd);<span class="hljs-built_in">double</span> c5 = <span class="hljs-built_in">ref</span>cube(edge);<span class="hljs-built_in">double</span> c6 = <span class="hljs-built_in">ref</span>cube(<span class="hljs-number">7.0</span>);<span class="hljs-built_in">double</span> c7 = <span class="hljs-built_in">ref</span>cube(side + <span class="hljs-number">10.0</span>);</code></pre></div><p>参数side、lens[2]、rd和*pd都是有名称的、double类型的数据对象，因此可以为其创建引用，而不需要临时变量（还记得吗，数组元素 的行为与同类型的变量类似）。然而，edge虽然是变量，类型却不正确，double引用不能指向long。另一方面，参数7.0和side + 10.0的类型都正确，但没有名称，在这些情况下，编译器都将生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器便可以随意将其删除。 </p><p>那么为什么对于常量引用，这种行为是可行的，其他情况下却不行的呢？对于程序清单8.4中的函数swapr( )：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapr</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a, <span class="hljs-type">int</span> &amp; b)</span>    <span class="hljs-comment">// use references</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> temp;    temp = a;       <span class="hljs-comment">// use a, b for values of variables</span>    a = b;    b = temp;&#125;</code></pre></div><p>如果在早期C++较宽松的规则下，执行下面的操作将发生什么情况呢？</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">long</span> a = <span class="hljs-number">3</span>,b = <span class="hljs-number">5</span>;<span class="hljs-attribute">swapr</span>(a,b);</code></pre></div><p>这里的类型不匹配，因此编译器将创建两个临时int变量，将它们初始化为3和5，然后交换临时变量的内容，而a和b保持不变。 </p><p>简而言之，如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将阻止这种意图的实现。解决方法是，禁止创建 临时变量，现在的C++标准正是这样做的（然而，在默认情况下，有些编译器仍将发出警告，而不是错误消息，因此如果看到了有关临时变量的警告，请不要忽略）。 </p><p>现在来看refcube( )函数。该函数的目的只是使用传递的值，而不是修改它们，因此临时变量不会造成任何不利的影响，反而会使函数在可处理的参数种类方面更通用。因此，如果声明将引用指定为const，C++将在必要时生成临时变量。实际上，对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值。 </p><p>如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。</p><p>将引用参数声明为常量数据的引用的理由有三个： </p><ul><li>使用const可以避免无意中修改数据的编程错误； </li><li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据； </li><li>使用const引用使函数能够正确生成并使用临时变量。</li></ul><p>C++11新增了另一种引用——右值引用（rvalue reference）。这种引用可指向右值，是使用&amp;&amp;声明的： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">double</span> &amp;&amp; rref = std::<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">36.00</span>); <span class="hljs-comment">//not allowed for double &amp;</span><span class="hljs-type">double</span> j =<span class="hljs-number">15.0</span>;<span class="hljs-type">double</span> &amp;&amp; jref = <span class="hljs-number">2.0</span>*j + <span class="hljs-number">18.5</span>;std::cout &lt;&lt; rref &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;std::cout &lt;&lt; jref &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;</code></pre></div><p>新增右值引用的主要目的是，让库设计人员能够提供有些操作的更有效实现。</p><h3 id="将引用用于结构"><a href="#将引用用于结构" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h3><p>引用非常适合用于结构和类（C++的用户定义类型）。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//strc_ref.cpp -- using structure references</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_throws</span>&#123;    std::string name;    <span class="hljs-type">int</span> made;    <span class="hljs-type">int</span> attempts;    <span class="hljs-type">float</span> percent;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> free_throws &amp; ft)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_pc</span><span class="hljs-params">(free_throws &amp; ft)</span></span>;<span class="hljs-function">free_throws &amp; <span class="hljs-title">accumulate</span><span class="hljs-params">(free_throws &amp;target, <span class="hljs-type">const</span> free_throws &amp;source)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    free_throws one = &#123;<span class="hljs-string">&quot;Ifelsa Branch&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>&#125;;    free_throws two = &#123;<span class="hljs-string">&quot;Andor Knott&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">16</span>&#125;;    free_throws three = &#123;<span class="hljs-string">&quot;Minnie Max&quot;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;    free_throws four = &#123;<span class="hljs-string">&quot;Whily Looper&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;    free_throws five = &#123;<span class="hljs-string">&quot;Long Long&quot;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">14</span>&#125;;    free_throws team = &#123;<span class="hljs-string">&quot;Throwgoods&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;    free_throws dup;    <span class="hljs-built_in">set_pc</span>(one);    <span class="hljs-built_in">display</span>(one);    <span class="hljs-built_in">accumulate</span>(team, one);    <span class="hljs-built_in">display</span>(team);<span class="hljs-comment">// use return value as argument</span>    <span class="hljs-built_in">display</span>(<span class="hljs-built_in">accumulate</span>(team, two));    <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">accumulate</span>(team, three), four);    <span class="hljs-built_in">display</span>(team);<span class="hljs-comment">// use return value in assignment</span>    dup = <span class="hljs-built_in">accumulate</span>(team,five);    std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying team:\n&quot;</span>;    <span class="hljs-built_in">display</span>(team);    std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying dup after assignment:\n&quot;</span>;    <span class="hljs-built_in">display</span>(dup);    <span class="hljs-built_in">set_pc</span>(four);<span class="hljs-comment">// ill-advised assignment</span>    <span class="hljs-built_in">accumulate</span>(dup,five) = four;    std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying dup after ill-advised assignment:\n&quot;</span>;    <span class="hljs-built_in">display</span>(dup);    <span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> free_throws &amp; ft)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> std::cout;    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; ft.name &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;  Made: &quot;</span> &lt;&lt; ft.made &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Attempts: &quot;</span> &lt;&lt; ft.attempts &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Percent: &quot;</span> &lt;&lt; ft.percent &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_pc</span><span class="hljs-params">(free_throws &amp; ft)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (ft.attempts != <span class="hljs-number">0</span>)        ft.percent = <span class="hljs-number">100.0f</span> *<span class="hljs-built_in">float</span>(ft.made)/<span class="hljs-built_in">float</span>(ft.attempts);    <span class="hljs-keyword">else</span>        ft.percent = <span class="hljs-number">0</span>;&#125;<span class="hljs-function">free_throws &amp; <span class="hljs-title">accumulate</span><span class="hljs-params">(free_throws &amp; target, <span class="hljs-type">const</span> free_throws &amp; source)</span></span><span class="hljs-function"></span>&#123;    target.attempts += source.attempts;    target.made += source.made;    <span class="hljs-built_in">set_pc</span>(target);    <span class="hljs-keyword">return</span> target;&#125;</code></pre></div><p>该程序首先初始化了多个结构对象。本书前面说过，如果指定的初始值比成员少，余下的成员（这里只有percent）将被设置为零。第一个函数调用如下： </p><div class="code-wrapper"><pre><code class="hljs reasonml">set<span class="hljs-constructor">_pc(<span class="hljs-params">one</span>)</span>;</code></pre></div><p>由于函数set_pc()的形参ft为引用，因此ft指向one，函数set_pc()的代码设置成员one.percent。就这里而言，按值传递不可行，因此这将导致设置的是one的临时拷贝的成员percent。根据前一章介绍的知识，另一种方法是使用指针参数并传递地址，但要复杂些：</p><div class="code-wrapper"><pre><code class="hljs xl">set_prop(&amp;one)void set_prop(free_throws * one)&#123;<span class="hljs-function"><span class="hljs-title">if</span>(pt-&gt;</span>attempts！=<span class="hljs-number">0</span>)<span class="hljs-function"><span class="hljs-title">pt</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">percent</span> = 100.0f*float(pt-&gt;</span><span class="hljs-function"><span class="hljs-title">made</span>)/float(pt-&gt;</span>attempts);<span class="hljs-keyword">else</span><span class="hljs-function"><span class="hljs-title">pt</span>-&gt;</span>percent = <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">display</span><span class="hljs-params">(one)</span></span></code></pre></div><p>由于display()显示结构的内容，而不修改它，因此这个函数使用了一个const引用参数。就这个函数而言，也可按值传递结构，但与复制原始结构的拷贝相比，使用引用可节省时间和内存。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">accumulate</span>(team, one);</code></pre></div><p>函数accumulate()接收两个结构参数，并将第二个结构的成员attempts和made的数据添加到第一个结构的相应成员中。只修改了第一 个结构，因此第一个参数为引用，而第二个参数为const引用：</p><div class="code-wrapper"><pre><code class="hljs ceylon">free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; accumulate(free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; target, const free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; source)</code></pre></div><p>返回值呢？当前讨论的函数调用没有使用它；就目前而言，原本可以将返回值声明为void，但请看下述函数调用： </p><div class="code-wrapper"><pre><code class="hljs lisp">display(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>, two))<span class="hljs-comment">;</span></code></pre></div><p>首先，将结构对象team作为第一个参数传递给了accumulate()。这意味着在函数accumulate()中，target指向的是 team。函数accumulate()修改team，再返回指向它的引用</p><div class="code-wrapper"><pre><code class="hljs ceylon">free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; accumulate(free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; target, const free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; source)</code></pre></div><p>如果返回类型被声明为free_throws而不是free_throws &amp;，上述返回语句将返回target（也就是team）的拷贝。但返回类型为引用，这意味着返回的是最初传递给accumulate()的team对象。 </p><p>接下来，将accumulate()的返回值作为参数传递给了display()，这意味着将team传递给了display()。display()的参数为引用，这意味着函数display()中的ft指向的是team，因此将显示team的内容。所以，下述代码：</p><div class="code-wrapper"><pre><code class="hljs lisp">display(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>, two))<span class="hljs-comment">;</span></code></pre></div><p>与下面的代码等效： </p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">accumulate</span><span class="hljs-params">(team, two)</span></span><span class="hljs-function"><span class="hljs-title">diaplay</span><span class="hljs-params">(team)</span></span></code></pre></div><p>上述逻辑也适用于如下语句：</p><div class="code-wrapper"><pre><code class="hljs lisp">accumulate(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>, three), four)<span class="hljs-comment">;</span></code></pre></div><p>因此，该语句与下面的语句等效： </p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">accumulate</span>(team, three);<span class="hljs-built_in">accumulate</span>(team, four);</code></pre></div><p>接下来，程序使用了一条赋值语句：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">dup</span> = accumulate(team,five)<span class="hljs-comment">;</span></code></pre></div><p>正如您预期的，这条语句将team中的值复制到dup中。 </p><p>最后，程序以独特的方式使用了accumulate()：</p><div class="code-wrapper"><pre><code class="hljs fix"><span class="hljs-attr">accumulate(dup,five) </span>=<span class="hljs-string"> four;</span></code></pre></div><p>这条语句将值赋给函数调用，这是可行的，因为函数的返回值是一个引用。如果函数accumulate()按值返回，这条语句将不能通过编译。 由于返回的是指向dup的引用，因此上述代码与下面的代码等效</p><div class="code-wrapper"><pre><code class="hljs hsp">accumulate(<span class="hljs-keyword">dup</span>,five)<span class="hljs-comment">;</span><span class="hljs-keyword">dup</span> = four<span class="hljs-comment">;</span></code></pre></div><p>其中第二条语句消除了第一条语句所做的工作，因此在原始赋值语句使用accumulate()的方式并不好。 </p><h4 id="为何要返回引用"><a href="#为何要返回引用" class="headerlink" title="为何要返回引用"></a>为何要返回引用</h4><p>下面更深入地讨论返回引用与传统返回机制的不同之处。传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将 结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而调用程序将使用这个值。请看下面的代码：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">double</span> m = sqrt(<span class="hljs-number">16</span>.<span class="hljs-number">0</span>);<span class="hljs-attribute">cout</span> &lt;&lt; sqrt(<span class="hljs-number">25</span>.<span class="hljs-number">0</span>);</code></pre></div><p>在第一条语句中，值4.0被复制到一个临时位置，然后被复制给m。在第二条语句中，值5.0被复制到一个临时位置，然后被传递给cout（这里理论上的描述，实际上，编译器可能合并某些步骤）。 </p><p>现在来看下面的语句：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">dup</span> = accumulate(team,five)<span class="hljs-comment">;</span></code></pre></div><p>如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为 引用时，将直接把team复制到dup，其效率更高。 </p><p>返回引用的函数实际上是被引用的变量的别名。 </p><h4 id="返回引用时需要注意的问题"><a href="#返回引用时需要注意的问题" class="headerlink" title="返回引用时需要注意的问题"></a>返回引用时需要注意的问题</h4><p>返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。您应避免编写下面这样的代码：</p><div class="code-wrapper"><pre><code class="hljs haxe">const free_throws &amp; clone2(free_throws &amp; ft)&#123;free_throws <span class="hljs-keyword">new</span><span class="hljs-type">guy</span>;<span class="hljs-keyword">new</span><span class="hljs-type">guy</span> = ft;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">guy</span>;&#125;</code></pre></div><p>该函数返回一个指向临时变量（newguy）的引用，函数运行完毕后它将不再存在。第9章将讨论各种变量的持续性。同样，也应避免返回 指向临时变量的指针。</p><p>为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用 也将指向这些数据。程序清单8.6中的accumulate()正是这样做的。 </p><p>另一种方法是用new来分配新的存储空间。前面见过这样的函数，它使用new为字符串分配内存空间，并返回指向该内存空间的指针。下 面是使用引用来完成类似工作的方法：</p><div class="code-wrapper"><pre><code class="hljs ceylon">const free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; clone(free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; ft)&#123;free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> * pt;*pt = ft;<span class="hljs-keyword">return</span> *pt;&#125;</code></pre></div><p>第一条语句创建一个无名的free_throws结构，并让指针pt指向该结构，因此*pt就是该结构。上述代码似乎会返回该结构，但函数声明表 明，该函数实际上将返回这个结构的引用。这样，便可以这样使用该函数：</p><div class="code-wrapper"><pre><code class="hljs 1c">free_throws <span class="hljs-meta">&amp; jolly = clone(three);</span></code></pre></div><p>这使得jolly成为新结构的引用。这种方法存在一个问题：在不再需要new分配的内存时，应使用delete来释放它们。调用clone( )隐藏了对new的调用，这使得以后很容易忘记使用delete来释放内存。第16章讨论的auto_ptr模板以及C++11新增的unique_ptr可帮助程序员自动完成释放工作。</p><h4 id="为何将const用于引用返回类型"><a href="#为何将const用于引用返回类型" class="headerlink" title="为何将const用于引用返回类型"></a>为何将const用于引用返回类型</h4><div class="code-wrapper"><pre><code class="hljs fix"><span class="hljs-attr">accumulate(dup,five) </span>=<span class="hljs-string"> four;</span></code></pre></div><p>其效果如下：首先将five的数据添加到dup中，再使用four的内容覆盖dup的内容。这条语句为何能够通过编译呢？在赋值语句中，左边必须是可修改的左值。也就是说，在赋值表达式中，左边的子表达式必须标识一个可修改的内存块。在这里，函数返回指向dup的引用，它确实标识的是一个这样的内存块，因此这条语句是合法的。 </p><p>另一方面，常规（非引用）返回类型是右值——不能通过地址访问的值。这种表达式可出现在赋值语句的右边，但不能出现在左边。其他 右值包括字面值（如10.0）和表达式（如x + y）。显然，获取字面值（如10.0）的地址没有意义，但为何常规函数返回值是右值呢？这是因为这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在。</p><p>假设您要使用引用返回值，但又不允许执行像给accumulate()赋值这样的操作，只需将返回类型声明为const引用： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">const</span> free_throws &amp; <span class="hljs-title">accumlate</span><span class="hljs-params">(free_throws &amp; target,<span class="hljs-type">const</span> free_throws &amp; source)</span></span>;</code></pre></div><p>现在返回类型为const，是不可修改的左值，因此下面的赋值语句不合法：</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">accumlate(dup,<span class="hljs-literal">five</span>) = <span class="hljs-literal">four</span><span class="hljs-comment">;//not allowed for const reference return</span></code></pre></div><p>该程序中的其他函数调用又如何呢？返回类型为const引用后，下面的语句仍合法：</p><div class="code-wrapper"><pre><code class="hljs lisp">display(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>,two))<span class="hljs-comment">;</span></code></pre></div><p>这是因为display()的形参也是const free_throws &amp;类型。但下面的语句不合法，因此accumulate()的第一个形参不是const： </p><div class="code-wrapper"><pre><code class="hljs lisp">accumulate(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>,three),four)<span class="hljs-comment">;</span></code></pre></div><p>这影响大吗？就这里而言不大，因为您仍可以这样做：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">accumulate</span>(team,three);<span class="hljs-built_in">accumulate</span>(team,four);</code></pre></div><p>另外，您仍可以在赋值语句右边使用accumulate()。 </p><p>通过省略const，可以编写更简短代码，但其含义也更模糊,通常，应避免在设计中添加模糊的特性，因为模糊特性增加了犯错 的机会。将返回类型声明为const引用，可避免您犯糊涂。然而，有时候省略const确实有道理，第11章将讨论的重载运算符&lt;&lt;就是一个这样的例子</p><h3 id="将引用用于类对象"><a href="#将引用用于类对象" class="headerlink" title="将引用用于类对象"></a>将引用用于类对象</h3><p>将类对象传递给函数时，C++通常的做法是使用引用</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strquote.cpp  -- different designs</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function">string <span class="hljs-title">version1</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span></span>;<span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version2</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span></span>;  <span class="hljs-comment">// has side effect</span><span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version3</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span></span>;  <span class="hljs-comment">// bad design</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string input;    string copy;    string result;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a string: &quot;</span>;    <span class="hljs-built_in">getline</span>(cin, input);    copy = input;    cout &lt;&lt; <span class="hljs-string">&quot;Your string as entered: &quot;</span> &lt;&lt; input &lt;&lt; endl;    result = <span class="hljs-built_in">version1</span>(input, <span class="hljs-string">&quot;***&quot;</span>);    cout &lt;&lt; <span class="hljs-string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;    result = <span class="hljs-built_in">version2</span>(input, <span class="hljs-string">&quot;###&quot;</span>);    cout &lt;&lt; <span class="hljs-string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Resetting original string.\n&quot;</span>;    input = copy;    result = <span class="hljs-built_in">version3</span>(input, <span class="hljs-string">&quot;@@@&quot;</span>);    cout &lt;&lt; <span class="hljs-string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function">string <span class="hljs-title">version1</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span></span><span class="hljs-function"></span>&#123;    string temp;    temp = s2 + s1 + s2;    <span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version2</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span>   <span class="hljs-comment">// has side effect</span></span><span class="hljs-function"></span>&#123;    s1 = s2 + s1 + s2;<span class="hljs-comment">// safe to return reference passed to function</span>    <span class="hljs-keyword">return</span> s1;&#125;<span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version3</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span>   <span class="hljs-comment">// bad design</span></span><span class="hljs-function"></span>&#123;    string temp;    temp = s2 + s1 + s2;<span class="hljs-comment">// unsafe to return reference to local variable</span>    <span class="hljs-keyword">return</span> temp;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-built_in">string</span> <span class="hljs-title function_">version1</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; s2</span>)&#123;    <span class="hljs-built_in">string</span> temp;    temp = s2 + s1 + s2;    <span class="hljs-keyword">return</span> temp;&#125;</code></pre></div><p>它接受两个string参数，并使用string类的相加功能来创建一个满足要求的新字符串。这两个函数参数都是const引用。如果使用string对象作为参数，最终结果将不变： </p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">version4</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s1,<span class="hljs-built_in">string</span> s2</span>)</span>;</code></pre></div><p>在这种情况下，s1和s2将为string对象。使用引用的效率更高，因为函数不需要创建新的string对象，并将原来对象中的数据复制到新对象中。限定符const指出，该函数将使用原来的string对象，但不会修改它。</p><p>temp是一个新的string对象，只在函数version1( )中有效，该函数执行完毕后，它将不再存在。因此，返回指向temp的引用不可行，因此该 函数的返回类型为string，这意味着temp的内容将被复制到一个临时存储单元中，然后在main( )中，该存储单元的内容被复制到一个名为result的string中： </p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = version1(input, <span class="hljs-string">&quot;***&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><p>对于函数version1( )，您可能注意到了很有趣的一点：该函数的两个形参（s1和s2）的类型都是const string &amp;，但实参（input和“***”）的类型分别是string和const char *。由于input的类型为string，因此让s1指向它没有任何问题。然而，程序怎么能够接受将char指针赋给string引用呢？</p><p>这里有两点需要说明。首先，string类定义了一种char *到string的转换功能，这使得可以 使用C-风格字符串来初始化string对象。其次是本章前面讨论过的类型为const引用的形参的一 个属性。假设实参的类型与引用参数类型不匹配，但可被转换为引用类型，程序将创建一个 正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引 用。例如，在本章前面，将int实参传递给const double &amp;形参时，就是以这种方式进行处理 的。同样，也可以将实参char *或const char *传递给形参const string &amp;。</p><p>这种属性的结果是，如果形参类型为const string &amp;，在调用函数时，使用的实参可以是string对象或C-风格字符串，如用引号括起的字符串字面量、以空字符结尾的char数组或指向char的指针变量。因此，下面的代码是可行的：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = version1(input, <span class="hljs-string">&quot;***&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><p>函数version2( )不创建临时string对象，而是直接修改原来的string对象：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">const</span> string &amp; version2(string &amp; <span class="hljs-built_in">s1</span>, const string &amp; <span class="hljs-built_in">s2</span>)   <span class="hljs-comment">// has side effect</span>&#123;    <span class="hljs-built_in">s1</span> = <span class="hljs-built_in">s2</span> + <span class="hljs-built_in">s1</span> + <span class="hljs-built_in">s2</span><span class="hljs-comment">;</span><span class="hljs-comment">// safe to return reference passed to function</span>    return <span class="hljs-built_in">s1</span><span class="hljs-comment">;</span>&#125;</code></pre></div><p>该函数可以修改s1，因为不同于s2，s1没有被声明为const。 </p><p>由于s1是指向main( )中一个对象（input）的引用，因此将s1最为引用返回是安全的。由于s1是指向input的引用，因此，下面一行代码：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = version2(input, <span class="hljs-string">&quot;###&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><p>等价于</p><div class="code-wrapper"><pre><code class="hljs hsp">version2(<span class="hljs-keyword">input</span>, <span class="hljs-string">&quot;###&quot;</span>)<span class="hljs-comment">;</span>result = <span class="hljs-keyword">input</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version3</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span>   <span class="hljs-comment">// bad design</span></span><span class="hljs-function"></span>&#123;    string temp;    temp = s2 + s1 + s2;<span class="hljs-comment">// unsafe to return reference to local variable</span>    <span class="hljs-keyword">return</span> temp;&#125;</code></pre></div><p>它存在一个致命的缺陷：返回一个指向version3( )中声明的变量的引用。这个函数能够通过编译（但编译器会发出警告），但当程序试图 执行该函数时将崩溃。具体地说，问题是由下面的赋值语句引发的：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = version3(input, <span class="hljs-string">&quot;@@@&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><p>程序试图引用已经释放的内存。</p><h3 id="对象、继承和引用"><a href="#对象、继承和引用" class="headerlink" title="对象、继承和引用"></a>对象、继承和引用</h3><p>继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。这种特征的一个实际结果是，可以定义一个接受基类引 用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//filefunc.cpp -- function with ostream &amp; parameter</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">file_it</span><span class="hljs-params">(ostream &amp; os, <span class="hljs-type">double</span> fo, <span class="hljs-type">const</span> <span class="hljs-type">double</span> fe[],<span class="hljs-type">int</span> n)</span></span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> LIMIT = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    ofstream fout;    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * fn = <span class="hljs-string">&quot;ep-data.txt&quot;</span>;    fout.<span class="hljs-built_in">open</span>(fn);    <span class="hljs-keyword">if</span> (!fout.<span class="hljs-built_in">is_open</span>())    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t open &quot;</span> &lt;&lt; fn &lt;&lt; <span class="hljs-string">&quot;. Bye.\n&quot;</span>;        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-type">double</span> objective;    cout &lt;&lt; <span class="hljs-string">&quot;Enter the focal length of your &quot;</span>            <span class="hljs-string">&quot;telescope objective in mm: &quot;</span>;    cin &gt;&gt; objective;    <span class="hljs-type">double</span> eps[LIMIT];    cout &lt;&lt; <span class="hljs-string">&quot;Enter the focal lengths, in mm, of &quot;</span> &lt;&lt; LIMIT         &lt;&lt; <span class="hljs-string">&quot; eyepieces:\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LIMIT; i++)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Eyepiece #&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;        cin &gt;&gt; eps[i];    &#125;    <span class="hljs-built_in">file_it</span>(fout, objective, eps, LIMIT);    <span class="hljs-built_in">file_it</span>(cout, objective, eps, LIMIT);    cout &lt;&lt; <span class="hljs-string">&quot;Done\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">file_it</span><span class="hljs-params">(ostream &amp; os, <span class="hljs-type">double</span> fo, <span class="hljs-type">const</span> <span class="hljs-type">double</span> fe[],<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// save initial formatting state</span>    ios_base::fmtflags initial;    initial = os.<span class="hljs-built_in">setf</span>(ios_base::fixed, ios_base::floatfield);    std::streamsize sz = os.<span class="hljs-built_in">precision</span>(<span class="hljs-number">0</span>);    os &lt;&lt; <span class="hljs-string">&quot;Focal length of objective: &quot;</span> &lt;&lt; fo &lt;&lt; <span class="hljs-string">&quot; mm\n&quot;</span>;    os.<span class="hljs-built_in">precision</span>(<span class="hljs-number">1</span>);    os.<span class="hljs-built_in">width</span>(<span class="hljs-number">12</span>);    os &lt;&lt; <span class="hljs-string">&quot;f.l. eyepiece&quot;</span>;    os.<span class="hljs-built_in">width</span>(<span class="hljs-number">15</span>);    os &lt;&lt; <span class="hljs-string">&quot;magnification&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        os.<span class="hljs-built_in">width</span>(<span class="hljs-number">12</span>);        os &lt;&lt; fe[i];        os.<span class="hljs-built_in">width</span>(<span class="hljs-number">15</span>);        os &lt;&lt; <span class="hljs-built_in">int</span> (fo/fe[i] + <span class="hljs-number">0.5</span>) &lt;&lt; endl;    &#125;    <span class="hljs-comment">// restore initial formatting state</span>    os.<span class="hljs-built_in">setf</span>(initial, ios_base::floatfield);    os.<span class="hljs-built_in">precision</span>(sz);&#125;</code></pre></div><p>对于该程序，最重要的一点是，参数os（其类型为ostream &amp;）可以指向ostream对象（如cout），也可以指向ofstream对象（如fout）。该程序还演示了如何使用ostream类中的格式化方法。方法setf( )让您能够设置各种格式化状态。例如，方法setf(ios_base::fixed)将对象置于使用定点表示法的模式；setf(ios_base::showpoint)将对象置于显示小数点的模式，即使小数部分为零。方法precision( )指定显示多少位小数（假定对象处于定点模式下）。所有这些设置都将一直保持不变，直到再次调用相应的方法重新 设置它们。方法width( )设置下一次输出操作使用的字段宽度，这种设置只在显示下一个值时有效，然后将恢复到默认设置。默认的字段宽度为零，这意味着刚好能容纳下要显示的内容。 </p><p>函数file_it( )使用了两个有趣的方法调用：</p><div class="code-wrapper"><pre><code class="hljs cpp">ios_base::fmtflags initial;    initial = os.<span class="hljs-built_in">setf</span>(ios_base::fixed, ios_base::floatfield);    std::streamsize sz = os.<span class="hljs-built_in">precision</span>(<span class="hljs-number">0</span>);    os &lt;&lt; <span class="hljs-string">&quot;Focal length of objective: &quot;</span> &lt;&lt; fo &lt;&lt; <span class="hljs-string">&quot; mm\n&quot;</span>;    os.<span class="hljs-built_in">precision</span>(<span class="hljs-number">1</span>);    os.<span class="hljs-built_in">width</span>(<span class="hljs-number">12</span>);    os &lt;&lt; <span class="hljs-string">&quot;f.l. eyepiece&quot;</span>;    os.<span class="hljs-built_in">width</span>(<span class="hljs-number">15</span>);    os &lt;&lt; <span class="hljs-string">&quot;magnification&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        os.<span class="hljs-built_in">width</span>(<span class="hljs-number">12</span>);        os &lt;&lt; fe[i];        os.<span class="hljs-built_in">width</span>(<span class="hljs-number">15</span>);        os &lt;&lt; <span class="hljs-built_in">int</span> (fo/fe[i] + <span class="hljs-number">0.5</span>) &lt;&lt; endl;    &#125;    <span class="hljs-comment">// restore initial formatting state</span>    os.<span class="hljs-built_in">setf</span>(initial, ios_base::floatfield);</code></pre></div><p>方法setf( )返回调用它之前有效的所有格式化设置。ios_base::fmtflags是存储这种信息所需的数据类型名称。因此，将返回值赋给initial将存储调用file_it( )之前的格式化设置，然后便可以使用变量initial作为参数来调用setf( )，将所有的格式化设置恢复到原来的值。因此，该函数将对象回到传递给file_it( )之前的状态。</p><p>需要说明的最后一点是，每个对象都存储了自己的格式化设置。因此，当程序将cout传递给file_it( )时，cout的设置将被修改，然后被恢 复；当程序将fout传递给file_it( )时，fout的设置将被修改，然后被恢复。</p><h3 id="何时使用引用参数"><a href="#何时使用引用参数" class="headerlink" title="何时使用引用参数"></a>何时使用引用参数</h3><p>使用引用参数的主要原因有两个。 </p><ul><li>程序员能够修改调用函数中的数据对象。 </li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。 </li></ul><p>当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于 指针的代码的另一个接口。那么，什么时候应使用引用、什么时候应使用指针呢？什么时候应按值传递呢？下面是一些指导原则： </p><ul><li>对于使用传递的值而不作修改的函数。</li><li>如果数据对象很小，如内置数据类型或小型结构，则按值传递。 </li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。 </li><li>如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。 </li><li>如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。 </li><li>对于修改调用函数中数据的函数：如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit（&amp;x）这样的代码（其中x是int），则很明显，该函数将修改x。如果数据对象是数组，则只能使用指针。 </li><li>如果数据对象是结构，则使用引用或指针。 </li><li>如果数据对象是类对象，则使用引用。 </li></ul><p>当然，这只是一些指导原则，很可能有充分的理由做出其他的选择。例如，对于基本类型，cin使用引用，因此可以使用cin&gt;&gt;n，而不是 cin &gt;&gt; &amp;n。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>默认参数指的是当函数调用中省略了实参时自动使用的一个值。</p><p>如何设置默认值呢？必须通过函数原型。由于编译器通过查看原型来了解函数所使用的参数数目，因此函数原型也必须将可能的默认参数 告知程序。方法是将值赋给原型中的参数。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">left</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str ,<span class="hljs-type">int</span> n = <span class="hljs-number">1</span>)</span></span>;</code></pre></div><p>您希望该函数返回一个新的字符串，因此将其类型设置为char *（指向char的指针）；您希望原始字符串保持不变，因此对第一个参数使用了const限定符；您希望n的默认值为1，因此将这个值赋给n。默认参数值是初始化值，因此上面的原型将n初始化为1。如果省略参数 n，则它的值将为1；否则，传递的值将覆盖1。</p><p>对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> harpo(<span class="hljs-built_in">int</span> n,<span class="hljs-built_in">int</span> m = <span class="hljs-number">4</span>,<span class="hljs-built_in">int</span> j = <span class="hljs-number">5</span>);<span class="hljs-comment">//valid</span><span class="hljs-built_in">int</span> chico(<span class="hljs-built_in">int</span> n,<span class="hljs-built_in">int</span> m = <span class="hljs-number">6</span>,<span class="hljs-built_in">int</span> j);<span class="hljs-comment">//invalid</span><span class="hljs-built_in">int</span> groucho(<span class="hljs-built_in">int</span> k = <span class="hljs-number">1</span>,<span class="hljs-built_in">int</span> m =<span class="hljs-number">2</span>,<span class="hljs-built_in">int</span> n = <span class="hljs-number">3</span>);<span class="hljs-comment">//valid</span></code></pre></div><p>实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。</p><p>程序清单8.9使用了默认参数。请注意，只有原型指定了默认值。函数定义与没有默认参数时完全相同。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// left.cpp -- string function with a default argument</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">80</span>;<span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> sample[ArSize];    cout &lt;&lt; <span class="hljs-string">&quot;Enter a string:\n&quot;</span>;    cin.<span class="hljs-built_in">get</span>(sample,ArSize);    <span class="hljs-type">char</span> *ps = <span class="hljs-built_in">left</span>(sample, <span class="hljs-number">4</span>);    cout &lt;&lt; ps &lt;&lt; endl;    <span class="hljs-keyword">delete</span> [] ps;       <span class="hljs-comment">// free old string</span>    ps = <span class="hljs-built_in">left</span>(sample);    cout &lt;&lt; ps &lt;&lt; endl;    <span class="hljs-keyword">delete</span> [] ps;       <span class="hljs-comment">// free new string</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// This function returns a pointer to a new string</span><span class="hljs-comment">// consisting of the first n characters in the str string.</span><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)        n = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> * p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n+<span class="hljs-number">1</span>];    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; str[i]; i++)        p[i] = str[i];  <span class="hljs-comment">// copy characters</span>    <span class="hljs-keyword">while</span> (i &lt;= n)        p[i++] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// set rest of string to &#x27;\0&#x27;</span>    <span class="hljs-keyword">return</span> p;&#125;</code></pre></div><p>该程序使用new创建一个新的字符串，以存储被选择的字符。一种可能出现的尴尬情况是，不合作的用户要求的字符数目可能为负。在这 种情况下，函数将字符计数设置为0，并返回一个空字符串。另一种可能出现的尴尬情况是，不负责任的用户要求的字符数目可能多于字符串包含的字符数，为预防这种情况，函数使用了一个组合测试：</p><div class="code-wrapper"><pre><code class="hljs cpp">i &lt; n &amp;&amp; str[i]；</code></pre></div><p>i &lt; n测试让循环复制了n个字符后终止。测试的第二部分——表达式str[i]，是要复制的字符的编码。遇到空值字符（其编码为0）后，循 环将结束。这样，while循环将使字符串以空值字符结束，并将余下的空间（如果有的话）设置为空值字符。 </p><p>另一种设置新字符串长度的方法是，将n设置为传递的值和字符串长度中较小的一个：</p><div class="code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = strlen(str);<span class="hljs-built_in">n</span> = (<span class="hljs-built_in">n</span>&lt;<span class="hljs-built_in">len</span>) ? <span class="hljs-symbol">n:le</span><span class="hljs-built_in">n</span>;<span class="hljs-built_in">char</span> *p = new <span class="hljs-built_in">char</span>[<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>];</code></pre></div><p>这将确保new分配的空间不会多于存储字符串所需的空间。如果用户执行像left(“Hi!”, 32767)这样的调用，则这种方法很有用。第一种方 法将把“Hi!”复制到由32767个字符组成的数组中，并将除前3个字符之外的所有字符都设置为空值字符；第二种方法将“Hi!”复制到由4个字符组成的数组中。但由于添加了另外一个函数调用（strlen( )），因此程序将更长，运行速度将降低，同时还必须包含头文件cstring（或 string.h）。C程序员倾向于选择运行速度更快、更简洁的代码，因此需要程序员在正确使用函数方面承担更多责任。然而，C++的传统是更强调可靠性。毕竟，速度较慢但能正常运行的程序，要比运行速度虽快但无法正常运行的程序好。如果调用strlen( )所需的时间很长，则可以让left( )直接确定n和字符串长度哪个小。例如，当m的值等于n或到达字符串结尾时，下面的循环都将终止：</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> m = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(m&lt;=n&amp;&amp;<span class="hljs-built_in">str</span>[m]!=<span class="hljs-string">&#x27;\0&#x27;</span>)m++<span class="hljs-built_in">char</span> * p =<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[m+<span class="hljs-number">1</span>];</code></pre></div><p>别忘了，在str[m]不是空值字符时，表达式str[m] != ‘\0’的结果为true，否则为false。由于在&amp;&amp;表达式中，非零值被转换为true，而零被 转换为false，</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载的关键是函数的参数列表——也称为函数特征标（function signature）。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和/或参数类型不同，则特征标也不同。例如，可以定义一组原型如下的print( )函数：</p><div class="code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">void</span> <span class="hljs-built_in">print</span>(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> * <span class="hljs-built_in">str</span>,<span class="hljs-type">int</span> <span class="hljs-built_in">width</span>);<span class="hljs-keyword">void</span> <span class="hljs-built_in">print</span>(<span class="hljs-type">double</span> d,<span class="hljs-type">int</span> <span class="hljs-built_in">width</span>);<span class="hljs-keyword">void</span> <span class="hljs-built_in">print</span>(<span class="hljs-type">long</span> l,<span class="hljs-type">int</span> <span class="hljs-built_in">width</span>);<span class="hljs-keyword">void</span> <span class="hljs-built_in">print</span>(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> <span class="hljs-built_in">width</span>);<span class="hljs-keyword">void</span> <span class="hljs-built_in">print</span>(<span class="hljs-keyword">const</span>  <span class="hljs-type">char</span> * <span class="hljs-built_in">str</span>);</code></pre></div><p>使用被重载的函数时，需要在函数调用中使用正确的参数类型</p><p>一些看起来彼此不同的特征标是不能共存的。例如，请看下面的两个原型：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;x)</span></span>;</code></pre></div><p>您可能认为可以在此处使用函数重载，因为它们的特征标看起来不同。然而，请从编译器的角度来考虑这个问题。假设有下面这样的代 码：</p><div class="code-wrapper"><pre><code class="hljs scss">cout &lt;&lt; <span class="hljs-built_in">cube</span>(x);</code></pre></div><p>参数x与double x原型和double &amp;x原型都匹配，因此编译器无法确定究竟应使用哪个原型。为避免这种混乱，编译器在检查函数特征标 时，将把类型引用和类型本身视为同一个特征标。 </p><p>匹配函数时，并不区分const和非const变量。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dribble</span><span class="hljs-params">(<span class="hljs-type">char</span> * bits)</span></span>;<span class="hljs-comment">//overloaded</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dribble</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cbits)</span></span>;<span class="hljs-comment">//overloaded</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dabble</span><span class="hljs-params">(<span class="hljs-type">char</span> * bits)</span></span>;<span class="hljs-comment">//not overloaded</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drivel</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * bits)</span></span>;<span class="hljs-comment">//not overloaded</span></code></pre></div><p>dribble( )函数有两个原型，一个用于const指针，另一个用于常规指针，编译器将根据实参是否为const来决定使用哪个原型。dribble( )函数只与带非const参数的调用匹配，而drivel( )函数可以与带const或非const参数的调用匹配。drivel( )和dabble( )之所以在行为上有这种差别，主要是由于将非const值赋给const变量是合法的，但反之则是非法的。 </p><p>请记住，是特征标，而不是函数类型使得可以对函数进行重载。例如，下面的两个声明是互斥的： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">gronk</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">float</span> m)</span></span>;<span class="hljs-comment">//same signatures</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gronk</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">float</span> m)</span></span>;<span class="hljs-comment">//not allowed</span></code></pre></div><p>因此，C++不允许以这种方式重载gronk( )。返回类型可以不同，但特征标也必须不同： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">gronk</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">float</span> m)</span></span>;<span class="hljs-comment">//difference signatures</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gronk</span><span class="hljs-params">(<span class="hljs-type">float</span> n,<span class="hljs-type">float</span> m)</span></span>;<span class="hljs-comment">//allowed</span></code></pre></div><p>类设计和STL经常使用引用参数，因此知道不同引用类型的重载很有用。请看下面三个原型：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp; r1)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sank</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> &amp;r2)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sunk</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;&amp; r3)</span></span>;</code></pre></div><p>左值引用参数r1与可修改的左值参数（如double变量）匹配；const左值引用参数r2与可修改的左值参数、const左值参数和右值参数（如两个double值的和）匹配；最后，左值引用参数r3与左值匹配。注意到与r1或r3匹配的参数都与r2匹配。这就带来了一个问题：如果重载使用这三种参数的函数，结果将如何？答案是将调用最匹配的版本： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">staff</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp; rs)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">staff</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> &amp;rcs)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stove</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;r1)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> &amp; r2)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stove</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;&amp; r3)</span></span>;<span class="hljs-type">double</span> x = <span class="hljs-number">55.5</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> y = <span class="hljs-number">32.0</span>;<span class="hljs-built_in">stove</span>(x)<span class="hljs-comment">//call stove(double &amp;);</span><span class="hljs-built_in">stove</span>(y)<span class="hljs-comment">//call stove(const double &amp;);</span><span class="hljs-built_in">stove</span>(x+y)<span class="hljs-comment">//call stove(double &amp;&amp;);如果没有定义函数stove(double &amp;&amp;)，stove(x+y)将调用函数stove(const double &amp;)</span></code></pre></div><h3 id="重载示例"><a href="#重载示例" class="headerlink" title="重载示例"></a>重载示例</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// leftover.cpp -- overloading the left() function</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num, <span class="hljs-type">unsigned</span> ct)</span></span>;<span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> * trip = <span class="hljs-string">&quot;Hawaii!!&quot;</span>;   <span class="hljs-comment">// test value</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n = <span class="hljs-number">12345678</span>; <span class="hljs-comment">// test value</span>    <span class="hljs-type">int</span> i;    <span class="hljs-type">char</span> * temp;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++)    &#123;        cout &lt;&lt; <span class="hljs-built_in">left</span>(n, i) &lt;&lt; endl;        temp = <span class="hljs-built_in">left</span>(trip,i);        cout &lt;&lt; temp &lt;&lt; endl;        <span class="hljs-keyword">delete</span> [] temp; <span class="hljs-comment">// point to temporary storage</span>    &#125;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// This function returns the first ct digits of the number num.</span><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num, <span class="hljs-type">unsigned</span> ct)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">unsigned</span> digits = <span class="hljs-number">1</span>;    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n = num;    <span class="hljs-keyword">if</span> (ct == <span class="hljs-number">0</span> || num == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">// return 0 if no digits</span>    <span class="hljs-keyword">while</span> (n /= <span class="hljs-number">10</span>)        digits++;    <span class="hljs-keyword">if</span> (digits &gt; ct)    &#123;        ct = digits - ct;        <span class="hljs-keyword">while</span> (ct--)            num /= <span class="hljs-number">10</span>;        <span class="hljs-keyword">return</span> num;         <span class="hljs-comment">// return left ct digits</span>    &#125;    <span class="hljs-keyword">else</span>                <span class="hljs-comment">// if ct &gt;= number of digits</span>        <span class="hljs-keyword">return</span> num;     <span class="hljs-comment">// return the whole number</span>&#125;<span class="hljs-comment">// This function returns a pointer to a new string</span><span class="hljs-comment">// consisting of the first n characters in the str string.</span><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)        n = <span class="hljs-number">0</span>;    <span class="hljs-type">char</span> * p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n+<span class="hljs-number">1</span>];    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; str[i]; i++)        p[i] = str[i];  <span class="hljs-comment">// copy characters</span>    <span class="hljs-keyword">while</span> (i &lt;= n)        p[i++] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// set rest of string to &#x27;\0&#x27;</span>    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//1</span><span class="hljs-comment">//H</span><span class="hljs-comment">//12</span><span class="hljs-comment">//Ha</span><span class="hljs-comment">//123</span><span class="hljs-comment">//Haw</span><span class="hljs-comment">//1234</span><span class="hljs-comment">//Hawa</span><span class="hljs-comment">//12345</span><span class="hljs-comment">//Hawai</span><span class="hljs-comment">//123456</span><span class="hljs-comment">//Hawaii</span><span class="hljs-comment">//1234567</span><span class="hljs-comment">//Hawaii!</span><span class="hljs-comment">//12345678</span><span class="hljs-comment">//Hawaii!!</span><span class="hljs-comment">//12345678</span><span class="hljs-comment">//Hawaii!!</span></code></pre></div><h3 id="何时使用函数重载"><a href="#何时使用函数重载" class="headerlink" title="何时使用函数重载"></a>何时使用函数重载</h3><p>虽然函数重载很吸引人，但也不要滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>现在的C++编译器实现了C++新增的一项特性——函数模板。函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的 泛型可用具体的类型（如int或double）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型（parameterized types）。</p><p>函数模板允许以任意类型的方式来定义函数。例如，可以这样建立一个交换模板：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> AnyType&gt;<span class="hljs-type">void</span> Swap&lt;AnyType &amp;a,AnyType &amp;b&gt;&#123;AnyType temp;temp = a;a=b;b=temp;&#125;</code></pre></div><p>第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和typename是必需的，除非可以使用关键字class代替typename。另外，必须使用尖括号。类型名可以任意选择（这里为AnyType），只要遵守C++命名规则即可；许多程序员都使用简单的名称，如T。余下的代码描述了交换两个AnyType值的算法。模板并不创建任何函数，而只是告诉编译器如何定义函数。需要交换int的函数时，编译器将按模板模式创建这样的函数，并用int代替AnyType。同样，需要交换double的函数时，编译器将按模板模式创建这样的函数，并用double代替AnyType。 </p><p>在标准C++98添加关键字typename之前，C++使用关键字class来创建模板。也就是说，可以这样编写模板定义： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyType</span>&gt;<span class="hljs-type">void</span> Swap&lt;AnyType &amp;a,AnyType &amp;b&gt;&#123;AnyType temp;temp = a;a=b;b=temp;&#125;</code></pre></div><p>typename关键字使得参数AnyType表示类型这一点更为明显；然而，有大量代码库是使用关键字class开发的。在这种上下文中，这两个 关键字是等价的</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// funtemp.cpp -- using a function template</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// function template prototype</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// or class T</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> j = <span class="hljs-number">20</span>;    cout &lt;&lt; <span class="hljs-string">&quot;i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Using compiler-generated int swapper:\n&quot;</span>;    <span class="hljs-built_in">Swap</span>(i,j);  <span class="hljs-comment">// generates void Swap(int &amp;, int &amp;)</span>    cout &lt;&lt; <span class="hljs-string">&quot;Now i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    <span class="hljs-type">double</span> x = <span class="hljs-number">24.5</span>;    <span class="hljs-type">double</span> y = <span class="hljs-number">81.7</span>;    cout &lt;&lt; <span class="hljs-string">&quot;x, y = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Using compiler-generated double swapper:\n&quot;</span>;    <span class="hljs-built_in">Swap</span>(x,y);  <span class="hljs-comment">// generates void Swap(double &amp;, double &amp;)</span>    cout &lt;&lt; <span class="hljs-string">&quot;Now x, y = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// function template definition</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">// or class T</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span><span class="hljs-function"></span>&#123;    T temp;   <span class="hljs-comment">// temp a variable of type T</span>    temp = a;    a = b;    b = temp;&#125;<span class="hljs-comment">//i, j = 10, 20.</span><span class="hljs-comment">//Using compiler-generated int swapper:</span><span class="hljs-comment">//Now i, j = 20, 10.</span><span class="hljs-comment">//x, y = 24.5, 81.7.</span><span class="hljs-comment">//Using compiler-generated double swapper:</span><span class="hljs-comment">//Now x, y = 81.7, 24.5.</span></code></pre></div><h3 id="重载的模板"><a href="#重载的模板" class="headerlink" title="重载的模板"></a>重载的模板</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// twotemps.cpp -- using overloaded template functions</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;     <span class="hljs-comment">// original template</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;     <span class="hljs-comment">// new template</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T *a, T *b, <span class="hljs-type">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span></span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> Lim = <span class="hljs-number">8</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">20</span>;    cout &lt;&lt; <span class="hljs-string">&quot;i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Using compiler-generated int swapper:\n&quot;</span>;    <span class="hljs-built_in">Swap</span>(i,j);              <span class="hljs-comment">// matches original template</span>    cout &lt;&lt; <span class="hljs-string">&quot;Now i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    <span class="hljs-type">int</span> d1[Lim] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>&#125;;    <span class="hljs-type">int</span> d2[Lim] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>&#125;;    cout &lt;&lt; <span class="hljs-string">&quot;Original arrays:\n&quot;</span>;    <span class="hljs-built_in">Show</span>(d1);    <span class="hljs-built_in">Show</span>(d2);    <span class="hljs-built_in">Swap</span>(d1,d2,Lim);        <span class="hljs-comment">// matches new template</span>    cout &lt;&lt; <span class="hljs-string">&quot;Swapped arrays:\n&quot;</span>;    <span class="hljs-built_in">Show</span>(d1);    <span class="hljs-built_in">Show</span>(d2);    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span><span class="hljs-function"></span>&#123;    T temp;    temp = a;    a = b;    b = temp;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T a[], T b[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    T temp;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        temp = a[i];        a[i] = b[i];        b[i] = temp;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; a[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;/&quot;</span>;    cout &lt;&lt; a[<span class="hljs-number">2</span>] &lt;&lt; a[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">&quot;/&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt; Lim; i++)        cout &lt;&lt; a[i];    cout &lt;&lt; endl;&#125;<span class="hljs-comment">//i, j = 10, 20.</span><span class="hljs-comment">//Using compiler-generated int swapper:</span><span class="hljs-comment">//Now i, j = 20, 10.</span><span class="hljs-comment">//Original arrays:</span><span class="hljs-comment">//07/04/1776</span><span class="hljs-comment">//07/20/1969</span><span class="hljs-comment">//Swapped arrays:</span><span class="hljs-comment">//07/20/1969</span><span class="hljs-comment">//07/04/1776</span></code></pre></div><h3 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h3><div class="code-wrapper"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<span class="hljs-symbol">void</span> <span class="hljs-symbol">f</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">a,<span class="hljs-symbol">T</span></span> <span class="hljs-symbol">b</span>)&#123;....&#125;</code></pre></div><p>通常，代码假定可执行哪些操作。例如，下面的代码假定定义了赋值，但如果T为数组，这种假设将不成立：</p><p>a = b;</p><p>同样，下面的语句假设定义了&lt;，但如果T为结构，该假设便不成立：</p><p>If(a &gt; b)</p><p>另外，为数组名定义了运算符&gt;，但由于数组名为地址，因此它比较的是数组的地址，而这可能不是您希望的。下面的语句假定为类型T 定义了乘法运算符，但如果T为数组、指针或结构，这种假设便不成立：</p><p>T c =a*b</p><p>总之，编写的模板函数很可能无法处理某些类型。另一方面，有时候通用化是有意义的，但C++语法不允许这样做。</p><h3 id="显式具体化"><a href="#显式具体化" class="headerlink" title="显式具体化"></a>显式具体化</h3><h4 id="第三代具体化（ISO-ANSI-C-标准）"><a href="#第三代具体化（ISO-ANSI-C-标准）" class="headerlink" title="第三代具体化（ISO/ANSI C++标准）"></a>第三代具体化（ISO/ANSI C++标准）</h4><ul><li>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模 板函数以及它们的重载版本。 </li><li>显式具体化的原型和定义应以template&lt;&gt;打头，并通过名称来指出类型。 </li><li>具体化优先于常规模板，而非模板函数优先于具体化和常规模板。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(job &amp;,job &amp;)</span></span>;<span class="hljs-comment">//non template function prototype</span><span class="hljs-comment">//template prototype</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;,T &amp;)</span></span>;<span class="hljs-comment">//explicitd specialization for the job type</span><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;job&gt;(job &amp;,job &amp;);</code></pre></div><p>正如前面指出的，如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生 成的版本。</p><h4 id="显式具体化示例"><a href="#显式具体化示例" class="headerlink" title="显式具体化示例"></a>显式具体化示例</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// twoswap.cpp -- specialization overrides a template</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span></span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">job</span>&#123;    <span class="hljs-type">char</span> name[<span class="hljs-number">40</span>];    <span class="hljs-type">double</span> salary;    <span class="hljs-type">int</span> floor;&#125;;<span class="hljs-comment">// explicit specialization</span><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;job&gt;(job &amp;j1, job &amp;j2);<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(job &amp;j)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);    cout.<span class="hljs-built_in">setf</span>(ios::fixed, ios::floatfield);    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>, j = <span class="hljs-number">20</span>;    cout &lt;&lt; <span class="hljs-string">&quot;i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Using compiler-generated int swapper:\n&quot;</span>;    <span class="hljs-built_in">Swap</span>(i,j);    <span class="hljs-comment">// generates void Swap(int &amp;, int &amp;)</span>    cout &lt;&lt; <span class="hljs-string">&quot;Now i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    job sue = &#123;<span class="hljs-string">&quot;Susan Yaffee&quot;</span>, <span class="hljs-number">73000.60</span>, <span class="hljs-number">7</span>&#125;;    job sidney = &#123;<span class="hljs-string">&quot;Sidney Taffee&quot;</span>, <span class="hljs-number">78060.72</span>, <span class="hljs-number">9</span>&#125;;    cout &lt;&lt; <span class="hljs-string">&quot;Before job swapping:\n&quot;</span>;    <span class="hljs-built_in">Show</span>(sue);    <span class="hljs-built_in">Show</span>(sidney);    <span class="hljs-built_in">Swap</span>(sue, sidney); <span class="hljs-comment">// uses void Swap(job &amp;, job &amp;)</span>    cout &lt;&lt; <span class="hljs-string">&quot;After job swapping:\n&quot;</span>;    <span class="hljs-built_in">Show</span>(sue);    <span class="hljs-built_in">Show</span>(sidney);    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span>    <span class="hljs-comment">// general version</span></span><span class="hljs-function"></span>&#123;    T temp;    temp = a;    a = b;    b = temp;&#125;<span class="hljs-comment">// swaps just the salary and floor fields of a job structure</span><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;job&gt;(job &amp;j1, job &amp;j2)  <span class="hljs-comment">// specialization</span>&#123;    <span class="hljs-type">double</span> t1;    <span class="hljs-type">int</span> t2;    t1 = j1.salary;    j1.salary = j2.salary;    j2.salary = t1;    t2 = j1.floor;    j1.floor = j2.floor;    j2.floor = t2;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(job &amp;j)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; j.name &lt;&lt; <span class="hljs-string">&quot;: $&quot;</span> &lt;&lt; j.salary         &lt;&lt; <span class="hljs-string">&quot; on floor &quot;</span> &lt;&lt; j.floor &lt;&lt; endl;&#125;<span class="hljs-comment">//i, j = 10, 20.</span><span class="hljs-comment">//Using compiler-generated int swapper:</span><span class="hljs-comment">//Now i, j = 20, 10.</span><span class="hljs-comment">//Before job swapping:</span><span class="hljs-comment">//Susan Yaffee: $73000.60 on floor 7</span><span class="hljs-comment">//Sidney Taffee: $78060.72 on floor 9</span><span class="hljs-comment">//After job swapping:</span><span class="hljs-comment">//Susan Yaffee: $78060.72 on floor 9</span><span class="hljs-comment">//Sidney Taffee: $73000.60 on floor 7</span></code></pre></div><h3 id="实例化和具体化"><a href="#实例化和具体化" class="headerlink" title="实例化和具体化"></a>实例化和具体化</h3><p>为进一步了解模板，必须理解术语实例化和具体化。记住，在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定 义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例（instantiation）。例如，在程序清单8.13中，函数调用Swap(i, j)导致编译器生成Swap( )的一个实例，该实例使用int类型。模板并非函数定义，但使用int的模板实例是函数定义。这种实例化方式被称为隐式实例化（implicit instantiation），因为编译器之所以知道需要进行定义，是由于程序调用Swap( )函数时提供了int参数。</p><p>最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许显式实例化（explicit instantiation）。这意味着可以直接命令编译器创建特定的实例，如Swap<int>( )。其语法是，声明所需的种类——用&lt;&gt;符号指示类型，并在声明前加上关键字template： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>);</code></pre></div><p>实现了这种特性的编译器看到上述声明后，将使用Swap( )模板生成一个使用int类型的实例。也就是说，该声明的意思是“使用Swap( )模板生成int类型的函数定义。”</p><p>与显式实例化不同的是，显式具体化使用下面两个等价的声明之一：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span> &amp;,<span class="hljs-type">int</span> &amp;);<span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;,<span class="hljs-type">int</span> &amp;)</span></span>;</code></pre></div><p>区别在于，这些声明的意思是“不要使用Swap( )模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义”。这些原型必须有 自己的函数定义。显式具体化声明在关键字template后包含&lt;&gt;，而显式实例化没有。 </p><p>试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错。</p><p>还可通过在程序中使用函数来创建显式实例化</p><div class="code-wrapper"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<span class="hljs-symbol">T</span> <span class="hljs-symbol">Add</span>(<span class="hljs-symbol">T</span> <span class="hljs-symbol">a,<span class="hljs-symbol">T</span></span> <span class="hljs-symbol">b</span>)&#123;<span class="hljs-keyword">return</span> a+b;&#125;...<span class="hljs-built_in">int</span> m = <span class="hljs-number">6</span>;<span class="hljs-built_in">double</span> x = <span class="hljs-number">10.2</span>;cout &lt;&lt;Add&lt;<span class="hljs-built_in">double</span>&gt;(x,m)&lt;&lt;endl;</code></pre></div><p>这里的模板与函数调用Add(x, m)不匹配，因为该模板要求两个函数参数的类型相同。但通过使用Add<double>(x, m)，可强制为double类型 实例化，并将参数m强制转换为double类型，以便与函数Add<double> (double, double)的第二个参数匹配。</p><div class="code-wrapper"><pre><code class="hljs llvm">int m <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span><span class="hljs-keyword">double</span> <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">14.3</span><span class="hljs-comment">;</span>Swap&lt;<span class="hljs-keyword">double</span>&gt;(m<span class="hljs-punctuation">,</span><span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span></code></pre></div><p>这将为类型double生成一个显式实例化。不幸的是，这些代码不管用，因为第一个形参的类型为double &amp;，不能指向int变量m。</p><p>隐式实例化、显式实例化和显式具体化统称为具体化（specialization）。它们的相同之处在于，它们表示的都是使用具体类型的函数定义，而不是通用描述。 </p><p>引入显式实例化后，必须使用新的语法——在声明中使用前缀template和template &lt;&gt;，以区分显式实例化和显式具体化。通常，功能 越多，语法规则也越多。下面的代码片段总结了这些概念：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(T &amp;,T &amp;)</span></span>;<span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;job&gt;(job &amp;,job &amp;);<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-type">char</span> &amp;,<span class="hljs-type">char</span> &amp;);<span class="hljs-type">short</span> a,b;...<span class="hljs-built_in">Swap</span>(a,b);job n,m;...<span class="hljs-built_in">Swap</span>(n,m);<span class="hljs-type">char</span> g,h;...<span class="hljs-built_in">Swap</span>(g,h)&#125;</code></pre></div><p>编译器看到char的显式实例化后，将使用模板定义来生成Swap( )的char版本。对于其他Swap( )调用，编译器根据函数调用中实际使用的参数，生成相应的版本。例如，当编译器看到函数调用Swap(a, b)后，将生成Swap( )的short版本，因为两个参数的类型都是short。当编译器看到Swap(n, m)后，将使用为job类型提供的独立定义（显式具体化）。当编译器看到Swap(g, h)后，将使用处理显式实例化时生成的模板具体化。</p><h3 id="编译器选择使用哪个函数版本"><a href="#编译器选择使用哪个函数版本" class="headerlink" title="编译器选择使用哪个函数版本"></a>编译器选择使用哪个函数版本</h3><p>对于函数重载、函数模板和函数模板重载，C++需要（且有）一个 定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多 个参数时。这个过程称为重载解析（overloading resolution）。详细解释这个策略将需要将近一章的篇幅，因此我们先大致了解一下这个过程是如何进行的。 </p><p>第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。 </p><p>第2步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为double，从而与double形参匹配，而模板可以为float生成一个实例。 </p><p>第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">may</span><span class="hljs-params">(<span class="hljs-string">&#x27;B&#x27;</span>)</span></span></code></pre></div><p>首先，编译器将寻找候选者，即名称为may( )的函数和函数模板。然后寻找那些可以用一个参数调用的函数。例如，下面的函数符合要 求，因为其名称与被调用的函数相同，且可只给它们传递一个参数：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">may</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//#1</span><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">may</span><span class="hljs-params">(<span class="hljs-type">float</span>,<span class="hljs-type">float</span> = <span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//#2</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">may</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<span class="hljs-comment">//#3</span><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">may</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span></span>;<span class="hljs-comment">//#4</span><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">may</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;)</span><span class="hljs-comment">//#5</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">may</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;)</span></span>;<span class="hljs-comment">//#6</span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">void</span> <span class="hljs-title">may</span><span class="hljs-params">(T *)</span></span>;<span class="hljs-comment">//#7</span></code></pre></div><p>注意，只考虑特征标，而不考虑返回类型。其中的两个候选函数（#4和#7）不可行，因为整数类型不能被隐式地转换（即没有显式强制 类型转换）为指针类型。剩余的一个模板可用来生成具体化，其中T被替换为char类型。这样剩下5个可行的函数，其中的每一个函数，如果它是声明的唯一一个函数，都可以被使用。</p><p>接下来，编译器必须确定哪个可行函数是最佳的。它查看为使函数调用参数与可行的候选函数的参数匹配所需要进行的转换。通常，从最 佳到最差的顺序如下所述。 </p><p>1．完全匹配，但常规函数优先于模板。 </p><p>2．提升转换（例如，char和shorts自动转换为int，float自动转换为double）。 </p><p>3．标准转换（例如，int转换为char，long转换为double）。 </p><p>4．用户定义的转换，如类声明中定义的转换。</p><p>例如，函数#1优于函数#2，因为char到int的转换是提升转换（参见第3章），而char到float的转换是标准转换（参见第3章）。函数#3、函数#5和函数#6都优于函数#1和#2，因为它们都是完全匹配的。#3和#5优于#6，因为#6函数是模板。这种分析引出了两个问题。什么是完全匹配？如果两个函数（如#3和#5）都完全匹配，将如何办呢？通常，有两个函数完全匹配是一种错误，但这一规则有两个例外。显然，我们需要对这一点做更深入的探讨。 </p><h4 id="完全匹配和最佳匹配"><a href="#完全匹配和最佳匹配" class="headerlink" title="完全匹配和最佳匹配"></a>完全匹配和最佳匹配</h4><p>进行完全匹配时，C++允许某些“无关紧要的转换”。表8.1列出了这些转换——Type表示任意类型。例如，int实参与int &amp;形参完全匹配。注意，Type可以是char &amp;这样的类型，因此这些规则包括从char &amp;到const char &amp;的转换。Type（argument-list）意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的（第7章介绍了函数指针以及为何可以将函数名作为参数传递给接受函数指针的函数）。第9章将介绍关键字volatile。 </p><p>完全匹配允许的无关紧要转换</p><table><thead><tr><th>从实参</th><th>到形参</th></tr></thead><tbody><tr><td>Type</td><td>Type &amp;</td></tr><tr><td>Type &amp;</td><td>Type</td></tr><tr><td>Type []</td><td>*Type</td></tr><tr><td>Type(argument-list)</td><td>Type(*)(argument-list))</td></tr><tr><td>Type</td><td>const Type</td></tr><tr><td>Type</td><td>Voliate Type</td></tr><tr><td>Type *</td><td>const Type</td></tr><tr><td>Type *</td><td>Voliate Type *</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">blot</span> &#123;<span class="hljs-type">int</span> a,<span class="hljs-type">char</span> b[<span class="hljs-number">10</span>]&#125;;blot ink = &#123;<span class="hljs-number">25</span>,<span class="hljs-string">&quot;spots&quot;</span>&#125;;...<span class="hljs-built_in">recycle</span>(ink);</code></pre></div><p>在这种情况下，下面的原型都是完全匹配的： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">(blot)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">(<span class="hljs-type">const</span> blot)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">(blot &amp;)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">(<span class="hljs-type">const</span> blot &amp;)</span></span>;</code></pre></div><p>正如您预期的，如果有多个匹配的原型，则编译器将无法完成重载解析过程；如果没有最佳的可行函数，则编译器将生成一条错误消息， 该消息可能会使用诸如“ambiguous（二义性）”这样的词语。</p><p>然而，有时候，即使两个函数都完全匹配，仍可完成重载解析。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹 配。也就是说，在recycle( )示例中，如果只定义了函数#3和#4是完全匹配的，则将选择#3，因为ink没有被声明为const。然而，const和非const之间的区别只适用于指针和引用指向的数据。也就是说，如果只定义了 #1和#2，则将出现二义性错误</p><p>一个完全匹配优于另一个的另一种情况是，其中一个是非模板函数，而另一个不是。在这种情况下，非模板函数将优先于模板函数（包 括显式具体化）。 </p><p>如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。例如，这意味着显式具体化将优于使用模板隐式生成的具体化：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">blot</span> &#123;<span class="hljs-type">int</span> a,<span class="hljs-type">char</span> b[<span class="hljs-number">10</span>]&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recycle</span> <span class="hljs-params">(Type t)</span><span class="hljs-comment">//template</span></span><span class="hljs-function"><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-type">void</span> recycle&lt;blot&gt; <span class="hljs-params">(blot &amp; t)</span></span>;...blot ink = &#123;<span class="hljs-number">25</span>,<span class="hljs-string">&quot;spots&quot;</span>&#125;;...<span class="hljs-built_in">recycle</span>(ink);</code></pre></div><p>术语“最具体（most specialized）”并不一定意味着显式具体化，而是指编译器推断使用哪种类型时执行的转换最少。例如，请看下面两个模板：</p><div class="code-wrapper"><pre><code class="hljs angelscript">template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt; <span class="hljs-symbol">void</span> <span class="hljs-symbol">recycle</span> (<span class="hljs-symbol">Type</span> <span class="hljs-symbol">t</span>) //#<span class="hljs-symbol">1</span><span class="hljs-symbol">template</span> &lt;<span class="hljs-symbol">class</span> <span class="hljs-symbol">Type</span>&gt; <span class="hljs-symbol">void</span> <span class="hljs-symbol">recycle</span> (<span class="hljs-symbol">Type</span> *<span class="hljs-symbol">t</span>) //#<span class="hljs-symbol">2</span></code></pre></div><p>假设包含这些模板的程序也包含如下代码：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">blot</span> &#123;<span class="hljs-type">int</span> a,charb[<span class="hljs-number">10</span>]&#125;;blot ink = &#123;<span class="hljs-number">25</span>,<span class="hljs-string">&quot;spots&quot;</span>&#125;;...<span class="hljs-built_in">recycle</span>(&amp;ink);</code></pre></div><p>recycle(&amp;ink)调用与#1模板匹配，匹配时将Type解释为blot *。recycle（&amp;ink）函数调用也与#2模板匹配，这次Type被解释为ink。因 此将两个隐式实例——recycle&lt;blot *&gt;(blot *)和recycle <blot>(blot *)发送到可行函数池中。 </p><p>在这两个模板函数中，recycle&lt;blot *&gt;(blot *)被认为是更具体的，因为在生成过程中，它需要进行的转换更少。也就是说，#2模板已经显式指出，函数参数是指向Type的指针，因此可以直接用blot标识Type；而#1模板将Type作为函数参数，因此Type必须被解释为指向blot的指针。也就是说，在#2模板中，Type已经被具体化为指针，因此说它“更具体”。</p><p>用于找出最具体的模板的规则被称为函数模板的部分排序规则（partial ordering rules）。和显式实例一样，这也是C++98新增的特性。 </p><h4 id="部分排序规则示例"><a href="#部分排序规则示例" class="headerlink" title="部分排序规则示例"></a>部分排序规则示例</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// tempover.cpp --- template overloading</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">// template A</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> n)</span></span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">// template B</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowArray</span><span class="hljs-params">(T * arr[], <span class="hljs-type">int</span> n)</span></span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">debts</span>&#123;    <span class="hljs-type">char</span> name[<span class="hljs-number">50</span>];    <span class="hljs-type">double</span> amount;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> things[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">13</span>, <span class="hljs-number">31</span>, <span class="hljs-number">103</span>, <span class="hljs-number">301</span>, <span class="hljs-number">310</span>, <span class="hljs-number">130</span>&#125;;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">debts</span> mr_E[<span class="hljs-number">3</span>] =            &#123;                    &#123;<span class="hljs-string">&quot;Ima Wolfe&quot;</span>, <span class="hljs-number">2400.0</span>&#125;,                    &#123;<span class="hljs-string">&quot;Ura Foxe&quot;</span>, <span class="hljs-number">1300.0</span>&#125;,                    &#123;<span class="hljs-string">&quot;Iby Stout&quot;</span>, <span class="hljs-number">1800.0</span>&#125;            &#125;;    <span class="hljs-type">double</span> * pd[<span class="hljs-number">3</span>];<span class="hljs-comment">// set pointers to the amount members of the structures in mr_E</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)        pd[i] = &amp;mr_E[i].amount;    cout &lt;&lt; <span class="hljs-string">&quot;Listing Mr. E&#x27;s counts of things:\n&quot;</span>;<span class="hljs-comment">// things is an array of int</span>    <span class="hljs-built_in">ShowArray</span>(things, <span class="hljs-number">6</span>);  <span class="hljs-comment">// uses template A</span>    cout &lt;&lt; <span class="hljs-string">&quot;Listing Mr. E&#x27;s debts:\n&quot;</span>;<span class="hljs-comment">// pd is an array of pointers to double</span>    <span class="hljs-built_in">ShowArray</span>(pd, <span class="hljs-number">3</span>);      <span class="hljs-comment">// uses template B (more specialized)</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;template A\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    cout &lt;&lt; endl;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowArray</span><span class="hljs-params">(T * arr[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;template B\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        cout &lt;&lt; *arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    cout &lt;&lt; endl;&#125;<span class="hljs-comment">//Listing Mr. E&#x27;s counts of things:</span><span class="hljs-comment">//template A</span><span class="hljs-comment">//13 31 103 301 310 130</span><span class="hljs-comment">//Listing Mr. E&#x27;s debts:</span><span class="hljs-comment">//template B</span><span class="hljs-comment">//2400 1300 1800</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">ShowArray(<span class="hljs-params">things</span>, 6)</span>;</code></pre></div><p>标识符things是一个int数组的名称，因此与下面的模板匹配：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">// template A</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> n)</span></span>;</code></pre></div><p>其中T被替换为int类型。 </p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-constructor">ShowArray(<span class="hljs-params">pd</span>, 3)</span>;</code></pre></div><p>其中pd是一个double *数组的名称。这与模板A匹配： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">// template A</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> n)</span></span>;</code></pre></div><p>其中，T被替换为类型double *。在这种情况下，模板函数将显示pd数组的内容，即3个地址。该函数调用也与模板B匹配：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;            <span class="hljs-comment">// template B</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowArray</span><span class="hljs-params">(T * arr[], <span class="hljs-type">int</span> n)</span></span>;</code></pre></div><p>在这里，T被替换为类型double，而函数将显示被解除引用的元素 *arr[i]，即数组内容指向的double值。在这两个模板中，模板B更具体，因为它做了特定的假设——数组内容是指针，因此被使用。 </p><p>简而言之，重载解析将寻找最匹配的函数。如果只存在一个这样的函数，则选择它；如果存在多个这样的函数，但其中只有一个是非模板 函数，则选择该函数；如果存在多个适合的函数，且它们都为模板函数，但其中有一个函数比其他函数更具体，则选择该函数。如果有多个同样合适的非模板函数或模板函数，但没有一个函数比其他函数更具体，则函数调用将是不确定的，因此是错误的；当然，如果不存在匹配的函数，则也是错误。 </p><h4 id="自己选择"><a href="#自己选择" class="headerlink" title="自己选择"></a>自己选择</h4><p>在有些情况下，可通过编写合适的函数调用，引导编译器做出您希 望的选择。请看程序清单8.15，该程序将模板函数定义放在文件开头， 从而无需提供模板原型。与常规函数一样，通过在使用函数前提供模板函数定义，它让它也充当原型。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// choices.cpp -- choosing a template</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><span class="hljs-function">T <span class="hljs-title">lesser</span><span class="hljs-params">(T a, T b)</span>         <span class="hljs-comment">// #1</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> a &lt; b ? a : b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lesser</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>  <span class="hljs-comment">// #2</span></span><span class="hljs-function"></span>&#123;    a = a &lt; <span class="hljs-number">0</span> ? -a : a;    b = b &lt; <span class="hljs-number">0</span> ? -b : b;    <span class="hljs-keyword">return</span> a &lt; b ? a : b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> m = <span class="hljs-number">20</span>;    <span class="hljs-type">int</span> n = <span class="hljs-number">-30</span>;    <span class="hljs-type">double</span> x = <span class="hljs-number">15.5</span>;    <span class="hljs-type">double</span> y = <span class="hljs-number">25.9</span>;    cout &lt;&lt; <span class="hljs-built_in">lesser</span>(m, n) &lt;&lt; endl;       <span class="hljs-comment">// use #2</span>    cout &lt;&lt; <span class="hljs-built_in">lesser</span>(x, y) &lt;&lt; endl;       <span class="hljs-comment">// use #1 with double</span>    cout &lt;&lt; lesser&lt;&gt;(m, n) &lt;&lt; endl;     <span class="hljs-comment">// use #1 with int</span>    cout &lt;&lt; <span class="hljs-built_in">lesser</span>&lt;<span class="hljs-type">int</span>&gt;(x, y)  &lt;&lt; endl; <span class="hljs-comment">// use #1 with int</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">cout &lt;&lt; lesser&lt;&gt;(m, n) &lt;&lt; endl;     <span class="hljs-regexp">//</span> use <span class="hljs-comment">#1 with int</span></code></pre></div><p>lesser&lt;&gt;(m, n)中的&lt;&gt;指出，编译器应选择模板函数，而不是非模板函数；编译器注意到实参的类型为int，因此使用int替代T对模板进行实例化</p><div class="code-wrapper"><pre><code class="hljs perl">cout &lt;&lt; lesser&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>)  &lt;&lt; endl; <span class="hljs-regexp">//</span> <span class="hljs-keyword">use</span> <span class="hljs-comment">#1 with int</span></code></pre></div><p>这条语句要求进行显式实例化（使用int替代T），将使用显式实例化得到的函数。x和y的值将被强制转换为int，该函数返回一个int值，这 就是程序显示15而不是15.5的原因所在。</p><h4 id="多个参数的函数"><a href="#多个参数的函数" class="headerlink" title="多个参数的函数"></a>多个参数的函数</h4><p>将有多个参数的函数调用与有多个参数的原型进行匹配时，情况将非常复杂。编译器必须考虑所有参数的匹配情况。如果找到比其他可行 函数都合适的函数，则选择该函数。一个函数要比其他函数都合适，其所有参数的匹配程度都必须不比其他函数差，同时至少有一个参数的匹配程度比其他函数都高。 </p><h3 id="模板函数的发展"><a href="#模板函数的发展" class="headerlink" title="模板函数的发展"></a>模板函数的发展</h3><h4 id="是什么类型"><a href="#是什么类型" class="headerlink" title="是什么类型"></a>是什么类型</h4><div class="code-wrapper"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T1,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">T2</span>&gt;<span class="hljs-symbol">void</span> <span class="hljs-symbol">ft</span>(<span class="hljs-symbol">T1</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T2</span></span> <span class="hljs-symbol">y</span>)&#123;?type?xpy=x+y;&#125;</code></pre></div><p>xpy应为什么类型呢？由于不知道ft()将如何使用，因此无法预先知道这一点。正确的类型可能是T1、T2或其他类型。例如，T1可能是 double，而T2可能是int，在这种情况下，两个变量的和将为double类型。T1可能是short，而T2可能是int，在这种情况下，两个变量的和为int类型。T1还可能是short，而T2可能是char，在这种情况下，加法运算将导致自动整型提升，因此结果类型为int。另外，结构和类可能重载运算符+，这导致问题更加复杂。因此，在C++98中，没有办法声明xpy的类型。 </p><h4 id="关键字decltype（C-11）"><a href="#关键字decltype（C-11）" class="headerlink" title="关键字decltype（C++11）"></a>关键字<strong>decltype</strong>（<strong>C++11</strong>）</h4><p>C++11新增的关键字decltype提供了解决方案。可这样使用该关键字：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<span class="hljs-keyword">decltype</span>(x) y; <span class="hljs-comment">//make y the same type as x</span></code></pre></div><p>给decltype提供的参数可以是表达式，因此在前面的模板函数ft()中，可使用下面的代码： </p><div class="code-wrapper"><pre><code class="hljs llvm">decltype(<span class="hljs-keyword">x</span>+y) xpy<span class="hljs-comment">;</span>xpy <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>+y<span class="hljs-comment">;</span></code></pre></div><p>另一种方法是，将这两条语句合而为一： </p><div class="code-wrapper"><pre><code class="hljs llvm">decltype(<span class="hljs-keyword">x</span>+y) xpy <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>+y<span class="hljs-comment">;</span></code></pre></div><p>因此，可以这样修复前面的模板函数ft()：</p><div class="code-wrapper"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T1,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">T2</span>&gt;<span class="hljs-symbol">void</span> <span class="hljs-symbol">ft</span>(<span class="hljs-symbol">T1</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T2</span></span> <span class="hljs-symbol">y</span>)&#123;decltype(x+y) xpy = x+y;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">decltype</span>(experession) <span class="hljs-selector-tag">var</span>;</code></pre></div><p>第一步：如果expression是一个没有用括号括起的标识符，则var的类型与该标识符的类型相同，包括const等限定符</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">double</span> x =<span class="hljs-number">2.5</span>;<span class="hljs-type">double</span> y =<span class="hljs-number">7.9</span>;<span class="hljs-type">double</span> &amp;rx = x;<span class="hljs-type">const</span> <span class="hljs-type">double</span> *pd;<span class="hljs-keyword">decltype</span>(x) w;<span class="hljs-keyword">decltype</span>(rx) u = y;<span class="hljs-keyword">decltype</span>(pd) v;</code></pre></div><p>第二步：如果expression是一个函数调用，则var的类型与函数的返回类型相同： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">indeed</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-keyword">decltype</span> (<span class="hljs-built_in">indeed</span>(<span class="hljs-number">3</span>)) m</code></pre></div><p>并不会实际调用函数。编译器通过查看函数的原型来获悉返回类型，而无需实际调用函数</p><p>第三步：如果expression是一个左值，则var为指向其类型的引用。这好像意味着前面的w应为引用类型，因为x是一个左值。但别忘了， 这种情况已经在第一步处理过了。要进入第三步，expression不能是未用括号括起的标识符。那么，expression是什么时将进入第三步呢？一 种显而易见的情况是，expression是用括号括起的标识符：</p><div class="code-wrapper"><pre><code class="hljs abnf">double xx <span class="hljs-operator">=</span><span class="hljs-number">4.4</span><span class="hljs-comment">;</span>decltype ((xx)) r2 <span class="hljs-operator">=</span> xx<span class="hljs-comment">;//r2 is double &amp;</span>decltype(xx) w <span class="hljs-operator">=</span>xx<span class="hljs-comment">;</span></code></pre></div><p>顺便说一句，括号并不会改变表达式的值和左值性。例如，下面两条语句等效： </p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">xx</span> <span class="hljs-operator">=</span> <span class="hljs-number">98.6</span><span class="hljs-comment">;</span>(xx) <span class="hljs-operator">=</span><span class="hljs-number">98.6</span><span class="hljs-comment">;</span></code></pre></div><p>第四步：如果前面的条件都不满足，则var的类型与expression的类型相同：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">3</span>;<span class="hljs-type">int</span> &amp;k = j;<span class="hljs-type">int</span> &amp;n = j;<span class="hljs-keyword">decltype</span>(j+<span class="hljs-number">6</span>) il;<span class="hljs-keyword">decltype</span>(<span class="hljs-number">100L</span>) i2;</code></pre></div><p>请注意，虽然k和n都是引用，但表达式k+n不是引用；它是两个int的和，因此类型为int。 </p><p>如果需要多次声明，可结合使用typedef和decltype：</p><div class="code-wrapper"><pre><code class="hljs angelscript">tempalte&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T1,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">T2</span>&gt;<span class="hljs-symbol">void</span> <span class="hljs-symbol">ft</span>(<span class="hljs-symbol">T1</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T2</span></span> <span class="hljs-symbol">y</span>)&#123;<span class="hljs-keyword">typedef</span> decltype(x+y) xytype;xytype xpy = x+y;xytype arr[<span class="hljs-number">10</span>];xytype &amp;rxy =arr[<span class="hljs-number">2</span>];&#125;</code></pre></div><h3 id="另一种函数声明语法（C-11后置返回类型）"><a href="#另一种函数声明语法（C-11后置返回类型）" class="headerlink" title="另一种函数声明语法（C++11后置返回类型）"></a>另一种函数声明语法（<strong>C++11</strong>后置返回类型）</h3><div class="code-wrapper"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T1,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">T2</span>&gt;?<span class="hljs-symbol">typ</span>?<span class="hljs-symbol">gt</span>(<span class="hljs-symbol">T1</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T2</span></span> <span class="hljs-symbol">y</span>)&#123;<span class="hljs-keyword">return</span> x+y&#125;</code></pre></div><p>同样，无法预先知道将x和y相加得到的类型。好像可以将返回类型设置为decltype ( x + y)，但不幸的是，此时还未声明参数x和y，它们不 在作用域内（编译器看不到它们，也无法使用它们）。必须在声明参数后使用decltype。为此，C++新增了一种声明和定义函数的语法。下面使用内置类型来说明这种语法的工作原理。对于下面的原型： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">float</span> y)</span></span>;</code></pre></div><p>使用新增的语法可编写成这样：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span> h(<span class="hljs-built_in">int</span> x ,<span class="hljs-built_in">float</span> y) -&gt;<span class="hljs-built_in">double</span>;</code></pre></div><p>这将返回类型移到了参数声明后面。-&gt;double被称为后置返回类型（trailing return type）。其中auto是一个占位符，表示后置返回类型提供的类型，这是C++11给auto新增的一种角色。这种语法也可用于函数定义：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span> h(<span class="hljs-built_in">int</span> x,<span class="hljs-built_in">float</span> y) -&gt; <span class="hljs-built_in">double</span>&#123;<span class="hljs-comment">/* function body */</span>&#125;</code></pre></div><p>通过结合使用这种语法和decltype，便可给gt()指定返回类型，如下所示：</p><div class="code-wrapper"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T1,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">T2</span>&gt;<span class="hljs-symbol">auto</span> <span class="hljs-symbol">gt</span>(<span class="hljs-symbol">T1</span> <span class="hljs-symbol">x,<span class="hljs-symbol">T2</span></span> <span class="hljs-symbol">y</span>)&#123;...<span class="hljs-keyword">return</span> x+y;...&#125;</code></pre></div><p>现在，decltype在参数声明后面，因此x和y位于作用域内，可以使用它们。 </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++扩展了C语言的函数功能。通过将inline关键字用于函数定义，并在首次调用该函数前提供其函数定义，可以使得C++编译器将该函数 视为内联函数。也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用。只有在函数很短时才能采用内联方式。 </p><p>引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。通常，被 声明为特定类型引用的标识符只能指向这种类型的数据；然而，如果一个类（如ofstream）是从另一个类（如ostream）派生出来的，则基类引用可以指向派生类对象</p><p>C++原型让您能够定义参数的默认值。如果函数调用省略了相应的参数，则程序将使用默认值；如果函数调用提供了参数值，则程序将使 用这个值（而不是默认值）。只能在参数列表中从右到左提供默认参数。因此，如果为某个参数提供了默认值，则必须为该参数右边所有的参数提供默认值。 </p><p>函数的特征标是其参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。通常，通过重载函数来 为不同的数据类型提供相同的服务。</p><p>函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，编译器将为程序中使用的特定参数类型生成正确的函数定义。 </p><h1 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h1><p>C++为在内存中存储数据方面提供了多种选择。可以选择数据保留在内存中的时间长度（存储持续性）以及程序的哪一部分可以访问数据 （作用域和链接）等。可以使用new来动态地分配内存，而定位new运算符提供了这种技术的一种变种。C++名称空间是另一种控制访问权的方式。通常，大型程序都由多个源代码文件组成，这些文件可能共享一些数据</p><h2 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h2><p>和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。第1章介绍过，可以单独编译这些文件，然后将它们链接成可 执行的程序。（通常，C++编译器既编译程序，也管理链接器。）如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。另外，大多数C++环境都提供了其他工具来帮助管理。例如，UNIX和Linux系统都具有make程序，可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序所需的步骤。大多数集成开发环境（包括Embarcadero C++ Builder、Microsoft Visual C++、Apple Xcode和Freescale CodeWarrior）都在Project菜单中提供了类似的工具</p><p>下面列出了头文件中常包含的内容。</p><ul><li>函数原型。 </li><li>使用#define或const定义的符号常量。 </li><li>结构声明。 </li><li>类声明。 </li><li>模板声明。 </li><li>内联函数。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// coordin.h -- structure templates and function prototypes</span><span class="hljs-comment">// structure templates</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COORDIN_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> COORDIN_H_</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">polar</span>&#123;    <span class="hljs-type">double</span> distance;    <span class="hljs-comment">// distance from origin</span>    <span class="hljs-type">double</span> angle;        <span class="hljs-comment">// direction from origin</span>&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rect</span>&#123;    <span class="hljs-type">double</span> x;        <span class="hljs-comment">// horizontal distance from origin</span>    <span class="hljs-type">double</span> y;        <span class="hljs-comment">// vertical distance from origin</span>&#125;;<span class="hljs-comment">// prototypes</span><span class="hljs-function">polar <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(rect xypos)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_polar</span><span class="hljs-params">(polar dapos)</span></span>; <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-15%2022.22.37.png" style="zoom:50%;" /><p>头文件管理</p><p>在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。例如，可能使用包含了另外一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef（即if not defined）的。下面的代码片段意味着仅当以前没有使用预处理器编译指令#define定义名称COORDIN<em>H</em>时，才处理#ifndef和#endif之间的语句：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COORDIN_H_</span>...<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>通常，使用#define语句来创建符号常量，如下所示： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXIMUM 4096</span></code></pre></div><p>但只要将#define用于名称，就足以完成该名称的定义，如下所示： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> COORDIN_H_</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> COORDIN_H_</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> COORDIN_H_</span>...<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>编译器首次遇到该文件时，名称COORDIN<em>H</em>没有定义（我们根据include文件名来选择名称，并加上一些下划线，以创建一个在其他地方不太可能被定义的名称）。在这种情况下，编译器将查看#ifndef和#endif之间的内容（这正是我们希望的），并读取定义COORDIN<em>H</em>的一 行。如果在同一个文件中遇到其他包含coordin.h的代码，编译器将知道COORDIN<em>H</em>已经被定义了，从而跳到#endfi后面的一行上。注意，这种方法并不能防止编译器将文件包含两次，而只是让它忽略除第一次包含之外的所有内容。大多数标准C和C++头文件都使用这种防护（guarding）方案。否则，可能在一个文件中定义同一个结构两次，这将导致编译错误。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cpp -- example of a three-file program</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;coordin.h&quot;</span> <span class="hljs-comment">// structure templates, function prototypes</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    rect rplace;    polar pplace;    cout &lt;&lt; <span class="hljs-string">&quot;Enter the x and y values: &quot;</span>;    <span class="hljs-keyword">while</span> (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)  <span class="hljs-comment">// slick use of cin</span>    &#123;        pplace = <span class="hljs-built_in">rect_to_polar</span>(rplace);        <span class="hljs-built_in">show_polar</span>(pplace);        cout &lt;&lt; <span class="hljs-string">&quot;Next two numbers (q to quit): &quot;</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Bye!\n&quot;</span>;<span class="hljs-comment">// keep window open in MSVC++</span><span class="hljs-comment">/*</span><span class="hljs-comment">    cin.clear();</span><span class="hljs-comment">    while (cin.get() != &#x27;\n&#x27;)</span><span class="hljs-comment">        continue;</span><span class="hljs-comment">    cin.get();</span><span class="hljs-comment">*/</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// file2.cpp -- contains functions called in file1.cpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;coordin.h&quot;</span> <span class="hljs-comment">// structure templates, function prototypes</span></span><span class="hljs-comment">// convert rectangular to polar coordinates</span><span class="hljs-function">polar <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(rect xypos)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    polar answer;    answer.distance =        <span class="hljs-built_in">sqrt</span>( xypos.x * xypos.x + xypos.y * xypos.y);    answer.angle = <span class="hljs-built_in">atan2</span>(xypos.y, xypos.x);    <span class="hljs-keyword">return</span> answer;      <span class="hljs-comment">// returns a polar structure</span>&#125;<span class="hljs-comment">// show polar coordinates, converting angle to degrees</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_polar</span> <span class="hljs-params">(polar dapos)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">const</span> <span class="hljs-type">double</span> Rad_to_deg = <span class="hljs-number">57.29577951</span>;    cout &lt;&lt; <span class="hljs-string">&quot;distance = &quot;</span> &lt;&lt; dapos.distance;    cout &lt;&lt; <span class="hljs-string">&quot;, angle = &quot;</span> &lt;&lt; dapos.angle * Rad_to_deg;    cout &lt;&lt; <span class="hljs-string">&quot; degrees\n&quot;</span>;&#125;</code></pre></div><p>将这两个源代码文件和新的头文件一起进行编译和链接，将生成一个可执行程序</p><p>顺便说一句，虽然我们讨论的是根据文件进行单独编译，但为保持通用性，C++标准使用了术语翻译单元（translation unit），而不是文 件；文件并不是计算机组织信息时的唯一方式。</p><h2 id="存储持续性、作用域和链接性"><a href="#存储持续性、作用域和链接性" class="headerlink" title="存储持续性、作用域和链接性"></a>存储持续性、作用域和链接性</h2><p>C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别就在于数据保留在内存中的时间。 </p><ul><li>自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时 被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。 </li><li>静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量。</li><li>线程存储持续性（C++11）：当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命 周期与所属的线程一样长。本书不探讨并行编程。 </li><li>动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）</li></ul><h3 id="作用域和链接"><a href="#作用域和链接" class="headerlink" title="作用域和链接"></a>作用域和链接</h3><p>作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。例如，函数中定义的变量可在该函数中使用，但不能在其他函数中 使用；而在文件中的函数定义之前定义的变量则可在所有函数中使用。链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的 名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。 </p><p>C++变量的作用域有多种。作用域为局部的变量只在定义它的代码块中可用。代码块是由花括号括起的一系列语句。例如函数体就是代码 块，但可以在函数体中嵌入其他代码块。作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。在函数原型作用域（function prototype scope）中使用的名称只在包含参数列表的括号内可用（这就是为什么这些名称是什么以及是否出现都不重要的原因）。在类中声明的成员的作用域为整个类（参见第10章）。在名称空间中声明的变量的作用域为整个名称空间（由于名称空间已经引入 到C++语言中，因此全局作用域是名称空间作用域的特例）。 </p><p>C++函数的作用域可以是整个类或整个名称空间（包括全局的），但不能是局部的（因为不能在代码块内定义函数，如果函数的作用域为 局部，则只对它自己是可见的，因此不能被其他函数调用。这样的函数将无法运行）。 </p><p>不同的C++存储方式是通过存储持续性、作用域和链接性来描述的。</p><h3 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h3><p>在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。也就是说，如果在main( )中声明了一 个名为texas的变量，并在函数oil( )中也声明了一个名为texas变量，则创建了两个独立的变量——只有在定义它们的函数中才能使用它们。对oil( )中的texas执行的任何操作都不会影响main( )中的texas，反之亦然。另外，当程序开始执行这些变量所属的代码块时，将为其分配内存；当函数结束时，这些变量都将消失（注意，执行到代码块时，将为变量分配内存，但其作用域的起点为其声明位置）。</p><p>如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。例如，假设在main( )的开头定义了一个名为teledeli的变量，然后在main( )中开始一个新的代码块，并其中定义了一个新的变量teledeli，则teledeli在内部代码块和外部代码块中都是可见的，而websight就只在内部代码块中可见，它的作用域是从定义它的位置到该代码块的结尾： </p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span> ()</span>&#123;<span class="hljs-built_in">int</span> teledeli = <span class="hljs-number">5</span>;&#123;<span class="hljs-built_in">int</span> teledeli = <span class="hljs-number">2</span>;&#125;&#125;</code></pre></div><p>然而，如果将内部代码块中的变量命名为teledeli，而不是websight，使得有两个同名的变量（一个位于外部代码块中，另一个位 于内部代码块中），情况将如何呢？在这种情况下，程序执行内部代码块中的语句时，将teledeli解释为局部代码块变量。我们说，新的定义隐 藏了（hide）以前的定义，新定义可见，旧定义暂时不可见。在程序离开该代码块时，原来的定义又重新可见</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// autoscp.cpp -- illustrating scope of automatic variables</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oil</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> texas = <span class="hljs-number">31</span>;    <span class="hljs-type">int</span> year = <span class="hljs-number">2011</span>;    cout &lt;&lt; <span class="hljs-string">&quot;In main(), texas = &quot;</span> &lt;&lt; texas &lt;&lt; <span class="hljs-string">&quot;, &amp;texas = &quot;</span>;    cout &lt;&lt; &amp;texas &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;In main(), year = &quot;</span> &lt;&lt; year &lt;&lt; <span class="hljs-string">&quot;, &amp;year = &quot;</span>;    cout &lt;&lt; &amp;year &lt;&lt; endl;    <span class="hljs-built_in">oil</span>(texas);    cout &lt;&lt; <span class="hljs-string">&quot;In main(), texas = &quot;</span> &lt;&lt; texas &lt;&lt; <span class="hljs-string">&quot;, &amp;texas = &quot;</span>;    cout &lt;&lt; &amp;texas &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;In main(), year = &quot;</span> &lt;&lt; year &lt;&lt; <span class="hljs-string">&quot;, &amp;year = &quot;</span>;    cout &lt;&lt; &amp;year &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oil</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> texas = <span class="hljs-number">5</span>;    cout &lt;&lt; <span class="hljs-string">&quot;In oil(), texas = &quot;</span> &lt;&lt; texas &lt;&lt; <span class="hljs-string">&quot;, &amp;texas = &quot;</span>;    cout &lt;&lt; &amp;texas &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;In oil(), x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &amp;x = &quot;</span>;    cout &lt;&lt; &amp;x &lt;&lt; endl;    &#123;                               <span class="hljs-comment">// start a block</span>        <span class="hljs-type">int</span> texas = <span class="hljs-number">113</span>;        cout &lt;&lt; <span class="hljs-string">&quot;In block, texas = &quot;</span> &lt;&lt; texas;        cout &lt;&lt; <span class="hljs-string">&quot;, &amp;texas = &quot;</span> &lt;&lt; &amp;texas &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">&quot;In block, x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &amp;x = &quot;</span>;        cout &lt;&lt; &amp;x &lt;&lt; endl;    &#125;                               <span class="hljs-comment">// end a block</span>    cout &lt;&lt; <span class="hljs-string">&quot;Post-block texas = &quot;</span> &lt;&lt; texas;    cout &lt;&lt; <span class="hljs-string">&quot;, &amp;texas = &quot;</span> &lt;&lt; &amp;texas &lt;&lt; endl;&#125;<span class="hljs-comment">//In main(), texas = 31, &amp;texas = 0x16dd07738</span><span class="hljs-comment">//In main(), year = 2011, &amp;year = 0x16dd07734</span><span class="hljs-comment">//In oil(), texas = 5, &amp;texas = 0x16dd076d8</span><span class="hljs-comment">//In oil(), x = 31, &amp;x = 0x16dd076dc</span><span class="hljs-comment">//In block, texas = 113, &amp;texas = 0x16dd076d4</span><span class="hljs-comment">//In block, x = 31, &amp;x = 0x16dd076dc</span><span class="hljs-comment">//Post-block texas = 5, &amp;texas = 0x16dd076d8</span><span class="hljs-comment">//In main(), texas = 31, &amp;texas = 0x16dd07738</span><span class="hljs-comment">//In main(), year = 2011, &amp;year = 0x16dd07734</span></code></pre></div><p>执行到main( )时，程序为texas和year分配空间，使得这些变量可见。当程序调用oil( )时，这些变量仍留在内存 中，但不可见。为两个新变量（x和texas）分配内存，从而使它们可见。在程序执行到oil( )中的内部代码块时，新的texas将不可见，它被一个更新的定义代替。然而，变量x仍然可见，这是因为该代码块没有定义x变量。当程序流程离开该代码块时，将释放最新的texas使用的内存，而第二个texas再次可见。当oil( )函数结束时，texas和x都将过期，而最初的texas和year再次变得可见。 </p><h4 id="自动变量的初始化"><a href="#自动变量的初始化" class="headerlink" title="自动变量的初始化"></a>自动变量的初始化</h4><p>可以使用任何在声明时其值为已知的表达式来初始化自动变量</p><div class="code-wrapper"><pre><code class="hljs abnf">int w<span class="hljs-comment">;</span>int x <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span></code></pre></div><h4 id="自动变量和栈"><a href="#自动变量和栈" class="headerlink" title="自动变量和栈"></a>自动变量和栈</h4><p>了解典型的C++编译器如何实现自动变量有助于更深入地了解自动变量。由于自动变量的数目随函数的开始和结束而增减，因此程序必须 在运行时对自动变量进行管理。常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以被称为栈，是由于新数据被象征性地放在原有数据的上面（也就是说，在相邻的内存单元中，而不是在同一个内存单元中），当程序使用完后，将其从栈中删除。栈的默认长度取决于实现，但编译器通常提供改变栈长度的选项。程序使用两个指针来跟踪栈，一个指针指向栈底——栈的开始位置，另一个指针指向堆顶 ——下一个可用内存单元。当函数被调用时，其自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。 </p><p>栈是LIFO（后进先出）的，即最后加入到栈中的变量首先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后 重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。例如，图9.3表明，函数fib( )被调用时，传递一个2字节的int和一个4字节的long。这些值被加入到栈中。当fib( )开始执行时，它将名称real和tell同这两个值关联起来。当fib( )结束时，栈顶指针重新指向以前的位置。新值没有被删除，但不再被标记，它们所占据的空间将被下一个将值加入到栈中的函数调用所使用（图9.3做了简化，因为函数调用可能传递其他信息，如返回地址）。</p><p><img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-16%2022.30.18.png"></p><h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><p>关键字register最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量：</p><div class="code-wrapper"><pre><code class="hljs abnf">register int_count_fast<span class="hljs-comment">;</span></code></pre></div><p>这旨在提高访问变量的速度。 </p><p>在C++11之前，这个关键字在C++中的用法始终未变，只是随着硬件和编译器变得越来越复杂，这种提示表明变量用得很多，编译器可对 其做特殊处理。在C++11中，这种提示作用也失去了，关键字register只是显式地指出变量是自动的。鉴于关键字register只能用于原本就是自动的变量，使用它的唯一原因是，指出程序员想使用一个自动变量，这个变量的名称可能与外部变量相同。这与auto以前的用途完全相同。然而，保留关键字register的重要原因是，避免使用了该关键字的现有代码非法</p><h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><p>和C语言一样，C++也为静态存储持续性变量提供了3种链接性：外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访 问）和无链接性（只能在当前函数或代码块中访问）。这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地 初始化静态变量，编译器将把它设置为0。在默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。 </p><p>传统的K&amp;R C不允许初始化自动数组和结构，但允许初始化静态数组和结构。ANSI C和C++允许对这两种数组和结构进行初始化，但有些旧的C++翻译器使用与ANSI C不完全兼容的C编译器。如果使用的是这样的实现，则可能需要使用这3种静态存储类型之一，以初始化数 组和结构。 </p><p>要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符；要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> <span class="hljs-keyword">global</span> = <span class="hljs-number">1000</span>;<span class="hljs-comment">//static duration,external linkage</span><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> one_file = <span class="hljs-number">50</span>; <span class="hljs-comment">//static duration,innteranl linkage</span><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">funct1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> count =<span class="hljs-number">0</span>;<span class="hljs-comment">//static duration,no linkage;</span><span class="hljs-built_in">int</span> llama = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> q</span>)</span>&#123;&#125;</code></pre></div><p>所有静态持续变量（上述示例中的global、 one_file和count）在整个程序执行期间都存在。在funct1( )中声明的变量count的作用域为局部，没有链接性，这意味着只能在funct1( )函数中使用它，就像自动变量llama一样。然而，与llama不同的是，即使在funct1( )函数没有被执行时，count也留在内存中。global和one_file的作用域都为整个文件，即在从声明位置到文件结尾的范围内都可以被使用。具体地说，可以在main( )、funct1( )和funct2( )中使用它们。由于one_file的链接性为内部，因此只能在包含上述代码的文件中使用它；由于global的链接性为外部，因此可以在程序的其他文件中使用它。</p><p>所有的静态持续变量都有下述初始化特征：未被初始化的静态变量的所有位都被设置为0。这种变量被称为零初始化的（zero- initialized）</p><h5 id="5种变量储存方式"><a href="#5种变量储存方式" class="headerlink" title="5种变量储存方式"></a><strong>5</strong>种变量储存方式</h5><table><thead><tr><th>存储描述</th><th>持续性</th><th>作用域</th><th>链接性</th><th>如何声明</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>代码块</td><td>无</td><td>在代码块中</td></tr><tr><td>寄存器</td><td>自动</td><td>代码块</td><td>无</td><td>在代码块中，使用关键字register</td></tr><tr><td>静态，无链接性</td><td>静态</td><td>代码块</td><td>无</td><td>在代码块中，使用关键字static</td></tr><tr><td>静态，外部链接性</td><td>静态</td><td>文件</td><td>外部</td><td>不在任何函数内</td></tr><tr><td>静态，内部链接性</td><td>静态</td><td>文件</td><td>内部</td><td>不在任何函数内，使用关键字static</td></tr></tbody></table><p>静态变量的初始化</p><p>除默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化。您可能猜到了，零初始化意味着将变量设置为零。对于标量 类型，零将被强制转换为合适的类型。例如，在C++代码中，空指针用0表示，但内部可能采用非零表示，因此指针变量将被初始化相应的内部表示。结构成员被零初始化，且填充位都被设置为零。 </p><p>零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量。动态初始化意味着变量将在 编译后初始化。 </p><h3 id="静态持续性、外部链接性"><a href="#静态持续性、外部链接性" class="headerlink" title="静态持续性、外部链接性"></a>静态持续性、外部链接性</h3><p>链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函 数而言都是外部的。例如，可以在main( )前面或头文件中定义它们。可以在文件中位于外部变量定义后面的任何函数中使用它，因此外部变量也称全局变量（相对于局部的自动变量）。 </p><h4 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h4><p>一方面，在每个使用外部变量的文件中，都必须声明它；另一方面，C++有“单定义规则”（One Definition Rule，ODR），该规则指出， 变量只能有一次定义。为满足这种需求，C++提供了两种变量声明。一种是定义声明（defining declaration）或简称为定义（definition），它给 变量分配存储空间；另一种是引用声明（referencing declaration）或简称为声明（declaration），它不给变量分配存储空间，因为它引用已有 的变量。</p><p>引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> blem;<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> gr = <span class="hljs-string">&#x27;z&#x27;</span>;</code></pre></div><p>如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使 用关键字extern声明它： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//file01.cpp</span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> cats = <span class="hljs-number">20</span>;<span class="hljs-comment">//definition because of initialization</span><span class="hljs-type">int</span> dogs =<span class="hljs-number">22</span>; <span class="hljs-comment">//also a definition</span><span class="hljs-type">int</span> fleas;<span class="hljs-comment">//also a definition</span><span class="hljs-comment">//file02.cpp</span><span class="hljs-comment">//use cats and dogs from file01.cpp</span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> cats; <span class="hljs-comment">//not definition because they use</span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> dogs; <span class="hljs-comment">//extern but not initialization</span>....<span class="hljs-comment">//file98.cpp</span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> cats; <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> dogs;<span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> fleas;</code></pre></div><p>在这里，所有文件都使用了在file01.cpp中定义的变量cats和dogs，但file02.cpp没有重新声明变量fleas，因此无法访问它。在文件file01.cpp 中，关键字extern并非必不可少的，因为即使省略它，效果也相同（参 见图9.4）</p><img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-18%2001.03.02.png" style="zoom:50%;" /><p>请注意，单定义规则并非意味着不能有多个变量的名称相同。例如，在不同函数中声明的同名自动变量是彼此独立的，它们都有自己的 地址。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// external.cpp -- external variable</span><span class="hljs-comment">// compile with support.cpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// external variable</span><span class="hljs-type">double</span> warming = <span class="hljs-number">0.3</span>;       <span class="hljs-comment">// warming defined</span><span class="hljs-comment">// function prototypes</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">double</span> dt)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">local</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>                  <span class="hljs-comment">// uses global variable</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;Global warming is &quot;</span> &lt;&lt; warming &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;    <span class="hljs-built_in">update</span>(<span class="hljs-number">0.1</span>);            <span class="hljs-comment">// call function to change warming</span>    cout &lt;&lt; <span class="hljs-string">&quot;Global warming is &quot;</span> &lt;&lt; warming &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;    <span class="hljs-built_in">local</span>();                <span class="hljs-comment">// call function with local warming</span>    cout &lt;&lt; <span class="hljs-string">&quot;Global warming is &quot;</span> &lt;&lt; warming &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// support.cpp -- use external variable</span><span class="hljs-comment">// compile with external.cpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> warming;  <span class="hljs-comment">// use warming from another file</span><span class="hljs-comment">// function prototypes</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">double</span> dt)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">local</span><span class="hljs-params">()</span></span>;<span class="hljs-keyword">using</span> std::cout;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">double</span> dt)</span>      <span class="hljs-comment">// modifies global variable</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> warming;  <span class="hljs-comment">// optional redeclaration</span>    warming += dt;          <span class="hljs-comment">// uses global warming</span>    cout &lt;&lt; <span class="hljs-string">&quot;Updating global warming to &quot;</span> &lt;&lt; warming;    cout &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">local</span><span class="hljs-params">()</span>                <span class="hljs-comment">// uses local variable</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">double</span> warming = <span class="hljs-number">0.8</span>;   <span class="hljs-comment">// new variable hides external one</span>    cout &lt;&lt; <span class="hljs-string">&quot;Local warming = &quot;</span> &lt;&lt; warming &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;        <span class="hljs-comment">// Access global variable with the</span>        <span class="hljs-comment">// scope resolution operator</span>    cout &lt;&lt; <span class="hljs-string">&quot;But global warming = &quot;</span> &lt;&lt; ::warming;    cout &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;&#125;</code></pre></div><p>main( )和update( ) 都可以访问外部变量warming。注意，update( )修改了warming，这种修改在随后使用该变量时显现出来了</p><p>warming的定义如下：</p><p><code>double warming = 0.3;       // warming defined</code></p><p>使用关键字extern声明变量warming，让该文件中的函数能够使用它： </p><p><code>extern double warming;  // use warming from another file</code></p><p>正如注释指出的，该声明的的意思是，使用外部定义的变量warming。 </p><p>另外，函数update()使用关键字extern重新声明了变量warming，这个关键字的意思是，通过这个名称使用在外部定义的变量。由于即使省 略该声明，update( )的功能也相同，因此该声明是可选的。它指出该函数被设计成使用外部变量。 local( )函数表明，定义与全局变量同名的局部变量后，局部变量将隐藏全局变量。例如，local( )函数显示warming的值时，将使用warming 的局部定义。 </p><p>C++比C语言更进了一步——它提供了作用域解析运算符（::）。放在变量名前面时，该运算符表示使用变量的全局版本。因此，local( )将 warming显示为0.8，但将::warming显示为0.4。从清晰和避免错误的角度说，相对于使用warming并依赖于作用域规则，在函数update()中使用::warming是更好的选择，也更安全。 </p><h3 id="静态持续性、内部链接性"><a href="#静态持续性、内部链接性" class="headerlink" title="静态持续性、内部链接性"></a>静态持续性、内部链接性</h3><p>将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。在多文件程序中，内部链接性和外部链接性之间的差别很有意义。链接性为内部的变量只能在其所属的文件中使用；但常规外部变量都具有外部链接性，即可以在其他文件中使用，</p><p>如果要在其他文件中使用相同的名称来表示其他变量，该如何办呢？只需省略关键字extern即可吗？</p><div class="code-wrapper"><pre><code class="hljs abnf">//file1.cppint errors <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">;</span>//file2.cppint errors <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-comment">;</span></code></pre></div><p>这种做法将失败，因为它违反了单定义规则。file2中的定义试图创建一个外部变量，因此程序将包含errors的两个定义，这是错误。 </p><p>但如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-comment">//file1.cpp</span><span class="hljs-type">int</span> errors = <span class="hljs-number">20</span>;<span class="hljs-comment">//file2.cpp</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> errors = <span class="hljs-number">5</span>;</code></pre></div><p>这没有违反单定义规则，因为关键字static指出标识符errors的链接性为内部，因此并非要提供外部定义。</p><p>在多文件程序中，可以在一个文件（且只能在一个文件）中定义一个外部变量。使用该变量的其他文件必须使用关键字extern声明它。 </p><p>可使用外部变量在多文件程序的不同部分之间共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（名称 空间提供了另外一种共享数据的方法）。另外，如果将作用域为整个文件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个文件的变量发生冲突。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// twofile1.cpp -- variables with external and internal linkage</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// to be compiled with two file2.cpp</span></span><span class="hljs-type">int</span> tom = <span class="hljs-number">3</span>;            <span class="hljs-comment">// external variable definition</span><span class="hljs-type">int</span> dick = <span class="hljs-number">30</span>;          <span class="hljs-comment">// external variable definition</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> harry = <span class="hljs-number">300</span>; <span class="hljs-comment">// static, internal linkage</span><span class="hljs-comment">// function prototype</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remote_access</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;main() reports the following addresses:\n&quot;</span>;    cout &lt;&lt; &amp;tom &lt;&lt; <span class="hljs-string">&quot; = &amp;tom, &quot;</span> &lt;&lt; &amp;dick &lt;&lt; <span class="hljs-string">&quot; = &amp;dick, &quot;</span>;    cout &lt;&lt; &amp;harry &lt;&lt; <span class="hljs-string">&quot; = &amp;harry\n&quot;</span>;    <span class="hljs-built_in">remote_access</span>();    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// twofile2.cpp -- variables with internal and external linkage</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> tom;         <span class="hljs-comment">// tom defined elsewhere</span><span class="hljs-type">static</span> <span class="hljs-type">int</span> dick = <span class="hljs-number">10</span>;   <span class="hljs-comment">// overrides external dick</span><span class="hljs-type">int</span> harry = <span class="hljs-number">200</span>;        <span class="hljs-comment">// external variable definition,</span>                        <span class="hljs-comment">// no conflict with twofile1 harry</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remote_access</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;remote_access() reports the following addresses:\n&quot;</span>;    cout &lt;&lt; &amp;tom &lt;&lt; <span class="hljs-string">&quot; = &amp;tom, &quot;</span> &lt;&lt; &amp;dick &lt;&lt; <span class="hljs-string">&quot; = &amp;dick, &quot;</span>;    cout &lt;&lt; &amp;harry &lt;&lt; <span class="hljs-string">&quot; = &amp;harry\n&quot;</span>;&#125;</code></pre></div><h3 id="静态存储持续性、无链接性"><a href="#静态存储持续性、无链接性" class="headerlink" title="静态存储持续性、无链接性"></a>静态存储持续性、无链接性</h3><p>无链接性的局部变 量。这种变量是这样创建的，将static限定符用于在代码块中定义的变量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。 这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。因此在两次函数调用之间，静态局部变量的值将保持不变。（静态变量适用于再生——可以用它们将瑞士银行的秘密账号传递到下一个要去的地方）。另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化。以后再调用函数时，将不会像自动变量那样再次被初始化</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// static.cpp -- using a static local variable</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// constants</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">10</span>;<span class="hljs-comment">// function prototype</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strcount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> input[ArSize];    <span class="hljs-type">char</span> next;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a line:\n&quot;</span>;    cin.<span class="hljs-built_in">get</span>(input, ArSize);    <span class="hljs-keyword">while</span> (cin)    &#123;        cin.<span class="hljs-built_in">get</span>(next);        <span class="hljs-keyword">while</span> (next != <span class="hljs-string">&#x27;\n&#x27;</span>)    <span class="hljs-comment">// string didn&#x27;t fit!</span>            cin.<span class="hljs-built_in">get</span>(next);      <span class="hljs-comment">// dispose of remainder</span>        <span class="hljs-built_in">strcount</span>(input);        cout &lt;&lt; <span class="hljs-string">&quot;Enter next line (empty line to quit):\n&quot;</span>;        cin.<span class="hljs-built_in">get</span>(input, ArSize);    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Bye\n&quot;</span>;<span class="hljs-comment">// code to keep window open for MSVC++</span><span class="hljs-comment">/*</span><span class="hljs-comment">cin.clear();</span><span class="hljs-comment">    while (cin.get() != &#x27;\n&#x27;)</span><span class="hljs-comment">        continue;</span><span class="hljs-comment">    cin.get();</span><span class="hljs-comment">*/</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strcount</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;        <span class="hljs-comment">// static local variable</span>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;               <span class="hljs-comment">// automatic local variable</span>    cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt;<span class="hljs-string">&quot;\&quot; contains &quot;</span>;    <span class="hljs-keyword">while</span> (*str++)               <span class="hljs-comment">// go to end of string</span>        count++;    total += count;    cout &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; characters\n&quot;</span>;    cout &lt;&lt; total &lt;&lt; <span class="hljs-string">&quot; characters total\n&quot;</span>;&#125;<span class="hljs-comment">//Enter a line:</span><span class="hljs-comment">//nice plants</span><span class="hljs-comment">//&quot;nice plan&quot; contains 9 characters</span><span class="hljs-comment">//9 characters total</span><span class="hljs-comment">//Enter next line (empty line to quit):</span><span class="hljs-comment">//thanks</span><span class="hljs-comment">//&quot;thanks&quot; contains 6 characters</span><span class="hljs-comment">//15 characters total</span><span class="hljs-comment">//Enter next line (empty line to quit):</span><span class="hljs-comment">//parting is suchsweet snow</span><span class="hljs-comment">//&quot;parting i&quot; contains 9 characters</span><span class="hljs-comment">//24 characters total</span><span class="hljs-comment">//Enter next line (empty line to quit):</span><span class="hljs-comment">//ok</span><span class="hljs-comment">//&quot;ok&quot; contains 2 characters</span><span class="hljs-comment">//26 characters total</span><span class="hljs-comment">//Enter next line (empty line to quit):</span><span class="hljs-comment">//</span><span class="hljs-comment">//Bye</span></code></pre></div><p>注意，由于数组长度为10，因此程序从每行读取的字符数都不超过9个。另外还需要注意的是，每次函数被调用时，自动变量count都被重置为0。然而，静态变量total只在程序运行时被设置为0，以后在两次函数调用之间，其值将保持不变，因此能够记录读取的字符总数。</p><h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><p>有些被称为存储说明符（storage class specifier）或cv-限定符（cv- qualifier）的C++关键字提供了其他有关存储的信息。下面是存储说明 符</p><ul><li>auto（在C++11中不再是说明符）； </li><li>register； </li><li>static； </li><li>extern； </li><li>thread_local（C++11新增的）； </li><li>mutable。 </li></ul><p>其中的大部分已经介绍过了，在同一个声明中不能使用多个说明符，但thread_local除外，它可与static或extern结合使用。前面讲过，在 C++11之前，可以在声明中使用关键字auto指出变量为自动变量；但在C++11中，auto用于自动类型推断。关键字register用于在声明中指示寄存器存储，而在C++11中，它只是显式地指出变量是自动的。关键字 static被用在作用域为整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性为静态的。关键字extern表明是引用声明，即声明引用在其他地方定义的变量。关键字thread_local指出变量的持续性与其所属线程的持续性相同。thread_local变量之于线程，犹如常规静态变量之于整个程序。关键字mutable的含义将根据const来解释，因此先来介绍cv-限定符，然后再解释它</p><h4 id="cv-限定符"><a href="#cv-限定符" class="headerlink" title="**cv-**限定符"></a>**cv-**限定符</h4><ul><li>const； </li><li>volatile。</li></ul><p>关键字volatile表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。听起来似乎很神秘，实际上并非如此。例如，可以将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息。在这种情况下，硬件（而不是程序）可能修改其中的内容。或者两个程序可能互相影响，共享数据。该关键字的作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile，则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器，不要进行这种优化。 </p><h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h4><p>可以用它来指出，即使结构（或类）变量为const，其某个成员也可以被修改。</p><div class="code-wrapper"><pre><code class="hljs fortran">struct <span class="hljs-keyword">data</span> &#123;<span class="hljs-built_in">char</span> <span class="hljs-keyword">name</span>[<span class="hljs-number">30</span>];mutable <span class="hljs-built_in">int</span> <span class="hljs-keyword">access</span>;&#125;const <span class="hljs-keyword">data</span> veep = &#123;<span class="hljs-string">&quot;mike&quot;</span>,<span class="hljs-number">0</span>&#125;;strcpy(veep.<span class="hljs-keyword">name</span>,<span class="hljs-string">&#x27;joe&#x27;</span>);veep.<span class="hljs-keyword">access</span>++</code></pre></div><p>veep的const限定符禁止程序修改veep的成员，但access成员的mutable说明符使得access不受这种限制。</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">int</span> fingers =<span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;&#125;</code></pre></div><p>C++修改了常量类型的规则，让程序员更轻松。例如，假设将一组常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那 么，预处理器将头文件的内容包含到每个源文件中后，所有的源文件都将包含类似下面这样的定义：</p><div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> fingers = <span class="hljs-number">10</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">warning</span> = <span class="hljs-string">&quot;wark&quot;</span></code></pre></div><p>如果全局const声明的链接性像常规变量那样是外部的，则根据单定义规则，这将出错。也就是说，只能有一个文件可以包含前面的声明，而其他文件必须使用extern关键字来提供引用声明。另外，只有未使用extern关键字的声明才能进行初始化： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//extern would be required if const had external linkage</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> fingers;<span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * warning;</code></pre></div><p>因此，需要为某个文件使用一组定义，而其他文件使用另一组声明。然而，由于外部定义的const数据的链接性为内部的，因此可以在所 有文件中使用相同的声明。</p><p>内部链接性还意味着，每个文件都有自己的一组常量，而不是所有文件共享一组常量。每个定义都是其所属文件私有的，这就是能够将常 量定义放在头文件中的原因。这样，只要在两个源代码文件中包括同一个头文件，则它们将获得同一组常量。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> states = <span class="hljs-number">50</span>;</code></pre></div><p>在这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它。这与常规外部变量不同，定义常规外部变量时，不必使用 extern关键字，但在使用该变量的其他文件中必须使用extern。然而，请在函数或代码块中声明const时，其作用域为代码块，即仅当程序执行该代码块中的代码时，该常量才是可用的。这意味着在函数或代码块中创建常量时，不必担心其名称与其他地方定义的常量发生冲突。 </p><h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><p>和变量一样，函数也有链接性，虽然可选择的范围比变量小。和C语言一样，C++不允许在一个函数中定义另外一个函数，因此所有函数 的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。在默认情况下，函数的链接性为外部的，即可以在文件间共享。实际上，可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义的，不过这是可选的（要让程序在另一个文件中查找函数，该文件必须作为程序的组成部分被编译，或者是由链接程序搜索的库文件）。还可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字： </p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">private</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x</span>)</span>;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">private</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> x</span>)</span>&#123;...&#125;</code></pre></div><p>这意味着该函数只在这个文件中可见，还意味着可以在其他文件中定义同名的的函数。和变量一样，在定义静态函数的文件中，静态函数 将覆盖外部定义，因此即使在外部定义了同名的函数，该文件仍将使用静态函数。</p><p>单定义规则也适用于非内联函数，因此对于每个非内联函数，程序只能包含一个定义。对于链接性为外部的函数来说，这意味着在多文件 程序中，只能有一个文件（该文件可能是库文件，而不是您提供的）包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。 内联函数不受这项规则的约束，这允许程序员能够将内联函数的定 义放在头文件中。这样，包含了头文件的每个文件都有内联函数的定 义。然而，C++要求同一个函数的所有内联定义都必须相同。 </p><p>假设在程序的某个文件中调用一个函数，C++将到哪里去寻找该函数的定义呢？如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义；否则，编译器（包括链接程序）将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消 息，因为每个外部函数只能有一个定义。如果在程序文件中没有找到，编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数（然而，C++保留了标准库函数的名称，即程序员不应使用它们）。有些编译器-链 接程序要求显式地指出要搜索哪些库。 </p><h3 id="语言链接性"><a href="#语言链接性" class="headerlink" title="语言链接性"></a>语言链接性</h3><p>另一种形式的链接性——称为语言链接性（language linking）也对函数有影响。首先介绍一些背景知识。链接程序要求每个不同的函数都有不同的符号名。在C语言中，一个名称只对应一个函数，因此这很容易实现。为满足内部需要，C语言编译器可能将spiff这样的函数名翻译为_spiff。这种方法被称为C语言链接性（C language linkage）。但在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此，C++编译器执行名称矫正或名称修饰（参见第8章），为重载函数生成不同的符号名称。例如，可能将spiff（int）转换为_spoff_i，而将spiff（double，double）转换为_spiff_d_d。这种方法被 称为C++语言链接（C++ language linkage）。 </p><p>链接程序寻找与C++函数调用匹配的函数时，使用的方法与C语言 不同。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">spiff</span><span class="hljs-params">(<span class="hljs-number">22</span>)</span></span></code></pre></div><p>它在C库文件中的符号名称为_spiff，但对于我们假设的链接程序来说，C++查询约定是查找符号名称_spiff_i。为解决这种问题，可以用函数原型来指出要使用的约定</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spiff</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">spoff</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C++&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spaff</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;</code></pre></div><p>第一个原型使用C语言链接性；而后面的两个使用C++语言链接 性。第二个原型是通过默认方式指出这一点的，而第三个显式地指出了这一点.</p><h3 id="存储方案和动态分配"><a href="#存储方案和动态分配" class="headerlink" title="存储方案和动态分配"></a>存储方案和动态分配</h3><p>前面介绍C++用来为变量（包括数组和结构）分配内存的5种方案（线程内存除外），它们不适用于使用C++运算符new（或C函数malloc( )）分配的内存，这种内存被称为动态内存。第4章介绍过，动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。因此，可以在一个函数中分配动态内存，而在另一个函数中将其释放。与自动内存不同，动态内存不是LIFO，其分配和释放顺序要取决于new和delete在何时以何种方式被使用。通常，编译器使用三块独立的内存：一块用于静态变量（可能再细分），一块用于自动变量，另外一块用于动态存储。</p><p>虽然存储方案概念不适用于动态内存，但适用于用来跟踪动态内存的自动和静态指针变量。例如，假设在一个函数中包含下面的语句： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">float</span> * p_fess = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[<span class="hljs-number">20</span>];</code></pre></div><p>由new分配的80个字节（假设float为4个字节）的内存将一直保留在内存中，直到使用delete运算符将其释放。但当包含该声明的语句块执行完毕时，p_fees指针将消失。如果希望另一个函数能够使用这80个字节中的内容，则必须将其地址传递或返回给该函数。另一方面，如果将p_fees的链接性声明为外部的，则文件中位于该声明后面的所有函数都可以使用它。另外，通过在另一个文件中使用下述声明，便可在其中使用该指针：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">float</span> * p_fees;</code></pre></div><p>在程序结束时，由new分配的内存通常都将被释放，不过情况也并不总是这样。例如，在不那么健壮的操作系统中，在某些情况下，请求大型内存块将导致该代码块在程序结束不会被自动释放。最佳的做法是，使用delete来释放new分配的内存。</p><h4 id="使用new运算符初始化"><a href="#使用new运算符初始化" class="headerlink" title="使用new运算符初始化"></a>使用new运算符初始化</h4><p>如果要初始化动态分配的变量，该如何办呢？在C++98中，有时候可以这样做，C++11增加了其他可能性。下面先来看看C++98提供的可 能性</p><p>如果要为内置的标量类型（如int或double）分配存储空间并初始化，可在类型名后面加上初始值，并将其用括号括起： </p><div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> (<span class="hljs-number">6</span>);<span class="hljs-keyword">double</span> * pd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span> (<span class="hljs-number">99.99</span>);</code></pre></div><p>然而，要初始化常规结构或数组，需要使用大括号的列表初始化，这要求编译器支持C++11。C++11允许您这样做： </p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">where</span> &#123;<span class="hljs-built_in">double</span> x;<span class="hljs-built_in">double</span> y;<span class="hljs-built_in">double</span> z;&#125;;<span class="hljs-keyword">where</span> * one =<span class="hljs-keyword">new</span> <span class="hljs-keyword">where</span> &#123;<span class="hljs-number">2.5</span>,<span class="hljs-number">5.3</span>,<span class="hljs-number">7.2</span>&#125;;<span class="hljs-built_in">int</span> * ar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> [<span class="hljs-number">4</span>] &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;</code></pre></div><p>在C++11中，还可将列表初始化用于单值变量:</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> *pin = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> &#123;<span class="hljs-number">6</span>&#125;;<span class="hljs-type">double</span> * pdo = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span> &#123;<span class="hljs-number">99.99</span>&#125;;</code></pre></div><h4 id="new失败时"><a href="#new失败时" class="headerlink" title="new失败时"></a>new失败时</h4><p>new可能找不到请求的内存量。在最初的10年中，C++在这种情况下让new返回空指针，但现在将引发异常std::bad_alloc</p><h4 id="new：运算符、函数和替换函数"><a href="#new：运算符、函数和替换函数" class="headerlink" title="new：运算符、函数和替换函数"></a>new：运算符、函数和替换函数</h4><p>运算符new和new []分别调用如下函数：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span></span>;<span class="hljs-type">void</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](std::<span class="hljs-type">size_t</span>);</code></pre></div><p>这些函数被称为分配函数（alloction function），它们位于全局名称空间中。同样，也有由delete和delete []调用的释放函数（deallocation function）： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span>;<span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span> *);</code></pre></div><p>std::size_t是一个 typedef，对应于合适的整型。对于下面这样的基本语句：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> * pi = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;</code></pre></div><p>将被转换为下面这样</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> *pi = <span class="hljs-keyword">new</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>));</code></pre></div><p>而下面的语句： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> *pa = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">40</span>];</code></pre></div><p>将被转换为下面这样： </p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> * pa = <span class="hljs-keyword">new</span>(<span class="hljs-number">40</span>*<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>));</code></pre></div><p>正如您知道的，使用运算符new的语句也可包含初始值，因此，使用new运算符时，可能不仅仅是调用new()函数。</p><div class="code-wrapper"><pre><code class="hljs gml"><span class="hljs-keyword">delete</span> <span class="hljs-symbol">pi</span> =&gt;<span class="hljs-keyword">delete</span> (<span class="hljs-symbol">pi</span>);</code></pre></div><p>C++将这些函数称为可替换的（replaceable）。这意味着如果您有足够的知识和意愿，可为new和delete提供替换函数，并根据需要对其进行定制。例如，可定义作用域为类的替换函数，并对其进行定制，以满足该类的内存分配需求。在代码中，仍将使用new运算符，但它将调用您定义的new()函数。 </p><h4 id="定位new运算符"><a href="#定位new运算符" class="headerlink" title="定位new运算符"></a>定位new运算符</h4><p>通常，new负责在堆（heap）中找到一个足以能够满足要求的内存块。new运算符还有另一种变体，被称为定位（placement）new运算 符，它让您能够指定要使用的位置。程序员可能使用这种特性来设置其内存管理规程、处理需要通过特定地址进行访问的硬件或在特定位置创建对象。</p><p>要使用定位new特性，首先需要包含头文件new，它提供了这种版本的new运算符的原型；然后将new运算符用于提供了所需地址的参数。除需要指定参数外，句法与常规new运算符相同。具体地说，使用定位new运算符时，变量后面可以有方括号，也可以没有。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// newplace.cpp -- using placement new</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for placement new</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF = <span class="hljs-number">512</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;<span class="hljs-type">char</span> buffer[BUF];      <span class="hljs-comment">// chunk of memory</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> *pd1, *pd2;    <span class="hljs-type">int</span> i;    cout &lt;&lt; <span class="hljs-string">&quot;Calling new and placement new:\n&quot;</span>;    pd1 = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[N];           <span class="hljs-comment">// use heap</span>    pd2 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-type">double</span>[N];  <span class="hljs-comment">// use buffer array</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)        pd2[i] = pd1[i] = <span class="hljs-number">1000</span> + <span class="hljs-number">20.0</span> * i;    cout &lt;&lt; <span class="hljs-string">&quot;Memory addresses:\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;  heap: &quot;</span> &lt;&lt; pd1         &lt;&lt; <span class="hljs-string">&quot;  static: &quot;</span> &lt;&lt;  (<span class="hljs-type">void</span> *) buffer  &lt;&lt;endl;    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)    &#123;        cout &lt;&lt; pd1[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd1[i] &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>;        cout &lt;&lt; pd2[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd2[i] &lt;&lt; endl;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;\nCalling new and placement new a second time:\n&quot;</span>;    <span class="hljs-type">double</span> *pd3, *pd4;    pd3= <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[N];            <span class="hljs-comment">// find new address</span>    pd4 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-type">double</span>[N];  <span class="hljs-comment">// overwrite old data</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)        pd4[i] = pd3[i] = <span class="hljs-number">1000</span> + <span class="hljs-number">40.0</span> * i;    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)    &#123;        cout &lt;&lt; pd3[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd3[i] &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>;        cout &lt;&lt; pd4[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd4[i] &lt;&lt; endl;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;\nCalling new and placement new a third time:\n&quot;</span>;    <span class="hljs-keyword">delete</span> [] pd1;    pd1= <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[N];    pd2 = <span class="hljs-built_in">new</span> (buffer + N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)) <span class="hljs-type">double</span>[N];    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)        pd2[i] = pd1[i] = <span class="hljs-number">1000</span> + <span class="hljs-number">60.0</span> * i;    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)    &#123;        cout &lt;&lt; pd1[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd1[i] &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>;        cout &lt;&lt; pd2[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd2[i] &lt;&lt; endl;    &#125;    <span class="hljs-keyword">delete</span> [] pd1;    <span class="hljs-keyword">delete</span> [] pd3;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Calling new and placement new:</span><span class="hljs-comment">//Memory addresses:</span><span class="hljs-comment">//heap: 0x6000032d8210  static: 0x100074000</span><span class="hljs-comment">//Memory contents:</span><span class="hljs-comment">//1000 at 0x6000032d8210; 1000 at 0x100074000</span><span class="hljs-comment">//1020 at 0x6000032d8218; 1020 at 0x100074008</span><span class="hljs-comment">//1040 at 0x6000032d8220; 1040 at 0x100074010</span><span class="hljs-comment">//1060 at 0x6000032d8228; 1060 at 0x100074018</span><span class="hljs-comment">//1080 at 0x6000032d8230; 1080 at 0x100074020</span><span class="hljs-comment">//</span><span class="hljs-comment">//Calling new and placement new a second time:</span><span class="hljs-comment">//Memory contents:</span><span class="hljs-comment">//1000 at 0x6000032d8270; 1000 at 0x100074000</span><span class="hljs-comment">//1040 at 0x6000032d8278; 1040 at 0x100074008</span><span class="hljs-comment">//1080 at 0x6000032d8280; 1080 at 0x100074010</span><span class="hljs-comment">//1120 at 0x6000032d8288; 1120 at 0x100074018</span><span class="hljs-comment">//1160 at 0x6000032d8290; 1160 at 0x100074020</span><span class="hljs-comment">//</span><span class="hljs-comment">//Calling new and placement new a third time:</span><span class="hljs-comment">//Memory contents:</span><span class="hljs-comment">//1000 at 0x6000032d8210; 1000 at 0x100074028</span><span class="hljs-comment">//1060 at 0x6000032d8218; 1060 at 0x100074030</span><span class="hljs-comment">//1120 at 0x6000032d8220; 1120 at 0x100074038</span><span class="hljs-comment">//1180 at 0x6000032d8228; 1180 at 0x100074040</span><span class="hljs-comment">//1240 at 0x6000032d8230; 1240 at 0x100074048</span></code></pre></div><h4 id="定位new的其他形式"><a href="#定位new的其他形式" class="headerlink" title="定位new的其他形式"></a>定位new的其他形式</h4><p>就像常规new调用一个接收一个参数的new()函数一样，标准定位new调用一个接收两个参数的new()函数： </p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> * pi = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>;  //invokes <span class="hljs-built_in">new</span>(sizeof(<span class="hljs-type">int</span>))<span class="hljs-type">int</span> * p2 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-type">int</span>; // invokes <span class="hljs-built_in">new</span>(sizeof(<span class="hljs-type">int</span>),buffer)<span class="hljs-type">int</span> * p3 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-type">int</span>[<span class="hljs-number">40</span>];//invokes <span class="hljs-built_in">new</span>(<span class="hljs-number">40</span>*sizeof(<span class="hljs-type">int</span>),buffer)</code></pre></div><p>定位new函数不可替换，但可重载。它至少需要接收两个参数，其中第一个总是std::size_t，指定了请求的字节数。这样的重载函数都被称为定义new，即使额外的参数没有指定位置。 </p><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>在C++中，名称可以是变量、函数、结构、枚举、类以及类和结构的成员。当随着项目的增大，名称相互冲突的可能性也将增加。使用多 个厂商的类库时，可能导致名称冲突。例如，两个库可能都定义了名为List、Tree和Node的类，但定义的方式不兼容。用户可能希望使用一个库的List类，而使用另一个库的Tree类。这种冲突被称为名称空间问题。</p><p>C++标准提供了名称空间工具，以便更好地控制名称的作用域。经过了一段时间后，编译器才支持名称空间，但现在这种支持很普遍。 </p><h3 id="传统的-C-名称空间"><a href="#传统的-C-名称空间" class="headerlink" title="传统的**C++**名称空间"></a>传统的**C++**名称空间</h3><p>声明区域是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明所在的代码块。 </p><p>第二个需要知道的术语是潜在作用域（potential scope）。变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。然而，变量并非在其潜在作用域内的任何位置都是可见的。例如，它可能被另一个在嵌套声明区域中声明的同名变量隐藏。例如，在函数中声明的局部变量（对于这种变量，声明区域为整个函数）将隐藏在同一个文件中声明的全局变量（对于这种变量，声明区域为整个文件）。 变量对程序而言可见的范围被称为作用域（scope），前面正是以这种方式使用该术语的。</p><p>C++关于全局变量和局部变量的规则定义了一种名称空间层次。每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的 名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部 变量发生冲突。</p><h3 id="新的名称空间特性"><a href="#新的名称空间特性" class="headerlink" title="新的名称空间特性"></a>新的名称空间特性</h3><p>C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名 称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Jack</span> &#123;<span class="hljs-built_in">double</span> pail;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fetch</span>()</span>;<span class="hljs-built_in">int</span> pal;<span class="hljs-keyword">struct</span> Well&#123;&#125;&#125;<span class="hljs-keyword">namespace</span> <span class="hljs-title">Jill</span>&#123;<span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">bucket</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> n</span>)</span> &#123;&#125;;<span class="hljs-built_in">double</span> fetch;<span class="hljs-built_in">int</span> pal;<span class="hljs-keyword">struct</span> Hill&#123;&#125;&#125;</code></pre></div><p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性 为外部的（除非它引用了常量）。 </p><p>除了用户定义的名称空间外，还存在另一个名称空间——全局名称空间（global namespace）。它对应于文件级声明区域，因此前面所说的全局变量现在被描述为位于全局名称空间中。</p><p>任何名称空间中的名称都不会与其他名称空间中的名称发生冲突。 因此，Jack中的fetch可以与Jill中的fetch共存，Jill中的Hill可以与外部 Hill共存。名称空间中的声明和定义规则同全局声明和定义规则相同。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> Jill &#123;<span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">goose</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span></span>;&#125;</code></pre></div><p>同样，原来的Jack名称空间为fetch( )函数提供了原型。可以在该文件后面（或另外一个文件中）再次使用Jack名称空间来提供该函数的代 码：</p><div class="code-wrapper"><pre><code class="hljs csharp">namespece Jack &#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fetch</span>()</span>&#123;...&#125;&#125;</code></pre></div><p>当然，需要有一种方法来访问给定名称空间中的名称。最简单的方法是，通过作用域解析运算符::，使用名称空间来限定该名称： </p><div class="code-wrapper"><pre><code class="hljs css">Jack::pail = <span class="hljs-number">12.34</span>;Jill::Hill mole;Jack::<span class="hljs-built_in">fetch</span>();</code></pre></div><p>未被装饰的名称（如pail）称为未限定的名称（unqualified name）；包含名称空间的名称（如Jack::pail）称为限定的名称（qualified name）。 </p><h4 id="using声明和using编译指令"><a href="#using声明和using编译指令" class="headerlink" title="using声明和using编译指令"></a>using声明和using编译指令</h4><p>我们并不希望每次使用名称时都对它进行限定，因此C++提供了两种机制（using声明和using编译指令）来简化对名称空间中名称的使 用。using声明使特定的标识符可用，using编译指令使整个名称空间可用。</p><p>using声明由被限定的名称和它前面的关键字using组成：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> Jill::fetch;</code></pre></div><p>using声明将特定的名称添加到它所属的声明区域中。例如main( )中的using声明Jill::fetch将fetch添加到main( )定义的声明区域中。完成该声明后，便可以使用名称fetch代替Jill::fetch。</p><h4 id="using编译指令和using声明之比较"><a href="#using编译指令和using声明之比较" class="headerlink" title="using编译指令和using声明之比较"></a>using编译指令和using声明之比较</h4><p>使用using编译指令导入一个名称空间中所有的名称与使用多个using声明是不一样的，而更像是大量使用作用域解析运算符。使用 using声明时，就好像声明了相应的名称一样。如果某个名称已经在函数 中声明了，则不能用using声明导入相同的名称。然而，使用using编译指令时，将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样。如果使用using编译指令导入一个已经在函数中声明的名称，则局部名称将隐藏名称空间名，就像隐藏同名的全局变量一样。</p><p>需要指出的另一点是，虽然函数中的using编译指令将名称空间的名称视为在函数之外声明的，但它不会使得该文件中的其他函数能够使用这些名称</p><p>一般说来，使用using声明比使用using编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出 指示。using编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 </p><h4 id="名称空间的其他特性"><a href="#名称空间的其他特性" class="headerlink" title="名称空间的其他特性"></a>名称空间的其他特性</h4><p>可以将名称空间声明进行嵌套：</p><div class="code-wrapper"><pre><code class="hljs angelscript">namespact elements &#123;<span class="hljs-keyword">namespace</span> <span class="hljs-symbol">file</span> &#123;<span class="hljs-built_in">int</span> flame;&#125;<span class="hljs-built_in">float</span> water;&#125;</code></pre></div><p>这里，flame指的是element::fire::flame。同样，可以使用下面的 using编译指令使内部的名称可用： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> elements::fire;</code></pre></div><p>另外，也可以在名称空间中使用using编译指令和using声明，如下所示：</p><div class="code-wrapper"><pre><code class="hljs powershell">namespece myth&#123;<span class="hljs-keyword">using</span> Jill::fetch;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> element;<span class="hljs-keyword">using</span> std::cout;<span class="hljs-keyword">using</span> std::cin;&#125;</code></pre></div><p>假设要访问Jill::fetch。由于Jill::fetch现在位于名称空间myth（在这里，它被叫做fetch）中，因此可以这样访问它：</p><div class="code-wrapper"><pre><code class="hljs cpp">std::cin &gt;&gt; myth::fetch;</code></pre></div><p>当然，由于它也位于Jill名称空间中，因此仍然可以称作Jill::fetch： </p><div class="code-wrapper"><pre><code class="hljs cpp">Jill::fetch;std::cout&lt;&lt;Jill::fetch;</code></pre></div><p>如果没有与之冲突的局部变量，则也可以这样做： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> myth;cin &gt;&gt; fetch;<span class="hljs-comment">//really std::cin and Jill::fetch</span></code></pre></div><p>现在考虑将using编译指令用于myth名称空间的情况。using编译指令是可传递的。如果A op B且B op C，则A op C，则说操作op是可传递的。例如，&gt;运算符是可传递的（也就是说，如果A&gt;B且B&gt;C，则A&gt;C）。在这个情况下，下面的语句将导入名称空间myth和elements：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> myth;</code></pre></div><p>这条编译指令与下面两条编译指令等价： </p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> myth;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> elements;</code></pre></div><p>可以给名称空间创建别名。例如，假设有下面的名称空间</p><div class="code-wrapper"><pre><code class="hljs abnf">namespace mvft <span class="hljs-operator">=</span> my_every_favorite_things<span class="hljs-comment">;</span></code></pre></div><p>可以使用这种技术来简化对嵌套名称空间的使用：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> MEF = myth::elements::fires;<span class="hljs-keyword">using</span> MEF::flame</code></pre></div><h4 id="未命名的名称空间"><a href="#未命名的名称空间" class="headerlink" title="未命名的名称空间"></a>未命名的名称空间</h4><p>可以通过省略名称空间的名称来创建未命名的名称空间：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">namespace</span> &#123;<span class="hljs-built_in">int</span> ice;<span class="hljs-built_in">int</span> bandycoot;&#125;</code></pre></div><p>这就像后面跟着using编译指令一样，也就是说，在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾。从这个方面 看，它们与全局变量相似。然而，由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明来使它在其他位置都可用。具体地说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">int</span> counts;&lt;=&gt;<span class="hljs-keyword">namespace</span> &#123;<span class="hljs-type">int</span> counts&#125;</code></pre></div><h3 id="名称空间示例"><a href="#名称空间示例" class="headerlink" title="名称空间示例"></a>名称空间示例</h3><p>现在来看一个多文件示例，该示例说明了名称空间的一些特性。该程序的第一个文件（参见程序清单9.11）是头文件，其中包含头文件中 常包含的内容：常量、结构定义和函数原型。在这个例子中，这些内容被放在两个名称空间中。第一个名称空间叫做pers，其中包含Person结构的定义和两个函数的原型——一个函数用人名填充结构，另一个函数显示结构的内容；第二个名称空间叫做debts，它定义了一个结构，该结构用来存储人名和金额。该结构使用了Person结构，因此，debts名称空间使用一条using编译指令，让pers中的名称在debts名称空间可用。debts名称空间也包含一些原型。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// namesp.h</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-comment">// create the pers and debts namespaces</span><span class="hljs-keyword">namespace</span> pers&#123;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>    &#123;         std::string fname;        std::string lname;     &#125;;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPerson</span><span class="hljs-params">(Person &amp;)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;)</span></span>;&#125;<span class="hljs-keyword">namespace</span> debts&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> pers;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Debt</span>    &#123;        Person name;        <span class="hljs-type">double</span> amount;    &#125;;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDebt</span><span class="hljs-params">(Debt &amp;)</span></span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showDebt</span><span class="hljs-params">(<span class="hljs-type">const</span> Debt &amp;)</span></span>;    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sumDebts</span><span class="hljs-params">(<span class="hljs-type">const</span> Debt ar[], <span class="hljs-type">int</span> n)</span></span>; &#125;</code></pre></div><p>第二个文件（见程序清单9.12）是源代码文件，它提供了头文件中的函数原型对应的定义。在名称空间中声明的函数名的作用域为整个名 称空间，因此定义和声明必须位于同一个名称空间中。这正是名称空间的开放性发挥作用的地方。通过包含namesp.h（参见程序清单9.11）导入了原来的名称空间。然后该文件将函数定义添加入到两个名称空间中，如程序清单9.12所示。另外，文件names.cpp演示了如何使用using声明和作用域解析运算符来使名称空间std中的元素可用。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// namesp.cpp -- namespaces</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namesp.h&quot;</span></span><span class="hljs-keyword">namespace</span> pers&#123;    <span class="hljs-keyword">using</span> std::cout;    <span class="hljs-keyword">using</span> std::cin;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPerson</span><span class="hljs-params">(Person &amp; rp)</span></span><span class="hljs-function">    </span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Enter first name: &quot;</span>;        cin &gt;&gt; rp.fname;        cout &lt;&lt; <span class="hljs-string">&quot;Enter last name: &quot;</span>;        cin &gt;&gt; rp.lname;    &#125;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp; rp)</span></span><span class="hljs-function">    </span>&#123;        std::cout &lt;&lt; rp.lname &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; rp.fname;    &#125;&#125;<span class="hljs-keyword">namespace</span> debts&#123;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDebt</span><span class="hljs-params">(Debt &amp; rd)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">getPerson</span>(rd.name);        std::cout &lt;&lt; <span class="hljs-string">&quot;Enter debt: &quot;</span>;        std::cin &gt;&gt; rd.amount;    &#125;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showDebt</span><span class="hljs-params">(<span class="hljs-type">const</span> Debt &amp; rd)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">showPerson</span>(rd.name);        std::cout &lt;&lt;<span class="hljs-string">&quot;: $&quot;</span> &lt;&lt; rd.amount &lt;&lt; std::endl;    &#125;        <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sumDebts</span><span class="hljs-params">(<span class="hljs-type">const</span> Debt ar[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-type">double</span> total = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)            total += ar[i].amount;        <span class="hljs-keyword">return</span> total;    &#125;&#125;</code></pre></div><p>最后，该程序的第三个文件（参见程序清单9.13）是一个源代码文件，它使用了名称空间中声明和定义的结构和函数。程序清单9.13演示 了多种使名称空间标识符可用的方法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// usenmsp.cpp -- using namespaces</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namesp.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">another</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> debts::Debt;<span class="hljs-keyword">using</span> debts::showDebt;    Debt golf = &#123; &#123;<span class="hljs-string">&quot;Benny&quot;</span>, <span class="hljs-string">&quot;Goatsniff&quot;</span>&#125;, <span class="hljs-number">120.0</span> &#125;;    <span class="hljs-built_in">showDebt</span>(golf);    <span class="hljs-built_in">other</span>();    <span class="hljs-built_in">another</span>(); <span class="hljs-comment">// std::cin.get();</span><span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> std::cout;    <span class="hljs-keyword">using</span> std::endl;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> debts;    Person dg = &#123;<span class="hljs-string">&quot;Doodles&quot;</span>, <span class="hljs-string">&quot;Glister&quot;</span>&#125;;    <span class="hljs-built_in">showPerson</span>(dg);    cout &lt;&lt; endl;    Debt zippy[<span class="hljs-number">3</span>];    <span class="hljs-type">int</span> i;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)        <span class="hljs-built_in">getDebt</span>(zippy[i]);    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)        <span class="hljs-built_in">showDebt</span>(zippy[i]);    cout &lt;&lt; <span class="hljs-string">&quot;Total debt: $&quot;</span> &lt;&lt; <span class="hljs-built_in">sumDebts</span>(zippy, <span class="hljs-number">3</span>) &lt;&lt; endl;        <span class="hljs-keyword">return</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">another</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> pers::Person;;        Person collector = &#123; <span class="hljs-string">&quot;Milo&quot;</span>, <span class="hljs-string">&quot;Rightshift&quot;</span> &#125;;    pers::<span class="hljs-built_in">showPerson</span>(collector);    std::cout &lt;&lt; std::endl; &#125;</code></pre></div><h3 id="名称空间及其前途"><a href="#名称空间及其前途" class="headerlink" title="名称空间及其前途"></a>名称空间及其前途</h3><p>下面是当前的一些指导原则。 </p><ul><li><p>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</p></li><li><p>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</p></li><li><p>如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间std中，这种做法扩展 到了来自C语言中的函数。例如，头文件math.h是与C语言兼容的，没有使用名称空间，但C++头文件cmath应将各种数学库函数放在名称空间std中。实际上，并非所有的编译器都完成了这种过渡。 </p></li><li><p>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。</p></li><li><p>不要在头文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非 要使用编译指令using，应将其放在所有预处理器编译指令#include之后。 </p></li><li><p>导入名称时，首选使用作用域解析运算符或using声明的方法。对于using声明，首选将其作用域设置为局部而不是全局。</p></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>C++鼓励程序员在开发程序时使用多个文件。一种有效的组织策略是，使用头文件来定义用户类型，为操纵用户类型的函数提供函数原 型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。最后，将main( )和其他使用这些函数的函数放在第三个文件中。 </p><p>C++的存储方案决定了变量保留在内存中的时间（储存持续性）以及程序的哪一部分可以访问它（作用域和链接性）。自动变量是在代码 块（如函数体或函数体中的代码块）中定义的变量，仅当程序执行到包含定义的代码块时，它们才存在，并且可见。自动变量可以通过使用存储类型说明符register或根本不使用说明符来声明，没有使用说明符时，变量将默认为自动的。register说明符提示编译器，该变量的使用频率很高，但C++11摒弃了这种用法。 </p><p>静态变量在整个程序执行期间都存在。对于在函数外面定义的变量，其所属文件中位于该变量的定义后面的所有函数都可以使用它（文 件作用域），并可在程序的其他文件中使用（外部链接性）。另一个文件要使用这种变量，必须使用extern关键字来声明它。对于文件间共享的变量，应在一个文件中包含其定义声明（无需使用extern，但如果同时进行初始化，也可使用它），并在其他文件中包含引用声明（使用extern且不初始化）。在函数的外面使用关键字static定义的变量的作用域为整个文件，但是不能用于其他文件（内部链接性）。在代码块中使用关键字static定义的变量被限制在该代码块内（局部作用域、无链接性），但在整个程序执行期间，它都一直存在并且保持原值。 </p><p>在默认情况下，C++函数的链接性为外部，因此可在文件间共享；但使用关键字static限定的函数的链接性为内部的，被限制在定义它的文 件中</p><p>动态内存分配和释放是使用new和delete进行的，它使用自由存储区或堆来存储数据。调用new占用内存，而调用delete释放内存。程序使用指针来跟踪这些内存单元。</p><p>名称空间允许定义一个可在其中声明标识符的命名区域。这样做的目的是减少名称冲突，尤其当程序非常大，并使用多个厂商的代码时。 可以通过使用作用域解析运算符、using声明或using编译指令，来使名称空间中的标识符可用。</p><h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><p>面向对象编程（OOP）是一种特殊的、设计程序的概念性方法，C++通过一些特性改进了C语言，使得应用这种方法更容易。下面是最 重要的OOP特性： </p><ul><li>抽象； </li><li>封装和数据隐藏； </li><li>多态； </li><li>继承； </li><li>代码的可重用性。</li></ul><h2 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h2>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Typescript</title>
    <link href="/2023/02/26/Effective-Typescript/"/>
    <url>/2023/02/26/Effective-Typescript/</url>
    
    <content type="html"><![CDATA[<h1 id="了解Typescript"><a href="#了解Typescript" class="headerlink" title="了解Typescript"></a>了解Typescript</h1><h2 id="理解Typescript与Javascript的关系"><a href="#理解Typescript与Javascript的关系" class="headerlink" title="理解Typescript与Javascript的关系"></a>理解Typescript与Javascript的关系</h2><h2 id="知道你在使用那个Typescript选项"><a href="#知道你在使用那个Typescript选项" class="headerlink" title="知道你在使用那个Typescript选项"></a>知道你在使用那个Typescript选项</h2><h2 id="理解代码的生成是独立于类型的"><a href="#理解代码的生成是独立于类型的" class="headerlink" title="理解代码的生成是独立于类型的"></a>理解代码的生成是独立于类型的</h2><h2 id="习惯结构类型"><a href="#习惯结构类型" class="headerlink" title="习惯结构类型"></a>习惯结构类型</h2><h2 id="限制使用any类型"><a href="#限制使用any类型" class="headerlink" title="限制使用any类型"></a>限制使用any类型</h2><h1 id="Typescript的类型系统"><a href="#Typescript的类型系统" class="headerlink" title="Typescript的类型系统"></a>Typescript的类型系统</h1><h2 id="使用你的编辑器来询问和探索类型系统"><a href="#使用你的编辑器来询问和探索类型系统" class="headerlink" title="使用你的编辑器来询问和探索类型系统"></a>使用你的编辑器来询问和探索类型系统</h2><h2 id="要将类型视为价值的集合"><a href="#要将类型视为价值的集合" class="headerlink" title="要将类型视为价值的集合"></a>要将类型视为价值的集合</h2><h2 id="知道如何分辨符号是类型空间还是值空间"><a href="#知道如何分辨符号是类型空间还是值空间" class="headerlink" title="知道如何分辨符号是类型空间还是值空间"></a>知道如何分辨符号是类型空间还是值空间</h2><h2 id="优先选择类型声明而不是类型断言"><a href="#优先选择类型声明而不是类型断言" class="headerlink" title="优先选择类型声明而不是类型断言"></a>优先选择类型声明而不是类型断言</h2><h2 id="避免对象包装类-String-Number-Boolean-Symbol-BigInt"><a href="#避免对象包装类-String-Number-Boolean-Symbol-BigInt" class="headerlink" title="避免对象包装类(String,Number,Boolean,Symbol,BigInt)"></a>避免对象包装类(String,Number,Boolean,Symbol,BigInt)</h2><h2 id="认识额外属性检查的局限性"><a href="#认识额外属性检查的局限性" class="headerlink" title="认识额外属性检查的局限性"></a>认识额外属性检查的局限性</h2><h1 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h1><h1 id="类型设计"><a href="#类型设计" class="headerlink" title="类型设计"></a>类型设计</h1><h1 id="和Any一起工作"><a href="#和Any一起工作" class="headerlink" title="和Any一起工作"></a>和Any一起工作</h1><h1 id="类型声明和-types"><a href="#类型声明和-types" class="headerlink" title="类型声明和@types"></a>类型声明和@types</h1><h1 id="编写和运行你的代码"><a href="#编写和运行你的代码" class="headerlink" title="编写和运行你的代码"></a>编写和运行你的代码</h1><h1 id="迁移到Typescript"><a href="#迁移到Typescript" class="headerlink" title="迁移到Typescript"></a>迁移到Typescript</h1>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法导论</title>
    <link href="/2023/02/05/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    <url>/2023/02/05/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript函数式编程</title>
    <link href="/2023/02/05/javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/02/05/javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出mysql</title>
    <link href="/2023/02/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAmysql/"/>
    <url>/2023/02/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAmysql/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十五章 算法复杂度</title>
    <link href="/2023/02/04/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2023/02/04/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 <em>O</em> 表示法</h1><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2017.41.26.png"></p><h2 id="理解大-O-表示法"><a href="#理解大-O-表示法" class="headerlink" title="理解大 O 表示法"></a>理解大 <em>O</em> 表示法</h2><p>如何衡量算法的效率？通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 <em>O</em> 表示法时，一般考虑的是 CPU（时间）占用</p><p>让我们试着用一些例子来理解大 <em>O</em> 表示法的规则。</p><p> <em>O</em>(1) </p><p>考虑以下函数。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">num</span>)&#123;  <span class="hljs-keyword">return</span> ++num; &#125;</code></pre></div><p>假设运行 increment(1)函数，执行时间等于 <em>X</em>。如果再用不同的参数（例如 2）运行一次increment 函数，执行时间依然是 <em>X</em>。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 <em>O</em>(1)（常数）。</p><p> <em>O</em>(<em>n</em>) </p><p>现在以第 13 章中实现的顺序搜索算法为例</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sequentialSearch</span>(<span class="hljs-params">array, value, equalsFn = defaultEquals</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">equalsFn</span>(value, array[i])) &#123; <span class="hljs-comment">// &#123;1&#125; </span> <span class="hljs-keyword">return</span> i;  &#125;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; &#125;</code></pre></div><p>如果将含 10 个元素的数组（[1, …, 10]）传递给该函数，假如搜索 1 这个元素，那么，第一次判断时就能找到想要搜索的元素。在这里我们假设每执行一次行{1}，开销是 1</p><p>现在，假如要搜索元素 11。行{1}会执行 10 次（迭代数组中所有的值，并且找不到要搜索的元素，因而结果返回-1）。如果行{1}的开销是 1，那么它执行 10 次的开销就是 10，10 倍于第一种假设。</p><p>现在，假如该数组有 1000 个元素（[1, …, 1000]）。搜索 1001 的结果是行{1}执行了1000 次（然后返回-1）。</p><p>注意，sequentialSearch 函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，行{1}会执行几次呢？如果查找的是数组中不存在的值，那么行{1}就会执行和数组大小一样多次，这就是通常所说的最坏情况。</p><p>最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 <em>O</em>(<em>n</em>)，<em>n</em> 是（输入）数组的大小</p><p>回到之前的例子，修改一下算法的实现（最坏情况），使之计算开销</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sequentialSearch</span>(<span class="hljs-params">array, value, equalsFn = defaultEquals</span>) &#123;  <span class="hljs-keyword">let</span> cost = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;  cost++;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">equalsFn</span>(value, array[i])) &#123;  <span class="hljs-keyword">return</span> i;  &#125;  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`cost for sequentialSearch with input size <span class="hljs-subst">$&#123;array.length&#125;</span> is <span class="hljs-subst">$&#123;cost&#125;</span>`</span>);  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; &#125;</code></pre></div><p>用不同大小的输入数组执行以上算法，可以看到不同的输出。</p><p> <em>O</em>(<em>n</em>2 ) </p><p>用冒泡排序做 <em>O</em>(<em>n</em>2)的例子。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">array, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123; <span class="hljs-comment">// &#123;1&#125; </span> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">// &#123;2&#125; </span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(array[j], array[j + <span class="hljs-number">1</span>]) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;  <span class="hljs-title function_">swap</span>(array, j, j + <span class="hljs-number">1</span>);  &#125;  &#125;  &#125;  <span class="hljs-keyword">return</span> array; &#125;</code></pre></div><p>假设行{1}和行{2}的开销分别是 1。修改算法的实现使之计算开销</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">array, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">let</span> cost = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123; <span class="hljs-comment">// &#123;1&#125; </span> cost++;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">// &#123;2&#125; </span> cost++;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(array[j], array[j + <span class="hljs-number">1</span>]) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;  <span class="hljs-title function_">swap</span>(array, j, j + <span class="hljs-number">1</span>);  &#125;  &#125;  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`cost for bubbleSort with input size <span class="hljs-subst">$&#123;length&#125;</span> is <span class="hljs-subst">$&#123;cost&#125;</span>`</span>);  <span class="hljs-keyword">return</span> array; &#125;</code></pre></div><p>如果用大小为 10 的数组执行 bubbleSort，开销是 100（102）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（1002）。需要注意，我们每次增加输入的大小，执行都会越来越久</p><p>时间复杂度 <em>O</em>(<em>n</em>)的代码只有一层循环，而 <em>O</em>(<em>n</em>2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 <em>O</em>(<em>n</em>3)。</p><h2 id="时间复杂度比较"><a href="#时间复杂度比较" class="headerlink" title="时间复杂度比较"></a>时间复杂度比较</h2><p>我们可以创建一个表格来表示不同的时间复杂度    </p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2018.06.17.png"></p><p>我们可以基于上表信息画一个图来表示不同的大 <em>O</em> 表示法的消耗。</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2018.07.33.png"></p><p>下表是常用数据结构的时间复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2018.08.43.png"></p><p>下表是图的时间复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2018.09.37.png"></p><p>下表是排序算法的时间复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2018.10.28.png"></p><p>下表是搜索算法的时间复杂度</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2018.11.21.png"></p><h2 id="NP-完全理论概述"><a href="#NP-完全理论概述" class="headerlink" title="NP 完全理论概述"></a>NP 完全理论概述</h2><p>一般来说，如果一个算法的复杂度为 <em>O</em>(<em>n**k</em>)，其中 <em>k</em> 是常数，我们就认为这个算法是高效的，这就是多项式算法。</p><p>对于给定的问题，如果存在多项式算法，则计为 <em>P</em>（polynomial，多项式）</p><p>还有一类 NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 <em>NP</em>。</p><p>如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 <em>P</em> 都是<em>NP</em>。然而，<em>P</em> = <em>NP</em> 是否成立，仍然不得而知。</p><p>NP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 <em>L</em> 是 NP 完全的：</p><p>(1) <em>L</em> 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；</p><p>(2) 所有的 NP 问题都能在多项式时间内归约为 <em>L</em>。</p><p>为了理解问题的归约，考虑两个决策问题 <em>L</em>和 <em>M</em>。假设算法 <em>A</em>可以解决问题 <em>L</em>，算法 <em>B</em>可以验证输入 <em>y</em>是否为 <em>M</em>的解。目标是找到一个把 <em>L</em>转化为 <em>M</em>的方法，使得算法 <em>B</em>可以用于构造算法 <em>A</em></p><p>还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。</p><p><em>P</em> = <em>NP</em> 是否成立，是计算机科学中最重要的难题之一。如果能找到答案，对密码学、算法研究、人工智能等诸多领域都会产生重大影响。</p><p>下面是满足 <em>P</em>&lt;&gt;<em>NP</em> 时，P、NP、NP 完全和 NP 困难问题的欧拉图。</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-05%2001.20.53.png"></p><p>非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。</p><p>NP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。</p><p>关于这些问题，详情请查阅 <a href="https://en.wikipedia.org/wiki/NP-completeness">https://en.wikipedia.org/wiki/NP-completeness</a></p><h2 id="不可解问题与启发式算法"><a href="#不可解问题与启发式算法" class="headerlink" title="不可解问题与启发式算法"></a>不可解问题与启发式算法</h2><p>我们提到的有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了</p><p>启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。详情请查阅<a href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)">https://en.wikipedia.org/wiki/Heuristic_(computer_science)</a></p><p>启发式算法可以很巧妙地解决一些问题。你可以尝试把研究启发式算法作为学士或硕士学位的论文主题。</p><h1 id="用算法娱乐身心"><a href="#用算法娱乐身心" class="headerlink" title="用算法娱乐身心"></a>用算法娱乐身心</h1><p>UVa Online Judge（<a href="http://uva.onlinejudge.org/%EF%BC%89%EF%BC%9A%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8C%85%E5%90%AB%E4%BA%86%E4%B8%96%E7%95%8C%E5%90%84%E5%A4%A7%E8%B5%9B%E4%BA%8B%E7%9A%84%E9%A2%98%E7%9B%AE%EF%BC%8C%E5%8C%85%E6%8B%AC">http://uva.onlinejudge.org/）：这个网站包含了世界各大赛事的题目，包括</a> 由 IBM 赞助的 ACM 国际大学生程序竞赛（ICPC。若你依然在校，应尽量参与这项赛事，如果团队获胜，则有可能免费享受一次国际旅行）。这个网站包括了成百上千的题目，可以应用本书所学的算法。</p><p>Sphere Online Judge（<a href="http://www.spoj.com/%EF%BC%89%EF%BC%9A">http://www.spoj.com/）：</a> 这个网站和 UVa Online Judge 差不多，但支持用更多语言解题（包括 JavaScript）。</p><p>Coderbyte（<a href="http://coderbyte.com/%EF%BC%89%EF%BC%9A%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8C%85%E5%90%AB%E4%BA%86%E5%8F%AF%E4%BB%A5%E7%94%A8">http://coderbyte.com/）：这个网站包含了可以用</a> JavaScript 解答的题目（简单、中等难度和非常困难）。</p><p>Project Euler（<a href="https://projecteuler.net/%EF%BC%89%EF%BC%9A%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8C%85%E5%90%AB%E4%BA%86%E4%B8%80%E7%B3%BB%E5%88%97%E6%95%B0%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE%E3%80%82%E4%BD%A0%E6%89%80%E8%A6%81%E5%81%9A%E7%9A%84%E5%B0%B1%E6%98%AF%E8%BE%93%E5%85%A5%E9%82%A3%E4%BA%9B%E9%A2%98%E7%9B%AE%E7%9A%84%E7%AD%94%E6%A1%88%EF%BC%8C%E4%B8%8D%E8%BF%87%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%94%A8%E7%AE%97%E6%B3%95%E6%9D%A5%E6%89%BE%E5%88%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A7%A3%E7%AD%94%E3%80%82">https://projecteuler.net/）：这个网站包含了一系列数学/计算机的编程题目。你所要做的就是输入那些题目的答案，不过我们可以用算法来找到正确的解答。</a></p><p>HackerRank（<a href="https://www.hackerrank.com）：这个网站包含">https://www.hackerrank.com）：这个网站包含</a> 16 个类别的挑战（可以应用本书中的算法和更多其他算法）。它也支持 JavaScript 和其他语言。</p><p>CodeChef（<a href="http://www.codechef.com/%EF%BC%89%EF%BC%9A%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%8C%85%E5%90%AB%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%EF%BC%8C%E5%B9%B6%E4%BC%9A%E4%B8%BE%E5%8A%9E%E5%9C%A8%E7%BA%BF%E6%AF%94%E8%B5%9B%E3%80%82">http://www.codechef.com/）：这个网站包含一些题目，并会举办在线比赛。</a></p><p>Top Coder（<a href="http://www.topcoder.com/%EF%BC%89%EF%BC%9A%E6%AD%A4%E7%BD%91%E7%AB%99%E4%BC%9A%E4%B8%BE%E5%8A%9E%E7%AE%97%E6%B3%95%E8%81%94%E8%B5%9B%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%81%94%E8%B5%9B%E9%80%9A%E5%B8%B8%E7%94%B1">http://www.topcoder.com/）：此网站会举办算法联赛，这些联赛通常由</a> NASA、Google、Yahoo!、Amazon 和 Facebook 这样的公司赞助。参加其中一些赛事，你可以获得到赞助公司工作的机会，而参与另一些赛事会赢得奖金。这个网站也提供很棒的解题和算法教程。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript（下卷）</title>
    <link href="/2023/02/02/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89/"/>
    <url>/2023/02/02/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript（中卷）</title>
    <link href="/2023/01/19/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89/"/>
    <url>/2023/01/19/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>• 空值（null）</p><p>• 未定义（undefined）</p><p>• 布尔值（ boolean）</p><p>• 数字（number）</p><p>• 字符串（string）</p><p>• 对象（object）</p><p>• 符号（symbol，ES6 中新增）</p><p>• bigInt</p><p>我们可以用 typeof 运算符来查看值的类型，它返回的是类型的字符串值。有意思的是，这几种类型和它们的字符串值并不一一对应：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">typeof</span> undefined === <span class="hljs-string">&quot;undefined&quot;</span>; <span class="hljs-comment">// true</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> === <span class="hljs-string">&quot;boolean&quot;</span>; <span class="hljs-comment">// true</span><span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span> === <span class="hljs-string">&quot;number&quot;</span>; <span class="hljs-comment">// true</span><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;42&quot;</span> === <span class="hljs-string">&quot;string&quot;</span>; <span class="hljs-comment">// true</span><span class="hljs-keyword">typeof</span> &#123; life: <span class="hljs-number">42</span> &#125; === <span class="hljs-string">&quot;object&quot;</span>; <span class="hljs-comment">// true</span><span class="hljs-comment">// ES6中新加入的类型</span><span class="hljs-function"><span class="hljs-keyword">typeof</span> <span class="hljs-title">Symbol</span>()</span> === <span class="hljs-string">&quot;symbol&quot;</span>; <span class="hljs-comment">// true</span></code></pre></div><p>null的类型判断不同</p><div class="code-wrapper"><pre><code class="hljs abnf">typeof null <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-comment">; // true</span></code></pre></div><p>我们需要使用复合条件来检测 null 值的类型：</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;(!a &amp;&amp; <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&quot;object&quot;</span>); <span class="hljs-comment">// true</span></code></pre></div><p>null 是基本类型中唯一的一个“假值”（falsy 或者 false-like）类型，typeof对它的返回值为 “object</p><p>还有一种情况：</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">/* .. */</span> &#125; === <span class="hljs-string">&quot;function&quot;</span>; <span class="hljs-comment">// true</span></code></pre></div><p>这样看来，function（函数）也是 JavaScript 的一个内置类型。然而查阅规范就会知道，它实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属性 [[Call]]，该属性使其可以被调用。</p><p>函数不仅是对象，还可以拥有属性。例如：</p><p>function a(b,c) {</p><p> /* .. */</p><p>}</p><p>函数对象的 length 属性是其声明的参数的个数：a.length; // 2 因为该函数声明了两个命名参数，b 和 c，所以其 length 值为 2再来看看数组。JavaScript 支持数组，那么它是否也是一个特殊类型？typeof [1,2,3] === “object”; // true不，数组也是对象。确切地说，它也是 object 的一个“子类型”，数组的元素按数字顺序来进行索引（而非普通像对象那样通过字符串键值），其 length 属性是元素的个数。</p><h2 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h2><p>JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值</p><p>换个角度来理解就是，JavaScript 不做“类型强制”；也就是说，语言引擎不要求变量总是持有与其初始值同类型的值。一个变量可以现在被赋值为字符串类型值，随后又被赋值为数字类型值。</p><p>42 的类型为 number，并且无法更改。而 “42” 的类型为 string。数字 42 可以通过强制类型转换（coercion）为字符串 “42”</p><p>在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为 JavaScript 中的变量没有类型。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;number&quot;</span>a = <span class="hljs-literal">true</span>;<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;boolean</span></code></pre></div><p>typeof 运算符总是会返回一个字符串：</p><h3 id="undefined-和-undeclared"><a href="#undefined-和-undeclared" class="headerlink" title="undefined 和 undeclared"></a>undefined 和 undeclared</h3><p>变量在未持有值的时候为 undefined。此时 typeof 返回 “undefined”</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;undefined&quot;</span><span class="hljs-keyword">var</span> b = <span class="hljs-number">42</span>;<span class="hljs-keyword">var</span> c;<span class="hljs-comment">// later</span>b = c;<span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &quot;undefined&quot;</span><span class="hljs-keyword">typeof</span> c; <span class="hljs-comment">// &quot;undefined&quot;</span></code></pre></div><p>js中undefined和undeclared是不相等的</p><p>已在作用域中声明但还没有赋值的变量，是 undefifined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</p><p>typeof不区分undefined 和 undeclared</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript 有 七 种 内 置 类 型：null、undefined、boolean、number、string、object 和symbol，可以使用 typeof 运算符来查看。</p><p>变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。</p><p>很多开发人员将 undefifined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。</p><p>undefined 是值的一种。undeclared 则表示变量还没有被声明过。</p><p>遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问 “undeclared” 变量时这样报错：ReferenceError: a is not defifined，并且 typeof 对 undefifined 和 undeclared 变量都返回”undefined”。</p><p>然而，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的办法。</p><h1 id="值"><a href="#值" class="headerlink" title="值"></a>值</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>和其他强类型语言不同，在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组就是通过这种方式来实现的）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, [<span class="hljs-number">3</span>] ];a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span>a[<span class="hljs-number">0</span>] === <span class="hljs-number">1</span>; <span class="hljs-comment">// true</span>a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">3</span>; <span class="hljs-comment">// true</span></code></pre></div><p>对数组声明后即可向其中加入值，不需要预先设定大小</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ ];a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 0</span>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;2&quot;</span>;a[<span class="hljs-number">2</span>] = [ <span class="hljs-number">3</span> ];a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span></code></pre></div><p>使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的 length 属性并不会发生变化</p><p>在创建“稀疏”数组（sparse array，即含有空白或空缺单元的数组）时要特别注意：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ ];a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 此处没有设置a[1]单元</span>a[<span class="hljs-number">2</span>] = [ <span class="hljs-number">3</span> ];a[<span class="hljs-number">1</span>]; <span class="hljs-comment">// undefined</span>a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span></code></pre></div><p>上面的代码可以正常运行，但其中的“空白单元”（empty slot）可能会导致出人意料的结果。a[1] 的值为 undefined，但这与将其显式赋值为 undefined（a[1] = undefined）还是有所区别</p><p>数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串键值和属性（但这些并不计算在数组长度内）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [];a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;a[<span class="hljs-string">&quot;foobar&quot;</span>] = <span class="hljs-number">2</span>;a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 1</span>a[<span class="hljs-string">&quot;foobar&quot;</span>]; <span class="hljs-comment">// 2</span>a.<span class="hljs-property">foobar</span>; <span class="hljs-comment">// 2</span></code></pre></div><p>如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ ];a[<span class="hljs-string">&quot;13&quot;</span>] = <span class="hljs-number">42</span>;a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 14</span></code></pre></div><p>在数组中加入字符串键值 / 属性并不是一个好主意。建议使用对象来存放键值 / 属性值，用数组来存放数字索引值</p><h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>有时需要将类数组（一组通过数字索引的值）转换为真正的数组，这一般通过数组工具函数（如 indexOf(..)、concat(..)、forEach(..) 等）来实现例如，一些 DOM 查询操作会返回 DOM 元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过 arguments 对象（类数组）将函数的参数当作列表来访问（从ES6 开始已废止）。</p><p>工具函数 slice(..) 经常被用于这类转换：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);  arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;bam&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);&#125;<span class="hljs-title function_">foo</span>(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>); <span class="hljs-comment">// [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;]</span></code></pre></div><p>用 ES6 中的内置工具函数 Array.from(..) 也能实现同样的功能</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串经常被当成字符数组。字符串的内部实现究竟有没有使用数组并不好说，但JavaScript 中的字符串和字符数组并不是一回事，最多只是看上去相似而已。</p><div class="code-wrapper"><pre><code class="hljs awk">a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;O&quot;</span>;b[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;O&quot;</span>;a; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;foo&quot;</span>b; <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]</code></pre></div><p>JavaScript 中字符串是不可变的，而数组是可变的。并且 a[1] 在 JavaScript 中并非总是合法语法，在老版本的 IE 中就不被允许（现在可以了）。正确的方法应该是 a.charAt(1)。</p><p>字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p><div class="code-wrapper"><pre><code class="hljs js">c = a.<span class="hljs-title function_">toUpperCase</span>();a === c; <span class="hljs-comment">// false</span>a; <span class="hljs-comment">// &quot;foo&quot;</span>c; <span class="hljs-comment">// &quot;FOO&quot;</span>b.<span class="hljs-title function_">push</span>( <span class="hljs-string">&quot;!&quot;</span> );b; <span class="hljs-comment">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</span></code></pre></div><p>许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数组的非变更方法来处理字符串：</p><div class="code-wrapper"><pre><code class="hljs js">a.<span class="hljs-property">join</span>; <span class="hljs-comment">// undefined</span>a.<span class="hljs-property">map</span>; <span class="hljs-comment">// undefined</span><span class="hljs-keyword">var</span> c = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">join</span>.<span class="hljs-title function_">call</span>( a, <span class="hljs-string">&quot;-&quot;</span> );<span class="hljs-keyword">var</span> d = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">call</span>( a, <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)&#123; <span class="hljs-keyword">return</span> v.<span class="hljs-title function_">toUpperCase</span>() + <span class="hljs-string">&quot;.&quot;</span>;&#125; ).<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot;&quot;</span> );c; <span class="hljs-comment">// &quot;f-o-o&quot;</span>d; <span class="hljs-comment">// &quot;F.O.O.&quot;</span></code></pre></div><p>另一个不同点在于字符串反转（JavaScript 面试常见问题）。数组有一个字符串没有的可变更成员函数 reverse()：</p><div class="code-wrapper"><pre><code class="hljs js">a.<span class="hljs-property">reverse</span>; <span class="hljs-comment">// undefined</span>b.<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// [&quot;!&quot;,&quot;o&quot;,&quot;O&quot;,&quot;f&quot;]</span>b; <span class="hljs-comment">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</span></code></pre></div><p>可惜我们无法“借用”数组的可变更成员函数，因为字符串是不可变的：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reverse</span>.<span class="hljs-title function_">call</span>( a );<span class="hljs-comment">// 返回值仍然是字符串&quot;foo&quot;的一个封装对象</span></code></pre></div><p>一个变通（破解）的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = a  <span class="hljs-comment">// 将a的值转换为字符数组</span>  .<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment">// 将数组中的字符进行倒转</span>  .<span class="hljs-title function_">reverse</span>()  <span class="hljs-comment">// 将数组中的字符拼接回字符串</span>  .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);c; <span class="hljs-comment">// &quot;oof&quot;</span></code></pre></div><p>请注意！上述方法对于包含复杂字符（Unicode，如星号、多字节字符等）的字符串并不适用。这时则需要功能更加完备、能够处理 Unicode 的工具库。可以参考 Mathias Bynen 的 Esrever（<a href="https://github.com/mathiasbynents/esrever%EF%BC%89">https://github.com/mathiasbynents/esrever）</a></p><p>如果需要经常以字符数组的方式来处理字符串的话，倒不如直接使用数组。这样就不用在字符串和数组之间来回折腾。可以在需要时使用 join(“”) 将字符数组转换为字符串。</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>js只有数字类型，不区分整数还是小数</p><p>JavaScript 中的“整数”就是没有小数的十进制数。所以 42.0 即等同于“整数”42</p><p>与大部分现代编程语言（包括几乎所有的脚本语言）一样，JavaScript 中的数字类型是基于 IEEE 754 标准来实现的，该标准通常也被称为“浮点数”。JavaScript 使用的是“双精度”格式（即 64 位二进制）。</p><p>特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同</p><p>由于数字值可以使用 Number 对象进行封装（参见第 3 章），因此数字值可以调用 Numberprototype 中的方法（参见第 3 章）。例如，tofixed(..) 方法可指定小数部分的显示位数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42.59</span>;a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">0</span> ); <span class="hljs-comment">// &quot;43&quot;</span>a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;42.6&quot;</span>a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// &quot;42.59&quot;</span>a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;42.590&quot;</span>a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">4</span> ); <span class="hljs-comment">// &quot;42.5900&quot;</span></code></pre></div><p>位数多于实际位会用0补齐</p><p>toPrecision(..) 方法用来指定有效数位的显示位数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42.59</span>;a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;4e+1&quot;</span>a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// &quot;43&quot;</span>a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;42.6&quot;</span>a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">4</span> ); <span class="hljs-comment">// &quot;42.59&quot;</span>a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">5</span> ); <span class="hljs-comment">// &quot;42.590&quot;</span>a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">6</span> ); <span class="hljs-comment">// &quot;42.5900&quot;</span></code></pre></div><p>上面的方法不仅适用于数字变量，也适用于数字常量。不过对于 . 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 无效语法：</span><span class="hljs-number">42.</span><span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// SyntaxError</span><span class="hljs-comment">// 下面的语法都有效：</span>(<span class="hljs-number">42</span>).<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;42.000&quot;</span><span class="hljs-number">0.42</span>.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;0.420&quot;</span><span class="hljs-number">42.</span>.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;42.000&quot;</span></code></pre></div><p>42.tofixed(3) 是无效语法，因为 . 被视为常量 42. 的一部分（如前所述），所以没有 . 属性访问运算符来调用 tofixed 方法。</p><p>42..tofixed(3) 则没有问题，因为第一个 . 被视为 number 的一部分，第二个 . 是属性访问运算符。只是这样看着奇怪，实际情况中也很少见。在基本类型值上直接调用的方法并不多见，不过这并不代表不好或不对。</p><p>下面的语法也是有效的（请注意其中的空格）：</p><p>42 .toFixed(3); // “42.000”</p><p>然而对数字常量而言，这样的语法很容易引起误会，不建议使用。</p><p>较大数的表示方式</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> onethousand = <span class="hljs-number">1</span>E3; // 即 <span class="hljs-number">1</span> * <span class="hljs-number">10</span>^<span class="hljs-number">3</span><span class="hljs-attribute">var</span> onemilliononehundredthousand = <span class="hljs-number">1</span>.<span class="hljs-number">1</span>E6; // 即 <span class="hljs-number">1</span>.<span class="hljs-number">1</span> * <span class="hljs-number">10</span>^<span class="hljs-number">6</span></code></pre></div><p>数字常量还可以使用二进制，八进制，十六进制来表示</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-number">0xf3</span>; <span class="hljs-comment">// 243的十六进制</span><span class="hljs-number">0Xf3</span>; <span class="hljs-comment">// 同上</span><span class="hljs-number">0363</span>; <span class="hljs-comment">// 243的八进制</span></code></pre></div><p>ES6开始，严格模式不支持0363这种八进制表示方式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">ES6</span> 支持以下新格式：<span class="hljs-number">0o363</span>; <span class="hljs-comment">// 243的八进制</span><span class="hljs-number">0O363</span>; <span class="hljs-comment">// 同上</span><span class="hljs-number">0b11110011</span>; <span class="hljs-comment">// 243的二进制</span><span class="hljs-number">0B11110011</span>; <span class="hljs-comment">// 同上</span></code></pre></div><p>要使用小写的o不要使用大写的O，容易混淆</p><h3 id="较小的数值"><a href="#较小的数值" class="headerlink" title="较小的数值"></a>较小的数值</h3><p>二进制浮点数最大的问题（不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此），是</p><p>会出现如下情况：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span> === <span class="hljs-number">0</span>.<span class="hljs-number">3</span>; // false</code></pre></div><p>简单来说，二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于0.3，而是一个比较接近的数字 0.30000000000000004，所以条件判断结果为 false。</p><p>那么应该怎样来判断 0.1 + 0.2 和 0.3 是否相等呢？</p><p>最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。</p><p>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前的版本写 polyfifill：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>) &#123; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,-<span class="hljs-number">52</span>);&#125;</code></pre></div><p>可以使用 Number.EPSILON 来比较两个数字是否相等（在指定的误差范围内）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numbersCloseEnoughToEqual</span>(<span class="hljs-params">n1,n2</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>( n1 - n2 ) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-number">0.3</span>;<span class="hljs-title function_">numbersCloseEnoughToEqual</span>( a, b ); <span class="hljs-comment">// true</span><span class="hljs-title function_">numbersCloseEnoughToEqual</span>( <span class="hljs-number">0.0000001</span>, <span class="hljs-number">0.0000002</span> ); <span class="hljs-comment">// false</span></code></pre></div><p>能够呈现的最大浮点数大约是 1.798e+308（这是一个相当大的数字），它定义在 Number.MAX_VALUE 中。最小浮点数定义在 Number.MIN_VALUE 中，大约是 5e-324，它不是负数，但无限接近于 0 ！</p><h3 id="整数的安全范围"><a href="#整数的安全范围" class="headerlink" title="整数的安全范围"></a>整数的安全范围</h3><p>能够被“安全”呈现的最大整数是 2^53 - 1，即 9007199254740991，在 ES6 中被定义为Number.MAX_SAFE_INTEGER。最小整数是 -9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。</p><p>可以使用bigInt来处理</p><h3 id="整数检测"><a href="#整数检测" class="headerlink" title="整数检测"></a>整数检测</h3><p>要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>( <span class="hljs-number">42</span> ); <span class="hljs-comment">// true</span><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>( <span class="hljs-number">42.000</span> ); <span class="hljs-comment">// true</span><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>( <span class="hljs-number">42.3</span> ); <span class="hljs-comment">// false</span></code></pre></div><p>也可以为 ES6 之前的版本 polyfifill Number.isInteger(..) 方法：</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Number</span>.isInteger) &#123;  <span class="hljs-built_in">Number</span>.isInteger = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">typeof</span> num == <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; num % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>;  &#125;;&#125;</code></pre></div><p>要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>( <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span> ); <span class="hljs-comment">// true</span><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>( <span class="hljs-number">2</span>, <span class="hljs-number">53</span> ) ); <span class="hljs-comment">// false</span><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>( <span class="hljs-number">2</span>, <span class="hljs-number">53</span> ) - <span class="hljs-number">1</span> ); <span class="hljs-comment">// true</span></code></pre></div><p>可以为 ES6 之前的版本 polyfifill Number.isSafeInteger(..) 方法：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-property">isSafeInteger</span>) &#123;  <span class="hljs-title class_">Number</span>.<span class="hljs-property">isSafeInteger</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(num) &amp;&amp; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(num) &lt;= <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;  &#125;;&#125;</code></pre></div><h3 id="32-位有符号整数"><a href="#32-位有符号整数" class="headerlink" title="32 位有符号整数"></a>32 位有符号整数</h3><p>虽然整数最大能够达到 53 位，但是有些数字操作（如数位操作）只适用于 32 位数字，所以这些操作中数字的安全范围就要小很多，变成从 Math.pow(-2,31)（-2147483648， 约－21 亿）到 Math.pow(2,31) - 1（2147483647，约 21 亿）</p><p>a | 0 可以将变量 a 中的数值转换为 32 位有符号整数，因为数位运算符 | 只适用于 32 位整数（它只关心 32 位以内的值，其他的数位将被忽略）。因此与 0 进行操作即可截取 a 中 的 32 位数位。</p><h2 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h2><h3 id="不是值的值"><a href="#不是值的值" class="headerlink" title="不是值的值"></a>不是值的值</h3><p>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名称既是类型也是值</p><p>undefined 和 null 常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别。例如：</p><p>• null 指空值（empty value）</p><p>• undefined 指没有值（missing value）</p><p>或者：</p><p>• undefined 指从未赋值</p><p>• null 指曾赋过值，但是目前没有值</p><p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而undefined 却是一个标识符，可以被当作变量来使用和赋值。</p><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>在非严格模式下，我们可以为全局标识符 undefined 赋值</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 非常糟糕的做法！</span>&#125;<span class="hljs-title function_">foo</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-string">&quot;use strict&quot;</span>;  <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// TypeError!</span>&#125;<span class="hljs-title function_">foo</span>();</code></pre></div><p>在非严格和严格两种模式下，我们可以声明一个名为 undefined 的局部变量。再次强调最好不要这样做！</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-string">&quot;use strict&quot;</span>; <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// 2</span>&#125;<span class="hljs-title function_">foo</span>();</code></pre></div><p><strong>void 运算符</strong></p><p>undefined 是一个内置标识符（除非被重新定义，见前面的介绍），它的值为 undefined，通过 void 运算符即可得到该值。</p><p>表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值：</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( <span class="hljs-keyword">void</span> a, a ); <span class="hljs-comment">// undefined 42</span></code></pre></div><p>按惯例我们用 void 0 来获得 undefined（这主要源自 C 语言，当然使用 void true 或其他void 表达式也是可以的）。void 0、void 1 和 undefined 之间并没有实质上的区别</p><h3 id="特殊的数字"><a href="#特殊的数字" class="headerlink" title="特殊的数字"></a>特殊的数字</h3><p>NaN</p><p>可以使用内建的全局工具函数 isNaN(..) 来判断一个值是否是 NaN</p><p>然而操作起来并非这么容易。isNaN(..) 有一个严重的缺陷，它的检查方式过于死板，就是“检查参数是否不是 NaN，也不是数字”。但是这样做的结果并不太准确：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> / <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;foo&quot;</span>;a; <span class="hljs-comment">// NaN</span>b; <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">isNaN</span>( a ); <span class="hljs-comment">// true</span><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">isNaN</span>( b ); <span class="hljs-comment">// true——晕！</span></code></pre></div><p>很明显 “foo” 不是一个数字，但是它也不是 NaN</p><p>ES6 开始我们可以使用工具函数 Number.isNaN(..)。ES6 之前的浏览器的 polyfifill 如下：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span>) &#123; <span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123; <span class="hljs-keyword">return</span> ( <span class="hljs-keyword">typeof</span> n === <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">isNaN</span>( n ) );  &#125;;&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> / <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>( a ); <span class="hljs-comment">// true</span><span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>( b ); <span class="hljs-comment">// false——好！</span></code></pre></div><p>实际上还有一个更简单的方法，即利用 NaN 不等于自身这个特点。NaN 是 JavaScript 中唯 一一个不等于自身的值。</p><p>用判断自己是否等于自己来判断是否是NaN</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span>) &#123; <span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123; <span class="hljs-keyword">return</span> n !== n; &#125;;&#125;</code></pre></div><p>无穷数</p><div class="code-wrapper"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span><span class="hljs-comment">; // Infinity  Number.POSITIVE_INfiNITY</span>var b <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> / <span class="hljs-number">0</span><span class="hljs-comment">; // -Infinity Number.NEGATIVE_INfiNITY</span></code></pre></div><p>在js和数学运算中，无穷/无穷是未定式</p><p>Infinity/Infinity 是一个未定义操作，结果为 NaN。</p><p>零值</p><p>在JS中存在+0和-0两种表示</p><p>-0 除了可以用作常量以外，也可以是某些数学运算的返回值。例如：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> a = <span class="hljs-number">0</span> / -<span class="hljs-number">3</span>; // -<span class="hljs-number">0</span><span class="hljs-attribute">var</span> b = <span class="hljs-number">0</span> * -<span class="hljs-number">3</span>; // -<span class="hljs-number">0</span></code></pre></div><p>加法和减法运算不会得到负零（negative zero）。</p><p>负零在开发调试控制台中通常显示为 -0，但在一些老版本的浏览器中仍然会显示为 0</p><p>根据规范，对负零进行字符串化会返回 “0”：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span> / -<span class="hljs-number">3</span>;<span class="hljs-comment">// 至少在某些浏览器的控制台中显示是正确的</span>a; <span class="hljs-comment">// -0</span><span class="hljs-comment">// 但是规范定义的返回结果是这样！</span>a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;0&quot;</span>a + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// &quot;0&quot;</span><span class="hljs-title class_">String</span>( a ); <span class="hljs-comment">// &quot;0&quot;</span><span class="hljs-comment">// JSON也如此，很奇怪</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a )</code></pre></div><p>有意思的是，如果反过来将其从字符串转换为数字，得到的结果是准确的：</p><div class="code-wrapper"><pre><code class="hljs js">+<span class="hljs-string">&quot;-0&quot;</span>; <span class="hljs-comment">// -0</span><span class="hljs-title class_">Number</span>( <span class="hljs-string">&quot;-0&quot;</span> ); <span class="hljs-comment">// -0</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>( <span class="hljs-string">&quot;-0&quot;</span> ); <span class="hljs-comment">// -0</span></code></pre></div><p>JSON.stringify(-0) 返回 “0”，而 JSON.parse(“-0”) 返回 -0</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-number">0</span> / -<span class="hljs-number">3</span>;a == b; <span class="hljs-comment">// true</span>-<span class="hljs-number">0</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>a === b; <span class="hljs-comment">// true</span>-<span class="hljs-number">0</span> === <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span><span class="hljs-number">0</span> &gt; -<span class="hljs-number">0</span>; <span class="hljs-comment">// false </span>a &gt; b; <span class="hljs-comment">// false</span></code></pre></div><p>要区分 -0 和 0，不能仅仅依赖开发调试窗口的显示结果，还需要做一些特殊处理：</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> is<span class="hljs-constructor">NegZero(<span class="hljs-params">n</span>)</span> &#123; n = <span class="hljs-constructor">Number( <span class="hljs-params">n</span> )</span>; return (n<span class="hljs-operator"> === </span><span class="hljs-number">0</span>)<span class="hljs-operator"> &amp;&amp; </span>(<span class="hljs-number">1</span><span class="hljs-operator"> / </span>n<span class="hljs-operator"> === </span>-Infinity);&#125;is<span class="hljs-constructor">NegZero( -0 )</span>; <span class="hljs-comment">// true</span>is<span class="hljs-constructor">NegZero( 0 <span class="hljs-operator">/</span> -3 )</span>; <span class="hljs-comment">// true</span>is<span class="hljs-constructor">NegZero( 0 )</span>; <span class="hljs-comment">// false</span></code></pre></div><p><strong>我们为什么需要负零呢</strong></p><p>有些应用程序中的数据需要以级数形式来表示（比如动画帧的移动速度），数字的符号位（sign）用来代表其他信息（比如移动的方向）。此时如果一个值为 0 的变量失去了它的符号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生</p><h2 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h2><p>NaN和自身不相等，-0！==0</p><p>ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等，可以用来处理</p><p>上述所有的特殊情况：</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> / <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-number">-3</span> * <span class="hljs-number">0</span>;<span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>( a, NaN ); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>( b, <span class="hljs-number">-0</span> ); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>( b, <span class="hljs-number">0</span> ); <span class="hljs-comment">// false</span></code></pre></div><p>对于 ES6 之前的版本，Object.is(..) 有一个简单的 polyfifill：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span>) &#123; <span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">v1, v2</span>) &#123; <span class="hljs-comment">// 判断是否是-0</span> <span class="hljs-keyword">if</span> (v1 === <span class="hljs-number">0</span> &amp;&amp; v2 === <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / v1 === <span class="hljs-number">1</span> / v2; &#125; <span class="hljs-comment">// 判断是否是NaN</span> <span class="hljs-keyword">if</span> (v1 !== v1) &#123; <span class="hljs-keyword">return</span> v2 !== v2; &#125; <span class="hljs-comment">// 其他情况</span> <span class="hljs-keyword">return</span> v1 === v2; &#125;;&#125;</code></pre></div><p>能使用 == 和 ===时就尽量不要使用 Object.is(..)，因为前者效率更高、更为通用。Object.is(..) 主要用来处理那些特殊的相等比较</p><h2 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h2><p>在许多编程语言中，赋值和参数传递可以通过值复制（value-copy）或者引用复制（reference-copy）来完成，这取决于我们使用什么语法</p><p>例如，在 C++ 中如果要向函数传递一个数字并在函数中更改它的值，就可以这样来声明参数 int&amp; myNum，即如果传递的变量是 x，myNum 就是指向 x 的引用。引用就像一种特殊的指针，是来指向变量的指针（别名）。如果参数不声明为引用的话，参数值总是通过值复制的方式传递，即便对复杂的对象值也是如此。</p><p>JavaScript 中没有指针，引用的工作机制也不尽相同。在 JavaScript 中变量不可能成为指向另一个变量的引用。</p><p>JavaScript 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用 / 指向关系</p><p>JavaScript 对值和引用的赋值 / 传递在语法上没有区别，完全根据值的类型来决定</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-keyword">var</span> b = a; <span class="hljs-comment">// b是a的值的一个副本</span>b++;a; <span class="hljs-comment">// 2</span>b; <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> c = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-keyword">var</span> d = c; <span class="hljs-comment">// d是[1,2,3]的一个引用</span>d.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> );c; <span class="hljs-comment">// [1,2,3,4]</span>d; <span class="hljs-comment">// [1,2,3,4]</span></code></pre></div><p>简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值 / 传递，包括null、undefined、字符串、数字、布尔和 ES6 中的 symbol</p><p>复合值（compound value）——对象（包括数组和封装对象）和函数，则总 是通过引用复制的方式来赋值 / 传递</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123; x.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> ); x; <span class="hljs-comment">// [1,2,3,4]</span> <span class="hljs-comment">// 然后</span> x = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]; x.<span class="hljs-title function_">push</span>( <span class="hljs-number">7</span> ); x; <span class="hljs-comment">// [4,5,6,7]</span>&#125;<span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-title function_">foo</span>( a );a; <span class="hljs-comment">// 是[1,2,3,4]，不是[4,5,6,7]</span></code></pre></div><p>函数的参数传递是值拷贝</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123; x = x + <span class="hljs-number">1</span>; x; <span class="hljs-comment">// 3 </span>&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>( a ); <span class="hljs-comment">// Object(a)也一样</span>foo( b );<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( b ); <span class="hljs-comment">// 是2，不是3</span></code></pre></div><p>原因是标量基本类型值是不可更改的（字符串和布尔也是如此）。如果一个数字对象的标量基本类型值是 2，那么该值就不能更改，除非创建一个包含新值的数字对象</p><p>x = x + 1 中，x 中的标量基本类型值 2 从数字对象中拆封（或者提取）出来后，x 就神不知鬼不觉地从引用变成了数字对象，它的值为 2 + 1 等于 3。然而函数外的 b 仍然指向原来那个值为 2 的数字对象。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似，但是它们的行为特征不同，在将字符作为数组来处理时需要特别小心。JavaScript 中的数字包括“整数”和“浮点型”。</p><p>基本类型中定义了几个特殊的值。</p><p>null 类型只有一个值 null，undefined 类型也只有一个值 undefined。所有变量在赋值之前默认值都是 undefined。void 运算符返回 undefined。</p><p>数 字 类 型 有 几 个 特 殊 值， 包 括 NaN（ 意 指“not a number”， 更 确 切 地 说 是“invalid number”）、+Infinity、-Infinity 和 -0。简单标量基本类型值（字符串和数字等）通过值复制来赋值 / 传递，而复合值（对象等）</p><p>通过引用复制来赋值 / 传递。JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不能指向别的变量 / 引用，只能指向值。</p><h1 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h1><p>常用的原生函数有：</p><p>• String()</p><p>• Number()</p><p>• Boolean()</p><p>• Array()</p><p>• Object()</p><p>• Function()</p><p>• RegExp()</p><p>• Date()</p><p>• Error()</p><p>• Symbol()——ES6 中新加入的！</p><p>这些都是内建函数</p><p>原生函数可以被当作构造函数来使用，但其构造出来的对象可能会和我们设想的有所出入：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// 是&quot;object&quot;，不是&quot;String&quot;</span>a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(a); <span class="hljs-comment">// &quot;[object String]&quot;</span></code></pre></div><p>通过构造函数（如 new String(“abc”)）创建出来的是封装了基本类型值（如 “abc”）的封装对象。</p><p>请注意：typeof 在这里返回的是对象类型的子类型。</p><h2 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性 [[Class]]"></a>内部属性 [[Class]]</h2><p>所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] );<span class="hljs-comment">// &quot;[object Array]&quot;</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-regexp">/regex-literal/i</span> );<span class="hljs-comment">// &quot;[object RegExp]&quot;</span></code></pre></div><p>上例中，数组的内部 [[Class]] 属性值是 “Array”，正则表达式的值是 “RegExp”。多数情况下，对象的内部 [[Class]] 属性和创建该对象的内建原生构造函数相对应（如下），但并非总是如此。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-literal">null</span> );<span class="hljs-comment">// &quot;[object Null]&quot;</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-literal">undefined</span> );<span class="hljs-comment">// &quot;[object Undefined]&quot;</span></code></pre></div><p>虽然 Null() 和 Undefined() 这样的原生构造函数并不存在，但是内部 [[Class]] 属性值仍然是 “Null” 和 “Undefined”。</p><p>其他基本类型值（如字符串、数字和布尔）的情况有所不同，通常称为“包装”（boxing</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-string">&quot;abc&quot;</span> );<span class="hljs-comment">// &quot;[object String]&quot;</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-number">42</span> );<span class="hljs-comment">// &quot;[object Number]&quot;</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-literal">true</span> );<span class="hljs-comment">// &quot;[object Boolean]&quot;</span></code></pre></div><p>上例中基本类型值被各自的封装对象自动包装，所以它们的内部 [[Class]] 属性值分别为”String”、”Number” 和 “Boolean”。</p><h2 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h2><p>封 装 对 象（object wrapper） 扮 演 着 十 分 重 要 的 角 色。 由 于 基 本 类 型 值 没 有 .length和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为基本类型值包装（box 或者 wrap）一个封装对象：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;abc&quot;</span>;a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span>a.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// &quot;ABC&quot;</span></code></pre></div><p>封装类型不要经常使用，这样可能会降低执行效率，应该由js引擎自己决定，应该用基本类型</p><h3 id="封装对象释疑"><a href="#封装对象释疑" class="headerlink" title="封装对象释疑"></a>封装对象释疑</h3><p>封装对象时要注意使用：</p><div class="code-wrapper"><pre><code class="hljs arcade">比如 <span class="hljs-built_in">Boolean</span>：<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>( <span class="hljs-literal">false</span> );<span class="hljs-keyword">if</span> (!a) &#123; <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> ); <span class="hljs-comment">// 执行不到这里</span>&#125;</code></pre></div><p>这里变成了封装对象，所以而对象属于truthly，所以永远会返回true</p><p>如果想要自行封装基本类型值，可以使用 Object(..) 函数（不带 new 关键字）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( a );<span class="hljs-keyword">var</span> c = <span class="hljs-title class_">Object</span>( a );<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;string&quot;</span><span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &quot;object&quot;</span><span class="hljs-keyword">typeof</span> c; <span class="hljs-comment">// &quot;object&quot;</span>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span>c <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( b ); <span class="hljs-comment">// &quot;[object String]&quot;</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( c ); <span class="hljs-comment">// &quot;[object String]&quot;</span></code></pre></div><p>尽量不要使用封装类型</p><h2 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h2><p>如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( <span class="hljs-string">&quot;abc&quot;</span> );<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>( <span class="hljs-number">42</span> );<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>( <span class="hljs-literal">true</span> );a.<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// &quot;abc&quot;</span>b.<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// 42</span>c.<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// true</span></code></pre></div><p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封。具体过程（即强制类型转换）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( <span class="hljs-string">&quot;abc&quot;</span> );<span class="hljs-keyword">var</span> b = a + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// b的值为&quot;abc&quot;</span><span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;object&quot;</span><span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &quot;string</span></code></pre></div><h2 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h2><p>尽量避免使用原生函数作为构造函数</p><h3 id="Array"><a href="#Array" class="headerlink" title="Array(..)"></a>Array(..)</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> );a; <span class="hljs-comment">// [1, 2, 3]</span><span class="hljs-keyword">var</span> b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];b; <span class="hljs-comment">// [1, 2, 3]</span></code></pre></div><p>构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的。</p><p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素</p><p>如若一个数组没有任何单元，但它的 length 属性中却显示有单元数量，这样奇特的数据结构会导致一些怪异的行为</p><p>我们将包含至少一个“空单元”的数组称为“稀疏数组”。</p><p>但是永远不要创建和使用空数组</p><h3 id="Object-、Function-和-RegExp"><a href="#Object-、Function-和-RegExp" class="headerlink" title="Object(..)、Function(..) 和 RegExp(..)"></a>Object(..)、Function(..) 和 RegExp(..)</h3><p>除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..)</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();c.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;c; <span class="hljs-comment">// &#123; foo: &quot;bar&quot; &#125;</span><span class="hljs-keyword">var</span> d = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span> &#125;;d; <span class="hljs-comment">// &#123; foo: &quot;bar&quot; &#125;</span><span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>( <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;return a * 2;&quot;</span> );<span class="hljs-keyword">var</span> f = <span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-keyword">return</span> a * <span class="hljs-number">2</span>; &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-keyword">return</span> a * <span class="hljs-number">2</span>; &#125;<span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>( <span class="hljs-string">&quot;^a*b+&quot;</span>, <span class="hljs-string">&quot;g&quot;</span> );<span class="hljs-keyword">var</span> i = <span class="hljs-regexp">/^a*b+/g</span>;</code></pre></div><p>在实际情况中没有必要使用 new Object() 来创建对象，因为这样就无法像常量形式那样一次设定多个属性，而必须逐一设定</p><p>构造函数 Function 只在极少数情况下很有用，比如动态定义函数参数和函数体的时候。不要把 Function(..) 当作 eval(..) 的替代品，你基本上不会通过这种方式来定义函数。</p><p>强烈建议使用常量形式（如 /^a*b+/g）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它们进行预编译和缓存。与前面的构造函数不同，RegExp(..) 有时还是很有用的，比如动态定义正则表达式时：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Kyle&quot;</span>;<span class="hljs-keyword">var</span> namePattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>( <span class="hljs-string">&quot;\\b(?:&quot;</span> + name + <span class="hljs-string">&quot;)+\\b&quot;</span>, <span class="hljs-string">&quot;ig&quot;</span> );<span class="hljs-keyword">var</span> matches = someText.<span class="hljs-title function_">match</span>( namePattern );</code></pre></div><p>上述情况在 JavaScript 编程中时有发生，这时 new RegExp(“pattern”,”flags”) 就能派上用场。</p><h3 id="Date-和-Error"><a href="#Date-和-Error" class="headerlink" title="Date(..) 和 Error(..)"></a>Date(..) 和 Error(..)</h3><p>相较于其他原生构造函数，Date(..) 和 Error(..) 的用处要大很多，因为没有对应的常量形式来作为它们的替代。</p><p>创建日期对象必须使用 new Date()。Date(..) 可以带参数，用来指定日期和时间，而不带参数的话则使用当前的日期和时间。</p><p>Date(..) 主要用来获得当前的 Unix 时间戳（从 1970 年 1 月 1 日开始计算，以秒为单位）。该值可以通过日期对象中的 getTime() 来获得。</p><p>从 ES5 开始引入了一个更简单的方法，即静态函数 Date.now()。对 ES5 之前的版本我们可以使用下面的 polyfifill：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span>) &#123; <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">getTime</span>(); &#125;;&#125;</code></pre></div><p>如果调用 Date() 时不带 new 关键字，则会得到当前日期的字符串值。其具体格式规范没有规定，浏览器使用 “Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)”这样的格式来显示。</p><p>构造函数 Error(..)（与前面的 Array() 类似）带不带 new 关键字都可。</p><p>创建错误对象（error object）主要是为了获得当前运行栈的上下文（大部分 JavaScript 引擎通过只读属性 .stack 来访问）。栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。</p><p>错误对象通常与 throw 一起使用：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123; <span class="hljs-keyword">if</span> (!x) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>( <span class="hljs-string">&quot;x wasn’t provided&quot;</span> ); &#125; <span class="hljs-comment">// .. </span>&#125;</code></pre></div><p>通常错误对象至少包含一个 message 属性，有时也不乏其他属性（必须作为只读属性访问），如 type。除了访问 stack 属性以外，最好的办法是调用（显式调用或者通过强制类型转换隐式调用）toString() 来获得经过格式化的便于阅读的错误信息。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol(..)"></a>Symbol(..)</h3><p>ES6 中新加入了一个基本数据类型 ——符号（Symbol）。符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名。该类型的引入主要源于 ES6 的一些特殊构造，此外符号也可以自行定义。</p><p>符号可以用作属性名，但无论是在代码还是开发控制台中都无法查看和访问它的值，只会显示为诸如 Symbol(Symbol.create) 这样的值</p><p>ES6 中有一些预定义符号，以 Symbol 的静态属性形式出现，如 Symbol.create、Symbol.iterator 等，可以这样来使用：</p><div class="code-wrapper"><pre><code class="hljs js">obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">/*..*/</span> &#125;;</code></pre></div><p>我们可以使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键字，否则会出错：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mysym = <span class="hljs-title class_">Symbol</span>( <span class="hljs-string">&quot;my own symbol&quot;</span> );mysym; <span class="hljs-comment">// Symbol(my own symbol)</span>mysym.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;Symbol(my own symbol)&quot;</span><span class="hljs-keyword">typeof</span> mysym; <span class="hljs-comment">// &quot;symbol&quot;</span><span class="hljs-keyword">var</span> a = &#123; &#125;;a[mysym] = <span class="hljs-string">&quot;foobar&quot;</span>;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>( a );<span class="hljs-comment">// [ Symbol(my own symbol) ]</span></code></pre></div><p>虽然符号实际上并非私有属性（通过 Object.getOwnPropertySymbols(..) 便可以公开获得对象中的所有符号），但它却主要用于私有或特殊属性。很多开发人员喜欢用它来替代有下划线（_）前缀的属性，而下划线前缀通常用于命名私有或特殊属性。</p><p>符号并非对象，而是一种简单标量基本类型</p><h3 id="原生原型"><a href="#原生原型" class="headerlink" title="原生原型"></a>原生原型</h3><p>原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype 等。</p><p>• String.prototype.indexOf(..)</p><p>在字符串中找到指定子字符串的位置。</p><p>• String.prototype.charAt(..)</p><p>获得字符串指定位置上的字符。</p><p>• String.prototype.substr(..)、String.prototype.substring(..) 和 String.prototype.slice(..)</p><p>获得字符串的指定部分。 </p><p>• String.prototype.toUpperCase() 和 String.prototype.toLowerCase()</p><p>将字符串转换为大写或小写。</p><p>• String.prototype.trim()</p><p>去掉字符串前后的空格，返回新的字符串。</p><p>以上方法并不改变原字符串的值，而是返回一个新字符串,所有字符串都可以访问这些方法其他构造函数的原型包含它们各自类型所特有的行为特征，比如 Number.prototype.tofixed(..)（将数字转换为指定长度的整数字符串）和 Array.prototype.concat(..)（合并数组）。所有的函数都可以调用 Function.prototype 中的 apply(..)、call(..) 和 bind(..)</p><p>然而，有些原生原型（native prototype）并非普通对象那么简单：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// &quot;function&quot;</span><span class="hljs-title class_">Function</span>.<span class="hljs-title function_">prototype</span>(); <span class="hljs-comment">// 空函数！</span><span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;/(?:)/&quot;——空正则表达式</span><span class="hljs-string">&quot;abc&quot;</span>.<span class="hljs-title function_">match</span>( <span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <span class="hljs-comment">// [&quot;&quot;]</span></code></pre></div><p>更糟糕的是，我们甚至可以修改它们（而不仅仅是添加属性）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>( <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <span class="hljs-comment">// true</span><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">push</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ); <span class="hljs-comment">// 3</span><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// [1,2,3]</span><span class="hljs-comment">// 需要将Array.prototype设置回空，否则会导致问题！</span><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;</code></pre></div><p>这里，Function.prototype 是一个函数，RegExp.prototype 是一个正则表达式，而 Array. prototype 是一个数组。是不是很有意思？</p><p><strong>将原型作为默认值</strong></p><p>Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式（无任何匹配），而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isThisCool</span>(<span class="hljs-params">vals,fn,rx</span>) &#123; vals = vals || <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; fn = fn || <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; rx = rx || <span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-keyword">return</span> rx.<span class="hljs-title function_">test</span>( vals.<span class="hljs-title function_">map</span>( fn ).<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot;&quot;</span> ) ); &#125;<span class="hljs-title function_">isThisCool</span>(); <span class="hljs-comment">// true</span><span class="hljs-title function_">isThisCool</span>( [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)&#123; <span class="hljs-keyword">return</span> v.<span class="hljs-title function_">toUpperCase</span>(); &#125;, <span class="hljs-regexp">/D/</span>); <span class="hljs-comment">// false</span></code></pre></div><p>这种方法的一个好处是 .prototypes 已被创建并且仅创建一次。相反，如果将 []、function(){} 和 /(?:)/ 作为默认值，则每次调用 isThisCool(..) 时它们都会被创建一次（具体创建与否取决于 JavaScript 引擎，稍后它们可能会被垃圾回收），这样无疑会造成内存和 CPU 资源的浪费。</p><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><h2 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h2><p>将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。</p><p>类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）然而在 JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicit coercion）来区分。二者的区别显而易见：我们能够从代码中看出哪些地方是显式强制类型转换，而隐式强制类型转换则不那么明显，通常是某些操作产生的副作用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<span class="hljs-keyword">var</span> b = a + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 隐式强制类型转换</span><span class="hljs-keyword">var</span> c = <span class="hljs-title class_">String</span>( a ); <span class="hljs-comment">// 显式强制类型转换</span></code></pre></div><h2 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h2><h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h3><p>它负责处理非字符串到字符串的强制类型转换</p><p>基本类型值的字符串化规则为：null 转换为 “null”，undefined 转换为 “undefined”，true转换为 “true”。数字的字符串化则遵循通用规则那些极小和极大的数字使用指数形式：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.07 连续乘以七个 1000</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">1.07</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;<span class="hljs-comment">// 七个1000一共21位数字</span>a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1.07e21&quot;</span></code></pre></div><p>对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回内部属性 [[Class]] 的值，如 “[object Object]”。</p><p>将对象强制类型转换为 string 是通过 ToPrimitive 抽象操作来完成的</p><p>数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接起来</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1,2,3&quot;</span></code></pre></div><p>toString() 可以被显式调用，或者在需要字符串化时自动调用。</p><h4 id="JSON-字符串化"><a href="#JSON-字符串化" class="headerlink" title="JSON 字符串化"></a>JSON 字符串化</h4><p>工具函数 JSON.stringify(..) 在将 JSON 对象序列化为字符串时也用到了 ToString。但是json的序列化并不是严格的显示类型转换</p><p>对大多数简单值来说，JSON 字符串化和 toString() 的效果基本相同，只不过序列化的结果总是字符串：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-number">42</span> ); <span class="hljs-comment">// &quot;42&quot;</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-string">&quot;42&quot;</span> ); <span class="hljs-comment">// &quot;&quot;42&quot;&quot; （含有双引号的字符串）</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// &quot;null&quot;</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-literal">true</span> ); <span class="hljs-comment">// &quot;true&quot;</span></code></pre></div><p>所有安全的 JSON 值（JSON-safe）都可以使用 JSON.stringify(..) 字符串化。安全的JSON 值是指能够呈现为有效 JSON 格式的值。</p><p>为了简单起见，我们来看看什么是不安全的 JSON 值。undefined、function、symbol（ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合 JSON结构标准，支持 JSON 的语言无法处理它们。</p><p>JSON.stringify(..) 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// undefined</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; ); <span class="hljs-comment">// undefined</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( [<span class="hljs-number">1</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;,<span class="hljs-number">4</span>]); <span class="hljs-comment">// &quot;[1,null,null,4]&quot;</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">b</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; &#125;); <span class="hljs-comment">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></code></pre></div><p>对包含循环引用的对象执行 JSON.stringify(..) 会出错。</p><p>如果对象中定义了 toJSON() 方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化。如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的 JSON 值。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;&#125;;<span class="hljs-keyword">var</span> a = &#123;  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,  <span class="hljs-attr">c</span>: o,  <span class="hljs-attr">d</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,&#125;;<span class="hljs-comment">// 在a中创建一个循环引用</span>o.<span class="hljs-property">e</span> = a;<span class="hljs-comment">// 循环引用在这里会产生错误</span><span class="hljs-comment">// JSON.stringify( a );</span><span class="hljs-comment">// 自定义的JSON序列化</span>a.<span class="hljs-property">toJSON</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 序列化仅包含b</span>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">b</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> &#125;;&#125;;<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a); <span class="hljs-comment">// &quot;&#123;&quot;b&quot;:42&#125;&quot;</span></code></pre></div><p>toJSON() 应该“返回一个能够被字符串化的安全的 JSON 值”，而不是“返回一个 JSON 字符串”。</p><div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-attr">val</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-comment">// 可能是我们想要的结果！</span> <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span>.<span class="hljs-title function_">slice</span>( <span class="hljs-number">1</span> ); &#125;&#125;;<span class="hljs-keyword">var</span> b = &#123; <span class="hljs-attr">val</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-comment">// 可能不是我们想要的结果！</span> <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span>.<span class="hljs-title function_">slice</span>( <span class="hljs-number">1</span> ).<span class="hljs-title function_">join</span>() + <span class="hljs-string">&quot;]&quot;</span>;  &#125;&#125;;<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a ); <span class="hljs-comment">// &quot;[2,3]&quot;</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( b ); <span class="hljs-comment">// &quot;&quot;[2,3]&quot;&quot;</span></code></pre></div><p>我们可以向 JSON.stringify(..) 传递一个可选参数 replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON() 很像。</p><p>如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。</p><p>如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined，否则返回指定的值。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] &#125;;<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a, [<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>] ); <span class="hljs-comment">// &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot;</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a, <span class="hljs-keyword">function</span>(<span class="hljs-params">k,v</span>)&#123; <span class="hljs-keyword">if</span> (k !== <span class="hljs-string">&quot;c&quot;</span>) <span class="hljs-keyword">return</span> v;&#125; );<span class="hljs-comment">// &quot;&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;</span></code></pre></div><p>JSON.string 还有一个可选参数 space，用来指定输出的缩进格式。space 为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;42&quot;</span>, <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] &#125;;<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span> );<span class="hljs-comment">// &quot;&#123;</span><span class="hljs-comment">// &quot;b&quot;: 42,</span><span class="hljs-comment">// &quot;c&quot;: &quot;42&quot;,</span><span class="hljs-comment">// &quot;d&quot;: [</span><span class="hljs-comment">// 1, </span><span class="hljs-comment">// 2,</span><span class="hljs-comment">// 3</span><span class="hljs-comment">// ]</span><span class="hljs-comment">// &#125;</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;-----&quot;</span> );<span class="hljs-comment">// &quot;&#123;</span><span class="hljs-comment">// -----&quot;b&quot;: 42,</span><span class="hljs-comment">// -----&quot;c&quot;: &quot;42&quot;,</span><span class="hljs-comment">// -----&quot;d&quot;: [</span><span class="hljs-comment">// ----------1,</span><span class="hljs-comment">// ----------2,</span><span class="hljs-comment">// ----------3</span><span class="hljs-comment">// -----]</span><span class="hljs-comment">// &#125;&quot;</span></code></pre></div><p>请记住，JSON.stringify(..) 并不是强制类型转换。在这里介绍是因为它涉及 ToString 强制类型转换，具体表现在以下两点。</p><p>(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。</p><p>(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。</p><h3 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h3><p>ToNumber 对以 0 开头的十六进制数并不按十六进制处理（而是按十进制</p><p>true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0</p><p>对象在调用toNumber的时候，首先会调用ToPrimitive，通过内部操作 DefaultValue，检查该值是否有 valueOf() 方法，如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString()的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。从 ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换</p><p>对象调用tonumber会先将其转成基本数据类型再进行操作</p><h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><h4 id="假值（falsy-value）"><a href="#假值（falsy-value）" class="headerlink" title="假值（falsy value）"></a>假值（falsy value）</h4><p>JavaScript 中的值可以分为以下两类：</p><p>(1) 可以被强制类型转换为 false 的值</p><p>(2) 其他（被强制类型转换为 true 的值）</p><p>以下这些是假值：</p><p>• undefined</p><p>• null</p><p>• false</p><p>• +0、-0 和 NaN</p><p>• “”</p><p>假值的布尔强制类型转换结果为 false</p><h4 id="真值（truthy-value）"><a href="#真值（truthy-value）" class="headerlink" title="真值（truthy value）"></a>真值（truthy value）</h4><p>除了假值之外的都是真值</p><h2 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h2><h3 id="字符串和数字之间的显式转换"><a href="#字符串和数字之间的显式转换" class="headerlink" title="字符串和数字之间的显式转换"></a>字符串和数字之间的显式转换</h3><p>字符串和数字之间的转换是通过 String(..) 和 Number(..) 这两个内建函数（原生构造函数）来实现的，请注意它们前面没有 new 关键字，并不创建封装对象。</p><p>在 JavaScript 开源社区中，一元运算 + 被普遍认为是显式强制类型转换</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = <span class="hljs-string">&quot;3.14&quot;</span>;<span class="hljs-keyword">var</span> d = <span class="hljs-number">5</span>+ +c;d; <span class="hljs-comment">// 8.14</span></code></pre></div><p>运算符的一元和二元形式的组合你也许能够想到很多种情况，下面是一个疯狂的例子：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1</span> + - + + + - + <span class="hljs-number">1</span>; <span class="hljs-comment">// 2</span></code></pre></div><p>尽量不要把一元运算符 +（还有 -）和其他运算符放在一起使用。上面的代码可以运行，但非常糟糕。此外 d = +c（还有 d =+ c）也容易和 d += c 搞混，两者天壤之别。</p><h5 id="日期显式转换为数字"><a href="#日期显式转换为数字" class="headerlink" title="日期显式转换为数字"></a>日期显式转换为数字</h5><p>一元运算符 + 的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为Unix 时间戳，以微秒为单位（从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>( <span class="hljs-string">&quot;Mon, 18 Aug 2014 08:53:06 CDT&quot;</span> );+d; <span class="hljs-comment">// 1408369986000</span></code></pre></div><p>我们常用下面的方法来获得当前的时间戳，例如：</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">timestamp</span> = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</code></pre></div><p>JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带 ()。于是我们可能会碰到 var timestamp = +new Date; 这样的写法。这样能否提高代码可读性还存在争议，因为这仅用于 new fn()，对一般的函数调用 fn() 并不适用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<span class="hljs-comment">// var timestamp = (new Date()).getTime();</span><span class="hljs-comment">// var timestamp = (new Date).getTime();</span><span class="hljs-keyword">var</span> timestamp = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<span class="hljs-comment">//ES5 中新加入的静态方法 Date.now()</span><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span>) &#123;<span class="hljs-comment">//老版本浏览器提供 Date.now() 的 polyfill</span> <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); &#125;;&#125;</code></pre></div><p>不建议对日期类型使用强制类型转换，应该使用 Date.now() 来获得当前的时间戳，使用 new Date(..).getTime() 来获得指定时间的时间戳</p><h4 id="奇特的-运算符"><a href="#奇特的-运算符" class="headerlink" title="奇特的 ~ 运算符"></a>奇特的 ~ 运算符</h4><p>字位运算符只适用于 32 位整数，运算符会强制操作数使用 32 位格式。这是通过抽象操作 ToInt32 来实现的</p><p>虽然严格说来并非强制类型转换（因为返回值类型并没有发生变化），但字位运算符（如 | 和 ~）和某些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字</p><p>例如 | 运算符（字位操作“或”）的空操作（no-op）0 | x，它仅执行 ToInt32 转换</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-number">0</span> | -<span class="hljs-number">0</span>; <span class="hljs-comment">// 0</span><span class="hljs-number">0</span> | <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// 0</span><span class="hljs-number">0</span> | <span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">// 0</span><span class="hljs-number">0</span> | -<span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">// 0</span></code></pre></div><p>以上这些特殊数字无法以 32 位格式呈现（因为它们来自 64 位 IEEE 754 标准，参见第 2章），因此 ToInt32 返回 0。</p><p>关于 0 | ___ 是显式还是隐式仍存在争议。从规范的角度来说它无疑是显式的，但如果对字位运算符没有这样深入的理解，它可能就是隐式的。为了前后保持一致，我们这里将其视为显式。再回到 ~。它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”（对每一个字位进行反转）。</p><p>字位反转是个很晦涩的主题，JavaScript 开发人员一般很少需要关心到字位级别。</p><p>对 ~ 还可以有另外一种诠释，源自早期的计算机科学和离散数学：~ 返回 2 的补码。这样一来问题就清楚多了！</p><p>~x 大致等同于 -(x+1)。很奇怪，但相对更容易说明问题：</p><p>~42; // -(42+1) ==&gt; -43</p><p>也许你还是没有完全弄明白 ~ 到底是什么玩意？为什么把它放在强制类型转换一章中介绍？稍安勿躁。</p><p>在 -(x+1) 中唯一能够得到 0（或者严格说是 -0）的 x 值是 -1。也就是说如果 x 为 -1 时，~和一些数字值在一起会返回假值 0，其他情况则返回真值。</p><p>然而这与我们讨论的内容有什么关系呢？</p><p>-1 是一个“哨位值”，哨位值是那些在各个类型中（这里是数字）被赋予了特殊含义的值。在 C 语言中我们用 -1 来代表函数执行失败，用大于等于 0 的值来代表函数执行成功。</p><p>JavaScript 中字符串的 indexOf(..) 方法也遵循这一惯例，该方法在字符串中搜索指定的子字符串，如果找到就返回子字符串所在的位置（从 0 开始），否则返回 -1。</p><p>indexOf(..) 不仅能够得到子字符串的位置，还可以用来检查字符串中是否包含指定的子字符串，相当于一个条件判断。例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;Hello World&quot;</span>;<span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;lo&quot;</span> ) &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// true</span> <span class="hljs-comment">// 找到匹配！</span>&#125;<span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;lo&quot;</span> ) != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// true</span> <span class="hljs-comment">// 找到匹配！</span>&#125;<span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> ) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// true</span> <span class="hljs-comment">// 没有找到匹配！</span>&#125;<span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> ) == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// true</span> <span class="hljs-comment">// 没有找到匹配！</span>&#125;</code></pre></div><p>&gt;= 0 和 == -1 这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，这里是指用 -1 作为失败时的返回值，这些细节应该被屏蔽掉。</p><p>现在我们终于明白 ~ 有什么用处了！ ~ 和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;Hello World&quot;</span>;~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;lo&quot;</span> ); <span class="hljs-comment">// -4 &lt;-- 真值!</span><span class="hljs-keyword">if</span> (~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;lo&quot;</span> )) &#123; <span class="hljs-comment">// true</span> <span class="hljs-comment">// 找到匹配！</span>&#125;~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> ); <span class="hljs-comment">// 0 &lt;-- 假值!</span>!~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> ); <span class="hljs-comment">// true</span><span class="hljs-keyword">if</span> (!~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> )) &#123; <span class="hljs-comment">// true</span> <span class="hljs-comment">// 没有找到匹配！</span>&#125;</code></pre></div><p>如果 indexOf(..) 返回 -1，~ 将其转换为假值 0，其他情况一律转换为真值。</p><p>由 -(x+1) 推断 <del>-1 的结果应该是 -0，然而实际上结果是 0，因为它是字位操作而非数学运算。从技术角度来说，if (</del>a.indexOf(..)) 仍然是对 indexOf(..) 的返回结果进行隐式强制类型转换，0 转换为 false，其他情况转换为 true。但我觉得 ~ 更像显式强制类型转换，前提是我对它有充分的理解。个人认为 ~ 比 &gt;= 0 和 == -1 更简洁。</p><h4 id="字位截除"><a href="#字位截除" class="headerlink" title="字位截除"></a>字位截除</h4><p>一些开发人员使用 ~~ 来截除数字值的小数部分，以为这和 Math.floor(..) 的效果一样，实际上并非如此</p><p>~~ 中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。~~ 和 !! 很相似。</p><p>对 ~~ 我们要多加注意。首先它只适用于 32 位数字，更重要的是它对负数的处理与 Math.floor(..) 不同。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>( -<span class="hljs-number">49.6</span> ); <span class="hljs-comment">// -50</span>~~-<span class="hljs-number">49.6</span>; <span class="hljs-comment">// -49</span></code></pre></div><p>~~x 能将值截除为一个 32 位整数，x | 0 也可以，而且看起来还更简洁</p><p>出于对运算符优先级（详见第 5 章）的考虑，我们可能更倾向于使用 ~~x：</p><div class="code-wrapper"><pre><code class="hljs js">~~<span class="hljs-number">1E20</span> / <span class="hljs-number">10</span>; <span class="hljs-comment">// 166199296</span><span class="hljs-number">1E20</span> | <span class="hljs-number">0</span> / <span class="hljs-number">10</span>; <span class="hljs-comment">// 1661992960</span>(<span class="hljs-number">1E20</span> | <span class="hljs-number">0</span>) / <span class="hljs-number">10</span>; <span class="hljs-comment">// 166199296</span></code></pre></div><h3 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h3><p>解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;42&quot;</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;42px&quot;</span>;<span class="hljs-title class_">Number</span>( a ); <span class="hljs-comment">// 42</span><span class="hljs-built_in">parseInt</span>( a ); <span class="hljs-comment">// 42</span><span class="hljs-title class_">Number</span>( b ); <span class="hljs-comment">// NaN</span><span class="hljs-built_in">parseInt</span>( b ); <span class="hljs-comment">// 42</span></code></pre></div><p>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回 NaN。</p><p>解析和转换之间不是相互替代的关系。它们虽然类似，但各有各的用途。如果字符串右边的非数字字符不影响结果，就可以使用解析。而转换要求字符串中所有的字符都是数字，像 “42px” 这样的字符串就不行。</p><p>解析字符串中的浮点数可以使用 parseFloat(..) 函数</p><p>不要忘了 parseInt(..) 针对的是字符串值。向 parseInt(..) 传递数字和其他类型的参数是没有用的，比如 true、function(){…} 和 [1,2,3]。非字符串参数会首先被强制类型转换为字符串，依赖这样的隐式强制类型转换并非上策，应该避免向 parseInt(..) 传递非字符串参数。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>( <span class="hljs-number">0.000008</span> ); <span class="hljs-comment">// 0 (&quot;0&quot; 来自于 &quot;0.000008&quot;)</span><span class="hljs-built_in">parseInt</span>( <span class="hljs-number">0.0000008</span> ); <span class="hljs-comment">// 8 (&quot;8&quot; 来自于 &quot;8e-7&quot;)</span><span class="hljs-built_in">parseInt</span>( <span class="hljs-literal">false</span>, <span class="hljs-number">16</span> ); <span class="hljs-comment">// 250 (&quot;fa&quot; 来自于 &quot;false&quot;)</span><span class="hljs-built_in">parseInt</span>( <span class="hljs-built_in">parseInt</span>, <span class="hljs-number">16</span> ); <span class="hljs-comment">// 15 (&quot;f&quot; 来自于 &quot;function..&quot;)</span><span class="hljs-built_in">parseInt</span>( <span class="hljs-string">&quot;0x10&quot;</span> ); <span class="hljs-comment">// 16</span><span class="hljs-built_in">parseInt</span>( <span class="hljs-string">&quot;103&quot;</span>, <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2</span><span class="hljs-built_in">parseInt</span>( <span class="hljs-number">1</span>/<span class="hljs-number">0</span>, <span class="hljs-number">19</span> ); <span class="hljs-comment">// 18 1/0回先转成字符串Infinity，i对应19进制的18，后面的不是数字，所以会被截取</span></code></pre></div><h3 id="显式转换为布尔值"><a href="#显式转换为布尔值" class="headerlink" title="显式转换为布尔值"></a>显式转换为布尔值</h3><p>显示的使用Boolean来将非boolean类型转成boolean类型比较少使用</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-keyword">var</span> b = [];<span class="hljs-keyword">var</span> c = &#123;&#125;;<span class="hljs-keyword">var</span> d = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> f = <span class="hljs-literal">null</span>;<span class="hljs-keyword">var</span> g;<span class="hljs-title class_">Boolean</span>( a ); <span class="hljs-comment">// true</span><span class="hljs-title class_">Boolean</span>( b ); <span class="hljs-comment">// true</span><span class="hljs-title class_">Boolean</span>( c ); <span class="hljs-comment">// true</span><span class="hljs-title class_">Boolean</span>( d ); <span class="hljs-comment">// false</span><span class="hljs-title class_">Boolean</span>( e ); <span class="hljs-comment">// false</span><span class="hljs-title class_">Boolean</span>( f ); <span class="hljs-comment">// false</span><span class="hljs-title class_">Boolean</span>( g ); <span class="hljs-comment">// false</span></code></pre></div><p>一元运算符 ! 显式地将值强制类型转换为布尔值。但是它同时还将真值反转为假值（或者将假值反转为真值）所以显式强制类型转换为布尔值最常用的方法是 !!，因为第二个 ! 会将结果反转回原值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-keyword">var</span> b = [];<span class="hljs-keyword">var</span> c = &#123;&#125;;<span class="hljs-keyword">var</span> d = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> f = <span class="hljs-literal">null</span>;<span class="hljs-keyword">var</span> g;!!a; <span class="hljs-comment">// true</span>!!b; <span class="hljs-comment">// true</span>!!c; <span class="hljs-comment">// true</span>!!d; <span class="hljs-comment">// false</span>!!e; <span class="hljs-comment">// false</span>!!f; <span class="hljs-comment">// false</span>!!g; <span class="hljs-comment">// false</span></code></pre></div><p>if(..).. 这样的布尔值上下文中，如果没有使用 Boolean(..) 和 !!，就会自动隐式地进行 ToBoolean 转换。建议使用 Boolean(..) 和 !! 来进行显式转换以便让代码更清晰易读。</p><h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><p>隐式强制类型转换的作用是减少冗余，让代码更简洁</p><h3 id="字符串和数字之间的隐式强制类型转换"><a href="#字符串和数字之间的隐式强制类型转换" class="headerlink" title="字符串和数字之间的隐式强制类型转换"></a>字符串和数字之间的隐式强制类型转换</h3><p>a + “”（隐式）和前面的 String(a)（显式）之间有一个细微的差别需要注意。根据ToPrimitive 抽象操作规则，a + “” 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。它们最后返回的都是字符串，但如果 a 是对象而非数字结果可能会不一样</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;, <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>; &#125;&#125;;a + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// &quot;42&quot;</span><span class="hljs-title class_">String</span>( a ); <span class="hljs-comment">// &quot;4&quot;</span></code></pre></div><p>再来看看从字符串强制类型转换为数字的情况。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;3.14&quot;</span>;<span class="hljs-keyword">var</span> b = a - <span class="hljs-number">0</span>;b; <span class="hljs-comment">// 3.14</span></code></pre></div><p>- 是数字减法运算符，因此 a - 0 会将 a 强制类型转换为数字。也可以使用 a * 1 和 a / 1，因为这两个运算符也只适用于数字，只不过这样的用法不太常见。</p><p>对象的 - 操作与 + 类似：</p><div class="code-wrapper"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> [<span class="hljs-number">3</span>]<span class="hljs-comment">;</span>var b <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<span class="hljs-comment">;</span>a - b<span class="hljs-comment">; // 2</span></code></pre></div><p>为了执行减法运算，a 和 b 都需要被转换为数字，它们首先被转换为字符串（通过toString()），然后再转换为数字。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onlyOne</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123; <span class="hljs-comment">// 跳过假值，和处理0一样，但是避免了NaN</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[i]) &#123; sum += <span class="hljs-variable language_">arguments</span>[i];<span class="hljs-comment">//这一步进行了隐式强制类型转换，将true转成1</span> &#125; &#125; <span class="hljs-keyword">return</span> sum == <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-literal">true</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-literal">false</span>;<span class="hljs-title function_">onlyOne</span>( b, a ); <span class="hljs-comment">// true</span><span class="hljs-title function_">onlyOne</span>( b, a, b, b, b ); <span class="hljs-comment">// true</span><span class="hljs-title function_">onlyOne</span>( b, b ); <span class="hljs-comment">// false</span><span class="hljs-title function_">onlyOne</span>( b, a, b, b, b, a ); <span class="hljs-comment">// false</span></code></pre></div><h3 id="隐式强制类型转换为布尔值"><a href="#隐式强制类型转换为布尔值" class="headerlink" title="隐式强制类型转换为布尔值"></a>隐式强制类型转换为布尔值</h3><p>(1) if (..) 语句中的条件判断表达式。</p><p>(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</p><p>(3) while (..) 和 do..while(..) 循环中的条件判断表达式。</p><p>(4) ? : 中的条件判断表达式。</p><p>(5) 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p><p>以上情况中，非布尔值会被隐式强制类型转换为布尔值，遵循前面介绍过的 ToBoolean 抽象操作规则。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-keyword">var</span> c;<span class="hljs-keyword">var</span> d = <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (a) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;yep&quot;</span> ); <span class="hljs-comment">// yep</span>&#125;<span class="hljs-keyword">while</span> (c) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;nope, never runs&quot;</span> );&#125;c = d ? a : b; c; <span class="hljs-comment">// &quot;abc&quot;</span><span class="hljs-keyword">if</span> ((a &amp;&amp; d) || c) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;yep&quot;</span> ); <span class="hljs-comment">// yep</span>&#125;</code></pre></div><h3 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h3><p>JavaScript 中它们返回的并不是布尔值</p><p>它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-keyword">var</span> c = <span class="hljs-literal">null</span>;a || b; <span class="hljs-comment">// 42 </span>a &amp;&amp; b; <span class="hljs-comment">// &quot;abc&quot;</span>c || b; <span class="hljs-comment">// &quot;abc&quot; </span>c &amp;&amp; b; <span class="hljs-comment">// null</span></code></pre></div><p>在 C 和 PHP 中，上例的结果是 true 或 false，在 JavaScript（以及 Python 和 Ruby）中却是某个操作数的值。</p><p>|| 和 &amp;&amp; 首先会对第一个操作数（a 和 c）执行条件判断，如果其不是布尔值（如上例）就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p><p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数（a 和 c）的值，如果为false 就返回第二个操作数（b）的值。</p><p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数（b）的值，如果为 false 就返回第一个操作数（a 和 c）的值。</p><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果（其中可能涉及强制类型转换）。c &amp;&amp; b 中 c 为 null，是一个假值，因此 &amp;&amp; 表达式的结果是 null（即 c 的值），而非条件判断的结果 false。</p><h3 id="符号的强制类型转换"><a href="#符号的强制类型转换" class="headerlink" title="符号的强制类型转换"></a>符号的强制类型转换</h3><p>Symbol只能进行显示的强制类型转换，而不能进行隐式的强制类型转换</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-title class_">Symbol</span>( <span class="hljs-string">&quot;cool&quot;</span> );<span class="hljs-title class_">String</span>( s1 ); <span class="hljs-comment">// &quot;Symbol(cool)&quot;</span><span class="hljs-keyword">var</span> s2 = <span class="hljs-title class_">Symbol</span>( <span class="hljs-string">&quot;not cool&quot;</span> );s2 + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// TypeError</span></code></pre></div><p>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true）。由于规则缺乏一致性，我们要对 ES6 中符号的强制类型转换多加小心。</p><h2 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h2><p>宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。</p><p>常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”。听起来蛮有道理，然而还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。</p><p>正确的解释是：“== 允许在相等比较中进行强制类型转换，而 === 不允许。”</p><h3 id="相等比较操作的性能"><a href="#相等比较操作的性能" class="headerlink" title="相等比较操作的性能"></a>相等比较操作的性能</h3><p>如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎实现上的细微差别之外，它们之间并没有什么不同。</p><p>如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 ==，没有就用 ===，不用在乎性能。</p><p>== 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。</p><p>在==进行强制类型转换时，</p><p>x==y</p><p>(1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。</p><p>(2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。</p><p>如果比较的双方有一个是boolean，可以先转成数组，再进行比较，如果两个类型还不一致，再进行转换</p><p>(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；</p><p>(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;42&quot;</span>;<span class="hljs-comment">// 不要这样用，条件判断不成立：</span><span class="hljs-keyword">if</span> (a == <span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">// .. </span>&#125;<span class="hljs-comment">// 也不要这样用，条件判断不成立：</span><span class="hljs-keyword">if</span> (a === <span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">// .. </span>&#125;<span class="hljs-comment">// 这样的显式用法没问题：</span><span class="hljs-keyword">if</span> (a) &#123; <span class="hljs-comment">// ..</span>&#125;<span class="hljs-comment">// 这样的显式用法更好：</span><span class="hljs-keyword">if</span> (!!a) &#123; <span class="hljs-comment">// .. </span>&#125;<span class="hljs-comment">// 这样的显式用法也很好：</span><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Boolean</span>( a )) &#123; <span class="hljs-comment">// .. </span>&#125;</code></pre></div><p>null 和 undefined 之间的相等比较</p><p>null 和 undefined 之间的 == 也涉及隐式强制类型转换</p><p>(1) 如果 x 为 null，y 为 undefined，则结果为 true。</p><p>(2) 如果 x 为 undefined，y 为 null，则结果为 true。</p><p>在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<span class="hljs-keyword">var</span> b;a == b; <span class="hljs-comment">// true</span>a == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>b == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>a == <span class="hljs-literal">false</span>; <span class="hljs-comment">// false</span>b == <span class="hljs-literal">false</span>; <span class="hljs-comment">// false</span>a == <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// false</span>b == <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// false</span>a == <span class="hljs-number">0</span>; <span class="hljs-comment">// false</span>b == <span class="hljs-number">0</span>; <span class="hljs-comment">// false</span></code></pre></div><p>只能null==undefined才是true，其他情况下包括falde，“”，0，这些假值在==中和undefiend，null比较都是false</p><p>对象和非对象之间的相等比较</p><p>关于对象（对象 / 函数 / 数组）和标量基本类型（字符串 / 数字 / 布尔值）之间的相等比较，ES5 规范 11.9.3.8-9 做如下规定：</p><p>(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；</p><p>(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p><p>这里只提到了字符串和数字，没有布尔值。原因是我们之前介绍过 11.9.3.6-7中规定了布尔值会先被强制类型转换为数字。</p><h3 id="比较少见的情况"><a href="#比较少见的情况" class="headerlink" title="比较少见的情况"></a>比较少见的情况</h3><h4 id="返回其他数字"><a href="#返回其他数字" class="headerlink" title="返回其他数字"></a>返回其他数字</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;&#125;;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>( <span class="hljs-number">2</span> ) == <span class="hljs-number">3</span>; <span class="hljs-comment">// true</span></code></pre></div><p>还有更奇怪的情况：</p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">if</span> <span class="hljs-params">(<span class="hljs-attr">a</span> == 2 &amp;&amp; <span class="hljs-attr">a</span> == 3)</span> &#123; <span class="hljs-string">//</span> <span class="hljs-string">..</span>&#125;</code></pre></div><p>你也许觉得这不可能，因为 a 不会同时等于 2 和 3。但“同时”一词并不准确，因为 a == 2 在 a == 3 之前执行。</p><p>如果让 a.valueOf() 每次调用都产生副作用，比如第一次返回 2，第二次返回 3，就会出现这样的情况。这实现起来很简单：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> i = <span class="hljs-number">2</span>;<span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> i++;&#125;;<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>( <span class="hljs-number">42</span> );<span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Yep, this happened.&quot;</span> );&#125;</code></pre></div><h4 id="假值的相等比较"><a href="#假值的相等比较" class="headerlink" title="假值的相等比较"></a>假值的相等比较</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-literal">false</span>; <span class="hljs-comment">// true -- 晕！</span><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// false</span><span class="hljs-literal">false</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span><span class="hljs-literal">false</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span><span class="hljs-literal">false</span> == <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span><span class="hljs-literal">false</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true -- 晕！</span><span class="hljs-literal">false</span> == <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// true -- 晕！</span><span class="hljs-literal">false</span> == []; <span class="hljs-comment">// true -- 晕！</span><span class="hljs-literal">false</span> == &#123;&#125;; <span class="hljs-comment">// false</span><span class="hljs-string">&quot;&quot;</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span><span class="hljs-string">&quot;&quot;</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span><span class="hljs-string">&quot;&quot;</span> == <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span><span class="hljs-string">&quot;&quot;</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true -- 晕！</span><span class="hljs-string">&quot;&quot;</span> == []; <span class="hljs-comment">// true -- 晕！</span><span class="hljs-string">&quot;&quot;</span> == &#123;&#125;; <span class="hljs-comment">// false</span><span class="hljs-number">0</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span><span class="hljs-number">0</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span><span class="hljs-number">0</span> == <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span><span class="hljs-number">0</span> == []; <span class="hljs-comment">// true -- 晕！</span><span class="hljs-number">0</span> == &#123;&#125;; <span class="hljs-comment">// false</span></code></pre></div><h4 id="极端情况"><a href="#极端情况" class="headerlink" title="极端情况"></a>极端情况</h4><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[]</span> == !<span class="hljs-selector-attr">[]</span> <span class="hljs-comment">// true</span></code></pre></div><p>根据 ToBoolean 规则，它会进行布尔值的显式强制类型转换（同时反转奇偶校验位）。所以 [] == ![] 变成了 [] == false。前面我们讲过 false == []，最后的结果就顺理成章了。</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>== [<span class="hljs-number">2</span>]; // true<span class="hljs-string">&quot;&quot;</span> == [null]; // true</code></pre></div><p>== 右边的值 [2] 和 [null] 会进行 ToPrimitive 强制类型转换，以便能够和左边的基本类型值（2 和 “”）进行比较。因为数组的 valueOf() 返回数组本身，所以强制类型转换过程中数组会进行字符串化。</p><p>第一行中的 [2] 会转换为 “2”，然后通过 ToNumber 转换为 2。第二行中的 [null] 会直接转换为 “”。所以最后的结果就是 2 == 2 和 “” == “”。</p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>== <span class="hljs-string">&quot;\n&quot;</span>; // true</code></pre></div><p>“”、”\n”（或者 “ “ 等其他空格组合）等空字符串被 ToNumber 强制类型转换为 0</p><h4 id="安全运用隐式强制类型转换"><a href="#安全运用隐式强制类型转换" class="headerlink" title="安全运用隐式强制类型转换"></a>安全运用隐式强制类型转换</h4><p>我们要对 == 两边的值认真推敲，以下两个原则可以让我们有效地避免出错。</p><p>• 如果两边的值中有 true 或者 false，千万不要使用 ==。</p><p>• 如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。</p><p>这时最好用 === 来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。</p><p>有一种情况下强制类型转换是绝对安全的，那就是 typeof 操作。typeof 总是返回七个字符串之一（参见第 1 章），其中没有空字符串。所以在类型检查过程中不会发生隐式强制类型转换。typeof x == “function” 是 100% 安全的，和 typeof x === “function” 一样。事实上两者在规范中是一回事。所以既不要盲目听命于代码工具每一处都用 ===，更不要对这个问题置若罔闻。我们要对自己的代码负责。</p><p>Alex Dorey（GitHub 用户名 @dorey）在 GitHub 上制作了一张图表，列出了各种相等比较的情况</p><p><a href="https://dorey.github.io/JavaScript-Equality-Table/unified/">https://dorey.github.io/JavaScript-Equality-Table/unified/</a></p><p><img src="https://raw.githubusercontent.com/yangzeng-cell/blog-images/master/%E6%88%AA%E5%B1%8F2023-01-27%2014.44.30.png"></p><h2 id="抽象关系比较"><a href="#抽象关系比较" class="headerlink" title="抽象关系比较"></a>抽象关系比较</h2><p>a &lt; b 中涉及的隐式强制类型转换</p><p>比较双方首先调用 ToPrimitive，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">42</span> ];<span class="hljs-keyword">var</span> b = [ <span class="hljs-string">&quot;43&quot;</span> ];a &lt; b; <span class="hljs-comment">// true</span>b &lt; a; <span class="hljs-comment">// false</span></code></pre></div><p>如果比较双方都是字符串，则按字母顺序来进行比较：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-string">&quot;42&quot;</span> ];<span class="hljs-keyword">var</span> b = [ <span class="hljs-string">&quot;043&quot;</span> ];a &lt; b; <span class="hljs-comment">// false</span></code></pre></div><p>a 和 b 并没有被转换为数字，因为 ToPrimitive 返回的是字符串，所以这里比较的是 “42” 和 “043” 两个字符串，它们分别以 “4” 和 “0” 开头。因为 “0” 在字母顺序上小于 “4”，所以最后结果为 false。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">4</span>, <span class="hljs-number">2</span> ];<span class="hljs-keyword">var</span> b = [ <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span> ];a &lt; b; <span class="hljs-comment">// false</span></code></pre></div><p>a 转换为 “4, 2”，b 转换为 “0, 4, 3”，同样是按字母顺序进行比较。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">42</span> &#125;;<span class="hljs-keyword">var</span> b = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">43</span> &#125;;a &lt; b; <span class="hljs-comment">// ??</span></code></pre></div><p>结果还是 false，因为 a 是 [object Object]，b 也是 [object Object]，所以按照字母顺序a &lt; b 并不成立。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">42</span> &#125;;<span class="hljs-keyword">var</span> b = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">43</span> &#125;;a &lt; b; <span class="hljs-comment">// false</span>a == b; <span class="hljs-comment">// false</span>a &gt; b; <span class="hljs-comment">// false</span>a &lt;= b; <span class="hljs-comment">// true</span>a &gt;= b; <span class="hljs-comment">// true</span></code></pre></div><p>是如果 a &lt; b 和 a == b 结果为 false，为什么 a &lt;= b 和 a &gt;= b 的结果会是 true 呢？</p><p>因为根据规范 a &lt;= b 被处理为 b &lt; a，然后将结果反转。因为 b &lt; a 的结果是 false，所以 a &lt;= b 的结果是 true。这可能与我们设想的大相径庭,即 &lt;= 应该是“小于或者等于”。实际上 JavaScript 中 &lt;= 是“不大于”的意思（即 !(a &gt; b)，处理为 !(b &lt; a)）。同理 a &gt;= b 处理为 b &lt;= a。</p><p>与 == 和 === 的完整性检查一样，我们应该在必要和安全的情况下使用强制类型转换，如：42 &lt; “43”。换句话说就是为了保证安全，应该对关系比较中的值进行显式强制类型转换：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">42</span> ];<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;043&quot;</span>;a &lt; b; <span class="hljs-comment">// false -- 字符串比较！</span><span class="hljs-title class_">Number</span>( a ) &lt; <span class="hljs-title class_">Number</span>( b ); <span class="hljs-comment">// true -- 数字比较！</span></code></pre></div><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><p>很多人不知道，语句都有一个结果值（statement completion value，undefined 也算）</p><p>获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示所执行的最后一条语句的结果值。</p><p>ES5 规 范 12.2 节中的变量声明（VariableDeclaration）算法实际上有一个返回值（是一个包含所声明变量名称的字符串，很奇特吧？），但是这个值被变量语句（VariableStatement）算法屏蔽掉了（for..in 循环除外），最后返回结果为空（undefined）。</p><p>比如代码块 { .. } 的结果值是其最后一个语句 / 表达式的结果。</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">var</span> b;<span class="hljs-attribute">if</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-attribute">b</span> = <span class="hljs-number">4</span> + <span class="hljs-number">38</span>;&#125;</code></pre></div><p>在控制台 /REPL 中输入以上代码应该会显示 42，即最后一个语句 / 表达式 b = 4 + 38 的结果值。换句话说，代码块的结果值就如同一个隐式的返回，即返回最后一个语句的结果值。</p><p>但下面这样的代码无法运行：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b;a = <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; b = <span class="hljs-number">4</span> + <span class="hljs-number">38</span>;&#125;;</code></pre></div><p>因为语法不允许我们获得语句的结果值并将其赋值给另一个变量（至少目前不行）</p><p>可以使用万恶的 eval(..)（又读作“evil”）来获得结果值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b;a = <span class="hljs-built_in">eval</span>( <span class="hljs-string">&quot;if (true) &#123; b = 4 + 38; &#125;&quot;</span> );a; <span class="hljs-comment">// 42</span></code></pre></div><p>ES7 规范有一项“do 表达式”（do expression）提案，类似下面这样：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b;a = <span class="hljs-keyword">do</span> &#123; <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; b = <span class="hljs-number">4</span> + <span class="hljs-number">38</span>;  &#125;&#125;;a; <span class="hljs-comment">// 42</span></code></pre></div><p>上例中，do { .. } 表达式执行一个代码块（包含一个或多个语句），并且返回其中最后一个语句的结果值，然后赋值给变量 a</p><h3 id="表达式的副作用"><a href="#表达式的副作用" class="headerlink" title="表达式的副作用"></a>表达式的副作用</h3><p>最常见的有副作用（也可能没有）的表达式是函数调用：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; a = a + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 结果值：undefined。副作用：a的值被改变</span></code></pre></div><p>其他一些表达式也有副作用，比如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;a++; <span class="hljs-comment">// 42</span>a; <span class="hljs-comment">// 43</span>++a; <span class="hljs-comment">// 44</span>a; <span class="hljs-comment">// 44</span></code></pre></div><p>除了赋值之外，还会自增。自增就是副作用</p><p>++a,它的副作用（将 a 递增）产生在表达式返回结果值之前，而 a++ 的副作用则产生在之后。</p><p>++a++ 会产生 ReferenceError 错误，因为运算符需要将产生的副作用赋值给一个变量。以 ++a++ 为例，它首先执行 a++（根据运算符优先级，如下），返回 42，然后执行 ++42，这时会产生 ReferenceError 错误，因为 ++ 无法直接在 42 这样的值上产生副作用。</p><p>常有人误以为可以用括号 ( ) 将 a++ 的副作用封装起来，例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<span class="hljs-keyword">var</span> b = (a++);a; <span class="hljs-comment">// 43</span>b; <span class="hljs-comment">// 42</span></code></pre></div><p>事实并非如此。( ) 本身并不是一个封装表达式，不会在表达式 a++ 产生副作用之后执行。即便可以，a++ 会首先返回 42，除非有表达式在 ++ 之后再次对 a 进行运算，否则还是不会得到 43，也就不能将 43 赋值给 b。</p><p>但也不是没有办法，可以使用 , 语句系列逗号运算符（statement-series comma operator）将多个独立的表达式语句串联成一个语句：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>, b;b = ( a++, a );a; <span class="hljs-comment">// 43</span>b; <span class="hljs-comment">// 43</span></code></pre></div><p>再如 delete 运算符。delete 用来删除对象中的属性和数组中的单元。它通</p><p>常以单独一个语句的形式出现：</p><div class="code-wrapper"><pre><code class="hljs awk">var obj = &#123; a: <span class="hljs-number">42</span>&#125;;obj.a; <span class="hljs-regexp">//</span> <span class="hljs-number">42</span><span class="hljs-keyword">delete</span> obj.a; <span class="hljs-regexp">//</span> trueobj.a; <span class="hljs-regexp">//</span> undefined</code></pre></div><p>如果操作成功，delete 返回 true，否则返回 false。其副作用是属性被从对象中删除（或者单元从 array 中删除）</p><p>另一个有趣的例子是 = 赋值运算符。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;a = <span class="hljs-number">42</span>; <span class="hljs-comment">// 42</span>a; <span class="hljs-comment">// 42</span></code></pre></div><p>a = 42 中的 = 运算符看起来没有副作用，实际上它的结果值是 42，它的副作用是将 42 赋值给 a。</p><h3 id="上下文规则"><a href="#上下文规则" class="headerlink" title="上下文规则"></a>上下文规则</h3><div class="code-wrapper"><pre><code class="hljs awk">[] + &#123;&#125;; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;[object Object]&quot;</span>&#123;&#125; + []; <span class="hljs-regexp">//</span> <span class="hljs-number">0</span></code></pre></div><p>表面上看 + 运算符根据第一个操作数（[] 或 {}）的不同会产生不同的结果，实则不然。第一行代码中，{} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。 [] 会被强制类型转换为 “”，而 {} 会被强制类型转换为 “[object Object]”。但在第二行代码中，{} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为 0。</p><p><strong>对象解构</strong></p><p>{ .. } 还可以用作函数命名参数（named function argument）的对象解构（object destructuring），方便隐式地用对象属性赋值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">&#123; a, b, c &#125;</span>) &#123; <span class="hljs-comment">// 不再需要这样:</span> <span class="hljs-comment">// var a = obj.a, b = obj.b, c = obj.c</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a, b, c );&#125;<span class="hljs-title function_">foo</span>( &#123; <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;foo&quot;</span>&#125; ); <span class="hljs-comment">// 42 &quot;foo&quot; [1, 2, 3]</span></code></pre></div><p>else if <strong>和可选代码块</strong></p><p>很多人误以为 JavaScript 中有 else if，因为我们可以这样来写代码：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (a) &#123;  <span class="hljs-comment">// ..</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b) &#123; <span class="hljs-comment">// .. </span>&#125;<span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// ..</span>&#125;</code></pre></div><p>事实上 JavaScript 没有 else if，但 if 和 else 只包含单条语句的时候可以省略代码块的x{ }。下面的代码你一定不会陌生：</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (a) <span class="hljs-keyword">do</span><span class="hljs-constructor">Something( <span class="hljs-params">a</span> )</span>;</code></pre></div><p>很多 JavaScript 代码检查工具建议对单条语句也应该加上 { }，如：</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (a) &#123; <span class="hljs-keyword">do</span><span class="hljs-constructor">Something( <span class="hljs-params">a</span> )</span>; &#125;</code></pre></div><p>else 也是如此，所以我们经常用到的 else if 实际上是这样的：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (a) &#123;  <span class="hljs-comment">// ..</span>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">if</span> (b) &#123;  <span class="hljs-comment">// ..</span> &#125;  <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// .. </span> &#125;</code></pre></div><p>if (b) { .. } else { .. } 实际上是跟在 else 后面的一个单独的语句，所以带不带 { } 都可以。换句话说，else if 不符合前面介绍的编码规范，else 中是一个单独的 if 语句。</p><p>else if 极为常见，能省掉一层代码缩进，所以很受青睐。但这只是我们自己发明的用法，切勿想当然地认为这些都属于 JavaScript 语法的范畴。</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>mdn运算符优先级列表：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p><h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>对 &amp;&amp; 和 || 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数。我们将这种现象称为“短路”（即执行最短路径）。</p><p>以 a &amp;&amp; b 为例，如果 a 是一个假值，足以决定 &amp;&amp; 的结果，就没有必要再判断 b 的值。同样对于 a || b，如果 a 是一个真值，也足以决定 || 的结果，也就没有必要再判断 b 的值。</p><p>“短路”很方便，也很常用，如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">opts</span>) &#123; <span class="hljs-keyword">if</span> (opts &amp;&amp; opts.<span class="hljs-property">cool</span>) &#123; <span class="hljs-comment">// .. </span> &#125;&#125;</code></pre></div><p>opts &amp;&amp; opts.cool 中的 opts 条件判断如同一道安全保护，因为如果 opts 未赋值（或者不是一个对象），表达式 opts.cool 会出错。通过使用短路特性，opts 条件判断未通过时opts.cool 就不会执行，也就不会产生错误！</p><p>|| 运算符也一样：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">opts</span>) &#123; <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">cache</span> || <span class="hljs-title function_">primeCache</span>()) &#123; <span class="hljs-comment">// .. </span> &#125;&#125;</code></pre></div><p>这里首先判断 opts.cache 是否存在，如果是则无需调用 primeCache() 函数，这样可以避免执行不必要的代码。</p><p>a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a=&gt;(a &amp;&amp; b || c) ? (c || b) ? a : (c &amp;&amp; b) : a</p><p>为 &amp;&amp; 运算符的优先级高于 ||，而 || 的优先级又高于 ? :。</p><h2 id="自动分号"><a href="#自动分号" class="headerlink" title="自动分号"></a>自动分号</h2><p>有时 JavaScript 会自动为代码行补上缺失的分号，即自动分号插入（Automatic Semicolon Insertion，ASI）。</p><p>因为如果缺失了必要的 ;，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的 ;。请注意，ASI 只在换行符处起作用，而不会在代码行的中间插入分号</p><p>如果 JavaScript 解析器发现代码行可能因为缺失分号而导致错误，那么它就会自动补上分号。并且，只有在代码行末尾与换行符之间除了空格和注释之外没有别的内容时，它才会这样做。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">var a</span> = 42, b c;</code></pre></div><p>如果 b 和 c 之间出现 a , 的话（即使另起一行），c 会被作为 var 语句的一部分来处理。在上例中，JavaScript 判断 b 之后应该有 ;，所以 c; 被处理为一个独立的表达式语句。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>, b = <span class="hljs-string">&quot;foo&quot;</span>;ab <span class="hljs-comment">// &quot;foo&quot;</span></code></pre></div><p>上述代码同样合法，不会产生错误，因为 ASI 也适用于表达式语句。</p><p>ASI 在某些情况下很有用，比如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<span class="hljs-keyword">do</span> &#123; <span class="hljs-comment">// ..</span>&#125; <span class="hljs-keyword">while</span> (a) <span class="hljs-comment">// &lt;-- 这里应该有;</span>a;</code></pre></div><p>语法规定 do..while 循环后面必须带 ;，而 while 和 for 循环后则不需要。大多数开发人员都不记得这一点，此时 ASI 就会自动补上分号。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;<span class="hljs-keyword">while</span> (a) &#123; <span class="hljs-comment">// ..</span>&#125; <span class="hljs-comment">// &lt;-- 这里可以没有;</span>a;</code></pre></div><p>其他涉及 ASI 的情况是 break、continue、return 和 yield（ES6）等关键字：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-keyword">if</span> (!a) <span class="hljs-keyword">return</span> a *= <span class="hljs-number">2</span>; <span class="hljs-comment">// .. </span>&#125;</code></pre></div><p>由于 ASI 会在 return 后面自动加上 ;，所以这里 return 语句并不包括第二行的 a *= 2。return 语句的跨度可以是多行，但是其后必须有换行符以外的代码：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-keyword">return</span> ( a * <span class="hljs-number">2</span> + <span class="hljs-number">3</span> / <span class="hljs-number">12</span>  );&#125;</code></pre></div><p>上述规则对 break、continue 和 yield 也同样适用。</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="提前使用变量"><a href="#提前使用变量" class="headerlink" title="提前使用变量"></a>提前使用变量</h3><p>ES6 规范定义了一个新概念，叫作 TDZ（Temporal Dead Zone，暂时性死区）。</p><p>TDZ 指的是由于代码中的变量还没有初始化而不能被引用的情况。</p><p>对此，最直观的例子是 ES6 规范中的 let 块作用域：</p><div class="code-wrapper"><pre><code class="hljs js">&#123; a = <span class="hljs-number">2</span>; <span class="hljs-comment">// ReferenceError!</span> <span class="hljs-keyword">let</span> a; &#125;</code></pre></div><p>a = 2 试图在 let a 初始化 a 之前使用该变量（其作用域在 { .. } 内），这里就是 a 的TDZ，会产生错误。</p><p>对未声明变量使用 typeof 不会产生错误，但在 TDZ 中却会报错：</p><div class="code-wrapper"><pre><code class="hljs js">&#123; <span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// undefined</span> <span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// ReferenceError! (TDZ)</span> <span class="hljs-keyword">let</span> b;&#125;</code></pre></div><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>另一个 TDZ 违规的例子是 ES6 中的参数默认值</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"> a = <span class="hljs-number">42</span>, b = a + b + <span class="hljs-number">5</span> </span>) &#123; <span class="hljs-comment">// ..</span>&#125;</code></pre></div><p>b = a + b + 5 在参数 b（= 右边的 b，而不是函数外的那个）的 TDZ 中访问 b，所以会出错。而访问 a 却没有问题，因为此时刚好跨出了参数 a 的 TDZ。</p><p>对 ES6 中的参数默认值而言，参数被省略或被赋值为 undefined 效果都一样，都是取该参数的默认值。然而某些情况下，它们之间还是有区别的：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"> a = <span class="hljs-number">42</span>, b = a + <span class="hljs-number">1</span> </span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>, a, b, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] );&#125;<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 0 42 43 undefined undefined</span><span class="hljs-title function_">foo</span>( <span class="hljs-number">10</span> ); <span class="hljs-comment">// 1 10 11 10 undefined</span><span class="hljs-title function_">foo</span>( <span class="hljs-number">10</span>, <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// 2 10 11 10 undefined</span><span class="hljs-title function_">foo</span>( <span class="hljs-number">10</span>, <span class="hljs-literal">null</span> ); <span class="hljs-comment">// 2 10 null 10 null</span></code></pre></div><p>虽然参数 a 和 b 都有默认值，但是函数不带参数时，arguments 数组为空,相反，如果向函数传递 undefined 值，则 arguments 数组中会出现一个值为 undefined 的单元，而不是默认值。</p><p>ES6 参数默认值会导致 arguments 数组和相对应的命名参数之间出现偏差，ES5 也会出现这种情况：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; a = <span class="hljs-number">42</span>; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] );&#125;<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 42 (linked)</span><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// undefined (not linked)</span></code></pre></div><p>向函数传递参数时，arguments 数组中的对应单元会和命名参数建立关联（linkage）以得到相同的值。相反，不传递参数就不会建立关联。</p><p>但是，在严格模式中并没有建立关联这一说：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-string">&quot;use strict&quot;</span>; a = <span class="hljs-number">42</span>; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] );&#125;<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2 (not linked)</span><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// undefined (not linked)</span></code></pre></div><p>因此，在开发中不要依赖这种关联机制。实际上，它是 JavaScript 语言引擎底层实现的一个抽象泄漏（leaky abstraction），并不是语言本身的特性。</p><p>在 ES6 之前，获得函数所有参数的唯一途径就是 arguments 数组。此外，即使将命名参数和 arguments 数组混用也不会出错，只需遵守一个原则，即不要同时访问命名参数和其对应的 arguments 数组单元。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a + <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 安全! &#125;</span><span class="hljs-title function_">foo</span>( <span class="hljs-number">10</span>, <span class="hljs-number">32</span> ); <span class="hljs-comment">// 42</span></code></pre></div><h2 id="try-finally"><a href="#try-finally" class="headerlink" title="try..finally"></a>try..finally</h2><p>finally 中的代码总是会在 try 之后执行，如果有 catch 的话则在 catch 之后执行。也可以将 finally 中的代码看作一个回调函数，即无论出现什么情况最后一定会被调用。</p><p>如果 try 中有 return 语句会出现什么情况呢？ return 会返回一个值，那么调用该函数得到返回值的代码是在 finally 之前还是之后执行呢？</p><div class="code-wrapper"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;  <span class="hljs-keyword">finally</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Hello&quot;</span> ); &#125; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;never runs&quot;</span> );&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">foo</span>() );<span class="hljs-comment">// Hello</span><span class="hljs-comment">// 42</span></code></pre></div><p>这里 return 42 先执行，并将 foo() 函数的返回值设置为 42。然后 try 执行完毕，接着执行 finally。最后 foo() 函数执行完毕，console.log(..) 显示返回值。</p><p>try 中的 throw 也是如此</p><div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-number">42</span>;  &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Hello&quot;</span> ); &#125; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;never runs&quot;</span> );&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">foo</span>() );<span class="hljs-comment">// Hello</span><span class="hljs-comment">// Uncaught Exception: 42</span></code></pre></div><p>如果 finally 中抛出异常（无论是有意还是无意），函数就会在此处终止。如果此前 try 中已经有 return 设置了返回值，则该值会被丢弃：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;  <span class="hljs-keyword">finally</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Oops!&quot;</span>; &#125; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;never runs&quot;</span> );&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">foo</span>() );<span class="hljs-comment">// Uncaught Exception: Oops!</span></code></pre></div><p>continue 和 break 等控制语句也是如此</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">continue</span>;  &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); &#125;&#125;<span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9</span></code></pre></div><p>continue 在每次循环之后，会在 i++ 执行之前执行 console.log(i)，所以结果是 0..9 而非1..10。</p><p>ES6 中新加入了 yield，可以将其视为return 的中间版本。然而与 return 不同的是，yield 在 generator（ES6 的另一个新特性）重新开始时才结束，这意味着 try { .. yield .. } 并未结束，因此 finally 不会在 yield 之后立即执行。</p><p>finally 中的 return 会覆盖 try 和 catch 中 return 的返回值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;  <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 没有返回语句，所以没有覆盖</span> &#125; &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 覆盖前面的 return 42</span> <span class="hljs-keyword">return</span>;  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;  <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 覆盖前面的 return 42</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>; &#125;&#125;<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 42</span><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// undefined</span><span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// Hello</span></code></pre></div><p>通常来说，在函数中省略 return 的结果和 return; 及 return undefined; 是一样的，但是在 finally 中省略 return 则会返回前面的 return 设定的返回值。</p><p>事实上，还可以将 finally 和带标签的 break 混合使用</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-attr">bar</span>: &#123; <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;  <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// 跳出标签为bar的代码块</span> <span class="hljs-keyword">break</span> bar; &#125; &#125; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Crazy&quot;</span> );  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">foo</span>() );<span class="hljs-comment">// Crazy</span><span class="hljs-comment">// Hello</span></code></pre></div><p>但切勿这样操作。利用 finally 加带标签的 break 来跳过 return 只会让代码变得晦涩难懂，即使加上注释也是如此</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (a) &#123; <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 执行一些代码</span> <span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> <span class="hljs-number">42</span>: <span class="hljs-comment">// 执行另外一些代码</span> <span class="hljs-keyword">break</span>; <span class="hljs-attr">default</span>: <span class="hljs-comment">// 执行缺省代码</span>&#125;</code></pre></div><p>首先，a 和 case 表达式的匹配算法与 ===相同。通常 case 语句中的 switch都是简单值</p><p>有时候需要使用强制类型转换，就是需要使用==进行比较，需要特殊处理</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;42&quot;</span>;<span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-keyword">case</span> a == <span class="hljs-number">10</span>: <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;10 or &#x27;10&#x27;&quot;</span> ); <span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> a == <span class="hljs-number">42</span>; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;42 or &#x27;42&#x27;&quot;</span> ); <span class="hljs-keyword">break</span>; <span class="hljs-attr">default</span>: <span class="hljs-comment">// 永远执行不到这里</span>&#125;<span class="hljs-comment">// 42 or &#x27;42&#x27;</span></code></pre></div><p>除简单值以外，case 中还可以出现各种表达式，它会将表达式的结果值和 true 进行比较。因为 a == 42 的结果为 true，所以条件成立。</p><p>尽管可以使用 ==，但 switch 中 true 和 true 之间仍然是严格相等比较。即如果 case 表达式的结果为真值，但不是严格意义上的 true，则条件不成立。所以，在这里使用 || 和 &amp;&amp; 等逻辑运算符就很容易掉进坑里：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;hello world&quot;</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-keyword">case</span> (a || b == <span class="hljs-number">10</span>): <span class="hljs-comment">// 永远执行不到这里</span> <span class="hljs-keyword">break</span>; <span class="hljs-attr">default</span>: <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> );&#125;<span class="hljs-comment">// Oops</span></code></pre></div><p>因为 (a || b == 10) 的结果是 “hello world” 而非 true，所以严格相等比较不成立。此时可以通过强制表达式返回 true 或 false，如 case !!(a || b == 10)</p><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="分块的程序"><a href="#分块的程序" class="headerlink" title="分块的程序"></a>分块的程序</h2><h3 id="异步控制台"><a href="#异步控制台" class="headerlink" title="异步控制台"></a>异步控制台</h3><p>并没有什么规范或一组需求指定 console.* 方法族如何工作——它们并不是 JavaScript 正式的一部分，而是由宿主环境添加到 JavaScript 中的。因此，不同的浏览器和 JavaScript 环境可以按照自己的意愿来实现，有时候这会引起混淆。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>那么，什么是事件循环？</p><p>先通过一段伪代码了解一下这个概念 :</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// eventLoop是一个用作队列的数组</span><span class="hljs-comment">// （先进，先出）</span><span class="hljs-keyword">var</span> eventLoop = [ ];<span class="hljs-keyword">var</span> event;<span class="hljs-comment">// “永远”执行</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">// 一次tick</span> <span class="hljs-keyword">if</span> (eventLoop.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 拿到队列中的下一个事件</span> event = eventLoop.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 现在，执行下一个事件</span> <span class="hljs-keyword">try</span> &#123; <span class="hljs-title function_">event</span>(); &#125; <span class="hljs-keyword">catch</span> (err) &#123; <span class="hljs-title function_">reportError</span>(err);   &#125; &#125;&#125;</code></pre></div><p>这当然是一段极度简化的伪代码，只用来说明概念。不过它应该足以用来帮助大家有更好的理解。</p><p>你可以看到，有一个用 while 循环实现的持续运行的循环，循环的每一轮称为一个 tick。对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这些事件就是你的回调函数。</p><p>一定要清楚，setTimeout(..) 并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。</p><p>如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么setTimeout(..) 定时器的精度可能不高。大体说来，只能确保你的回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，要根据事件队列的状态而定。</p><p>所以换句话说就是，程序通常分成了很多小块，在事件循环队列中一个接一个地执行。严格地说，和你的程序不直接相关的其他事件也可能会插入到队列中</p><h2 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h2><p>术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。记住，异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情</p><p>并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。</p><p>与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。</p><p>并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">later</span>(<span class="hljs-params"></span>) &#123;  answer = answer * <span class="hljs-number">2</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Meaning of life:&quot;</span>, answer ); &#125;</code></pre></div><p>尽管 later() 的所有内容被看作单独的一个事件循环队列表项，但如果考虑到这段代码是运行在一个线程中，实际上可能有很多个不同的底层运算。比如，answer = answer * 2 需要先加载 answer 的当前值，然后把 2 放到某处并执行乘法，取得结果之后保存回 answer 中。</p><p>在单线程环境中，线程队列中的这些项目是底层运算确实是无所谓的，因为线程本身不会被中断。但如果是在并行系统中，同一个程序中可能有两个不同的线程在运转，这时很可能就会得到不确定的结果。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  a = a + <span class="hljs-number">1</span>; &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  a = a * <span class="hljs-number">2</span>; &#125; <span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div><p>根据 JavaScript 的单线程运行特性，如果 foo() 运行在 bar() 之前，a 的结果是 42，而如果bar() 运行在 foo() 之前的话，a 的结果就是 41。</p><p>如果共享同一数据的 JavaScript 事件并行执行的话，那么问题就变得更加微妙了。考虑foo() 和 bar() 中代码运行的线程分别执行的是以下两段伪代码任务，然后思考一下如果它们恰好同时运行的话会出现什么情况。</p><p>线程 1（X 和 Y 是临时内存地址）：</p><div class="code-wrapper"><pre><code class="hljs tp">foo():  a. 把a的值加载到<span class="hljs-keyword">X</span>  b. 把<span class="hljs-number">1</span>保存在<span class="hljs-keyword">Y</span>  c. 执行<span class="hljs-keyword">X</span>加<span class="hljs-keyword">Y</span>，结果保存在<span class="hljs-keyword">X</span>  d. 把<span class="hljs-keyword">X</span>的值保存在a</code></pre></div><p>线程 2（X 和 Y 是临时内存地址）：</p><div class="code-wrapper"><pre><code class="hljs tp">bar():  a. 把a的值加载到<span class="hljs-keyword">X</span>  b. 把<span class="hljs-number">2</span>保存在<span class="hljs-keyword">Y</span>  c. 执行<span class="hljs-keyword">X</span>乘<span class="hljs-keyword">Y</span>，结果保存在<span class="hljs-keyword">X</span>  d. 把<span class="hljs-keyword">X</span>的值保存在a</code></pre></div><p>现在，假设两个线程并行执行。你可能已经发现了这个程序的问题，是吧？它们在临时步骤中使用了共享的内存地址 X 和 Y。</p><p>如果按照以下步骤执行，最终结果将会是什么样呢？</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-number">1</span>a (把a的值加载到X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) <span class="hljs-number">2</span>a (把a的值加载到X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) <span class="hljs-number">1</span>b (把<span class="hljs-number">1</span>保存在Y <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">1</span>) <span class="hljs-number">2</span>b (把<span class="hljs-number">2</span>保存在Y <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">2</span>) <span class="hljs-number">1</span>c (执行X加Y，结果保存在X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">22</span>) <span class="hljs-number">1</span>d (把X的值保存在a <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">22</span>) <span class="hljs-number">2</span>c (执行X乘Y，结果保存在X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">44</span>) <span class="hljs-number">2</span>d (把X的值保存在a <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">44</span>)</code></pre></div><p>a 的结果将是 44。但如果按照以下顺序执行呢？</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-number">1</span>a (把a的值加载到X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) <span class="hljs-number">2</span>a (把a的值加载到X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) <span class="hljs-number">2</span>b (把<span class="hljs-number">2</span>保存在Y <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">2</span>) <span class="hljs-number">1</span>b (把<span class="hljs-number">1</span>保存在Y <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">1</span>) <span class="hljs-number">2</span>c (执行X乘Y，结果保存在X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) <span class="hljs-number">1</span>c (执行X加Y，结果保存在X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">21</span>) <span class="hljs-number">1</span>d (把X的值保存在a <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">21</span>) <span class="hljs-number">2</span>d (把X的值保存在a <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">21</span>)</code></pre></div><p>a 的结果将是 21。</p><p>所以，多线程编程是非常复杂的。因为如果不通过特殊的步骤来防止这种中断和交错运行的话，可能会得到出乎意料的、不确定的行为，通常这很让人头疼。</p><p>JavaScript 从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。但是这并不意味着 JavaScript 总是确定性的。回忆一下前面提到的，foo() 和 bar() 的相对顺序改变可能会导致不同结果（41 或 42）。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>单线程事件循环是并发的一种形式</p><h3 id="非交互"><a href="#非交互" class="headerlink" title="非交互"></a>非交互</h3><p>两个或多个“进程”在同一个程序内并发地交替运行它们的步骤 / 事件时，如果这些任务彼此不相关，就不一定需要交互。如果进程间没有相互影响的话，不确定性是完全可以接受的。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = &#123;&#125;; <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">results</span>) &#123;  res.<span class="hljs-property">foo</span> = results; &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">results</span>) &#123;  res.<span class="hljs-property">bar</span> = results; &#125; <span class="hljs-comment">// ajax(..)是某个库提供的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div><p>foo() 和 bar() 是两个并发执行的“进程”，按照什么顺序执行是不确定的。但是，我们构建程序的方式使得无论按哪种顺序执行都无所谓，因为它们是独立运行的，不会相互影响。</p><p>这并不是竞态条件 bug，因为不管顺序如何，代码总会正常工作。</p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>更常见的情况是，并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。正如前面介绍的，如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = []; <span class="hljs-keyword">function</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">data</span>) &#123;  res.<span class="hljs-title function_">push</span>( data ); &#125; <span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, response ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, response );</code></pre></div><p>这里的并发“进程”是这两个用来处理 Ajax 响应的 response() 调用。它们可能以任意顺序运行。</p><p>我们假定期望的行为是 res[0] 中放调用 “<a href="http://some.url.1&quot;/">http://some.url.1&quot;</a> 的结果，res[1] 中放调用”<a href="http://some.url.2&quot;/">http://some.url.2&quot;</a> 的结果。有时候可能是这样，但有时候却恰好相反，这要视哪个调用先完成而定。</p><p>这种不确定性很有可能就是一个竞态条件 bug</p><p>所以，可以协调交互顺序来处理这样的竞态条件：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = []; <span class="hljs-keyword">function</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">data</span>) &#123;  <span class="hljs-keyword">if</span> (data.<span class="hljs-property">url</span> == <span class="hljs-string">&quot;http://some.url.1&quot;</span>) &#123;  res[<span class="hljs-number">0</span>] = data;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">url</span> == <span class="hljs-string">&quot;http://some.url.2&quot;</span>) &#123;  res[<span class="hljs-number">1</span>] = data;  &#125; &#125; <span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, response ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, response );</code></pre></div><p>不管哪一个 Ajax 响应先返回，我们都要通过查看 data.url（当然，假定从服务器总会返回一个！）判断应该把响应数据放在 res 数组中的什么位置上。res[0] 总是包含 “<a href="http://some.url.1&quot;/">http://some.url.1&quot;</a> 的结果，res[1] 总是包含 “<a href="http://some.url.2&quot;/">http://some.url.2&quot;</a> 的结果。通过简单的协调，就避免了竞态条件引起的不确定性。</p><p>从这个场景推出的方法也可以应用于多个并发函数调用通过共享 DOM 彼此之间交互的情况，比如一个函数调用更新某个 <div> 的内容，另外一个更新这个 <div> 的风格或属性（比如使这个 DOM 元素一有内容就显示出来）。可能你并不想在这个 DOM 元素在拿到内容之前显示出来，所以这种协调必须要保证正确的交互顺序。</p><p>有些并发场景如果不做协调，就总是（并非偶尔）会出错。考虑：</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a, b; <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123; a = x * <span class="hljs-number">2</span>;  baz(); &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">y</span>) &#123;  b = y * <span class="hljs-number">2</span>;  baz(); &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a + b); &#125; <span class="hljs-comment">// ajax(..)是某个库中的某个Ajax函数</span>ajax( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); ajax( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div><p>在这个例子中，无论 foo() 和 bar() 哪一个先被触发，总会使 baz() 过早运行（a 或者 b 仍处于未定义状态）；但对 baz() 的第二次调用就没有问题，因为这时候 a 和 b 都已经可用了</p><p>要解决这个问题有多种方法。这里给出了一种简单方法：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b; <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;  a = x * <span class="hljs-number">2</span>;  <span class="hljs-keyword">if</span> (a &amp;&amp; b) &#123;  <span class="hljs-title function_">baz</span>();  &#125; &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">y</span>) &#123;  b = y * <span class="hljs-number">2</span>;  <span class="hljs-keyword">if</span> (a &amp;&amp; b) &#123;  <span class="hljs-title function_">baz</span>();  &#125; &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a + b ); &#125; <span class="hljs-comment">// ajax(..)是某个库中的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div><p>包裹 baz() 调用的条件判断 if (a &amp;&amp; b) 传统上称为门（gate），我们虽然不能确定 a 和 b到达的顺序，但是会等到它们两个都准备好再进一步打开门（调用 baz()）。</p><p>另一种可能遇到的并发交互条件有时称为竞态（race），但是更精确的叫法是门闩（latch）。它的特性可以描述为“只有第一名取胜”。在这里，不确定性是可以接受的，因为它明确指出了这一点是可以接受的：需要“竞争”到终点，且只有唯一的胜利者</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a; <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;  a = x * <span class="hljs-number">2</span>;  <span class="hljs-title function_">baz</span>(); &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x</span>) &#123;  a = x / <span class="hljs-number">2</span>;  <span class="hljs-title function_">baz</span>(); &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); &#125; <span class="hljs-comment">// ajax(..)是某个库中的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div><p>不管哪一个（foo() 或 bar()）后被触发，都不仅会覆盖另外一个给 a 赋的值，也会重复调用 baz()（很可能并不是想要的结果）。</p><p>所以，可以通过一个简单的门闩协调这个交互过程，只让第一个通过：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a; <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;  <span class="hljs-keyword">if</span> (!a) &#123;  a = x * <span class="hljs-number">2</span>;  <span class="hljs-title function_">baz</span>();  &#125; &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x</span>) &#123;  <span class="hljs-keyword">if</span> (!a) &#123;  a = x / <span class="hljs-number">2</span>;  <span class="hljs-title function_">baz</span>();  &#125; &#125; <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); &#125; <span class="hljs-comment">// ajax(..)是某个库中的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div><p>条件判断 if (!a) 使得只有 foo() 和 bar() 中的第一个可以通过，第二个（实际上是任何后续的）调用会被忽略。也就是说，第二名没有任何意义！</p><h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>还有一种并发合作方式，称为并发协作（cooperative concurrency）。这里的重点不再是通过共享作用域中的值进行交互（尽管显然这也是允许的！）。这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = []; <span class="hljs-comment">// response(..)从Ajax调用中取得结果数组</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">data</span>) &#123;  <span class="hljs-comment">// 添加到已有的res数组</span> res = res.<span class="hljs-title function_">concat</span>(  <span class="hljs-comment">// 创建一个新的变换数组把所有data值加倍</span> data.<span class="hljs-title function_">map</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>;  &#125; )  ); &#125; <span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, response ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, response )</code></pre></div><p>如果 “<a href="http://some.url.1&quot;/">http://some.url.1&quot;</a> 首先取得结果，那么整个列表会立刻映射到 res 中。如果记录有几千条或更少，这不算什么。但是如果有像 1000 万条记录的话，就可能需要运行相当一段时间了（在高性能笔记本上需要几秒钟，在移动设备上需要更长时间，等等）。</p><p>这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的 response(..)调用或 UI 刷新，甚至是像滚动、输入、按钮点击这样的用户事件。这是相当痛苦的</p><p>所以，要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，你可以异步地批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = []; <span class="hljs-comment">// response(..)从Ajax调用中取得结果数组</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">data</span>) &#123;  <span class="hljs-comment">// 一次处理1000个</span> <span class="hljs-keyword">var</span> chunk = data.<span class="hljs-title function_">splice</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1000</span> );  <span class="hljs-comment">// 添加到已有的res组</span> res = res.<span class="hljs-title function_">concat</span>(  <span class="hljs-comment">// 创建一个新的数组把chunk中所有值加倍</span> chunk.<span class="hljs-title function_">map</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>;  &#125; )  );  <span class="hljs-comment">// 还有剩下的需要处理吗？</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 异步调度下一次批处理</span> <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-title function_">response</span>( data );  &#125;, <span class="hljs-number">0</span> );  &#125; &#125; <span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span><span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, response ); <span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, response );</code></pre></div><p>我们把数据集合放在最多包含 1000 条项目的块中。这样，我们就确保了“进程”运行时间会很短，即使这意味着需要更多的后续“进程”，因为事件循环队列的交替运行会提高站点 /App 的响应（性能）。</p><p>这里使用 setTimeout(..0)（hack）进行异步调度，基本上它的意思就是“把这个函数插入到当前事件循环队列的结尾处”。</p><p>严格说来，setTimeout(..0) 并不直接把项目插入到事件循环队列。定时器会在有机会的时候插入事件。举例来说，两个连续的 setTimeout(..0) 调用不能保证会严格按照调用顺序处理，所以各种情况都有可能出现，比如定时器漂移，在这种情况下，这些事件的顺序就不可预测。在 Node.js 中，类似的方法是 process.nextTick(..)。尽管它们使用方便（通常性能也更高），但并没有（至少到目前为止）直接的方法可以适应所有环境来确保异步事件的顺序</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语</title>
    <link href="/2023/01/08/%E8%8B%B1%E8%AF%AD/"/>
    <url>/2023/01/08/%E8%8B%B1%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>英语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高数</title>
    <link href="/2023/01/08/%E9%AB%98%E6%95%B0/"/>
    <url>/2023/01/08/%E9%AB%98%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer Plus</title>
    <link href="/2022/12/30/C-Primer-Plus/"/>
    <url>/2022/12/30/C-Primer-Plus/</url>
    
    <content type="html"><![CDATA[<h1 id="开始学习C"><a href="#开始学习C" class="headerlink" title="开始学习C++"></a>开始学习C++</h1><p>一个cpp文件常见的部分</p><ul><li>注释，由前缀//标识。 </li><li>预处理器编译指令#include。 </li><li>函数头：int main( )。 </li><li>编译指令using namespace。 </li><li>函数体，用{和}括起。 </li><li>使用C++的cout工具显示消息的语句。 </li><li>结束main( )函数的return语句。 </li></ul><h2 id="main-函数"><a href="#main-函数" class="headerlink" title="**main( )**函数"></a>**main( )**函数</h2><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  vector&lt;string&gt; msg&#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>, <span class="hljs-string">&quot;VS Code&quot;</span>, <span class="hljs-string">&quot;and the C++ extension!&quot;</span>&#125;;  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string &amp;word : msg)  &#123;    cout &lt;&lt; word &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  &#125;  cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>第一行int main( )叫函数头（function heading），花括号({和})中包 括的部分叫函数体。</p><p>main( )中最后一条语句叫做返回语句（return statement），它结束 该函数。</p><p>在C++中，不能省略分号。</p><p>通常，C++函数可被其他函数激活或调用，函数头描述了函数与调 用它的函数之间的接口。位于函数名前面的部分叫做函数返回类型，它 </p><p>描述的是从函数返回给调用它的函数的信息。函数名后括号中的部分叫 做形参列表（argument list）或参数列表（parameter list）；它描述的是 从调用函数传递给被调用的函数的信息。这种通用格式用于main( )时让 人感到有些迷惑，因为通常并不从程序的其他部分调用main( )。</p><p>然而，通常，main( )被启动代码调用，而启动代码是由编译器添加 到程序中的，是程序和操作系统（UNIX、Windows 7或其他操作系统） 之间的桥梁。事实上，该函数头描述的是main( )和操作系统之间的接 口</p><p>然而，通常，main( )被启动代码调用，而启动代码是由编译器添加 到程序中的，是程序和操作系统（UNIX、Windows 7或其他操作系统） 之间的桥梁。事实上，该函数头描述的是main( )和操作系统之间的接 口</p><p>来看一下main( )的接口描述，该接口从int开始。C++函数可以给调 用函数返回一个值，这个值叫做返回值（return value）。在这里，从关 键字int可知，main( )返回一个整数值。接下来，是空括号。通常， C++函数在调用另一个函数时，可以将信息传递给该函数。括号中的函 数头部分描述的就是这种信息。在这里，空括号意味着main( )函数不接 受任何信息，或者main( )不接受任何参数。（main( )不接受任何参数并 不意味着main( )是不讲道理的、发号施令的函数。相反，术语参数 （argument）只是计算机人员用来表示从一个函数传递给另一个函数的 信息）。</p><p>简而言之，下面的函数头表明main( )函数可以给调用它的函数返回 一个整数值，且不从调用它的函数那里获得任何信息： </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></code></pre></div><p>很多现有的程序都使用经典C函数头：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">main</span>()</code></pre></div><p>在C语言中，省略返回类型相当于说函数的类型为int。然而， C++逐步淘汰了这种用法。 也可以使用下面的变体： </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span></code></pre></div><p>在括号中使用关键字void明确地指出，函数不接受任何参数。在C++（不是C）中，让括号空着与在括号中使用void等效（在C中，让括 号空着意味着对是否接受参数保持沉默）。有些程序员使用下面的函数头，并省略返回语句：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></code></pre></div><p>这在逻辑上是一致的，因为void返回类型意味着函数不返回任何 值。该变体适用于很多系统，但由于它不是当前标准强制的一个选项， </p><p>因此在有些系统上不能工作。因此，读者应避免使用这种格式，而应使 用C++标准格式，这不需要做太多的工作就能完成。最后ANSI/ISO C++标准对那些抱怨必须在main( )函数最后包含一 条返回语句过于繁琐的人做出了让步。如果编译器到达main( )函数末尾 时没有遇到返回语句，则认为main( )函数以如下语句结尾：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><p>这条隐含的返回语句只适用于main( )函数，而不适用于其他函数</p><h3 id="为什么-main-不能使用其他名称"><a href="#为什么-main-不能使用其他名称" class="headerlink" title="为什么**main( )**不能使用其他名称"></a>为什么**main( )**不能使用其他名称</h3><p>通常，C++程序必须包含一个名为main( )的函数（不是Main( )、 MAIN( )或mane( )。记住，大小写和拼写都要正确）.在运行 C++程序时，通常从main( )函数开始执行。因此，如果没有main( )，程 序将不完整，编译器将指出未定义main( )函数。 </p><p>存在一些例外情况。例如，在Windows编程中，可以编写一个动态 链接库（DLL）模块，这是其他Windows程序可以使用的代码。由于 </p><p>DLL模块不是独立的程序，因此不需要main( )。用于专用环境的程序— 如机器人中的控制器芯片—可能不需要main( )。有些编程环境提供一个 框架程序，该程序调用一些非标准函数，如_tmain( )。在这种情况下， 有一个隐藏的main( )，它调用_tmain( )。但常规的独立程序都需要main( )，</p><h2 id="C-注释"><a href="#C-注释" class="headerlink" title="**C++**注释"></a>**C++**注释</h2><p>C++注释以双斜杠（//）打头,编译器忽略注释,C++也能够识别C注释<code>/*注释*/</code></p><h2 id="C-预处理器和iostream文件"><a href="#C-预处理器和iostream文件" class="headerlink" title="C++预处理器和iostream文件"></a><strong>C++<strong>预处理器和</strong>iostream</strong>文件</h2><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;</code></pre></div><p>可使用其他代码替换第2行，这里使用这行代码旨在简化该程序 （如果编译器不接受这几行代码，则说明它没有遵守标准C++98，</p><p>C++和C一样，也使用一个预处理器，该程序在进行主编译之前对 源文件进行处理。有些C++实现使用翻译器程序将C++程 序转换为C程序。虽然翻译器也是一种预处理器，但这里不讨论这种预 处理器，而只讨论这样的预处理器，即它处理名称以#开头的编译指 令）。不必执行任何特殊的操作来调用该预处理器，它会在编译程序时 自动运行。 </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span></code></pre></div><p>该编译指令导致预处理器将iostream文件的内容添加到程序中。这 是一种典型的预处理器操作：在源代码被编译之前，替换或添加文本</p><p>这提出了一个问题：为什么要将iostream文件的内容添加到程序中 呢？答案涉及程序与外部世界之间的通信。iostream中的io指的是输入 （进入程序的信息）和输出（从程序中发送出去的信息）。C++的输入输出方案涉及iostream文件中的多个定义。为了使用cout来显示消息，第 一个程序需要这些定义。#include编译指令导致iostream文件的内容随源 代码文件的内容一起被发送给编译器。实际上，iostream文件的内容将 取代程序中的代码行#include <iostream>。原始文件没有被修改，而是将源代码文件和iostream组合成一个复合文件，编译的下一阶段将使用 该文件。 </p><p><strong>使用cin和cout进行输入和输出的程序必须包含文件iostream。</strong> </p><h2 id="头文件名"><a href="#头文件名" class="headerlink" title="头文件名"></a>头文件名</h2><p>像iostream这样的文件叫做包含文件（include file）—由于它们被包 含在其他文件中；也叫头文件（header file）—由于它们被包含在文件 起始处。C++编译器自带了很多头文件，每个头文件都支持一组特定的 工具。C语言的传统是，头文件使用扩展名h，将其作为一种通过名称标 识文件类型的简单方式。例如，头文件math.h支持各种C语言数学函 数，但C++的用法变了。现在，对老式C的头文件保留了扩展名 h（C++程序仍可以使用这种文件），而C++头文件则没有扩展名。有些 C头文件被转换为C++头文件，这些文件被重新命名，去掉了扩展名 h（使之成为C++风格的名称），并在文件名称前面加上前缀c（表明来 自C语言）。例如，C++版本的math.h为cmath。有时C头文件的C版本和 C++版本相同，而有时候新版本做了一些修改。对于纯粹的C++头文件 （如iostream）来说，去掉h不只是形式上的变化，没有h的头文件也可 以包含名称空间</p><table><thead><tr><th>头文件类型</th><th>约定</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>c++旧时风格</td><td>以.h结尾</td><td>iostream.h</td><td>C++程序可以使用</td></tr><tr><td>C旧式风格</td><td>以.h结尾</td><td>math.h</td><td>C、C++程序可以使用</td></tr><tr><td>c++新式风格</td><td>没有扩展名</td><td>iostream</td><td>C++程序可以使用，使用namespace std</td></tr><tr><td>转换后的C</td><td>加上前缀c，没有</td><td>cmath</td><td>C++程序可以使用，可以使用不是C的特</td></tr></tbody></table><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>如果使用iostream，而不是iostream.h，则应使用下面的名称空间编 译指令来使iostream中的定义对程序可用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;</code></pre></div><h2 id="使用cout进行-C-输出"><a href="#使用cout进行-C-输出" class="headerlink" title="使用cout进行**C++**输出"></a>使用<strong>cout</strong>进行**C++**输出</h2><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;messge&quot;</span>;</code></pre></div><h3 id="控制符endl"><a href="#控制符endl" class="headerlink" title="控制符endl"></a>控制符<strong>endl</strong></h3><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; endl;</code></pre></div><p>endl是一个特殊的C++符号，表示一个重要的概念：重起一行。在 输出流中插入endl将导致屏幕光标移到下一行开头。诸如endl等对于cout 来说有特殊含义的特殊符号被称为控制符（manipulator）。和cout一 样，endl也是在头文件iostream中定义的，且位于名称空间std中。</p><div class="code-wrapper"><pre><code class="hljs abnf">cout &lt;&lt; <span class="hljs-string">&quot;The God, the&quot;</span><span class="hljs-comment">;</span>cout &lt;&lt; <span class="hljs-string">&quot;Bad ,&quot;</span><span class="hljs-comment">;</span>cout &lt;&lt; <span class="hljs-string">&quot;and the uncle&quot;</span><span class="hljs-comment">;</span>cout &lt;&lt; endl<span class="hljs-comment">;</span></code></pre></div><p>输出</p><p>The God, the Bad ,and the uncle</p><p>同样，每个字符串紧接在前一个字符串的后面。如果要在两个字符 串之间留一个空格，必须将空格包含在字符串中。注意，要尝试上述输 出示例，必须将代码放到完整的程序中，该程序包含一个main( )函数头 以及起始和结束花括号</p><h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p>C++还提供了另一种在输出中指示换行的旧式方法：C语言符号 \n： </p><div class="code-wrapper"><pre><code class="hljs abnf">cout &lt;&lt; <span class="hljs-string">&quot;what s next?\n&quot;</span><span class="hljs-comment">;</span></code></pre></div><p>\n被视为一个字符，名为换行符。</p><p>显示字符串时，在字符串中包含换行符，而不是在末尾加上endl， 可减少输入量</p><p>另一方面，如果要生成一个空行，则两种方法的输入量相同，但对 大多数人而言，输入endl更为方便</p><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;cout &lt;&lt; endl;</code></pre></div><p>显示用引号括起的字符串时，通常使用换行符\n，在其他情 况下则使用控制符endl。一个差别是，endl确保程序继续运行前刷新输 出（将其立即显示在屏幕上）；而使用“\n”不能提供这样的保证，这意 味着在有些系统中，有时可能在您输入信息后才会出现提示。 </p><h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>C++（和C）有一项不寻常的特性—可以连 续使用赋值运算符</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> steinway;<span class="hljs-type">int</span> balnwin;<span class="hljs-type">int</span> yamaha;steinway = balnwin = yamaha = <span class="hljs-number">88</span>;</code></pre></div><p>cout 可以用来输出变量</p><div class="code-wrapper"><pre><code class="hljs bash">cout &lt;&lt; <span class="hljs-string">steinway</span></code></pre></div><h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">int</span> carrots;  cout &lt;&lt; <span class="hljs-string">&quot;how many carrots do you have?&quot;</span>;  cout &lt;&lt; <span class="hljs-string">&quot;endl&quot;</span>;  cin &gt;&gt; carrots;  cout &lt;&lt; <span class="hljs-string">&quot;here are two more&quot;</span>;  carrots = carrots + <span class="hljs-number">2</span>;  cout &lt;&lt; <span class="hljs-string">&quot;now you are &quot;</span> &lt;&lt; carrots &lt;&lt; <span class="hljs-string">&quot;carrots&quot;</span> &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>上面的输出表明，从键盘输入的值（12）最终被赋给变量carrots。 下面就是执行这项功能的语句： </p><div class="code-wrapper"><pre><code class="hljs c++">cin &gt;&gt; carrots;</code></pre></div><h3 id="使用cout进行拼接"><a href="#使用cout进行拼接" class="headerlink" title="使用cout进行拼接"></a>使用<strong>cout</strong>进行拼接</h3><div class="code-wrapper"><pre><code class="hljs bash">cout &lt;&lt; <span class="hljs-string">&quot;now you are &quot;</span> &lt;&lt; <span class="hljs-string">carrots &lt;&lt; &quot;carrots</span><span class="hljs-string">&quot; &lt;&lt; endl;</span></code></pre></div><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C++函数分两种：有返回值的和没有返回值的。在标准C++函数库 中可以找到这两类函数的例子，您也可以自己创建这两种类型的函数</p><h3 id="使用有返回值的函数"><a href="#使用有返回值的函数" class="headerlink" title="使用有返回值的函数"></a>使用有返回值的函数</h3><p>C++程序应当为程序中使用的每个函数提供原型。</p><p>函数原型之于函数就像变量声明之于变量—指出涉及的类型。例 如，C++库将sqrt( )函数定义成将一个（可能）带小数部分的数字（如 </p><p>6.25）作为参数，并返回一个相同类型的数字。有些语言将这种数字称 为实数，但是C++将这种类型称为double（将在第3章介绍）。sqrt( )的 函数原型像这样：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;   <span class="hljs-comment">//function prototype</span></code></pre></div><p>第一个double意味着sqrt( )将返回一个double值。括号中的double意 味着sqrt( )需要一个double参数。因此该原型对sqrt( )的描述和下面代码 中使用的函数相同</p><p>第一个double意味着sqrt( )将返回一个double值。括号中的double意 </p><p>味着sqrt( )需要一个double参数。因此该原型对sqrt( )的描述和下面代码 </p><p>中使用的函数相同</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">double</span> x;x=<span class="hljs-built_in">sqrt</span>(x)</code></pre></div><p>原型结尾的分号表明它是一条语句，这使得它是一个原型，而不是 函数头。如果省略分号，编译器将把这行代码解释为一个函数头，并要 求接着提供定义该函数的函数体。 </p><p>在程序中使用sqrt( )时，也必须提供原型。可以用两种方法来实 现：</p><p>在源代码文件中输入函数原型； </p><p>包含头文件cmath（老系统为math.h），其中定义了原型。</p><p>第二种方法更好，因为头文件更有可能使原型正确。对于C++库中 的每个函数，都在一个或多个头文件中提供了其原型。请通过手册或在 </p><p>线帮助查看函数描述来确定应使用哪个头文件。例如，sqrt( )函数的说 明将指出，应使用cmath头文件。（同样，可能必须使用老式的头文件 math.h，它可用于C和C++程序中。）</p><p>不要混淆函数原型和函数定义。可以看出，原型只描述函数接口。 也就是说，它描述的是发送给函数的信息和返回的信息。而定义中包含 了函数的代码，如计算平方根的代码。C和C++将库函数的这两项特性 （原型和定义）分开了。库文件中包含了函数的编译代码，而头文件中 则包含了原型。</p><p>应在首次使用函数之前提供其原型。通常的做法是把原型放到 main( )函数定义的前面。程序清单2.4演示了库函数sqrt( )的用法，它通 </p><p>过包含cmath文件来提供该函数的原型： </p><h3 id="函数变体"><a href="#函数变体" class="headerlink" title="函数变体"></a>函数变体</h3><p>有些函数需要多项信息。这些函数使用多个参数，参数间用逗号分 开。例如，数学函数pow( )接受两个参数，返回值为以第一个参数为 </p><p>底，第二个参数为指数的幂。该函数的原型如下： </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">double</span>,<span class="hljs-type">double</span>)</span> <span class="hljs-comment">//prototype of a function with two argument;</span></span></code></pre></div><p>另外一些函数不接受任何参数。例如，有一个C库（与cstdlib或 stdlib.h头文件相关的库）包含一个rand( )函数，该函数不接受任何参 </p><p>数，并返回一个随机整数。该函数的原型如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rand</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;</code></pre></div><p>关键字void明确指出，该函数不接受任何参数。如果省略void，让 括号为空，则C++将其解释为一个不接受任何参数的隐式声明。可以这 </p><p>样使用该函数：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">myGuess</span><span class="hljs-operator">=</span>rand()</code></pre></div><p>还有一些函数没有返回值。例如，假设编写了一个函数，它按美 元、美分格式显示数字。当向它传递参数23.5时，它将在屏幕上显示 </p><p>$23.50。由于这个函数把值发送给屏幕，而不是调用程序，因此不需要 返回值。可以在原型中使用关键字void来指定返回类型，以指出函数没 有返回值： </p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bucks</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span></code></pre></div><p>由于它不返回值，因此不能将该函数调用放在赋值语句或其他表达 式中。相反，应使用一条纯粹的函数调用语句：</p><p>在有些语言中，有返回值的函数被称为函数（function）；没有返 回值的函数被称为过程（procedure）或子程序（subroutine）。但C++与 C一样，这两种变体都被称为函数。 </p><h3 id="用户定义的函数"><a href="#用户定义的函数" class="headerlink" title="用户定义的函数"></a>用户定义的函数</h3><p>标准C库提供了140多个预定义的函数。如果其中的函数能满足要 求，则应使用它们。但用户经常需要编写自己的函数，尤其是在设计类 </p><p>的时候。无论如何，设计自己的函数很有意思，下面来介绍这一过程。 前面已经使用过好几个用户定义的函数，它们都叫main( )。每个C++程 序都必须有一个main( )函数，用户必须对它进行定义。假设需要添加另一个用户定义的函数。和库函数一样，也可以通过函数名来调用用户定 义的函数。对于库函数，在使用之前必须提供其原型，通常把原型放到 main( )定义之前。但现在您必须提供新函数的源代码。最简单的方法 是，将代码放在main( )的后面</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simon</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// function prototype for simon()</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-built_in">simon</span>(<span class="hljs-number">3</span>);  cout &lt;&lt; <span class="hljs-string">&quot;pick an integer&quot;</span>;  <span class="hljs-type">int</span> count;  cin &gt;&gt; count;  <span class="hljs-built_in">simon</span>(count);  cout &lt;&lt; <span class="hljs-string">&quot;done!&quot;</span> &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simon</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">// define this simon function</span>  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  cout &lt;&lt; <span class="hljs-string">&quot;simon touch you toe&quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; times&quot;</span> &lt;&lt; endl;&#125;</code></pre></div><h4 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stonetolb</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">int</span> stone;  cout &lt;&lt; <span class="hljs-string">&quot;enter the weight in stone &quot;</span>;  cin &gt;&gt; stone;  <span class="hljs-type">int</span> pounds = <span class="hljs-built_in">stonetolb</span>(stone);  cout &lt;&lt; stone &lt;&lt; <span class="hljs-string">&quot; stone = &quot;</span>;  cout &lt;&lt; pounds &lt;&lt; <span class="hljs-string">&quot; ponds.&quot;</span> &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stonetolb</span><span class="hljs-params">(<span class="hljs-type">int</span> sts)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">14</span> * sts;&#125;</code></pre></div><p>函数stonetolb( )短小、简单，但包含了全部的函数特性： </p><p>有函数头和函数体； </p><p>接受一个参数； </p><p>返回一个值； </p><p>需要一个原型。 </p><h4 id="在多函数程序中使用using编译指令"><a href="#在多函数程序中使用using编译指令" class="headerlink" title="在多函数程序中使用using编译指令"></a>在多函数程序中使用<strong>using</strong>编译指令</h4><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;</code></pre></div><p>这是因为每个函数都使用了cout，因此需要能够访问位于名称空间 std中的cout定义。 </p><p>可以采用另一种方法让两个函数都能够访问名 称空间std，即将编译指令放在函数的外面，且位于两个函数的前面：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simon</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// function prototype for simon()</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">simon</span>(<span class="hljs-number">3</span>);  cout &lt;&lt; <span class="hljs-string">&quot;pick an integer&quot;</span>;  <span class="hljs-type">int</span> count;  cin &gt;&gt; count;  <span class="hljs-built_in">simon</span>(count);  cout &lt;&lt; <span class="hljs-string">&quot;done!&quot;</span> &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simon</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123; <span class="hljs-comment">// define this simon function</span>    cout &lt;&lt; <span class="hljs-string">&quot;simon touch you toe&quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; times&quot;</span> &lt;&lt; endl;&#125;</code></pre></div><p>当前通行的理念是，只让需要访问名称空间std的函数访问它是更好 的选择。例如，在程序清单2.6中，只有main( )函数使用cout，因此没有 必要让函数stonetolb( )能够访问名称空间std。因此编译指令using被放在 函数main( )中，使得只有该函数能够访问名称空间std。</p><p>总之，让程序能够访问名称空间std的方法有多种，下面是其中的4 种。</p><ul><li>将using namespace std；放在函数定义之前，让文件中所有的函数 都能够使用名称空间std中所有的元素。 </li><li>将using namespace std；放在特定的函数定义中，让该函数能够使用名称空间std中的所有元素。</li><li>在特定的函数中使用类似using std::cout;这样的编译指令，而不是 using namespace std;，让该函数能够使用指定的元素，如cout。</li><li>完全不使用编译指令using，而在需要使用名称空间std中的元素 时，使用前缀std::，如下所示： </li></ul><div class="code-wrapper"><pre><code class="hljs c++">std:cout &lt;&lt; <span class="hljs-string">&quot;i am using cout&quot;</span> &lt;&lt; std:endl;</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++程序由一个或多个被称为函数的模块组成。程序从main( )函数 （全部小写）开始执行，因此该函数必不可少。函数由函数头和函数体 </p><p>组成。函数头指出函数的返回值（如果有的话）的类型和函数期望通过 参数传递给它的信息的类型。函数体由一系列位于花括号（{}）中的 C++语句组成。 </p><p>有多种类型的C++语句，包括下述6种。</p><ul><li>声明语句：定义函数中使用的变量的名称和类型。 </li><li>赋值语句：使用赋值运算符（=）给变量赋值。 </li><li>消息语句：将消息发送给对象，激发某种行动。 </li><li>函数调用：执行函数。被调用的函数执行完毕后，程序返回到函数 调用语句后面的语句。 </li><li>函数原型：声明函数的返回类型、函数接受的参数数量和类型</li><li>返回语句：将一个值从被调用的函数那里返回到调用函数中</li></ul><p>类是用户定义的数据类型规范，它详细描述了如何表示信息以及可 对数据执行的操作。对象是根据类规范创建的实体，就像简单变量是根 据数据类型描述创建的实体一样。</p><p>C++提供了两个用于处理输入和输出的预定义对象（cin和cout）， 它们是istream和ostream类的实例，这两个类是在iostream文件中定义 的。为ostream类定义的插入运算符（&lt;&lt;）使得将数据插入到输出流成 为可能；为istream类定义的抽取运算符（&gt;&gt;）能够从输入流中抽取信 息。cin和cout都是智能对象，能够根据程序上下文自动将信息从一种形 式转换为另一种形式。</p><p>C++可以使用大量的C库函数。要使用库函数，应当包含提供该函 数原型的头文件。</p><h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><p>内置的C++类型分两组：基本类型和复合类型</p><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> braincount;braincount = <span class="hljs-number">5</span>;</code></pre></div><p>这些语句告诉程序，它正在存储整数，并使用名称braincount来表 示该整数的值（这里为5）。实际上，程序将找到一块能够存储整数的 </p><p>内存，将该内存单元标记为braincount，并将5复制到该内存单元中；然 后，您可在程序中使用braincount来访问该内存单元。这些语句没有告 诉您，这个值将存储在内存的什么位置，但程序确实记录了这种信息。 实际上，可以使用&amp;运算符来检索braincount的内存地址</p><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>C++命名规则:</p><ul><li><p>在名称中只能使用字母字符、数字和下划线（_）</p></li><li><p>名称的第一个字符不能是数字</p></li><li><p>区分大写字符与小写字符</p></li><li><p>不能将C++关键字用作名称</p></li><li><p>以两个下划线或下划线和大写字母打头的名称被保留给实现（编译 器及其使用的资源）使用。以一个下划线开头的名称被保留给实 现，用作全局标识符.</p></li><li><p>C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制.</p><p>最后一点使得C++与ANSI C（C99标准）有所区别，后者只保证名 称中的前63个字符有意义（在ANSI C中，前63个字符相同的名称被认 为是相同的，即使第64个字符不同）。 </p></li></ul><p>如果想用两个或更多的单词组成一个名称，通常的做法是用下划线 字符将单词分开，如my_onions；或者从第二个单词开始将每个单词的 第一个字母大写，如myEyeTooth。（C程序员倾向于按C语言的方式使 用下划线，而Pascal程序员喜欢采用大写方式。）这两种形式都很容易 将单词区分开，如carDrip和cardRip或boat_sport和boats_port。 </p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>整数就是没有小数部分的数字，如2、98、-5286和0。整数有很 多，如果将无限大的整数看作很大，则不可能用有限的计算机内存来表 </p><p>示所有的整数。因此，语言只能表示所有整数的一个子集。有些语言只 提供一种整型（一种类型满足所有要求！），而C++则提供好几种，这 样便能够根据程序的具体要求选择最合适的整型。</p><p>不同C++整型使用不同的内存量来存储整数。使用的内存量越大， 可以表示的整数值范围也越大。另外，有的类型（符号类型）可表示正 值和负值，而有的类型（无符号类型）不能表示负值。术语宽度 （width）用于描述存储整数时使用的内存量。使用的内存越多，则越 宽。C++的基本整型（按宽度递增的顺序排列）分别是char、short、 int、long和C++11新增的long long，其中每种类型都有符号版本和无符 号版本，因此总共有10种类型可供选择.</p><h4 id="整型short、int、long和long-long"><a href="#整型short、int、long和long-long" class="headerlink" title="整型short、int、long和long long"></a>整型<strong>short</strong>、<strong>int</strong>、<strong>long</strong>和<strong>long long</strong></h4><p>short至少16位(bit)</p><p>int至少和short一样长</p><p>long至少32位，且·至少和int一样长</p><p>long long至少64位，且至少和long一样长</p><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">位：计算机内存的基本单元是位（bit），用01表示</span><span class="hljs-comment">字节：通常指的是8位的内存单元，字节指的就是描述计算机内 存量的度量单位，1KB等于1024字节，1MB等于1024KB。然而，C</span><span class="hljs-literal">++</span><span class="hljs-comment">对字节的定义与此不 同。C</span><span class="hljs-literal">++</span><span class="hljs-comment">字节由至少能够容纳实现的基本字符集的相邻位组成。也就是说，可能取值的数目必 须等于或超过字符数目。在美国，基本字符集通常是ASCII和EBCDIC字符集，它们都可以用8 位来容纳，所以在使用这两种字符集的系统中，C</span><span class="hljs-literal">++</span><span class="hljs-comment">字节通常包含8位。然而，国际编程可能 需要使用更大的字符集，如Unicode，因此有些实现可能使用16位甚至32位的字节。有些人使 用术语八位组（octet）表示8位字节</span></code></pre></div><p>short是short int的简称</p><p>long是long int 的简称</p><p>long long 是long long int的简称</p><p>这些都是符号类型，说明每种的正负值除符号位都是相等的要知道系统中整数的最大长度，可以在程序中使用C++工具来检查 类型的长度。首先，sizeof运算符返回类型或变量的长度，单位为字节 （运算符是内置的语言元素，对一个或多个数据进行运算，并生成一个 值。例如，加号运算符+将两个值相加）。前面说过，“字节”的含义依 赖于实现，因此在一个系统中，两字节的int可能是16位，而在另一个系 统中可能是32位。其次，头文件climits（在老式实现中为limits.h）中包 含了关于整型限制的信息。具体地说，它定义了表示各种限制的符号名 称。例如，INT_MAX为int的最大取值，CHAR_BIT为字节的位数</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">int</span> n_int = INT_MAX;  <span class="hljs-type">short</span> n_short = SHRT_MAX;  <span class="hljs-type">long</span> n_long = LONG_MAX;  <span class="hljs-type">long</span> <span class="hljs-type">long</span> n_llong = LLONG_MAX;<span class="hljs-comment">//对类型名（如int）使用 sizeof运算符时，应将名称放在括号中；但对变量名（如n_short）使用 该运算符，括号是可选的</span>  cout &lt;&lt; <span class="hljs-string">&quot;int is &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-string">&quot;bytes&quot;</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;shorts is &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span> n_short &lt;&lt; <span class="hljs-string">&quot;bytes&quot;</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;long is &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span> n_long &lt;&lt; <span class="hljs-string">&quot;bytes&quot;</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;long long is &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span> n_llong &lt;&lt; <span class="hljs-string">&quot;bytes&quot;</span> &lt;&lt; endl;  cout &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;maxinum value: &quot;</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;int: &quot;</span> &lt;&lt; n_int &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;short: &quot;</span> &lt;&lt; n_short &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;long: &quot;</span> &lt;&lt; n_long &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;long long: &quot;</span> &lt;&lt; n_llong &lt;&lt; endl       &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;max int value: &quot;</span> &lt;&lt; INT_MIN &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;bits per bytes: &quot;</span> &lt;&lt; CHAR_BIT &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment">int is 4bytes</span><span class="hljs-comment">shorts is 2bytes</span><span class="hljs-comment">long is 8bytes</span><span class="hljs-comment">long long is 8bytes</span><span class="hljs-comment"></span><span class="hljs-comment">maxinum value: </span><span class="hljs-comment">int: 2147483647</span><span class="hljs-comment">short: 32767</span><span class="hljs-comment">long: 9223372036854775807</span><span class="hljs-comment">long long: 9223372036854775807</span><span class="hljs-comment"></span><span class="hljs-comment">min int value: -2147483648</span><span class="hljs-comment">bits per bytes: 8</span><span class="hljs-comment">*/</span></code></pre></div><h5 id="climits中的符号常量"><a href="#climits中的符号常量" class="headerlink" title="climits中的符号常量"></a><strong>climits</strong>中的符号常量</h5><table><thead><tr><th>符号常量</th><th>表示</th></tr></thead><tbody><tr><td>CHAR_BIT</td><td>char的位数</td></tr><tr><td>CHAR_MAX</td><td>char的最大值</td></tr><tr><td>CHAR_MIN</td><td>char的最小值</td></tr><tr><td>SCHAR_MAX</td><td>signed char的最大值</td></tr><tr><td>SCHAR_MIN</td><td>signed char的最小值</td></tr><tr><td>UCHAR_MAX</td><td>unsigned char的最大值</td></tr><tr><td>SHRT_MAX</td><td>short的最大值</td></tr><tr><td>SHRT_MIN</td><td>short的最小值</td></tr><tr><td>USHRT_MAX</td><td>unsigned short的最大值</td></tr><tr><td>INT_MAX</td><td>int的最大值</td></tr><tr><td>INT_MIN</td><td>int的最小值</td></tr><tr><td>UNIT_MAX</td><td>unsigned int的最大值</td></tr><tr><td>LONG_MAX</td><td>long的最大值</td></tr><tr><td>LONG_MIN</td><td>long的最小值</td></tr><tr><td>ULONG_MAX</td><td>unsigned long的最大值</td></tr><tr><td>LLONG_MAX</td><td>long long的最大值</td></tr><tr><td>LLONG_MIN</td><td>long long的最小值</td></tr><tr><td>ULLONG_MAX</td><td>unsigned long long的最大值</td></tr></tbody></table><h5 id="符号常量—预处理器方式"><a href="#符号常量—预处理器方式" class="headerlink" title="符号常量—预处理器方式"></a>符号常量<strong>—</strong>预处理器方式</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//在climit文件中</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_INT 32767；</span></code></pre></div><p>在C++编译过程中，首先将源代码传递给预处理器。在这里，#define和#include一样，也 是一个预处理器编译指令。该编译指令告诉预处理器：在程序中查找INT_MAX，并将所有的 INT_MAX都替换为32767。因此#define编译指令的工作方式与文本编辑器或字处理器中的全 局搜索并替换命令相似。修改后的程序将在完成这些替换后被编译。预处理器查找独立的标 记（单独的单词），跳过嵌入的单词。也就是说，预处理器不会将PINT_MAXTM替换为 P32767IM。也可以使用#define来定义自己的符号常量。然而，#define编 译指令是C语言遗留下来的。C++有一种更好的创建符号常量的方法（使用关键字const，将在 后面的一节讨论），所以不会经常使用#define。然而，有些头文件，尤其是那些被设计成可 用于C和C++中的头文件，必须使用#define。 </p><h5 id="初始化-方式"><a href="#初始化-方式" class="headerlink" title="初始化 方式"></a>初始化 方式</h5><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> uncles=<span class="hljs-number">5</span>;<span class="hljs-type">int</span> aunts=uncles;<span class="hljs-type">int</span> chirs=uncle+aunts+<span class="hljs-number">4</span>;<span class="hljs-comment">//C++还有另一种C语言没有的初始化 语法：</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wrens</span><span class="hljs-params">(<span class="hljs-number">144</span>)</span></span>;</code></pre></div><p><strong>如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值 将是它被创建之前，相应内存单元保存的值。</strong></p><h5 id="C-11初始化方式"><a href="#C-11初始化方式" class="headerlink" title="C++11初始化方式"></a><strong>C++11</strong>初始化方式</h5><p>还有另一种初始化方式，这种方式用于数组和结构，但在C++98 中，也可用于单值变量：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> hamburgers=&#123;<span class="hljs-number">24</span>&#125;;</code></pre></div><p>将大括号初始化器用于单值变量的情形还不多，但C++11标准使得 这种情形更多了。首先，采用这种方式时，可以使用等号（=），也可</p><p>以不使用：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> nums&#123;<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">//set nums to 7</span><span class="hljs-type">int</span> rheas=&#123;<span class="hljs-number">12</span>&#125;;<span class="hljs-comment">// set rheas to 12;</span></code></pre></div><p>其次，大括号内可以不包含任何东西。在这种情况下，变量将被初 始化为零： </p><div class="code-wrapper"><pre><code class="hljs abnf">int rocs<span class="hljs-operator">=</span>&#123;&#125;<span class="hljs-comment">;</span>int psychis&#123;&#125;<span class="hljs-comment">;</span></code></pre></div><h3 id="无符号类型"><a href="#无符号类型" class="headerlink" title="无符号类型"></a>无符号类型</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> change;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rovert;<span class="hljs-type">unsigned</span> quarterback; <span class="hljs-comment">/*默认是int型*/</span><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> gone;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> lang_lang;</code></pre></div><p>注意，unsigned本身是unsigned int的缩写。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZERO 0</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">short</span> sam = SHRT_MAX;  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> sue = sam;  cout &lt;&lt; <span class="hljs-string">&quot;Sam has &quot;</span> &lt;&lt; sam &lt;&lt; <span class="hljs-string">&quot; dollars and sue has &quot;</span> &lt;&lt; sue;  cout &lt;&lt; <span class="hljs-string">&quot;dollars depoutd &quot;</span> &lt;&lt; endl       &lt;&lt; <span class="hljs-string">&quot;and $1 to each account.&quot;</span> &lt;&lt; endl       &lt;&lt; <span class="hljs-string">&quot;now&quot;</span>;  sam = sam + <span class="hljs-number">1</span>;  sue = sue + <span class="hljs-number">1</span>;  cout &lt;&lt; <span class="hljs-string">&quot;Sam has &quot;</span> &lt;&lt; sam &lt;&lt; <span class="hljs-string">&quot;dollars and sue has &quot;</span> &lt;&lt; sue;  cout &lt;&lt; <span class="hljs-string">&quot; dollarrs deposited.\nPoor sam&quot;</span> &lt;&lt; endl;  sam = ZERO;  sue = ZERO;  cout &lt;&lt; <span class="hljs-string">&quot;Sam has &quot;</span> &lt;&lt; sam &lt;&lt; <span class="hljs-string">&quot; dollars and Sue has&quot;</span> &lt;&lt; sue;  cout &lt;&lt; <span class="hljs-string">&quot;dollars depoutd &quot;</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;Take $1 from each account&quot;</span> &lt;&lt; endl       &lt;&lt; <span class="hljs-string">&quot;now&quot;</span>;  sam = sam - <span class="hljs-number">1</span>;  sue = sue - <span class="hljs-number">1</span>;<span class="hljs-comment">//无符号数0-1 会在另外一端-1</span>  cout &lt;&lt; <span class="hljs-string">&quot;samhas &quot;</span> &lt;&lt; sam &lt;&lt; <span class="hljs-string">&quot; dollars and Sue has &quot;</span> &lt;&lt; sue;  cout &lt;&lt; <span class="hljs-string">&quot; dollars deposited&quot;</span> &lt;&lt; endl       &lt;&lt; <span class="hljs-string">&quot;lucky sue &quot;</span> &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">Sam has 32767 dollars and sue has 32767dollars depoutd</span><span class="hljs-comment">and $1 to each account.</span><span class="hljs-comment">nowSam has -32768dollars and sue has 32768 dollarrs deposited.</span><span class="hljs-comment">Poor sam</span><span class="hljs-comment">Sam has 0 dollars and Sue has0dollars depoutd</span><span class="hljs-comment">Take $1 from each account</span><span class="hljs-comment">nowsamhas -1 dollars and Sue has 65535 dollars deposited</span><span class="hljs-comment">lucky sue</span><span class="hljs-comment">*/</span></code></pre></div><p>该程序将一个short变量（sam）和一个unsigned short变量（sue）分 别设置为最大的short值，在我们的系统上，是32767。然后，将这些变 量的值都加1。这对于sue来说没有什么问题，因为新值仍比无符号整数 的最大值小得多；但sam的值从32767变成了−32768！同样，对于sam， 将其设置为0并减去1，也不会有问题；但对于无符号变量sue，将其设 置为0并减去后，它变成了65535。可以看出，这些整型变量的行为就像 里程表。如果超越了限制，其值将为范围另一端的取值。C++确保了无符号类型的这种行为；但C++并不保证符号整型超 越限制（上溢和下溢）时不出错，而这正是当前实现中最为常见的行 为。</p><h4 id="C-如何确定常量的类型"><a href="#C-如何确定常量的类型" class="headerlink" title="**C++**如何确定常量的类型"></a>**C++**如何确定常量的类型</h4><div class="code-wrapper"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;year = &quot;</span>&lt;&lt; <span class="hljs-number">1492</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span></code></pre></div><p>程序将把1492存储为int、long还是其他整型呢？答案是，除非有理 由存储为其他类型（如使用了特殊的后缀来表示特定的类型，或者值太 大，不能存储为int），否则C++将整型常量存储为int类型.</p><p>首先来看看后缀。后缀是放在数字常量后面的字母，用于表示类 型。整数后面的l或L后缀表示该整数为long常量，u或U后缀表unsigned int常量，ul（可以采用任何一种顺序，大写小写均可）表示 unsigned long常量（由于小写l看上去像1，因此应使用大写L作后缀）。 例如，在int为16位、long为32位的系统上，数字22022被存储为int，占 16位，数字22022L被存储为long，占32位。同样，22022LU和22022UL 都被存储为unsigned long。C++11提供了用于表示类型long long的后缀ll 和LL，还提供了用于表示类型unsigned long long的后缀ull、Ull、uLL和 ULL。</p><p>接下来考察长度。在C++中，对十进制整数采用的规则，与十六进 制和八进制稍微有些不同。对于不带后缀的十进制整数，将使用下面几 种类型中能够存储该数的最小类型来表示：int、long或long long。在int 为16位、long为32位的计算机系统上，20000被表示为int类型，40000被 表示为long类型，3000000000被表示为long long类型。对于不带后缀的 十六进制或八进制整数，将使用下面几种类型中能够存储该数的最小类 型来表示：int、unsigned int long、unsigned long、long long或unsigned long long。在将40000表示为long的计算机系统中，十六进制数 0x9C40（40000）将被表示为unsigned int。这是因为十六进制常用来表 示内存地址，而内存地址是没有符号的，因此，usigned int比long更适合 用来表示16位的地址</p><h3 id="char类型：字符和小整数"><a href="#char类型：字符和小整数" class="headerlink" title="char类型：字符和小整数"></a><strong>char</strong>类型：字符和小整数</h3><p>char类型是专为存 储字符（如字母和数字）而设计的</p><p>现在，存储数字对于计算机来说算 不了什么，但存储字母则是另一回事。编程语言通过使用字母的数值编 码解决了这个问题。因此，char类型是另一种整型。它足够长，能够表 示目标计算机系统中的所有基本符号—所有的字母、数字、标点符号 等。实际上，很多系统支持的字符都不超过128个，因此用一个字节就可以表示所有的符号。因此，虽然char最常被用来处理字符，但也可以 将它用做比short更小的整型。</p><p>最常用的符号集是ASCII字符集.字符集 中的字符用数值编码（ASCII码）表示</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">char</span> ch;  cout &lt;&lt; <span class="hljs-string">&quot;enter a character: &quot;</span> &lt;&lt; endl;  cin &gt;&gt; ch;  cout &lt;&lt; <span class="hljs-string">&quot;hila &quot;</span>;  cout &lt;&lt; <span class="hljs-string">&quot;thank you for the &quot;</span> &lt;&lt; ch &lt;&lt; <span class="hljs-string">&quot; charactor&quot;</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// enter a character: </span><span class="hljs-comment">// a</span><span class="hljs-comment">// hila thank you for the a charactor</span></code></pre></div><p>C++对字符用单引号，对字符串使用双引号。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;M&#x27;</span>;  <span class="hljs-type">int</span> i = ch;  cout &lt;&lt; <span class="hljs-string">&quot;the ascii code for &quot;</span> &lt;&lt; ch &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; i &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;add one to the character code:&quot;</span> &lt;&lt; endl;  ch = ch + <span class="hljs-number">1</span>;  i = ch;  cout &lt;&lt; <span class="hljs-string">&quot;the ascii code for &quot;</span> &lt;&lt; ch &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; i &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;displaying char ch using cout.put(ch) &quot;</span>;  cout.<span class="hljs-built_in">put</span>(ch);  cout.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;!&#x27;</span>);  cout &lt;&lt; endl       &lt;&lt; <span class="hljs-string">&quot;done&quot;</span> &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// the ascii code for M is 77</span><span class="hljs-comment">// add one to the character code:</span><span class="hljs-comment">// the ascii code for N is 78</span><span class="hljs-comment">// displaying char ch using cout.put(ch) N!</span><span class="hljs-comment">// done</span></code></pre></div><p>‘M’表示字符M的数值编码，因此将char变量ch.初始化为‘M’，将把c设置为77。然后，程序将同样的值赋给int变量i， 这样ch和i的值都是77。接下来，cout把ch显示为M，而把i显示为77。由于ch实际上是一个整数，因此可以对它使用整数操作，如加1， 这将把ch的值变为78。然后，程序将i重新设置为新的值（也可以将i加 1）。cout再次将这个值的char版本显示为字符，将int版本显示为数字。C++将字符表示为整数提供了方便，使得操纵字符值很容易。不必 使用笨重的转换函数在字符和ASCII码之间来回转换。 </p><p>即使通过键盘输入的数字也被视为字符。请看下面的代码</p><div class="code-wrapper"><pre><code class="hljs abnf">char ch<span class="hljs-comment">;</span>cin &gt;&gt; ch<span class="hljs-comment">;</span></code></pre></div><p>如果您输入5并按回车键，上述代码将读取字符“5”，并将其对应的 字符编码（ASCII编码53）存储到变量ch中。请看下面的代码： </p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> <span class="hljs-number">ch</span><span class="hljs-comment">;</span>cin &gt;&gt; <span class="hljs-number">ch</span><span class="hljs-comment">;</span></code></pre></div><p>如果您也输入5并按回车键，上述代码将读取字符“5”，将其转换为 相应的数字值5，并存储到变量n中</p><p>cout.put( )成员函数提供了另一种显示字符的方法，可以替代&lt;&lt;运 算符。</p><p>在 C++的Release 2.0之前，cout将字符变量显示为字符，而将字符常量 （如‘M’和‘N’）显示为数字。问题是，C++的早期版本与C一样，也将 把字符常量存储为int类型。也就是说，‘M’的编码77将被存储在一个16 位或32位的单元中。而char变量一般占8位。下面的语句从常量‘M’中复 制8位（左边的8位）到变量ch中</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">char ch</span>=<span class="hljs-string">&#x27;M&#x27;</span>;</code></pre></div><p>遗憾的是，这意味着对cout来说，‘M’和ch看上去有天壤之别，虽 然它们存储的值相同。因此，下面的语句将打印$字符的ASCII码，而不 </p><p>是字符$： </p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">cout</span> &lt;&lt; <span class="hljs-string">&#x27;$&#x27;</span></code></pre></div><p>但下面的语句将打印字符$：</p><div class="code-wrapper"><pre><code class="hljs gams">cout.<span class="hljs-keyword">put</span>(<span class="hljs-string">&#x27;$&#x27;</span>)</code></pre></div><p>在Release 2.0之后，C++将字符常量存储为char类型，而不是int类 型。这意味着cout现在可以正确处理字符常量了。</p><h4 id="signed-char和unsigned-char"><a href="#signed-char和unsigned-char" class="headerlink" title="signed char和unsigned char"></a><strong>signed char</strong>和<strong>unsigned char</strong></h4><p>与int不同的是，char在默认情况下既不是没有符号，也不是有符 号。是否有符号由C++实现决定，这样编译器开发人员可以最大限度地 将这种类型与硬件属性匹配起来。如果char有某种特定的行为对您来说 非常重要，则可以显式地将类型设置为signed char 或unsigned char：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> fodo;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> bar;<span class="hljs-type">signed</span> <span class="hljs-type">char</span> snark;</code></pre></div><p>如果将char用作数值类型，则unsigned char和signed char之间的差异 将非常重要。unsigned char类型的表示范围通常为0～255，而signed char 的表示范围为−128到127</p><h4 id="wcha-t"><a href="#wcha-t" class="headerlink" title="wcha_t"></a><strong>wcha_t</strong></h4><p>程序需要处理的字符集可能无法用一个8位的字节表示，如日文汉字系统。对于这种情况，C++的处理方式有两种.首先，如果大型字符 集是实现的基本字符集，则编译器厂商可以将char定义为一个16位的字 节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和 一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型 wchar_t（宽字符类型）可以表示扩展字符集。wchar_t类型是型与另一种整型（底层（underlying）类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。</p><p>cin和cout将输入和输出看作是char流，因此不适于用来处理wchar_t 类型。iostream头文件的最新版本提供了作用相似的工具—wcin和 wcout，可用于处理wchar_t流。另外，可以通过加上前缀L来指示宽字 符常量和宽字符串。下面的代码将字母P的wchar_t版本存储到变量bob 中，并显示单词tall的wchar_t版本： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">wchar_t</span> bob =<span class="hljs-string">L&#x27;P&#x27;</span>;wcout&lt;&lt;<span class="hljs-string">L&quot;tall&quot;</span>&lt;&lt;endl;</code></pre></div><p>在支持两字节wchar_t的系统中，上述代码将把每个字符存储在一 个两个字节的内存单元中</p><h4 id="C-11新增的类型：char16-t和char32-t"><a href="#C-11新增的类型：char16-t和char32-t" class="headerlink" title="C++11新增的类型：char16_t和char32_t"></a><strong>C++11</strong>新增的类型：<strong>char16_t</strong>和<strong>char32_t</strong></h4><p>随着编程人员日益熟悉Unicode，类型wchar_t显然不再能够满足需 求。事实上，在计算机系统上进行字符和字符串编码时，仅使用 Unicode码点并不够。具体地说，进行字符串编码时，如果有特定长度 和符号特征的类型，将很有帮助，而类型wchar_t的长度和符号特征随 实现而已。因此，C++11新增了类型char16_t和char32_t，其中前者是无 符号的，长16位，而后者也是无符号的，但长32位。C++11使用前缀u 表示char16_t字符常量和字符串常量，如u‘C’和u“be good”；并使用前缀 U表示char32_t常量，如U‘R’和U“dirty rat”。类型char16_t与/u00F6形式 的通用字符名匹配，而类型char32_t与/U0000222B形式的通用字符名匹 配。前缀u和U分别指出字符字面值的类型为char16_t和char32_t：</p><div class="code-wrapper"><pre><code class="hljs python">char16_t ch1=<span class="hljs-string">u&#x27;q&#x27;</span>;char32_t ch2=<span class="hljs-string">U&#x27;\U000222B&#x27;</span></code></pre></div><p>与wchar_t一样，char16_t和char32_t也都有底层类型—一种内置的 整型，但底层类型可能随系统而已。 </p><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a><strong>bool</strong>类型</h3><p>ANSI/ISO C++标准添加了一种名叫bool的新类型（对C++来说是新 的）。在计算中，布尔变量的值可以是true或false。C++和C一样，也没有布尔类型。C++将 非零值解释为true，将零解释为false。然而，现在可以使用bool类型来 表示真和假了，它们分别用预定义的字面值true和false表示。也就是 说，可以这样编写语句：</p><div class="code-wrapper"><pre><code class="hljs routeros">bool <span class="hljs-attribute">is_ready</span>=<span class="hljs-literal">true</span>;</code></pre></div><p>字面值true和false都可以通过提升转换为int类型，true被转换为1， 而false被转换为0： </p><div class="code-wrapper"><pre><code class="hljs routeros">int <span class="hljs-attribute">ans</span>=<span class="hljs-literal">true</span>;int <span class="hljs-attribute">promise</span>=<span class="hljs-literal">false</span>;</code></pre></div><p>另外，任何数字值或指针值都可以被隐式转换（即不用显式强制转 换）为bool值。任何非零值都被转换为true，而零被转换为false： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">bool</span> start=<span class="hljs-number">-100</span> <span class="hljs-comment">//true</span><span class="hljs-type">bool</span> stop=<span class="hljs-number">0</span> <span class="hljs-comment">//false</span></code></pre></div><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a><strong>const</strong>限定符</h3><p>是使用const关键字来修改变量声明和初始化</p><div class="code-wrapper"><pre><code class="hljs abnf">const int Months<span class="hljs-operator">=</span><span class="hljs-number">12</span><span class="hljs-comment">;</span></code></pre></div><p>这样，便可以在程序中使用Months，而不是12了（在程序中，12可 能表示一英尺有多少英寸或一打面包圈是多少个，而名称Months指出了 值12表示的是什么）。常量（如Months）被初始化后，其值就被固定 了，编译器将不允许再修改该常量的值。如果您这样做，g++将指出程 序试图给一个只读变量赋值。关键字const叫做限定符，因为它限定了声 明的含义</p><p>一种常见的做法是将名称的首字母大写，以提醒您Months是个常 量。这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。 另一种约定是将整个名称大写，使用#define创建常量时通常使用这种约 定。还有一种约定是以字母k打头，如kmonths。当然，还有其他约定。 很多组织都有特殊的编码约定，要求其程序员遵守</p><p>如果以前使用过C语言，您可能觉得前面讨论的#define语句已经足 够完成这样的工作了。但const比#defien好。首先，它能够明确指定类 型。其次，可以使用C++的作用域规则将定义限制在特定的函数或文件 中（作用域规则描述了名称在各种模块中的可知程度，将在第9章讨 论）。第三，可以将const用于更复杂的类型，如第4章将介绍的数组和 结构</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="书写浮点数"><a href="#书写浮点数" class="headerlink" title="书写浮点数"></a>书写浮点数</h4><p>C++有两种书写浮点数的方式。第一种是使用常用的标准小数点表示法</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">12</span>.<span class="hljs-number">34</span><span class="hljs-attribute">93900</span>.<span class="hljs-number">32</span><span class="hljs-attribute">0</span>.<span class="hljs-number">0023</span><span class="hljs-attribute">8</span>.<span class="hljs-number">0</span></code></pre></div><p>第二种表示浮点值的方法叫做E表示法，</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>.<span class="hljs-number">52</span>e+<span class="hljs-number">8</span><span class="hljs-attribute">8</span>.<span class="hljs-number">33</span>E-<span class="hljs-number">4</span><span class="hljs-attribute">7E5</span></code></pre></div><p>E表示法确保数字以浮点格式存储，即使没有小数点。注意，既可 以使用E也可以使用e，指数可以是正数也可以是负数。然而，数字中不能有空格，因此7.2 E6是非法的</p><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>和ANSI C一样，C++也有3种浮点类型：float、double和long double。这些类型是按它们可以表示的有效数位和允许的指数最小范围来描述的。有效位（significant figure）是数字中有意义的位。例如，加利福尼亚的Shasta山脉的高度为14179英尺，该数字使用了5个有效位，指出了最接近的英尺数。然而，将Shasta山脉的高度写成约14000英尺 时，有效位数为2位，因为结果经过四舍五入精确到了千位。在这种情 况下，其余的3位只不过是占位符而已。有效位数不依赖于小数点的位 置。例如，可以将高度写成14.162千英尺。这样仍有5个有效位，因为 这个值精确到了第5位.</p><p>事实上，C和C++对于有效位数的要求是，float至少32位，double至 少48位，且不少于float，long double至少和double一样多。这三种类型 的有效位数可以一样多。然而，通常，float为32位，double为64位， long double为80、96或128位。另外，这3种类型的指数范围至少是−37到37。可以从头文件cfloat或float.h中找到系统的限制。（cfloat是C语言 的float.h文件的C++版本。）</p><div class="code-wrapper"><pre><code class="hljs js">#include &lt;iostream&gt;int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;  using namespace std;  cout.<span class="hljs-title function_">setf</span>(<span class="hljs-attr">ios_base</span>::fixed, <span class="hljs-attr">ios_base</span>::floatfield); <span class="hljs-comment">// fixed-point</span>  float tub = <span class="hljs-number">10.0</span> / <span class="hljs-number">3.0</span>;  double mint = <span class="hljs-number">10.0</span> / <span class="hljs-number">3.0</span>;  <span class="hljs-keyword">const</span> float million = <span class="hljs-number">1.0e6</span>;  cout &lt;&lt; <span class="hljs-string">&quot;tub = &quot;</span> &lt;&lt; tub;  cout &lt;&lt; <span class="hljs-string">&quot;, a million tubs = &quot;</span> &lt;&lt; million * tub;  cout &lt;&lt; <span class="hljs-string">&quot;, \n and ten million tubs = &quot;</span>;  cout &lt;&lt; <span class="hljs-number">10</span> * million * tub &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;min t= &quot;</span> &lt;&lt; mint &lt;&lt; <span class="hljs-string">&quot; and a minillion mints = &quot;</span>;  cout &lt;&lt; million * mint &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// tub = 3.333333, a million tubs = 3333333.250000,</span><span class="hljs-comment">//  and ten million tubs = 33333332.000000</span><span class="hljs-comment">// min t= 3.333333 and a minillion mints = 3333333.333333</span></code></pre></div><p>通常cout会删除结尾的零。例如，将3333333.250000显示为 3333333.25。调用cout.setf( )将覆盖这种行为，至少在新的实现中是这样 的。这里要注意的是，为何float的精度比double低。tub和mint都被初始 化为10.0/3.0—3.333333333333333333……由于cout打印6位小数，因此 tub和mint都是精确的。但当程序将每个数乘以一百万后，tub在第7个3 之后就与正确的值有了误差。tub在7位有效位上还是精确的（该系统确 保float至少有6位有效位，但这是最糟糕的情况）。然而，double类型的 变量显示了13个3，因此它至少有13位是精确的。由于系统确保15位有效位，因此这就没有什么好奇怪的了。另外，将tub乘以一百万，再乘以10后，得到的结果不正确，这再一次指出了float的精度限制。</p><h4 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h4><p>在程序中书写浮点常量的时候，程序将把它存储为哪种浮点类型呢？在默认情况下，像8.24和2.4E8这样的浮点常量都属于double类型。 如果希望常量为float类型，请使用f或F后缀。对于long double类型，可使用l或L后缀（由于l看起来像数字1，因此L是更好的选择）。下面是 一些示例： </p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">1.234</span>f <span class="hljs-regexp">//</span>a float constant;<span class="hljs-number">2.45</span>E20F <span class="hljs-regexp">//</span>a float constant;<span class="hljs-number">2.345324</span>E28 <span class="hljs-regexp">//</span>a double constant;<span class="hljs-number">2.2</span>L <span class="hljs-regexp">//</span>a long double constant;</code></pre></div><h4 id="浮点数的优缺点"><a href="#浮点数的优缺点" class="headerlink" title="浮点数的优缺点"></a>浮点数的优缺点</h4><p>与整数相比，浮点数有两大优点。首先，它们可以表示整数之间的 值。其次，由于有缩放因子，它们可以表示的范围大得多。另一方面， 浮点运算的速度通常比整数运算慢，且精度将降低</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">float</span> a = <span class="hljs-number">2.34E+22</span>f;  <span class="hljs-type">float</span> b = a + <span class="hljs-number">1.0f</span>;  cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;b - a = &quot;</span> &lt;&lt; b - a &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p><strong>有些基于ANSI C之前的编译器的老式C++实现不支持浮点常量后缀f。如果出现这样的问题， 可以用2.34E+22代替2.34E+22f，用(float) 1.0代替1.0f。</strong></p><p>该程序将数字加1，然后减去原来的数字。结果应该为1。下面是在 某个系统上运行时该程序的输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=<span class="hljs-number">2</span>.<span class="hljs-number">34</span>e+<span class="hljs-number">022</span><span class="hljs-attribute">b</span>-a=<span class="hljs-number">0</span></code></pre></div><p>问题在于，2.34E+22是一个小数点左边有23位的数字。加上1，就 是在第23位加1。但float类型只能表示数字中的前6位或前7位，因此修 改第23位对这个值不会有任何影响。</p><p>C++对基本类型进行分类，形成了若干个族。类型signed char、short、int和long统称为符 号整型；它们的无符号版本统称为无符号整型；C++11新增了long long。bool、char、 wchar_t、符号整数和无符号整型统称为整型；C++11新增了char16_t和char32_t。float、double和long double统称为浮点型。整数和浮点型统称算术（arithmetic）类型</p><h2 id="C-算术运算符"><a href="#C-算术运算符" class="headerlink" title="C++算术运算符"></a>C++算术运算符</h2><p>C++使用运算符来运算。它提供了几种运算符来完成5 种基本的算术计算：加法、减法、乘法、除法以及求模。每种运算符都使用两个值（操作数）来计算结果。运算符及其操作数构成了表达式。</p><p>下面是5种基本的C++算术运算符。</p><ol><li>+运算符对操作数执行加法运算。例如，4+20等于24。 </li><li>−运算符从第一个数中减去第二个数。例如，12−3等于9。 </li><li>运算符将操作数相乘。例如，<em>28</em>4等于112。 </li><li>/运算符用第一个数除以第二个数。例如，1000/5等于200。如果两 个操作数都是整数，则结果为商的整数部分。例如，17/3等于5， 小数部分被丢弃。 </li><li>%运算符求模。也就是说，它生成第一个数除以第二个数后的余 数。例如，19%6为1，因为19是6的3倍余1。两个操作数必须都是 整型，将该运算符用于浮点数将导致编译错误。如果其中一个是负 数，则结果的符号满足如下规则：(a/b)*b + a%b ＝ a。 </li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">float</span> hats, heads;  cout.<span class="hljs-built_in">setf</span>(ios::fixed, ios_base::floatfield);  cout &lt;&lt; <span class="hljs-string">&quot;enter a number : &quot;</span>;  cin &gt;&gt; hats;  cout &lt;&lt; <span class="hljs-string">&quot;enter another number : &quot;</span>;  cin &gt;&gt; heads;  cout &lt;&lt; <span class="hljs-string">&quot;hats = &quot;</span> &lt;&lt; hats &lt;&lt; <span class="hljs-string">&quot;; heads = &quot;</span> &lt;&lt; heads &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;hats + heads = &quot;</span> &lt;&lt; hats + heads &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;hats - heads = &quot;</span> &lt;&lt; hats - heads &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;hats / heads = &quot;</span> &lt;&lt; hats / heads &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;hats * heads = &quot;</span> &lt;&lt; hats * heads &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// enter a number : 50.25</span><span class="hljs-comment">// enter another number : 11.17</span><span class="hljs-comment">// hats = 50.250000; heads = 11.170000</span><span class="hljs-comment">// hats + heads = 61.419998</span><span class="hljs-comment">// hats - heads = 39.080002</span><span class="hljs-comment">// hats / heads = 4.498657</span><span class="hljs-comment">// hats * heads = 561.292480</span></code></pre></div><p>11.17加上50.25应等于61.42，但 是输出中却是61.419998。这不是运算问题；而是由于float类型表示有效位数的能力有限。记住，对于float，C++只保证6位有效位。如果将 61.419998四舍五入成6位，将得到61.4200，这是保证精度下的正确值。如果需要更高的精度，请使用double或long double。</p><div class="code-wrapper"><pre><code class="hljs js">#include &lt;iostream&gt;int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;  using namespace std;  cout.<span class="hljs-title function_">setf</span>(<span class="hljs-attr">ios_base</span>::fixed, <span class="hljs-attr">ios_base</span>::floatfield);  cout &lt;&lt; <span class="hljs-string">&quot;interger division:9/5 = &quot;</span> &lt;&lt; <span class="hljs-number">9</span> / <span class="hljs-number">5</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;floating-point : 9.0/5.0 = &quot;</span> &lt;&lt; <span class="hljs-number">9.0</span> / <span class="hljs-number">5.0</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;mixed division: 9.0/5 = &quot;</span> &lt;&lt; <span class="hljs-number">9.0</span> / <span class="hljs-number">5</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;double constants : 1e7/9.0 = &quot;</span> &lt;&lt; <span class="hljs-number">1.e7</span> / <span class="hljs-number">9.0</span> &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot;float constants: 1e7f/9.0f = &quot;</span>;  cout &lt;&lt; <span class="hljs-number">1.</span>e7f / <span class="hljs-number">9.</span>0f &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// interger division:9/5 = 1</span><span class="hljs-comment">// floating-point : 9.0/5.0 = 1.800000</span><span class="hljs-comment">// mixed division: 9.0/5 = 1.800000</span><span class="hljs-comment">// double constants : 1e7/9.0 = 1111111.111111</span><span class="hljs-comment">// float constants: 1e7f/9.0f = 1111111.125000</span></code></pre></div><p>整数9除以5的结果为整数1。4/5的小数部分 （或0.8）被丢弃。在本章后面学习求模运算符时，将会看到这种除法的实际应用。接下来的两行表明，当至少有一个操作数是浮点数时，结 果为1.8。实际上，对不同类型进行运算时，C++将把它们全部转换为同 一类型。本章稍后将介绍这种自动转换。最后两行的相对精度表明，如 果两个操作数都是double类型，则结果为double类型；如果两个操作数 都是float类型，则结果为float类型。记住，浮点常量在默认情况下为 double类型。 </p><p>除法运算符表示了3种不同的运算：int除法、float除法和double除法。 </p><p>C++根据上下文（这里是操作数的类型）来确定运算符的含义。使用相同的符号进行多种操作 叫做运算符重载（operator overloading）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">const</span> <span class="hljs-type">int</span> Lbs_per_stn = <span class="hljs-number">14</span>;  <span class="hljs-type">int</span> lbs;  cout &lt;&lt; <span class="hljs-string">&quot;enter your weight in pounds: &quot;</span>;  cin &gt;&gt; lbs;  <span class="hljs-type">int</span> stone = lbs / Lbs_per_stn;  <span class="hljs-type">int</span> pounds = lbs % Lbs_per_stn;  cout &lt;&lt; lbs &lt;&lt; <span class="hljs-string">&quot; pound are &quot;</span> &lt;&lt; stone &lt;&lt; <span class="hljs-string">&quot; stone &quot;</span> &lt;&lt; pounds &lt;&lt; <span class="hljs-string">&quot;pound(s). \n&quot;</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// enter your weight in pounds: 181</span><span class="hljs-comment">// 181 pound are 12 stone 13pound(s).</span></code></pre></div><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>C++自动执行很多类型转换：</p><p>将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进 行转换； </p><p>表达式中包含不同的类型时，C++将对值进行转换； </p><p>将参数传递给函数时，C++将对值进行转换</p><p>C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将 被转换为接收变量的类型。例如，假设so_long的类型为long，thirty的类 型为short，而程序中包含这样的语句：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">so_long</span>=thirty<span class="hljs-comment">;</span></code></pre></div><p>则进行赋值时，程序将thirty的值（通常是16位）扩展为long值（通 常为32位）。扩展后将得到一个新值，这个值被存储在so_long中，而 thirty的内容不变。</p><p>将一个值赋给值取值范围更大的类型通常不会导致什么问题。例 如，将short值赋给long变量并不会改变这个值，只是占用的字节更多而 已。然而，将一个很大的long值（如2111222333）赋给float变量将降低 精度。因为float只有6位有效数字，因此这个值将被四舍五入为 2.11122E9。因此，有些转换是安全的，有些则会带来麻烦。表3.3列出 了一些可能出现的转换问题</p><table><thead><tr><th>转换</th><th>潜在问题</th></tr></thead><tbody><tr><td>将较大的浮点类型转换为较小的 浮点类型，如将double转换为float</td><td>精度（有效数位）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的</td></tr><tr><td>将浮点类型转换为整型</td><td>小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的</td></tr><tr><td>将较大的整型转换为较小的整 型，如将long转换为short</td><td>原来的值可能超出目标类型的取值范围，通常只复制右边的字节</td></tr></tbody></table><p>将0赋给bool变量时，将被转换为false；而非零值将被转换为true。将浮点值赋给整型将导致两个问题。首先，将浮点值转换为整型会 </p><p>将数字截短（除掉小数部分）。其次，float值对于int变量来说可能太大 了。在这种情况下，C++并没有定义结果应该是什么；这意味着不同的 实现的反应可能不同。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  cout.<span class="hljs-built_in">setf</span>(ios_base::fixed, ios_base::floatfield);  <span class="hljs-type">float</span> tree = <span class="hljs-number">3</span>;  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">guess</span><span class="hljs-params">(<span class="hljs-number">3.9832</span>)</span></span>;  <span class="hljs-type">int</span> debt = <span class="hljs-number">7.2E12</span>;  cout &lt;&lt; <span class="hljs-string">&quot; tree = &quot;</span> &lt;&lt; tree &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot; guess = &quot;</span> &lt;&lt; guess &lt;&lt; endl;  cout &lt;&lt; <span class="hljs-string">&quot; debt= &quot;</span> &lt;&lt; debt &lt;&lt; endl;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">tree = 3.000000</span><span class="hljs-comment"> guess = 3</span><span class="hljs-comment"> debt= 1</span><span class="hljs-comment">*/</span></code></pre></div><p>在这个程序中，将浮点值3.0赋给了tree。将3.9832赋给int变量guess 导致这个值被截取为3。将浮点型转换为整型时，C++采取截取（丢弃 小数部分）而不是四舍五入（查找最接近的整数）。最后，int变量debt 无法存储3.0E12，这导致C++没有对结果进行定义的情况发生。在这种 系统中，debt的结果为1634811904，或大约1.6E09。 当您将整数变量初始化为浮点值时，有些编译器将提出警告，指出 这可能丢掉数据。另外，对于debt变量，不同编译器显示的值也可能不 同。例如，在另一个系统上运行该程序时，得到的值为2147483647。</p><h5 id="以-方式初始化时进行的转换"><a href="#以-方式初始化时进行的转换" class="headerlink" title="以**{ }**方式初始化时进行的转换"></a>以**{ }**方式初始化时进行的转换</h5><p>C++11将使用大括号的初始化称为列表初始化（list- initialization），因为这种初始化常用于给复杂的数据类型提供值列表</p><p>具体地说，列表初始化不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。例如，不允许将浮点型转换为整型。在不同的整型 之间转换或将整型转换为浮点型可能被允许，条件是编译器知道目标变量能够正确地存储赋给它的值。例如，可将long变量初始化为int值，因为long总是至少与int一样长；相反方向的转换也可能被允许，只要int变量能够存储赋给它的long常量： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <span class="hljs-type">const</span> <span class="hljs-type">int</span> code = <span class="hljs-number">66</span>;  <span class="hljs-type">int</span> x = <span class="hljs-number">66</span>;  <span class="hljs-type">char</span> c1 = &#123;<span class="hljs-number">66</span>&#125;;  <span class="hljs-type">char</span> c2 = &#123;<span class="hljs-number">313155</span>&#125;;  <span class="hljs-type">char</span> c3 = &#123;code&#125;;  <span class="hljs-type">char</span> c4 = &#123;x&#125;;  x = <span class="hljs-number">31325</span>;  <span class="hljs-type">char</span> c5 = x;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>在上述代码中，初始化c4时，您知道x的值为66，但在编译器看来，x是一个变量，其值可能很大。编译器不会跟踪下述阶段可能发生 的情况：从x被初始化到它被用来初始化c4。</p><h5 id="表达式中的转换"><a href="#表达式中的转换" class="headerlink" title="表达式中的转换"></a>表达式中的转换</h5><p>当同一个表达式中包含两种不同的算术类型时，将出现什么情况 呢？在这种情况下，C++将执行两种自动转换：首先，一些类型在出现 时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时 将被转换。 </p><p>先来看看自动转换。在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true被转换为1，false 被转换为0。这些转换被称为整型提升（integral promotion）。例如，请 看下面的语句： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">short</span> chickens = <span class="hljs-number">20</span>; <span class="hljs-type">short</span> ducks = <span class="hljs-number">35</span>; <span class="hljs-type">short</span> fowl = chickens + ducks;</code></pre></div><p>为执行第3行语句，C++程序取得chickens和ducks的值，并将它们转 换为int。然后，程序将结果转换为short类型，因为结果将被赋给一个 short变量。这种说法可能有点拗口，但是情况确实如此。通常将int类型 选择为计算机最自然的类型，这意味着计算机使用这种类型时，运算速度可能最快。 </p><p>还有其他一些整型提升：如果short比int短，则unsigned short类型将 被转换为int；如果两种类型的长度相同，则unsigned short类型将被转换 为unsigned int。这种规则确保了在对unsigned short进行提升时不会损失数据。</p><p>同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t 取值范围的类型：int、unsigned int、long或unsigned long。将不同类型进行算术运算时，也会进行一些转换，例如将int和float 相加时。当运算涉及两种类型时，较小的类型将被转换为较大的类型</p><p>（1）如果有一个操作数的类型是long double，则将另一个操作数 转换为long double。 </p><p>（2）否则，如果有一个操作数的类型是double，则将另一个操作 数转换为double。 </p><p>（3）否则，如果有一个操作数的类型是float，则将另一个操作数 转换为float。 </p><p>（4）否则，说明操作数都是整型，因此执行整型提升</p><p>（5）在这种情况下，如果两个操作数都是有符号或无符号的，且 其中一个操作数的级别比另一个低，则转换为级别高的类型。</p><p>（6）如果一个操作数为有符号的，另一个操作数为无符号的，且 无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符 </p><p>号操作数所属的类型。</p><p>（7）否则，如果有符号类型可表示无符号类型的所有可能取值， 则将无符号操作数转换为有符号操作数所属的类型。 </p><p>（8）否则，将两个操作数都转换为有符号类型的无符号版本。 </p><p>ANSI C遵循的规则与ISO 2003 C++相同，这与前述规则稍有不同； 而传统K&amp;R C的规则又与ANSI C稍有不同。例如，传统C语言总是将 float提升为double，即使两个操作数都是float。</p><p>前面的列表谈到了整型级别的概念。简单地说，有符号整型按级别 从高到低依次为long long、long、int、short和signed char。无符号整型 的排列顺序与有符号整型相同。类型char、signed char和unsigned char的 级别相同。类型bool的级别最低。wchar_t、char16_t和char32_t的级别与其底层类型相同。</p><h5 id="传递参数时的转换"><a href="#传递参数时的转换" class="headerlink" title="传递参数时的转换"></a>传递参数时的转换</h5><p>传递参数时的类型转换通常由C++函数原型,控制。然而，也可以取消原型对参数传递的控制，尽管这样做并不明 智。在这种情况下C++将对char和short类型（signed和unsigned）应用 整型提升。另外，为保持与传统C语言中大量代码的兼容性，在将参数 传递给取消原型对参数传递控制的函数时，C++将float参数提升为 double</p><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>C++还允许通过强制类型转换机制显式地进行类型转换。（C++认识到，必须有类型规则，而有时又需要推翻这些规则。）强制类型转换 的格式有两种。例如，为将存储在变量thorn中的int值转换为long类型,可以使用下述表达式中的一种： </p><div class="code-wrapper"><pre><code class="hljs cpp">(<span class="hljs-type">long</span>) thron; <span class="hljs-comment">//returns a type long conversion of thorn</span><span class="hljs-built_in">long</span> (thron) <span class="hljs-comment">//returns a type long conversion of thorn</span></code></pre></div><p>强制类型转换不会修改thorn变量本身，而是创建一个新的、指定类 型的值，可以在表达式中使用这个值。</p><p>第一种格式来自C语言，第二种格式是纯粹的C++。新格式的想法 是，要让强制类型转换就像是函数调用。这样对内置类型的强制类型转 换就像是为用户定义的类设计的类型转换</p><p>C++还引入了4个强制类型转换运算符，对它们的使用要求更为严 格，这将在第15章介绍。在这四个运算符中，static_cast&lt;&gt;可用于将值 从一种数值类型转换为另一种数值类型。例如，可以像下面这样将thorn 转换为long类型： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span>&gt; (thron);<span class="hljs-comment">//returns a type long conversion of thron</span></code></pre></div><p>推而广之，可以这样做：</p><div class="code-wrapper"><pre><code class="hljs elm"><span class="hljs-title">static_cast</span>&lt;typeName&gt; (value);</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> auks ,bats,coots;    auks=<span class="hljs-number">19.99</span>+<span class="hljs-number">11.99</span>;    bats=(<span class="hljs-type">int</span>)<span class="hljs-number">19.99</span>+(<span class="hljs-type">int</span>)<span class="hljs-number">11.99</span>;    coots=<span class="hljs-built_in">int</span> (<span class="hljs-number">19.99</span>) + <span class="hljs-built_in">int</span> (<span class="hljs-number">11.99</span>);    cout &lt;&lt; <span class="hljs-string">&quot;auks = &quot;</span>&lt;&lt;auks&lt;&lt;<span class="hljs-string">&quot; , bats = &quot;</span>&lt;&lt;bats;    cout &lt;&lt; <span class="hljs-string">&quot; , coots = &quot;</span> &lt;&lt;coots&lt;&lt;endl;    <span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27;Z&#x27;</span>;    cout &lt;&lt; <span class="hljs-string">&quot; The code for &quot;</span> &lt;&lt; ch &lt;&lt; <span class="hljs-string">&quot;is &quot;</span>&lt;&lt; <span class="hljs-built_in">int</span>(ch) &lt;&lt;endl;    cout &lt;&lt; <span class="hljs-string">&quot; yes the code is &quot;</span>&lt;&lt;<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(ch);    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>该程序指出了使用强制类型转换的两个原因。首先，可能有一些值 被存储为double类型，但要使用它们来计算得到一个int类型的值。例 如，可能要用浮点数来对齐网格或者模拟整数值（如人口）。程序员可 能希望在计算时将值视为int，强制类型转换允许直接这样做。注意，将 值转换为int，然后相加得到的结果，与先将值相加，然后转换为int是不 同的，至少对于这些值来说是不同的。</p><h4 id="C-11中的auto声明"><a href="#C-11中的auto声明" class="headerlink" title="C++11中的auto声明"></a>C++11中的auto声明</h4><p>C++11新增了一个工具，让编译器能够根据初始值的类型推断变量 的类型。为此，它重新定义了auto的含义。auto是一个C语言关键字，但 很少使用。在初始化声明中，如果 使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成 与初始值相同：</p><div class="code-wrapper"><pre><code class="hljs abnf">auto n<span class="hljs-operator">=</span><span class="hljs-number">100</span><span class="hljs-comment">; //int</span>auto x<span class="hljs-operator">=</span><span class="hljs-number">1.5</span><span class="hljs-comment">; //double</span>auto y<span class="hljs-operator">=</span><span class="hljs-number">1.3</span>e12L<span class="hljs-comment">; //long double</span></code></pre></div><p>然而，自动推断类型并非为这种简单情况而设计的；事实上，如果 将其用于这种简单情形，甚至可能让您误入歧途。例如，假设您要将 x、y和z都指定为double类型，并编写了如下代码：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">auto</span> x = <span class="hljs-number">0</span>.<span class="hljs-number">0</span>; //x is double because <span class="hljs-number">0</span>.<span class="hljs-number">0</span><span class="hljs-attribute">double</span> y = <span class="hljs-number">0</span>; //<span class="hljs-number">0</span> automatically converted to <span class="hljs-number">0</span>.<span class="hljs-number">0</span>;<span class="hljs-attribute">auto</span> z = <span class="hljs-number">0</span>; //z is int because <span class="hljs-number">0</span> is int;</code></pre></div><p>显式地声明类型时，将变量初始化0（而不是0.0）不会导致任何问题，但采用自动类型推断时，这却会导致问题。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>C++的基本类型分为两组：一组由存储为整数的值组成，另一组由 存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无 符号来区分。整型从最小到最大依次是：bool、char、signed char、 unsigned char、short、unsigned short、int、unsigned int、long、unsigned long以及C++11新增的long long和unsigned long long。还有一种wchar_t 类型，它在这个序列中的位置取决于实现。C++11新增了类型char16_t 和char32_t，它们的宽度足以分别存储16和32位的字符编码。C++确保 了char足够大，能够存储系统基本字符集中的任何成员，而wchar_t则可 以存储系统扩展字符集中的任意成员，short至少为16位，而int至少与 short一样长，long至少为32位，且至少和int一样长。确切的长度取决于 实现。</p><p>字符通过其数值编码来表示。I/O系统决定了编码是被解释为字符 还是数字。浮点类型可以表示小数值以及比整型能够表示的值大得多的值。3 种浮点类型分别是float、double和long double。C++确保float不比double 长，而double不比long double长。通常，float使用32位内存，double使用 64位，long double使用80到128位</p><p>通过提供各种长度不同、有符号或无符号的类型，C++使程序员能 够根据特定的数据要求选择合适的类型</p><p>C++使用运算符来提供对数字类型的算术运算：加、减、乘、除和 求模。当两个运算符对同一个操作数进行操作时，C++的优先级和结合 性规则可以确定先执行哪种操作。</p><p>对变量赋值、在运算中使用不同类型、使用强制类型转换时， C++将把值从一种类型转换为另一种类型。很多类型转换都是“安全 的”，即可以在不损失和改变数据的情况下完成转换。例如，可以把int 值转换为long值，而不会出现任何问题。对于其他一些转换，如将浮点 类型转换为整型，则需要更加小心。</p><h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>要创建数组，可使用声明语句。数组声明应指出以下三点：</p><p>存储在每个元素中的值的类型； </p><p>数组名； </p><p>数组中的元素数</p><p>在C++中，可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。例如，下面的声明创建一个名为months的 数组，该数组有12个元素，每个元素都可以存储一个short类型的值</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">short</span> months[<span class="hljs-number">12</span>]</code></pre></div><p>事实上，可以将数组中的每个元素看作是一个简单变量。 声明数组的通用格式如下</p><div class="code-wrapper"><pre><code class="hljs abnf">typeName srrayName[arraySize]<span class="hljs-comment">;</span></code></pre></div><p>表达式arraySize指定元素数目，它必须是整型常数（如10）或const 值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编 译时都是已知的。具体地说，arraySize不能是变量，变量的值是在程序 运行时设置的。然而，可以使用new运算符来避开这种限制。</p><p>数组之所以被称为复合类型，是因为它是使用其他类型来创建的（C语言使用术语“派生 类型”，但由于C++对类关系使用术语“派生”，所以它必须创建一个新术语）。不能仅仅将某 种东西声明为数组，它必须是特定类型的数组。没有通用的数组类型，但存在很多特定的数组类型，如char数组或long数组。例如，请看下面的声明： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">float</span> loans[<span class="hljs-number">20</span>]</code></pre></div><p>loans的类型不是“数组”，而是“float数组”。这强调了loans数组是使用float类型创建的</p><p>数组的很多用途都是基于这样一个事实：可以单独访问数组元素。 方法是使用下标或索引来对元素进行编号。C++数组从0开始编号（这 没有商量的余地，必须从0开始。Pascal和BASIC用户必须调整习惯）。 C++使用带索引的方括号表示法来指定数组元素。例如，months[0]是 months数组的第一个元素，months[11]是最后一个元素。注意，最后一 个元素的索引比数组长度小1（参见图4.1）。因此，数组声明能够使用 一个声明创建大量的变量，然后便可以用索引来标识和访问各个元素。</p><p>编译器不会检查使用的下标是否有效。例如，如果将一个值赋给不存在的元素 months[101]，编译器并不会指出错误。但是程序运行后，这种赋值可能引发问题，它可能破坏数据或代码，也可能导致程序异常终止。所以必须确保程序只使用有效的下标值</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> yams[<span class="hljs-number">3</span>];    yams[<span class="hljs-number">0</span>]=<span class="hljs-number">7</span>;    yams[<span class="hljs-number">1</span>]=<span class="hljs-number">8</span>;    yams[<span class="hljs-number">2</span>]=<span class="hljs-number">6</span>;    <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">5</span>&#125;;    cout &lt;&lt; <span class="hljs-string">&quot;total yams = &quot;</span>;    cout &lt;&lt; yams[<span class="hljs-number">0</span>] + yams[<span class="hljs-number">1</span>]+yams[<span class="hljs-number">2</span>]&lt;&lt;endl;    cout &lt;&lt; <span class="hljs-string">&quot;the package with &quot;</span> &lt;&lt; yams[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; yams costs&quot;</span>;    cout &lt;&lt; arr[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot; cents per yam. \n&quot;</span>;    <span class="hljs-type">int</span> total=yams[<span class="hljs-number">0</span>]*arr[<span class="hljs-number">0</span>]+yams[<span class="hljs-number">1</span>]*arr[<span class="hljs-number">1</span>];    total=total+yams[<span class="hljs-number">2</span>]*arr[<span class="hljs-number">2</span>];    cout &lt;&lt; <span class="hljs-string">&quot;the total yam expense is &quot;</span> &lt;&lt; total &lt;&lt; <span class="hljs-string">&quot; cents . \n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;\n Size of yams array =&quot;</span> &lt;&lt;<span class="hljs-keyword">sizeof</span> yams;    cout &lt;&lt; <span class="hljs-string">&quot; bytes. \n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Size of one element &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span> yams[<span class="hljs-number">0</span>];    cout &lt;&lt; <span class="hljs-string">&quot; bytes . \n&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//total yams = 21</span><span class="hljs-comment">//the package with 8 yams costs30 cents per yam.</span><span class="hljs-comment">//the total yam expense is 410 cents .</span><span class="hljs-comment">//</span><span class="hljs-comment">//Size of yams array =12 bytes.</span><span class="hljs-comment">//Size of one element 4 bytes . </span></code></pre></div><p>sizeof运算符返回类型或数据对象的长度（单位为字节）。注意，如果将sizeof运算符用于数组名，得到的将是整个数组中的字节数。但如果将sizeof用于数组元素，则得到的将是元素的长度（单位为字节）</p><h3 id="数组的初始化规则"><a href="#数组的初始化规则" class="headerlink" title="数组的初始化规则"></a>数组的初始化规则</h3><p>只有在定义数组时才能使用初始化，此后就不能使用了，也不能将 一个数组赋给另一个数组： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cards[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<span class="hljs-comment">//okey</span><span class="hljs-type">int</span> hand[<span class="hljs-number">4</span>]; <span class="hljs-comment">//okey</span>hand[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">//not allowed</span>hand=cards; <span class="hljs-comment">//not allowed</span></code></pre></div><p>然而，可以使用下标分别给数组中的元素赋值。初始化数组时，提供的值可以少于数组的元素数目</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">float</span> hoteltips[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">5.0</span>,<span class="hljs-number">2.5</span>&#125;;</code></pre></div><p>如果只对数组的一部分进行初始化，则编译器将把其他元素设置为 0。因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第 一个元素初始化为0，然后让编译器将其他元素都初始化为0即可</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">long</span> totals[<span class="hljs-number">500</span>]=&#123;<span class="hljs-number">0</span>&#125;;</code></pre></div><p>如果初始化为{1}而不是{0}，则第一个元素被设置为1，其他元素 都被设置为0。</p><p>如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个 数。例如，对于下面的声明：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">short</span> things[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;</code></pre></div><p>通常，让编译器计算元素个数是种很糟的做法，因为其计数可能与您想象的不一样。例 如，您可能不小心在列表中遗漏了一个值。然而，这种方法对于将字符数组初始化为一个字 符串来说比较安全，很快您将明白这一点。如果主要关心的问题是程序，而不是自己是否知 道数组的大小，则可以这样做： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">short</span> things[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;;<span class="hljs-type">int</span> num_elements=<span class="hljs-keyword">sizeof</span> things/ <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span>);</code></pre></div><h3 id="C-11数组初始化方法"><a href="#C-11数组初始化方法" class="headerlink" title="C++11数组初始化方法"></a>C++11数组初始化方法</h3><p>C++11将使用大括号的初始化（列表初始化）作为一 种通用初始化方式，可用于所有类型。数组以前就可使用列表初始化， 但C++11中的列表初始化新增了一些功能。 </p><p>首先，初始化数组时，可省略等号（=）： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">double</span> earnings[<span class="hljs-number">4</span>] &#123;<span class="hljs-number">1.2e4</span>,<span class="hljs-number">1.3e4</span>,<span class="hljs-number">1.3e6</span>,<span class="hljs-number">1.6e4</span>&#125;;</code></pre></div><p>可不在大括号内包含任何东西，这将把所有元素都设置为零</p><div class="code-wrapper"><pre><code class="hljs cpp">usinged <span class="hljs-type">int</span> couts[<span class="hljs-number">10</span>]=&#123;&#125;;<span class="hljs-type">float</span> balance[<span class="hljs-number">100</span>] &#123;&#125;;</code></pre></div><p>列表初始化禁止缩窄准换</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">long</span> printf[]=&#123;<span class="hljs-number">90</span>,<span class="hljs-number">25</span>,<span class="hljs-number">3.4</span>&#125;; <span class="hljs-comment">//not allowed</span><span class="hljs-type">char</span> shifts[<span class="hljs-number">4</span>] &#123;<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">1122011</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;; <span class="hljs-comment">//not allowed</span><span class="hljs-type">char</span> tlifs[<span class="hljs-number">4</span>] &#123;<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-number">112</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;; <span class="hljs-comment">//allowed</span></code></pre></div><p>在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整 型是缩窄操作，即使浮点数的小数点后面为零。第二条语句也不能通过 编译，因为1122011超出了char变量的取值范围（这里假设char变量的长 度为8位）。第三条语句可通过编译，因为虽然112是一个int值，但它在 char变量的取值范围内。</p><p>C++标准模板库（STL）提供了一种数组替代品—模板类vector，而C++11新增了模板类array。这些替代品比内置复合类型数组更复杂、更灵活</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是存储在内存的连续字节中的一系列字符。C++处理字符串 的方式有两种。第一种来自C语言，常被称为C-风格字符串（C-style string），然后介绍另一种基于string类库的方法</p><p>存储在连续字节中的一系列字符意味着可以将字符串存储在char数 组中，其中每个字符都位于自己的数组元素中。字符串提供了一种存储 文本信息的便捷方式，如提供给用户的消息（“请告诉我您的瑞士银行 账号”）或来自用户的响应（“您肯定在开玩笑”）。C-风格字符串具有 一种特殊的性质：以空字符（null character）结尾，空字符被写作\0， 其ASCII码为0，用来标记字符串的结尾。例如，请看下面两个声明：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> dog[<span class="hljs-number">8</span>]=&#123;<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>&#125;;<span class="hljs-comment">//not a string</span><span class="hljs-type">char</span> cat[<span class="hljs-number">8</span>]=&#123;<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<span class="hljs-comment">//is string</span></code></pre></div><p>这两个数组都是char数组，但只有第二个数组是字符串。空字符对 C-风格字符串而言至关重要。例如，C++有很多处理字符串的函数，其 中包括cout使用的那些函数。它们都逐个地处理字符串中的字符，直到到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示前7个字符，发现空字符后停止。但是，如果使用cout显示上面的dog数组（它不是字符串），cout将打印出数组中的8个字母，并接着将内存中随后的各个字节解释为要打印的字符，直到遇到空字符为止。由于空 字符（实际上是被设置为0的字节）在内存中很常见，因此这一过程将 很快停止。但尽管如此，还是不应将不是字符串的字符数组当作字符串来处理。</p><p>将数组初始化成单个字符数字很不好写，一般不使用这种写法，一般使用字符串常量（string constant）或字符串字面值 （string literal）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> birds[<span class="hljs-number">11</span>]=<span class="hljs-string">&quot;Mr. cheeps&quot;</span>; <span class="hljs-comment">//必须使用双引号，不能使用单引号</span><span class="hljs-type">char</span> fish[]=<span class="hljs-string">&quot;fish&quot;</span>;</code></pre></div><p>用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包 括它。另外，各种C++输入工具通过键盘输入，将字符串 读入到char数组中时，将自动加上结尾的空字符</p><p>当然，应确保数组足够大，能够存储字符串中所有字符—包括空字 符。使用字符串常量初始化字符数组是这样的一种情况，即让编译器计算元素数目更为安全。让数组比字符串长没有什么害处，只是会浪费一些空间而已。这是因为处理字符串的函数根据空字符的位置，而不是数组长度来进行处理。C++对字符串长度没有限制。 </p><p>在确定存储字符串所需的最短数组时，别忘了将结尾的空字符计算在内。</p><p>数组初始化字符串时，剩余的空间会用\0填补注意，字符串常量（使用双引号）不能与字符常量（使用单引号） 互换。字符常量（如’S’）是字符串编码的简写表示。在ASCII系统上，’S’只是83的另一种写法，因此，下面的语句将83赋给shirt_size：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">char</span> shirt_size = <span class="hljs-string">&#x27;S&#x27;</span></code></pre></div><p>但”S”不是字符常量，它表示的是两个字符（字符S和\0）组成的字符串,”S”实际上表示的是字符串所在的内存地址</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">char</span> shirt_size = <span class="hljs-string">&quot;S&quot;</span> <span class="hljs-comment">//这样是不允许的</span></code></pre></div><p>由于地址在C++中是一种独立的类型，因此C++编译器不允许这种不合理的做法</p><h3 id="拼接字符串常量"><a href="#拼接字符串常量" class="headerlink" title="拼接字符串常量"></a>拼接字符串常量</h3><p>C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个。事实上，任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。拼接时不会在被连接的字符串之间添加空格，第二个字符串 的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后 面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。</p><h3 id="在数组中使用字符串"><a href="#在数组中使用字符串" class="headerlink" title="在数组中使用字符串"></a>在数组中使用字符串</h3><p>要将字符串存储到数组中，最常用的方法有两种—将数组初始化为 字符串常量、将键盘或文件输入读入到数组中。程序清单4.2演示了这 两种方法，它将一个数组初始化为用引号括起的字符串，并使用cin将 一个输入字符串放到另一个数组中。该程序还使用了标准C语言库函数 strlen( )来确定字符串的长度。标准头文件cstring（老式实现为string.h） 提供了该函数以及很多与字符串相关的其他函数的声明。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strings.cpp -- storing strings in an array</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>  <span class="hljs-comment">// for the strlen() function</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> Size = <span class="hljs-number">15</span>;    <span class="hljs-type">char</span> name1[Size];               <span class="hljs-comment">// empty array</span>    <span class="hljs-type">char</span> name2[Size] = <span class="hljs-string">&quot;C++owboy&quot;</span>;  <span class="hljs-comment">// initialized array</span>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> some implementations may require the static keyword</span>    <span class="hljs-comment">// to initialize the array name2</span>    cout &lt;&lt; <span class="hljs-string">&quot;Howdy! I&#x27;m &quot;</span> &lt;&lt; name2;    cout &lt;&lt; <span class="hljs-string">&quot;! What&#x27;s your name?\n&quot;</span>;    cin &gt;&gt; name1;    cout &lt;&lt; <span class="hljs-string">&quot;Well, &quot;</span> &lt;&lt; name1 &lt;&lt; <span class="hljs-string">&quot;, your name has &quot;</span>;    cout &lt;&lt; <span class="hljs-built_in">strlen</span>(name1) &lt;&lt; <span class="hljs-string">&quot; letters and is stored\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;in an array of &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(name1) &lt;&lt; <span class="hljs-string">&quot; bytes.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Your initial is &quot;</span> &lt;&lt; name1[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    name2[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;                <span class="hljs-comment">// set to null character</span>    cout &lt;&lt; <span class="hljs-string">&quot;Here are the first 3 characters of my name: &quot;</span>;    cout &lt;&lt; name2 &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Howdy! I&#x27;m C++owboy! What&#x27;s your name?</span><span class="hljs-comment">//basicman</span><span class="hljs-comment">//        Well, basicman, your name has 8 letters and is stored</span><span class="hljs-comment">//        in an array of 15 bytes.</span><span class="hljs-comment">//Your initial is b.</span><span class="hljs-comment">//Here are the first 3 characters of my name: C++</span></code></pre></div><p>首先，sizeof运算符指出整个数组的长度：15字节，但 strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。另外，strlen( ) 只计算可见的字符，而不把空字符计算在内。因此，对于Basicman，返回的值为8，而不是 9。如果cosmic是字符串，则要存储该字符串，数组的长度不能短于strlen（cosmic）+1。</p><p>由于name1和name2是数组，所以可以用索引来访问数组中各个字符。例如，该程序使用 name1[0]找到数组的第一个字符。另外，该程序将name2[3]设置为空字符。这使得字符串在第 3个字符后即结束，虽然数组中还有其他的字符</p><p>该程序使用符号常量来指定数组的长度。程序常常有多条语句使用 了数组长度。使用符号常量来表示数组长度后，当需要修改程序以使用 不同的数组长度时，工作将变得更简单—只需在定义符号常量的地方进 行修改即可。</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-11%2022.40.37.png"></p><h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">20</span>;    <span class="hljs-type">char</span> name[ArSize];    <span class="hljs-type">char</span> dessert[ArSize];    cout &lt;&lt; <span class="hljs-string">&quot;Enter your name:\n&quot;</span>;    cin &gt;&gt; name;    cout &lt;&lt; <span class="hljs-string">&quot;Enter your favorite dessert:\n&quot;</span>;    cin &gt;&gt; dessert;    cout &lt;&lt; <span class="hljs-string">&quot;I have some delicious &quot;</span> &lt;&lt; dessert;    cout &lt;&lt; <span class="hljs-string">&quot; for you, &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter your name:</span><span class="hljs-comment">//Alistair breeb</span><span class="hljs-comment">//Enter your favorite dessert:</span><span class="hljs-comment">//I have some delicious breed for you, Alistair.</span></code></pre></div><p>cin是如何确定已完成字符串输入呢？由于不能通过键盘输入空字 符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白 （空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在 获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符</p><p>这个例子的实际结果是，cin把Alistair作为第一个字符串，并将它 放到name数组中。这把Dreeb留在输入队列中。当cin在输入队列中搜索 用户喜欢的甜点时，它发现了Dreeb，因此cin读取Dreeb，并将它放到 dessert数组中</p><h3 id="每次读取一行字符串输入"><a href="#每次读取一行字符串输入" class="headerlink" title="每次读取一行字符串输入"></a>每次读取一行字符串输入</h3><h4 id="面向行的输入：getline"><a href="#面向行的输入：getline" class="headerlink" title="面向行的输入：getline( )"></a>面向行的输入：<strong>getline( )</strong></h4><p>getline( )函数读取整行，它使用通过回车键输入的换行符来确定输 入结尾。要调用这种方法，可以使用cin.getline( )。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字 符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。</p><p>例如，假设要使用getline( )将姓名读入到一个包含20个元素的name 数组中。可以使用这样的函数调用： </p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cin</span>.getline(name,<span class="hljs-number">20</span>);//实际只能存<span class="hljs-number">19</span>个元素</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">20</span>;    <span class="hljs-type">char</span> name[ArSize];    <span class="hljs-type">char</span> dessert[ArSize];    cout &lt;&lt; <span class="hljs-string">&quot;Enter your name:\n&quot;</span>;    cin.<span class="hljs-built_in">getline</span>(name, ArSize);  <span class="hljs-comment">// reads through newline</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter your favorite dessert:\n&quot;</span>;    cin.<span class="hljs-built_in">getline</span>(dessert, ArSize);    cout &lt;&lt; <span class="hljs-string">&quot;I have some delicious &quot;</span> &lt;&lt; dessert;    cout &lt;&lt; <span class="hljs-string">&quot; for you, &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter your name:</span><span class="hljs-comment">//marry willion</span><span class="hljs-comment">//Enter your favorite dessert:</span><span class="hljs-comment">//katy bell</span><span class="hljs-comment">//I have some delicious katy bell for you, marry willion.</span></code></pre></div><p>getline( )函 数每次读取一行。它通过换行符来确定行尾，但不保存换行符。相反,在存储字符串时，它用空字符来替换换行符</p><h4 id="面向行的输入：get"><a href="#面向行的输入：get" class="headerlink" title="面向行的输入：get( )"></a>面向行的输入：get( )</h4><p>istream类有另一个名为get( )的成员函数,该函数有几种变体。其中一种变体的工作方式与getline( )类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但get并不再读取并丢弃换行符，而是将其留在输入队列中。假设我们连续两次调用get( )：</p><div class="code-wrapper"><pre><code class="hljs routeros">cin.<span class="hljs-built_in">get</span>(name,ArSize);cin.<span class="hljs-built_in">get</span>(dessert,ArSize);</code></pre></div><p>由于第一次调用后，换行符将留在输入队列中，因此第二次调用时 看到的第一个字符便是换行符。因此get( )认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get( )将不能跨过该换行符。 </p><p>get( )有另一种变体。使用不带任何参数的cin.get( )调用 可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为 读取下一行输入做好准备。也就是说，可以采用下面的调用序列：</p><div class="code-wrapper"><pre><code class="hljs routeros">cin.<span class="hljs-built_in">get</span>(name,ArSize);cin.<span class="hljs-built_in">get</span>();cin.<span class="hljs-built_in">get</span>(dessert,ArSize);</code></pre></div><p>另一种使用get( )的方式是将两个类成员函数拼接起来（合并），如下所示：</p><div class="code-wrapper"><pre><code class="hljs pgsql">cin.<span class="hljs-keyword">get</span>(<span class="hljs-type">name</span>,ArSize).<span class="hljs-keyword">get</span>();//<span class="hljs-keyword">get</span> <span class="hljs-keyword">return</span> cin 可以进行链式调用</code></pre></div><p>之所以可以这样做，是由于cin.get（name，ArSize）返回一个cin对象，该对象随后将被用来调用get( )函数。同样，下面的语句将把输入中连续的两行分别读入到数组name1和name2 中，其效果与两次调用 cin.getline( )相同：</p><div class="code-wrapper"><pre><code class="hljs scss">cin<span class="hljs-selector-class">.getline</span>(name1,name2)<span class="hljs-selector-class">.getline</span>(name1,name2);</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// instr3.cpp -- reading more than one word with get() &amp; get()</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">20</span>;    <span class="hljs-type">char</span> name[ArSize];    <span class="hljs-type">char</span> dessert[ArSize];    cout &lt;&lt; <span class="hljs-string">&quot;Enter your name:\n&quot;</span>;    cin.<span class="hljs-built_in">get</span>(name, ArSize).<span class="hljs-built_in">get</span>();    <span class="hljs-comment">// read string, newline</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter your favorite dessert:\n&quot;</span>;    cin.<span class="hljs-built_in">get</span>(dessert, ArSize).<span class="hljs-built_in">get</span>();    cout &lt;&lt; <span class="hljs-string">&quot;I have some delicious &quot;</span> &lt;&lt; dessert;    cout &lt;&lt; <span class="hljs-string">&quot; for you, &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><p>需要指出的一点是，C++允许函数有多个版本，条件是这些版本的 参数列表不同。如果使用的是cin.get（name，ArSize），则编译器知道 是要将一个字符串放入数组中，因而将使用适当的成员函数。如果使用 的是cin.get( )—函数重载</p><p>为什么要使用get( )，而不是getline( )呢？首先，老式实现没有 getline( )。其次，get( )使输入更仔细。例如，假设用get( )将一行读入数 组中。如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入</p><p>总之， getline( )使用起来简单一些，但get( )使得检查错误更简单些。可以用其中的任何一个来读取一行输入；只是应该知道，它们的行为稍有不同。</p><h4 id="空行和其他问题"><a href="#空行和其他问题" class="headerlink" title="空行和其他问题"></a>空行和其他问题</h4><p>当getline( )或get( )读取空行时，将发生什么情况？最初的做法是， 下一条输入语句将在前一条getline( )或get( )结束读取的位置开始读取； 但当前的做法是，当get( )（不是getline( )）读取空行后将设置失效位 （failbit）。这意味着接下来的输入将被阻断，但可以用下面的命令来 恢复输入：</p><div class="code-wrapper"><pre><code class="hljs coq">cin.<span class="hljs-built_in">clear</span>()</code></pre></div><p>另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入 行包含的字符数比指定的多，则getline( )和get( )将把余下的字符留在输 入队列中，而getline( )还会设置失效位，并关闭后面的输入</p><h3 id="混合输入字符串和数字"><a href="#混合输入字符串和数字" class="headerlink" title="混合输入字符串和数字"></a>混合输入字符串和数字</h3><p>混合输入数字和面向行的字符串会导致问题</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;What year was your house built?\n&quot;</span>;    <span class="hljs-type">int</span> year;    cin &gt;&gt; year;    <span class="hljs-comment">// cin.get();</span>    cout &lt;&lt; <span class="hljs-string">&quot;What is its street address?\n&quot;</span>;    <span class="hljs-type">char</span> address[<span class="hljs-number">80</span>];    cin.<span class="hljs-built_in">getline</span>(address, <span class="hljs-number">80</span>);    cout &lt;&lt; <span class="hljs-string">&quot;Year built: &quot;</span> &lt;&lt; year &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Address: &quot;</span> &lt;&lt; address &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Done!\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//What year was your house built?</span><span class="hljs-comment">//1966</span><span class="hljs-comment">//What is its street address?</span><span class="hljs-comment">//Year built: 1966</span><span class="hljs-comment">//Address:</span><span class="hljs-comment">//Done!</span></code></pre></div><p>用户根本没有输入地址的机会。问题在于，当cin读取年份，将回 车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符 后，将认为是一个空行，并将一个空字符串赋给address数组。解决办法是在读取地址之前先读取并丢弃换行符.使用get()或者get(ch)</p><div class="code-wrapper"><pre><code class="hljs perl">cin&gt;&gt;year;cin.get()//cin.get(ch)//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">/</span><span class="hljs-regexp">(cin&gt;&gt;year).get()/</span>/get(ch)</code></pre></div><p>C++程序常使用指针（而不是数组）来处理字符串</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;What year was your house built?\n&quot;</span>;    <span class="hljs-type">int</span> year;    cin &gt;&gt; year;    cin.<span class="hljs-built_in">get</span>();    cout &lt;&lt; <span class="hljs-string">&quot;What is its street address?\n&quot;</span>;    <span class="hljs-type">char</span> address[<span class="hljs-number">80</span>];    cin.<span class="hljs-built_in">getline</span>(address, <span class="hljs-number">80</span>);    cout &lt;&lt; <span class="hljs-string">&quot;Year built: &quot;</span> &lt;&lt; year &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Address: &quot;</span> &lt;&lt; address &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Done!\n&quot;</span>;    cin.<span class="hljs-built_in">get</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//What year was your house built?</span><span class="hljs-comment">//1966</span><span class="hljs-comment">//What is its street address?</span><span class="hljs-comment">//built 122</span><span class="hljs-comment">//Year built: 1966</span><span class="hljs-comment">//Address: built 122</span><span class="hljs-comment">//Done!</span></code></pre></div><h2 id="string类简介"><a href="#string类简介" class="headerlink" title="string类简介"></a>string类简介</h2><p>ISO/ANSI C++98标准通过添加string类扩展了C++库，因此现在可 以string类型的变量（使用C++的话说是对象）而不是字符数组来存储字符串。您将看到，string类使用起来比数组简单，同时提供了将字符串作为一种数据类型的表示方法。 </p><p>要使用string类，必须在程序中包含头文件string。string类位于名称 空间std中，因此您必须提供一条using编译指令，或者使用std::string来引用它。string类定义隐藏了字符串的数组性质，让您能够像处理普通变量那样处理字符串</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strtype1.cpp -- using the C++ string class</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>               <span class="hljs-comment">// make string class available</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>];            <span class="hljs-comment">// create an empty array</span>    <span class="hljs-type">char</span> charr2[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;jaguar&quot;</span>; <span class="hljs-comment">// create an initialized array</span>    string str1;                <span class="hljs-comment">// create an empty string object</span>    string str2 = <span class="hljs-string">&quot;panther&quot;</span>;    <span class="hljs-comment">// create an initialized string</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter a kind of feline: &quot;</span>;    cin &gt;&gt; charr1;    cout &lt;&lt; <span class="hljs-string">&quot;Enter another kind of feline: &quot;</span>;    cin &gt;&gt; str1;                <span class="hljs-comment">// use cin for input</span>    cout &lt;&lt; <span class="hljs-string">&quot;Here are some felines:\n&quot;</span>;    cout &lt;&lt; charr1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; charr2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>         &lt;&lt; str1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; str2 <span class="hljs-comment">// use cout for output</span>         &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;The third letter in &quot;</span> &lt;&lt; charr2 &lt;&lt; <span class="hljs-string">&quot; is &quot;</span>         &lt;&lt; charr2[<span class="hljs-number">2</span>] &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;The third letter in &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="hljs-string">&quot; is &quot;</span>         &lt;&lt; str2[<span class="hljs-number">2</span>] &lt;&lt; endl;    <span class="hljs-comment">// use array notation</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter a kind of feline: ocelot</span><span class="hljs-comment">//Enter another kind of feline: tiger</span><span class="hljs-comment">//Here are some felines:</span><span class="hljs-comment">//ocelot jaguar tiger panther</span><span class="hljs-comment">//The third letter in jaguar is g</span><span class="hljs-comment">//The third letter in panther is n</span></code></pre></div><p>从这个示例可知，在很多方面，使用string对象的方式与使用字符数组相同。</p><p>可以使用C-风格字符串来初始化string对象。 </p><p>可以使用cin来将键盘输入存储到string对象中。 </p><p>可以使用cout来显示string对象。 </p><p>可以使用数组表示法来访问存储在string对象中的字符。</p><div class="code-wrapper"><pre><code class="hljs abnf">string str1<span class="hljs-comment">;</span>string str2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;panther&quot;</span><span class="hljs-comment">;</span></code></pre></div><p>类设计让程序能够自动处理string的大小。例如，str1的声明创建一个长度为0的string对象，但程序将输入读取到str1中时，将自动调整str1的长度：</p><div class="code-wrapper"><pre><code class="hljs abnf">cin &gt;&gt; str1<span class="hljs-comment">;</span></code></pre></div><h3 id="C-11字符串初始化"><a href="#C-11字符串初始化" class="headerlink" title="C++11字符串初始化"></a>C++11字符串初始化</h3><p>C++11也允许将列表初始化用于C-风格字符串和string对象：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> first_date[] = &#123;<span class="hljs-string">&quot;Le Chapon Dodu&quot;</span>&#125;;<span class="hljs-type">char</span> second_date[] = &#123;<span class="hljs-string">&quot;The Elegant Plate&quot;</span>&#125;;string third_date = &#123;<span class="hljs-string">&quot;The Bread Bowl&quot;</span>&#125;;string fourth_date = &#123;<span class="hljs-string">&quot;hank&#x27;s Fine Eats&quot;</span>&#125;;</code></pre></div><h3 id="赋值、拼接和附加"><a href="#赋值、拼接和附加" class="headerlink" title="赋值、拼接和附加"></a>赋值、拼接和附加</h3><p>使用string类时，某些操作比使用数组时更简单。例如，不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对 象：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>];<span class="hljs-type">char</span> charr2[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;jaguar&quot;</span>;string str1;string str2= <span class="hljs-string">&quot;panther&quot;</span>;charr1 =charr2; <span class="hljs-comment">//不允许</span>str1 = str2;</code></pre></div><p>string类简化了字符串合并操作。可以使用运算符+将两个string对象合并起来，还可以使用运算符+=将字符串附加到string对象的末尾。继续前面的代码，您可以这样做： </p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">string</span> str3;<span class="hljs-attribute">str3</span> =str1+str2;<span class="hljs-attribute">str1</span> += str2;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strtype2.cpp �- assigning, adding, and appending</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>               <span class="hljs-comment">// make string class available</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    string s1 = <span class="hljs-string">&quot;penguin&quot;</span>;    string s2, s3;    cout &lt;&lt; <span class="hljs-string">&quot;You can assign one string object to another: s2 = s1\n&quot;</span>;    s2 = s1;    cout &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot;, s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;You can assign a C-style string to a string object.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;s2 = \&quot;buzzard\&quot;\n&quot;</span>;    s2 = <span class="hljs-string">&quot;buzzard&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;You can concatenate strings: s3 = s1 + s2\n&quot;</span>;    s3 = s1 + s2;    cout &lt;&lt; <span class="hljs-string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;You can append strings.\n&quot;</span>;    s1 += s2;    cout &lt;&lt;<span class="hljs-string">&quot;s1 += s2 yields s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;    s2 += <span class="hljs-string">&quot; for a day&quot;</span>;    cout &lt;&lt;<span class="hljs-string">&quot;s2 += \&quot; for a day\&quot; yields s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;    <span class="hljs-comment">//cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//You can assign one string object to another: s2 = s1</span><span class="hljs-comment">//s1: penguin, s2: penguin</span><span class="hljs-comment">//You can assign a C-style string to a string object.</span><span class="hljs-comment">//s2 = &quot;buzzard&quot;</span><span class="hljs-comment">//s2: buzzard</span><span class="hljs-comment">//You can concatenate strings: s3 = s1 + s2</span><span class="hljs-comment">//s3: penguinbuzzard</span><span class="hljs-comment">//You can append strings.</span><span class="hljs-comment">//s1 += s2 yields s1 = penguinbuzzard</span><span class="hljs-comment">//s2 += &quot; for a day&quot; yields s2 = buzzard for a day</span></code></pre></div><h3 id="string类的其他操作"><a href="#string类的其他操作" class="headerlink" title="string类的其他操作"></a>string类的其他操作</h3><p>在C++新增string类之前，程序员也需要完成诸如给字符串赋值等工作。对于C-风格字符串，程序员使用C语言库中的函数来完成这些任 务。头文件cstring（以前为string.h）提供了这些函数。例如，可以使用函数strcpy( )将字符串复制到字符数组中，使用函数strcat( )将字符串附加到字符数组末尾：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">strcpy</span>(charr1,charr2);<span class="hljs-comment">//将charr2复制到charr1</span><span class="hljs-built_in">strcat</span>(charr1,charr2);<span class="hljs-comment">//将charr2，拼接到charr1</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strtype3.cpp -- more string class features</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>               <span class="hljs-comment">// make string class available</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>              <span class="hljs-comment">// C-style string library</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> charr1[<span class="hljs-number">20</span>];    <span class="hljs-type">char</span> charr2[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;jaguar&quot;</span>;    string str1;    string str2 = <span class="hljs-string">&quot;panther&quot;</span>;    <span class="hljs-comment">// assignment for string objects and character arrays</span>    str1 = str2;                <span class="hljs-comment">// copy str2 to str1</span>    <span class="hljs-built_in">strcpy</span>(charr1, charr2);     <span class="hljs-comment">// copy charr2 to charr1</span>    <span class="hljs-comment">// appending for string objects and character arrays</span>    str1 += <span class="hljs-string">&quot; paste&quot;</span>;           <span class="hljs-comment">// add paste to end of str1</span>    <span class="hljs-built_in">strcat</span>(charr1, <span class="hljs-string">&quot; juice&quot;</span>);   <span class="hljs-comment">// add juice to end of charr1</span>    <span class="hljs-comment">// finding the length of a string object and a C-style string</span>    <span class="hljs-type">int</span> len1 = str1.<span class="hljs-built_in">size</span>();     <span class="hljs-comment">// obtain length of str1</span>    <span class="hljs-type">int</span> len2 = <span class="hljs-built_in">strlen</span>(charr1);  <span class="hljs-comment">// obtain length of charr1</span>    cout &lt;&lt; <span class="hljs-string">&quot;The string &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="hljs-string">&quot; contains &quot;</span>         &lt;&lt; len1 &lt;&lt; <span class="hljs-string">&quot; characters.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;The string &quot;</span> &lt;&lt; charr1 &lt;&lt; <span class="hljs-string">&quot; contains &quot;</span>         &lt;&lt; len2 &lt;&lt; <span class="hljs-string">&quot; characters.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//The string panther paste contains 13 characters.</span><span class="hljs-comment">//The string jaguar juice contains 12 characters.</span></code></pre></div><p>使用字符数组时，总是存在目标数组过小，无法存储指定信息的危险</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> site[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;house&quot;</span>;<span class="hljs-built_in">strcat</span>(site,<span class="hljs-string">&quot; of pancakes&quot;</span>);;<span class="hljs-comment">//memory problem</span></code></pre></div><p>函数strcat( )试图将全部12个字符复制到数组site中，这将覆盖相邻的内存。这可能导致程序终止，或者程序继续运行，但数据被损坏。 string类具有自动调整大小的功能，从而能够避免这种问题发生。C函数 库确实提供了与strcat( )和strcpy( )类似的函数—strncat( )和strncpy( )，它 们接受指出目标数组最大允许长度的第三个参数，因此更为安全，但使 用它们进一步增加了编写程序的复杂度</p><p>下面是两种确定字符串中字符数的方法：</p><div class="code-wrapper"><pre><code class="hljs abnf">int len1<span class="hljs-operator">=</span>str1.size()<span class="hljs-comment">;</span>int len2<span class="hljs-operator">=</span>strlen(charr1)<span class="hljs-comment">;</span></code></pre></div><p>函数strlen( )是一个常规函数，它接受一个C-风格字符串作为参数， 并返回该字符串包含的字符数。函数size( )的功能基本上与此相同，但句法不同：str1不是被用作函数参数，而是位于函数名之前，它们之间用句点连接</p><p>这种句法表明，str1是一个对象，而size( )是一个类方法。方法是一个函数，只能通过其所属类的对象进行调用。在这里，str1是一个string对象，而size( )是string类的一个方法。总之，C函数使用参数来指出要使用哪个字符串，而C++ string类对象使用对象名和句点运算符来指出要使用哪个字符串。</p><h3 id="4-3-4-string类I-O"><a href="#4-3-4-string类I-O" class="headerlink" title="4.3.4 string类I/O"></a>4.3.4 string类I/O</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strtype4.cpp -- line input</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>               <span class="hljs-comment">// make string class available</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>              <span class="hljs-comment">// C-style string library</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> charr[<span class="hljs-number">20</span>];     string str;    cout &lt;&lt; <span class="hljs-string">&quot;Length of string in charr before input: &quot;</span>          &lt;&lt; <span class="hljs-built_in">strlen</span>(charr) &lt;&lt; endl;<span class="hljs-comment">//这里的长度是随机的，因为是未初始化，所以length是随机值</span>    cout &lt;&lt; <span class="hljs-string">&quot;Length of string in str before input: &quot;</span>         &lt;&lt; str.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a line of text:\n&quot;</span>;    cin.<span class="hljs-built_in">getline</span>(charr, <span class="hljs-number">20</span>);     <span class="hljs-comment">// indicate maximum length</span>    cout &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; charr &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Enter another line of text:\n&quot;</span>;    <span class="hljs-built_in">getline</span>(cin, str);          <span class="hljs-comment">// cin now an argument; no length specifier</span>    cout &lt;&lt; <span class="hljs-string">&quot;You entered: &quot;</span> &lt;&lt; str &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Length of string in charr after input: &quot;</span>          &lt;&lt; <span class="hljs-built_in">strlen</span>(charr) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Length of string in str after input: &quot;</span>         &lt;&lt; str.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<span class="hljs-comment">//Length of string in charr before input: 1</span><span class="hljs-comment">//Length of string in str before input: 0</span><span class="hljs-comment">//Enter a line of text:</span><span class="hljs-comment">//peanut butter</span><span class="hljs-comment">//You entered: peanut butter</span><span class="hljs-comment">//Enter another line of text:</span><span class="hljs-comment">//blueberry jam</span><span class="hljs-comment">//You entered: blueberry jam</span><span class="hljs-comment">//Length of string in charr after input: 13</span><span class="hljs-comment">//Length of string in str after input: 13</span></code></pre></div><p>该数组的长度要大。这里要两点需要说明。首先，为初始化的数组的内容是未定义的；其次，函数strlen( )从数组的第一个元素开始计算字节 数，直到遇到空字符。在这个例子中，在数组末尾的几个字节后才遇到空字符。对于未被初始化的数据，第一个空字符的出现位置是随机的，因此您在运行该程序时，得到的数组长度很可能与此不同。另外，用户输入之前，str中的字符串长度为0。这是因为未被初始 化的string对象的长度被自动设置为0。</p><p>下面是将一行输入读取到数组中的代码：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cin</span>.getline(charr,<span class="hljs-number">20</span>);</code></pre></div><p>这种句点表示法表明，函数getline( )是istream类的一个类方法（还记得吗，cin是一个istream对象）。正如前面指出的，第一个参数是目标数组；第二个参数数组长度，getline( )使用它来避免超越数组的边界。</p><p>下面是将一行输入读取到string对象中的代码：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">getline</span>(cin,str);</code></pre></div><p>这里没有使用句点表示法，这表明这个getline( )不是类方法。它将cin作为参数，指出到哪里去查找输入。另外，也没有指出字符串长度 的参数，因为string对象将根据字符串的长度自动调整自己的大小。</p><p>那么，为何一个getline( )是istream的类方法，而另一个不是呢？在引入string类之前很久，C++就有istream类。因此istream的设计考虑到了诸如double和int等基本C++数据类型，但没有考虑string类型，所以 istream类中，有处理double、int和其他基本类型的类方法，但没有处理string对象的类方法。</p><p>除char类型外，C++还有类型wchar_t；而C++11新增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符串字面值。对于这些类型的字符串字面值，C++分别使用前缀L、u和U表示，下面是一个如何使用这些前缀的例子： </p><div class="code-wrapper"><pre><code class="hljs python">wchar_t title[] = L<span class="hljs-string">&quot;Chief Asreogator&quot;</span>;char16_t name[] = <span class="hljs-string">u&quot;Felonia Ripova&quot;</span>;char32_t car[] = <span class="hljs-string">U&quot;humber super sniper&quot;</span>;</code></pre></div><p>C++11还支持Unicode字符编码方案UTF-8。在这种方案中，根据编码的数字值，字符可能存储为1～4个八位组。C++使用前缀u8来表示这种类型的字符串字面值。</p><p>C++11新增的另一种类型是原始（raw）字符串。在原始字符串中，字符表示的就是自己，例如，序列\n不表示换行符，而表示两个常 规字符—斜杠和n，因此在屏幕上显示时，将显示这两个字符。另一个 例子是，可在字符串中使用”，而无需使用繁琐的 “。当然，既然可在字符串字面量包含”，就不能再使用它来表示字符串 的开头和末尾。因此，原始字符串将”(和)”用作定界符，并使用前缀R来 标识原始字符串：</p><div class="code-wrapper"><pre><code class="hljs cpp">cout &lt;&lt; R <span class="hljs-string">&quot;(jim &quot;</span>king<span class="hljs-string">&quot; Tutt uses &quot;</span>\n<span class="hljs-string">&quot; instead of endl.)&quot;</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span></code></pre></div><h2 id="结构简介"><a href="#结构简介" class="headerlink" title="结构简介"></a>结构简介</h2><p>结构是 一种比数组更灵活的数据格式，因为同一个结构可以存储多种类型的数据，这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起</p><p>结构是用户定义的类型，而结构声明定义了这种类型的数据属性。 定义了类型后，便可以创建这种类型的变量。因此创建结构包括两步。 首先，定义结构描述—它描述并标记了能够存储在结构中的各种数据类型。然后按描述创建结构变量（结构数据对象）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inflatable</span> &#123;<span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<span class="hljs-type">float</span> volume;<span class="hljs-type">double</span> price;&#125;</code></pre></div><p>关键字struct表明，这些代码定义的是一个结构的布局。标识符 inflatable是这种数据格式的名称，因此新类型的名称为inflatable。这 样，便可以像创建char或int类型的变量那样创建inflatable类型的变量 了。接下来的大括号中包含的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。这个例子使用了一个适合用于存储字符串的 char数组、一个float和一个double。列表中的每一项都被称为结构成员，因此infatable结构有3个成员（参见图4.6）。总之，结构定义指出了新类型（这里是inflatable）的特征。 </p><p>定义结构后，便可以创建这种类型的变量了：</p><div class="code-wrapper"><pre><code class="hljs abnf">inflatable hat<span class="hljs-comment">;</span>inflatable woopie_cushion<span class="hljs-comment">;</span>inflatable mainframe<span class="hljs-comment">;</span></code></pre></div><p>如果您熟悉C语言中的结构，则可能已经注意到了，C++允许在声明结构变量时省略关键字struct：</p><div class="code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">inflatable</span> goose;  <span class="hljs-comment">//keyword struct required in C</span>inflatable vincent; <span class="hljs-comment">//keyword struct not require c++;</span></code></pre></div><p>由于hat的类型为inflatable，因此可以使用成员运算符（.）来访问各个成员。例如，hat.volume指的是结构的volume成员，hat.price指的是 price成员。同样，vincent.price是vincent变量的price成员。总之，通过成员名能够访问结构的成员，就像通过索引能够访问数组的元素一样。由于price成员被声明为double类型，因此hat.price和vincent.price相当于是double类型的变量，可以像使用常规double变量那样来使用它们。总之，hat是一个结构，而hat.price是一个double变量。顺便说一句，访问类成员函数（如cin.getline( )）的方式是从访问结构成员变量（如vincent.price）的方式衍生而来的。</p><h3 id="在程序中使用结构"><a href="#在程序中使用结构" class="headerlink" title="在程序中使用结构"></a>在程序中使用结构</h3><div class="code-wrapper"><pre><code class="hljs CPP"><span class="hljs-comment">// structur.cpp -- a simple structure</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inflatable</span>   <span class="hljs-comment">// structure declaration</span>&#123;    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-type">float</span> volume;    <span class="hljs-type">double</span> price;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    inflatable guest =            &#123;                    <span class="hljs-string">&quot;Glorious Gloria&quot;</span>,  <span class="hljs-comment">// name value</span>                    <span class="hljs-number">1.88</span>,               <span class="hljs-comment">// volume value</span>                    <span class="hljs-number">29.99</span>               <span class="hljs-comment">// price value</span>            &#125;;  <span class="hljs-comment">// guest is a structure variable of type inflatable</span><span class="hljs-comment">// It&#x27;s initialized to the indicated values</span>    inflatable pal =            &#123;                    <span class="hljs-string">&quot;Audacious Arthur&quot;</span>,                    <span class="hljs-number">3.12</span>,                    <span class="hljs-number">32.99</span>            &#125;;  <span class="hljs-comment">// pal is a second variable of type inflatable</span><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> some implementations require using</span><span class="hljs-comment">// static inflatable guest =</span>    cout &lt;&lt; <span class="hljs-string">&quot;Expand your guest list with &quot;</span> &lt;&lt; guest.name;    cout &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; pal.name &lt;&lt; <span class="hljs-string">&quot;!\n&quot;</span>;<span class="hljs-comment">// pal.name is the name member of the pal variable</span>    cout &lt;&lt; <span class="hljs-string">&quot;You can have both for $&quot;</span>;    cout &lt;&lt; guest.price + pal.price &lt;&lt; <span class="hljs-string">&quot;!\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Expand your guest list with Glorious Gloria and Audacious Arthur!</span><span class="hljs-comment">//You can have both for $62.98!</span></code></pre></div><p>结构有两种申明方式：可以 将声明放在main( )函数中，紧跟在开始括号的后面。另一种选择是将声 明放到main( )的前面，这里采用的便是这种方式，位于函数外面的声明 被称为外部声明。对于这个程序来说，两种选择之间没有实际区别。但 是对于那些包含两个或更多函数的程序来说，差别很大。外部声明可以 被其后面的任何函数使用，而内部声明只能被该声明所属的函数使用。 通常应使用外部声明，这样所有函数都可以使用这种类型的结构。c++提倡使用外部结构声明</p><h3 id="C-11结构初始化"><a href="#C-11结构初始化" class="headerlink" title="C++11结构初始化"></a>C++11结构初始化</h3><p>与数组一样，C++11也支持将列表初始化用于结构，且等号（=） 是可选的：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">inflatable</span> duck &#123;<span class="hljs-string">&quot;Daphne&quot;</span>,<span class="hljs-number">0</span>.<span class="hljs-number">12</span>,<span class="hljs-number">9</span>.<span class="hljs-number">98</span>&#125;</code></pre></div><p>其次，如果大括号内未包含任何东西，各个成员都将被设置为零。最后，不允许缩窄转换。</p><h3 id="结构可以将string类作为成员吗"><a href="#结构可以将string类作为成员吗" class="headerlink" title="结构可以将string类作为成员吗"></a>结构可以将<strong>string</strong>类作为成员吗</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inflatable</span> &#123;std::string name;<span class="hljs-type">float</span> volume;<span class="hljs-type">double</span> price;&#125;</code></pre></div><p>一定要让结构定义能够访问名称空间std。为此，可以将编译指令 using移到结构定义之前；也可以像前面那样，将name的类型声明为 std::string。</p><h3 id="其他结构属性"><a href="#其他结构属性" class="headerlink" title="其他结构属性"></a>其他结构属性</h3><p>可以同时完成定义结构和创建结构变量的工作。为此，只需将变量名放在结束括号的后面即可： </p><div class="code-wrapper"><pre><code class="hljs cpp">Struct perks &#123;<span class="hljs-type">int</span> key_number;<span class="hljs-type">char</span> car[<span class="hljs-number">12</span>]&#125; mr_smith,ms_jones;</code></pre></div><p>甚至可以初始化以这种方式创建的变量</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">perks</span> &#123;<span class="hljs-type">int</span> key_number;<span class="hljs-type">char</span> car[<span class="hljs-number">2</span>];&#125; mr_glitz = &#123;<span class="hljs-number">7</span>,<span class="hljs-string">&quot;Packard&quot;</span>&#125;</code></pre></div><p>然而，将结构定义和变量声明分开，可以使程序更易于阅读和理解</p><p>还可以声明没有名称的结构类型，方法是省略名称，同时定义一种结构类型和一个这种类型的变量：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> &#123;<span class="hljs-type">int</span> x;<span class="hljs-type">int</span> y;&#125; position</code></pre></div><p>这样将创建一个名为position的结构变量。可以使用成员运算符来访问它的成员（如position.x），但这种类型没有名称，因此以后无法创建这种类型的变量</p><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// arrstruc.cpp -- an array of structures</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">inflatable</span>&#123;    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-type">float</span> volume;    <span class="hljs-type">double</span> price;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    inflatable guests[<span class="hljs-number">2</span>] =          <span class="hljs-comment">// initializing an array of structs</span>    &#123;        &#123;<span class="hljs-string">&quot;Bambi&quot;</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">21.99</span>&#125;,      <span class="hljs-comment">// first structure in array</span>        &#123;<span class="hljs-string">&quot;Godzilla&quot;</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">565.99</span>&#125;  <span class="hljs-comment">// next structure in array</span>    &#125;;    cout &lt;&lt; <span class="hljs-string">&quot;The guests &quot;</span> &lt;&lt; guests[<span class="hljs-number">0</span>].name &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; guests[<span class="hljs-number">1</span>].name         &lt;&lt; <span class="hljs-string">&quot;\nhave a combined volume of &quot;</span>         &lt;&lt; guests[<span class="hljs-number">0</span>].volume + guests[<span class="hljs-number">1</span>].volume &lt;&lt; <span class="hljs-string">&quot; cubic feet.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><h3 id="结构中的位字段"><a href="#结构中的位字段" class="headerlink" title="结构中的位字段"></a>结构中的位字段</h3><p>与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。字段的类型 应为整型或枚举，接下来是冒号，冒号后面是一个数字，它指定了使用的位数。可以使用没有名称的字段来提供间距。每个 成员都被称为位字段（bit field）。下面是一个例子：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">torgle_register</span> &#123;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> SN : <span class="hljs-number">4</span> <span class="hljs-comment">//4 bits for SN value</span><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> : <span class="hljs-number">4</span> <span class="hljs-comment">// 4 bits unused</span><span class="hljs-type">bool</span> goodIn : <span class="hljs-number">1</span>; <span class="hljs-comment">//valid input (1bit)</span><span class="hljs-type">bool</span> goodTorgle : <span class="hljs-number">1</span>; <span class="hljs-comment">// successful torgling</span>&#125;</code></pre></div><p>可以像通常那样初始化这些字段，还可以使用标准的结构表示法来访问位字段：</p><div class="code-wrapper"><pre><code class="hljs cpp">torgle_register tr &#123;<span class="hljs-number">14</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>&#125;;<span class="hljs-keyword">if</span>(tr.goodIn)&#123;  ....&#125;</code></pre></div><p>位字段通常用在低级编程中。</p><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，结构可以同时存储int、 long和double，共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。例如，请看下面的声明：</p><div class="code-wrapper"><pre><code class="hljs angelscript">union one4all &#123;<span class="hljs-built_in">int</span> <span class="hljs-built_in">int</span>_val;long long_val;<span class="hljs-built_in">double</span> <span class="hljs-built_in">double</span>_val;&#125;</code></pre></div><p>可以使用one4all变量来存储int、long或double，条件是在不同的时间进行：</p><div class="code-wrapper"><pre><code class="hljs abnf">one4all pail<span class="hljs-comment">;</span>pail.int_val <span class="hljs-operator">=</span> <span class="hljs-number">15</span><span class="hljs-comment">;</span>cout&lt;&lt; pail.int_val<span class="hljs-comment">;</span>pail.double_val <span class="hljs-operator">=</span><span class="hljs-number">1.38</span><span class="hljs-comment">;</span>cout &lt;&lt; pail.double_val<span class="hljs-comment">;</span></code></pre></div><p>因此，pail有时可以是int变量，而有时又可以是double变量。成员 名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。例如，假设管理一个小商品目录，其中有一些商品的ID为整数，而另一些的ID为字符串。在这种情况下，可以这样做：</p><div class="code-wrapper"><pre><code class="hljs abnf">struct widget&#123;char brand[<span class="hljs-number">20</span>]<span class="hljs-comment">;</span>int type<span class="hljs-comment">;</span>union id&#123;long id_num<span class="hljs-comment">;</span>char id_char[<span class="hljs-number">20</span>]<span class="hljs-comment">;</span>&#125; id_val<span class="hljs-comment">;</span>&#125;<span class="hljs-comment">;</span></code></pre></div><p>匿名共用体（anonymous union）没有名称，其成员将成为位于相同地址处的变量。显然，每次只有一个成员是当前的成员：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">widget</span> &#123;<span class="hljs-type">char</span> brand[<span class="hljs-number">20</span>];<span class="hljs-type">int</span> type;<span class="hljs-keyword">union</span>&#123;<span class="hljs-type">long</span> id_num;<span class="hljs-type">char</span> id_char[<span class="hljs-number">20</span>];&#125;&#125;<span class="hljs-keyword">if</span>(price.type==<span class="hljs-number">1</span>)cin &gt;&gt; price.id_num;<span class="hljs-keyword">else</span>cin &gt;&gt; price.id_char;</code></pre></div><p>由于共用体是匿名的，因此id_num和id_char被视为prize的两个成员，它们的地址相同，所以不需要中间标识符id_val。程序员负责确定 当前哪个成员是活动的。</p><p>共用体常用于（但并非只能用于）节省内存。当前，系统的内存多达数GB甚至数TB，好像没有必要节省内存，但并非所有的C++程序都 是为这样的系统编写的。C++还用于嵌入式系统编程，如控制烤箱、 MP3播放器或火星漫步者的处理器。对这些应用程序来说，内存可能非常宝贵。另外，共用体常用于操作系统数据结构或硬件数据结构</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>C++的enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还允许定义新类型，但必须按严格的限制进行。使用 enum的句法与使用结构相似。例如，请看下面的语句： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">spectum</span> &#123;red,orange,yellow,green,blue,violet,indigo,ultraviolet&#125;;</code></pre></div><p>这条语句完成两项工作。 </p><p>让spectrum成为新类型的名称；spectrum被称为枚举（enumeration），就像struct变量被称为结构一样。将red、orange、yellow等作为符号常量，它们对应整数值0～7。这些常量叫作枚举量（enumerator）。</p><p>在默认情况下，将整数值赋给枚举量，第一个枚举量的值为0，第二个枚举量的值为1，依次类推。可以通过显式地指定整数值来覆盖默 认值</p><p>可以用枚举名来声明这种类型的变量</p><div class="code-wrapper"><pre><code class="hljs abnf">spectrum band<span class="hljs-comment">;</span></code></pre></div><p>在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">band</span><span class="hljs-operator">=</span>blue<span class="hljs-comment">;</span></code></pre></div><p>因此，spectrum变量受到限制，只有8个可能的值。如果试图将一个非法值赋给它，则有些编译器将出现编译器错误，而另一些则发出警 告。为获得最大限度的可移植性，应将把非enum值赋给enum变量视为错误</p><div class="code-wrapper"><pre><code class="hljs awk">band =orange; <span class="hljs-regexp">//</span>valid++band;   <span class="hljs-regexp">//</span>not valid ,band = orange + red; <span class="hljs-regexp">//</span>not valid</code></pre></div><p>然而，有些实现并没有这种限制，这有可能导致违反类型限制。例 如，如果band的值为ultraviolet（7），则++band（如果有效的话）将把band增加到8，而对于spectrum类型来说，8是无效的。另外，为获得最大限度的可移植性，应采纳较严格的限制</p><p>枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型：</p><div class="code-wrapper"><pre><code class="hljs processing"><span class="hljs-type">int</span> <span class="hljs-type">color</span> =<span class="hljs-built_in">blue</span> <span class="hljs-comment">//valid</span>band =<span class="hljs-number">3</span><span class="hljs-comment">//valid but  int not convert to spectrum</span><span class="hljs-type">color</span> = <span class="hljs-number">3</span>+<span class="hljs-built_in">red</span>;</code></pre></div><p>虽然在这个例子中，3对应的枚举量是green，但将3赋给band将导致类型错误。不过将green赋给band是可以的，因为它们都是spectrum类型。同样，有些实现方法没有这种限制。表达式3 + red中的加法并非为枚举量定义，但red被转换为int类型，因此结果的类型也是int。由于在这种情况下，枚举将被转换为int，因此可以在算术表达式中同时使用枚举和常规整数，尽管并没有为枚举本身定义算术运算.</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">band</span> =orange + red<span class="hljs-comment">;</span></code></pre></div><p>非法的原因有些复杂。确实没有为枚举定义运算符+，但用于算术表达式中时，枚举将被转换为整数，因此表达式orange + red将被转换为1 + 0。这是一个合法的表达式，但其类型为int，不能将其赋给类型为spectrum的变量band。 </p><p>如果int值是有效的，则可以通过强制类型转换，将它赋给枚举变量：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">band</span> <span class="hljs-operator">=</span> spectrum(<span class="hljs-number">3</span>)<span class="hljs-comment">;  //typecast 3 to type spectrum</span><span class="hljs-attribute">band</span> <span class="hljs-operator">=</span> spectrum(<span class="hljs-number">40003</span>)<span class="hljs-comment">;  //undefined 不要对不确定的值进行强制转换</span></code></pre></div><h3 id="设置枚举量的值"><a href="#设置枚举量的值" class="headerlink" title="设置枚举量的值"></a>设置枚举量的值</h3><p>可以使用赋值运算符来显式地设置枚举量的值</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">enum</span> bits&#123;one =<span class="hljs-number">1</span>,two=<span class="hljs-number">2</span>,four=<span class="hljs-number">4</span>,eight=<span class="hljs-number">8</span>&#125;;</code></pre></div><p>指定的值必须是整数。也可以只显式地定义其中一些枚举量的值</p><div class="code-wrapper"><pre><code class="hljs applescript">enum bigstep&#123;<span class="hljs-keyword">first</span>,<span class="hljs-keyword">second</span>=<span class="hljs-number">100</span>,<span class="hljs-keyword">third</span>&#125;;</code></pre></div><p>这里，first在默认值是0，后面没有被初始化的枚举量的值将比其前面的枚举量大1。因此，third的值为101。最后，可以创建多个值相同的枚举量： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span> &#123;zero,<span class="hljs-literal">null</span> = <span class="hljs-number">0</span>,one,numero_uno = <span class="hljs-number">1</span>&#125;;</code></pre></div><p>其中，zero和null都为0，one和umero_uno都为1。在C++早期的版本中，只能将int值（或提升为int的值）赋给枚举量，但这种限制取消了，因此可以使用long甚至long long类型的值</p><h3 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h3><p>最初，对于枚举来说，只有声明中指出的那些值是有效的。然而，C++现在通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚 举都有取值范围（range），通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">enum</span> bits&#123;one = <span class="hljs-number">1</span>,two = <span class="hljs-number">2</span>,four = <span class="hljs-number">4</span>,eight = <span class="hljs-number">8</span>&#125;;<span class="hljs-attribute">myflag</span>=bits(<span class="hljs-number">6</span>)  //在这个范围内都是有效的 <span class="hljs-number">6</span>不是枚举值，但它位于枚举定义的取值范围内</code></pre></div><p>取值范围的定义如下。首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取 值范围的上限。例如，前面定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0；否则，采用与寻找上限方式相同的方式，但加上负号。例如，如果最小的枚举量为−6，而比它小的、最大的2的幂是−8（加上负号），因此下限为−7。</p><p>选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚 举，使用一个字节或更少的空间；而对于包含long类型值的枚举，则使用4个字节。</p><p>C++11扩展了枚举，增加了作用域内枚举</p><h2 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h2><p>在第3章的开头，提到了计算机程序在存储数据时必须跟踪的3种基 本属性</p><p>信息存储在何处；</p><p>存储的值为多少；</p><p>存储的信息是什么类型；</p><p>您使用过一种策略来达到上述目的：定义一个简单变量。声明语句指出了值的类型和符号名，还让程序为值分配内存，并在内部跟踪该内 存单元。</p><p>下面来看一看另一种策略，它在开发C++类时非常重要。这种策略以指针为基础，指针是一个变量，其存储的是值的地址，而不是值本 身。在讨论指针之前，我们先看一看如何找到常规变量的地址。只需对变量应用地址运算符（&amp;），就可以获得它的位置；例如，如果home是一个变量，则&amp;home是它的地址。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// address.cpp -- using the &amp; operator to find addresses</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> donuts = <span class="hljs-number">6</span>;    <span class="hljs-type">double</span> cups = <span class="hljs-number">4.5</span>;    cout &lt;&lt; <span class="hljs-string">&quot;donuts value = &quot;</span> &lt;&lt; donuts;    cout &lt;&lt; <span class="hljs-string">&quot; and donuts address = &quot;</span> &lt;&lt; &amp;donuts &lt;&lt; endl;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> you may need to use unsigned (&amp;donuts)</span><span class="hljs-comment">// and unsigned (&amp;cups)</span>    cout &lt;&lt; <span class="hljs-string">&quot;cups value = &quot;</span> &lt;&lt; cups;    cout &lt;&lt; <span class="hljs-string">&quot; and cups address = &quot;</span> &lt;&lt; &amp;cups &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//donuts value = 6 and donuts address = 0x16fadf738</span><span class="hljs-comment">//cups value = 4.5 and cups address = 0x16fadf730</span></code></pre></div><p>显示地址时，该实现的cout使用十六进制表示法，因为这是常用于描述内存的表示法（有些实现可能使用十进制表示法）。在该实现中， donuts的存储位置比cups要低。两个地址的差为0x0065fd44 –0x0065fd40（即4）。这是有意义的，因为donuts的类型为int，而这种类 型使用4个字节。当然，不同系统给定的地址值可能不同。有些系统可能先存储cups，再存储donuts，这样两个地址值的差将为8个字节，因为 cups的类型为double。另外，在有些系统中，可能不会将这两个变量存储在相邻的内存单元中。 </p><p>使用常规变量时，值是指定的量，而地址为派生量</p><p>面向对象编程与传统的过程性编程的区别在于，OOP强调的是在运行阶段（而不是编译阶段）进行决策。运行阶段指的是程序正在运行时，编译阶段指的是编译器将程序组合起来时。运行阶段决策就好比度假时，选择参观哪些景点取决于天气和当时的心情；而编译阶段 决策更像不管在什么条件下，都坚持预先设定的日程安排。 </p><p>运行阶段决策提供了灵活性，可以根据当时的情况进行调整。例如，考虑为数组分配内 存的情况。传统的方法是声明一个数组。要在C++中声明数组，必须指定数组的长度。因此，数组长度在程序编译时就设定好了；这就是编译阶段决策。您可能认为，在80%的情况下，一 个包含20个元素的数组足够了，但程序有时需要处理200个元素。为了安全起见，使用了一个 包含200个元素的数组。这样，程序在大多数情况下都浪费了内存。OOP通过将这样的决策推 迟到运行阶段进行，使程序更灵活。在程序运行后，可以这次告诉它只需要20个元素，而还可以下次告诉它需要205个元素</p><p>总之，使用OOP时，您可能在运行阶段确定数组的长度。为使用这种方法，语言必须允许在程序运行时创建数组。稍后您看会到，C++采用的方法是，使用关键字new请求正确数量的内存以及使用指针来跟踪新分配的内存的位置。 </p><p>在运行阶段做决策并非OOP独有的，但使用C++编写这样的代码比使用C语言简单处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一种特殊类型的变量—指针用于存储值的地址。因此，指针名表示的是地址。<em>运算符被称为间接值（indirect velue）或解除引用 （dereferencing）运算符，将其应用于指针，可以得到该地址处存储的 值（这和乘法使用的符号相同；C++根据上下文来确定所指的是乘法还是解除引用）。例如，假设manly是一个指针，则manly表示的是一个地址，而</em>manly表示存储在该地址处的值。*manly与常规int变量等效</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> updates = <span class="hljs-number">6</span>;        <span class="hljs-comment">// declare a variable</span>    <span class="hljs-type">int</span> * p_updates;        <span class="hljs-comment">// declare pointer to an int</span>    p_updates = &amp;updates;   <span class="hljs-comment">// assign address of int to pointer</span><span class="hljs-comment">// express values two ways</span>    cout &lt;&lt; <span class="hljs-string">&quot;Values: updates = &quot;</span> &lt;&lt; updates;    cout &lt;&lt; <span class="hljs-string">&quot;, *p_updates = &quot;</span> &lt;&lt; *p_updates &lt;&lt; endl;<span class="hljs-comment">// express address two ways</span>    cout &lt;&lt; <span class="hljs-string">&quot;Addresses: &amp;updates = &quot;</span> &lt;&lt; &amp;updates;    cout &lt;&lt; <span class="hljs-string">&quot;, p_updates = &quot;</span> &lt;&lt; p_updates &lt;&lt; endl;<span class="hljs-comment">// use pointer to change value</span>    *p_updates = *p_updates + <span class="hljs-number">1</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Now updates = &quot;</span> &lt;&lt; updates &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Values: updates = 6, *p_updates = 6</span><span class="hljs-comment">//Addresses: &amp;updates = 0x16dd2b738, p_updates = 0x16dd2b738</span><span class="hljs-comment">//Now updates = 7</span></code></pre></div><p>从中可知，int变量updates和指针变量p_updates只不过是同一枚硬币的两面。变量updates表示值，并使用&amp;运算符来获得地址；而变量p_updates表示地址，并使用<em>运算符来获得值。由于 p_updates指向updates，因此</em>p_updates和updates完全等价。可以像使用 int变量那样使用<em>p_updates。正如程序清单4.15表明的，甚至可以将值赋给</em>p_updates。这样做将修改指向的值，即updates。</p><h3 id="声明和初始化指针"><a href="#声明和初始化指针" class="headerlink" title="声明和初始化指针"></a>声明和初始化指针</h3><p>指针声明必须指定指针指向的数据的类型</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> * p_updates;</code></pre></div><p>这表明，* p_updates的类型为int。由于<em>运算符被用于指针，因此p_updates变量本身必须是指针。我们说p_updates指向int类型，我们还说p_updates的类型是指向int的指针，或int</em>。可以这样说，p_updates是指针（地址），而*p_updates是int，而不是指针</p><p>顺便说一句，*运算符两边的空格是可选的。传统上，C程序员使用这种格式：</p><div class="code-wrapper"><pre><code class="hljs autoit"><span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span></code></pre></div><p>这强调*ptr是一个int类型的值。而很多C++程序员使用这种格式：</p><div class="code-wrapper"><pre><code class="hljs abnf">inr* ptr<span class="hljs-comment">;</span></code></pre></div><p>这强调的是：int*是一种类型—指向int的指针。在哪里添加空格对于编译器来说没有任何区别，您甚至可以这样做：</p><div class="code-wrapper"><pre><code class="hljs autoit"><span class="hljs-built_in">int</span>*<span class="hljs-built_in">ptr</span><span class="hljs-comment">;</span></code></pre></div><p>但要知道的是，下面的声明创建一个指针（p1）和一个int变量（p2）：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">int</span>* <span class="hljs-built_in">p1</span>, <span class="hljs-built_in">p2</span><span class="hljs-comment">;</span></code></pre></div><p>对每个指针变量名，都需要使用一个*。</p><p>*<em>在C++中，int <em>是一种复合类型，是指向int的指针</em></em></p><p>可以用同样的句法来声明指向其他类型的指针：</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-built_in">double</span> * tax_ptr;<span class="hljs-built_in">char</span> * <span class="hljs-built_in">str</span>;</code></pre></div><p>由于已将tax_ptr声明为一个指向double的指针，因此编译器知道 tax_ptr是一个double类型的值。也就是说，它知道*tax_ptr是一个以浮 点格式存储的值，这个值（在大多数系统上）占据8个字节。指针变量 不仅仅是指针，而且是指向特定类型的指针。tax_ptr的类型是指向 double的指针（或double *类型），str是指向char的指针类型（或char *）。尽管它们都是指针，却是不同类型的指针。和数组一样，指针都 是基于其他类型的。 </p><p>虽然tax_ptr和str指向两种长度不同的数据类型，但这两个变量本身的长度通常是相同的。也就是说，char的地址与double的地址的长度相 同，地址的长度或值既不能指示关于变量的长度或类型的任何信息，也不能指示该地址上有什么建筑物。一般来说，地址需要2个还是4 个字节，取决于计算机系统</p><p>可以在声明语句中初始化指针。在这种情况下，被初始化的是指针，而不是它指向的值。也就是说，下面的语句将pt（而不是*pt）的值 设置为&amp;higgens：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> higgens = <span class="hljs-number">5</span>;<span class="hljs-built_in">int</span> * pt=&amp;higgens;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// init_ptr.cpp -- initialize a pointer</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> higgens = <span class="hljs-number">5</span>;    <span class="hljs-type">int</span> * pt = &amp;higgens;    cout &lt;&lt; <span class="hljs-string">&quot;Value of higgens = &quot;</span> &lt;&lt; higgens         &lt;&lt; <span class="hljs-string">&quot;; Address of higgens = &quot;</span> &lt;&lt; &amp;higgens &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Value of *pt = &quot;</span> &lt;&lt; *pt         &lt;&lt; <span class="hljs-string">&quot;; Value of pt = &quot;</span> &lt;&lt; pt &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Value of higgens = 5; Address of higgens = 0x16fc77738</span><span class="hljs-comment">//Value of *pt = 5; Value of pt = 0x16fc77738</span></code></pre></div><h3 id="指针的危险"><a href="#指针的危险" class="headerlink" title="指针的危险"></a>指针的危险</h3><p>在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存</p><div class="code-wrapper"><pre><code class="hljs abnf">long * fellow<span class="hljs-comment">;</span>*fellow <span class="hljs-operator">=</span> <span class="hljs-number">23333</span><span class="hljs-comment">;</span></code></pre></div><p>fellow确实是一个指针，但它指向哪里呢？上述代码没有将地址赋 给fellow。那么223323将被放在哪里呢？我们不知道。由于fellow没有被 初始化，它可能有任何值。不管值是什么，程序都将它解释为存储 223323的地址。如果fellow的值碰巧为1200，计算机将把数据放在地址 1200上，即使这恰巧是程序代码的地址。fellow指向的地方很可能并不 是所要存储223323的地方。这种错误可能会导致一些最隐匿、最难以跟 踪的bug</p><p>一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。这是关于使用指针的金科玉律。</p><h3 id="指针和数字"><a href="#指针和数字" class="headerlink" title="指针和数字"></a>指针和数字</h3><p>指针不是整型，虽然计算机通常把地址当作整数来处理。从概念上 看，指针与整数是截然不同的类型。整数是可以执行加、减、除等运算 的数字，而指针描述的是位置，将两个地址相乘没有任何意义。从可以 对整数和指针执行的操作上看，它们也是彼此不同的。因此，不能简单 地将整数赋给指针</p><div class="code-wrapper"><pre><code class="hljs abnf">int * pt<span class="hljs-comment">;</span><span class="hljs-attribute">pt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>xB800000<span class="hljs-comment">;//左边是指向int型指针，但是右边是一个整数</span><span class="hljs-attribute">pt</span> <span class="hljs-operator">=</span> （int *）<span class="hljs-number">0</span>xB800000<span class="hljs-comment">;//要强制转成int * 才可以；这样两边都是int 指针类型</span></code></pre></div><h3 id="使用new来分配内存"><a href="#使用new来分配内存" class="headerlink" title="使用new来分配内存"></a>使用new来分配内存</h3><p>前面我们都将指针初始化为变量的地址；变量是在编译时分配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了 一个别名。指针真正的用武之地在于，在运行阶段分配未命名的内存以存储值。在这种情况下，只能通过指针来访问内存。在C语言中，可以 用库函数malloc( )来分配内存；在C++中仍然可以这样做，但C++还有更好的方法—new运算符。 </p><p>程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋给一个指针</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> * pn =<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>；</code></pre></div><p>new int告诉程序，需要适合存储int的内存。new运算符根据类型来 确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。接下来，将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地址，而*pn是存储在那里的值。将这种方法与将变量的地址赋给指针进行比较：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> higgens;<span class="hljs-type">int</span> * pt = &amp;higgens;</code></pre></div><p>在这两种情况（pn和pt）下，都是将一个int变量的地址赋给了指针。在第二种情况下，可以通过名称higgens来访问该int，在第一种情况 下，则只能通过该指针进行访问。这引出了一个问题：pn指向的内存没有名称，如何称呼它呢？我们说pn指向一个数据对象，这里的“对象”不是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变 量”更通用，它指的是为数据项分配的内存块。因此，变量也是数据对象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。</p><p>为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下</p><div class="code-wrapper"><pre><code class="hljs cpp">typeName * pointer_name = <span class="hljs-keyword">new</span> typeName;</code></pre></div><p>需要在两个地方指定数据类型：用来指定需要什么样的内存和用来声明合适的指针。当然，如果已经声明了相应类型的指针，则可以使用 该指针，而不用再声明一个新的指针</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// use_new.cpp -- using the new operator</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> nights = <span class="hljs-number">1001</span>;    <span class="hljs-type">int</span> * pt = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;         <span class="hljs-comment">// allocate space for an int</span>    *pt = <span class="hljs-number">1001</span>;                 <span class="hljs-comment">// store a value there</span>    cout &lt;&lt; <span class="hljs-string">&quot;nights value = &quot;</span>;    cout &lt;&lt; nights &lt;&lt; <span class="hljs-string">&quot;: location &quot;</span> &lt;&lt; &amp;nights &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;int &quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;value = &quot;</span> &lt;&lt; *pt &lt;&lt; <span class="hljs-string">&quot;: location = &quot;</span> &lt;&lt; pt &lt;&lt; endl;    <span class="hljs-type">double</span> * pd = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>;   <span class="hljs-comment">// allocate space for a double</span>    *pd = <span class="hljs-number">10000001.0</span>;           <span class="hljs-comment">// store a double there</span>    cout &lt;&lt; <span class="hljs-string">&quot;double &quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;value = &quot;</span> &lt;&lt; *pd &lt;&lt; <span class="hljs-string">&quot;: location = &quot;</span> &lt;&lt; pd &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;location of pointer pd: &quot;</span> &lt;&lt; &amp;pd &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;size of pt = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(pt);    cout &lt;&lt; <span class="hljs-string">&quot;: size of *pt = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(*pt) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;size of pd = &quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span> pd;    cout &lt;&lt; <span class="hljs-string">&quot;: size of *pd = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(*pd) &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//nights value = 1001: location 0x16b21f738</span><span class="hljs-comment">//int value = 1001: location = 0x600003ed0030</span><span class="hljs-comment">//double value = 1e+07: location = 0x600003ed0040</span><span class="hljs-comment">//location of pointer pd: 0x16b21f728</span><span class="hljs-comment">//size of pt = 8: size of *pt = 4</span><span class="hljs-comment">//size of pd = 8: size of *pd = 8</span></code></pre></div><p>对于指针，需要指出的另一点是，new分配的内存块通常与常规变量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈 （stack）的内存区域中，而new从被称为堆heap）或自由存储区（free store）的内存区域分配内存。</p><h3 id="使用delete释放内存"><a href="#使用delete释放内存" class="headerlink" title="使用delete释放内存"></a>使用delete释放内存</h3><p>当需要内存时，可以使用new来请求，这只是C++内存管理数据包中有魅力的一个方面。另一个方面是delete运算符，它使得在使用完内 存后，能够将其归还给内存池，这是通向最有效地使用内存的关键一步。归还或释放（free）的内存可供程序的其他部分使用。使用delete时，后面要加上指向内存块的指针（这些内存块最初是用new分配的）：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ps=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-keyword">delete</span> ps;</code></pre></div><p>这将释放ps指向的内存，但不会删除指针ps本身。例如，可以将ps重新指向另一个新分配的内存块。一定要配对地使用new和delete；否则将发生内存泄漏（memory leak），也就是说，被分配的内存再也无法使用了。如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。 </p><p>不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。另外，不能使用delete来 释放声明变量所获得的内存：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> * ps = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">//ok</span><span class="hljs-keyword">delete</span> ps; <span class="hljs-comment">//ok</span><span class="hljs-keyword">delete</span> ps; <span class="hljs-comment">//not ok 不要尝试释放已经释放的内存块</span><span class="hljs-type">int</span> jud = <span class="hljs-number">5</span>; <span class="hljs-comment">//ok</span><span class="hljs-type">int</span> * pi =&amp;jud; <span class="hljs-comment">//ok</span><span class="hljs-keyword">delete</span> pi <span class="hljs-comment">//not allowed new和delete需要配合使用，不能使用delete删除非new创建的指针赋值</span></code></pre></div><p><strong>只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的</strong></p><p>注意，使用delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> * ps = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">//allocate memory</span><span class="hljs-type">int</span> * pq = ps; <span class="hljs-comment">//set same pointer to same block</span><span class="hljs-keyword">delete</span> pq; <span class="hljs-comment">//delete second block</span></code></pre></div><p>一般来说，不要创建两个指向同一个内存块的指针，因为这将增加错误地删除同一个内存块两次的可能性。但稍后您会看到，对于返回指 针的函数，使用另一个指针确实有道理</p><h3 id="使用new来创建动态数组"><a href="#使用new来创建动态数组" class="headerlink" title="使用new来创建动态数组"></a>使用new来创建动态数组</h3><p>在编译时给数组分配内存被称 为静态联编（static binding），意味着数组是在编译时加入到程序中的。但使用new时，如果在运行阶段需要数组，则创建它；如果不需要，则不创建。还可以在程序运行时选择数组的长度。这被称为动态联 编（dynamic binding），意味着数组是在程序运行时创建的。这种数组 叫作动态数组（dynamic array）。使用静态联编时，必须在编写程序时指定数组的长度；使用动态联编时，程序将在运行时确定数组的长度。</p><h4 id="使用new创建动态数组"><a href="#使用new创建动态数组" class="headerlink" title="使用new创建动态数组"></a>使用new创建动态数组</h4><p>在C++中，创建动态数组很容易；只要将数组的元素类型和元素数目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。例 如，要创建一个包含10个int元素的数组，可以这样做：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> * arr =<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//new运算符返回第一个元素的地址</span></code></pre></div><p>当程序使用完new分配的内存块时，应使用delete释放它们。然而，对于使用new创建的数组，应使用另一种格式的delete来释放： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">delete</span> [] arr;</code></pre></div><p>方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。 请注意delete和指针之间的方括号。如果使用new时，不带方括号，则使 用delete时，也不应带方括号。如果使用new时带方括号，则使用delete 时也应带方括号。C++的早期版本无法识别方括号表示法。然而，对于ANSI/ISO标准来说，new与delete的格式不匹配导致的后果是不确定的，这意味着程序员不能依赖于某种特定的行为。</p><p>总之，使用new和delete时，应遵守以下规则:</p><ul><li>不要使用delete来释放不是new分配的内存。 </li><li>不要使用delete释放同一个内存块两次。 </li><li>如果使用new [ ]为数组分配内存，则应使用delete [ ]来释放。 </li><li>如果使用new 为一个实体分配内存，则应使用delete（没有方括号）来释放</li><li>对空指针应用delete是安全的。</li></ul><p>Arr是指向一个int（数组第一个元素）的指针。您的责任是跟踪内存块中的元素个数。也就是说，由于编译器不能对psome是指向10个整数中的第1个这种情况进行跟踪，因此编写程序时，必须让程序跟踪元素的数目。</p><p>实际上，程序确实跟踪了分配的内存量，以便以后使用delete [ ]运算符时能够正确地释放这些内存。但这种信息不是公用的，例如，不能 使用sizeof运算符来确定动态分配的数组包含的字节数</p><p>为数组分配内存的通用格式如下： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typename</span> * pointer_name = <span class="hljs-keyword">new</span> <span class="hljs-keyword">typename</span>[num_elements];</code></pre></div><p>使用new运算符可以确保内存块足以存储num_elements个类型为type_name的元素，而pointer_name将指向第1个元素。下面将会看到，可以以使用数组名的方式来使用pointer_name。 </p><h4 id="使用动态数组"><a href="#使用动态数组" class="headerlink" title="使用动态数组"></a>使用动态数组</h4><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> * psome = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// arraynew.cpp -- using the new operator for arrays</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> * p3 = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span> [<span class="hljs-number">3</span>]; <span class="hljs-comment">// space for 3 doubles</span>    p3[<span class="hljs-number">0</span>] = <span class="hljs-number">0.2</span>;                  <span class="hljs-comment">// treat p3 like an array name</span>    p3[<span class="hljs-number">1</span>] = <span class="hljs-number">0.5</span>;    p3[<span class="hljs-number">2</span>] = <span class="hljs-number">0.8</span>;    cout &lt;&lt; <span class="hljs-string">&quot;p3[1] is &quot;</span> &lt;&lt; p3[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    p3 = p3 + <span class="hljs-number">1</span>;                  <span class="hljs-comment">// increment the pointer</span>    cout &lt;&lt; <span class="hljs-string">&quot;Now p3[0] is &quot;</span> &lt;&lt; p3[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; and &quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;p3[1] is &quot;</span> &lt;&lt; p3[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    p3 = p3 - <span class="hljs-number">1</span>;                  <span class="hljs-comment">// point back to beginning</span>    <span class="hljs-keyword">delete</span> [] p3;                 <span class="hljs-comment">// free the memory</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//p3[1] is 0.5.</span><span class="hljs-comment">//Now p3[0] is 0.5 and p3[1] is 0.8.</span></code></pre></div><h2 id="指针、数组和指针算术"><a href="#指针、数组和指针算术" class="headerlink" title="指针、数组和指针算术"></a>指针、数组和指针算术</h2><p>指针和数组基本等价的原因在于指针算术（pointer arithmetic）和C++内部处理数组的方式。</p><p>首先，我们来看一看算术。将整数变量加1后，其值将增加1；但将指针变量加1后，增加的量等于它指向的类型的字节数。将指向double的指针加1后，如果系统对double使用8个字节存储，则数值将增加8；将指向short的指针加1后，如果系统对short使用2个字节存储，则指针值将增加2</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// addpntrs.cpp -- pointer addition</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> wages[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">10000.0</span>, <span class="hljs-number">20000.0</span>, <span class="hljs-number">30000.0</span>&#125;;    <span class="hljs-type">short</span> stacks[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-comment">// Here are two ways to get the address of an array</span>    <span class="hljs-type">double</span> * pw = wages;     <span class="hljs-comment">// name of an array = address</span>    <span class="hljs-type">short</span> * ps = &amp;stacks[<span class="hljs-number">0</span>]; <span class="hljs-comment">// or use address operator</span><span class="hljs-comment">// with array element</span>    cout &lt;&lt; <span class="hljs-string">&quot;pw = &quot;</span> &lt;&lt; pw &lt;&lt; <span class="hljs-string">&quot;, *pw = &quot;</span> &lt;&lt; *pw &lt;&lt; endl;    pw = pw + <span class="hljs-number">1</span>;    cout &lt;&lt; <span class="hljs-string">&quot;add 1 to the pw pointer:\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;pw = &quot;</span> &lt;&lt; pw &lt;&lt; <span class="hljs-string">&quot;, *pw = &quot;</span> &lt;&lt; *pw &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;ps = &quot;</span> &lt;&lt; ps &lt;&lt; <span class="hljs-string">&quot;, *ps = &quot;</span> &lt;&lt; *ps &lt;&lt; endl;    ps = ps + <span class="hljs-number">1</span>;    cout &lt;&lt; <span class="hljs-string">&quot;add 1 to the ps pointer:\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;ps = &quot;</span> &lt;&lt; ps &lt;&lt; <span class="hljs-string">&quot;, *ps = &quot;</span> &lt;&lt; *ps &lt;&lt; <span class="hljs-string">&quot;\n\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;access two elements with array notation\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;stacks[0] = &quot;</span> &lt;&lt; stacks[<span class="hljs-number">0</span>]         &lt;&lt; <span class="hljs-string">&quot;, stacks[1] = &quot;</span> &lt;&lt; stacks[<span class="hljs-number">1</span>] &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;access two elements with pointer notation\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;*stacks = &quot;</span> &lt;&lt; *stacks         &lt;&lt; <span class="hljs-string">&quot;, *(stacks + 1) =  &quot;</span> &lt;&lt; *(stacks + <span class="hljs-number">1</span>) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(wages) &lt;&lt; <span class="hljs-string">&quot; = size of wages array\n&quot;</span>;    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(pw) &lt;&lt; <span class="hljs-string">&quot; = size of pw pointer\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//pw = 0x16cf37720, *pw = 10000</span><span class="hljs-comment">//add 1 to the pw pointer:</span><span class="hljs-comment">//pw = 0x16cf37728, *pw = 20000</span><span class="hljs-comment">//</span><span class="hljs-comment">//ps = 0x16cf37714, *ps = 3</span><span class="hljs-comment">//add 1 to the ps pointer:</span><span class="hljs-comment">//ps = 0x16cf37716, *ps = 2</span><span class="hljs-comment">//</span><span class="hljs-comment">//access two elements with array notation</span><span class="hljs-comment">//stacks[0] = 3, stacks[1] = 2</span><span class="hljs-comment">//access two elements with pointer notation</span><span class="hljs-comment">//*stacks = 3, *(stacks + 1) =  2</span><span class="hljs-comment">//24 = size of wages array</span><span class="hljs-comment">//8 = size of pw pointer</span></code></pre></div><h3 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h3><p>将指针变量加1后，其增加的值等于指向的类型占用的字节数。</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-18%2015.38.18.png"></p><p>此后，程序对ps执行相同的操作。这一次由于ps指向的是shor t类型，而short占用2个字节，因此将指针加1时，其值将增加2。结果是， 指针也指向数组中下一个元素。</p><p>数组表达式stacks[1]。C++编译器将该表达式看作是 <em>（stacks + 1），这意味着先计算数组第2个元素的地址，然后找到存储 在那里的值。最后的结果便是stacks [1]的含义（运算符优先级要求使用括号，如果不使用括号，将给</em>stacks加1，而不是给stacks加1）。</p><p>从该程序的输出可知，*（stacks + 1）和stacks[1]是等价的。同样， *（stacks + 2）和stacks[2]也是等价的。通常，使用数组表示法时， C++都执行下面的转换</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">array</span>name[i] become *(<span class="hljs-built_in">array</span>name+<span class="hljs-number">1</span>)</code></pre></div><p>如果使用的是指针，而不是数组名，则C++也将执行同样的转换： </p><div class="code-wrapper"><pre><code class="hljs css">pointername<span class="hljs-selector-attr">[i]</span> become *(pintername+<span class="hljs-selector-tag">i</span>)</code></pre></div><p>因此，在很多情况下，可以相同的方式使用指针名和数组名。对于 它们，可以使用数组方括号表示法，也可以使用解除引用运算符 </p><p>（*）。在多数表达式中，它们都表示地址。区别之一是，可以修改指 针的值，而数组名是常量：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">pintername</span> =pointername+<span class="hljs-number">1</span><span class="hljs-comment">; //valid</span><span class="hljs-attr">arratname</span> = arrayname +<span class="hljs-number">1</span> //<span class="hljs-literal">no</span> valid</code></pre></div><p>另一个区别是，对数组应用sizeof运算符得到的是数组的长度，而 对指针应用sizeof得到的是指针的长度</p><p>数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址： </p><div class="code-wrapper"><pre><code class="hljs perl">short <span class="hljs-keyword">tell</span>[<span class="hljs-number">10</span>];cout &lt;&lt; <span class="hljs-keyword">tell</span> &lt;&lt; endl;<span class="hljs-regexp">//displa</span><span class="hljs-keyword">y</span> <span class="hljs-keyword">tell</span>[<span class="hljs-number">0</span>]cout &lt;&lt; &amp;<span class="hljs-keyword">tell</span> &lt;&lt; endl; <span class="hljs-regexp">//</span>display address of the whole array</code></pre></div><p>从数字上说，这两个地址相同；但从概念上说，&amp;tell[0]（即tell）是一个2字节内存块的地址，而&amp;tell是一个20字节内存块的地址。因此，表达式tell + 1将地址值加2，而表达式&amp;tell 2将地址加20。换句话说，tell是一个short指针（* short），而&amp;tell是一个这样的指针，即指 向包含20个元素的short数组（short (*) [20]）。</p><div class="code-wrapper"><pre><code class="hljs 1c">short (*pas)[<span class="hljs-number">20</span>] = <span class="hljs-meta">&amp;tell;</span></code></pre></div><p>如果省略括号，优先级规则将使得pas先与[20]结合，导致pas是一个short指针数组，它包含20个元素，因此括号是必不可少的。其次，如果要描述变量的类型，可将声明中的变量名删除。因此，pas的类型为short (<em>) [20]。另外，由于pas被设置为&amp;tell，因此</em>pas与tell等价，所以(*pas) [0]为tell数组的第一个元素。 </p><p><strong>总之，使用new来创建数组以及使用指针来访问不同的元素很简 单。只要把指针当作数组名对待即可。然而，要理解为何可以这样做， 将是一种挑战。要想真正了解数组和指针，应认真复习它们的相互关 系</strong></p><h3 id="指针小结"><a href="#指针小结" class="headerlink" title="指针小结"></a>指针小结</h3><h4 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h4><p>​    要声明指向特定类型的指针，请使用下面的格式</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typename</span> * pintername</code></pre></div><h4 id="给指针赋值"><a href="#给指针赋值" class="headerlink" title="给指针赋值"></a>给指针赋值</h4><p>应将内存地址赋给指针。可以对变量名应用&amp;运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址。</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">double</span> * pn;<span class="hljs-type">double</span> * pa;<span class="hljs-type">char</span> * pc;<span class="hljs-type">double</span> bubble = <span class="hljs-number">3.2</span>;pn = &amp;bubble;pc = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>;pa = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[<span class="hljs-number">20</span>];</code></pre></div><h4 id="对指针解除引用"><a href="#对指针解除引用" class="headerlink" title="对指针解除引用"></a>对指针解除引用</h4><p>对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符（*）来解除引用</p><h4 id="区分指针和指针所指向的值"><a href="#区分指针和指针所指向的值" class="headerlink" title="区分指针和指针所指向的值"></a>区分指针和指针所指向的值</h4><p>如果pt是指向int的指针，则*pt不是指向int的指针，而是完全等同于一个int类型的变量。pt才是指针。 </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> *pt = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-comment">//assign an address to the pointer pt</span>*pt = <span class="hljs-number">5</span>; <span class="hljs-comment">//store the value 5 at the address</span></code></pre></div><h4 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h4><p>在多数情况下，C++将数组名视为数组的第一个元素的地址。</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> tacos[<span class="hljs-number">10</span>]; <span class="hljs-comment">//now tacos is the same as &amp;tacos[0]</span></code></pre></div><p>一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。</p><h4 id="指针算术"><a href="#指针算术" class="headerlink" title="指针算术"></a>指针算术</h4><p>C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。还可以将一个指针减去另一个指针，获得两 个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数组（也可以指向超出结尾的一个位置）时，这种运算才有意义；这将得到两个元素的间隔。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tacos[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-type">int</span> * pt =tacos;pt = pt+<span class="hljs-number">1</span>;<span class="hljs-type">int</span> *pe = &amp;tacos[<span class="hljs-number">9</span>];pe = pe <span class="hljs-number">-1</span>;<span class="hljs-type">int</span> diff  = pe - pt;</code></pre></div><h4 id="数组的动态联编和静态联编"><a href="#数组的动态联编和静态联编" class="headerlink" title="数组的动态联编和静态联编"></a>数组的动态联编和静态联编</h4><p>使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置：</p><div class="code-wrapper"><pre><code class="hljs abnf">int tacos[<span class="hljs-number">10</span>]<span class="hljs-comment">;</span></code></pre></div><p>使用new[ ]运算符创建数组时，将采用动态联编（动态数组），即 将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数 组后，应使用delete [ ]释放其占用的内存：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-type">int</span> size ;<span class="hljs-type">int</span> *pz = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<span class="hljs-keyword">delete</span> [] pz;</code></pre></div><h4 id="数组表示法和指针表示法"><a href="#数组表示法和指针表示法" class="headerlink" title="数组表示法和指针表示法"></a>数组表示法和指针表示法</h4><p>使用方括号数组表示法等同于对指针解除引用</p><div class="code-wrapper"><pre><code class="hljs css">tacos<span class="hljs-selector-attr">[0]</span> means *tacos means the value at <span class="hljs-selector-tag">address</span> tacostacos<span class="hljs-selector-attr">[3]</span> means *(tacos+<span class="hljs-number">3</span>) means the value at <span class="hljs-selector-tag">address</span> + <span class="hljs-number">3</span> <span class="hljs-selector-tag">address</span></code></pre></div><p>数组名和指针变量都是如此，因此对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];*pt = <span class="hljs-number">5</span>;pt[<span class="hljs-number">0</span>]=<span class="hljs-number">6</span>;pt[<span class="hljs-number">9</span>]=<span class="hljs-number">44</span>;<span class="hljs-type">int</span> coast[<span class="hljs-number">10</span>];*(coast + <span class="hljs-number">4</span>) = <span class="hljs-number">12</span>;</code></pre></div><h3 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h3><h3 id="使用new创建动态结构"><a href="#使用new创建动态结构" class="headerlink" title="使用new创建动态结构"></a>使用<strong>new</strong>创建动态结构</h3><p>在运行时创建数组优于在编译时创建数组，对于结构也是如此。需 要在程序运行时为结构分配所需的空间，这也可以使用new运算符来完 成。通过使用new，可以创建动态结构。同样，“动态”意味着内存是在运行时，而不是编译时分配的</p><p>将new用于结构由两步组成：创建结构和访问其成员。要创建结构，需要同时使用结构类型和new。例如，要创建一个未命名的 inflatable类型，并将其地址赋给一个指针，可以这样做：</p><div class="code-wrapper"><pre><code class="hljs abnf">inflatable * ps <span class="hljs-operator">=</span> new inflatable<span class="hljs-comment">;</span></code></pre></div><p>这将把足以存储inflatable结构的一块可用内存的地址赋给ps。这种句法和C++的内置类型完全相同。 比较棘手的一步是访问成员。创建动态结构时，不能将成员运算符 句点用于结构名，因为这种结构没有名称，只是知道它的地址。C++专 门为这种情况提供了一个运符：箭头成员运算符（−&gt;）。该运算符由 连字符和大于号组成，可用于指向结构的指针，就像点运算符可用于结 构名一样。例如，如果ps指向一个inflatable结构，则ps−&gt;price是被指向 的结构的price成员</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thing</span> &#123;<span class="hljs-type">int</span> good;<span class="hljs-type">int</span> bad;&#125;things grubnose = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">435</span>&#125;;things * pt = &amp;grubnose;grubnose.good;grubnose.bad;pt-&gt;good;pt-&gt;bad;</code></pre></div><p>如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构的指针，则使用箭头运算符。</p><p>另一种访问结构成员的方法是，如果ps是指向结构的指针，则<em>ps就是被指向的值—结构本身。由于</em>ps是一个结构，因此（*ps）.price是 该结构的price成员。C++的运算符优先规则要求使用括号。 </p><div class="code-wrapper"><pre><code class="hljs js">#include &lt;iostream&gt;struct inflatable   <span class="hljs-comment">// structure definition</span>&#123;    char name[<span class="hljs-number">20</span>];    float volume;    double price;&#125;;int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;    using namespace std;    inflatable * ps = <span class="hljs-keyword">new</span> inflatable; <span class="hljs-comment">// allot memory for structure</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter name of inflatable item: &quot;</span>;    cin.<span class="hljs-title function_">get</span>(ps-&gt;name, <span class="hljs-number">20</span>);            <span class="hljs-comment">// method 1 for member access</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter volume in cubic feet: &quot;</span>;    cin &gt;&gt; (*ps).<span class="hljs-property">volume</span>;              <span class="hljs-comment">// method 2 for member access</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter price: $&quot;</span>;    cin &gt;&gt; ps-&gt;price;    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; (*ps).<span class="hljs-property">name</span> &lt;&lt; endl;              <span class="hljs-comment">// method 2</span>    cout &lt;&lt; <span class="hljs-string">&quot;Volume: &quot;</span> &lt;&lt; ps-&gt;volume &lt;&lt; <span class="hljs-string">&quot; cubic feet\n&quot;</span>; <span class="hljs-comment">// method 1</span>    cout &lt;&lt; <span class="hljs-string">&quot;Price: $&quot;</span> &lt;&lt; ps-&gt;price &lt;&lt; endl;             <span class="hljs-comment">// method 1</span>    <span class="hljs-keyword">delete</span> ps;                        <span class="hljs-comment">// free memory used by structure</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter name of inflatable item: Fabulous Frodo</span><span class="hljs-comment">//Enter volume in cubic feet: 1.4</span><span class="hljs-comment">//Enter price: $27.99</span><span class="hljs-comment">//Name: Fabulous Frodo</span><span class="hljs-comment">//Volume: 1.4 cubic feet</span><span class="hljs-comment">//Price: $27.99</span></code></pre></div><p>一个使用new和delete的示例</p><p>下面介绍一个使用new和delete来存储通过键盘输入的字符串的示例。程序清单4.22定义了一个函数getname( )，该函数返回一个指向输入字符串的指针。该函数将输入读入到一个大型的临时数组中，然后使用new [ ]创建一个刚好能够存储该输入字符串的内存块，并返回一个指向该内存块的指针。对于读取大量字符串的程序，这种方法可以节省大量内存（实际编写程序时，使用string类将更容易，因为这样可以使用内置的new和delete）。 </p><p>假设程序要读取1000个字符串，其中最大的字符串包含79个字符，而大多数字符串都短得多。如果用char数组来存储这些字符串，则需要 1000个数组，其中每个数组的长度为80个字符。这总共需要80000个字节，而其中的很多内存没有被使用。另一种方法是，创建一个数组，它包含1000个指向char的指针，然后使用new根据每个字符串的需要分配相应数量的内存。这将节省几万个字节。是根据输入来分配内存，而不是为每个字符串使用一个大型数组。另外，还可以使用new根据需要的指针数量来分配空间。就目前而言，这有点不切实际，即使是使用1000个指针的数组也是这样，不过程序清单4.22还是演示了一些技巧。另外，为演示delete是如何工作的，该程序还用它来释放内存以便能够重新使用。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// delete.cpp -- using the delete operator</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>      <span class="hljs-comment">// or string.h</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">getname</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;   <span class="hljs-comment">// function prototype</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">char</span> * name;        <span class="hljs-comment">// create pointer but no storage</span>    name = <span class="hljs-built_in">getname</span>();   <span class="hljs-comment">// assign address of string to name</span>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; (<span class="hljs-type">int</span> *) name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">delete</span> [] name;     <span class="hljs-comment">// memory freed</span>    name = <span class="hljs-built_in">getname</span>();   <span class="hljs-comment">// reuse freed memory</span>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; (<span class="hljs-type">int</span> *) name &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-keyword">delete</span> [] name;     <span class="hljs-comment">// memory freed again</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">getname</span><span class="hljs-params">()</span>        <span class="hljs-comment">// return pointer to new string</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">char</span> temp[<span class="hljs-number">80</span>];      <span class="hljs-comment">// temporary storage</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter last name: &quot;</span>;    cin &gt;&gt; temp;    <span class="hljs-type">char</span> * pn = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(temp) + <span class="hljs-number">1</span>];    <span class="hljs-built_in">strcpy</span>(pn, temp);   <span class="hljs-comment">// copy string into smaller space</span>    <span class="hljs-keyword">return</span> pn;          <span class="hljs-comment">// temp lost when function ends</span>&#125;<span class="hljs-comment">//Enter last name: Fredelddumpkin</span><span class="hljs-comment">//Fredelddumpkin at 0x600000f70000</span><span class="hljs-comment">//Enter last name: Pook</span><span class="hljs-comment">//Pook at 0x600000f70000</span></code></pre></div><p>来看一下程序清单4.22中的函数getname( )。它使用cin将输入的单词放到temp数组中，然后使用new分配新内存，以存储该单词。程序需要strle（temp）+ 1个字符（包括空字符）来存储该字符串，因此将这个值提供给new。获得空间后，getname( )使用标准库函数strcpy( )将temp中的字符串复制到新的内存块中。该函数并不检查内存块是否能够容纳字符串，但getname( )通过使用new请求合适的字节数来完成了这样的工作。最后，函数返回pn，这是字符串副本的地址。 </p><p>在main( )中，返回值（地址）被赋给指针name。该指针是在main( )中定义的，但它指向getname( )函数中分配的内存块。然后，程序打印该字符串及其地址。接下来，在释放name指向的内存块后，main( )再次调用getname()。C++不保证新释放的内存就是下一次使用new时选择的内存，从程序运行结果可知，确实不是。 </p><p>在这个例子中，getname( )分配内存，而main( )释放内存。将new和delete放在不同的函数中通常并不是个好办法，因为这样很容易忘记使用delete。不过这个例子确实把new和delete分开放置了，只是为了说明这样做也是可以的。 </p><h3 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h3><p>根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在 时间的长短方面，以这3种方式分配的数据对象各不相同.（C++11新增了第四种类型—线程存储</p><h4 id="自动存储"><a href="#自动存储" class="headerlink" title="自动存储"></a>自动存储</h4><p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量 （automatic variable），这意味着它们在所属的函数被调用时自动产 生，在该函数结束时消亡。例如，程序清单4.22中的temp数组仅当getname( )函数活动时存在。当程序控制权回到main( )时，temp使用的内存将自动被释放。如果getname( )返回temp的地址，则main( )中的name指针指向的内存将很快得到重新使用。这就是在getname( )中使用new的原因之一。</p><p>实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。到目前为止，我们使用的所有 代码块都是整个函数。然而，在下一章将会看到，函数内也可以有代码块。如果在其中的某个代码块定义了一个变量，则该变量仅在程序执行该代码块中的代码时存在。 </p><p>自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量， 这被称为后进先出（LIFO）。因此，在程序执行过程中，栈将不断地增大和缩小。 </p><h4 id="静态存储"><a href="#静态存储" class="headerlink" title="静态存储"></a>静态存储</h4><p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用 关键字static：</p><div class="code-wrapper"><pre><code class="hljs abnf">static double fee <span class="hljs-operator">=</span> <span class="hljs-number">56.50</span><span class="hljs-comment">;</span></code></pre></div><p>在K&amp;R C中，只能初始化静态数组和静态结构，而C++ Release2.0（及后续版本）和ANSI C中，也可以初始化自动数组和自动结构。 然而，一些您可能已经发现，有些C++实现还不支持对自动数组和自动 结构的初始化。</p><p>自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定函数被执行时存在（自动变量）。</p><h4 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h4><p>new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的.new和delete让您能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或函数的生存时间控制。与使用常规变量相比，使用new和delete让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制使得占用的内存总是连续的，但new和delete 的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难</p><h4 id="栈、堆和内存泄漏"><a href="#栈、堆和内存泄漏" class="headerlink" title="栈、堆和内存泄漏"></a>栈、堆和内存泄漏</h4><p>如果使用new运算符在自由存储空间（或堆）上创建变量后，没有调用delete，将发生什么情况呢？如果没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。实际上，将会无法访 问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。极端情况（不过不常见）是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内 存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃,即使是最好的程序员和软件公司，也可能导致内存泄漏。要避免内存泄漏，最好是养成这样一种习惯，即同时使用new和delete运算符，在自由存储空间上动态分配内存，随后便释放它。C++智能指针有助于自动完成这种任务</p><h2 id="类型组合"><a href="#类型组合" class="headerlink" title="类型组合"></a>类型组合</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">antarctica_years_end</span> &#123;<span class="hljs-type">int</span> year;&#125;</code></pre></div><p>创建结构变量</p><div class="code-wrapper"><pre><code class="hljs cpp">antarctica_years_end s01,s02,s03;</code></pre></div><p>成员运算符访问成员</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">s01.year</span>=<span class="hljs-number">1998</span><span class="hljs-comment">;</span></code></pre></div><p>可创建指向这种结构的指针</p><div class="code-wrapper"><pre><code class="hljs 1c">antarctica_years_end * pa =<span class="hljs-meta">&amp;s02;</span></code></pre></div><p>将该指针设置为有效地址后，就可使用间接成员运算符来访问成员</p><div class="code-wrapper"><pre><code class="hljs abnf">pa -&gt; year <span class="hljs-operator">=</span><span class="hljs-number">1999</span><span class="hljs-comment">;</span></code></pre></div><p>可创建结构数组:</p><div class="code-wrapper"><pre><code class="hljs abnf">antarctica_years_end trio[<span class="hljs-number">3</span>]<span class="hljs-comment">;</span></code></pre></div><p>可以使用成员运算符访问元素的成员</p><div class="code-wrapper"><pre><code class="hljs arcade">trio[<span class="hljs-number">0</span>].<span class="hljs-built_in">year</span> = <span class="hljs-number">2003</span>;(trio+<span class="hljs-number">1</span>)-&gt;<span class="hljs-built_in">year</span> = <span class="hljs-number">2004</span>;<span class="hljs-comment">//same as trio[1].year =2004</span></code></pre></div><p>创建指针数组</p><div class="code-wrapper"><pre><code class="hljs dts">const antarctica_years_end *arp[<span class="hljs-number">3</span>] = <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">&amp;s01</span>,<span class="hljs-variable">&amp;s02</span>,<span class="hljs-variable">&amp;s03</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><p>可创建指向上述数组的指针</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> antarctica_years_end**ppa =arp <span class="hljs-comment">//arp指向数组的第一个值的指针，然后他的值又是指针，所以要获取真正的值需要** </span></code></pre></div><p>C++11版本的auto提供的方便。编译器知道arp的类型，能够正确地推断出ppb的类型：</p><div class="code-wrapper"><pre><code class="hljs abnf">auto ppb <span class="hljs-operator">=</span> arp；</code></pre></div><p>如何使用ppa来访问数据呢？由于ppa是一个指向结构指针的指针， 因此*ppa是一个结构指针，可将间接成员运算符应用于它： </p><div class="code-wrapper"><pre><code class="hljs livescript">std ：：cout &lt;&lt; <span class="hljs-function"><span class="hljs-params">(*ppa)</span>-&gt;</span>year &lt;&lt; std::endl;std ：：cout &lt;&lt; <span class="hljs-function"><span class="hljs-params">(*ppa+<span class="hljs-number">1</span>)</span>-&gt;</span>year &lt;&lt; std::endl;</code></pre></div><p>由于ppa指向arp的第一个元素，因此*ppa为第一个元素，即&amp;s01。所以，(*ppa)-&gt;year为s01的year成员。在第二条语句中，ppb+1指向下一 个元素arp[1]，即&amp;s02。其中的括号必不可少，这样才能正确地结合。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// mixtypes.cpp --some type combinations</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">antarctica_years_end</span>&#123;    <span class="hljs-type">int</span> year;    <span class="hljs-comment">/* some really interesting data, etc. */</span>&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    antarctica_years_end s01, s02, s03;    s01.year = <span class="hljs-number">1998</span>;    antarctica_years_end * pa = &amp;s02;    pa-&gt;year = <span class="hljs-number">1999</span>;    antarctica_years_end trio[<span class="hljs-number">3</span>]; <span class="hljs-comment">// array of 3 structures</span>    trio[<span class="hljs-number">0</span>].year = <span class="hljs-number">2003</span>;    std::cout &lt;&lt; trio-&gt;year &lt;&lt; std::endl;    <span class="hljs-type">const</span> antarctica_years_end * arp[<span class="hljs-number">3</span>] = &#123;&amp;s01, &amp;s02, &amp;s03&#125;;    std::cout &lt;&lt; arp[<span class="hljs-number">1</span>]-&gt;year &lt;&lt; std::endl;    <span class="hljs-type">const</span> antarctica_years_end ** ppa = arp;    <span class="hljs-keyword">auto</span> ppb = arp; <span class="hljs-comment">// C++0x automatic type deduction</span><span class="hljs-comment">// or else use const antarctica_years_end ** ppb = arp;</span>    std::cout &lt;&lt; (*ppa)-&gt;year &lt;&lt; std::endl;    std::cout &lt;&lt; (*(ppb+<span class="hljs-number">1</span>))-&gt;year &lt;&lt; std::endl;    <span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//2003</span><span class="hljs-comment">//1999</span><span class="hljs-comment">//1998</span><span class="hljs-comment">//1999</span></code></pre></div><h2 id="数组的替代品"><a href="#数组的替代品" class="headerlink" title="数组的替代品"></a>数组的替代品</h2><p>模板类vector和array是数组的替代品</p><h3 id="模板类vector"><a href="#模板类vector" class="headerlink" title="模板类vector"></a>模板类vector</h3><p>模板类vector类似于string类，也是一种动态数组。您可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。基本上，它是使用new创建动态数组的替代品。实际上，vector类确实使用new和delete来管理内存，但这种工作是自动完成的</p><p>这里不深入探讨模板类意味着什么，而只介绍一些基本的实用知识。首先，要使用vector对象，必须包含头文件vector。其次，vector包 含在名称空间std中，因此您可使用using编译指令、using声明或 std::vector。第三，模板使用不同的语法来指出它存储的数据类型。第 四，vector类使用不同的语法来指定元素数</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-title">vt</span><span class="hljs-params">(n_elem)</span></span>;</code></pre></div><p>其中参数n_elem可以是整型常量，也可以是整型变量。</p><h3 id="模板类array（C-11）"><a href="#模板类array（C-11）" class="headerlink" title="模板类array（C++11）"></a>模板类array（C++11）</h3><p>vector类的功能比数组强大，但付出的代价是效率稍低。如果您需要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便 和安全。有鉴于此，C++11新增了模板类array，它也位于名称空间std中。与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。要创建array对象，需要包含头文件array。array对象的创建语法与 vector稍有不同： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span>...<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;array&lt;<span class="hljs-type">int</span> 5&gt; ai;array&lt;<span class="hljs-type">double</span>,4&gt; ad = &#123;<span class="hljs-number">1.2</span>,<span class="hljs-number">2.1</span>,<span class="hljs-number">3.43</span>,<span class="hljs-number">4.3</span>&#125;</code></pre></div><p>推而广之，下面的声明创建一个名为arr的array对象，它包含n_elem个类型为typename的元素：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">array<span class="hljs-keyword">&lt;typename,n_elem&gt;</span></span> arr;</code></pre></div><p>与创建vector对象不同的是，n_elem不能是变量。在C++11中，可将列表初始化用于vector和array对象，但在C++98 中，不能对vector对象这样做。 </p><h3 id="比较数组、vector对象和array对象"><a href="#比较数组、vector对象和array对象" class="headerlink" title="比较数组、vector对象和array对象"></a>比较数组、vector对象和array对象</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// choices.cpp -- array variations</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>   <span class="hljs-comment">// STL C++98</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span>    <span class="hljs-comment">// C++0x</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// C, original C++</span>    <span class="hljs-type">double</span> a1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1.2</span>, <span class="hljs-number">2.4</span>, <span class="hljs-number">3.6</span>, <span class="hljs-number">4.8</span>&#125;;<span class="hljs-comment">// C++98 STL</span>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;   <span class="hljs-comment">// create vector with 4 elements</span><span class="hljs-comment">// no simple way to initialize in C98</span>    a2[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>/<span class="hljs-number">3.0</span>;    a2[<span class="hljs-number">1</span>] = <span class="hljs-number">1.0</span>/<span class="hljs-number">5.0</span>;    a2[<span class="hljs-number">2</span>] = <span class="hljs-number">1.0</span>/<span class="hljs-number">7.0</span>;    a2[<span class="hljs-number">3</span>] = <span class="hljs-number">1.0</span>/<span class="hljs-number">9.0</span>;<span class="hljs-comment">// C++0x -- create and initialize array object</span>    array&lt;<span class="hljs-type">double</span>, 4&gt; a3 = &#123;<span class="hljs-number">3.14</span>, <span class="hljs-number">2.72</span>, <span class="hljs-number">1.62</span>, <span class="hljs-number">1.41</span>&#125;;    array&lt;<span class="hljs-type">double</span>, 4&gt; a4;    a4 = a3;     <span class="hljs-comment">// valid for array objects of same size</span><span class="hljs-comment">// use array notation</span>    cout &lt;&lt; <span class="hljs-string">&quot;a1[2]: &quot;</span> &lt;&lt; a1[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;a1[<span class="hljs-number">2</span>] &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;a2[2]: &quot;</span> &lt;&lt; a2[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;a2[<span class="hljs-number">2</span>] &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;a3[2]: &quot;</span> &lt;&lt; a3[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;a3[<span class="hljs-number">2</span>] &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;a4[2]: &quot;</span> &lt;&lt; a4[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;a4[<span class="hljs-number">2</span>] &lt;&lt; endl;<span class="hljs-comment">// misdeed</span>    a1[<span class="hljs-number">-2</span>] = <span class="hljs-number">20.2</span>;    cout &lt;&lt; <span class="hljs-string">&quot;a1[-2]: &quot;</span> &lt;&lt; a1[<span class="hljs-number">-2</span>] &lt;&lt;<span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;a1[<span class="hljs-number">-2</span>] &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;a3[2]: &quot;</span> &lt;&lt; a3[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;a3[<span class="hljs-number">2</span>] &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;a4[2]: &quot;</span> &lt;&lt; a4[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;a4[<span class="hljs-number">2</span>] &lt;&lt; endl;    <span class="hljs-comment">//  cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//a1[2]: 3.6 at 0x16ae27710</span><span class="hljs-comment">//a2[2]: 0.142857 at 0x600001b35110</span><span class="hljs-comment">//a3[2]: 1.62 at 0x16ae276d0</span><span class="hljs-comment">//a4[2]: 1.62 at 0x16ae276b0</span><span class="hljs-comment">//a1[-2]: 20.2 at 0x16ae276f0</span><span class="hljs-comment">//a3[2]: 1.62 at 0x16ae276d0</span><span class="hljs-comment">//a4[2]: 1.62 at 0x16ae276b0</span></code></pre></div><p>首先，注意到无论是数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素。其次，从地址可知，array对象和数组存储在相同的内存区域（即栈）中，而vector对象存储在另一个区域（自由存储区或堆）中。第三，注意到可以将一个array对象赋给另一个array对象；而对于数组，必须逐元素复制数据。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">a1</span>[-<span class="hljs-number">2</span>] = <span class="hljs-number">20</span>.<span class="hljs-number">2</span>;//=&gt;*(a1-<span class="hljs-number">2</span>)</code></pre></div><p>其含义如下：找到a1指向的地方，向前移两个double元素，并将20.2存储到目的地。也就是说，将信息存储到数组的外面。与C语言一 样，C++也不检查这种超界错误</p><p>也可以这样做</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">a2</span>.at(<span class="hljs-number">1</span>) = <span class="hljs-number">2</span>.<span class="hljs-number">3</span>;</code></pre></div><p>中括号表示法和成员函数at()的差别在于，使用at()时，将在运行期间捕获非法索引，而程序默认将中断。这种额外检查的代价是运行时间 更长，这就是C++让允许您使用任何一种表示法的原因所在。另外，这些类还让您能够降低意外超界错误的概率。例如，它们包含成员函数begin()和end()，让您能够确定边界，以免无意间超界</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>数组、结构和指针是C++的3种复合类型。数组可以在一个数据对象中存储多个同种类型的值。通过使用索引或下标，可以访问数组中各 个元素。</p><p>结构可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符（.）来访问其中的成员。使用结构的第一步是创建结 构模板，它定义结构存储了哪些成员。模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量</p><p>共用体可以存储一个值，但是这个值可以是不同的类型，成员名指出了使用的模式。</p><p>指针是被设计用来存储地址的变量。我们说，指针指向它存储的地址。指针声明指出了指针指向的对象的类型。对指针应用解除引用运算 符，将得到指针指向的位置中的值。</p><p>字符串是以空字符为结尾的一系列字符。字符串可用引号括起的字符串常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在 char数组中，可以用被初始化为指向字符串的char指针表示字符串。函数strlen( )返回字符串的长度，其中不包括空字符。函数strcpy( )将字符串从一个位置复制到另一个位置。在使用这些函数时，应当包含头文件cstring或string.h。</p><p>头文件string支持的C++ string类提供了另一种对用户更友好的字符串处理方法。具体地说，string对象将根据要存储的字符串自动调整其 大小，用户可以使用赋值运算符来复制字符串。</p><p>new运算符允许在程序运行时为数据对象请求内存。该运算符返回获得内存的地址，可以将这个地址赋给一个指针，程序将只能使用该指 针来访问这块内存。如果数据对象是简单变量，则可以使用解除引用运算符（*）来获得其值；如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；如果数据对象是结构，则可以用指针解除引用运算符（-&gt;）来访问其成员。</p><p>指针和数组紧密相关。如果ar是数组名，则表达式ar[i]被解释为 *（ar + i），其中数组名被解释为数组第一个元素的地址。这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访 问new分配的数组中的元素。</p><p>运算符new和delete允许显式控制何时给数据对象分配内存，何时将内存归还给内存池。自动变量是在函数中声明的变量，而静态变量在 函数外部或者使用关键字static声明的变量，这两种变量都不太灵活。自动变量在程序执行到其所属的代码块（通常是函数定义）时产生，在离开该代码块时终止。静态变量在整个程序周期内都存在。</p><p>C++98新增的标准模板库（STL）提供了模板类vector，它是动态数组的替代品。C++11提供了模板类array，它是定长数组的替代品。</p><h1 id="循环和关系表达式"><a href="#循环和关系表达式" class="headerlink" title="循环和关系表达式"></a>循环和关系表达式</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// forloop.cpp -- introducing the for loop</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> i;  <span class="hljs-comment">// create a counter</span><span class="hljs-comment">//   initialize; test ; update</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)        cout &lt;&lt; <span class="hljs-string">&quot;C++ knows loops.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;C++ knows when to stop.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//C++ knows loops.</span><span class="hljs-comment">//C++ knows loops.</span><span class="hljs-comment">//C++ knows loops.</span><span class="hljs-comment">//C++ knows loops.</span><span class="hljs-comment">//C++ knows loops.</span><span class="hljs-comment">//C++ knows when to stop.</span></code></pre></div><h3 id="for循环的组成部分"><a href="#for循环的组成部分" class="headerlink" title="for循环的组成部分"></a>for循环的组成部分</h3><p>for循环的组成部分完成下面这些步骤。</p><p>1．设置初始值。 </p><p>2．执行测试，看看循环是否应当继续进行。 </p><p>3．执行循环操作。 </p><p>4．更新用于测试的值。</p><p>C++循环设计中包括了这些要素，很容易识别。初始化、测试和更新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表 达式，彼此由分号隔开。控制部分后面的语句叫作循环体，只要测试表 达式为true，它便被执行：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(initialization;test-expression;update-expression)</span></span>body</code></pre></div><p>C++语法将整个for看作一条语句—虽然循环体可以包含一条或多条语句。（包含多条语句时，需要使用复合语句或代码块，这将在本章后 面进行讨论。）</p><p>循环只执行一次初始化。通常，程序使用该表达式将变量设置为起始值，然后用该变量计算循环周期。</p><p>test-expression（测试表达式）决定循环体是否被执行。通常，这个表达式是关系表达式，即对两个值进行比较。这个例子将i的值同5进行比较，看i是否小于5。如果比较结果为真，则程序将执行循环体。实际上，C++并没有将test-expression的值限制为只能为真或假。可以使用任意表达式，C++将把结果强制转换为bool类型。因此，值为0的表达式将被转换为bool值false，导致循环结束。如果表达式的值为非零，则被强制转换为bool值true，循环将继续进行</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// num_test.cpp -- use numeric test in for loop</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;Enter the starting countdown value: &quot;</span>;    <span class="hljs-type">int</span> limit;    cin &gt;&gt; limit;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = limit; i; i--)     <span class="hljs-comment">// quits when i is 0</span>        cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Done now that i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter the starting countdown value: 4</span><span class="hljs-comment">//i = 4</span><span class="hljs-comment">//i = 3</span><span class="hljs-comment">//i = 2</span><span class="hljs-comment">//i = 1</span><span class="hljs-comment">//Done now that i = 0</span></code></pre></div><p>注意，循环在i变为0后结束</p><p>关系表达式（如i&lt;5）是如何得到循环终止值0的呢？在引入bool类型之前，如果关系表达式为true，则被判定为1；如果为false，则被判定为0。因此，表达式3&lt;5的值为1，而5&lt;5的值为0。然而，C++添加了bool类型后，关系表达式就判定为bool字面值true和false，而不是1和0了。这种变化不会导致不兼容的问题，因为C++程序在需要整数值的地方将把true和false分别转换为1和0，而在需要bool值的地方将把0转换为false，非0转换为true。 </p><p>for循环是入口条件（entry-condition）循环。这意味着在每轮循环之前，都将计算测试表达式的值，当测试表达式为false时，将不会执行循环体</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// express.cpp -- values of expressions</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> x;    cout &lt;&lt; <span class="hljs-string">&quot;The expression x = 100 has the value &quot;</span>;    cout &lt;&lt; (x = <span class="hljs-number">100</span>) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Now x = &quot;</span> &lt;&lt; x &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;The expression x &lt; 3 has the value &quot;</span>;    cout &lt;&lt; (x &lt; <span class="hljs-number">3</span>) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;The expression x &gt; 3 has the value &quot;</span>;    cout &lt;&lt; (x &gt; <span class="hljs-number">3</span>) &lt;&lt; endl;    cout.<span class="hljs-built_in">setf</span>(ios_base::boolalpha);   <span class="hljs-comment">//a newer C++ feature</span>    cout &lt;&lt; <span class="hljs-string">&quot;The expression x &lt; 3 has the value &quot;</span>;    cout &lt;&lt; (x &lt; <span class="hljs-number">3</span>) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;The expression x &gt; 3 has the value &quot;</span>;    cout &lt;&lt; (x &gt; <span class="hljs-number">3</span>) &lt;&lt; endl;    <span class="hljs-comment">/// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//the expression x = 100 has the value 100</span><span class="hljs-comment">//Now x = 100</span><span class="hljs-comment">//The expression x &lt; 3 has the value 0</span><span class="hljs-comment">//The expression x &gt; 3 has the value 1</span><span class="hljs-comment">//The expression x &lt; 3 has the value false</span><span class="hljs-comment">//The expression x &gt; 3 has the value true</span></code></pre></div><p>通常，cout在显示bool值之前将它们转换为int，但cout.setf（ios：：boolalpha）函数调用设置了一个标记，该标记命令cout显示true和false，而不是1和0。</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span></code></pre></div><p>从表达式到语句的转变很容易，只要加分号即可;</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;</span></code></pre></div><p>for结构的控制部分由3个表达式组成，它们由分号分隔。然而，C++循环允许像下面这样做：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span> ; i++)</span></span></code></pre></div><p>也就是说，可以在for循环的初始化部分中声明变量。这很方便，但并不适用于原来的句法，因为声明不是表达式。这种一度是非法的行为最初是通过定义一种新的表达式—声明语句表达式（declaration- statement expression）—来合法化的，声明语句表达式不带分号声明，只能出现在for语句中。然而，这种调整已经被取消了，代之以将for语句的句法修改成下面这样：</p><div class="code-wrapper"><pre><code class="hljs mel"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">for</span>-init-statement <span class="hljs-keyword">condition</span>;<span class="hljs-keyword">expression</span>)statement</code></pre></div><p>因为这里只有一个分号（而不是两个分号）。但是这是允许的，因为for-init-statement被视为一条语句，而语句有自己的分号。对于for-init-statement来说，它既可以是表达式语句，也可以是声明。这种句法规则用语句替换了后面跟分号的表达式，语句本身有自己的分号</p><p>在for-init-statement中声明变量还有其实用的一面，这也是应该知道的。这种变量只存在于for语句中，也就是说，当程序离开循环后，这种变量将消失： </p><div class="code-wrapper"><pre><code class="hljs abnf">for(int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;i&lt;5;i++)</span>cout&lt;&lt;<span class="hljs-string">&quot;c++ knows loop \n&quot;</span><span class="hljs-comment">;</span></code></pre></div><h3 id="回到for循环"><a href="#回到for循环" class="headerlink" title="回到for循环"></a>回到for循环</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// formore.cpp -- more looping with for</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">16</span>;      <span class="hljs-comment">// example of external declaration</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">long</span> <span class="hljs-type">long</span> factorials[ArSize];    factorials[<span class="hljs-number">1</span>] = factorials[<span class="hljs-number">0</span>] = <span class="hljs-number">1LL</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; ArSize; i++)        factorials[i] = i * factorials[i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ArSize; i++)        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;! = &quot;</span> &lt;&lt; factorials[i] &lt;&lt; std::endl;    <span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//0! = 1</span><span class="hljs-comment">//1! = 1</span><span class="hljs-comment">//2! = 2</span><span class="hljs-comment">//3! = 6</span><span class="hljs-comment">//4! = 24</span><span class="hljs-comment">//5! = 120</span><span class="hljs-comment">//6! = 720</span><span class="hljs-comment">//7! = 5040</span><span class="hljs-comment">//8! = 40320</span><span class="hljs-comment">//9! = 362880</span><span class="hljs-comment">//10! = 3628800</span><span class="hljs-comment">//11! = 39916800</span><span class="hljs-comment">//12! = 479001600</span><span class="hljs-comment">//13! = 6227020800</span><span class="hljs-comment">//14! = 87178291200</span><span class="hljs-comment">//15! = 1307674368000</span></code></pre></div><h3 id="修改步长"><a href="#修改步长" class="headerlink" title="修改步长"></a>修改步长</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// bigstep.cpp -- count as directed</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> std::cout;    <span class="hljs-comment">// a using declaration</span>    <span class="hljs-keyword">using</span> std::cin;    <span class="hljs-keyword">using</span> std::endl;;    cout &lt;&lt; <span class="hljs-string">&quot;Enter an integer: &quot;</span>;    <span class="hljs-type">int</span> by;    cin &gt;&gt; by;    cout &lt;&lt; <span class="hljs-string">&quot;Counting by &quot;</span> &lt;&lt; by &lt;&lt; <span class="hljs-string">&quot;s:\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i = i + by)        cout &lt;&lt; i &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter an integer: 17</span><span class="hljs-comment">//Counting by 17s:</span><span class="hljs-comment">//0</span><span class="hljs-comment">//17</span><span class="hljs-comment">//34</span><span class="hljs-comment">//51</span><span class="hljs-comment">//68</span><span class="hljs-comment">//85</span></code></pre></div><h3 id="使用for循环访问字符串"><a href="#使用for循环访问字符串" class="headerlink" title="使用for循环访问字符串"></a>使用for循环访问字符串</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// forstr1.cpp -- using for with a string</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a word: &quot;</span>;    string word;    cin &gt;&gt; word;    <span class="hljs-comment">// display letters in reverse order</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<span class="hljs-comment">//size可以获得字符串的个数</span>        cout &lt;&lt; word[i];    cout &lt;&lt; <span class="hljs-string">&quot;\nBye.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter a word: animal</span><span class="hljs-comment">//lamina</span><span class="hljs-comment">//Bye.</span></code></pre></div><p>如果所用的实现没有添加新的头文件，则必须使用string.h，而不是cstring。</p><h3 id="副作用和顺序点"><a href="#副作用和顺序点" class="headerlink" title="副作用和顺序点"></a>副作用和顺序点</h3><p>副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；顺序点 （sequence point）是程序执行过程中的一个点，在这里，进入下一步之 前将确保对所有的副作用都进行了评估。在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运 =算符和递减运算符执行的所有修改都必须完成。另外，任何完整的表达式末尾都是一个顺序点</p><p>何为完整表达式呢？它是这样一个表达式：不是另一个更大表达式的子表达式。完整表达式的例子有：表达式语句中的表达式部分以及用 作while循环中检测条件的表达式。</p><p>顺序点有助于阐明后缀递增何时进行</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(gust++&lt;<span class="hljs-number">10</span>)        cout&lt;&lt;gust&lt;&lt;endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">y</span>=(<span class="hljs-number">4</span>+x++)+(<span class="hljs-number">6</span>+x++)</code></pre></div><p>表达式4 + x++不是一个完整表达式，因此，C++不保证x的值在计算子表达式4 + x++后立刻增加1。在这个例子中，整条赋值语句是一个 完整表达式，而分号标示了顺序点，因此C++只保证程序执行到下一条语句之前，x的值将被递增两次。C++没有规定是在计算每个子表达式之后将x的值递增，还是在整个表达式计算完毕后才将x的值递增，有鉴于此，您应避免使用这样的表达式。</p><h3 id="前缀格式和后缀格式"><a href="#前缀格式和后缀格式" class="headerlink" title="前缀格式和后缀格式"></a>前缀格式和后缀格式</h3><div class="code-wrapper"><pre><code class="hljs excel">for(<span class="hljs-built_in">n</span>=<span class="hljs-number">1</span>im;<span class="hljs-built_in">n</span>&gt;<span class="hljs-number">0</span>;<span class="hljs-built_in">n</span>--)for(<span class="hljs-built_in">n</span>-lim;<span class="hljs-built_in">n</span>&gt;<span class="hljs-number">0</span>;--<span class="hljs-built_in">n</span>)在这里，这两种没有区别但是在这种情况下，用户这样定义前缀函数：将值加<span class="hljs-number">1</span>，然后返回结果；但 后缀版本首先复制一个副本，将其加<span class="hljs-number">1</span>，然后将复制的副本返回。因 此，对于类而言，前缀版本的效率比后缀版本高</code></pre></div><p>总之，对于内置类型，采用哪种格式不会有差别；但对于用户定义的类型，如果有用户定义的递增和递减运算符，则前缀格式的效率更 高</p><h3 id="递增-递减运算符和指针"><a href="#递增-递减运算符和指针" class="headerlink" title="递增**/**递减运算符和指针"></a>递增**/**递减运算符和指针</h3><p>可以将递增运算符用于指针和基本变量。本书前面介绍过，将递增运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节 数，这种规则适用于对指针递增和递减：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">21.1</span>,<span class="hljs-number">32.8</span>,<span class="hljs-number">23.4</span>,<span class="hljs-number">45.2</span>,<span class="hljs-number">37.4</span>&#125;;<span class="hljs-built_in">double</span> *pt = arr;++pt;</code></pre></div><p>也可以结合使用这些运算符和<em>运算符来修改指针指向的值。将</em>和++同时用于指针时提出了这样的问题：将什么解除引用，将什么递增。 这取决于运算符的位置和优先级。前缀递增、前缀递减和解除引用运算符的优先级相同，以从右到左的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合</p><p>前缀运算符的从右到到结合规则意味着*++pt的含义如下：现将++应用于pt（因为++位于*的右边），然后将*应用于被递增后的pt：</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">double x</span> = *++pt;</code></pre></div><p>另一方面，++*pt意味着先取得pt指向的值，然后将这个值加1：</p><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-literal">++</span><span class="hljs-comment">*pt;</span></code></pre></div><p>在这种情况下，pt仍然指向arr[2]。 </p><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">(*pt)</span><span class="hljs-literal">++</span><span class="hljs-comment">;</span></code></pre></div><p>圆括号指出，首先对指针解除引用，得到24.4。然后，运算符++将这个值递增到25.4，pt仍然指向arr[2]。</p><div class="code-wrapper"><pre><code class="hljs brainfuck"><span class="hljs-comment">*pt</span><span class="hljs-literal">++</span><span class="hljs-comment">;</span></code></pre></div><p>后缀运算符++的优先级更高，这意味着将运算符用于pt，而不是 <em>pt，因此对指针递增。然而后缀运算符意味着将对原来的地址 （&amp;arr[2]）而不是递增后的新地址解除引用，因此</em>pt++的值为arr[2]， 即25.4，但该语句执行完毕后，pt的值将为arr[3]的地址。</p><h3 id="组合赋值运算符"><a href="#组合赋值运算符" class="headerlink" title="组合赋值运算符"></a>组合赋值运算符</h3><table><thead><tr><th>操作符</th><th>作用L为左操作符，R为右操作符</th></tr></thead><tbody><tr><td>+=</td><td>L=L+R</td></tr><tr><td>-=</td><td>L=L-R</td></tr><tr><td>*=</td><td>L=L*R</td></tr><tr><td>/=</td><td>L=L/R</td></tr><tr><td>%=</td><td>L=L%R</td></tr></tbody></table><h3 id="复合语句（语句块）"><a href="#复合语句（语句块）" class="headerlink" title="复合语句（语句块）"></a>复合语句（语句块）</h3><p>在for循环体中有多条语句时，需要使用花括号</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// block.cpp -- use a block statement</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;The Amazing Accounto will sum and average &quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;five numbers for you.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Please enter five values:\n&quot;</span>;    <span class="hljs-type">double</span> number;    <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)    &#123;                                   <span class="hljs-comment">// block starts here</span>        cout &lt;&lt; <span class="hljs-string">&quot;Value &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<span class="hljs-comment">//如果没有花括号，只会执行第一条作为循环语句</span>        cin &gt;&gt; number;        sum += number;    &#125;                                   <span class="hljs-comment">// block ends here</span>    cout &lt;&lt; <span class="hljs-string">&quot;Five exquisite choices indeed! &quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;They sum to &quot;</span> &lt;&lt; sum &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;and average to &quot;</span> &lt;&lt; sum / <span class="hljs-number">5</span> &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;The Amazing Accounto bids you adieu!\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//The Amazing Accounto will sum and average five numbers for you.</span><span class="hljs-comment">//Please enter five values:</span><span class="hljs-comment">//Value 1: 1942</span><span class="hljs-comment">//Value 2: 1948</span><span class="hljs-comment">//Value 3: 1957</span><span class="hljs-comment">//Value 4: 1974</span><span class="hljs-comment">//Value 5: 1980</span><span class="hljs-comment">//Five exquisite choices indeed! They sum to 9801</span><span class="hljs-comment">//and average to 1960.2.</span><span class="hljs-comment">//The Amazing Accounto bids you adieu!</span></code></pre></div><p>复合语句还有一种有趣的特性。如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完该语 句块后，变量将被释放。这表明此变量仅在该语句块中才是可用的：</p><p>注意，在外部语句块中定义的变量在内部语句块中也是被定义了的。</p><p>如果在一个语句块中声明一个变量，而外部语句块中也有一个这种名称的变量，在块中内部变量会覆盖外部变量</p><h3 id="其他语法技巧—逗号运算符"><a href="#其他语法技巧—逗号运算符" class="headerlink" title="其他语法技巧—逗号运算符"></a>其他语法技巧<strong>—</strong>逗号运算符</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// forstr2.cpp -- reversing an array</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a word: &quot;</span>;    string word;    cin &gt;&gt; word;    <span class="hljs-comment">// physically modify string object</span>    <span class="hljs-type">char</span> temp;    <span class="hljs-type">int</span> i, j;    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, i = word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &lt; i; --i, ++j)    &#123;                       <span class="hljs-comment">// start block</span>        temp = word[i];        word[i] = word[j];        word[j] = temp;    &#125;                       <span class="hljs-comment">// end block</span>    cout &lt;&lt; word &lt;&lt; <span class="hljs-string">&quot;\nDone\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter a word: stressed</span><span class="hljs-comment">//desserts</span><span class="hljs-comment">//Done</span></code></pre></div><p>到目前为止，逗号运算符最常见的用途是将两个或更多的表达式放到一个for循环表达式中。不过C++还为这个运算符提供了另外两个特 性。首先，它确保先计算第一个表达式，然后计算第二个表达式（换句话说，逗号运算符是一个顺序点）。如下所示的表达式是安全的：</p><div class="code-wrapper"><pre><code class="hljs cpp">i = <span class="hljs-number">20</span>,j=i*<span class="hljs-number">20</span>;</code></pre></div><p>其次，C++规定，逗号表达式的值是第二部分的值。例如，上述表达式的值为40，因为j = 2 * i的值为40。</p><p>在所有运算符中，逗号运算符的优先级是最低的。例如，下面的语句：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">cats</span> = <span class="hljs-number">17</span>,<span class="hljs-number">240</span>;//被解释为（cats=<span class="hljs-number">17</span>），<span class="hljs-number">240</span></code></pre></div><p>也就是说，将cats设置为17，240不起作用。然而，由于括号的优先级最高，下面的表达式将把cats设置为240—逗号右侧的表达式值： </p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">cats</span> = (<span class="hljs-number">17</span>,<span class="hljs-number">240</span>)<span class="hljs-comment">;</span></code></pre></div><h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>!=</td><td>不等于</td></tr></tbody></table><p>关系运算符的优先级比算术运算符低</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>+<span class="hljs-number">3</span>&gt;y-<span class="hljs-number">2</span>//=&gt;(x+<span class="hljs-number">3</span>)&gt;(y-<span class="hljs-number">2</span>)</code></pre></div><h3 id="C-风格字符串的比较"><a href="#C-风格字符串的比较" class="headerlink" title="**C-**风格字符串的比较"></a>**C-**风格字符串的比较</h3><p>假设要知道字符数组中的字符串是不是mate。如果word是数组名，下面的测试可能并不能像我们预想的那样工作</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">word</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mate&quot;</span></code></pre></div><p>请记住，数组名是数组的地址。同样，用引号括起的字符串常量也是其地址。因此，上面的关系表达式不是判断两个字符串是否相同，而 是查看它们是否存储在相同的地址上。两个字符串的地址是否相同呢？ 答案是否定的，虽然它们包含相同的字符。</p><p>由于C++将C-风格字符串视为地址，因此如果使用关系运算符来比较它们，将无法得到满意的结果。相反，应使用C-风格字符串库中的 strcmp( )函数来比较。该函数接受两个字符串地址作为参数。这意味着参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，该 函数将返回零；如果第一个字符串按字母顺序排在第二个字符串之前，则strcmp( )将返回一个负数值；如果第一个字符串按字母顺序排在第二个字符串之后，则strcpm( )将返回一个正数值。实际上，“按系统排列顺序”比“按字母顺序”更准确。这意味着字符是根据字符的系统编码来进行比较的。例如，使用ASCII码时，所有大写字母的编码都比小写字母小，所以按排列顺序，大写字母将位于小写字母之前。因此，字符串“Zoo”在字符串“aviary”之前。根据编码进行比较还意味着大写字母和小写字母是不同的，因此字符串“FOO”和字符串“foo”不同。</p><p>在有些语言（如BASIC和标准Pascal）中，存储在不同长度的数组中的字符串彼此不相等。但是C-风格字符串是通过结尾的空值字符定义 的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存储在长度不同的数组中，也可能是相同的</p><p>顺便说一句，虽然不能用关系运算符来比较字符串，但却可以用它们来比较字符，因为字符实际上是整型</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">for</span>(ch = <span class="hljs-string">&#x27;a&#x27;</span>;ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>;ch++)cout &lt;&lt; <span class="hljs-string">ch;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// compstr1.cpp -- comparing strings using arrays</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>     <span class="hljs-comment">// prototype for strcmp()</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> word[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;?ate&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-built_in">strcmp</span>(word, <span class="hljs-string">&quot;mate&quot;</span>); ch++)    &#123;        cout &lt;&lt; word &lt;&lt; endl;        word[<span class="hljs-number">0</span>] = ch;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;After loop ends, word is &quot;</span> &lt;&lt; word &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//?ate</span><span class="hljs-comment">//aate</span><span class="hljs-comment">//bate</span><span class="hljs-comment">//cate</span><span class="hljs-comment">//date</span><span class="hljs-comment">//eate</span><span class="hljs-comment">//fate</span><span class="hljs-comment">//gate</span><span class="hljs-comment">//hate</span><span class="hljs-comment">//iate</span><span class="hljs-comment">//jate</span><span class="hljs-comment">//kate</span><span class="hljs-comment">//late</span><span class="hljs-comment">//After loop ends, word is mate</span></code></pre></div><p>可以对字符变量使用递增运算符和递减运算符，因为char类型实际上是整型，因此这种操作实际上将修改存储在变量中的整数编码。</p><h3 id="比较string类字符串"><a href="#比较string类字符串" class="headerlink" title="比较string类字符串"></a>比较string类字符串</h3><p>如果使用string类字符串而不是C-风格字符串，比较起来将简单些，因为类设计让您能够使用关系运算符进行比较。这之所以可行，是因为类函数重载（重新定义）了这些运算符</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// compstr2.cpp -- comparing strings using arrays</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>     <span class="hljs-comment">// string class</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    string word = <span class="hljs-string">&quot;?ate&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>; word != <span class="hljs-string">&quot;mate&quot;</span>; ch++)    &#123;        cout &lt;&lt; word &lt;&lt; endl;        word[<span class="hljs-number">0</span>] = ch;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;After loop ends, word is &quot;</span> &lt;&lt; word &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//?ate</span><span class="hljs-comment">//aate</span><span class="hljs-comment">//bate</span><span class="hljs-comment">//cate</span><span class="hljs-comment">//date</span><span class="hljs-comment">//eate</span><span class="hljs-comment">//fate</span><span class="hljs-comment">//gate</span><span class="hljs-comment">//hate</span><span class="hljs-comment">//iate</span><span class="hljs-comment">//jate</span><span class="hljs-comment">//kate</span><span class="hljs-comment">//late</span><span class="hljs-comment">//After loop ends, word is mate</span></code></pre></div><p>string类重载运算符!=的方式让您能够在下述条件下使用它：至少有 一个操作数为string对象，另一个操作数可以是string对象，也可以是C- 风格字符串。 </p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">word</span> != <span class="hljs-string">&quot;mate&quot;</span>;</code></pre></div><p>string类的设计让您能够将string对象作为一个实体（在关系型测试表达式中），也可以将其作为一个聚合对象，从而使用数组表示法来提取其中的字符。 </p><p>正如您看到的，使用C-风格字符串和string对象可获得相同的结果，但使用string对象更简单、更直观。 </p><p>最后，和前面大多数for循环不同，此循环不是计数循环。也就是说，它并不对语句块执行指定的次数。相反，此循环将根据情况（word 为“mate”）来确定是否停止。对于这种测试，C++程序通常使用while循环</p><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>while循环是没有初始化和更新部分的for循环，它只有测试条件和循环体：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(test-condition)</span></span>body</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// while.cpp -- introducing the while loop</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">20</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> name[ArSize];    cout &lt;&lt; <span class="hljs-string">&quot;Your first name, please: &quot;</span>;    cin &gt;&gt; name;    cout &lt;&lt; <span class="hljs-string">&quot;Here is your name, verticalized and ASCIIized:\n&quot;</span>;    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// start at beginning of string</span>    <span class="hljs-keyword">while</span> (name[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)     <span class="hljs-comment">// process to end of string 以逐字符遍历 字符串直到遇到空值字符的技术是C++处理C-风格字符串的标准方法。 由于字符串中包含了结尾标记，因此程序通常不需要知道字符串的长度</span>    &#123;        cout &lt;&lt; name[i] &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; <span class="hljs-built_in">int</span>(name[i]) &lt;&lt; endl;        i++;                    <span class="hljs-comment">// don&#x27;t forget this step</span>    &#125;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Here is your name, verticalized and ASCIIized:</span><span class="hljs-comment">//M: 77</span><span class="hljs-comment">//u: 117</span><span class="hljs-comment">//f: 102</span><span class="hljs-comment">//f: 102</span><span class="hljs-comment">//y: 121</span></code></pre></div><p><code>while (name[i] != &#39;\0&#39;)</code></p><p>它可以测试数组中特定的字符是不是空值字符。为使该测试最终能够成功，循环体必须修改i的值，这是通过在循环体结尾将i加1来实现 的。省略这一步将导致循环停留在同一个数组元素上，打印该字符及其 编码，直到强行终止该程序。导致死循环是循环最常见的问题之一。通 常，在循环体中忘记更新某个值时，便会出现这种情况</p><p>可以这样修改while行</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(name[i])</span></span></code></pre></div><p>经过这种修改后，程序的工作方式将不变。这是由于name[i]是常规 字符，其值为该字符的编码—非零值或true。然而，当name[i]为空值字符时，其编码将为0或false。这种表示法更为简洁（也更常用），但没有程序清单5.13中的表示法清晰。对于后一种情况，“笨拙”的编译器生成的代码的速度将更快，“聪明”的编译器对于这两个版本生成的代码将相同</p><p>要打印字符的ASCII码，必须通过强制类型转换将name[i]转换为整型。这样，cout将把值打印成整数，而不是将它解释为字符编码不同于C-风格字符串，string对象不使用空字符来标记字符串末 尾，因此要将上述程序转换为使用string类的版本，只需用string对 象替换char数组即可。第16章将讨论可用于标识string对象中最后一个字符的技术。 </p><h3 id="for与while"><a href="#for与while" class="headerlink" title="for与while"></a>for与while</h3><p>for循环格式允许将所有相关的信息—初始值、终止值和更新计数器的方法—放在同一个地方。在无法预先知道循环将执行的次数时，程序员常使用while循环</p><p>在设计循环时，请记住下面几条指导原则。 </p><ul><li>指定循环终止的条件。 </li><li>在首次测试之前初始化条件。 </li><li>在条件被再次测试之前更新条件。 </li></ul><p>for循环的一个优点是，其结构提供了一个可实现上述3条指导原则的地方，因此有助于程序员记住应该这样做。但这些指导原则也适用于while循环。</p><p>for和while当包含多个语句块的时候需要使用花括号，语句块是由花括号定义的，不是由缩进定义的。</p><h3 id="等待一段时间：编写延时循环"><a href="#等待一段时间：编写延时循环" class="headerlink" title="等待一段时间：编写延时循环"></a>等待一段时间：编写延时循环</h3><p>ANSI C和C++库中，clock( )，返回程序开始执行后所用的系统时间。这有两个复杂的问题：首先，clock( )返回时间的单位不一定是秒；其次，该函数的返回类型在某些系统上可能是long，在另一些系统上可能是unsigned long或其他类型。</p><p>但头文件ctime（较早的实现中为time.h）提供了这些问题的解决方案。首先，它定义了一个符号常量—CLOCKS_PER_SEC，该常量等于 每秒钟包含的系统时间单位数。因此，将系统时间除以这个值，可以得到秒数。或者将秒数乘以CLOCK_PER_SEC，可以得到以系统时间单位为单位的时间。其次，ctime将clock_t作为clock( )返回类型的别名（参见本章后面的注释“类型别名”），这意味着可以将变量声明为clock_t类型，编译器将把它转换为long、unsigned int或适合系统的其他类型。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// waiting.cpp -- using clock() in a time-delay loop</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span> <span class="hljs-comment">// describes clock() function, clock_t type</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;Enter the delay time, in seconds: &quot;</span>;    <span class="hljs-type">float</span> secs;    cin &gt;&gt; secs;    <span class="hljs-type">clock_t</span> delay = secs * CLOCKS_PER_SEC;  <span class="hljs-comment">// convert to clock ticks</span>    cout &lt;&lt; <span class="hljs-string">&quot;starting\a\n&quot;</span>;    <span class="hljs-type">clock_t</span> start = <span class="hljs-built_in">clock</span>();    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">clock</span>() - start &lt; delay )        <span class="hljs-comment">// wait until time elapses</span>        ;                                   <span class="hljs-comment">// note the semicolon</span>    cout &lt;&lt; <span class="hljs-string">&quot;done \a\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>该程序以系统时间单位为单位（而不是以秒为单位）计算延迟时间，避免了在每轮循环中将系统时间转换为秒。</p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>C++为类型建立别名的方式有两种。一种是使用预处理器： </p><div class="code-wrapper"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BYTE char <span class="hljs-comment">//preprocessor replace BYTE with char</span></span></code></pre></div><p>这样，预处理器将在编译程序时用char替换所有的BYTE，从而使BYTE成为char的别名。</p><p>第二种方法是使用C++（和C）的关键字typedef来创建别名。例如，要将byte作为char的别名，可以这样做： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> <span class="hljs-type">byte</span>;</code></pre></div><p>通用格式</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> typeName aliasName；</code></pre></div><p>换句话说，如果要将aliasName作为某种类型的别名，可以声明aliasName，如同将aliasName声明为这种类型的变量那样，然后在声明的前面加上关键字typedef。例如，要让byte_pointer成为char指针的别名，可将byte_pointer声明为char指针，然后在前面加上typedef：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> * byte_pointer</code></pre></div><p>也可以使用#define，不过声明一系列变量时，这种方法不适用。例如，请看下面的代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLOAT_POINTER float *FLOAT_PONITER pa,pb;</span></code></pre></div><p>预处理器置换将该声明转换为这样： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">float</span> * pa,pt;</code></pre></div><p>typedef方法不会有这样的问题。它能够处理更复杂的类型别名，这使得与使用#define相比，使用typedef是一种更佳的选择—有时候，这也是唯一的选择。 </p><p>注意，typedef不会创建新类型，而只是为已有的类型建立一个新名称。如果将word作为int的别名，则cout将把word类型的值视为int类型。</p><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> n;    cout &lt;&lt; <span class="hljs-string">&quot;Enter numbers in the range 1-10 to find &quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;my favorite number\n&quot;</span>;    <span class="hljs-keyword">do</span>    &#123;        cin &gt;&gt; n;       <span class="hljs-comment">// execute body</span>    &#125; <span class="hljs-keyword">while</span> (n != <span class="hljs-number">7</span>);   <span class="hljs-comment">// then test</span>    cout &lt;&lt; <span class="hljs-string">&quot;Yes, 7 is my favorite.\n&quot;</span> ;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="基于范围的for循环（C-11）"><a href="#基于范围的for循环（C-11）" class="headerlink" title="基于范围的for循环（C++11）"></a>基于范围的for循环（C++11）</h2><p>C++11新增了一种循环：基于范围（range-based）的for循环。这简 化了一种常见的循环任务：对数组（或容器类，如vector和array）的每 个元素执行相同的操作，如下例所示： </p><div class="code-wrapper"><pre><code class="hljs llvm"><span class="hljs-keyword">double</span> price[<span class="hljs-number">5</span>] <span class="hljs-operator">=</span> &#123;<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">1.4</span>&#125;for(<span class="hljs-keyword">double</span> <span class="hljs-keyword">x</span>:price)&#123;cout&lt;&lt;<span class="hljs-keyword">x</span>&lt;&lt;std::endl<span class="hljs-comment">;</span>&#125;</code></pre></div><p>其中，x最初表示数组prices的第一个元素。显示第一个元素后，不断执行循环，而x依次表示数组的其他元素。因此，上述代码显示全部5个元素，每个元素占据一行。总之，该循环显示数组中的每个值。</p><p>要修改数组的元素，需要使用不同的循环变量语法：</p><div class="code-wrapper"><pre><code class="hljs llvm">for(<span class="hljs-keyword">double</span> &amp;<span class="hljs-keyword">x</span> : price)&#123;<span class="hljs-keyword">x</span><span class="hljs-operator">=</span><span class="hljs-keyword">x</span>*<span class="hljs-number">0.8</span><span class="hljs-comment">;</span>&#125;</code></pre></div><p>符号&amp;表明x是一个引用变量，这个主题将在第8章讨论。就这里而言，这种声明让接下来的代码能够修改数组的内容，而第一种语法不 能。</p><h2 id="循环和文本输入"><a href="#循环和文本输入" class="headerlink" title="循环和文本输入"></a>循环和文本输入</h2><h3 id="使用原始的cin进行输入"><a href="#使用原始的cin进行输入" class="headerlink" title="使用原始的cin进行输入"></a>使用原始的<strong>cin</strong>进行输入</h3><p>如果程序要使用循环来读取来自键盘的文本输入，则必须有办法知道何时停止读取。如何知道这一点呢？一种方法是选择某个特殊字符— 有时被称为哨兵字符（sentinel character）,将其作为停止标记。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// textin1.cpp -- reading chars with a while loop</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> ch;    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;      <span class="hljs-comment">// use basic input</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter characters; enter # to quit:\n&quot;</span>;    cin &gt;&gt; ch;          <span class="hljs-comment">// get a character</span>    <span class="hljs-keyword">while</span> (ch != <span class="hljs-string">&#x27;#&#x27;</span>)   <span class="hljs-comment">// test the character</span>    &#123;        cout &lt;&lt; ch;     <span class="hljs-comment">// echo the character</span>        ++count;        <span class="hljs-comment">// count the character</span>        cin &gt;&gt; ch;      <span class="hljs-comment">// get the next character</span>    &#125;    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; characters read\n&quot;</span>;<span class="hljs-comment">// get rid of rest of line</span>    <span class="hljs-comment">// while (cin.get() != &#x27;\n&#x27;)</span>    <span class="hljs-comment">// ;</span><span class="hljs-comment">//cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>请注意该程序的结构。该程序在循环之前读取第一个输入字符，这样循环可以测试第一个字符。这很重要，因为第一个字符可能是#。由于textin1.cpp使用的是入口条件循环，因此在这种情况下，能够正确地跳过整个循环。由于前面已经将变量count设置为0，因此count的值也是正确的。</p><p>如果读取的第一个字符不是#，则程序进入该循环，显示字符，增加计数，然后读取下一个字符。最后一步是极为重要的，没有这一步， 循环将反复处理第一个输入字符，一直进行下去。有了这一步后，程序 就可以处理到下一个字符。</p><p>注意，该循环设计遵循了前面指出的几条指导原则。结束循环的条件是最后读取的一个字符是#。该条件是通过在循环之前读取一个字符 进行初始化的，而通过循环体结尾读取下一个字符进行更新。 </p><p>上面的做法合情合理。但为什么程序在输出时省略了空格呢？原因在cin。读取char值时，与读取其他基本类型一样，cin将忽略空格和换行符。因此输入中的空格没有被回显，也没有被包括在计数内。 </p><p>更为复杂的是，发送给cin的输入被缓冲。这意味着只有在用户按下回车键后，他输入的内容才会被发送给程序。这就是在运行该程序 时，可以在#后面输入字符的原因。按下回车键后，整个字符序列将被发送给程序，但程序在遇到#字符后将结束对输入的处理。 </p><h3 id="使用cin-get-char-进行补救"><a href="#使用cin-get-char-进行补救" class="headerlink" title="使用cin.get(char)进行补救"></a>使用cin.get(char)进行补救</h3><p>通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制表符和换行符。cin所属的istream类（在iostream中定义）中包含一个能够满足这种要求的成员函数。具体地说，成员函数cin.get(ch)读取输入中的下一个字符（即使它是空格），并将其赋给变量ch。使用这个函数调用替换cin&gt;&gt;ch，可以修补上述问题的问题</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> ch;    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Enter characters; enter # to quit:\n&quot;</span>;    cin.<span class="hljs-built_in">get</span>(ch);        <span class="hljs-comment">// use the cin.get(ch) function</span>    <span class="hljs-keyword">while</span> (ch != <span class="hljs-string">&#x27;#&#x27;</span>)    &#123;        cout &lt;&lt; ch;        ++count;        cin.<span class="hljs-built_in">get</span>(ch);    <span class="hljs-comment">// use it again</span>    &#125;    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; characters read\n&quot;</span>;<span class="hljs-comment">// get rid of rest of line</span>    <span class="hljs-comment">// while (cin.get() != &#x27;\n&#x27;)</span>    <span class="hljs-comment">//    ;</span>    <span class="hljs-comment">//cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><p>现在，该程序回显了每个字符，并将全部字符计算在内，其中包括 空格。输入仍被缓冲，因此输入的字符个数仍可能比最终到达程序的要多。</p><p>如果熟悉C语言，可能以为这个程序存在严重的错误！cin.get(ch)调用将一个值放在ch变量中，这意味着将修改该变量的值。在C语言中， 要修改变量的值，必须将变量的地址传递给函数。但程序清单5.17调用 cin.get( )时，传递的是ch，而不是&amp;ch。在C语言中，这样的代码无效，但在C++中有效，只要函数将参数声明为引用即可。引用是C++在C语言的基础上新增的一种类型。头文件iostream将cin.get(ch)的参数声明为引用类型，因此该函数可以修改其参数的值。我们将在第8章中详细介绍。同时，C语言行家可以松一口气了—通常，在C++中传递的参数的工作方式与在C语言中相同。然而，cin.get(ch)不是这样。</p><h3 id="使用哪一个cin-get"><a href="#使用哪一个cin-get" class="headerlink" title="使用哪一个cin.get( )"></a>使用哪一个cin.get( )</h3><div class="code-wrapper"><pre><code class="hljs routeros">char name[ArSize];<span class="hljs-built_in">..</span>.cout&lt;&lt; <span class="hljs-string">&quot;Enter your name:\n&quot;</span>;cin.<span class="hljs-built_in">get</span>(name,Arsize).<span class="hljs-built_in">get</span>()</code></pre></div><p>最后一行相当于两个连续的函数调用： </p><div class="code-wrapper"><pre><code class="hljs routeros">cin.<span class="hljs-built_in">get</span>(name,Arsize);cin.<span class="hljs-built_in">get</span>();</code></pre></div><p>cin.get( )的一个版本接受两个参数：数组名（字符串char<em>类型）的地址）和ArSize（int类型的整数）。（记住，数组名是其第一个元素 的地址，因此字符数组名的类型为char</em>。）接下来，程序使用了不接受任何参数的cin.get( )。而最近，我们这样使用过cin.get( )： </p><div class="code-wrapper"><pre><code class="hljs abnf">char ch<span class="hljs-comment">;</span>cin.get(ch)<span class="hljs-comment">;</span></code></pre></div><p>这里cin.get接受一个cha r参数在C语言中，如果函数接受char指针和int参数，则使用该函数时，不能只传递一个参数（类型不同）。但在C++中，可以这样做，因为该语言支持被称为函数重载的OOP特性。函数重载允许创建多个同名函数，条件是它们 的参数列表不同。例如，如果在C++中使用cin.get（name，ArSize）， 则编译器将找到使用char*和int作为参数的cin.get( )版本；如果使用 cin.get（ch），则编译器将使用接受一个char参数的版本；如果没有提供参数，则编译器将使用不接受任何参数的cin.get( )版本。函数重载允 许对多个相关的函数使用相同的名称，这些函数以不同方式或针对不同 类型执行相同的基本任务。第8章将讨论该主题。另外，通过使用 istream类中的get( )示例，读者将逐渐习惯函数重载。为区分不同的函数 版本，我们在引用它们时提供参数列表。因此，cin.get( )指的是不接受 任何参数的版本，而cin.get(char)则指的是接受一个参数的版本。</p><h3 id="文件尾条件"><a href="#文件尾条件" class="headerlink" title="文件尾条件"></a>文件尾条件</h3><p>很多操作系统（包括Unix、Linux和Windows命令提示符模式）都支持重定向，允许用文件替换键盘输入。例如，假设在Windows中有一个名为gofish.exe的可执行程序和一个名为fishtale的文本文件，则可以在命令提示符模式下输入下面的命令</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gofish</span> &lt; fishable</code></pre></div><p>这样，程序将从fishtale文件（而不是键盘）获取输入。&lt;符号是Unix和Windows命令提示符模式的重定向运算符。</p><p>其次，很多操作系统都允许通过键盘来模拟文件尾条件。在Unix中，可以在行首按下Ctrl+D来实现；在Windows命令提示符模式下，可 以在任意位置按Ctrl+Z和Enter。有些C++实现支持类似的行为，即使底层操作系统并不支持。键盘输入的EOF概念实际上是命令行环境遗留下来的。然而，用于Mac的Symantec C++模拟了UNIX，将Ctrl+D视为仿真的EOF。Metrowerks Codewarrior能够在Macintosh和Windows环境下识别Ctrl+Z。用于PC的Microsoft Visual C++、Borland C++ 5.5和GNU C++ 都 能够识别行首的Ctrl + Z，但用户必须随后按下回车键。总之，很多PC编程环境都将Ctrl+Z视为模拟的EOF，但具体细节（必须在行首还是可以在任何位置，是否必须按下回车键等）各不相同。</p><p>检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过成员函数eof( )来查看eofbit是否被设置；如果检测到EOF，则cin.eof( )将返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1，则fail( )成员函数返回true，否则返回false。注意，eof( )和fail( )方法报告 最近读取的结果；也就是说，它们在事后报告，而不是预先报告。因此 应将cin.eof( )或cin.fail( )测试放在读取后</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// textin3.cpp -- reading chars to end of file</span><span class="hljs-meta">#include &lt;iostream&gt;</span><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;    <span class="hljs-built_in">char</span> ch;    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;    cin.<span class="hljs-keyword">get</span>(ch);        <span class="hljs-comment">// attempt to read a char</span>    <span class="hljs-keyword">while</span> (cin.fail() == <span class="hljs-literal">false</span>)  <span class="hljs-comment">// test for EOF</span>    &#123;        cout &lt;&lt; ch;     <span class="hljs-comment">// echo character</span>        ++count;        cin.<span class="hljs-keyword">get</span>(ch);    <span class="hljs-comment">// attempt to read another char</span>    &#125;    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; characters read\n&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>前面指出过，cin方法检测到EOF时，将设置cin对象中一个指示 EOF条件的标记。设置这个标记后，cin将不读取输入，再次调用cin也 不管用。对于文件输入，这是有道理的，因为程序不应读取超出文件尾 的内容。然而，对于键盘输入，有可能使用模拟EOF来结束循环，但稍 后要读取其他输入。cin.clear( )方法可能清除EOF标记，使输入继续进 行。这将在第17章详细介绍。不过要记住的是，在有些系统中，按 Ctrl+Z实际上将结束输入和输出，而cin.clear( )将无法恢复输入和输出。</p><p>每次读取一个字符，直到遇到EOF的输入循环的基本设计如下：</p><div class="code-wrapper"><pre><code class="hljs sqf"><span class="hljs-keyword">while</span> (cin.fail() == <span class="hljs-literal">false</span>)  <span class="hljs-comment">// test for EOF</span>    &#123;        cout &lt;&lt; ch;     <span class="hljs-comment">// echo character</span>        ++<span class="hljs-built_in">count</span>;        cin.<span class="hljs-built_in">get</span>(ch);    <span class="hljs-comment">// attempt to read another char</span>    &#125;</code></pre></div><p>!运算符可以 将true切换为false或将false切换为true。可以使用此运算符将上述while测 试改写成这样：</p><div class="code-wrapper"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span> <span class="hljs-comment">(!cin.fail()</span>)</code></pre></div><p>方法cin.get(char)的返回值是一个cin对象。然而，istream类提供了一个可以将istream对象（如cin）转换为bool值的函数；当cin出现在需要bool值的地方（如在while循环的测试条件中）时，该转换函数将被调用。另外，如果最后一次读取成功了，则转换得到的bool值为true；否则为false。这意味着可以将上述while测试改写为这样：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(cin)</span></span></code></pre></div><p>这比! cin.fail( )或!cin.eof( )更通用，因为它可以检测到其他失败原因，如磁盘故障。 </p><p>最后，由于cin.get(char)的返回值为cin，因此可以将循环精简成这种格式：</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">while</span>(cin.<span class="hljs-built_in">get</span>(ch))&#123;<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.&#125;</code></pre></div><p>这样，cin.get(char)只被调用一次，而不是两次：循环前一次、循环结束后一次。为判断循环测试条件，程序必须首先调用cin.get(ch)。如果成功，则将值放入ch中。然后，程序获得函数调用的返回值，即cin。接下来，程序对cin进行bool转换，如果输入成功，则结果为true，否则为false。三条指导原则（确定结束条件、对条件进行初始化以及更新条件）全部被放在循环测试条件中。</p><h3 id="另一个cin-get-版本"><a href="#另一个cin-get-版本" class="headerlink" title="另一个cin.get( )版本"></a>另一个cin.get( )版本</h3><p>“怀旧”的C语言用户可能喜欢C语言中的字符I/O函数—getchar( )和putchar( )，它们仍然适用，只要像在C语言中那样包含头文件 stdio.h（或新的cstdio）即可。也可以使用istream和ostream类中类似功能 的成员函数，来看看这种方式。</p><p>不接受任何参数的cin.get( )成员函数返回输入中的下一个字符。也就是说，可以这样使用它：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">ch</span><span class="hljs-operator">=</span>cin.get()<span class="hljs-comment">;</span></code></pre></div><p>该函数的工作方式与C语言中的getchar( )相似，将字符编码作为int值返回；而cin.get(ch)返回一个对象，而不是读取的字符。同样，可以 使用cout.put( )函数（参见第3章）来显示字符： </p><div class="code-wrapper"><pre><code class="hljs abnf">cout.put(ch)<span class="hljs-comment">;</span></code></pre></div><p>该函数的工作方式类似C语言中的putchar( )，只不过其参数类型为char，而不是int。</p><p>最初，put( )成员只有一个原型—put(char)。可以传递一个int参数给它，该参数将被强制转换为char。C++标准还要求只有一个原型。然而，有些C++实现都提供了3个原型：put(char)、put(signed char)和put(unsigned char)。在这些实现中，给put( )传递一个int参数将导致错误消息，因为转换int的方式不止一种。使用显式强制类型转换的原型（如cin.put(char(ch))）可使用int参数</p><p>为成功地使用cin.get( )，需要知道其如何处理EOF条件。当该函数到达EOF时，将没有可返回的字符。相反，cin.get( )将返回一个用符号 常量EOF表示的特殊值。该常量是在头文件iostream中定义的。EOF值必须不同于任何有效的字符值，以便程序不会将EOF与常规字符混淆。通常，EOF被定义为值−1，因为没有ASCII码为−1的字符，但并不需要知道实际的值，而只需在程序中使用EOF即可。例如，程序清单5.18的核心是这样： </p><div class="code-wrapper"><pre><code class="hljs routeros">char ch;cin.<span class="hljs-built_in">get</span>(ch);<span class="hljs-keyword">while</span>(cin.fail()==<span class="hljs-literal">false</span>)&#123;cout&lt;&lt;ch;++cout;cin.<span class="hljs-built_in">get</span>(ch)&#125;</code></pre></div><p>可以使用int ch，并用cin.get( )代替cin.get(char)，用cout.put( )代替cout，用EOF测试代替cin.fail( )测试：</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> <span class="hljs-number">ch</span><span class="hljs-comment">;</span><span class="hljs-number">ch</span>=cin<span class="hljs-number">.</span>get()<span class="hljs-comment">;</span>while(<span class="hljs-number">ch</span>!=EOF)&#123;cout<span class="hljs-number">.</span>put(<span class="hljs-number">ch</span>)++cout<span class="hljs-comment">;</span><span class="hljs-number">ch</span>=cin<span class="hljs-number">.</span>get()<span class="hljs-comment">;</span>&#125;</code></pre></div><p>如果ch是一个字符，则循环将显示它。如果ch为EOF，则循环将结束。</p><p>除了当前所做的修改外，关于使用cin.get( )还有一个微妙而重要的问题。由于EOF表示的不是有效字符编码，因此可能不与char类型兼 容。例如，在有些系统中，char类型是没有符号的，因此char变量不可能为EOF值（−1）。由于这种原因，如果使用cin.get( )（没有参数）并测试EOF，则必须将返回值赋给int变量，而不是char变量。另外，如果 将ch的类型声明为int，而不是char，则必须在显示ch时将其强制转换为char类型。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// textin4.cpp -- reading chars with cin.get()</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> ch;                         <span class="hljs-comment">// should be int, not char</span>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> ((ch = cin.<span class="hljs-built_in">get</span>()) != EOF) <span class="hljs-comment">// test for end-of-file</span>    &#123;        cout.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">char</span>(ch));        ++count;    &#125;    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; characters read\n&quot;</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><p><strong>cin.get(char)和cin.get( )之间的差别。</strong> </p><table><thead><tr><th>属性</th><th>Cin.get(ch)</th><th>ch=cin.get()</th></tr></thead><tbody><tr><td>传递输入字符的方式</td><td>赋给参数ch</td><td>将函数返回值赋给 ch</td></tr><tr><td>用于字符输入时函数的返 回值</td><td>istream对象（执行bool转换后为 true）</td><td>int类型的字符编码</td></tr><tr><td>到达EOF时函数的返回值</td><td>istream对象（执行bool转换后为 false）</td><td>EOF</td></tr></tbody></table><p>那么应使用cin.get( )还是cin.get(char)呢？使用字符参数的版本更符合对象方式，因为其返回值是istream对象。这意味着可以将它们拼接起来。例如，下面的代码将输入中的下一个字符读入到ch1中，并将接下来的一个字符读入到ch2中： </p><div class="code-wrapper"><pre><code class="hljs routeros">cin.<span class="hljs-built_in">get</span>(ch1).<span class="hljs-built_in">get</span>(ch2);</code></pre></div><p>这是可行的，因为函数调用cin.get(ch1)返回一个cin对象，然后便可以通过该对象调用get(ch2)。</p><p>get( )的主要用途是能够将stdio.h的getchar( )和putchar( )函数转换为iostream的cin.get( )和cout.put( )方法。只要用头文件iostream替换stdio.h，并用作用相似的方法替换所有的getchar( )和putchar( )即可（如果旧的代码使用int变量进行输入，而所用的实现包含put( )的多个原型，则必须做进一步的调整。） </p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>C++提供了3种循环：for循环、while循环和do while循环。如果循环 测试条件为true或非零，则循环将重复执行一组指令；如果测试条件为 false或0，则结束循环。for循环和while循环都是入口条件循环，这意味 着程序将在执行循环体中的语句之前检查测试条件。do while循环是出 口条件循环，这意味着其将在执行循环体中的语句之后检查条件。</p><p>每种循环的句法都要求循环体由一条语句组成。然而，这条语句可以是复合语句，也可以是语句块（由花括号括起的多条语句）。关系表达式对两个值进行比较，常被用作循环测试条件。关系表达式是通过使用6种关系运算符之一构成的：&lt;、&lt;=、= =、&gt;=、&gt;或! =。 关系表达式的结果为bool类型，值为true或false。</p><p>许多程序都逐字节地读取文本输入或文本文件，istream类提供了多种可完成这种工作的方法。如果ch是一个char变量，则下面的语句将输 入中的下一个字符读入到ch中：</p><div class="code-wrapper"><pre><code class="hljs abnf">cin&gt;&gt;ch<span class="hljs-comment">;</span></code></pre></div><p>然而，它将忽略空格、换行符和制表符。下面的成员函数调用读取 输入中的下一个字符（而不管该字符是什么）并将其存储到ch中：</p><div class="code-wrapper"><pre><code class="hljs routeros">cin.<span class="hljs-built_in">get</span>(ch);</code></pre></div><p>成员函数调用cin.get( )返回下一个输入字符—包括空格、换行符和制表符，因此，可以这样使用它：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">ch</span><span class="hljs-operator">=</span>cin.get()<span class="hljs-comment">;</span></code></pre></div><p>cin.get（char）成员函数调用通过返回转换为false的bool值来指出已到达EOF，而cin.get( )成员函数调用则通过返回EOF值来指出已到达 EOF，EOF是在文件iostream中定义的</p><h1 id="分支语句和逻辑运算符"><a href="#分支语句和逻辑运算符" class="headerlink" title="分支语句和逻辑运算符"></a>分支语句和逻辑运算符</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(test-condition)</span></span>statement</code></pre></div><h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h3><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(test-condition)</span></span>statement1<span class="hljs-keyword">else</span>statement2</code></pre></div><h3 id="格式化if-else语句"><a href="#格式化if-else语句" class="headerlink" title="格式化if else语句"></a>格式化if else语句</h3><p>if else中的两种操作都必须是一条语句。如果需要多条语句，需要用大括号将它们括起来，组成一个块语句。和有些语言（如BASIC和 FORTRAN）不同的是，由于C++不会自动将if和else之间的所有代码视为一个代码块，因此必须使用大括号将这些语句组合成一个语句块。</p><h3 id="if-else-if-else结构"><a href="#if-else-if-else结构" class="headerlink" title="if else if else结构"></a>if else if else结构</h3><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">if</span>()</span>...<span class="hljs-keyword">else</span><span class="hljs-function"><span class="hljs-title">if</span>()</span>...<span class="hljs-keyword">else</span></code></pre></div><p>也可以写成</p><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">if</span>()</span>...<span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-title">if</span>()</span>...<span class="hljs-keyword">else</span>../.</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// ifelseif.cpp -- using if else if else</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> Fave = <span class="hljs-number">27</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> n;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a number in the range 1-100 to find &quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;my favorite number: &quot;</span>;    <span class="hljs-keyword">do</span>    &#123;        cin &gt;&gt; n;        <span class="hljs-keyword">if</span> (n &lt; Fave)            cout &lt;&lt; <span class="hljs-string">&quot;Too low -- guess again: &quot;</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; Fave)            cout &lt;&lt; <span class="hljs-string">&quot;Too high -- guess again: &quot;</span>;        <span class="hljs-keyword">else</span>            cout &lt;&lt; Fave &lt;&lt; <span class="hljs-string">&quot; is right!\n&quot;</span>;    &#125; <span class="hljs-keyword">while</span> (n != Fave);    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter a number in the range 1-100 to find my favorite number: 50</span><span class="hljs-comment">//Too high -- guess again: 25</span><span class="hljs-comment">//Too low -- guess again: 37</span><span class="hljs-comment">//Too high -- guess again: 31</span><span class="hljs-comment">//Too high -- guess again: 28</span><span class="hljs-comment">//Too high -- guess again: 27</span><span class="hljs-comment">//27 is right!</span></code></pre></div><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><h3 id="逻辑OR运算符："><a href="#逻辑OR运算符：" class="headerlink" title="逻辑OR运算符：||"></a>逻辑OR运算符：||</h3><p>C++可以采用逻辑OR运算符（||），将两个表达式组合在一起。如果原来表达式中的任何一个或全部都为true（或非零），则得到的表达式的值为true；否则，表达式的值为false。</p><p>C++规定，||运算符是个顺序点（sequence point）。也是说，先修改左侧的值，再对右侧的值进行判定（C++11的说法是，运算符左边的子表达式先于右边的子表达式）。例如，请看下面的表达式： </p><div class="code-wrapper"><pre><code class="hljs routeros">i++ &amp;lt; 6||<span class="hljs-attribute">i</span>== j</code></pre></div><p>假设i原来的值为10，则在对i和j进行比较时，i的值将为11。另外，如果左侧的表达式为true，则C++将不会去判定右侧的表达式，因为只 要一个表达式为true，则整个逻辑表达式为true（读者可能还记得，冒号和逗号运算符也是顺序点）。 </p><h3 id="逻辑AND运算符：-amp-amp"><a href="#逻辑AND运算符：-amp-amp" class="headerlink" title="逻辑AND运算符：&amp;&amp;"></a>逻辑AND运算符：&amp;&amp;</h3><p>逻辑AND运算符（&amp;&amp;），也是将两个表达式组合成一个表达式。仅当原来的两个表达式都为true时，得到的表达式的值才为true</p><p>&amp;&amp;运算符也是顺序点，因此将首先判定左侧， 并且在右侧被判定之前产生所有的副作用。如果左侧为false，则整个逻辑表达式必定为false，在这种情况下，C++将不会再对右侧进行判定</p><h3 id="用-amp-amp-来设置取值范围"><a href="#用-amp-amp-来设置取值范围" class="headerlink" title="用&amp;&amp;来设置取值范围"></a>用&amp;&amp;来设置取值范围</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// more_and.cpp -- using the logical AND operator</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">char</span> * qualify[<span class="hljs-number">4</span>] =       <span class="hljs-comment">// an array of pointers*/</span>&#123;                               <span class="hljs-comment">// to strings</span>    <span class="hljs-string">&quot;10,000-meter race.\n&quot;</span>,    <span class="hljs-string">&quot;mud tug-of-war.\n&quot;</span>,    <span class="hljs-string">&quot;masters canoe jousting.\n&quot;</span>,    <span class="hljs-string">&quot;pie-throwing festival.\n&quot;</span>&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> age;    cout &lt;&lt; <span class="hljs-string">&quot;Enter your age in years: &quot;</span>;    cin &gt;&gt; age;    <span class="hljs-type">int</span> index;    <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">17</span> &amp;&amp; age &lt; <span class="hljs-number">35</span>)        index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">35</span> &amp;&amp; age &lt; <span class="hljs-number">50</span>)        index = <span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">50</span> &amp;&amp; age &lt; <span class="hljs-number">65</span>)        index = <span class="hljs-number">2</span>;    <span class="hljs-keyword">else</span>        index = <span class="hljs-number">3</span>;    cout &lt;&lt; <span class="hljs-string">&quot;You qualify for the &quot;</span> &lt;&lt; qualify[index];     <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="逻辑NOT运算符："><a href="#逻辑NOT运算符：" class="headerlink" title="逻辑NOT运算符：!"></a>逻辑NOT运算符：!</h3><p>!运算符将它后面的表达式的真值取反。也是说，如果expression为true，则!expression是false；如果expression为false，则!expression是true。更准确地说，如果expression为true或非零，则!expression为false。</p><p>通常，不使用这个运算符可以更清楚地表示关系：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(!(x&gt;<span class="hljs-number">5</span>)</span></span>)<span class="hljs-comment">//if(x&lt;=5)</span></code></pre></div><p>然而，!运算符对于返回true-false值或可以被解释为true-false值的函数来说很有用。例如，如果C-风格字符串s1和s2不同，则strcmp(s1, s2)将返回非零（true）值，否则返回0。这意味着如果这两个字符串相同，则!strcmp(s1, s2)为true。 </p><p>程序清单6.7使用这种技术（将!运算符用于函数返回值）来筛选可赋给int变量的数字输入。如果用户定义的函数is_int( )（稍后将详细介 绍）的参数位于int类型的取值范围内，则它将返回true。然后，程序使用while(!is-int(num))测试来拒绝不在该取值范围内的值。 </p><p>程序清单<strong>6.7 not.cpp</strong></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// not.cpp -- using the not operator</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_int</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> num;    cout &lt;&lt; <span class="hljs-string">&quot;Yo, dude! Enter an integer value: &quot;</span>;    cin &gt;&gt; num;    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">is_int</span>(num))    <span class="hljs-comment">// continue while num is not int-able</span>    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Out of range -- please try again: &quot;</span>;        cin &gt;&gt; num;    &#125;    <span class="hljs-type">int</span> val = <span class="hljs-built_in">int</span> (num);    <span class="hljs-comment">// type cast</span>    cout &lt;&lt; <span class="hljs-string">&quot;You&#x27;ve entered the integer &quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;\nBye\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_int</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (x &lt;= INT_MAX &amp;&amp; x &gt;= INT_MIN)   <span class="hljs-comment">// use climits values</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><p>如果给读取int值的程序输入一个过大的值，很多C++实现只是将这个值 截短为合适的大小，并不会通知丢失了数据。程序清单6.7中的程序避免了这样的问题，它首先将可能的int值作为double值来读取。double类型的精度足以存储典型的int值，且取值范围更大。另一种选择是，使用long long来存储输入的值，因为其取值范围比int大。布尔函数is_int( )使用了climits文件（第3章讨论过）中定义的两个 符号常量（INT_MAX和INT_MIN）来确定其参数是否位于适当的范围 内。如果是，该函数将返回true，否则返回false。 main( )程序使用while循环来拒绝无效输入，直到用户输入有效的值为止。可以在输入超出取值范围时显示int的界限，这样程序将更为友好。确认输入有效后，程序将其赋给一个int变量。 </p><h3 id="逻辑运算符细节"><a href="#逻辑运算符细节" class="headerlink" title="逻辑运算符细节"></a>逻辑运算符细节</h3><p>C++逻辑OR和逻辑AND运算符的优先级都低于关系运算符</p><p>!运算符的优先级高于所有的关系运算符和算术运算 符</p><p>逻辑AND运算符的优先级高于逻辑OR运算符</p><p>虽然C++运算符的优先级规则常可能不使用括号便可以编写复合比较的语句，但最简单的方法还是用括号将测试进行分组，而不管是否需 要括号。这样代码容易阅读，避免读者查看不常使用的优先级规则，并 减少由于没有准确记住所使用的规则而出错的可能性。</p><h3 id="其他表示方式"><a href="#其他表示方式" class="headerlink" title="其他表示方式"></a>其他表示方式</h3><p>并不是所有的键盘都提供了用作逻辑运算符的符号，因此C++标准提供了另一种表示方式</p><p>如表6.3所示。标识符and、or和not都是C++保留字，这意味着不能将它们用作变量名等。它们不是关键字，因为它们都是已有语言特性的另一种表示方式。另外，它们并不是C语言中的保留字，但C语言程序可以将它们用作运算符，只要在程序中包含了头文件iso646.h。C++不要求使用头文件。</p><table><thead><tr><th>运算符</th><th>另一种表达式</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>and</td></tr><tr><td>||</td><td>or</td></tr><tr><td>!</td><td>Not</td></tr></tbody></table><h2 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a>字符函数库cctype</h2><p>C++从C语言继承了一个与字符相关的、非常方便的函数软件包， 可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这些函数的原型是在头文件cctype（老式的风格中为ctype.h）中定义的。例如，如果ch是一个字母，则isalpha（ch）函数返回一个非零值，否则返回0。同样，如果ch是标点符号（如逗号或句号），函数ispunct（ch）将返回true。（这些函数的返回类型为int，而不是bool， 但通常bool转换让您能够将它们视为bool类型。） </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// cctypes.cpp -- using the ctype.h library</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span>              <span class="hljs-comment">// prototypes for character functions</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;Enter text for analysis, and type @&quot;</span>            <span class="hljs-string">&quot; to terminate input.\n&quot;</span>;    <span class="hljs-type">char</span> ch;      <span class="hljs-type">int</span> whitespace = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> digits = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> chars = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> punct = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> others = <span class="hljs-number">0</span>;    cin.<span class="hljs-built_in">get</span>(ch);                <span class="hljs-comment">// get first character</span>    <span class="hljs-keyword">while</span> (ch != <span class="hljs-string">&#x27;@&#x27;</span>)            <span class="hljs-comment">// test for sentinel</span>    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalpha</span>(ch))         <span class="hljs-comment">// is it an alphabetic character?</span>            chars++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isspace</span>(ch))    <span class="hljs-comment">// is it a whitespace character?</span>            whitespace++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(ch))    <span class="hljs-comment">// is it a digit?</span>            digits++;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ispunct</span>(ch))    <span class="hljs-comment">// is it punctuation?</span>            punct++;        <span class="hljs-keyword">else</span>            others++;        cin.<span class="hljs-built_in">get</span>(ch);            <span class="hljs-comment">// get next character</span>    &#125;    cout &lt;&lt; chars &lt;&lt; <span class="hljs-string">&quot; letters, &quot;</span>         &lt;&lt; whitespace &lt;&lt; <span class="hljs-string">&quot; whitespace, &quot;</span>         &lt;&lt; digits &lt;&lt; <span class="hljs-string">&quot; digits, &quot;</span>         &lt;&lt; punct &lt;&lt; <span class="hljs-string">&quot; punctuations, &quot;</span>         &lt;&lt; others &lt;&lt; <span class="hljs-string">&quot; others.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div><p><strong>cctype</strong>中的字符函数</p><table><thead><tr><th>函数名称</th><th>返回值</th></tr></thead><tbody><tr><td>isalnum()</td><td>如果参数是字母数字，即字母或数字，该函数返回true</td></tr><tr><td>isalpha()</td><td>如果参数是字母，该函数返回true</td></tr><tr><td>iscntrl()</td><td>如果参数是控制字符，该函数返回true</td></tr><tr><td>isdigit()</td><td>如果参数是数字（0～9），该函数返回true</td></tr><tr><td>isgraph()</td><td>如果参数是除空格之外的打印字符，该函数返回true</td></tr><tr><td>islower()</td><td>如果参数是小写字母，该函数返回true</td></tr><tr><td>isprint()</td><td>如果参数是打印字符（包括空格），该函数返回true</td></tr><tr><td>ispunct()</td><td>如果参数是标点符号，该函数返回true</td></tr><tr><td>isspace()</td><td>如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符或 者垂直制表符，该函数返回true</td></tr><tr><td>isupper()</td><td>如果参数是大写字母，该函数返回true</td></tr><tr><td>isxdigit()</td><td>如果参数是十六进制数字，即0～9、a～f或A～F，该函数返回true</td></tr><tr><td>tolower()</td><td>如果参数是大写字符，则返回其小写，否则返回该参数</td></tr><tr><td>toupper()</td><td>如果参数是小写字符，则返回其大写，否则返回该参数</td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="?:运算符"></a>?:运算符</h2><p>C++有一个常被用来代替if else语句的运算符，这个运算符被称为条件运算符（?:），它是C++中唯一一个需要3个操作数的运算符。该运 算符的通用格式如下</p><div class="code-wrapper"><pre><code class="hljs gcode">expressio<span class="hljs-symbol">n1</span>?expressio<span class="hljs-symbol">n2</span>:expressio<span class="hljs-symbol">n3</span>;</code></pre></div><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>有些硬件/操作系统组合不会将转义序列\a解释为振铃。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// switch.cpp -- using the switch statement</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showmenu</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// function prototypes</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">report</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">comfort</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">showmenu</span>();    <span class="hljs-type">int</span> choice;    cin &gt;&gt; choice;    <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">5</span>)    &#123;        <span class="hljs-keyword">switch</span>(choice)        &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>  :   cout &lt;&lt; <span class="hljs-string">&quot;\a\n&quot;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>  :   <span class="hljs-built_in">report</span>();                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>  :   cout &lt;&lt; <span class="hljs-string">&quot;The boss was in all day.\n&quot;</span>;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>  :   <span class="hljs-built_in">comfort</span>();                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span> :   cout &lt;&lt; <span class="hljs-string">&quot;That&#x27;s not a choice.\n&quot;</span>;        &#125;        <span class="hljs-built_in">showmenu</span>();        cin &gt;&gt; choice;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Bye!\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showmenu</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;Please enter 1, 2, 3, 4, or 5:\n&quot;</span>            <span class="hljs-string">&quot;1) alarm           2) report\n&quot;</span>            <span class="hljs-string">&quot;3) alibi           4) comfort\n&quot;</span>            <span class="hljs-string">&quot;5) quit\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">report</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;It&#x27;s been an excellent week for business.\n&quot;</span>            <span class="hljs-string">&quot;Sales are up 120%. Expenses are down 35%.\n&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">comfort</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;Your employees think you are the finest CEO\n&quot;</span>            <span class="hljs-string">&quot;in the industry. The board of directors think\n&quot;</span>            <span class="hljs-string">&quot;you are the finest CEO in the industry.\n&quot;</span>;&#125;</code></pre></div><h3 id="将枚举量用作标签"><a href="#将枚举量用作标签" class="headerlink" title="将枚举量用作标签"></a>将枚举量用作标签</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// enum.cpp -- using enum</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// create named constants for 0 - 6</span><span class="hljs-keyword">enum</span> &#123;red, orange, yellow, green, blue, violet, indigo&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;Enter color code (0-6): &quot;</span>;    <span class="hljs-type">int</span> code;    cin &gt;&gt; code;    <span class="hljs-keyword">while</span> (code &gt;= red &amp;&amp; code &lt;= indigo)    &#123;        <span class="hljs-keyword">switch</span> (code)        &#123;            <span class="hljs-keyword">case</span> red     : cout &lt;&lt; <span class="hljs-string">&quot;Her lips were red.\n&quot;</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> orange  : cout &lt;&lt; <span class="hljs-string">&quot;Her hair was orange.\n&quot;</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> yellow  : cout &lt;&lt; <span class="hljs-string">&quot;Her shoes were yellow.\n&quot;</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> green   : cout &lt;&lt; <span class="hljs-string">&quot;Her nails were green.\n&quot;</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> blue    : cout &lt;&lt; <span class="hljs-string">&quot;Her sweatsuit was blue.\n&quot;</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> violet  : cout &lt;&lt; <span class="hljs-string">&quot;Her eyes were violet.\n&quot;</span>; <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> indigo  : cout &lt;&lt; <span class="hljs-string">&quot;Her mood was indigo.\n&quot;</span>; <span class="hljs-keyword">break</span>;        &#125;        cout &lt;&lt; <span class="hljs-string">&quot;Enter color code (0-6): &quot;</span>;        cin &gt;&gt; code;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Bye\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>程序清单6.11使用enum定义了一组相关的常量，然后在switch语句中使用这些常量。通常，cin无法识别枚举类型（它不知道程序员是如 何定义它们的），因此该程序要求用户选择选项时输入一个整数。当switch语句将int值和枚举量标签进行比较时，将枚举量提升为int。另外，在while循环测试条件中，也会将枚举量提升为int类型。</p><h3 id="switch和if-else"><a href="#switch和if-else" class="headerlink" title="switch和if else"></a>switch和if else</h3><p>switch语句中的每一个case标签都必须是一个单独的值。另外，这个值必须是整数（包括char），因此switch无法处理浮点测试。另外case标签值还必须是常量。如果选项涉及取值范围、浮点测试或两个变量的比较，则应使用if else语句。</p><p>然而，如果所有的选项都可以使用整数常量来标识，则可以使用switch语句或if else语句。由于switch语句是专门为这种情况设计的，因 此，如果选项超过两个，则就代码长度和执行速度而言，switch语句的效率更高</p><h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><p>break和continue语句都使程序能够跳过部分代码。可以在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处 执行。continue语句用于循环中，让程序跳过循环体中余下的代码，并 开始新一轮循环</p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-26%2012.08.38.png" style="zoom:50%;" /><p>程序清单6.12演示了这两条语句是如何工作的。该程序让用户输入一行文本。循环将回显每个字符，如果该字符为句点，则使用break结 束循环。这表明，可以在某种条件为true时，使用break来结束循环。接下来，程序计算空格数，但不计算其他字符。当字符不为空格时，循环使用continue语句跳过计数部分。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// jump.cpp -- using continue and break</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">80</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> line[ArSize];    <span class="hljs-type">int</span> spaces = <span class="hljs-number">0</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a line of text:\n&quot;</span>;    cin.<span class="hljs-built_in">get</span>(line, ArSize);    cout &lt;&lt; <span class="hljs-string">&quot;Complete line:\n&quot;</span> &lt;&lt; line &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Line through first period:\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; line[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)    &#123;        cout &lt;&lt; line[i];    <span class="hljs-comment">// display character</span>        <span class="hljs-keyword">if</span> (line[i] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-comment">// quit if it&#x27;s a period</span>            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">if</span> (line[i] != <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// skip rest of loop</span>            <span class="hljs-keyword">continue</span>;        spaces++;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; spaces &lt;&lt; <span class="hljs-string">&quot; spaces\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Done.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>和C语言一样，C++也有goto语句</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> ch;cin &gt;&gt; ch;<span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;P&#x27;</span>)&#123;<span class="hljs-keyword">goto</span> paris;&#125;cout &lt;&lt; ...paris:cout &lt;&lt; .....</code></pre></div><p>在大多数情况下（有些人认为，在任何情况下），使用goto语句不好，而应使用结构化控制语句（如if else、switch、continue等）来控制程序的流程。 </p><h2 id="读取数字的循环"><a href="#读取数字的循环" class="headerlink" title="读取数字的循环"></a>读取数字的循环</h2><p>假设要编写一个将一系列数字读入到数组中的程序，并允许用户在数组填满之前结束输入。一种方法是利用cin。请看下面的代码： </p><div class="code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>;cin &gt;&gt; <span class="hljs-built_in">n</span>;</code></pre></div><p>如果用户输入一个单词，而不是一个数字，情况将如何呢？发生这种类型不匹配的情况时，将发生4种情况： </p><ul><li>n的值保持不变； </li><li>不匹配的输入将被留在输入队列中； </li><li>cin对象中的一个错误标记被设置； </li><li>对cin方法的调用将返回false（如果被转换为bool类型）。</li></ul><p>方法返回false意味着可以用非数字输入来结束读取数字的循环。非数字输入设置错误标记意味着必须重置该标记，程序才能继续读取输 入。clear( )方法重置错误输入标记，同时也重置文件尾（EOF条件),输入错误和EOF都将导致cin返回false，</p><p>假设要编写一个程序，来计算平均每天捕获的鱼的重量。这里假设每天最多捕获5条鱼，因此一个包含5个元素的数组将足以存储所有的数 据，但也可能没有捕获这么多鱼。在程序清单6.13中，如果数组被填满或者输入了非数字输入，循环将结束。 </p><p>程序清单<strong>6.13 cinfish.cpp</strong></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// cinfish.cpp -- non-numeric input terminates loop</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> Max = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// get data</span>    <span class="hljs-type">double</span> fish[Max];    cout &lt;&lt; <span class="hljs-string">&quot;Please enter the weights of your fish.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;You may enter up to &quot;</span> &lt;&lt; Max         &lt;&lt; <span class="hljs-string">&quot; fish &lt;q to terminate&gt;.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;fish #1: &quot;</span>;    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; Max &amp;&amp; cin &gt;&gt; fish[i]) &#123;        <span class="hljs-keyword">if</span> (++i &lt; Max)            cout &lt;&lt; <span class="hljs-string">&quot;fish #&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;    &#125;<span class="hljs-comment">// calculate average</span>    <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)        total += fish[j];<span class="hljs-comment">// report results</span>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)        cout &lt;&lt; <span class="hljs-string">&quot;No fish\n&quot;</span>;    <span class="hljs-keyword">else</span>        cout &lt;&lt; total / i &lt;&lt; <span class="hljs-string">&quot; = average weight of &quot;</span>             &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; fish\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Done.\n&quot;</span>;<span class="hljs-comment">// code to keep VC execution window open if q is entered</span><span class="hljs-comment">// if (!cin)  // input terminated by non-numeric response</span><span class="hljs-comment">// &#123;</span><span class="hljs-comment">//     cin.clear();  // reset input</span><span class="hljs-comment">//     cin.get();    // read q</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// cin.get();    // read end of line after last input</span><span class="hljs-comment">// cin.get();    // wait for user to press &lt;Enter&gt;</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Please enter the weights of your fish.</span><span class="hljs-comment">//You may enter up to 5 fish &lt;q to terminate&gt;.</span><span class="hljs-comment">//fish #1: 10</span><span class="hljs-comment">//fish #2: 20</span><span class="hljs-comment">//fish #3: 30</span><span class="hljs-comment">//fish #4: 50</span><span class="hljs-comment">//fish #5: q</span><span class="hljs-comment">//27.5 = average weight of 4 fish</span><span class="hljs-comment">//        Done.</span></code></pre></div><p>程序清单6.13中的表达式cin&gt;&gt;fish [i]实际上一个是cin方法函数调用，该函数返回cin。如果cin位于测试条件中，则将被转换为bool类 型。如果输入成功，则转换后的值为true，否则为false</p><p>当用户输入的不是数字时，该程序将不再读取输入。下面来看一个继续读取的例子。假设程序要求用户提供5个高尔夫得分，以计算平均 成绩。如果用户输入非数字输入，程序将拒绝，并要求用户继续输入数字。可以看到，可以使用cin输入表达式的值来检测输入是不是数字。    程序发现用户输入了错误内容时，应采取3个步骤。 </p><p>1．重置cin以接受新的输入。 </p><p>2．删除错误输入。 </p><p>3．提示用户再输入。</p><p>请注意，程序必须先重置cin，然后才能删除错误输入</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// cingolf.cpp -- non-numeric input skipped</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> Max = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// get data</span>    <span class="hljs-type">int</span> golf[Max];    cout &lt;&lt; <span class="hljs-string">&quot;Please enter your golf scores.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;You must enter &quot;</span> &lt;&lt; Max &lt;&lt; <span class="hljs-string">&quot; rounds.\n&quot;</span>;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Max; i++)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;round #&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;        <span class="hljs-keyword">while</span> (!(cin &gt;&gt; golf[i])) &#123;            cin.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// reset input</span>            <span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)                <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">// get rid of bad input</span>            cout &lt;&lt; <span class="hljs-string">&quot;Please enter a number: &quot;</span>;        &#125;    &#125;<span class="hljs-comment">// calculate average</span>    <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Max; i++)        total += golf[i];<span class="hljs-comment">// report results</span>    cout &lt;&lt; total / Max &lt;&lt; <span class="hljs-string">&quot; = average score &quot;</span>         &lt;&lt; Max &lt;&lt; <span class="hljs-string">&quot; rounds\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Please enter your golf scores.</span><span class="hljs-comment">//You must enter 5 rounds.</span><span class="hljs-comment">//round #1: 88</span><span class="hljs-comment">//round #2: a</span><span class="hljs-comment">//Please enter a number: 33</span><span class="hljs-comment">//round #3: 55</span><span class="hljs-comment">//round #4: 66</span><span class="hljs-comment">//round #5: 22</span><span class="hljs-comment">//52.8 = average score 5 rounds</span></code></pre></div><h2 id="简单文件输入-输出"><a href="#简单文件输入-输出" class="headerlink" title="简单文件输入**/**输出"></a>简单文件输入**/**输出</h2><h3 id="写入到文本文件中"><a href="#写入到文本文件中" class="headerlink" title="写入到文本文件中"></a>写入到文本文件中</h3><p>对于文件输入，C++使用类似于cout的东西。下面来复习一些有关将cout用于控制台输出的基本事实，为文件输出做准备。</p><ol><li>必须包含头文件iostream。 </li><li>头文件iostream定义了一个用处理输出的ostream类。 </li><li>头文件iostream声明了一个名为cout的ostream变量（对象）。 </li><li>必须指明名称空间std；例如，为引用元素cout和endl，必须使用编 </li><li>译指令using或前缀std::。 </li><li>可以结合使用cout和运算符&lt;&lt;来显示各种类型的数据。 </li></ol><p>文件输出与此极其相似。 </p><ol><li>必须包含头文件fstream。 </li><li>头文件fstream定义了一个用于处理输出的ofstream类。 </li><li>需要声明一个或多个ofstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。 </li><li>必须指明名称空间std；例如，为引用元素ofstream，必须使用编译指令using或前缀std::。 </li><li>需要将ofstream对象与文件关联起来。为此，方法之一是使用open( )方法。 </li><li>使用完文件后，应使用方法close( )将其关闭。 </li><li>可结合使用ofstream对象和运算符&lt;&lt;来输出各种类型的数据。</li></ol><p>注意，虽然头文件iostream提供了一个预先定义好的名为cout的ostream对象，但您必须声明自己的ofstream对象，为其命名，并将其同文件关联起来。下面演示了如何声明这种对象： </p><div class="code-wrapper"><pre><code class="hljs abnf">ofstream outFile<span class="hljs-comment">;</span>ofstream fout<span class="hljs-comment">;</span></code></pre></div><p>下面演示了如何将这种对象与特定的文件关联起来：</p><div class="code-wrapper"><pre><code class="hljs sas">outFile.<span class="hljs-meta">open</span>(<span class="hljs-string">&quot;fish.txt&quot;</span>);char <span class="hljs-keyword">filename</span>[50];cin &gt;&gt; <span class="hljs-keyword">filename</span>;fout.opr<span class="hljs-meta">n</span>(<span class="hljs-keyword">filename</span>);</code></pre></div><p>下面演示了如何使用这种对象：</p><div class="code-wrapper"><pre><code class="hljs abnf">double wt <span class="hljs-operator">=</span> <span class="hljs-number">125.8</span><span class="hljs-comment">;</span>outFile &lt;&lt; wt<span class="hljs-comment">;</span>char line[<span class="hljs-number">81</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;22222&quot;</span><span class="hljs-comment">;</span>fout &lt;&lt; line &lt;&lt;endl<span class="hljs-comment">;</span></code></pre></div><p>重要的是，声明一个ofstream对象并将其同文件关联起来后，便可以像使用cout那样使用它。所有可用于cout的操作和方法（如&lt;&lt;、endl和setf( )）都可用于ofstream对象（如前述示例中的outFile和fout）。</p><p>总之，使用文件输出的主要步骤如下。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// outfile.cpp -- writing to a file</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>                  <span class="hljs-comment">// for file I/O</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> automobile[<span class="hljs-number">50</span>];    <span class="hljs-type">int</span> year;    <span class="hljs-type">double</span> a_price;    <span class="hljs-type">double</span> d_price;    ofstream outFile;               <span class="hljs-comment">// create object for output</span>    outFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;carinfo.txt&quot;</span>);    <span class="hljs-comment">// associate with a file</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter the make and model of automobile: &quot;</span>;    cin.<span class="hljs-built_in">getline</span>(automobile, <span class="hljs-number">50</span>);    cout &lt;&lt; <span class="hljs-string">&quot;Enter the model year: &quot;</span>;    cin &gt;&gt; year;    cout &lt;&lt; <span class="hljs-string">&quot;Enter the original asking price: &quot;</span>;    cin &gt;&gt; a_price;    d_price = <span class="hljs-number">0.913</span> * a_price;<span class="hljs-comment">// display information on screen with cout</span>    cout &lt;&lt; fixed;    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);    cout.<span class="hljs-built_in">setf</span>(ios_base::showpoint);    cout &lt;&lt; <span class="hljs-string">&quot;Make and model: &quot;</span> &lt;&lt; automobile &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Year: &quot;</span> &lt;&lt; year &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Was asking $&quot;</span> &lt;&lt; a_price &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;Now asking $&quot;</span> &lt;&lt; d_price &lt;&lt; endl;<span class="hljs-comment">// now do exact same things using outFile instead of cout</span>    outFile &lt;&lt; fixed;    outFile.<span class="hljs-built_in">precision</span>(<span class="hljs-number">2</span>);    outFile.<span class="hljs-built_in">setf</span>(ios_base::showpoint);    outFile &lt;&lt; <span class="hljs-string">&quot;Make and model: &quot;</span> &lt;&lt; automobile &lt;&lt; endl;    outFile &lt;&lt; <span class="hljs-string">&quot;Year: &quot;</span> &lt;&lt; year &lt;&lt; endl;    outFile &lt;&lt; <span class="hljs-string">&quot;Was asking $&quot;</span> &lt;&lt; a_price &lt;&lt; endl;    outFile &lt;&lt; <span class="hljs-string">&quot;Now asking $&quot;</span> &lt;&lt; d_price &lt;&lt; endl;    outFile.<span class="hljs-built_in">close</span>();                <span class="hljs-comment">// done with file</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//Enter the make and model of automobile: 111111111111</span><span class="hljs-comment">//Enter the model year: 2023</span><span class="hljs-comment">//Enter the original asking price: 20</span><span class="hljs-comment">//Make and model: 111111111111</span><span class="hljs-comment">//Year: 2023</span><span class="hljs-comment">//Was asking $20.00</span><span class="hljs-comment">//Now asking $18.26</span></code></pre></div><p>屏幕输出是使用cout的结果。如果您查看该程序的可执行文件所在的目录，将看到一个名为carinfo.txt的新文件（根据编译器的配置，该文件也可能位于其他文件夹），其中包含使用outFile生成的输出。如果使用文本编辑器打开该文件，将发现其内容如下：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Make</span> and model: <span class="hljs-number">111111111111</span><span class="hljs-attribute">Year</span>: <span class="hljs-number">2023</span><span class="hljs-attribute">Was</span> asking $<span class="hljs-number">20</span>.<span class="hljs-number">00</span><span class="hljs-attribute">Now</span> asking $<span class="hljs-number">18</span>.<span class="hljs-number">26</span></code></pre></div><p>正如读者看到的，outFile将cout显示到屏幕上的内容写入到了文件carinfo.txt中。 </p><p>程序说明 在程序清单6.15的程序中，声明一个ofstream对象后，便可以使用方法open( )将该对象特定文件关联起来： </p><div class="code-wrapper"><pre><code class="hljs stata">ofstream <span class="hljs-keyword">outFile</span>;               <span class="hljs-comment">// create object for output</span><span class="hljs-keyword">outFile</span>.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;carinfo.txt&quot;</span>);    <span class="hljs-comment">// associate with a file</span></code></pre></div><p>程序使用完该文件后，应该将其关闭：</p><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">outFile</span>.<span class="hljs-keyword">close</span>()</code></pre></div><p>注意，方法close( )不需要使用文件名作为参数，这是因为outFile已经同特定的文件关联起来。如果您忘记关闭文件，程序正常终止时将自动关闭它。 </p><p>outFile可使用cout可使用的任何方法。它不但能够使用运算符&lt;&lt;，还可以使用各种格式化方法，如setf( )和precision( )。这些方法只影响调用它们的对象。例如，对于不同的对象，可以提供不同的值：</p><div class="code-wrapper"><pre><code class="hljs abnf">cout.precision(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>outFile.precision(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span></code></pre></div><p>读者需要记住的重点是，创建好ofstream对象（如outFile）后，便可以像使用cout那样使用它。 </p><p>回到open( )方法： </p><div class="code-wrapper"><pre><code class="hljs abnf">openFile.open(<span class="hljs-string">&quot;carinfo.txt&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><p>在这里，该程序运行之前，文件carinfo.txt并不存在。在这种情况下，方法open( )将新建一个名为carinfo.txt的文件。如果在此运行该程 序，文件carinfo.txt将存在，此时情况将如何呢？默认情况下，open( )将首先截断该文件，即将其长度截短到零——丢其原有的内容，然后将新的输出加入到该文件中</p><p>打开已有的文件，以接受输出时，默认将它其长度截短为零，因此原来的内容将丢失。 </p><p>打开文件用于接受输入时可能失败。例如，指定的文件可能已经存在，但禁止对其进行访问。因此细心的程序员将检查打开文件的操作是 否成功，这将在下一个例子中介绍。</p><h3 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h3><p>接下来介绍文本文件输入，它是基于控制台输入的。控制台输入涉及多个方面，下面首先总结这些方面。 </p><ul><li>必须包含头文件iostream。 </li><li>头文件iostream定义了一个用处理输入的istream类。 </li><li>头文件iostream声明了一个名为cin的istream变量（对象）。 </li><li>必须指明名称空间std；例如，为引用元素cin，必须使用编译指令using或前缀std::。 </li><li>可以结合使用cin和运算符&gt;&gt;来读取各种类型的数据。 </li><li>可以使用cin和get( )方法来读取一个字符，使用cin和getline( )来读取一行字符。 </li><li>可以结合使用cin和eof( )、fail( )方法来判断输入是否成功。 </li><li>对象cin本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。 </li></ul><p>文件输出与此极其相似： </p><ul><li>必须包含头文件fstream。 </li><li>头文件fstream定义了一个用于处理输入的ifstream类。 </li><li>需要声明一个或多个ifstream变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则。 </li><li>必须指明名称空间std；例如，为引用元素ifstream，必须使用编译指令using或前缀std::。 </li><li>需要将ifstream对象与文件关联起来。为此，方法之一是使用open( )方法。</li><li>使用完文件后，应使用close( )方法将其关闭。 </li><li>可结合使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据。 </li><li>可以使用ifstream对象和get( )方法来读取一个字符，使用ifstream对象和getline( )来读取一行字符。 </li><li>可以结合使用ifstream和eof( )、fail( )等方法来判断输入是否成功。 </li><li>ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换为布尔值true，否则被转换为false。 </li></ul><p>注意，虽然头文件iostream提供了一个预先定义好的名为cin的istream对象，但您必须声明自己的ifstream对象，为其命名，并将其同文件关联起来。下面演示了如何声明这种对象：</p><div class="code-wrapper"><pre><code class="hljs abnf">ifstream inFile<span class="hljs-comment">;</span>ifstream fin<span class="hljs-comment">;</span></code></pre></div><p>下面演示了如何将这种对象与特定的文件关联起来：</p><div class="code-wrapper"><pre><code class="hljs sas"><span class="hljs-keyword">inFile</span>.<span class="hljs-meta">open</span>(<span class="hljs-string">&quot;blowing.txt&quot;</span>);char <span class="hljs-keyword">filename</span>[50];cin &gt;&gt; <span class="hljs-keyword">filename</span>;fin.<span class="hljs-meta">open</span>(<span class="hljs-keyword">filename</span>);</code></pre></div><p>注意，方法open( )接受一个C-风格字符串作为参数，这可以是一个字面字符串，也可以是存储在数组中的字符串。 </p><p>下面演示了如何使用这种对象：</p><div class="code-wrapper"><pre><code class="hljs scss">double wt;inFile &gt;&gt; wt;char line<span class="hljs-selector-attr">[81]</span>;fin<span class="hljs-selector-class">.getline</span>(line,<span class="hljs-number">81</span>)</code></pre></div><p>重要的是，声明一个ifstream对象并将其同文件关联起来后，便可以像使用cin那样使用它。所有可用于cin的操作和方法都可用于ifstream对象（如前述示例中的inFile和fin）。</p><p>如果试图打开一个不存在的文件用于输入，情况将如何呢？这种错误将导致后面使用ifstream对象进行输入时失败。检查文件是否被成功</p><p>打开的首先方法是使用方法is_open( )，为此，可以使用类似于下面的代码：</p><div class="code-wrapper"><pre><code class="hljs awk">inFile.open(<span class="hljs-string">&quot;blowing.txt&quot;</span>);<span class="hljs-keyword">if</span>(!inFile.is_open())&#123;<span class="hljs-keyword">exit</span>(EXIT_FAILURE);&#125;</code></pre></div><p>如果文件被成功地打开，方法is_open( )将返回true；因此如果文件没有被打开，表达式!inFile.isopen( )将为true。函数exit( )的原型是在头文件cstdlib中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值EXIT_FAILURE。函数exit( )终止程序。 </p><p>方法is_open( )是C++中相对较新的内容。如果读者的编译器不支持它，可使用较老的方法good( )来代替。正如第17章将讨论的，方法 good( )在检查可能存在的问题方面，没有is_open( )那么广泛。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// sumafile.cpp -- functions with an array argument</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>          <span class="hljs-comment">// file I/O support</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>          <span class="hljs-comment">// support for exit()</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">60</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> filename[SIZE];    ifstream inFile;        <span class="hljs-comment">// object for handling file input</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter name of data file: &quot;</span>;    cin.<span class="hljs-built_in">getline</span>(filename, SIZE);    inFile.<span class="hljs-built_in">open</span>(filename);  <span class="hljs-comment">// associate inFile with a file</span>    <span class="hljs-keyword">if</span> (!inFile.<span class="hljs-built_in">is_open</span>())  <span class="hljs-comment">// failed to open file</span>    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Could not open the file &quot;</span> &lt;&lt; filename &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">&quot;Program terminating.\n&quot;</span>;        <span class="hljs-comment">// cin.get();    // keep window open</span>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-type">double</span> value;    <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;          <span class="hljs-comment">// number of items read</span>    inFile &gt;&gt; value;        <span class="hljs-comment">// get first value</span>    <span class="hljs-keyword">while</span> (inFile.<span class="hljs-built_in">good</span>())   <span class="hljs-comment">// while input good and not at EOF</span>    &#123;        ++count;            <span class="hljs-comment">// one more item read</span>        sum += value;       <span class="hljs-comment">// calculate running total</span>        inFile &gt;&gt; value;    <span class="hljs-comment">// get next value</span>    &#125;    <span class="hljs-keyword">if</span> (inFile.<span class="hljs-built_in">eof</span>())        cout &lt;&lt; <span class="hljs-string">&quot;End of file reached.\n&quot;</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inFile.<span class="hljs-built_in">fail</span>())        cout &lt;&lt; <span class="hljs-string">&quot;Input terminated by data mismatch.\n&quot;</span>;    <span class="hljs-keyword">else</span>        cout &lt;&lt; <span class="hljs-string">&quot;Input terminated for unknown reason.\n&quot;</span>;    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)        cout &lt;&lt; <span class="hljs-string">&quot;No data processed.\n&quot;</span>;    <span class="hljs-keyword">else</span>    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Items read: &quot;</span> &lt;&lt; count &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;        cout &lt;&lt; <span class="hljs-string">&quot;Average: &quot;</span> &lt;&lt; sum / count &lt;&lt; endl;    &#125;    inFile.<span class="hljs-built_in">close</span>();         <span class="hljs-comment">// finished with the file</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>程序还必须能够找到这个文件。通常，除非在输入的文件名中包含路径，否则程序将在可执行文件所属的文件夹中查找。 </p><p>Windows文本文件的每行都以回车字符和换行符结尾；通常情况下，C++在读取文件时将这两个字符转换为换行符，并在写入文件时执行相反的转换。有些文本编辑器（如MetrowerksCodeWarrior IDE编辑器），不会自动在最后一行末尾加上换行符。因此，如果读者使用的是这种编辑器，请在输入最后的文本后按下回车键，然后再保存文件。 </p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>使用引导程序选择不同操作的语句后，程序和编程将更有趣（这是 否也能引起程序员们的兴趣，我没有做过研究）。C++提供了if语句、if else语句和switch语句来管理选项。if语句使程序有条件地执行语句或语句块，也就是说，如果满足特定的条件，程序将执行特定的语句或语句块。if else语句程序选择执行两个语句或语句块之一。可以在这条语句后再加上if else，以提供一系列的选项。switch语句引导程序执行一系列选项之一。</p><p>C++还提供了帮助决策的运算符。第5章讨论了关系表达式，这种表达式对两个值进行比较。if和if else语句通常使用关系表达式作为测试 条件。通过使用逻辑运算符（&amp;&amp;、||和!），可以组合或修改关系表达 式，创建更细致的测试。条件运算符?:）提供了一种选择两个值之一的简洁方式。</p><p>cctype字符函数库提供了一组方便的、功能强大的工具，可用于分析字符输入。</p><p>对于文件I/O来说，循环和选择语句是很有用的工具；文件I/O与控制台I/O极其相似。声明ifstream和ofstream对象，并将它们同文件关联起来后，便可以像使用cin和cout那样使用这些对象。</p><p>使用循环和决策语句，便可以编写有趣的、智能的、功能强大的程序</p><h1 id="函数——C-的编程模块"><a href="#函数——C-的编程模块" class="headerlink" title="函数——C++的编程模块"></a>函数——C++的编程模块</h1><h2 id="复习函数的基本知识"><a href="#复习函数的基本知识" class="headerlink" title="复习函数的基本知识"></a>复习函数的基本知识</h2><p>要使用C++函数，必须完成如下工作</p><ul><li>提供函数定义； </li><li>提供函数原型； </li><li>调用函数。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// calling.cpp -- defining, prototyping, and calling a function</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// function prototype</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;main() will call the simple() function:\n&quot;</span>;    <span class="hljs-built_in">simple</span>();     <span class="hljs-comment">// function call</span>    cout &lt;&lt; <span class="hljs-string">&quot;main() is finished with the simple() function.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// function definition</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m but a simple function.\n&quot;</span>;&#125;</code></pre></div><p>执行函数simple()时，将暂停执行main( )中的代码；等函数simple()执行完毕后，继续执行main()中的代码。在每个函数定义中，都使用了一条using编译指令，因为每个函数都使用了cout。另一种方法是，在函数定义之前放置一条using编译指令或在函数中使用std::cout。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>可以将函数分成两类：没有返回值的函数和有返回值的函数。没有返回值的函数被称为void函数，其通用格式如下：</p><div class="code-wrapper"><pre><code class="hljs scss">void <span class="hljs-built_in">functionName</span>(parameterList)&#123;<span class="hljs-built_in">statement</span>(s);return;  <span class="hljs-comment">//optional</span>&#125;</code></pre></div><p>其中，parameterList指定了传递给函数的参数类型和数量，本章后面将更详细地介绍该列表。可选的返回语句标记了函数的结尾；否则，函数将在右花括号处结束。void函数相当于Pascal中的过程、FORTRAN中的子程序和现代BASIC中的子程序过程。通常，可以用void函数来执行某种操作。例如，将Cheers!打印指定次数（n）的函数如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cheers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-keyword">for</span>(let i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;std::cout&lt;&lt;<span class="hljs-string">&quot;cheers&quot;</span>;&#125;std::cout&lt;&lt;std::endl;&#125;</code></pre></div><p>参数列表int n意味着调用函数cheers( )时，应将一个int值作为参数传递给它。 </p><p>有返回值的函数将生成一个值，并将它返回给调用函数。换句话来说，如果函数返回9.0的平方根（sqrt（9.0）），则该函数调用的值为 3.0。这种函数的类型被声明为返回值的类型，其通用格式如下：</p><div class="code-wrapper"><pre><code class="hljs wren"><span class="hljs-variable">typeName</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">parameterList</span>)&#123;<span class="hljs-variable">statements</span>;<span class="hljs-keyword">return</span> <span class="hljs-variable">value</span>;&#125;</code></pre></div><p>对于有返回值的函数，必须使用返回语句，以便将值返回给调用函数。值本身可以是常量、变量，也可以是表达式，只是其结果的类型必 须为typeName类型或可以被转换为typeName（例如，如果声明的返回 类型为double，而函数返回一个int表达式，则该int值将被强制转换为 double类型）。然后，函数将最终的值返回给调用函数。C++对于返回 值的类型有一定的限制：不能是数组，但可以是其他任何类型——整 数、浮点数、指针，甚至可以是结构和对象！（有趣的是，虽然C++函 数不能直接返回数组，但可以将数组作为结构或对象组成部分来返 回。）</p><h3 id="函数原型和函数调用"><a href="#函数原型和函数调用" class="headerlink" title="函数原型和函数调用"></a>函数原型和函数调用</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cheers</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;       <span class="hljs-comment">// prototype: no return value</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>;  <span class="hljs-comment">// prototype: returns a double</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-built_in">cheers</span>(<span class="hljs-number">5</span>);          <span class="hljs-comment">// function call</span>    cout &lt;&lt; <span class="hljs-string">&quot;Give me a number: &quot;</span>;    <span class="hljs-type">double</span> side;    cin &gt;&gt; side;    <span class="hljs-type">double</span> volume = <span class="hljs-built_in">cube</span>(side);    <span class="hljs-comment">// function call</span>    cout &lt;&lt; <span class="hljs-string">&quot;A &quot;</span> &lt;&lt; side &lt;&lt;<span class="hljs-string">&quot;-foot cube has a volume of &quot;</span>;    cout &lt;&lt; volume &lt;&lt; <span class="hljs-string">&quot; cubic feet.\n&quot;</span>;    <span class="hljs-built_in">cheers</span>(<span class="hljs-built_in">cube</span>(<span class="hljs-number">2</span>));    <span class="hljs-comment">// prototype protection at work</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cheers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        cout &lt;&lt; <span class="hljs-string">&quot;Cheers! &quot;</span>;    cout &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x * x * x;&#125;<span class="hljs-comment">//Cheers! Cheers! Cheers! Cheers! Cheers!</span><span class="hljs-comment">//Give me a number: 5</span><span class="hljs-comment">//A 5-foot cube has a volume of 125 cubic feet.</span><span class="hljs-comment">//Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers! Cheers!</span></code></pre></div><h4 id="为什么需要原型"><a href="#为什么需要原型" class="headerlink" title="为什么需要原型"></a>为什么需要原型</h4><p>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。例如，请看原型 将如何影响程序清单7.2中下述函数调用：</p><div class="code-wrapper"><pre><code class="hljs abnf">double volume <span class="hljs-operator">=</span> cube(side)<span class="hljs-comment">;</span></code></pre></div><p>首先，原型告诉编译器，cube( )有一个double参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube( )函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数（这里为main( )）将从这个位置取得返回值。由于原型指出了cube( )的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。</p><p>为何编译器需要原型，难道它就不能在文件中进一步查找，以了解函数是如何定义的吗？这种方法的一个问题是效率不高。编译器在搜索文件的剩余部分时将必须停止对main( )的编译。一个更严重的问题是，函数甚至可能并不在文件中。C++允许将一个程序放在多个文件中，单独编译这些文件，然后再将它们组合起来。在这种情况下，编译器在编译main( )时，可能无权访问函数代码。如果函数位于库中，情况也将如此。避免使用函数原型的唯一方法是，在首次使用函数之前定义它，但这并不总是可行的。另外，C++的编程风格是将main()放在最前面，因为它通常提供了程序的整体结构。</p><h4 id="原型的语法"><a href="#原型的语法" class="headerlink" title="原型的语法"></a>原型的语法</h4><p>函数原型是一条语句，因此必须以分号结束。获得原型最简单的方法是，复制函数定义中的函数头，并添加分号。对于cube( )，程序清单 7.2中的程序正是这样做的：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>;</code></pre></div><p>然而，函数原型不要求提供变量名，有类型列表就足够了。对于cheer( )的原型，该程序只提供了参数类型：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cheer</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;</code></pre></div><p>通常，在原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。 </p><h4 id="原型的功能"><a href="#原型的功能" class="headerlink" title="原型的功能"></a>原型的功能</h4><ul><li>编译器正确处理函数返回值； </li><li>编译器检查使用的参数数目是否正确； </li><li>编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）。 </li></ul><p>自动类型转换并不能避免所有可能的错误。例如，如果将8.33E27传递给期望一个int值的函数，则这样大的值将不能被正确转换为int值。 当较大的类型被自动转换为较小的类型时，有些编译器将发出警告，指出这可能会丢失数据。</p><p>仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。 </p><p>在编译阶段进行的原型化被称为静态类型检查（static type checking）。可以看出，静态类型检查可捕获许多在运行阶段非常难以捕获的错误。</p><h2 id="函数参数和按值传递"><a href="#函数参数和按值传递" class="headerlink" title="函数参数和按值传递"></a>函数参数和按值传递</h2><p>C++通常按值传递参数，这意味着将数值参数传递给函数，而后者将其赋给一个新的变量</p><div class="code-wrapper"><pre><code class="hljs abnf">double volume <span class="hljs-operator">=</span> cube(side)<span class="hljs-comment">;</span></code></pre></div><p>其中，side是一个变量，在前面的程序运行中，其值为5。cube( )的函数头如下：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>;</code></pre></div><p>被调用时，该函数将创建一个新的名为x的double变量，并将其初始化为5。这样，cube( )执行的操作将不会影响main( )中的数据，因为 cube( )使用的是side的副本，而不是原来的数据</p><p>用于接收传递值的变量被称为形参。传递给函数的值被称为实参。出于简化的目的，C++标准使用参数（argument）来表示 实参，使用参量（parameter）来表示形参，因此参数传递将参量赋给参数</p><img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-02-28%2021.56.47.png" style="zoom:50%;" /><p>在函数中声明的变量（包括参数）是该函数私有的。在函数被调用时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些 变量使用的内存（有些C++文献将分配和释放内存称为创建和毁坏变量，这样似乎更激动人心）。这样的变量被称为局部变量，因为它们被限制在函数中。前面提到过，这样做有助于确保数据的完整性。这还意味着，如果在main( )中声明了一个名为x的变量，同时在另一个函数中也声明了一个名为x的变量，则它们将是两个完全不同的、毫无关系的变量。这样的变量也被称为自动变量，因为它们是在程序执行过程中自动被分配和释放的。</p><h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h3><p>函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可：</p><div class="code-wrapper"><pre><code class="hljs lisp">n_chars(&#x27;R&#x27;,<span class="hljs-number">25</span>)<span class="hljs-comment">;</span></code></pre></div><p>同样，在定义函数时，也在函数头中使用由逗号分隔的参数声明列表</p><div class="code-wrapper"><pre><code class="hljs reasonml">void n<span class="hljs-constructor">_chars(<span class="hljs-params">char</span> <span class="hljs-params">c</span>,<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>;</code></pre></div><p>该函数头指出，函数n_char( )接受一个char参数和一个int参数。传递给函数的值被赋给参数c和n。如果函数的两个参数的类型相同，则必须分别指定每个参数的类型，而不能像声明常规变量那样，将声明组合在一起：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">fif</span><span class="hljs-params">(<span class="hljs-type">float</span> a ,<span class="hljs-type">float</span> b)</span>;<span class="hljs-comment">//ok</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">fif</span><span class="hljs-params">(<span class="hljs-type">float</span> a,b)</span><span class="hljs-comment">//no</span></code></pre></div><p>和其他函数一样，只需添加分号就可以得到该函数的原型</p><div class="code-wrapper"><pre><code class="hljs reasonml">void n<span class="hljs-constructor">_chars(<span class="hljs-params">char</span> <span class="hljs-params">c</span>,<span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span>;</code></pre></div><p>和一个参数的情况一样，原型中的变量名不必与定义中的变量名相同，而且可以省略： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">n_chars</span><span class="hljs-params">(<span class="hljs-type">char</span>,<span class="hljs-type">int</span>)</span></span>;</code></pre></div><p>然而，提供变量名将使原型更容易理解，尤其是两个参数的类型相 同时。这样，变量名可以提醒参量和参数间的对应关系：</p><div class="code-wrapper"><pre><code class="hljs reasonml">double memo<span class="hljs-constructor">_density(<span class="hljs-params">double</span> <span class="hljs-params">weight</span>,<span class="hljs-params">double</span> <span class="hljs-params">volume</span>)</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// twoarg.cpp -- a function with 2 arguments</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">n_chars</span><span class="hljs-params">(<span class="hljs-type">char</span>, <span class="hljs-type">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> times;    <span class="hljs-type">char</span> ch;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a character: &quot;</span>;    cin &gt;&gt; ch;    <span class="hljs-keyword">while</span> (ch != <span class="hljs-string">&#x27;q&#x27;</span>)        <span class="hljs-comment">// q to quit</span>    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Enter an integer: &quot;</span>;        cin &gt;&gt; times;        <span class="hljs-built_in">n_chars</span>(ch, times); <span class="hljs-comment">// function with two arguments</span>        cout &lt;&lt; <span class="hljs-string">&quot;\nEnter another character or press the&quot;</span>                <span class="hljs-string">&quot; q-key to quit: &quot;</span>;        cin &gt;&gt; ch;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;The value of times is &quot;</span> &lt;&lt; times &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot;Bye\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">n_chars</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">// displays c n times</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>)         <span class="hljs-comment">// continue until n reaches 0</span>        cout &lt;&lt; c;&#125;</code></pre></div><h3 id="另外一个接受两个参数的函数"><a href="#另外一个接受两个参数的函数" class="headerlink" title="另外一个接受两个参数的函数"></a>另外一个接受两个参数的函数</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//lotto.cpp -- probability of winning</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// Note: some implementations require double instead of long double</span><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">probability</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> numbers, <span class="hljs-type">unsigned</span> picks)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> total, choices;    cout &lt;&lt; <span class="hljs-string">&quot;Enter the total number of choices on the game card and\n&quot;</span>            <span class="hljs-string">&quot;the number of picks allowed:\n&quot;</span>;    <span class="hljs-keyword">while</span> ((cin &gt;&gt; total &gt;&gt; choices) &amp;&amp; choices &lt;= total)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;You have one chance in &quot;</span>;        cout &lt;&lt; <span class="hljs-built_in">probability</span>(total, choices);      <span class="hljs-comment">// compute the odds</span>        cout &lt;&lt; <span class="hljs-string">&quot; of winning.\n&quot;</span>;        cout &lt;&lt; <span class="hljs-string">&quot;Next two numbers (q to quit): &quot;</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;bye\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// the following function calculates the probability of picking picks</span><span class="hljs-comment">// numbers correctly from numbers choices</span><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">probability</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> numbers, <span class="hljs-type">unsigned</span> picks)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">long</span> <span class="hljs-type">double</span> result = <span class="hljs-number">1.0</span>;  <span class="hljs-comment">// here come some local variables</span>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> n;    <span class="hljs-type">unsigned</span> p;    <span class="hljs-keyword">for</span> (n = numbers, p = picks; p &gt; <span class="hljs-number">0</span>; n--, p--)        result = result * n / p ;    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>形参可以从函数调用中，从函数调用的时候从外部获取值，局部参数则是定义在函数内部，从函数内部获取值</p><h2 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// arrfun1.cpp -- functions with an array argument</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">8</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span></span>;        <span class="hljs-comment">// prototype 数组会被当作指针</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> cookies[ArSize] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">128</span>&#125;;<span class="hljs-comment">// some systems require preceding int with static to</span><span class="hljs-comment">// enable array initialization</span>    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">sum_arr</span>(cookies, ArSize);    cout &lt;&lt; <span class="hljs-string">&quot;Total cookies eaten: &quot;</span> &lt;&lt; sum &lt;&lt;  <span class="hljs-string">&quot;\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// return the sum of an integer array</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        total = total + arr[i];    <span class="hljs-keyword">return</span> total;&#125;</code></pre></div><h3 id="函数如何使用指针来处理数组"><a href="#函数如何使用指针来处理数组" class="headerlink" title="函数如何使用指针来处理数组"></a>函数如何使用指针来处理数组</h3><p>在大多数情况下，C++和C语言一样，也将数组名视为指针。第4章介绍过，C++将数组名解释为其第一个元素的地址：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">cookies</span> == &amp;cookies[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span></code></pre></div><p>该规则有一些例外。首先，数组声明使用数组名来标记存储位置；其次，对数组名使用sizeof将得到整个数组的长度（以字节为单位）； 第三，正如第4章指出的，将地址运算符&amp;用于数组名时，将返回整个 数组的地址，例如&amp;cookies将返回一个32字节内存块的地址（如果int长4字节）。</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sum = sum<span class="hljs-constructor">_arr(<span class="hljs-params">cookies</span>, ArSize)</span>;</code></pre></div><p>其中，cookies是数组名，而根据C++规则，cookies是其第一个元素的地址，因此函数传递的是地址。由于数组的元素的类型为int，因此 cookies的类型必须是int指针，即int *。这表明，正确的函数头应该是这样的：</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sum<span class="hljs-constructor">_arr(<span class="hljs-params">int</span> <span class="hljs-operator">*</span> <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>;</code></pre></div><p>其中用int * arr替换了int arr [ ]。这证明这两个函数头都是正确的，因为在C++中，当（且仅当）用于函数头或函数原型中，int *arr和int arr[ ]的含义才是相同的。它们都意味着arr是一个int指针。然而，数组表示 法（int arr[ ]）提醒用户，arr不仅指向int，还指向int数组的第一个int。 当指针指向数组的第一个元素时，本书使用数组表示法；而当指针指向 一个独立的值时，使用指针表示法。别忘了，在其他的上下文中，int * arr和int arr [ ]的含义并不相同。例如，不能在函数体中使用int tip[ ]来声明指针</p><p>鉴于变量arr实际上就是一个指针，函数的其余部分是合理的。第4章在介绍动态数组时指出过，同数组名或指针一样，也可以用方括号数 组表示法来访问数组元素。无论arr是指针还是数组名，表达式arr [3]都指的是数组的第4个元素。就目前而言，提请读者记住下面两个恒等式，将不会有任何坏处：</p><div class="code-wrapper"><pre><code class="hljs inform7">arr<span class="hljs-comment">[i]</span> == *(arr+i);&amp;arr<span class="hljs-comment">[i]</span> == arr+i</code></pre></div><p>记住，将指针（包括数组名）加1，实际上是加上了一个与指针指向的类型的长度（以字节为单位）相等的值。对于遍历数组而言，使用 指针加法和数组下标时等效的。 </p><h3 id="将数组作为参数意味着什么"><a href="#将数组作为参数意味着什么" class="headerlink" title="将数组作为参数意味着什么"></a>将数组作为参数意味着什么</h3><img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-01%2021.49.14.png" style="zoom:50%;" /><p>数组名与指针对应是好事吗？确实是一件好事。将数组地址作为参数可以节省复制整个数组所需的时间和内存。如果数组很大，则使用拷 贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。在经典的C语言中，这确实是一个问题，但ANSI C和C++中的const限定符提供了解决这种问题的办法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// arrfun2.cpp -- functions with an array argument</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">8</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span></span>;<span class="hljs-comment">// use std:: instead of using directive</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> cookies[ArSize] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">128</span>&#125;;<span class="hljs-comment">//  some systems require preceding int with static to</span><span class="hljs-comment">//  enable array initialization</span>    std::cout &lt;&lt; cookies &lt;&lt; <span class="hljs-string">&quot; = array address, &quot;</span>;<span class="hljs-comment">//  some systems require a type cast: unsigned (cookies)</span>    std::cout &lt;&lt; <span class="hljs-keyword">sizeof</span> cookies &lt;&lt; <span class="hljs-string">&quot; = sizeof cookies\n&quot;</span>;    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">sum_arr</span>(cookies, ArSize);    std::cout &lt;&lt; <span class="hljs-string">&quot;Total cookies eaten: &quot;</span> &lt;&lt; sum &lt;&lt;  std::endl;    sum = <span class="hljs-built_in">sum_arr</span>(cookies, <span class="hljs-number">3</span>);        <span class="hljs-comment">// a lie</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;First three eaters ate &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot; cookies.\n&quot;</span>;    sum = <span class="hljs-built_in">sum_arr</span>(cookies + <span class="hljs-number">4</span>, <span class="hljs-number">4</span>);    <span class="hljs-comment">// another lie</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Last four eaters ate &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot; cookies.\n&quot;</span>;    <span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// return the sum of an integer array</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;    std::cout &lt;&lt; arr &lt;&lt; <span class="hljs-string">&quot; = arr, &quot;</span>;<span class="hljs-comment">// some systems require a type cast: unsigned (arr)</span>    std::cout &lt;&lt; <span class="hljs-keyword">sizeof</span> arr &lt;&lt; <span class="hljs-string">&quot; = sizeof arr\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        total = total + arr[i];    <span class="hljs-keyword">return</span> total;&#125;<span class="hljs-comment">//0x16b5cf710 = array address, 32 = sizeof cookies</span><span class="hljs-comment">//0x16b5cf710 = arr, 8 = sizeof arr</span><span class="hljs-comment">//Total cookies eaten: 255</span><span class="hljs-comment">//0x16b5cf710 = arr, 8 = sizeof arr</span><span class="hljs-comment">//First three eaters ate 7 cookies.</span><span class="hljs-comment">//0x16b5cf720 = arr, 8 = sizeof arr</span><span class="hljs-comment">//Last four eaters ate 240 cookies.</span></code></pre></div><p>注意，地址值和数组的长度随系统而异。另外，有些C++实现以十进制而不是十六进制格式显示地址，还有些编译器以十六进制显示地址 时，会加上前缀0x。 </p><p>程序清单7.6说明了数组函数的一些有趣的地方。首先，cookies和arr指向同一个地址。但sizeof cookies的值为32，而sizeof arr为4。这是由于sizeof cookies是整个数组的长度，而sizeof arr只是指针变量的长度 （上述程序运行结果是从一个使用4字节地址的系统中获得的）。顺便 说一句，这也是必须显式传递数组长度，而不能在sum_arr( )中使用sizeof arr的原因；指针本身并没有指出数组的长度</p><p>由于sum_arr( )只能通过第二个参数获知数组中的元素数量，因此可以对函数“说谎”。例如，程序第二次使用该函数时，这样调用它：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">sum</span> = sum_arr(cookies, <span class="hljs-number">3</span>)<span class="hljs-comment">;    // another lie</span></code></pre></div><p>通过告诉该函数cookies有3个元素，可以让它计算前3个元素的总和</p><p>为什么在这里停下了呢？还可以提供假的数组起始位置：</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">sum</span> = sum_arr(cookies+<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<span class="hljs-comment">;</span></code></pre></div><p>由于cookies是第一个元素的地址，因此cookies + 4是第5个元素的地址。这条语句将计算数组第5、6、7、8个元素的总和。请注意输出中第三次函数调用选择将不同于前两个调用的地址赋给arr的。是的，可以将&amp;cookies[4]，而不是cookies + 4作为参数；它们的含义是相同的</p><p>为将数组类型和元素数量告诉数组处理函数，请通过两个不同的参数来传递它们：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> size)</span></span>;</code></pre></div><p>而不要试图使用方括号表示法来传递数组长度： </p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[size])</span></span>;</code></pre></div><h3 id="更多数组函数示例"><a href="#更多数组函数示例" class="headerlink" title="更多数组函数示例"></a>更多数组函数示例</h3><p>来看一个简单的案例。假设要使用一个数组来记录房地产的价值（假设拥有房地产）。在这种情况下，程序员必须确定要使用哪种类 型。当然，double的取值范围比int和long大，并且提供了足够多的有效位数来精确地表示这些值。接下来必须决定数组元素的数目。（对于使用new创建的动态数组来说，可以稍后再决定，但我们希望使事情简单一点）。如果房地产数目不超过5个，则可以使用一个包含5个元素的double数组。 </p><p>现在，考虑要对房地产数组执行的操作。两个基本的操作分别是，将值读入到数组中和显示数组内容。我们再添加另一个操作：重新评估 每种房地产的值。为简单起见，假设所有房地产都以相同的比率增加或 者减少。（别忘了，这是一本关于C++的书，而不是关于房地产管理的书。）接下来，为每项操作编写一个函数，然后编写相应的代码。下面首先介绍这些步骤，然后将其用于一个完整的示例中。</p><h4 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h4><p>由于接受数组名参数的函数访问的是原始数组，而不是其副本，因此可以通过调用该函数将值赋给数组元素。该函数的一个参数是要填充的数组的名称。通常，程序可以管理多个人的投资，因此需要多个数组，因此不能在函数中设置数组长度，而要将数组长度作为第二个参数传递，就像前一个示例那样。另外，用户也可能希望在数组被填满之前停止读取数据，因此需要在函数中建立这种特性。由于用户输入的元素数目可能少于数组的长度，因此函数应返回实际输入的元素数目。因此，该函数的原型如下：</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> fill<span class="hljs-constructor">_array(<span class="hljs-params">double</span> <span class="hljs-params">arr</span>[],<span class="hljs-params">int</span> <span class="hljs-params">limit</span>)</span>;</code></pre></div><p>该函数接受两个参数，一个是数组名，另一个指定了要读取的最大元素数；该函数返回实际读取的元素数。例如，如果使用该函数来处理 一个包含5个元素的数组，则将5作为第二个参数。如果只输入3个值，则该函数将返回3。 </p><p>可以使用循环连续地将值读入到数组中，但如何提早结束循环呢？ 一种方法是，使用一个特殊值来指出输入结束。由于所有的属性都不为负，因此可以使用负数来指出输入结束。另外，该函数应对错误输入作出反应，如停止输入等。这样，该函数的代码如下所示：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fill_array</span><span class="hljs-params">(<span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> temp;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i++)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Enter value #&quot;</span> &lt;&lt; (i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;        cin &gt;&gt; temp;        <span class="hljs-keyword">if</span> (!cin)    <span class="hljs-comment">// bad input</span>        &#123;            cin.<span class="hljs-built_in">clear</span>();            <span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)                <span class="hljs-keyword">continue</span>;           cout &lt;&lt; <span class="hljs-string">&quot;Bad input; input process terminated.\n&quot;</span>;           <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span>)     <span class="hljs-comment">// signal to terminate</span>            <span class="hljs-keyword">break</span>;        ar[i] = temp;    &#125;    <span class="hljs-keyword">return</span> i;&#125;</code></pre></div><p>注意，代码中包含了对用户的提示。如果用户输入的是非负值，则这个值将被赋给数组，否则循环结束。如果用户输入的都是有效值，则 循环将在读取最大数目的值后结束。循环完成的最后一项工作是将i加1，因此循环结束后，i将比最后一个数组索引大1，即等于填充的元素数目。然后，函数返回这个值。</p><h4 id="显示数组及用const保护数组"><a href="#显示数组及用const保护数组" class="headerlink" title="显示数组及用const保护数组"></a>显示数组及用const保护数组</h4><p>创建显示数组内容的函数很简单。只需将数组名和填充的元素数目传递给函数，然后该函数使用循环来显示每个元素。然而，还有另一个 问题——确保显示函数不修改原始数组。除非函数的目的就是修改传递给它的数据，否则应避免发生这种情况。使用普通参数时，这种保护将自动实现，这是由于C++按值传递数据，而且函数使用数据的副本。然而，接受数组名的函数将使用原始数据，这正是fill_array( )函数能够完成其工作的原因。为防止函数无意中修改数组的内容，可在声明形参时使用关键字const（参见第3章）： </p><div class="code-wrapper"><pre><code class="hljs reasonml">void show<span class="hljs-constructor">_array(<span class="hljs-params">const</span> <span class="hljs-params">double</span> <span class="hljs-params">ar</span>[], <span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>;  <span class="hljs-comment">// don&#x27;t change data</span></code></pre></div><p>该声明表明，指针ar指向的是常量数据。这意味着不能使用ar修改该数据，也就是说，可以使用像ar[0]这样的值，但不能修改。注意，这 并不是意味着原始数组必须是常量，而只是意味着不能在show_array( )函数中使用ar来修改这些数据。因此，show_array( )将数组视为只读数据。假设无意间在show_array( )函数中执行了下面的操作，从而违反了这种限制：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>[<span class="hljs-number">0</span>]+=<span class="hljs-number">10</span>;</code></pre></div><p>编译器将禁止这样做。</p><p>下面是show_array( )函数的代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Property #&quot;</span> &lt;&lt; (i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;: $&quot;</span>;        cout &lt;&lt; ar[i] &lt;&lt; endl;    &#125;&#125;</code></pre></div><h4 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">revalue</span><span class="hljs-params">(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        ar[i] *= r;&#125;</code></pre></div><p>由于这个函数将修改数组的值，因此在声明ar时，不能使用const。</p><h4 id="将上述代码组合起来"><a href="#将上述代码组合起来" class="headerlink" title="将上述代码组合起来"></a>将上述代码组合起来</h4><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// arrfun3.cpp -- array functions and const</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> Max = <span class="hljs-number">5</span>;<span class="hljs-comment">// function prototypes</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fill_array</span><span class="hljs-params">(<span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> limit)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span>;  <span class="hljs-comment">// don&#x27;t change data</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">revalue</span><span class="hljs-params">(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> properties[Max];    <span class="hljs-type">int</span> size = <span class="hljs-built_in">fill_array</span>(properties, Max);    <span class="hljs-built_in">show_array</span>(properties, size);    <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Enter revaluation factor: &quot;</span>;        <span class="hljs-type">double</span> factor;        <span class="hljs-keyword">while</span> (!(cin &gt;&gt; factor))    <span class="hljs-comment">// bad input</span>        &#123;            cin.<span class="hljs-built_in">clear</span>();            <span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)                <span class="hljs-keyword">continue</span>;            cout &lt;&lt; <span class="hljs-string">&quot;Bad input; Please enter a number: &quot;</span>;        &#125;        <span class="hljs-built_in">revalue</span>(factor, properties, size);        <span class="hljs-built_in">show_array</span>(properties, size);    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Done.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fill_array</span><span class="hljs-params">(<span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> limit)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> temp;    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i++)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Enter value #&quot;</span> &lt;&lt; (i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;        cin &gt;&gt; temp;        <span class="hljs-keyword">if</span> (!cin)    <span class="hljs-comment">// bad input</span>        &#123;            cin.<span class="hljs-built_in">clear</span>();            <span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>)                <span class="hljs-keyword">continue</span>;            cout &lt;&lt; <span class="hljs-string">&quot;Bad input; input process terminated.\n&quot;</span>;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span>)     <span class="hljs-comment">// signal to terminate</span>            <span class="hljs-keyword">break</span>;        ar[i] = temp;    &#125;    <span class="hljs-keyword">return</span> i;&#125;<span class="hljs-comment">// the following function can use, but not alter,</span><span class="hljs-comment">// the array whose address is ar</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_array</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Property #&quot;</span> &lt;&lt; (i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;: $&quot;</span>;        cout &lt;&lt; ar[i] &lt;&lt; endl;    &#125;&#125;<span class="hljs-comment">// multiplies each element of ar[] by r</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">revalue</span><span class="hljs-params">(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        ar[i] *= r;&#125;<span class="hljs-comment">//Enter value #1: 100000</span><span class="hljs-comment">//Enter value #2: 80000</span><span class="hljs-comment">//Enter value #3: 222000</span><span class="hljs-comment">//Enter value #4: 240000</span><span class="hljs-comment">//Enter value #5: 118000</span><span class="hljs-comment">//Property #1: $100000</span><span class="hljs-comment">//Property #2: $80000</span><span class="hljs-comment">//Property #3: $222000</span><span class="hljs-comment">//Property #4: $240000</span><span class="hljs-comment">//Property #5: $118000</span><span class="hljs-comment">//Enter revaluation factor: 0.8</span><span class="hljs-comment">//Property #1: $80000</span><span class="hljs-comment">//Property #2: $64000</span><span class="hljs-comment">//Property #3: $177600</span><span class="hljs-comment">//Property #4: $192000</span><span class="hljs-comment">//Property #5: $94400</span><span class="hljs-comment">//Done.</span></code></pre></div><h4 id="程序说明-1"><a href="#程序说明-1" class="headerlink" title="程序说明"></a>程序说明</h4><p>前面已经讨论了与该示例相关的重要编程细节，因此这里回顾一下 整个过程。我们首先考虑的是通过数据类型和设计适当的函数来处理数 据，然后将这些函数组合成一个程序。有时也称为自下而上的程序设计 （bottom-up programming），因为设计过程从组件到整体进行。这种方法非常适合于OOP——它首先强调的是数据表示和操纵。而传统的过程性编程倾向于从上而下的程序设计（top-down programming），首先指定模块化设计方案，然后再研究细节。这两种方法都很有用，最终的产品都是模块化程序。</p><h4 id="数组处理函数的常用编写方式"><a href="#数组处理函数的常用编写方式" class="headerlink" title="数组处理函数的常用编写方式"></a>数组处理函数的常用编写方式</h4><p>假设要编写一个处理double数组的函数。如果该函数要修改数组， 其原型可能类似于下面这样：</p><div class="code-wrapper"><pre><code class="hljs reasonml">void f<span class="hljs-constructor">_modify(<span class="hljs-params">double</span> <span class="hljs-params">ar</span>[],<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>;</code></pre></div><p>如果函数不修改数组，其原型可能类似于下面这样： </p><div class="code-wrapper"><pre><code class="hljs reasonml">void f<span class="hljs-constructor">_modify(<span class="hljs-params">const</span> <span class="hljs-params">double</span> <span class="hljs-params">ar</span>[],<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span>;</code></pre></div><p>当然，在函数原型中可以省略变量名，也可将返回类型指定为类型。这里的要点是，ar实际上是一个指针，指向传入的数组的第一个元 素；另外，由于通过参数传递了元素数，这两个函数都可使用任何长度的数组，只要数组的类型为double：</p><div class="code-wrapper"><pre><code class="hljs scss">double rewards<span class="hljs-selector-attr">[1000]</span>;double default<span class="hljs-selector-attr">[50]</span>;<span class="hljs-built_in">f_modify</span>(rewards,<span class="hljs-number">1000</span>)</code></pre></div><p>这种做法是通过传递两个数字（数组地址和元素数）实现的。正如您看到的，函数缺少一些有关原始数组的知识；例如，它不能使用 sizeof来获悉原始数组的长度，而必须依赖于程序员传入正确的元素数</p><h3 id="使用数组区间的函数"><a href="#使用数组区间的函数" class="headerlink" title="使用数组区间的函数"></a>使用数组区间的函数</h3><p>对于处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量提交给它；传统的C/C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供了找到所有数据所需的信息。</p><p>还有另一种给函数提供所需信息的方法，即指定元素区间 （range），这可以通过传递两个指针来完成：一个指针标识数组的开头，另一个指针标识数组的尾部。例如，C++标准模板库（STL，将在第16章介绍）将区间方法广义化了。STL方法使用“超尾”概念来指定区间。也就是说，对于数组而言，标识数组结尾的参数将是指向最后一个元素后面的指针。例如，假设有这样的声明： </p><div class="code-wrapper"><pre><code class="hljs scss">double elbuod<span class="hljs-selector-attr">[20]</span></code></pre></div><p>则指针elboud和elboud + 20定义了区间。首先，数组名elboub指向第一个元素。表达式elboud + 19指向最后一个元素（即elboud[19]），因此，elboud + 20指向数组结尾后面的一个位置。将区间传递给函数将告诉函数应处理哪些元素。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// arrfun4.cpp -- functions with an array range</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> ArSize = <span class="hljs-number">8</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_arr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> * begin, <span class="hljs-type">const</span> <span class="hljs-type">int</span> * end)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> cookies[ArSize] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">128</span>&#125;;<span class="hljs-comment">//  some systems require preceding int with static to</span><span class="hljs-comment">//  enable array initialization</span>    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">sum_arr</span>(cookies, cookies + ArSize);    cout &lt;&lt; <span class="hljs-string">&quot;Total cookies eaten: &quot;</span> &lt;&lt; sum &lt;&lt;  endl;    sum = <span class="hljs-built_in">sum_arr</span>(cookies, cookies + <span class="hljs-number">3</span>);        <span class="hljs-comment">// first 3 elements</span>    cout &lt;&lt; <span class="hljs-string">&quot;First three eaters ate &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot; cookies.\n&quot;</span>;    sum = <span class="hljs-built_in">sum_arr</span>(cookies + <span class="hljs-number">4</span>, cookies + <span class="hljs-number">8</span>);    <span class="hljs-comment">// last 4 elements</span>    cout &lt;&lt; <span class="hljs-string">&quot;Last four eaters ate &quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&quot; cookies.\n&quot;</span>;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// return the sum of an integer array</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_arr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> * begin, <span class="hljs-type">const</span> <span class="hljs-type">int</span> * end)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * pt;    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (pt = begin; pt != end; pt++)        total = total + *pt;    <span class="hljs-keyword">return</span> total;&#125;<span class="hljs-comment">//Total cookies eaten: 255</span><span class="hljs-comment">//First three eaters ate 7 cookies.</span><span class="hljs-comment">//Last four eaters ate 240 cookies.</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">for</span> (pt = <span class="hljs-keyword">begin</span>; pt != <span class="hljs-keyword">end</span>; pt++)       total = total + *pt;</code></pre></div><p>它将pt设置为指向要处理的第一个元素（begin指向的元素）的指针，并将*pt（元素的值）加入到total中。然后，循环通过递增操作来更 新pt，使之指向下一个元素。只要pt不等于end，这一过程就将继续下去。当pt等于end时，它将指向区间中最后一个元素后面的一个位置，此时循环将结束。 </p><p>其次，请注意不同的函数调用是如何指定数组中不同的区间的：</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> sum = sum<span class="hljs-constructor">_arr(<span class="hljs-params">cookies</span>, <span class="hljs-params">cookies</span> + ArSize)</span>;sum = sum<span class="hljs-constructor">_arr(<span class="hljs-params">cookies</span>, <span class="hljs-params">cookies</span> + 3)</span>;        <span class="hljs-comment">// first 3 elements</span>sum = sum<span class="hljs-constructor">_arr(<span class="hljs-params">cookies</span> + 4, <span class="hljs-params">cookies</span> + 8)</span>;    <span class="hljs-comment">// last 4 elements</span></code></pre></div><p>指针cookies + ArSize指向最后一个元素后面的一个位置（数组有ArSize个元素，因此cookies[ArSize − 1]是最后一个元素，其地址为 cookies + ArSize – 1）。因此，区间[cookies，cookies + ArSize]指定的是整个数组。同样，cookies，cookies + 3指定了前3个元素，依此类推。 </p><p>请注意，根据指针减法规则，在sum_arr( )中，表达式end – begin是一个整数值，等于数组的元素数目。</p><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>可以用两种不同的方式将const关键字用于指针。第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置</p><p>首先，声明一个指向常量的指针pt：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> age = <span class="hljs-number">39</span>;<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * pt = &amp;age;</code></pre></div><p>该声明指出，pt指向一个const int（这里为39），因此不能使用pt来修改这个值。换句话来说，*pt的值为const，不能被修改：</p><div class="code-wrapper"><pre><code class="hljs awk">*pt+=<span class="hljs-number">1</span>;<span class="hljs-regexp">//i</span>nvalidcin&gt;&gt;*pt<span class="hljs-regexp">//i</span>nvalid</code></pre></div><p>现在来看一个微妙的问题。pt的声明并不意味着它指向的值实际上就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt指向age，而age不是const。可以直接通过age变量来修改age的值，但不能使用pt指针来修改它： </p><div class="code-wrapper"><pre><code class="hljs abnf">*pt <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">; //invalid</span><span class="hljs-attribute">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span><span class="hljs-comment">; //valid</span></code></pre></div><p>以前我们将常规变量的地址赋给常规指针，而这里将常规变量的地址赋给指向const的指针。因此还有两种可能：将const变量的地址赋给 指向const的指针、将const的地址赋给常规指针。这两种操作都可行吗？第一种可行，但第二种不可行： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> g_earth = <span class="hljs-number">9.80</span>;<span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> * pe = &amp;g_earth; <span class="hljs-comment">//valid</span><span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> g_moon = <span class="hljs-number">1.63</span>;<span class="hljs-built_in">float</span> * pm = &amp;g_moon;<span class="hljs-comment">//invalid</span></code></pre></div><p>对于第一种情况来说，既不能使用g_earth来修改值9.80，也不能使用pe来修改。C++禁止第二种情况的原因很简单——如果将g_moon的地址赋给pm，则可以使用pm来修改g_moon的值，这使得g_moon的const状态很荒谬，因此C++禁止将const的地址赋给非const指针。如果读者非要这样做，可以使用强制类型转换来突破这种限制，</p><p>如果将指针指向指针，则情况将更复杂。前面讲过，假如涉及的是一级间接关系，则将非const指针赋给const指针是可以的：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> age = <span class="hljs-number">39</span>;   <span class="hljs-comment">//age++ is a valid operation</span><span class="hljs-built_in">int</span> *pd = &amp;age; <span class="hljs-comment">//*pd = 41 is a valid operation</span><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * pt = pd; <span class="hljs-comment">//*pt = 42 is an invalid operation</span></code></pre></div><p>然而，进入两级间接关系时，与一级间接关系一样将const和非const混合的指针赋值方式将不再安全。如果允许这样做，则可以编写这 样的代码：</p><div class="code-wrapper"><pre><code class="hljs smali">const<span class="hljs-built_in"> int </span>**pp2;<span class="hljs-built_in"></span><span class="hljs-built_in">int </span>*p1;<span class="hljs-built_in"></span><span class="hljs-built_in">const </span>int n = 13;pp2 = &amp;p1;//not allowed but suppose it were*pp2 = &amp;n;//valid,both<span class="hljs-built_in"> const </span>,but sets p1 to point at n*p1 = 10;//valid ,but change<span class="hljs-built_in"> const </span>n</code></pre></div><p>上述代码将非const地址（&amp;pl）赋给了const指针（pp2），因此可以使用pl来修改const数据。因此，仅当只有一层间接关系（如指针指向基本数据类型）时，才可以将非const地址或指针赋给const指针。</p><p>如果数据类型本身并不是指针，则可以将const数据或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。 </p><p>假设有一个由const数据组成的数组：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> int months[<span class="hljs-number">12</span>] = &#123;<span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>&#125;</code></pre></div><p>则禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作为参数传递给使用非常量形参的函数： </p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> (<span class="hljs-built_in">int</span> arr[],<span class="hljs-built_in">int</span> n);<span class="hljs-comment">//should have been const int arr[]</span><span class="hljs-built_in">int</span> j = <span class="hljs-keyword">sum</span>(month,<span class="hljs-number">12</span>)<span class="hljs-comment">//not allow</span></code></pre></div><p>上述函数调用试图将const指针（months）赋给非const指针（arr），编译器将禁止这种函数调用。 </p><h5 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h5><p>将指针参数声明为指向常量数据的指针有两条理由：</p><p>这样可以避免由于无意间修改数据而导致的编程错误；</p><p>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。</p><p>如果条件允许，则应将指针形参声明为指向const的指针。 </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> age = <span class="hljs-number">39</span>;<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * pt = &amp;age;</code></pre></div><p>第二个声明中的const只能防止修改pt指向的值（这里为39），而不能防止修改pt的值。也就是说，可以将一个新地址赋给pt： </p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">int sage</span> = 80;<span class="hljs-attribute">pt</span> = &amp;sage;</code></pre></div><p>但仍然不能使用pt来修改它指向的值（现在为80）。</p><p>第二种使用const的方式使得无法修改指针的值：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> sloth = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * ps = &amp;sloth;<span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span> finger = &amp;sloth;</code></pre></div><p>在最后一个声明中，关键字const的位置与以前不同。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。简而言之，finger和<em>ps都是const，而</em>finger和ps不是</p><p>还可以声明指向const对象的const指针：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> trouble = <span class="hljs-number">2.0E30</span>;<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * <span class="hljs-keyword">const</span> stick = &amp;trouble;</code></pre></div><p>其中，stick 只能指向 trouble，而 stick 不能用来修改 trouble 的值。简而言之，stick 和*stick 都是const。 </p><h2 id="函数和二维数组"><a href="#函数和二维数组" class="headerlink" title="函数和二维数组"></a>函数和二维数组</h2><p>Data是一个数组名，该数组有3个元素。第一个元素本身是一个数组，有4个int值组成。因此data的类型是指向由4个int组成的数组的指 针，因此正确的原型如下：</p><div class="code-wrapper"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">int</span> (*ar2)[<span class="hljs-number">4</span>],<span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>)</code></pre></div><p>​    其中的括号是必不可少的，因为下面的声明将声明一个由4个指向int的指针组成的数组，而不是由一个指向由4个int组成的数组的指针；另外，函数参数不能是数组</p><p>还有另外一种格式，这种格式与上述原型的含义完全相同，但可读性更强：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> ar2[][<span class="hljs-number">4</span>],<span class="hljs-type">int</span> size)</span></span>;</code></pre></div><p>上述两个原型都指出，ar2是指针而不是数组。还需注意的是，指针类型指出，它指向由4个int组成的数组。因此，指针类型指定了列 数，这就是没有将列数作为独立的函数参数进行传递的原因。</p><p>由于指针类型指定了列数，因此sum( )函数只能接受由4列组成的数组。但长度变量指定了行数，因此sum( )对数组的行数没有限制：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a[<span class="hljs-number">100</span>][<span class="hljs-number">4</span>];<span class="hljs-attribute">int</span> b[<span class="hljs-number">6</span>][<span class="hljs-number">4</span>];<span class="hljs-attribute">int</span> total1=sum(a,<span class="hljs-number">100</span>)<span class="hljs-attribute">int</span> total2=sum(b,<span class="hljs-number">6</span>)</code></pre></div><p>由于参数ar2是指向数组的指针，那么我们如何在函数定义中使用它呢？最简单的方法是将ar2看作是一个二维数组的名称。下面是一个 可行的函数定义：</p><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> ar2[][<span class="hljs-number">4</span>],<span class="hljs-type">int</span> size)</span></span>&#123;<span class="hljs-type">int</span> total = <span class="hljs-number">0</span> ;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;r&lt;size;r++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;c&lt;<span class="hljs-number">4</span>;c++)&#123;total +=ar2[r][c]&#125;&#125;<span class="hljs-keyword">return</span> total;&#125;</code></pre></div><p>同样，行数被传递给size参数，但无论是参数ar2的声明或是内部for循环中，列数都是固定的——4列。</p><p>可以使用数组表示法的原因如下。由于ar2指向数组（它的元素是由4个int组成的数组）的第一个元素（元素0），因此表达式ar2 + r指向 编号为r的元素。因此ar2[r]是编号为r的元素。由于该元素本身就是一个由4个int组成的数组，因此ar2[r]是由4个int组成的数组的名称。将下标用于数组名将得到一个数组元素，因此ar2[r][c]是由4个int组成的数组中的一个元素，是一个int值。必须对指针ar2执行两次解除引用，才能得到数据。最简单的方法是使用方括号两次：ar2[r][c]。然而，如果不考虑难看的话，也可以使用运算符*两次：</p><div class="code-wrapper"><pre><code class="hljs inform7">ar2<span class="hljs-comment">[r]</span><span class="hljs-comment">[c]</span> ==*(*(ar2+r)+c)</code></pre></div><h2 id="函数和C-风格字符串"><a href="#函数和C-风格字符串" class="headerlink" title="函数和C-风格字符串"></a>函数和C-风格字符串</h2><h3 id="将-C-风格字符串作为参数的函数"><a href="#将-C-风格字符串作为参数的函数" class="headerlink" title="将**C-**风格字符串作为参数的函数"></a>将**C-**风格字符串作为参数的函数</h3><p>假设要将字符串作为参数传递给函数，则表示字符串的方式有三 种：</p><ul><li>char数组； </li><li>用引号括起的字符串常量（也称字符串字面值）； </li><li>被设置为字符串的地址的char指针。</li></ul><p>但上述3种选择的类型都是char指针（准确地说是char*），因此可以将其作为字符串处理函数的参数：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">char</span> ghost[<span class="hljs-number">15</span>] = <span class="hljs-string">&quot;galloping&quot;</span>;<span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;galumphing&quot;</span>;<span class="hljs-type">int</span> n1 = <span class="hljs-built_in">strlen</span>(ghost);<span class="hljs-comment">//ghost is &amp;ghost[0]</span><span class="hljs-type">int</span> n2 = <span class="hljs-built_in">strlen</span>(str); <span class="hljs-comment">//pointer to char</span><span class="hljs-type">int</span> n3 = <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;gamboling&quot;</span>); <span class="hljs-comment">// address of string</span></code></pre></div><p>可以说是将字符串作为参数来传递，但实际传递的是字符串第一个字符的地址。这意味着字符串函数原型应将其表示字符串的形参声明为 char *类型。 </p><p>C-风格字符串与常规char数组之间的一个重要区别是，字符串有内置的结束字符（前面讲过，包含字符，但不以空值字符结尾的char数组 只是数组，而不是字符串）。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strgfun.cpp -- functions with a string argument</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">c_in_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">char</span> ch)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">char</span> mmm[<span class="hljs-number">15</span>] = <span class="hljs-string">&quot;minimum&quot;</span>;    <span class="hljs-comment">// string in an array</span><span class="hljs-comment">// some systems require preceding char with static to</span><span class="hljs-comment">// enable array initialization</span>    <span class="hljs-type">char</span> *wail = <span class="hljs-string">&quot;ululate&quot;</span>;    <span class="hljs-comment">// wail points to string</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ms = <span class="hljs-built_in">c_in_str</span>(mmm, <span class="hljs-string">&#x27;m&#x27;</span>);    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> us = <span class="hljs-built_in">c_in_str</span>(wail, <span class="hljs-string">&#x27;u&#x27;</span>);    cout &lt;&lt; ms &lt;&lt; <span class="hljs-string">&quot; m characters in &quot;</span> &lt;&lt; mmm &lt;&lt; endl;    cout &lt;&lt; us &lt;&lt; <span class="hljs-string">&quot; u characters in &quot;</span> &lt;&lt; wail &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// this function counts the number of ch characters</span><span class="hljs-comment">// in the string str</span><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">c_in_str</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, <span class="hljs-type">char</span> ch)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (*str)        <span class="hljs-comment">// quit when *str is &#x27;\0&#x27;</span>    &#123;        <span class="hljs-keyword">if</span> (*str == ch)            count++;        str++;        <span class="hljs-comment">// move pointer to next char</span>    &#125;    <span class="hljs-keyword">return</span> count; &#125;</code></pre></div><p>由于程序清单7.9中的c_int_str( )函数不应修改原始字符串，因此它在声明形参str时使用了限定符const。这样，如果错误地址函数修改了字 符串的内容，编译器将捕获这种错误。当然，可以在函数头中使用数组表示法，而不声明str： </p><div class="code-wrapper"><pre><code class="hljs reasonml">unsigned <span class="hljs-built_in">int</span> c<span class="hljs-constructor">_in_str(<span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-params">str</span>[], <span class="hljs-params">char</span> <span class="hljs-params">ch</span>)</span></code></pre></div><p>然而，使用指针表示法提醒读者注意，参数不一定必须是数组名，也可以是其他形式的指针。</p><p>该函数本身演示了处理字符串中字符的标准方式：</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> (*str)        <span class="hljs-regexp">//</span> quit when *str is <span class="hljs-string">&#x27;\0&#x27;</span>   &#123;      statement;       str++;        <span class="hljs-regexp">//</span> move pointer to <span class="hljs-keyword">next</span> char   &#125;</code></pre></div><p>str最初指向字符串的第一个字符，因此<em>str表示的是第一个字符。例如，第一次调用该函数后，</em>str的值将为m——“minimum”的第一个字 符。只要字符不为空值字符（\0），<em>str就为非零值，因此循环将继续。在每轮循环的结尾处，表达式str++将指针增加一个字节，使之指向字符串中的下一个字符。最终，str将指向结尾的空值字符，使得</em>str等于0——空值字符的数字编码，从而结束循环。 </p><h3 id="返回C-风格字符串的函数"><a href="#返回C-风格字符串的函数" class="headerlink" title="返回C-风格字符串的函数"></a>返回C-风格字符串的函数</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strgback.cpp -- a function that returns a pointer to char</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">buildstr</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> n)</span></span>;     <span class="hljs-comment">// prototype</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> times;    <span class="hljs-type">char</span> ch;    cout &lt;&lt; <span class="hljs-string">&quot;Enter a character: &quot;</span>;    cin &gt;&gt; ch;    cout &lt;&lt; <span class="hljs-string">&quot;Enter an integer: &quot;</span>;    cin &gt;&gt; times;    <span class="hljs-type">char</span> *ps = <span class="hljs-built_in">buildstr</span>(ch, times);    cout &lt;&lt; ps &lt;&lt; endl;    <span class="hljs-keyword">delete</span> [] ps;                   <span class="hljs-comment">// free memory</span>    ps = <span class="hljs-built_in">buildstr</span>(<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">20</span>);         <span class="hljs-comment">// reuse pointer</span>    cout &lt;&lt; ps &lt;&lt; <span class="hljs-string">&quot;-DONE-&quot;</span> &lt;&lt; ps &lt;&lt; endl;    <span class="hljs-keyword">delete</span> [] ps;                   <span class="hljs-comment">// free memory</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// builds string made of n c characters</span><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">buildstr</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">char</span> * pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n + <span class="hljs-number">1</span>];    pstr[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;         <span class="hljs-comment">// terminate string</span>    <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>)        pstr[n] = c;        <span class="hljs-comment">// fill rest of string</span>    <span class="hljs-keyword">return</span> pstr;&#125;<span class="hljs-comment">//Enter a character: V</span><span class="hljs-comment">//Enter an integer: 48</span><span class="hljs-comment">//VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV</span><span class="hljs-comment">//++++++++++++++++++++-DONE-++++++++++++++++++++</span></code></pre></div><p>要创建包含n个字符的字符串，需要能够存储n + 1个字符的空间， 以便能够存储空值字符。因此，程序清单7.10中的函数请求分配n + 1个字节的内存来存储该字符串，并将最后一个字节设置为空值字符，然后从后向前对数组进行填充。在程序清单7.10中，下面的循环将循环n次，直到n减少到0，这将填充n个元素：</p><div class="code-wrapper"><pre><code class="hljs abnf">while (n-- &gt; <span class="hljs-number">0</span>)       pstr[n] <span class="hljs-operator">=</span> c<span class="hljs-comment">; </span></code></pre></div><p>在最后一轮循环开始时，n的值为1。由于n−−意味着先使用这个值，然后将其递减，因此while循环测试条件将对1和0进行比较，发现 测试为true，循环继续。测试后，函数将n减为0，因此pstr[0]是最后一个被设置为c的元素。之所以从后向前（而不是从前向后）填充字符 串，是为了避免使用额外的变量。从前向后填充的代码将与下面类似：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(i&lt;n)pstr[i++] = c;</code></pre></div><p>注意，变量pstr的作用域为buildstr函数内，因此该函数结束时，pstr（而不是字符串）使用的内存将被释放。但由于函数返回了pstr的 值，因此程序仍可以通过main( )中的指针ps来访问新建的字符串。 </p><p>当该字符串不再需要时，程序清单7.10中的程序使用delete释放该字符串占用的内存。然后，将ps指向为下一个字符串分配的内存块，然后释放它们。这种设计（让函数返回一个指针，该指针指向new分配的内存）的缺点是，程序员必须记住使用delete。在第12章中，读者将知道C++类如何使用构造函数和析构函数负责为您处理这些细节</p><h2 id="函数和结构"><a href="#函数和结构" class="headerlink" title="函数和结构"></a>函数和结构</h2><p>为结构编写函数比为数组编写函数要简单得多。虽然结构变量和数组一样，都可以存储多个数据项，但在涉及到函数时，结构变量的行为更接近于基本的单值变量。也就是说，与数组不同，结构将其数据组合成单个实体或数据对象，该实体被视为一个整体。前面讲过，可以将一个结构赋给另外一个结构。同样，也可以按值传递结构，就像普通变量那样。在这种情况下，函数将使用原始结构的副本。另外，函数也可以返回结构。与数组名就是数组第一个元素的地址不同的是，结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&amp;。在C语言和C++中，都使用符号&amp;来表示地址运算符；另外，C++还使用该运算符来表示引用变量，这将在第8章讨论。</p><p>使用结构编程时，最直接的方式是像处理基本类型那样来处理结构；也就是说，将结构作为参数传递，并在需要时将结构用作返回值使 用。然而，按值传递结构有一个缺点。如果结构非常大，则复制结构将增加内存要求，降低系统运行的速度。出于这些原因（同时由于最初C语言不允许按值传递结构），许多C程序员倾向于传递结构的地址，然后使用指针来访问结构的内容。C++提供了第三种选择——按引用传递（将在第8章介绍）。下面介绍其他两种传递方式，首先介绍传递和返回整个结构</p><h3 id="传递和返回结构"><a href="#传递和返回结构" class="headerlink" title="传递和返回结构"></a>传递和返回结构</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// travel.cpp -- using structures with functions</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">travel_time</span>&#123;    <span class="hljs-type">int</span> hours;    <span class="hljs-type">int</span> mins;&#125;;<span class="hljs-type">const</span> <span class="hljs-type">int</span> Mins_per_hr = <span class="hljs-number">60</span>;<span class="hljs-function">travel_time <span class="hljs-title">sum</span><span class="hljs-params">(travel_time t1, travel_time t2)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_time</span><span class="hljs-params">(travel_time t)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    travel_time day1 = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">45</span>&#125;;    <span class="hljs-comment">// 5 hrs, 45 min</span>    travel_time day2 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">55</span>&#125;;    <span class="hljs-comment">// 4 hrs, 55 min</span>    travel_time trip = <span class="hljs-built_in">sum</span>(day1, day2);    cout &lt;&lt; <span class="hljs-string">&quot;Two-day total: &quot;</span>;    <span class="hljs-built_in">show_time</span>(trip);    travel_time day3= &#123;<span class="hljs-number">4</span>, <span class="hljs-number">32</span>&#125;;    cout &lt;&lt; <span class="hljs-string">&quot;Three-day total: &quot;</span>;    <span class="hljs-built_in">show_time</span>(<span class="hljs-built_in">sum</span>(trip, day3));    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function">travel_time <span class="hljs-title">sum</span><span class="hljs-params">(travel_time t1, travel_time t2)</span></span><span class="hljs-function"></span>&#123;    travel_time total;    total.mins = (t1.mins + t2.mins) % Mins_per_hr;    total.hours = t1.hours + t2.hours +                  (t1.mins + t2.mins) / Mins_per_hr;    <span class="hljs-keyword">return</span> total;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_time</span><span class="hljs-params">(travel_time t)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; t.hours &lt;&lt; <span class="hljs-string">&quot; hours, &quot;</span>         &lt;&lt; t.mins &lt;&lt; <span class="hljs-string">&quot; minutes\n&quot;</span>;&#125;<span class="hljs-comment">//Two-day total: 10 hours, 40 minutes</span><span class="hljs-comment">//Three-day total: 15 hours, 12 minutes</span></code></pre></div><p>其中，travel_time就像是一个标准的类型名，可被用来声明变量、函数的返回类型和函数的参数类型。由于total和t1变量是travel_time结构，因此可以对它们使用句点成员运算符。由于sum( )函数返回travel_time结构，因此可以将其用作show_time( )函数的参数。由于在默认情况下，C++函数按值传递参数，因此函数调用show_time(sum(trip,day3))将执行函数调用sum(trip, day3)，以获得其返回值。然后，show_time( )调用将sum( )的返回值（而不是函数自身）传递给show_time( )。</p><h3 id="另一个处理结构的函数示例"><a href="#另一个处理结构的函数示例" class="headerlink" title="另一个处理结构的函数示例"></a>另一个处理结构的函数示例</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strctfun.cpp -- functions with a structure argument</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-comment">// structure declarations</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">polar</span>&#123;    <span class="hljs-type">double</span> distance;      <span class="hljs-comment">// distance from origin</span>    <span class="hljs-type">double</span> angle;         <span class="hljs-comment">// direction from origin</span>&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rect</span>&#123;    <span class="hljs-type">double</span> x;             <span class="hljs-comment">// horizontal distance from origin</span>    <span class="hljs-type">double</span> y;             <span class="hljs-comment">// vertical distance from origin</span>&#125;;<span class="hljs-comment">// prototypes</span><span class="hljs-function">polar <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(rect xypos)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_polar</span><span class="hljs-params">(polar dapos)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    rect rplace;    polar pplace;    cout &lt;&lt; <span class="hljs-string">&quot;Enter the x and y values: &quot;</span>;    <span class="hljs-keyword">while</span> (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)  <span class="hljs-comment">// slick use of cin</span>    &#123;        pplace = <span class="hljs-built_in">rect_to_polar</span>(rplace);        <span class="hljs-built_in">show_polar</span>(pplace);        cout &lt;&lt; <span class="hljs-string">&quot;Next two numbers (q to quit): &quot;</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Done.\n&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// convert rectangular to polar coordinates</span><span class="hljs-function">polar <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(rect xypos)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    polar answer;    answer.distance =        <span class="hljs-built_in">sqrt</span>( xypos.x * xypos.x + xypos.y * xypos.y);    answer.angle = <span class="hljs-built_in">atan2</span>(xypos.y, xypos.x);    <span class="hljs-keyword">return</span> answer;      <span class="hljs-comment">// returns a polar structure</span>&#125;<span class="hljs-comment">// show polar coordinates, converting angle to degrees</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_polar</span> <span class="hljs-params">(polar dapos)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">const</span> <span class="hljs-type">double</span> Rad_to_deg = <span class="hljs-number">57.29577951</span>;    cout &lt;&lt; <span class="hljs-string">&quot;distance = &quot;</span> &lt;&lt; dapos.distance;    cout &lt;&lt; <span class="hljs-string">&quot;, angle = &quot;</span> &lt;&lt; dapos.angle * Rad_to_deg;    cout &lt;&lt; <span class="hljs-string">&quot; degrees\n&quot;</span>;&#125;</code></pre></div><h3 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h3><p>假设要传递结构的地址而不是整个结构以节省时间和空间，则需要重新编写前面的函数，使用指向结构的指针。首先来看一看如何重新编 写show_polar( )函数。需要修改三个地方：</p><p>调用函数时，将结构的地址（&amp;pplace）而不是结构本身（pplace）传递给它； </p><p>将形参声明为指向polar的指针，即polar *类型。由于函数不应该修改结构，因此使用了const修饰符； </p><p>由于形参是指针而不是结构，因此应间接成员运算符（-&gt;），而不是成员运算符（句点）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strctptr.cpp -- functions with pointer to structure arguments</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-comment">// structure templates</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">polar</span>&#123;    <span class="hljs-type">double</span> distance;      <span class="hljs-comment">// distance from origin</span>    <span class="hljs-type">double</span> angle;         <span class="hljs-comment">// direction from origin</span>&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">rect</span>&#123;    <span class="hljs-type">double</span> x;             <span class="hljs-comment">// horizontal distance from origin</span>    <span class="hljs-type">double</span> y;             <span class="hljs-comment">// vertical distance from origin</span>&#125;;<span class="hljs-comment">// prototypes</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(<span class="hljs-type">const</span> rect * pxy, polar * pda)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_polar</span> <span class="hljs-params">(<span class="hljs-type">const</span> polar * pda)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    rect rplace;    polar pplace;    cout &lt;&lt; <span class="hljs-string">&quot;Enter the x and y values: &quot;</span>;    <span class="hljs-keyword">while</span> (cin &gt;&gt; rplace.x &gt;&gt; rplace.y)    &#123;        <span class="hljs-built_in">rect_to_polar</span>(&amp;rplace, &amp;pplace);    <span class="hljs-comment">// pass addresses</span>        <span class="hljs-built_in">show_polar</span>(&amp;pplace);        <span class="hljs-comment">// pass address</span>        cout &lt;&lt; <span class="hljs-string">&quot;Next two numbers (q to quit): &quot;</span>;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Done.\n&quot;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// show polar coordinates, converting angle to degrees</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_polar</span> <span class="hljs-params">(<span class="hljs-type">const</span> polar * pda)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">const</span> <span class="hljs-type">double</span> Rad_to_deg = <span class="hljs-number">57.29577951</span>;    cout &lt;&lt; <span class="hljs-string">&quot;distance = &quot;</span> &lt;&lt; pda-&gt;distance;    cout &lt;&lt; <span class="hljs-string">&quot;, angle = &quot;</span> &lt;&lt; pda-&gt;angle * Rad_to_deg;    cout &lt;&lt; <span class="hljs-string">&quot; degrees\n&quot;</span>;&#125;<span class="hljs-comment">// convert rectangular to polar coordinates</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rect_to_polar</span><span class="hljs-params">(<span class="hljs-type">const</span> rect * pxy, polar * pda)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    pda-&gt;distance =            <span class="hljs-built_in">sqrt</span>(pxy-&gt;x * pxy-&gt;x + pxy-&gt;y * pxy-&gt;y);    pda-&gt;angle = <span class="hljs-built_in">atan2</span>(pxy-&gt;y, pxy-&gt;x);&#125;<span class="hljs-comment">//Enter the x and y values: 30 40</span><span class="hljs-comment">//distance = 50, angle = 53.1301 degrees</span><span class="hljs-comment">//Next two numbers (q to quit): -100 100</span><span class="hljs-comment">//distance = 141.421, angle = 135 degrees</span><span class="hljs-comment">//Next two numbers (q to quit): q</span><span class="hljs-comment">//Done.</span></code></pre></div><p>从用户的角度来说，程序清单7.13的行为与程序清单7.12相同。它们之间的差别在于，程序清单7.12使用的是结构副本，而程序清单7.13 使用的是指针，让函数能够对原始结构进行操作。 </p><h2 id="函数和string对象"><a href="#函数和string对象" class="headerlink" title="函数和string对象"></a>函数和string对象</h2><p>虽然C-风格字符串和string对象的用途几乎相同，但与数组相比，string对象与结构的更相似。例如，可以将一个结构赋给另一个结构， 也可以将一个对象赋给另一个对象。可以将结构作为完整的实体传递给函数，也可以将对象作为完整的实体进行传递。如果需要多个字符串，可以声明一个string对象数组，而不是二维char数组。</p><div class="code-wrapper"><pre><code class="hljs cpp">/ topfive.cpp -- handling an array of string objects<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> string sa[], <span class="hljs-type">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string list[SIZE];     <span class="hljs-comment">// an array holding 5 string object</span>    cout &lt;&lt; <span class="hljs-string">&quot;Enter your &quot;</span> &lt;&lt; SIZE &lt;&lt; <span class="hljs-string">&quot; favorite astronomical sights:\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++)    &#123;        cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;        <span class="hljs-built_in">getline</span>(cin,list[i]);    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Your list:\n&quot;</span>;    <span class="hljs-built_in">display</span>(list, SIZE);    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> string sa[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; sa[i] &lt;&lt; endl;&#125;</code></pre></div><p>对于该示例，需要指出的一点是，除函数getline( )外，该程序像对待内置类型（如int）一样对待string对象。如果需要string数组，只需使用通常的数组声明格式即可： </p><div class="code-wrapper"><pre><code class="hljs lsl"><span class="hljs-type">string</span> <span class="hljs-type">list</span>[SIZE];</code></pre></div><p>这样，数组list的每个元素都是一个string对象，可以像下面这样使用它：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">getline</span>(cin,list[i]);</code></pre></div><p>同样，形参sa是一个指向string对象的指针，因此sa[i]是一个string对象，可以像下面这样使用它： </p><div class="code-wrapper"><pre><code class="hljs bash">cout &lt;&lt; <span class="hljs-string">i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; sa[i</span>] &lt;&lt; <span class="hljs-string">endl;</span></code></pre></div><h2 id="函数与array对象"><a href="#函数与array对象" class="headerlink" title="函数与array对象"></a>函数与array对象</h2><p>在C++中，类对象是基于结构的，因此结构编程方面的有些考虑因素也适用于类。例如，可按值将对象传递给函数，在这种情况下，函数 处理的是原始对象的副本。另外，也可传递指向对象的指针，这让函数能够操作原始对象。下面来看一个使用C++11模板类array的例子。 </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//arrobj.cpp -- functions with array objects</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> Seasons = <span class="hljs-number">4</span>;<span class="hljs-type">const</span> std::array&lt;std::string, Seasons&gt; Snames =    &#123;<span class="hljs-string">&quot;Spring&quot;</span>, <span class="hljs-string">&quot;Summer&quot;</span>, <span class="hljs-string">&quot;Fall&quot;</span>, <span class="hljs-string">&quot;Winter&quot;</span>&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(std::array&lt;<span class="hljs-type">double</span>, Seasons&gt; * pa)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(std::array&lt;<span class="hljs-type">double</span>, Seasons&gt; da)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    std::array&lt;<span class="hljs-type">double</span>, 4&gt; expenses;    <span class="hljs-built_in">fill</span>(&amp;expenses);    <span class="hljs-built_in">show</span>(expenses);    <span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(std::array&lt;<span class="hljs-type">double</span>, Seasons&gt; * pa)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Seasons; i++)    &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Enter &quot;</span> &lt;&lt; Snames[i] &lt;&lt; <span class="hljs-string">&quot; expenses: &quot;</span>;        std::cin &gt;&gt; (*pa)[i];    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(std::array&lt;<span class="hljs-type">double</span>, Seasons&gt; da)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;\nEXPENSES\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Seasons; i++)    &#123;        std::cout &lt;&lt; Snames[i] &lt;&lt; <span class="hljs-string">&quot;: $&quot;</span> &lt;&lt; da[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;        total += da[i];    &#125;    std::cout &lt;&lt; <span class="hljs-string">&quot;Total: $&quot;</span> &lt;&lt; total &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;&#125;</code></pre></div><p>由于const array对象Snames是在所有函数之前声明的，因此可后面的任何函数定义中使用它。与const Seasons一样，Snames也有整个源代码文件共享。这个程序没有使用编译指令using，因此必须使用std::限定array和string。为简化程序，并将重点放在函数可如何使用对象上，函数fill()没有检查输入是否有效</p><p>函数fill()和show()都有缺点。函数show()存在的问题是，expenses存储了四个double值，而创建一个新对象并将expenses的值复制到其中的效率太低。如果修改该程序，使其处理每月甚至每日的开支，这种问题将更严重。 </p><p>函数fill()使用指针来直接处理原始对象，这避免了上述效率低下的问题，但代价是代码看起来更复杂：</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">fill</span>(&amp;expenses);</code></pre></div><p>cin &gt;&gt; (*pa)[i];</p><p>在最后一条语句中，pa是一个指向array&lt;double, 4&gt;对象的指针，因此*pa为这种对象，而(*pa) [i]是该对象的一个元素。由于运算符优先级 的影响，其中的括号必不可少。这里的逻辑很简单，但增加了犯错的机会。</p><p>使用第8章将讨论的引用可解决效率和表示法两方面的问题。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>C++函数有一种有趣的特点——可以调用自己（然而，与C语言不同的是，C++不允许main( )调用自己），这种功能被称为递归</p><h3 id="包含一个递归调用的递归"><a href="#包含一个递归调用的递归" class="headerlink" title="包含一个递归调用的递归"></a>包含一个递归调用的递归</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// recur.cpp -- using recursion</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countdown</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">countdown</span>(<span class="hljs-number">4</span>);           <span class="hljs-comment">// call the recursive function</span>    <span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">countdown</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; <span class="hljs-string">&quot;Counting down ... &quot;</span> &lt;&lt; n &lt;&lt; &amp;n &lt;&lt; endl;    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)        <span class="hljs-built_in">countdown</span>(n<span class="hljs-number">-1</span>);     <span class="hljs-comment">// function calls itself</span>    cout &lt;&lt; n &lt;&lt; &amp;n &lt;&lt; <span class="hljs-string">&quot;: Kaboom!\n&quot;</span>;&#125;Counting down ... <span class="hljs-number">4</span> <span class="hljs-number">0x16db2371c</span>Counting down ... <span class="hljs-number">3</span> <span class="hljs-number">0x16db236ec</span>Counting down ... <span class="hljs-number">2</span> <span class="hljs-number">0x16db236bc</span>Counting down ... <span class="hljs-number">1</span> <span class="hljs-number">0x16db2368c</span>Counting down ... <span class="hljs-number">0</span> <span class="hljs-number">0x16db2365c</span><span class="hljs-number">0</span> <span class="hljs-number">0x16db2365c</span>: Kaboom!<span class="hljs-number">1</span> <span class="hljs-number">0x16db2368c</span>: Kaboom!<span class="hljs-number">2</span> <span class="hljs-number">0x16db236bc</span>: Kaboom!<span class="hljs-number">3</span> <span class="hljs-number">0x16db236ec</span>: Kaboom!<span class="hljs-number">4</span> <span class="hljs-number">0x16db2371c</span>: Kaboom!</code></pre></div><p>注意，每个递归调用都创建自己的一套变量，因此当程序到达第5次调用时，将有5个独立的n变量，其中每个变量的值都不同。</p><h3 id="包含多个递归调用的递归"><a href="#包含多个递归调用的递归" class="headerlink" title="包含多个递归调用的递归"></a>包含多个递归调用的递归</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// ruler.cpp -- using recursion to subdivide a ruler</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-type">const</span> <span class="hljs-type">int</span> Len = <span class="hljs-number">66</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> Divs = <span class="hljs-number">6</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">subdivide</span><span class="hljs-params">(<span class="hljs-type">char</span> ar[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> level)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">char</span> ruler[Len];    <span class="hljs-type">int</span> i;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; Len - <span class="hljs-number">2</span>; i++)        ruler[i] = <span class="hljs-string">&#x27; &#x27;</span>;    ruler[Len - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-type">int</span> max = Len - <span class="hljs-number">2</span>;    <span class="hljs-type">int</span> min = <span class="hljs-number">0</span>;    ruler[min] = ruler[max] = <span class="hljs-string">&#x27;|&#x27;</span>;    std::cout &lt;&lt; ruler &lt;&lt; std::endl;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= Divs; i++)    &#123;        <span class="hljs-built_in">subdivide</span>(ruler,min,max, i);        std::cout &lt;&lt; ruler &lt;&lt; std::endl;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; Len - <span class="hljs-number">2</span>; j++)            ruler[j] = <span class="hljs-string">&#x27; &#x27;</span>;  <span class="hljs-comment">// reset to blank ruler</span>    &#125;    <span class="hljs-comment">// std::cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">subdivide</span><span class="hljs-params">(<span class="hljs-type">char</span> ar[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> level)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (level == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> mid = (high + low) / <span class="hljs-number">2</span>;    ar[mid] = <span class="hljs-string">&#x27;|&#x27;</span>;    <span class="hljs-built_in">subdivide</span>(ar, low, mid, level - <span class="hljs-number">1</span>);    <span class="hljs-built_in">subdivide</span>(ar, mid, high, level - <span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//|                                                               |</span><span class="hljs-comment">//|                               |                               |</span><span class="hljs-comment">//|               |               |               |               |</span><span class="hljs-comment">//|       |       |       |       |       |       |       |       |</span><span class="hljs-comment">//|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |</span><span class="hljs-comment">//| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |</span><span class="hljs-comment">//|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||</span></code></pre></div><p>subdivide( )函数使用变量level来控制递归层。函数调用自身时，将把level减1，当level为0时，该函数将不再调用自己。注意，subdivide( )调用自己两次，一次针对左半部分，另一次针对右半部分。最初的中点被用作一次调用的右端点和另一次调用的左端点。请注意，调用次数将呈几何级数增长。也就是说，调用一次导致两个调用，然后导致4个调用，再导致8个调用，依此类推。这就是6层调 用能够填充64个元素的原因（2^6=64）。这将不断导致函数调用数（以及存储的变量数）翻倍，因此如果要求的递归层次很多，这种递归方式将是一种糟糕的选择；然而，如果递归层次较少，这将是一种精致而简单的选择。 </p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>与数据项相似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。通常，这些地址对用户而言，既不重要，也没有什么用处，但对程序而言，却很有用。例如，可以编写将另一个函数的地址作为参数的函数。这样第一个函数将能够找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的时间传递不同函数的地址，这意味着可以在不同的时间使用不同的函数</p><h3 id="函数指针的基础知识"><a href="#函数指针的基础知识" class="headerlink" title="函数指针的基础知识"></a>函数指针的基础知识</h3><h4 id="获取函数的地址"><a href="#获取函数的地址" class="headerlink" title="获取函数的地址"></a>获取函数的地址</h4><p>获取函数的地址很简单：只要使用函数名（后面不跟参数）即可。也就是说，如果think( )是一个函数，则think就是该函数的地址。要将函数作为参数进行传递，必须传递函数名。一定要区分传递的是函数的地址还是函数的返回值： </p><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">process</span>（<span class="hljs-variable">think</span>）<span class="hljs-variable">thought</span>（<span class="hljs-function"><span class="hljs-title">think</span>())</span></code></pre></div><p>process( )调用使得process( )函数能够在其内部调用think( )函数。thought( )调用首先调用think( )函数，然后将think( )的返回值传递给 thought( )函数。 </p><h4 id="声明函数指针"><a href="#声明函数指针" class="headerlink" title="声明函数指针"></a>声明函数指针</h4><p>声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。这意味 着声明应指定函数的返回类型以及函数的特征标（参数列表）。也就是说，声明应像函数原型那样指出有关函数的信息</p><div class="code-wrapper"><pre><code class="hljs scss">double (*pf)(int);</code></pre></div><p>通常，要声明指向特定类型的函数的指针，可以首先编写这种函数的原型，然后用（*pf）替换函数名。这样pf就是这类函数的指针。</p><p>为提供正确的运算符优先级，必须在声明中使用括号将<code>*pf</code>括起。括号的优先级比*运算符高，因此<code>*pf（int）</code>意味着pf( )是一个返回指针 的函数，而<code>(*pf)</code>（int）意味着pf是一个指向函数的指针：</p><div class="code-wrapper"><pre><code class="hljs scss">double (*pf)(int);double * <span class="hljs-built_in">pf</span>(int);</code></pre></div><p>正确地声明pf后，便可以将相应函数的地址赋给它：</p><div class="code-wrapper"><pre><code class="hljs abnf">double pam(int)<span class="hljs-comment">;</span>double (*pf)(int)<span class="hljs-comment">;</span><span class="hljs-attribute">pf</span> <span class="hljs-operator">=</span> pam<span class="hljs-comment">;</span></code></pre></div><p>注意，pam( )的特征标和返回类型必须与pf相同。如果不相同，编译器将拒绝这种赋值：</p><h4 id="使用指针来调用函数"><a href="#使用指针来调用函数" class="headerlink" title="使用指针来调用函数:"></a>使用指针来调用函数:</h4><p>现在进入最后一步，即使用指针来调用被指向的函数。线索来自指针声明。前面讲过，（*pf）扮演的角色与函数名相同，因此使用 </p><p>（*pf）时，只需将它看作函数名即可：</p><div class="code-wrapper"><pre><code class="hljs abnf">double pam(int)<span class="hljs-comment">;</span>double (*pf)(int)<span class="hljs-comment">;</span><span class="hljs-attribute">pf</span> <span class="hljs-operator">=</span> pam<span class="hljs-comment">;</span>double x <span class="hljs-operator">=</span> pam(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span>double y <span class="hljs-operator">=</span> (*pf)(<span class="hljs-number">5</span>)<span class="hljs-comment">;</span></code></pre></div><p>实际上，C++也允许像使用函数名那样使用pf： </p><div class="code-wrapper"><pre><code class="hljs abnf">double y <span class="hljs-operator">=</span> pf(<span class="hljs-number">5</span>)<span class="hljs-comment">;</span></code></pre></div><p>第一种格式虽然不太好看，但它给出了强有力的提示——代码正在使用函数指针。 </p><p>为何pf和<code>（*pf）</code>等价呢？一种学派认为，由于pf是函数指针，而*pf 是函数，因此应将<code>（*pf）( )</code>用作函数调用。另一种学派认为，由于函数名是指向该函数的指针，指向函数的指针的行为应与函数名相似，因此应将pf( )用作函数调用使用。C++进行了折衷——这2种方式都是正确的，或者至少是允许的，虽然它们在逻辑上是互相冲突的。</p><h3 id="函数指针示例"><a href="#函数指针示例" class="headerlink" title="函数指针示例"></a>函数指针示例</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// fun_ptr.cpp -- pointers to functions</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">betsy</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">pam</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">// second argument is pointer to a type double function that</span><span class="hljs-comment">// takes a type int argument</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">estimate</span><span class="hljs-params">(<span class="hljs-type">int</span> lines, <span class="hljs-type">double</span> (*pf)(<span class="hljs-type">int</span>))</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">int</span> code;    cout &lt;&lt; <span class="hljs-string">&quot;How many lines of code do you need? &quot;</span>;    cin &gt;&gt; code;    cout &lt;&lt; <span class="hljs-string">&quot;Here&#x27;s Betsy&#x27;s estimate:\n&quot;</span>;    <span class="hljs-built_in">estimate</span>(code, betsy);    cout &lt;&lt; <span class="hljs-string">&quot;Here&#x27;s Pam&#x27;s estimate:\n&quot;</span>;    <span class="hljs-built_in">estimate</span>(code, pam);    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">betsy</span><span class="hljs-params">(<span class="hljs-type">int</span> lns)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0.05</span> * lns;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">pam</span><span class="hljs-params">(<span class="hljs-type">int</span> lns)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0.03</span> * lns + <span class="hljs-number">0.0004</span> * lns * lns;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">estimate</span><span class="hljs-params">(<span class="hljs-type">int</span> lines, <span class="hljs-type">double</span> (*pf)(<span class="hljs-type">int</span>))</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    cout &lt;&lt; lines &lt;&lt; <span class="hljs-string">&quot; lines will take &quot;</span>;    cout &lt;&lt; (*pf)(lines) &lt;&lt; <span class="hljs-string">&quot; hour(s)\n&quot;</span>;&#125;</code></pre></div><h3 id="深入探讨函数指针"><a href="#深入探讨函数指针" class="headerlink" title="深入探讨函数指针"></a>深入探讨函数指针</h3><p>下面是一些函数的原型，它们的特征标和返回类型相同： </p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> ar[],<span class="hljs-type">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> [],<span class="hljs-type">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> * , <span class="hljs-type">int</span>)</span></span>;</code></pre></div><p>这些函数的特征标看似不同，但实际上相同。首先，前面说过，在函数原型中，参数列表const double ar [ ]与const double * ar的含义完全相同。其次，在函数原型中，可以省略标识符。因此，const double ar [ ] 可简化为const double [ ]，而const double * ar可简化为const double *。因此，上述所有函数特征标的含义都相同。另一方面，函数定义必须提供标识符，因此需要使用const double ar [ ]或const double * ar。 </p><p>接下来，假设要声明一个指针，它可指向这三个函数之一。假定该指针名为pa，则只需将目标函数原型中的函数名替换为(*pa)：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * (*p3)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * , <span class="hljs-built_in">int</span>);</code></pre></div><p>可在声明的同时进行初始化：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * (*p3)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * , <span class="hljs-built_in">int</span>) = f1;</code></pre></div><p>使用C++11的自动类型推断功能时，代码要简单得多： </p><div class="code-wrapper"><pre><code class="hljs abnf">auto p3 <span class="hljs-operator">=</span> f1<span class="hljs-comment">;</span></code></pre></div><p>鉴于需要使用三个函数，如果有一个函数指针数组将很方便。这样，将可使用for循环通过指针依次调用每个函数。如何声明这样的数组 呢？显然，这种声明应类似于单个函数指针的声明，但必须在某个地方加上[3]，以指出这是一个包含三个函数指针的数组。问题是在什么地方加上[3]，答案如下（包含初始化）： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * (*pa[<span class="hljs-number">3</span>])(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * , <span class="hljs-built_in">int</span>)=&#123;f1,f2,f3&#125;;</code></pre></div><p>为何将[3]放在这个地方呢？pa是一个包含三个元素的数组，而要声明这样的数组，首先需要使用pa[3]。该声明的其他部分指出了数组包含的元素是什么样的。运算符[]的优先级高于*，因此<code>*pa[3]</code>表明pa是一个包含三个指针的数组。上述声明的其他部分指出了每个指针指向的是什么：特征标为const double *, int，且返回类型为const double *的函数。因此，pa是一个包含三个指针的数组，其中每个指针都指向这样的函数，即将const double *和int作为参数，并返回一个const double *。</p><p>这里能否使用auto呢？不能。自动类型推断只能用于单值初始化，而不能用于初始化列表。但声明数组pa后，声明同样类型的数组就很简单了：    </p><div class="code-wrapper"><pre><code class="hljs abnf">auto pb <span class="hljs-operator">=</span> pa<span class="hljs-comment">;</span></code></pre></div><p>本书前面说过，数组名是指向第一个元素的指针，因此pa和pb都是指向函数指针的指针。 </p><p>如何使用它们来调用函数呢？pa[i]和pb[i]都表示数组中的指针，因此可将任何一种函数调用表示法用于它们： </p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * px = pa[<span class="hljs-number">0</span>](av,<span class="hljs-number">3</span>);<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * py = (*pb[<span class="hljs-number">1</span>])(av,<span class="hljs-number">3</span>);</code></pre></div><p>要获得指向的double值，可使用运算符*：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">double</span> x = *pa[<span class="hljs-number">0</span>](av,<span class="hljs-number">3</span>);<span class="hljs-attribute">double</span> y = *(*pb[<span class="hljs-number">1</span>])(av,<span class="hljs-number">3</span>);</code></pre></div><p>可做的另一件事是创建指向整个数组的指针。由于数组名pa是指向函数指针的指针，因此指向数组的指针将是这样的指针，即它指向指针 的指针。这听起来令人恐怖，但由于可使用单个值对其进行初始化，因 此可使用auto： </p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">auto pc</span> = &amp;pa;</code></pre></div><p>如果您喜欢自己声明，该如何办呢？显然，这种声明应类似于pa的声明，但由于增加了一层间接，因此需要在某个地方添加一个*。具体 地说，如果这个指针名为pd，则需要指出它是一个指针，而不是数组。 这意味着声明的核心部分应为<code>(*pd)[3]</code>，其中的括号让标识符pd与<code>*</code>先结 合：</p><div class="code-wrapper"><pre><code class="hljs smali">*pd[3] //an<span class="hljs-built_in"> array </span>of three pointer(*pd)[3] // a pointer to an<span class="hljs-built_in"> array </span>of 3 element</code></pre></div><p>换句话说，pd是一个指针，它指向一个包含三个元素的数组。这些元素是什么呢？由pa的声明的其他部分描述，结果如下：</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> *(*(*pd[<span class="hljs-number">3</span>]))(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> * ,<span class="hljs-built_in">int</span>)=&amp;pa;</code></pre></div><p>要调用函数，需认识到这样一点：既然pd指向数组，那么<code>*pd</code>就是 数组，而<code>(*pd)[i]</code>是数组中的元素，即函数指针。因此，较简单的函数调 用是<code>(*pd)i</code>，而<code>*(*pd)i</code>是返回的指针指向的值。也可以使用第二种使用指针调用函数的语法：使用<code>(*(*pd)[i])(av,3)</code>来调用函数，而<code>*(*(*pd)[i])(av,3)</code>是指向的double值。 </p><p>请注意pa（它是数组名，表示地址）和&amp;pa之间的差别。正如您在本书前面看到的，在大多数情况下，pa都是数组第一个元素的地址，即 &amp;pa[0]。因此，它是单个指针的地址。但&amp;pa是整个数组（即三个指针块）的地址。从数字上说，pa和&amp;pa的值相同，但它们的类型不同。一种差别是，pa+1为数组中下一个元素的地址，而&amp;pa+1为数组pa后面一 个12字节内存块的地址（这里假定地址为4字节）。另一个差别是，要 得到第一个元素的值，只需对pa解除一次引用，但需要对&amp;pa解除两次 引用：</p><div class="code-wrapper"><pre><code class="hljs 1c">**<span class="hljs-meta">&amp;pa == *pa == pa[0]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// arfupt.cpp -- an array of function pointers</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// various notations, same signatures</span><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span>;<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> [], <span class="hljs-type">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *, <span class="hljs-type">int</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;    <span class="hljs-type">double</span> av[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1112.3</span>, <span class="hljs-number">1542.6</span>, <span class="hljs-number">2227.9</span>&#125;;    <span class="hljs-comment">// pointer to a function</span>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> *(*p1)(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *, <span class="hljs-type">int</span>) = f1;    <span class="hljs-keyword">auto</span> p2 = f2;  <span class="hljs-comment">// C++0x automatic type deduction</span>    <span class="hljs-comment">// pre-C++0x can use the following code instead</span>    <span class="hljs-comment">// const double *(*p2)(const double *, int) = f2;</span>    cout &lt;&lt; <span class="hljs-string">&quot;Using pointers to functions:\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot; Address  Value\n&quot;</span>;    cout &lt;&lt;  (*p1)(av,<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; *(*p1)(av,<span class="hljs-number">3</span>) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-built_in">p2</span>(av,<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; *<span class="hljs-built_in">p2</span>(av,<span class="hljs-number">3</span>) &lt;&lt; endl;    <span class="hljs-comment">// pa an array of pointers</span>    <span class="hljs-comment">// auto doesn&#x27;t work with list initialization</span>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> *(*pa[<span class="hljs-number">3</span>])(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *, <span class="hljs-type">int</span>) = &#123;f1,f2,f3&#125;;    <span class="hljs-comment">// but it does work for initializing to a single value</span>    <span class="hljs-comment">// pb a pointer to first element of pa</span>    <span class="hljs-keyword">auto</span> pb = pa;    <span class="hljs-comment">// pre-C++0x can use the following code instead</span>    <span class="hljs-comment">// const double *(**pb)(const double *, int) = pa;</span>    cout &lt;&lt; <span class="hljs-string">&quot;\nUsing an array of pointers to functions:\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot; Address  Value\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)        cout &lt;&lt; pa[i](av,<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; *pa[i](av,<span class="hljs-number">3</span>) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;\nUsing a pointer to a pointer to a function:\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot; Address  Value\n&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)        cout &lt;&lt; pb[i](av,<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; *pb[i](av,<span class="hljs-number">3</span>) &lt;&lt; endl;    <span class="hljs-comment">// what about a pointer to an array of function pointers</span>    cout &lt;&lt; <span class="hljs-string">&quot;\nUsing pointers to an array of pointers:\n&quot;</span>;    cout &lt;&lt; <span class="hljs-string">&quot; Address  Value\n&quot;</span>;    <span class="hljs-comment">// easy way to declare pc</span>    <span class="hljs-keyword">auto</span> pc = &amp;pa;    <span class="hljs-comment">// pre-C++0x can use the following code instead</span>    <span class="hljs-comment">// const double *(*(*pc)[3])(const double *, int) = &amp;pa;</span>    cout &lt;&lt; (*pc)[<span class="hljs-number">0</span>](av,<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; *(*pc)[<span class="hljs-number">0</span>](av,<span class="hljs-number">3</span>) &lt;&lt; endl;    <span class="hljs-comment">// hard way to declare pd</span>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> *(*(*pd)[<span class="hljs-number">3</span>])(<span class="hljs-type">const</span> <span class="hljs-type">double</span> *, <span class="hljs-type">int</span>) = &amp;pa;    <span class="hljs-comment">// store return value in pdb</span>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> * pdb = (*pd)[<span class="hljs-number">1</span>](av,<span class="hljs-number">3</span>);    cout &lt;&lt; pdb &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; *pdb &lt;&lt; endl;    <span class="hljs-comment">// alternative notation</span>    cout &lt;&lt; (*(*pd)[<span class="hljs-number">2</span>])(av,<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; *(*(*pd)[<span class="hljs-number">2</span>])(av,<span class="hljs-number">3</span>) &lt;&lt; endl;    <span class="hljs-comment">// cin.get();</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// some rather dull functions</span><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> * ar, <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> ar;&#125;<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> ar+<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">double</span> * <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span> ar[], <span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> ar+<span class="hljs-number">2</span>;&#125;</code></pre></div><h3 id="使用typedef进行简化"><a href="#使用typedef进行简化" class="headerlink" title="使用typedef进行简化"></a>使用typedef进行简化</h3><p>除auto外，C++还提供了其他简化声明的工具。您可能还记得，第5章说过，关键字typedef让您能够创建类型别名： </p><div class="code-wrapper"><pre><code class="hljs d"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">double</span> <span class="hljs-built_in">real</span> ;</code></pre></div><p>这里采用的方法是，将别名当做标识符进行声明，并在开头使用关键字typedef。</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> *(*p_fun)(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> *,<span class="hljs-built_in">int</span>);p_fun p1 = f1;</code></pre></div><p>然后使用这个别名来简化代码：</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">p_fun</span> pa[<span class="hljs-number">3</span>]=&#123;<span class="hljs-built_in">f1</span>,<span class="hljs-built_in">f2</span>,<span class="hljs-built_in">f3</span>&#125;<span class="hljs-comment">;</span><span class="hljs-symbol">p_fun</span> (*pd)[<span class="hljs-number">3</span>] = &amp;pa<span class="hljs-comment">;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>while循环中return、break、continue的区别</title>
    <link href="/2022/12/29/while%E5%BE%AA%E7%8E%AF%E4%B8%ADreturn%E3%80%81break%E3%80%81continue%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/12/29/while%E5%BE%AA%E7%8E%AF%E4%B8%ADreturn%E3%80%81break%E3%80%81continue%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>搜集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseClone.js</title>
    <link href="/2022/12/28/baseClone-js/"/>
    <url>/2022/12/28/baseClone-js/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Stack</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Stack.js&quot;</span>;<span class="hljs-keyword">import</span> arrayEach <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./arrayEach.js&quot;</span>;<span class="hljs-keyword">import</span> assignValue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./assignValue.js&quot;</span>;<span class="hljs-keyword">import</span> cloneBuffer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./cloneBuffer.js&quot;</span>;<span class="hljs-keyword">import</span> copyArray <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./copyArray.js&quot;</span>;<span class="hljs-keyword">import</span> copyObject <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./copyObject.js&quot;</span>;<span class="hljs-keyword">import</span> cloneArrayBuffer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./cloneArrayBuffer.js&quot;</span>;<span class="hljs-keyword">import</span> cloneDataView <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./cloneDataView.js&quot;</span>;<span class="hljs-keyword">import</span> cloneRegExp <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./cloneRegExp.js&quot;</span>;<span class="hljs-keyword">import</span> cloneSymbol <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./cloneSymbol.js&quot;</span>;<span class="hljs-keyword">import</span> cloneTypedArray <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./cloneTypedArray.js&quot;</span>;<span class="hljs-keyword">import</span> copySymbols <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./copySymbols.js&quot;</span>;<span class="hljs-keyword">import</span> copySymbolsIn <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./copySymbolsIn.js&quot;</span>;<span class="hljs-keyword">import</span> getAllKeys <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./getAllKeys.js&quot;</span>;<span class="hljs-keyword">import</span> getAllKeysIn <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./getAllKeysIn.js&quot;</span>;<span class="hljs-keyword">import</span> getTag <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./getTag.js&quot;</span>;<span class="hljs-keyword">import</span> initCloneObject <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./initCloneObject.js&quot;</span>;<span class="hljs-keyword">import</span> isBuffer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../isBuffer.js&quot;</span>;<span class="hljs-keyword">import</span> isObject <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../isObject.js&quot;</span>;<span class="hljs-keyword">import</span> isTypedArray <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../isTypedArray.js&quot;</span>;<span class="hljs-keyword">import</span> keys <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../keys.js&quot;</span>;<span class="hljs-keyword">import</span> keysIn <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../keysIn.js&quot;</span>;<span class="hljs-comment">/** Used to compose bitmasks for cloning. */</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLONE_DEEP_FLAG</span> = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLONE_FLAT_FLAG</span> = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span> = <span class="hljs-number">4</span>;<span class="hljs-comment">/** `Object#toString` result references. */</span><span class="hljs-keyword">const</span> argsTag = <span class="hljs-string">&quot;[object Arguments]&quot;</span>;<span class="hljs-keyword">const</span> arrayTag = <span class="hljs-string">&quot;[object Array]&quot;</span>;<span class="hljs-keyword">const</span> boolTag = <span class="hljs-string">&quot;[object Boolean]&quot;</span>;<span class="hljs-keyword">const</span> dateTag = <span class="hljs-string">&quot;[object Date]&quot;</span>;<span class="hljs-keyword">const</span> errorTag = <span class="hljs-string">&quot;[object Error]&quot;</span>;<span class="hljs-keyword">const</span> mapTag = <span class="hljs-string">&quot;[object Map]&quot;</span>;<span class="hljs-keyword">const</span> numberTag = <span class="hljs-string">&quot;[object Number]&quot;</span>;<span class="hljs-keyword">const</span> objectTag = <span class="hljs-string">&quot;[object Object]&quot;</span>;<span class="hljs-keyword">const</span> regexpTag = <span class="hljs-string">&quot;[object RegExp]&quot;</span>;<span class="hljs-keyword">const</span> setTag = <span class="hljs-string">&quot;[object Set]&quot;</span>;<span class="hljs-keyword">const</span> stringTag = <span class="hljs-string">&quot;[object String]&quot;</span>;<span class="hljs-keyword">const</span> symbolTag = <span class="hljs-string">&quot;[object Symbol]&quot;</span>;<span class="hljs-keyword">const</span> weakMapTag = <span class="hljs-string">&quot;[object WeakMap]&quot;</span>;<span class="hljs-keyword">const</span> arrayBufferTag = <span class="hljs-string">&quot;[object ArrayBuffer]&quot;</span>;<span class="hljs-keyword">const</span> dataViewTag = <span class="hljs-string">&quot;[object DataView]&quot;</span>;<span class="hljs-keyword">const</span> float32Tag = <span class="hljs-string">&quot;[object Float32Array]&quot;</span>;<span class="hljs-keyword">const</span> float64Tag = <span class="hljs-string">&quot;[object Float64Array]&quot;</span>;<span class="hljs-keyword">const</span> int8Tag = <span class="hljs-string">&quot;[object Int8Array]&quot;</span>;<span class="hljs-keyword">const</span> int16Tag = <span class="hljs-string">&quot;[object Int16Array]&quot;</span>;<span class="hljs-keyword">const</span> int32Tag = <span class="hljs-string">&quot;[object Int32Array]&quot;</span>;<span class="hljs-keyword">const</span> uint8Tag = <span class="hljs-string">&quot;[object Uint8Array]&quot;</span>;<span class="hljs-keyword">const</span> uint8ClampedTag = <span class="hljs-string">&quot;[object Uint8ClampedArray]&quot;</span>;<span class="hljs-keyword">const</span> uint16Tag = <span class="hljs-string">&quot;[object Uint16Array]&quot;</span>;<span class="hljs-keyword">const</span> uint32Tag = <span class="hljs-string">&quot;[object Uint32Array]&quot;</span>;<span class="hljs-comment">/** Used to identify `toStringTag` values supported by `clone`. */</span><span class="hljs-comment">/**定义那些类型是可以拷贝那些是不可以拷贝的 */</span><span class="hljs-keyword">const</span> cloneableTags = &#123;&#125;;cloneableTags[argsTag] =  cloneableTags[arrayTag] =  cloneableTags[arrayBufferTag] =  cloneableTags[dataViewTag] =  cloneableTags[boolTag] =  cloneableTags[dateTag] =  cloneableTags[float32Tag] =  cloneableTags[float64Tag] =  cloneableTags[int8Tag] =  cloneableTags[int16Tag] =  cloneableTags[int32Tag] =  cloneableTags[mapTag] =  cloneableTags[numberTag] =  cloneableTags[objectTag] =  cloneableTags[regexpTag] =  cloneableTags[setTag] =  cloneableTags[stringTag] =  cloneableTags[symbolTag] =  cloneableTags[uint8Tag] =  cloneableTags[uint8ClampedTag] =  cloneableTags[uint16Tag] =  cloneableTags[uint32Tag] =    <span class="hljs-literal">true</span>;cloneableTags[errorTag] = cloneableTags[weakMapTag] = <span class="hljs-literal">false</span>;<span class="hljs-comment">/** Used to check objects for own properties. */</span><span class="hljs-comment">/**用于检测是否是实例对象本身的属性，而不是原型链上的属性 */</span><span class="hljs-keyword">const</span> hasOwnProperty = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes an object clone based on its `toStringTag`.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * **Note:** This function only supports cloning values with tags of</span><span class="hljs-comment"> * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@private</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; object The object to clone.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; tag The `toStringTag` of the object to clone.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; [isDeep] Specify a deep clone.</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Object</span>&#125; Returns the initialized clone.</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**根据数据类型初始化创建对应的类型· */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">initCloneByTag</span>(<span class="hljs-params">object, tag, isDeep</span>) &#123;  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Ctor</span> = object.<span class="hljs-property">constructor</span>;  <span class="hljs-keyword">switch</span> (tag) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-attr">arrayBufferTag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneArrayBuffer</span>(object);    <span class="hljs-keyword">case</span> <span class="hljs-attr">boolTag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">dateTag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(+object);    <span class="hljs-keyword">case</span> <span class="hljs-attr">dataViewTag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneDataView</span>(object, isDeep);    <span class="hljs-keyword">case</span> <span class="hljs-attr">float32Tag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">float64Tag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">int8Tag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">int16Tag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">int32Tag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">uint8Tag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">uint8ClampedTag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">uint16Tag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">uint32Tag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneTypedArray</span>(object, isDeep);    <span class="hljs-keyword">case</span> <span class="hljs-attr">mapTag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>();    <span class="hljs-keyword">case</span> <span class="hljs-attr">numberTag</span>:    <span class="hljs-keyword">case</span> <span class="hljs-attr">stringTag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>(object);    <span class="hljs-keyword">case</span> <span class="hljs-attr">regexpTag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneRegExp</span>(object);    <span class="hljs-keyword">case</span> <span class="hljs-attr">setTag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ctor</span>();    <span class="hljs-keyword">case</span> <span class="hljs-attr">symbolTag</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneSymbol</span>(object);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes an array clone.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@private</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Array</span>&#125; array The array to clone.</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Array</span>&#125; Returns the initialized clone.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">initCloneArray</span>(<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> array.<span class="hljs-title function_">constructor</span>(<span class="hljs-params">length</span>);  <span class="hljs-comment">// Add properties assigned by `RegExp#exec`.</span>  <span class="hljs-keyword">if</span> (    length &amp;&amp;    <span class="hljs-keyword">typeof</span> array[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;string&quot;</span> &amp;&amp;    hasOwnProperty.<span class="hljs-title function_">call</span>(array, <span class="hljs-string">&quot;index&quot;</span>)  ) &#123;    result.<span class="hljs-property">index</span> = array.<span class="hljs-property">index</span>;    result.<span class="hljs-property">input</span> = array.<span class="hljs-property">input</span>;  &#125;  <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * The base implementation of `clone` and `cloneDeep` which tracks</span><span class="hljs-comment"> * traversed objects.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@private</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; value The value to clone.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; bitmask The bitmask flags.</span><span class="hljs-comment"> *  1 - Deep clone</span><span class="hljs-comment"> *  2 - Flatten inherited properties</span><span class="hljs-comment"> *  4 - Clone symbols</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; [customizer] The function to customize cloning.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">string</span>&#125; [key] The key of `value`.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; [object] The parent object of `value`.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; [stack] Tracks traversed objects and their clone counterparts.</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">*</span>&#125; Returns the cloned value.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">baseClone</span>(<span class="hljs-params">value, bitmask, customizer, key, object, stack</span>) &#123;  <span class="hljs-keyword">let</span> result;  <span class="hljs-keyword">const</span> isDeep = bitmask &amp; <span class="hljs-variable constant_">CLONE_DEEP_FLAG</span>;  <span class="hljs-comment">//展平继承的属性</span>  <span class="hljs-keyword">const</span> isFlat = bitmask &amp; <span class="hljs-variable constant_">CLONE_FLAT_FLAG</span>;  <span class="hljs-keyword">const</span> isFull = bitmask &amp; <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span>;  <span class="hljs-comment">//判断是否有传入的处理函数</span>  <span class="hljs-keyword">if</span> (customizer) &#123;    result = object ? <span class="hljs-title function_">customizer</span>(value, key, object, stack) : <span class="hljs-title function_">customizer</span>(value);  &#125;  <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">//如果不是object，直接返回</span>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(value)) &#123;    <span class="hljs-keyword">return</span> value;  &#125;  <span class="hljs-comment">//判断是否是数组</span>  <span class="hljs-keyword">const</span> isArr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value);  <span class="hljs-comment">//获取数据类型</span>  <span class="hljs-keyword">const</span> tag = <span class="hljs-title function_">getTag</span>(value);  <span class="hljs-comment">//如果是数组，对数组进行处理</span>  <span class="hljs-keyword">if</span> (isArr) &#123;    result = <span class="hljs-title function_">initCloneArray</span>(value);    <span class="hljs-keyword">if</span> (!isDeep) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">copyArray</span>(value, result);    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//是否是function</span>    <span class="hljs-keyword">const</span> isFunc = <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;function&quot;</span>;    <span class="hljs-comment">//如果是buffer</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isBuffer</span>(value)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">cloneBuffer</span>(value, isDeep);    &#125;    <span class="hljs-comment">//object 或者类数组对象 或者是函数</span>    <span class="hljs-keyword">if</span> (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) &#123;      <span class="hljs-comment">//既不是函数也不需要展开继承属性</span>      result = isFlat || isFunc ? &#123;&#125; : <span class="hljs-title function_">initCloneObject</span>(value);      <span class="hljs-keyword">if</span> (!isDeep) &#123;        <span class="hljs-keyword">return</span> isFlat          ? <span class="hljs-title function_">copySymbolsIn</span>(value, <span class="hljs-title function_">copyObject</span>(value, <span class="hljs-title function_">keysIn</span>(value), result))          : <span class="hljs-title function_">copySymbols</span>(value, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(result, value));      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//如果是函数或者是不可复制内容，则返回该值或者空对象</span>      <span class="hljs-keyword">if</span> (isFunc || !cloneableTags[tag]) &#123;        <span class="hljs-keyword">return</span> object ? value : &#123;&#125;;      &#125;      result = <span class="hljs-title function_">initCloneByTag</span>(value, tag, isDeep);    &#125;  &#125;  <span class="hljs-comment">//检查是否有循环引用，如果有，则返回他的clone</span>  <span class="hljs-comment">// Check for circular references and return its corresponding clone.</span>  stack || (stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>());  <span class="hljs-keyword">const</span> stacked = stack.<span class="hljs-title function_">get</span>(value);  <span class="hljs-keyword">if</span> (stacked) &#123;    <span class="hljs-keyword">return</span> stacked;  &#125;  stack.<span class="hljs-title function_">set</span>(value, result);  <span class="hljs-comment">//map类型</span>  <span class="hljs-keyword">if</span> (tag == mapTag) &#123;    value.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">subValue, key</span>) =&gt;</span> &#123;      result.<span class="hljs-title function_">set</span>(        key,        <span class="hljs-title function_">baseClone</span>(subValue, bitmask, customizer, key, value, stack)      );    &#125;);    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">//set类型</span>  <span class="hljs-keyword">if</span> (tag == setTag) &#123;    value.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">subValue</span>) =&gt;</span> &#123;      result.<span class="hljs-title function_">add</span>(        <span class="hljs-title function_">baseClone</span>(subValue, bitmask, customizer, subValue, value, stack)      );    &#125;);    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">//TypedArray类型</span>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTypedArray</span>(value)) &#123;    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-keyword">const</span> keysFunc = isFull    ? isFlat      ? getAllKeysIn      : getAllKeys    : isFlat    ? keysIn    : keys;  <span class="hljs-keyword">const</span> props = isArr ? <span class="hljs-literal">undefined</span> : <span class="hljs-title function_">keysFunc</span>(value);  <span class="hljs-title function_">arrayEach</span>(props || value, <span class="hljs-function">(<span class="hljs-params">subValue, key</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (props) &#123;      key = subValue;      subValue = value[key];    &#125;    <span class="hljs-comment">// Recursively populate clone (susceptible to call stack limits).</span>    <span class="hljs-title function_">assignValue</span>(      result,      key,      <span class="hljs-title function_">baseClone</span>(subValue, bitmask, customizer, key, value, stack)    );  &#125;);  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>lodash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lodash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lodash</title>
    <link href="/2022/12/26/lodash/"/>
    <url>/2022/12/26/lodash/</url>
    
    <content type="html"><![CDATA[<h2 id="“Array”-Methods"><a href="#“Array”-Methods" class="headerlink" title="“Array” Methods"></a><code>“Array” Methods</code></h2><h3 id="chunk-array-size-1"><a href="#chunk-array-size-1" class="headerlink" title="_.chunk(array, [size=1])"></a><code>_.chunk(array, [size=1])</code></h3><p>这个方法可以将一位数组转化成二维数组，第二个参数是指每一个子数组中的元素个数</p><h4 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>array</code> <em>(Array)</em>: The array to process.</li><li><code>[size=1]</code> <em>(number)</em>: The length of each chunk</li></ol><h4 id="Returns"><a href="#Returns" class="headerlink" title="Returns"></a>Returns</h4><p><em>(Array)</em>: Returns the new array of chunks.</p><div class="code-wrapper"><pre><code class="hljs js">_.<span class="hljs-title function_">chunk</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>], <span class="hljs-number">2</span>);<span class="hljs-comment">// =&gt; [[&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;c&#x27;, &#x27;d&#x27;]]</span> _.<span class="hljs-title function_">chunk</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>], <span class="hljs-number">3</span>);<span class="hljs-comment">// =&gt; [[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;]]</span></code></pre></div><p>解析</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">chunk</span>(<span class="hljs-params">array, size = <span class="hljs-number">1</span></span>) &#123;  <span class="hljs-comment">//和0进行比较，避免size出现负数</span>  size = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title function_">toInteger</span>(size), <span class="hljs-number">0</span>)  <span class="hljs-comment">//获取length</span>  <span class="hljs-keyword">const</span> length = array == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : array.<span class="hljs-property">length</span>  <span class="hljs-comment">//避免length不存在或者为0</span>  <span class="hljs-keyword">if</span> (!length || size &lt; <span class="hljs-number">1</span>) &#123;    <span class="hljs-comment">//直接返回空数组</span>    <span class="hljs-keyword">return</span> []  &#125;  <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> resIndex = <span class="hljs-number">0</span>  <span class="hljs-comment">//需要定义多少个chunk</span>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(length / size))<span class="hljs-comment">//while循环</span>  <span class="hljs-keyword">while</span> (index &lt; length) &#123;    result[resIndex++] = <span class="hljs-title function_">slice</span>(array, index, (index += size))  &#125;  <span class="hljs-keyword">return</span> result&#125;</code></pre></div><h3 id="compact-array"><a href="#compact-array" class="headerlink" title="_.compact(array)"></a><code>_.compact(array)</code></h3><p>返回一个新的数组，删除掉为falsey的value，例如false,NaN,undefined,””,0,null,</p><h4 id="Arguments-1"><a href="#Arguments-1" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>array</code> <em>(Array)</em>: The array to compact.</li></ol><h4 id="Returns-1"><a href="#Returns-1" class="headerlink" title="Returns"></a>Returns</h4><p><em>(Array)</em>: Returns the new array of filtered values.</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs js">_.<span class="hljs-title function_">compact</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">3</span>]);<span class="hljs-comment">// =&gt; [1, 2, 3]</span></code></pre></div><p>源码</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compact</span>(<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">let</span> resIndex = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> result = []  <span class="hljs-keyword">if</span> (array == <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> result  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> array) &#123;    <span class="hljs-keyword">if</span> (value) &#123;      result[resIndex++] = value    &#125;  &#125;  <span class="hljs-keyword">return</span> result&#125;</code></pre></div><h3 id="concat-array-values"><a href="#concat-array-values" class="headerlink" title="_.concat(array, [values])"></a><code>_.concat(array, [values])</code></h3><p>将多个值连接成一个新的数组</p><h4 id="Arguments-2"><a href="#Arguments-2" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>array</code> <em>(Array)</em>: The array to concatenate.</li><li><code>[values]</code> <em>(…*)</em>: The values to concatenate.</li></ol><h4 id="Returns-2"><a href="#Returns-2" class="headerlink" title="Returns"></a>Returns</h4><p><em>(Array)</em>: Returns the new concatenated array.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>];<span class="hljs-keyword">var</span> other = _.<span class="hljs-title function_">concat</span>(array, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>], [[<span class="hljs-number">4</span>]]); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(other);<span class="hljs-comment">// =&gt; [1, 2, 3, [4]]</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array);<span class="hljs-comment">// =&gt; [1]</span></code></pre></div><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">concat</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">var</span> length = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>;      <span class="hljs-keyword">if</span> (!length) &#123;        <span class="hljs-keyword">return</span> [];      &#125;      <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>(length - <span class="hljs-number">1</span>),          array = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>],          index = length;      <span class="hljs-keyword">while</span> (index--) &#123;        args[index - <span class="hljs-number">1</span>] = <span class="hljs-variable language_">arguments</span>[index];      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">arrayPush</span>(<span class="hljs-title function_">isArray</span>(array) ? <span class="hljs-title function_">copyArray</span>(array) : [array], <span class="hljs-title function_">baseFlatten</span>(args, <span class="hljs-number">1</span>));    &#125;</code></pre></div><h3 id="difference-array-values"><a href="#difference-array-values" class="headerlink" title="_.difference(array, [values])"></a><code>_.difference(array, [values])</code></h3><p>比较两个数组之间的差异，返回一个新的数组，包含第一个数组的值但不含另外一个数组</p><h4 id="Arguments-3"><a href="#Arguments-3" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>array</code> <em>(Array)</em>: The array to inspect.</li><li><code>[values]</code> <em>(…Array)</em>: The values to exclude.</li></ol><h4 id="Returns-3"><a href="#Returns-3" class="headerlink" title="Returns"></a>Returns</h4><p><em>(Array)</em>: Returns the new array of filtered values.</p><h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">_</span>.difference([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<span class="hljs-meta"> [2, 3]);</span><span class="hljs-meta">// =&gt; [1]</span></code></pre></div><h4 id="source-1"><a href="#source-1" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">difference</span>(<span class="hljs-params">array, ...values</span>) &#123;  <span class="hljs-comment">//判断是否是数组或者类数组</span>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isArrayLikeObject</span>(array)    ? <span class="hljs-title function_">baseDifference</span>(array, <span class="hljs-title function_">baseFlatten</span>(values, <span class="hljs-number">1</span>, isArrayLikeObject, <span class="hljs-literal">true</span>))    : []&#125;</code></pre></div><h3 id="differenceBy-array-values-iteratee-identity"><a href="#differenceBy-array-values-iteratee-identity" class="headerlink" title="_.differenceBy(array, [values], [iteratee=_.identity])"></a><code>_.differenceBy(array, [values], [iteratee=_.identity])</code></h3><p>这个方法和第一个difference类似，但是她可以穿入一个方法，数组的每个值都会执行这个方法，并返回一个新的数组，执行完iteratee，过滤第一个·数组，不包含第二个数组</p><h4 id="Arguments-4"><a href="#Arguments-4" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>array</code> <em>(Array)</em>: The array to inspect.</li><li><code>[values]</code> <em>(…Array)</em>: The values to exclude.</li><li><code>[iteratee=_.identity]</code> <em>(Function)</em>: The iteratee invoked per element.</li></ol><h4 id="Returns-4"><a href="#Returns-4" class="headerlink" title="Returns"></a>Returns</h4><p><em>(Array)</em>: Returns the new array of filtered values.</p><h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js">_.<span class="hljs-title function_">differenceBy</span>([<span class="hljs-number">2.1</span>, <span class="hljs-number">1.2</span>], [<span class="hljs-number">2.3</span>, <span class="hljs-number">3.4</span>], <span class="hljs-title class_">Math</span>.<span class="hljs-property">floor</span>);<span class="hljs-comment">// =&gt; [1.2]</span> <span class="hljs-comment">// The `_.property` iteratee shorthand.</span>_.<span class="hljs-title function_">differenceBy</span>([&#123; <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">2</span> &#125;, &#123; <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">1</span> &#125;], [&#123; <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">1</span> &#125;], <span class="hljs-string">&#x27;x&#x27;</span>);<span class="hljs-comment">// =&gt; [&#123; &#x27;x&#x27;: 2 &#125;]</span></code></pre></div><h4 id="source-2"><a href="#source-2" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">differenceBy</span>(<span class="hljs-params">array, ...values</span>) &#123;  <span class="hljs-keyword">let</span> iteratee = <span class="hljs-title function_">last</span>(values)  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArrayLikeObject</span>(iteratee)) &#123;    iteratee = <span class="hljs-literal">undefined</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isArrayLikeObject</span>(array)    ? <span class="hljs-title function_">baseDifference</span>(array, <span class="hljs-title function_">baseFlatten</span>(values, <span class="hljs-number">1</span>, isArrayLikeObject, <span class="hljs-literal">true</span>), iteratee)    : []&#125;</code></pre></div><h3 id="join-array-separator-39-39"><a href="#join-array-separator-39-39" class="headerlink" title="_.join(array, [separator=&#39;,&#39;])"></a><code>_.join(array, [separator=&#39;,&#39;])</code></h3><p>将数组转化成字符串，以第二个参数作为拼接</p><h4 id="Arguments-5"><a href="#Arguments-5" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>array</code> <em>(Array)</em>: The array to convert.</li><li><code>[separator=&#39;,&#39;]</code> <em>(string)</em>: The element separator.</li></ol><h4 id="Returns-5"><a href="#Returns-5" class="headerlink" title="Returns"></a>Returns</h4><p><em>(string)</em>: Returns the joined string.</p><h4 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs awk">_.join([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], <span class="hljs-string">&#x27;~&#x27;</span>);<span class="hljs-regexp">//</span> =&gt; <span class="hljs-string">&#x27;a~b~c&#x27;</span></code></pre></div><h4 id="source-3"><a href="#source-3" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">join</span>(<span class="hljs-params">array, separator</span>) &#123;  <span class="hljs-comment">//nativeJoin===Array.prototype.join</span>   <span class="hljs-keyword">return</span> array == <span class="hljs-literal">null</span> ? <span class="hljs-string">&#x27;&#x27;</span> : nativeJoin.<span class="hljs-title function_">call</span>(array, separator); &#125;</code></pre></div><h3 id="last-array"><a href="#last-array" class="headerlink" title="_.last(array)"></a><code>_.last(array)</code></h3><h4 id="Arguments-6"><a href="#Arguments-6" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>array</code> <em>(Array)</em>: The array to query.</li></ol><h4 id="Returns-6"><a href="#Returns-6" class="headerlink" title="Returns"></a>Returns</h4><p><em>(*)</em>: Returns the last element of <code>array</code>.</p><h4 id="Example-4"><a href="#Example-4" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js">_.<span class="hljs-title function_">last</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<span class="hljs-comment">// =&gt; 3</span></code></pre></div><h4 id="source-4"><a href="#source-4" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">last</span>(<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">const</span> length = array == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : array.<span class="hljs-property">length</span>  <span class="hljs-keyword">return</span> length ? array[length - <span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>&#125;</code></pre></div><h2 id="“Lang”-Methods"><a href="#“Lang”-Methods" class="headerlink" title="“Lang” Methods"></a><code>“Lang” Methods</code></h2><h3 id="castArray-value"><a href="#castArray-value" class="headerlink" title="_.castArray(value)"></a><code>_.castArray(value)</code></h3><h3 id="clone-value"><a href="#clone-value" class="headerlink" title="_.clone(value)"></a><code>_.clone(value)</code></h3><p>浅拷贝</p><p>此方法大致基于结构化克隆算法，支持arrays, array buffers, booleans, date objects,、Maps、number、object、正则表达式、Set、字符串、 symbols, and typed arrays。 arguments 对象自己的可枚举属性被克隆为普通对象。对于错误对象、函数、DOM 节点和 WeakMaps 等不可克隆的值，将返回一个空对象。</p><h4 id="Arguments-7"><a href="#Arguments-7" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>value</code> <em>(*)</em>: The value to clone.</li></ol><h4 id="Returns-7"><a href="#Returns-7" class="headerlink" title="Returns"></a>Returns</h4><p><em>(*)</em>: Returns the cloned value.</p><h4 id="Example-5"><a href="#Example-5" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> objects = [&#123; <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span> &#125;]; <span class="hljs-keyword">var</span> shallow = _.<span class="hljs-title function_">clone</span>(objects);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shallow[<span class="hljs-number">0</span>] === objects[<span class="hljs-number">0</span>]);<span class="hljs-comment">// =&gt; true</span></code></pre></div><h4 id="source-5"><a href="#source-5" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/** Used to compose bitmasks for cloning. */</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span> = <span class="hljs-number">4</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">baseClone</span>(value, <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span>)&#125;</code></pre></div><h3 id="cloneDeep-value"><a href="#cloneDeep-value" class="headerlink" title="_.cloneDeep(value)"></a><code>_.cloneDeep(value)</code></h3><p>这个方法类似<a href="https://www.lodashjs.com/docs/lodash.cloneDeep#clone"><code>_.clone</code></a>，除了它会递归拷贝 <code>value</code>。（注：也叫深拷贝）。</p><h4 id="Arguments-8"><a href="#Arguments-8" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>value</code> <em>(*)</em>: The value to recursively clone.</li></ol><h4 id="Returns-8"><a href="#Returns-8" class="headerlink" title="Returns"></a>Returns</h4><p><em>(*)</em>: Returns the deep cloned value.</p><h4 id="Example-6"><a href="#Example-6" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> objects = [&#123; <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span> &#125;]; <span class="hljs-keyword">var</span> deep = _.<span class="hljs-title function_">cloneDeep</span>(objects);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deep[<span class="hljs-number">0</span>] === objects[<span class="hljs-number">0</span>]);<span class="hljs-comment">// =&gt; false</span></code></pre></div><h4 id="source-6"><a href="#source-6" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/** Used to compose bitmasks for cloning. */</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLONE_DEEP_FLAG</span> = <span class="hljs-number">1</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span> = <span class="hljs-number">4</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * This method is like `clone` except that it recursively clones `value`.</span><span class="hljs-comment"> * Object inheritance is preserved.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@category</span> <span class="hljs-variable">Lang</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; value The value to recursively clone.</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">*</span>&#125; Returns the deep cloned value.</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> <span class="hljs-variable">clone</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><span class="hljs-comment"> *</span><span class="hljs-comment"> * const objects = [&#123; &#x27;a&#x27;: 1 &#125;, &#123; &#x27;b&#x27;: 2 &#125;]</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * const deep = cloneDeep(objects)</span><span class="hljs-comment"> * console.log(deep[0] === objects[0])</span><span class="hljs-comment"> * // =&gt; false</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">baseClone</span>(value, <span class="hljs-variable constant_">CLONE_DEEP_FLAG</span> | <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span>)&#125;</code></pre></div><h3 id="cloneWith-value-customizer"><a href="#cloneWith-value-customizer" class="headerlink" title="_.cloneWith(value, [customizer])"></a><code>_.cloneWith(value, [customizer])</code></h3><p>这个方法和clone方法相似，他会接受一个自定义方法，返回一个clone值，如果customizer是undefuned，则会使用clone方法，customizer方法接受4个参数*(value [, index|key, object, stack])*</p><h4 id="Arguments-9"><a href="#Arguments-9" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>value</code> <em>(*)</em>: The value to clone.</li><li><code>[customizer]</code> <em>(Function)</em>: The function to customize cloning.</li></ol><h4 id="Returns-9"><a href="#Returns-9" class="headerlink" title="Returns"></a>Returns</h4><p><em>(*)</em>: Returns the cloned value.</p><h4 id="Example-7"><a href="#Example-7" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">customizer</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">if</span> (_.<span class="hljs-title function_">isElement</span>(value)) &#123;    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">false</span>);  &#125;&#125; <span class="hljs-keyword">var</span> el = _.<span class="hljs-title function_">cloneWith</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>, customizer); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el === <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);<span class="hljs-comment">// =&gt; false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el.<span class="hljs-property">nodeName</span>);<span class="hljs-comment">// =&gt; &#x27;BODY&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>);<span class="hljs-comment">// =&gt; 0</span></code></pre></div><h4 id="source-7"><a href="#source-7" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span> = <span class="hljs-number">4</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneWith</span>(<span class="hljs-params">value, customizer</span>) &#123;  customizer = <span class="hljs-keyword">typeof</span> customizer === <span class="hljs-string">&#x27;function&#x27;</span> ? customizer : <span class="hljs-literal">undefined</span>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">baseClone</span>(value, <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span>, customizer)&#125;</code></pre></div><h3 id="cloneDeepWith-value-customizer"><a href="#cloneDeepWith-value-customizer" class="headerlink" title="_.cloneDeepWith(value, [customizer])"></a><code>_.cloneDeepWith(value, [customizer])</code></h3><p>cloneDeepWith和cloneWith类似，但是他会进行递归clone value</p><h4 id="Arguments-10"><a href="#Arguments-10" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>value</code> <em>(*)</em>: The value to recursively clone.</li><li><code>[customizer]</code> <em>(Function)</em>: The function to customize cloning.</li></ol><h4 id="Returns-10"><a href="#Returns-10" class="headerlink" title="Returns"></a>Returns</h4><p><em>(*)</em>: Returns the deep cloned value.</p><h4 id="Example-8"><a href="#Example-8" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">customizer</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">if</span> (_.<span class="hljs-title function_">isElement</span>(value)) &#123;    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);  &#125;&#125; <span class="hljs-keyword">var</span> el = _.<span class="hljs-title function_">cloneDeepWith</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>, customizer); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el === <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>);<span class="hljs-comment">// =&gt; false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el.<span class="hljs-property">nodeName</span>);<span class="hljs-comment">// =&gt; &#x27;BODY&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span>);<span class="hljs-comment">// =&gt; 20</span></code></pre></div><h4 id="source-8"><a href="#source-8" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeepWith</span>(<span class="hljs-params">value, customizer</span>) &#123;  customizer = <span class="hljs-keyword">typeof</span> customizer === <span class="hljs-string">&#x27;function&#x27;</span> ? customizer : <span class="hljs-literal">undefined</span>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">baseClone</span>(value, <span class="hljs-variable constant_">CLONE_DEEP_FLAG</span> | <span class="hljs-variable constant_">CLONE_SYMBOLS_FLAG</span>, customizer)&#125;</code></pre></div><h2 id="“Function”-Methods"><a href="#“Function”-Methods" class="headerlink" title="“Function” Methods"></a><code>“Function” Methods</code></h2><h3 id="debounce-func-wait-0-options"><a href="#debounce-func-wait-0-options" class="headerlink" title="_.debounce(func, [wait=0], [options={}])"></a><code>_.debounce(func, [wait=0], [options=&#123;&#125;])</code></h3><p>创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 <code>wait</code> 毫秒后调用 <code>func</code> 方法。 debounced（防抖动）函数提供一个 <code>cancel</code> 方法取消延迟的函数调用以及 <code>flush</code> 方法立即调用。 可以提供一个 options（选项） 对象决定如何调用 <code>func</code> 方法，<code>options.leading</code> 与|或 <code>options.trailing</code> 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 <code>func</code> 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。 后续调用的 debounced（防抖动）函数返回是最后一次 <code>func</code> 调用的结果。</p><p><strong>注意:</strong> 如果 <code>leading</code> 和 <code>trailing</code> 选项为 <code>true</code>, 则 <code>func</code> 允许 trailing 方式调用的条件为: 在 <code>wait</code> 期间多次调用防抖方法。</p><p>如果 <code>wait</code> 为 <code>0</code> 并且 <code>leading</code> 为 <code>false</code>, <code>func</code>调用将被推迟到下一个点，类似<code>setTimeout</code>为<code>0</code>的超时。</p><h4 id="Arguments-11"><a href="#Arguments-11" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>func</code> <em>(Function)</em>: 要防抖动的函数。</li><li><code>[wait=0]</code> <em>(number)</em>: 需要延迟的毫秒数。</li><li><code>[options=]</code> <em>(Object)</em>: 选项对象。</li><li><code>[options.leading=false]</code> <em>(boolean)</em>: 指定在延迟开始前调用。</li><li><code>[options.maxWait]</code> <em>(number)</em>: 设置 <code>func</code> 允许被延迟的最大值。</li><li><code>[options.trailing=true]</code> <em>(boolean)</em>: 指定在延迟结束后调用。</li></ol><h4 id="Returns-11"><a href="#Returns-11" class="headerlink" title="Returns"></a>Returns</h4><p><em>(Function)</em>: Returns the new debounced function.</p><h4 id="Example-9"><a href="#Example-9" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// Avoid costly calculations while the window size is in flux.</span><span class="hljs-title function_">jQuery</span>(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, _.<span class="hljs-title function_">debounce</span>(calculateLayout, <span class="hljs-number">150</span>)); <span class="hljs-comment">// Invoke `sendMail` when clicked, debouncing subsequent calls.</span><span class="hljs-title function_">jQuery</span>(element).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, _.<span class="hljs-title function_">debounce</span>(sendMail, <span class="hljs-number">300</span>, &#123;  <span class="hljs-string">&#x27;leading&#x27;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-string">&#x27;trailing&#x27;</span>: <span class="hljs-literal">false</span>&#125;)); <span class="hljs-comment">// Ensure `batchLog` is invoked once after 1 second of debounced calls.</span><span class="hljs-keyword">var</span> debounced = _.<span class="hljs-title function_">debounce</span>(batchLog, <span class="hljs-number">250</span>, &#123; <span class="hljs-string">&#x27;maxWait&#x27;</span>: <span class="hljs-number">1000</span> &#125;);<span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&#x27;/stream&#x27;</span>);<span class="hljs-title function_">jQuery</span>(source).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, debounced); <span class="hljs-comment">// Cancel the trailing debounced invocation.</span><span class="hljs-title function_">jQuery</span>(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>, debounced.<span class="hljs-property">cancel</span>);</code></pre></div><h4 id="source-9"><a href="#source-9" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> isObject <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./isObject.js&#x27;</span><span class="hljs-keyword">import</span> root <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./.internal/root.js&#x27;</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Creates a debounced function that delays invoking `func` until after `wait`</span><span class="hljs-comment"> * milliseconds have elapsed since the last time the debounced function was</span><span class="hljs-comment"> * invoked, or until the next browser frame is drawn. The debounced function</span><span class="hljs-comment"> * comes with a `cancel` method to cancel delayed `func` invocations and a</span><span class="hljs-comment"> * `flush` method to immediately invoke them. Provide `options` to indicate</span><span class="hljs-comment"> * whether `func` should be invoked on the leading and/or trailing edge of the</span><span class="hljs-comment"> * `wait` timeout. The `func` is invoked with the last arguments provided to the</span><span class="hljs-comment"> * debounced function. Subsequent calls to the debounced function return the</span><span class="hljs-comment"> * result of the last `func` invocation.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * **Note:** If `leading` and `trailing` options are `true`, `func` is</span><span class="hljs-comment"> * invoked on the trailing edge of the timeout only if the debounced function</span><span class="hljs-comment"> * is invoked more than once during the `wait` timeout.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred</span><span class="hljs-comment"> * until the next tick, similar to `setTimeout` with a timeout of `0`.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`</span><span class="hljs-comment"> * invocation will be deferred until the next frame is drawn (typically about</span><span class="hljs-comment"> * 16ms).</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * See [David Corbacho&#x27;s article](https://css-tricks.com/debouncing-throttling-explained-examples/)</span><span class="hljs-comment"> * for details over the differences between `debounce` and `throttle`.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 0.1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@category</span> <span class="hljs-variable">Function</span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Function</span>&#125; func The function to debounce.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; [wait=0]</span><span class="hljs-comment"> *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is</span><span class="hljs-comment"> *  used (if available).</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Object</span>&#125; [options=&#123;&#125;] The options object.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; [options.leading=false]</span><span class="hljs-comment"> *  Specify invoking on the leading edge of the timeout.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; [options.maxWait]</span><span class="hljs-comment"> *  The maximum time `func` is allowed to be delayed before it&#x27;s invoked.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; [options.trailing=true]</span><span class="hljs-comment"> *  Specify invoking on the trailing edge of the timeout.</span><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">Function</span>&#125; Returns the new debounced function.</span><span class="hljs-comment"> * <span class="hljs-doctag">@example</span></span><span class="hljs-comment"> *</span><span class="hljs-comment"> * // Avoid costly calculations while the window size is in flux.</span><span class="hljs-comment"> * jQuery(window).on(&#x27;resize&#x27;, debounce(calculateLayout, 150))</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * // Invoke `sendMail` when clicked, debouncing subsequent calls.</span><span class="hljs-comment"> * jQuery(element).on(&#x27;click&#x27;, debounce(sendMail, 300, &#123;</span><span class="hljs-comment"> *   &#x27;leading&#x27;: true,</span><span class="hljs-comment"> *   &#x27;trailing&#x27;: false</span><span class="hljs-comment"> * &#125;))</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * // Ensure `batchLog` is invoked once after 1 second of debounced calls.</span><span class="hljs-comment"> * const debounced = debounce(batchLog, 250, &#123; &#x27;maxWait&#x27;: 1000 &#125;)</span><span class="hljs-comment"> * const source = new EventSource(&#x27;/stream&#x27;)</span><span class="hljs-comment"> * jQuery(source).on(&#x27;message&#x27;, debounced)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * // Cancel the trailing debounced invocation.</span><span class="hljs-comment"> * jQuery(window).on(&#x27;popstate&#x27;, debounced.cancel)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * // Check for pending invocations.</span><span class="hljs-comment"> * const status = debounced.pending() ? &quot;Pending...&quot; : &quot;Ready&quot;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait, options</span>) &#123;  <span class="hljs-keyword">let</span> lastArgs,    lastThis,    maxWait,    result,    timerId,    lastCallTime  <span class="hljs-keyword">let</span> lastInvokeTime = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> leading = <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> maxing = <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> trailing = <span class="hljs-literal">true</span>  <span class="hljs-comment">// Bypass `requestAnimationFrame` by explicitly setting `wait=0`.</span>  <span class="hljs-keyword">const</span> useRAF = (!wait &amp;&amp; wait !== <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">typeof</span> root.<span class="hljs-property">requestAnimationFrame</span> === <span class="hljs-string">&#x27;function&#x27;</span>)  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Expected a function&#x27;</span>)  &#125;  wait = +wait || <span class="hljs-number">0</span>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(options)) &#123;    <span class="hljs-comment">//转成boolean</span>    leading = !!options.<span class="hljs-property">leading</span>    maxing = <span class="hljs-string">&#x27;maxWait&#x27;</span> <span class="hljs-keyword">in</span> options    maxWait = maxing ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(+options.<span class="hljs-property">maxWait</span> || <span class="hljs-number">0</span>, wait) : maxWait    trailing = <span class="hljs-string">&#x27;trailing&#x27;</span> <span class="hljs-keyword">in</span> options ? !!options.<span class="hljs-property">trailing</span> : trailing  &#125;  <span class="hljs-comment">//</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeFunc</span>(<span class="hljs-params">time</span>) &#123;    <span class="hljs-keyword">const</span> args = lastArgs    <span class="hljs-keyword">const</span> thisArg = lastThis    lastArgs = lastThis = <span class="hljs-literal">undefined</span>    lastInvokeTime = time    result = func.<span class="hljs-title function_">apply</span>(thisArg, args)    <span class="hljs-keyword">return</span> result  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">startTimer</span>(<span class="hljs-params">pendingFunc, wait</span>) &#123;    <span class="hljs-keyword">if</span> (useRAF) &#123;      root.<span class="hljs-title function_">cancelAnimationFrame</span>(timerId)      <span class="hljs-keyword">return</span> root.<span class="hljs-title function_">requestAnimationFrame</span>(pendingFunc)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">setTimeout</span>(pendingFunc, wait)  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cancelTimer</span>(<span class="hljs-params">id</span>) &#123;    <span class="hljs-keyword">if</span> (useRAF) &#123;      <span class="hljs-keyword">return</span> root.<span class="hljs-title function_">cancelAnimationFrame</span>(id)    &#125;    <span class="hljs-built_in">clearTimeout</span>(id)  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">leadingEdge</span>(<span class="hljs-params">time</span>) &#123;    <span class="hljs-comment">// Reset any `maxWait` timer.</span>    lastInvokeTime = time    <span class="hljs-comment">// Start the timer for the trailing edge.</span>    timerId = <span class="hljs-title function_">startTimer</span>(timerExpired, wait)    <span class="hljs-comment">// Invoke the leading edge.</span>    <span class="hljs-keyword">return</span> leading ? <span class="hljs-title function_">invokeFunc</span>(time) : result  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">remainingWait</span>(<span class="hljs-params">time</span>) &#123;    <span class="hljs-keyword">const</span> timeSinceLastCall = time - lastCallTime    <span class="hljs-keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime    <span class="hljs-keyword">const</span> timeWaiting = wait - timeSinceLastCall    <span class="hljs-keyword">return</span> maxing      ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(timeWaiting, maxWait - timeSinceLastInvoke)      : timeWaiting  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldInvoke</span>(<span class="hljs-params">time</span>) &#123;    <span class="hljs-keyword">const</span> timeSinceLastCall = time - lastCallTime    <span class="hljs-keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime    <span class="hljs-comment">// Either this is the first call, activity has stopped and we&#x27;re at the</span>    <span class="hljs-comment">// trailing edge, the system time has gone backwards and we&#x27;re treating</span>    <span class="hljs-comment">// it as the trailing edge, or we&#x27;ve hit the `maxWait` limit.</span>    <span class="hljs-keyword">return</span> (lastCallTime === <span class="hljs-literal">undefined</span> || (timeSinceLastCall &gt;= wait) ||      (timeSinceLastCall &lt; <span class="hljs-number">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait))  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">timerExpired</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> time = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldInvoke</span>(time)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">trailingEdge</span>(time)    &#125;    <span class="hljs-comment">// Restart the timer.</span>    timerId = <span class="hljs-title function_">startTimer</span>(timerExpired, <span class="hljs-title function_">remainingWait</span>(time))  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">trailingEdge</span>(<span class="hljs-params">time</span>) &#123;    timerId = <span class="hljs-literal">undefined</span>    <span class="hljs-comment">// Only invoke if we have `lastArgs` which means `func` has been</span>    <span class="hljs-comment">// debounced at least once.</span>    <span class="hljs-keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">invokeFunc</span>(time)    &#125;    lastArgs = lastThis = <span class="hljs-literal">undefined</span>    <span class="hljs-keyword">return</span> result  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cancel</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (timerId !== <span class="hljs-literal">undefined</span>) &#123;      <span class="hljs-title function_">cancelTimer</span>(timerId)    &#125;    lastInvokeTime = <span class="hljs-number">0</span>    lastArgs = lastCallTime = lastThis = timerId = <span class="hljs-literal">undefined</span>  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flush</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> timerId === <span class="hljs-literal">undefined</span> ? result : <span class="hljs-title function_">trailingEdge</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pending</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> timerId !== <span class="hljs-literal">undefined</span>  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounced</span>(<span class="hljs-params">...args</span>) &#123;    <span class="hljs-keyword">const</span> time = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()    <span class="hljs-keyword">const</span> isInvoking = <span class="hljs-title function_">shouldInvoke</span>(time)    lastArgs = args    lastThis = <span class="hljs-variable language_">this</span>    lastCallTime = time    <span class="hljs-keyword">if</span> (isInvoking) &#123;      <span class="hljs-keyword">if</span> (timerId === <span class="hljs-literal">undefined</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-title function_">leadingEdge</span>(lastCallTime)      &#125;      <span class="hljs-keyword">if</span> (maxing) &#123;        <span class="hljs-comment">// Handle invocations in a tight loop.</span>        timerId = <span class="hljs-title function_">startTimer</span>(timerExpired, wait)        <span class="hljs-keyword">return</span> <span class="hljs-title function_">invokeFunc</span>(lastCallTime)      &#125;    &#125;    <span class="hljs-keyword">if</span> (timerId === <span class="hljs-literal">undefined</span>) &#123;      timerId = <span class="hljs-title function_">startTimer</span>(timerExpired, wait)    &#125;    <span class="hljs-keyword">return</span> result  &#125;  debounced.<span class="hljs-property">cancel</span> = cancel  debounced.<span class="hljs-property">flush</span> = flush  debounced.<span class="hljs-property">pending</span> = pending  <span class="hljs-keyword">return</span> debounced&#125;</code></pre></div><h3 id="throttle-func-wait-0-options"><a href="#throttle-func-wait-0-options" class="headerlink" title="_.throttle(func, [wait=0], [options={}])"></a><code>_.throttle(func, [wait=0], [options=&#123;&#125;])</code></h3><p>创建一个节流函数，在 wait 秒内最多执行 <code>func</code> 一次的函数。 该函数提供一个 <code>cancel</code> 方法取消延迟的函数调用以及 <code>flush</code> 方法立即调用。 可以提供一个 options 对象决定如何调用 <code>func</code> 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。 <code>func</code> 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 <code>func</code> 调用的结果。</p><p><strong>注意:</strong> 如果 <code>leading</code> 和 <code>trailing</code> 都设定为 <code>true</code> 则 <code>func</code> 允许 trailing 方式调用的条件为: 在 <code>wait</code> 期间多次调用。</p><p>如果 <code>wait</code> 为 <code>0</code> 并且 <code>leading</code> 为 <code>false</code>, <code>func</code>调用将被推迟到下一个点，类似<code>setTimeout</code>为<code>0</code>的超时。</p><p>查看<a href="https://css-tricks.com/debouncing-throttling-explained-examples/">David Corbacho’s article</a> 了解<a href="https://www.lodashjs.com/docs/lodash.throttle#throttle"><code>_.throttle</code></a> 与<a href="https://www.lodashjs.com/docs/lodash.throttle#debounce"><code>_.debounce</code></a> 的区别。</p><h4 id="Arguments-12"><a href="#Arguments-12" class="headerlink" title="Arguments"></a>Arguments</h4><ol><li><code>func</code> <em>(Function)</em>: 要节流的函数。</li><li><code>[wait=0]</code> <em>(number)</em>: 需要节流的毫秒。</li><li><code>[options=]</code> <em>(Object)</em>: 选项对象。</li><li><code>[options.leading=true]</code> <em>(boolean)</em>: 指定调用在节流开始前。</li><li><code>[options.trailing=true]</code> <em>(boolean)</em>: 指定调用在节流结束后。</li></ol><h4 id="Returns-12"><a href="#Returns-12" class="headerlink" title="Returns"></a>Returns</h4><p><em>(Function)</em>: Returns the new throttled function.</p><h4 id="Example-10"><a href="#Example-10" class="headerlink" title="Example"></a>Example</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// Avoid excessively updating the position while scrolling.</span><span class="hljs-title function_">jQuery</span>(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, _.<span class="hljs-title function_">throttle</span>(updatePosition, <span class="hljs-number">100</span>)); <span class="hljs-comment">// Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.</span><span class="hljs-keyword">var</span> throttled = _.<span class="hljs-title function_">throttle</span>(renewToken, <span class="hljs-number">300000</span>, &#123; <span class="hljs-string">&#x27;trailing&#x27;</span>: <span class="hljs-literal">false</span> &#125;);<span class="hljs-title function_">jQuery</span>(element).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, throttled); <span class="hljs-comment">// Cancel the trailing throttled invocation.</span><span class="hljs-title function_">jQuery</span>(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>, throttled.<span class="hljs-property">cancel</span>);</code></pre></div><h4 id="source-10"><a href="#source-10" class="headerlink" title="source"></a>source</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait, options</span>) &#123;  <span class="hljs-keyword">let</span> leading = <span class="hljs-literal">true</span>  <span class="hljs-keyword">let</span> trailing = <span class="hljs-literal">true</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Expected a function&#x27;</span>)  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(options)) &#123;    leading = <span class="hljs-string">&#x27;leading&#x27;</span> <span class="hljs-keyword">in</span> options ? !!options.<span class="hljs-property">leading</span> : leading    trailing = <span class="hljs-string">&#x27;trailing&#x27;</span> <span class="hljs-keyword">in</span> options ? !!options.<span class="hljs-property">trailing</span> : trailing  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">debounce</span>(func, wait, &#123;    leading,    trailing,    <span class="hljs-string">&#x27;maxWait&#x27;</span>: wait  &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> throttle</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>lodash</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lodash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收的算法与实现</title>
    <link href="/2022/12/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/12/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h1><h2 id="学习GC之前"><a href="#学习GC之前" class="headerlink" title="学习GC之前"></a>学习GC之前</h2><p>GC 要做的有两件事。</p><ol><li><p>找到内存空间里的垃圾</p></li><li><p>回收垃圾，让程序员能再次利用这部分空间</p></li></ol><p>满足这两项功能的程序就是 GC。</p>]]></content>
    
    
    <categories>
      
      <category>垃圾回收</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾回收</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript（上卷）</title>
    <link href="/2022/12/25/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89/"/>
    <url>/2022/12/25/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h1><h2 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h2><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编 译</p><p><strong>分词/词法分析（Tokenizing/Lexing）</strong></p><p>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代 码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成 为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。</p><p>分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的， 主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简 单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法 单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法 分析。 </p><p><strong>解析/语法分析（Parsing）</strong></p><p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。 var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下 来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子 节点。 </p><p><strong>代码生成</strong></p><p>将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息 息相关。抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指 令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。</p><p>比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在 语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化 等。</p><p>首先，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因 为与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。 </p><p>对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时 间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 JIT，可以延 迟编译甚至实施重编译）来保证性能最佳。</p><p>简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。 </p><p>参与到对程序 var a = 2; 进行处理的过程中:</p><p><strong>引擎</strong></p><p>从头到尾负责整个 JavaScript 程序的编译及执行过程。</p><p><strong>编译器</strong></p><p>引擎的好朋友之一，负责语法分析及代码生成等脏活累活</p><p><strong>作用域</strong></p><p>引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p><p>当你看见 var a = 2; 这段程序时，很可能认为这是一句声明。但引擎却不这 么看。事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，个则由引擎在运行时处理。</p><p>下面我们将 var a = 2; 分解，看看引擎和它的朋友们是如何协同工作的。</p><p>编译器会进行如下处理：</p><p>1.遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。 </p><p>2.接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量</p><p>如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异 常！</p><p>当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图 找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋 值操作的右侧”，更准确地说是“非左侧”。 你可以将 RHS 理解成 retrieve his source value（取到它的源值），这意味着“得到某某的 值”。</p><p>考虑以下代码： </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a );</code></pre></div><p>其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取 得 a 的值，这样才能将值传递给 console.log(..)。 </p><p>相比之下，例如： </p><div class="code-wrapper"><pre><code class="hljs js">a = <span class="hljs-number">2</span>;</code></pre></div><p>这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。</p><p>LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式</p><p>考虑下面的程序，其中既有 LHS 也有 RHS 引用：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span>** <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); <span class="hljs-comment">// 2 </span>&#125;<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> );</code></pre></div><p>最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把 它给我”。并且 (..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值！ </p><p>这里还有一个容易被忽略却非常重要的细节。 代码中隐式的 a＝2 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给 foo(..) 函数时，2 会被分配给参数 a。为了给参数 a（隐式地）分配值，需要进行一次 LHS 查询</p><p>这里还有对 a 进行的 RHS 引用，并且将得到的值传给了 console.log(..)。console. log(..) 本身也需要一个引用才能执行，因此会对 console 对象进行 RHS 查询，并且检查 得到的值中是否有一个叫作 log 的方法。</p><p>最后，在概念上可以理解为在 LHS 和 RHS 之间通过对值 2 进行交互来将其传递进 log(..) （通过变量 a 的 RHS 查询）。假设在 log(..) 函数的原生实现中它可以接受参数，在将 2 赋 值给其中第一个（也许叫作 arg1）参数之前，这个参数需要进行 LHS 引用查询</p><p>你可能会倾向于将函数声明 function foo(a) {… 概念化为普通的变量声明 和赋值，比如 var foo、foo ＝ function(a) {…。如果这样理解的话，这 个函数声明将需要进行 LHS 查询。 然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值 的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分 配给”foo。因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并 不合适。 </p><h2 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h2><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>为什么区分 LHS 和 RHS 是一件重要的事情？ </p><p>因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行 为是不一样的。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a + b ); b = a; &#125;<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> );</code></pre></div><p>第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变 量，因为在任何相关的作用域中都无法找到它。 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。</p><p>相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。</p><p>ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上 有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。 </p><p>接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError</p><p>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对 变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域 的赋值操作。</p><p>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所 需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层 楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。 </p><p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。</p><h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法 作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语 言在使用（比如 Bash 脚本、Perl 中的一些模式等）。</p><h2 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h2><p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域 不变（大部分情况下是这样的）</p><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见 第一个匹配的标识符为止</p><p>全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。<code>window.a</code>通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量 如果被遮蔽了，无论如何都无法被访问到。无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。 </p><p>词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz， 词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接 管对 bar 和 baz 属性的访问。 </p><h2 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h2><p>欺骗词法作用域会导致性能 下降</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书 写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并 运行，就好像代码是写在那个位置的一样</p><p>在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插 入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str, a</span>) &#123;<span class="hljs-built_in">eval</span>( str ); <span class="hljs-comment">// 欺骗！ console.log( a, b );</span>&#125;<span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>; <span class="hljs-title function_">foo</span>( <span class="hljs-string">&quot;var b = 3;&quot;</span>, <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1, 3</span></code></pre></div><p>eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代 码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实 上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽 了外部（全局）作用域中的同名变量。 当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到 外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2</p><p>默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函 数），就会对 eval(..) 所处的词法作用域进行修改eval在严格模式中无法修改他所在的词法作用域</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str</span>) &#123;  <span class="hljs-string">&quot;use strict&quot;</span>;  <span class="hljs-built_in">eval</span>(str);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// ReferenceError: a is not defined</span>&#125;<span class="hljs-title function_">foo</span>(<span class="hljs-string">&quot;var a = 2&quot;</span>);</code></pre></div><p>JavaScript 中 还 有 其 他 一 些 功 能 效 果 和 eval(..) 很 相 似。setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的 函数代码。这些功能已经过时且并不被提倡。不要使用它们！</p><p>new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转 化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。 </p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象 本身。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 单调乏味的重复 &quot;obj&quot;</span>obj.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;obj.<span class="hljs-property">b</span> = <span class="hljs-number">3</span>;obj.<span class="hljs-property">c</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// 简单的快捷方式</span><span class="hljs-keyword">with</span> (obj) &#123;  a = <span class="hljs-number">3</span>;  b = <span class="hljs-number">4</span>;  c = <span class="hljs-number">5</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) &#123;  <span class="hljs-keyword">with</span> (obj) &#123;    a = <span class="hljs-number">2</span>;  &#125;&#125;<span class="hljs-keyword">var</span> o1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-keyword">var</span> o2 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-title function_">foo</span>(o1);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2 foo( o2 );</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o2.<span class="hljs-property">a</span>); <span class="hljs-comment">// undefined</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2——不好，a 被泄漏到全局作用域上了！</span></code></pre></div><p>这个例子中创建了 o1 和 o2 两个对象。其中一个具有 a 属性，另外一个没有。foo(..) 函 数接受一个 obj 参数，该参数是一个对象引用，并对这个对象引用执行了 with(obj) {..}。 在 with 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个 LHS 引用，并将 2 赋值给它。 </p><p>当我们将 o1 传递进去，a＝2 赋值操作找到了 o1.a 并将 2 赋值给它，这在后面的 console. log(o1.a) 中可以体现。而当 o2 传递进去，o2 并没有 a 属性，因此不会创建这个属性， o2.a 保持 undefined</p><p>但是可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局的变量 a。这 是怎么回事？</p><p>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符。</p><p>尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作 用域中。</p><p>eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。</p><p>可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含 有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符， 因此进行了正常的 LHS 标识符查找</p><p>o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行 时，自动创建了一个全局变量（因为是非严格模式）。 </p><p>另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限 制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词 法作用域。</p><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的 词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到 标识符。</p><p>但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断 都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底 是什么。 </p><p>最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简 单的做法就是完全不做任何优化。 </p><p>如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪 明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代 码会运行得更慢这个事实。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段 基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找</p><p>JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包 含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在 运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）</p><p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p><h1 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h1><h2 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。</p><h2 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h2><p>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来 一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际 上就是把这些代码“隐藏”起来了。</p><p>实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任 何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的 作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域 来“隐藏”它们。</p><p>为什么“隐藏”变量和函数是一个有用的技术？</p><p>有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来 的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计</p><p>这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作 用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小 特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确 的代码应该是可以阻止对这些变量或函数进行访问的。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">a</span>) &#123;  b = a + <span class="hljs-title function_">doSomethingElse</span>(a * <span class="hljs-number">2</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b * <span class="hljs-number">3</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params">a</span>) &#123;  <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">var</span> b;<span class="hljs-title function_">doSomething</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 15</span></code></pre></div><p>在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体 实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅 没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用， 从而导致超出了 doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内 容隐藏在 doSomething(..) 内部，，例如：</p><div class="code-wrapper"><pre><code class="hljs js">unction <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">a</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingElse</span>(<span class="hljs-params">a</span>) &#123;    <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">var</span> b;  b = a + <span class="hljs-title function_">doSomethingElse</span>(a * <span class="hljs-number">2</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b * <span class="hljs-number">3</span>);&#125;<span class="hljs-title function_">doSomething</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 15</span></code></pre></div><p>现在，b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。 功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会 依此进行实现。</p><p>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">a</span>) &#123;    i = <span class="hljs-number">3</span>; <span class="hljs-comment">// 修改 for 循环所属作用域中的 i console.log( a + i );</span>  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-title function_">bar</span>(i * <span class="hljs-number">2</span>); <span class="hljs-comment">// 糟糕，无限循环了！</span>  &#125;&#125;<span class="hljs-title function_">foo</span>();</code></pre></div><p>bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这 个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件</p><p>bar(..) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以，var i = 3; 就可以满足这个需求（同时会为 i 声明一个前面提到过的“遮蔽变量”）。另外一种方法是 采用一个完全不同的标识符名称，比如 var j = 3;。但是软件设计在某种情况下可能自然 而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是 唯一的最佳选择。</p><h4 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h4><p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它 们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。</p><p>这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象 被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属 性，而不是将自己的标识符暴漏在顶级的词法作用域中</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyReallyCoolLibrary</span> = &#123;  <span class="hljs-attr">awesome</span>: <span class="hljs-string">&quot;stuff&quot;</span>,  <span class="hljs-attr">doSomething</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// ...</span>  &#125;,  <span class="hljs-attr">doAnotherThing</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// ...</span>  &#125;,&#125;;</code></pre></div><h4 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h4><p>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器 的机制将库的标识符显式地导入到另外一个特定的作用域中。</p><p>显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用 域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域 中，这样可以有效规避掉所有的意外冲突。</p><p>因此，只要你愿意，即使不使用任何依赖管理工具也可以实现相同的功效</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐 藏”起来，外部作用域无法访问包装函数内部的任何内容。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// &lt;-- 添加这一行</span>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 3</span>&#125; <span class="hljs-comment">// &lt;-- 以及这一行</span><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &lt;-- 以及这一行</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span></code></pre></div><p>虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先， 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域（在这个 例子中是全局作用域）。其次，必须显式地通过函数名（foo()）调用这个函数才能运行其 中的代码。</p><p>如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行， 这将会更加理想。</p><p>幸好，JavaScript 提供了能够同时解决这两个问题的方案、</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// &lt;-- 添加这一行</span>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 3</span>&#125;)(); <span class="hljs-comment">// &lt;-- 以及这一行</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span></code></pre></div><p>首先，包装函数的声明以 (function… 而不仅是以 function… 开始。尽管看上去这并不 是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一 个标准的函数声明来处理。 </p><p>区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p><p>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。</p><p>比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过 foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。</p><p>换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域</p><h4 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h4><p>对于函数表达式你最熟悉的场景可能就是回调参数了，比如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I waited 1 second!&quot;</span>);&#125;, <span class="hljs-number">1000</span>);</code></pre></div><p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的， 而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。</p><p>匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是 它也有几个缺点需要考虑。</p><p>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</p><p>如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。</p><p>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让 代码不言自明。 </p><p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函 数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">etTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timeoutHandler</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// &lt;-- 快看，我有名字了！</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I waited 1 second!&quot;</span>);&#125;, <span class="hljs-number">1000</span>);</code></pre></div><h4 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 3</span>&#125;)();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span></code></pre></div><p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。</p><p>这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式 （Immediately Invoked Function Expression）； </p><p>函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使 用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值 得推广的实践。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 3</span>&#125;)();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span></code></pre></div><p>相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式：(function(){ .. }())。仔 细观察其中的区别。第一种形式中函数表达式被包含在 ( ) 中，然后在后面用另一个 () 括 号来调用。第二种形式中用来调用的 () 括号被移进了用来包装的 ( ) 括号中。</p><p>IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 3</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span>&#125;)(<span class="hljs-variable language_">window</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span></code></pre></div><p>这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常（虽 然不常见）。将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可以 保证在代码块中 undefined 标识符的值真的是 undefined</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-literal">undefined</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 给其他代码挖了一个大坑！绝对不要这样做！</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"><span class="hljs-literal">undefined</span></span>) &#123;  <span class="hljs-keyword">var</span> a;  <span class="hljs-keyword">if</span> (a === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Undefined is safe here!&quot;</span>);  &#125;&#125;)();</code></pre></div><p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。这种模式在 UMD（Universal Module Definition）项目中被广 泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params">def</span>) &#123;  <span class="hljs-title function_">def</span>(<span class="hljs-variable language_">window</span>);&#125;)(<span class="hljs-keyword">function</span> <span class="hljs-title function_">def</span>(<span class="hljs-params"><span class="hljs-variable language_">global</span></span>) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 3</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">global</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span>&#125;);</code></pre></div><p>函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进 IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将 window 传入当作 global 参数的值</p><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);&#125;</code></pre></div><p>我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使 用 i，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。</p><p>这就是块作用域的用处。变量的声明应该距离使用的地方越近越好，并最大限度地本地 化。另外一个例子：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (foo) &#123;  <span class="hljs-keyword">var</span> bar = foo * <span class="hljs-number">2</span>;  bar = <span class="hljs-title function_">something</span>(bar);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar);&#125;</code></pre></div><p>bar 变量仅在 if 声明的上下文中使用，因此如果能将它声明在 if 块内部中会是一个很有 意义的事情。但是，当使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。这段代码是为了风格更易读而伪装出的形式上的块作用域，如果使用这 种形式，要确保没在作用域其他地方意外地使用 bar 只能依靠自觉性。</p><h4 id="with-1"><a href="#with-1" class="headerlink" title="with"></a>with</h4><p>With也是块级作用域</p><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h4><p>非常少有人会注意到 JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作 用域，其中声明的变量仅在 catch 内部有效。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;  <span class="hljs-title function_">undefined</span>(); <span class="hljs-comment">// 执行一个非法操作来强制制造一个异常</span>&#125; <span class="hljs-keyword">catch</span> (err) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err); <span class="hljs-comment">// 能够正常执行！</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err); <span class="hljs-comment">// ReferenceError: err not found</span></code></pre></div><p>正如你所看到的，err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境（除了老 版本的 IE 浏览器）所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。 为了避免这个不必要的警告，很多开发者会将 catch 的参数命名为 err1、 err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查。</p><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let 为其声明的变量隐式地了所在的块作用域。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (foo) &#123;  <span class="hljs-keyword">let</span> bar = foo * <span class="hljs-number">2</span>;  bar = <span class="hljs-title function_">something</span>(bar);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar); <span class="hljs-comment">// ReferenceError</span></code></pre></div><p>用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过 程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将 其包含在其他的块中，就会导致代码变得混乱。</p><p>为块作用域显式地创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。通常 来讲，显式的代码优于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书 写，并且和其他语言中块作用域的工作原理一致：</p><p>只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑 定的块。在这个例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重 构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。</p><p>使用 let 进行的声明不会在块作用域中进行提升</p><h5 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h5><p>另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>) &#123;  <span class="hljs-comment">// 在这里做点有趣的事情</span>&#125;<span class="hljs-keyword">var</span> someReallyBigData = &#123;&#125;;<span class="hljs-title function_">process</span>(someReallyBigData);<span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;my_button&quot;</span>);btn.<span class="hljs-title function_">addEventListener</span>(  <span class="hljs-string">&quot;click&quot;</span>,  <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">evt</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button clicked&quot;</span>);  &#125;,  <span class="hljs-comment">/*capturingPhase=*/</span> <span class="hljs-literal">false</span>);</code></pre></div><p>click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执 行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成 了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体 实现）。</p><p>块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">data</span>) &#123;  <span class="hljs-comment">// 在这里做点有趣的事情</span>&#125; <span class="hljs-comment">// 在这个块中定义的内容可以销毁了！</span>&#123;  <span class="hljs-keyword">let</span> someReallyBigData = &#123;&#125;;  <span class="hljs-title function_">process</span>(someReallyBigData);&#125;<span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;my_button&quot;</span>);btn.<span class="hljs-title function_">addEventListener</span>(  <span class="hljs-string">&quot;click&quot;</span>,  <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">evt</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button clicked&quot;</span>);  &#125;,  <span class="hljs-comment">/*capturingPhase=*/</span> <span class="hljs-literal">false</span>);</code></pre></div><h5 id="let循环"><a href="#let循环" class="headerlink" title="let循环"></a>let循环</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); &#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i ); <span class="hljs-comment">// ReferenceError </span></code></pre></div><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环 的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p><p>下面通过另一种方式来说明每次迭代时进行重新绑定的行为： </p><div class="code-wrapper"><pre><code class="hljs js">&#123;  <span class="hljs-keyword">let</span> j;  <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;    <span class="hljs-keyword">let</span> i = j; <span class="hljs-comment">// 每个迭代重新绑定！</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);  &#125;&#125;</code></pre></div><p>由于 let 声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域）， 当代码中存在对于函数作用域中 var 声明的隐式依赖时，就会有很多隐藏的陷阱，如果用 let 来替代 var 则需要在代码重构的过程中付出额外的精力</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 （常量）。之后任何试图修改值的操作都会引起错误</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (foo) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;  <span class="hljs-keyword">const</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">// 包含在 if 中的块作用域常量</span>  a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 正常 !</span>  b = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误 !</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// Ref</span></code></pre></div><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><p>包括变量和函数在内的所有声明都会在任何代码被执行前首先 被处理</p><div class="code-wrapper"><pre><code class="hljs js">a = <span class="hljs-number">2</span>;<span class="hljs-keyword">var</span> a;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//undefined</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</code></pre></div><p>当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个 声明：var a; 和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。</p><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变 了代码执行的顺序，会造成非常严重的破坏。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">foo</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined</span>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;&#125;</code></pre></div><p>foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可 以正常执行。</p><p>函数声明会被提升，但是函数表达式却不会被提升</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 不是 ReferenceError, 而是 TypeError!</span><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// ...</span>&#125;;</code></pre></div><p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域），因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值（如果它是一个函数声明而不 是函数表达式，那么就会赋值）。foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 TypeError 异常。</p><p>同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError bar(); // ReferenceError</span><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// ...</span>&#125;;</code></pre></div><h3 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h3><p>函数声明和变量声明都会被提升。</p><p>但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是函数会首先被提升，然后才是变量</p><p>函数是一等公民</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 1</span><span class="hljs-keyword">var</span> foo;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);&#125;foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);&#125;;</code></pre></div><p>注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽 略了），因为函数声明会被提升到普通变量之前。</p><p>尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);&#125;</code></pre></div><p>虽然这些听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是 非常糟糕的，而且经常会导致各种奇怪的问题。</p><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代 码暗示的那样可以被条件判断所控制： </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &quot;b&quot;</span><span class="hljs-keyword">var</span> a = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (a) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a&quot;</span>);  &#125;&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b&quot;</span>);  &#125;&#125;</code></pre></div><h1 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h1><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  &#125;  <span class="hljs-keyword">return</span> bar;&#125;<span class="hljs-keyword">var</span> baz = <span class="hljs-title function_">foo</span>();<span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// 2</span></code></pre></div><p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作 一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值</p><p>在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实 际上只是通过不同的标识符引用调用了内部的函数 bar()</p><p>bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方 执行。</p><p>在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。</p><p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。</p><p>拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。</p><p>bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p><p>因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。</p><p>这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的 词法作用域。</p><p>当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到 闭包。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span>  &#125;  <span class="hljs-title function_">bar</span>(baz);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>) &#123;  <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 妈妈快看呀，这就是闭包！</span>&#125;</code></pre></div><p>把内部函数 baz 传递给 bar，当调用这个内部函数时（现在叫作 fn），它涵盖的 foo() 内部 作用域的闭包就可以观察到了，因为它能够访问 a。</p><p>传递函数当然也可以是间接的。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  &#125;  fn = baz; <span class="hljs-comment">// 将 baz 分配给全局变量</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 妈妈快看呀，这就是闭包！</span>&#125;<span class="hljs-title function_">foo</span>();<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2</span></code></pre></div><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">message</span>) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);  &#125;, <span class="hljs-number">1000</span>);&#125;<span class="hljs-title function_">wait</span>(<span class="hljs-string">&quot;Hello, closure!&quot;</span>);</code></pre></div><p>将一个内部函数（名为 timer）传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。</p><p>wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..) 作用域的闭包。 </p><p>深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。这就是闭包。</p><p>本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使 用了回调函数，实际上就是在使用闭包！</p><div class="code-wrapper"><pre><code class="hljs js">ar a = <span class="hljs-number">2</span>;(<span class="hljs-keyword">function</span> <span class="hljs-title function_">IIFE</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);&#125;)();</code></pre></div><p>虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中 的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而 外部作用域，也就是全局作用域也持有 a）。a 是通过普通的词法作用域查找而非闭包被发现的。</p><p>尽管技术上来讲，闭包是发生在定义时的，但并不非常明显，就好像六祖慧能所说：“既 非风动，亦非幡动，仁者心动耳。”。 </p><p>尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建 可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用 闭包。 </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);  &#125;, i * <span class="hljs-number">1000</span>);&#125;</code></pre></div><p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。 但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。</p><p>这是为什么？</p><p>首先解释 6 是从哪里来的。这个循环的终止条件是 i 不再 &lt;=5。条件首次成立时 i 的值是 6。因此，输出显示的是循环结束时 i 的最终值。</p><p>仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上， 当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。</p><p>这里引伸出一个更深入的问题，代码中到底有什么缺陷导致它的行为同语义所暗示的不一 致呢？缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是 根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的， 但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。 </p><p>这样说的话，当然所有函数共享一个 i 的引用。循环结构让我们误以为背后还有更复杂的 机制在起作用，但实际上没有。如果将延迟函数的回调重复定义五次，完全不使用循环， 那它同这段代码是完全等价的。</p><p>下面回到正题。缺陷是什么？我们需要更多的闭包作用域，特别是在循环的过程中每个迭 代都需要一个闭包作用域。</p><p>IIFE 会通过声明并立即执行一个函数来创建作用域</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;  (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);    &#125;, i * <span class="hljs-number">1000</span>);  &#125;)();&#125;</code></pre></div><p>这样能行吗？试试吧，我等着你。</p><p>我不卖关子了。这样不行。但是为什么呢？我们现在显然拥有更多的词法作用域了。的确 每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。 </p><p>如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一 个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。</p><p>它需要有自己的变量，用来在每个迭代中储存 i 的值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;  (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">var</span> j = i;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);    &#125;, j * <span class="hljs-number">1000</span>);  &#125;)();&#125;</code></pre></div><p>可以对这段代码进行一些改进：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;  (<span class="hljs-keyword">function</span> (<span class="hljs-params">j</span>) &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);    &#125;, j * <span class="hljs-number">1000</span>);  &#125;)(i);&#125;</code></pre></div><p>当然，这些 IIFE 也不过就是函数，因此我们可以将 i 传递进去，如果愿意的话可以将变量 名定为 j，当然也可以还叫作 i。无论如何这段代码现在可以工作了。</p><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的 作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p><p>仔细思考我们对前面的解决方案的分析。我们使用 IIFE 在每次迭代时都创建一个新的作用 域。换句话说，每次迭代我们都需要一个块作用域。第 3 章介绍了 let 声明，可以用来劫 持块作用域，并且在这个块作用域中声明一个变量。</p><p>本质上这是将一个块转换成一个可以被关闭的作用域</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;  <span class="hljs-keyword">let</span> j = i; <span class="hljs-comment">// 是的，闭包的块作用域！</span>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);  &#125;, j * <span class="hljs-number">1000</span>);&#125;</code></pre></div><p>for 循环头部的 let 声明还会有一 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随 后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>;  <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(something);  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(another.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; ! &quot;</span>));  &#125;&#125;</code></pre></div><p>正如在这段代码中所看到的，这里并没有明显的闭包，只有两个私有数据变量 something 和 another，以及 doSomething() 和 doAnother() 两个内部函数，它们的词法作用域（而这 就是闭包）也就是 foo() 的内部作用域。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>;  <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(something);  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(another.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; ! &quot;</span>));  &#125;  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">doSomething</span>: doSomething, <span class="hljs-attr">doAnother</span>: doAnother &#125;;&#125;<span class="hljs-keyword">var</span> foo = <span class="hljs-title class_">CoolModule</span>();foo.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// cool</span>foo.<span class="hljs-title function_">doAnother</span>(); <span class="hljs-comment">// 1 ! 2 ! 3</span></code></pre></div><p>这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露， 这里展示的是其变体</p><p>首先，CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行 外部函数，内部作用域和闭包都无法被创建。</p><p>其次，CoolModule() 返回一个用对象字面量语法 { key: value, … } 来表示的对象。这 个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API</p><p>这个对象类型的返回值最终被赋值给外部的变量 foo，然后就可以通过它来访问 API 中的 属性方法，比如 foo.doSomething()。</p><p>从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函 数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属 性）。</p><p>doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包（通过调用 CoolModule() 实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作 用域外部时，我们已经创造了可以观察和实践闭包的条件。 </p><p>模块模式需要具备两个必要条件。</p><p>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）</p><p>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</p><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p><p>上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次， 每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的 改进来实现单例模式：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>;  <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(something);  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">doAnother</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(another.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; ! &quot;</span>));  &#125;  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">doSomething</span>: doSomething, <span class="hljs-attr">doAnother</span>: doAnother &#125;;&#125;)();foo.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// cool</span>foo.<span class="hljs-title function_">doAnother</span>(); <span class="hljs-comment">// 1 ! 2 ! 3</span></code></pre></div><p>我们将模块函数转换成了 IIFE（参见第 3 章），立即调用这个函数并将返回值直接赋值给 </p><p>单例的模块实例标识符 foo。 </p><p>模块也是普通的函数，因此可以接受参数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params">id</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id);  &#125;  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">identify</span>: identify &#125;;&#125;<span class="hljs-keyword">var</span> foo1 = <span class="hljs-title class_">CoolModule</span>(<span class="hljs-string">&quot;foo 1&quot;</span>);<span class="hljs-keyword">var</span> foo2 = <span class="hljs-title class_">CoolModule</span>(<span class="hljs-string">&quot;foo 2&quot;</span>);foo1.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// &quot;foo 1&quot;</span>foo2.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// &quot;foo 2&quot;</span></code></pre></div><p>模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">CoolModule</span>(<span class="hljs-params">id</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 修改公共 API</span>    publicAPI.<span class="hljs-property">identify</span> = identify2;  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify1</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id);  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">identify2</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id.<span class="hljs-title function_">toUpperCase</span>());  &#125;  <span class="hljs-keyword">var</span> publicAPI = &#123; <span class="hljs-attr">change</span>: change, <span class="hljs-attr">identify</span>: identify1 &#125;;  <span class="hljs-keyword">return</span> publicAPI;&#125;)(<span class="hljs-string">&quot;foo module&quot;</span>);foo.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// foo module</span>foo.<span class="hljs-title function_">change</span>();foo.<span class="hljs-title function_">identify</span>(); <span class="hljs-comment">// FOO MODULE</span></code></pre></div><p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。 </p><h4 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h4><p>大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。这里 并不会研究某个具体的库，为了宏观了解我会简单地介绍一些核心概念：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyModules</span> = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">Manager</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> modules = &#123;&#125;;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">define</span>(<span class="hljs-params">name, deps, impl</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; deps.<span class="hljs-property">length</span>; i++) &#123;      deps[i] = modules[deps[i]];    &#125;    modules[name] = impl.<span class="hljs-title function_">apply</span>(impl, deps);  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">name</span>) &#123;    <span class="hljs-keyword">return</span> modules[name];  &#125;  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">define</span>: define, <span class="hljs-attr">get</span>: get &#125;;&#125;)();</code></pre></div><p>这段代码的核心是 modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装 函数（可以传入任何依赖），并且将返回值，也就是模块的 API，储存在一个根据名字来管 理的模块列表中。</p><p>下面展示了如何使用它来定义模块： </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;bar&quot;</span>, [], <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">who</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Let me introduce: &quot;</span> + who;  &#125;  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hello</span>: hello &#125;;&#125;);<span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;foo&quot;</span>, [<span class="hljs-string">&quot;bar&quot;</span>], <span class="hljs-keyword">function</span> (<span class="hljs-params">bar</span>) &#123;  <span class="hljs-keyword">var</span> hungry = <span class="hljs-string">&quot;hippo&quot;</span>;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">awesome</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-title function_">hello</span>(hungry).<span class="hljs-title function_">toUpperCase</span>());  &#125;  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">awesome</span>: awesome &#125;;&#125;);<span class="hljs-keyword">var</span> bar = <span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;bar&quot;</span>);<span class="hljs-keyword">var</span> foo = <span class="hljs-title class_">MyModules</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;foo&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-title function_">hello</span>(<span class="hljs-string">&quot;hippo&quot;</span>)); <span class="hljs-comment">// Let me introduce: hippo</span>foo.<span class="hljs-title function_">awesome</span>(); <span class="hljs-comment">// LET ME INTRODUCE: HIPPO</span></code></pre></div><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。</p><p>模块有两个主要特征：</p><p>（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭 包。</p><h1 id="块作用域的替代方案"><a href="#块作用域的替代方案" class="headerlink" title="块作用域的替代方案"></a>块作用域的替代方案</h1><div class="code-wrapper"><pre><code class="hljs js">&#123;  <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// ReferenceError</span></code></pre></div><p>这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果？ 答案是使用 catch</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">try</span> &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-number">2</span>;&#125; <span class="hljs-keyword">catch</span> (a) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 2</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// ReferenceError</span></code></pre></div><p>catch 分句具有块作用域，因此它可以在 ES6 之前的环境中作为块作用域的替代 方案</p><h1 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a><strong>this</strong>词法</h1><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span>,  <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);  &#125;,&#125;;<span class="hljs-keyword">var</span> id = <span class="hljs-string">&quot;not awesome&quot;</span>;obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// 酷</span><span class="hljs-built_in">setTimeout</span>(obj.<span class="hljs-property">cool</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// 不酷</span></code></pre></div><p>问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最长用 的就是</p><p> var self = this方式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,  <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;    <span class="hljs-keyword">if</span> (self.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;        self.<span class="hljs-property">count</span>++;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;awesome?&quot;</span>);      &#125;, <span class="hljs-number">100</span>);    &#125;  &#125;,&#125;;obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// 酷吧？</span></code></pre></div><p>this词法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,  <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// 箭头函数是什么鬼东西？</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;awesome?&quot;</span>);      &#125;, <span class="hljs-number">100</span>);    &#125;  &#125;,&#125;;obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// 很酷吧 ?</span></code></pre></div><p>bind绑定</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,  <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">coolFn</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &lt; <span class="hljs-number">1</span>) &#123;      <span class="hljs-built_in">setTimeout</span>(        <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; <span class="hljs-comment">// this 是安全的 // 因为 bind(..)</span>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;more awesome&quot;</span>);        &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),        <span class="hljs-number">100</span>      ); <span class="hljs-comment">// look, bind()!</span>    &#125;  &#125;,&#125;;obj.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// 更酷了</span></code></pre></div><h1 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于<strong>this</strong></h1><p>this 关键字是 JavaScript 中最复杂的机制之一</p><h2 id="为什么要用this"><a href="#为什么要用this" class="headerlink" title="为什么要用this"></a>为什么要用this</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>();&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + identify.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);&#125;<span class="hljs-keyword">var</span> me = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Kyle&quot;</span> &#125;;<span class="hljs-keyword">var</span> you = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Reader&quot;</span> &#125;;identify.<span class="hljs-title function_">call</span>(me); <span class="hljs-comment">// KYLE</span>identify.<span class="hljs-title function_">call</span>(you); <span class="hljs-comment">// READER</span>speak.<span class="hljs-title function_">call</span>(me); <span class="hljs-comment">// Hello, 我是 KYLE</span>speak.<span class="hljs-title function_">call</span>(you); <span class="hljs-comment">// Hello, 我是 READER</span></code></pre></div><p>这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。</p><p>如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params">context</span>) &#123;  <span class="hljs-keyword">return</span> context.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>();&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">context</span>) &#123;  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + <span class="hljs-title function_">identify</span>(context);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);&#125;<span class="hljs-title function_">identify</span>(you); <span class="hljs-comment">// READER s</span><span class="hljs-title function_">peak</span>(me); <span class="hljs-comment">//hello, 我是 KYLE</span></code></pre></div><p>然而，this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计 得更加简洁并且易于复用</p><p>this 在任何情况下都不指向函数的词法作用域。在 JavaScript 内部，作用 域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bar</span>();&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// ReferenceError: a is not defined</span></code></pre></div><p>不要把this的指向和词法作用域混淆</p><p><strong>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</strong></p><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到。 </p><h1 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a><strong>this</strong>全面解析</h1><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 当前调用栈是：baz // 因此，当前调用位置是全局作用域</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;baz&quot;</span>);  <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &lt;-- bar 的调用位置</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar // 因此，当前调用位置在 baz 中</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bar&quot;</span>);  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &lt;-- foo 的调用位置</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);&#125;<span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// &lt;-- baz 的调用位置</span></code></pre></div><p>你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所 写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法 是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具， 其中包含 JavaScript 调试器。就本例来说，你可以在工具中给 foo() 函数的 第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger; 语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数 调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置</p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用 其他规则时的默认规则。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span></code></pre></div><p>你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a = 2）就是全局对 象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的</p><p>如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-string">&quot;use strict&quot;</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// TypeError: this is undefined</span></code></pre></div><p>虽然 this 的绑定规则完全取决于调用位置，但是只 有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo() 的调用位置无关：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-string">&quot;use strict&quot;</span>;  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span>&#125;)();</code></pre></div><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">foo</span>: foo &#125;;obj.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span></code></pre></div><p>首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。 但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥 有”或者“包含”它。无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的</p><p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>, <span class="hljs-attr">foo</span>: foo &#125;;<span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">obj2</span>: obj2 &#125;;obj1.<span class="hljs-property">obj2</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 42</span></code></pre></div><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者undefined 上，取决于是否是严格模式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">foo</span>: foo &#125;;<span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 函数别名！</span><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &quot;oops, global&quot;</span></code></pre></div><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定</p><p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params">fn</span>) &#123;  <span class="hljs-comment">// fn 其实引用的是 foo</span>  <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;-- 调用位置！</span>&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">foo</span>: foo &#125;;<span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><span class="hljs-title function_">doFoo</span>(obj.<span class="hljs-property">foo</span>); <span class="hljs-comment">// &quot;oops, global&quot;</span></code></pre></div><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一 个例子一样。 </p><p>如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一 样的，没有区别：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">foo</span>: foo &#125;;<span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span><span class="hljs-built_in">setTimeout</span>(obj.<span class="hljs-property">foo</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// &quot;oops, global&quot;</span></code></pre></div><p>JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span>** <span class="hljs-title">setTimeout</span>(<span class="hljs-params">fn,delay</span>) </span>&#123; <span class="hljs-comment">// 等待 delay 毫秒 </span><span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params"></span>)</span>; <span class="hljs-comment">// &lt;-- 调用位置！ </span>&#125;</code></pre></div><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;foo.<span class="hljs-title function_">call</span>(obj); <span class="hljs-comment">// 2</span></code></pre></div><p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。这通常被称为“装箱”。</p><p>显式绑定仍然无法解决我们之前提出的丢失绑定问题</p><h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><p>但是显式绑定的一个变种可以解决这个问题</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  foo.<span class="hljs-title function_">call</span>(obj);&#125;;<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// 2 </span><span class="hljs-built_in">setTimeout</span>(bar, <span class="hljs-number">100</span>); <span class="hljs-comment">// 2</span><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this</span>bar.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">window</span>); <span class="hljs-comment">//2</span></code></pre></div><p>我们创建了函数 bar()，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 </p><p>总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定</p><p>硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something);  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);&#125;;<span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 2 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 5</span></code></pre></div><p>另一种使用方法是创建一个 i可以重复使用的辅助函数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something);  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;&#125; <span class="hljs-comment">// 简单的辅助绑定函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">fn, obj</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>);  &#125;;&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">var</span> bar = <span class="hljs-title function_">bind</span>(foo, obj);<span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 2 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 5</span></code></pre></div><p>由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype. bind，它的用法如下：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>, something);  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + something;&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(obj);<span class="hljs-keyword">var</span> b = <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 2 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 5</span></code></pre></div><p>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。 </p><h4 id="API调用的“上下文”"><a href="#API调用的“上下文”" class="headerlink" title="API调用的“上下文”"></a>API调用的“上下文”</h4><p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”（</p><p>context），其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">el</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(el, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&quot;awesome&quot;</span> &#125;; <span class="hljs-comment">// 调用 foo(..) 时把 this 绑定到 obj</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(foo, obj); <span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span></code></pre></div><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。 </p><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会 调用类中的构造函数。通常的形式是这样的：</p><div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">something</span> <span class="hljs-operator">=</span> new MyClass(..)<span class="hljs-comment">;</span></code></pre></div><p>JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开 发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实 际上和面向类的语言完全不同</p><p>首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><p>举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它： 15.7.2 Number 构造函数 当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的 对象。 所以，包括内置对象函数（比如 Number(..)，详情请查看第 3 章）在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区 别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 </p><ol><li><p>创建（或者说构造）一个全新的对象。 </p></li><li><p>这个新对象会被执行 [[ 原型 ]] 连接。 </p></li><li><p>这个新对象会绑定到函数调用的 this。 </p></li><li><p>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</p></li></ol><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><strong>默认绑定的优先级是四条规则中最低的</strong></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">foo</span>: foo &#125;;<span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">foo</span>: foo &#125;;obj1.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span>obj2.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3</span>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj2); <span class="hljs-comment">// 3</span>obj2.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj1); <span class="hljs-comment">// 2</span></code></pre></div><p><strong>显示绑定的优先级高于隐式绑定</strong></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something;&#125;<span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">foo</span>: foo &#125;;<span class="hljs-keyword">var</span> obj2 = &#123;&#125;;obj1.<span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span>obj1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj2, <span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">a</span>); <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.<span class="hljs-title function_">foo</span>(<span class="hljs-number">4</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">a</span>); <span class="hljs-comment">// 4</span></code></pre></div><p><strong>new 绑定比隐式绑定优先级高</strong></p><p>new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级</p><p>在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们 提供的对象绑定到 this 上。</p><p>这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new 来控制 this 绑定。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something;&#125;<span class="hljs-keyword">var</span> obj1 = &#123;&#125;;<span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(obj1);<span class="hljs-title function_">bar</span>(<span class="hljs-number">2</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz.<span class="hljs-property">a</span>); <span class="hljs-comment">// 3</span></code></pre></div><p>bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3。相反，new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。</p><p>ES5 中内置的 Function.prototype.bind(..) 更加复杂。下面是 MDN 提供的一种 bind(..) 实现，为了方便阅读我们对代码进行了排版：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span>) &#123;  <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">oThis</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;      <span class="hljs-comment">// 与 ECMAScript 5 最接近的 // 内部 IsCallable 函数</span>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(        <span class="hljs-string">&quot;Function.prototype.bind - what is trying &quot;</span> +          <span class="hljs-string">&quot;to be bound is not callable&quot;</span>      );    &#125;    <span class="hljs-keyword">var</span> aArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>),      fToBind = <span class="hljs-variable language_">this</span>,      fNOP = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,      fBound = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> fToBind.<span class="hljs-title function_">apply</span>(          <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="hljs-variable language_">this</span> : oThis,          aArgs.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>))        );      &#125;;    fNOP.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;    fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fNOP</span>();    <span class="hljs-keyword">return</span> fBound;  &#125;;&#125;</code></pre></div><p>polyfill 代码主要用于旧浏览器的兼容，比如说在旧的浏览器中并没 有内置 bind 函数，因此可以使用 polyfill 代码在旧浏览器中实现新的功 能），对于 new 使用的硬绑定函数来说，这段 polyfill 代码和 ES5 内置的 bind(..) 函数并不完全相同（后面会介绍为什么要在 new 中使用硬绑定函 数）。由于 polyfill 并不是内置函数，所以无法创建一个不包含 .prototype 的函数，因此会具有一些副作用。如果你要在 new 中使用硬绑定函数并且依 赖 polyfill 代码的话，一定要非常小心</p><p>下面是 new 修改 this 的相关代码：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="hljs-variable language_">this</span> : oThis <span class="hljs-comment">// ... 以及： </span>fNOP.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fNOP</span>();</code></pre></div><p>这段代码会判断硬绑定函数是否是被 new 调用，如果是的话就会使用新创建 的 this 替换硬绑定的 this。</p><p>那么，为什么要在 new 中使用硬绑定函数呢？直接使用普通函数不是更简单吗？</p><p>之所以要在 new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind(..) 的功能之一就是可以把除了第一个 参数（第一个参数用于绑定 this）之外的其他参数都传给下层的函数（这种技术称为“部 分应用”，是“柯里化”的一种）。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">p1, p2</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = p1 + p2;&#125; <span class="hljs-comment">// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么 // 反正使用 new 时 this 会被修改</span><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;p1&quot;</span>);<span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-string">&quot;p2&quot;</span>);baz.<span class="hljs-property">val</span>; <span class="hljs-comment">// p1p2</span></code></pre></div><h4 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h4><ol><li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 </li></ol><p>var bar = new foo() </p><ol start="2"><li>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 </li></ol><p>var bar = foo.call(obj2) </p><ol start="3"><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 </li></ol><p>var bar = obj1.foo() </p><ol start="4"><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 </li></ol><p>var bar = foo() </p><h2 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h2><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;foo.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 2</span></code></pre></div><p>一种非常常见的做法是使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。 类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a:&quot;</span> + a + <span class="hljs-string">&quot;, b:&quot;</span> + b);&#125; <span class="hljs-comment">// 把数组“展开”成参数 foo.apply( null, [2, 3] ); // a:2, b:3</span><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);<span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// a:2, b:3</span></code></pre></div><p>可以用 … 操作符代替 apply(..) 来“展 开”数组，foo(…[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的 this 绑定。可惜，在 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。 </p><p>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序 然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览 器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）。</p><p>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序 产生任何副作用</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a:&quot;</span> + a + <span class="hljs-string">&quot;, b:&quot;</span> + b);&#125; <span class="hljs-comment">// 我们的 DMZ 空对象</span><span class="hljs-keyword">var</span> ø = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 把数组展开成参数</span>foo.<span class="hljs-title function_">apply</span>(ø, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// a:2, b:3 // 使用 bind(..) 进行柯里化</span><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(ø, <span class="hljs-number">2</span>);<span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// a:2, b:3</span></code></pre></div><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。</p><p>间接引用最容易在赋值时发生：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">foo</span>: foo &#125;;<span class="hljs-keyword">var</span> p = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">4</span> &#125;;o.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 3</span>(p.<span class="hljs-property">foo</span> = o.<span class="hljs-property">foo</span>)(); <span class="hljs-comment">// 2</span></code></pre></div><p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。 注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。 </p><h3 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h3><p>之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new 时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。</p><p>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。可以通过一种被称为软绑定的方法来实现我们想要的效果：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span>) &#123;  <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;    <span class="hljs-keyword">var</span> fn = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 捕获所有 curried 参数</span>    <span class="hljs-keyword">var</span> curried = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">var</span> bound = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(        !<span class="hljs-variable language_">this</span> || <span class="hljs-variable language_">this</span> === (<span class="hljs-variable language_">window</span> || <span class="hljs-variable language_">global</span>) ? obj : <span class="hljs-variable language_">this</span>,        curried.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>(curried, <span class="hljs-variable language_">arguments</span>)      );    &#125;;    bound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);    <span class="hljs-keyword">return</span> bound;  &#125;;&#125;</code></pre></div><p>除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里 化</p><p>下面我们看看 softBind 是否实现了软绑定功能</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj&quot;</span> &#125;,  obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj2&quot;</span> &#125;,  obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;obj3&quot;</span> &#125;;<span class="hljs-keyword">var</span> fooOBJ = foo.<span class="hljs-title function_">softBind</span>(obj);<span class="hljs-title function_">fooOBJ</span>(); <span class="hljs-comment">// name: obj</span>obj2.<span class="hljs-property">foo</span> = foo.<span class="hljs-title function_">softBind</span>(obj);obj2.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// name: obj2 &lt;---- 看！！！</span>fooOBJ.<span class="hljs-title function_">call</span>(obj3); <span class="hljs-comment">// name: obj3 &lt;---- 看！</span><span class="hljs-built_in">setTimeout</span>(obj2.<span class="hljs-property">foo</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// name: obj &lt;---- 应用了软绑定</span></code></pre></div><p>可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默 认绑定，则会将 this 绑定到 obj。</p><h3 id="this词法-1"><a href="#this词法-1" class="headerlink" title="this词法"></a>this词法</h3><p>箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定 义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决 定 this。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 返回一个箭头函数</span>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123;    <span class="hljs-comment">//this 继承自 foo()</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);  &#125;;&#125;<span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">call</span>(obj1);bar.<span class="hljs-title function_">call</span>(obj2); <span class="hljs-comment">// 2, 不是 3 ！</span></code></pre></div><p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不 行！）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 这里的 this 在此法上继承自 foo()</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);  &#125;, <span class="hljs-number">100</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;foo.<span class="hljs-title function_">call</span>(obj); <span class="hljs-comment">// 2</span></code></pre></div><p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体 现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经 在使用一种几乎和箭头函数完全一样的模式。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// lexical capture of this</span>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self.<span class="hljs-property">a</span>);  &#125;, <span class="hljs-number">100</span>);&#125;<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;foo.<span class="hljs-title function_">call</span>(obj); <span class="hljs-comment">// 2</span></code></pre></div><p>虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替 代的是 this 机制</p><p>如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数 来否定 this 机制，那你或许应当：</p><ol><li><p>只使用词法作用域并完全抛弃错误 this 风格的代码； </p></li><li><p>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。</p></li></ol><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>对象可以通过两种形式定义：声明（文字）形式和构造形式。</p><p>对象的文字语法大概是这样：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObj = &#123;  <span class="hljs-attr">key</span>: value, <span class="hljs-comment">// ...</span>&#125;;</code></pre></div><p>构造形式大概是这样：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();myObj.<span class="hljs-property">key</span> = value;</code></pre></div><p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。一般会采用声明形式创建函数</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>js中常见的类型有null, undefined,boolean,number,string,symbol,object,bigint,symbol,基本数据类型不是对象，null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行 typeof null 时会返回字符串 “object”。实际上，null 本身是基本类型</p><p>不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”</p><p>实际上，JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”）。JavaScript 中的函 数是“一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作 其他对象一样操作函数（比如当作另一个函数的参数）。</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>String,Number,Boolean,Object,Function,Array,Date,RegExp,Error,内置函数可以当作构造函数来使用</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">&quot;I am a string&quot;</span>;<span class="hljs-keyword">typeof</span> strPrimitive; <span class="hljs-comment">// &quot;string&quot;</span>strPrimitive <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// false</span><span class="hljs-keyword">var</span> strObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;I am a string&quot;</span>);<span class="hljs-keyword">typeof</span> strObject; <span class="hljs-comment">// &quot;object&quot;</span>strObject <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span><span class="hljs-comment">// 检查 sub-type 对象</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(strObject); <span class="hljs-comment">// [object String]</span></code></pre></div><p>boolean,number,string,symbol,bigint,symbol这些使用声明方式创建的变量，可以直接访问字面量上的属性和方法，之所以可以这 样做，是因为引擎自动把字面量转换成 对应的对象，所以可以访问属性和方法。null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有 文字形式</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span>myObject[<span class="hljs-string">&quot;a&quot;</span>]; <span class="hljs-comment">// 2</span></code></pre></div><p>如果要访问 myObject 中 a 位置上的值，我们需要使用 . 操作符或者 [] 操作符。.a 语法通 常被称为“属性访问”，[“a”] 语法通常被称为“键访问”。实际上它们访问的是同一个位 置，并且会返回相同的值 2，所以这两个术语是可以互换的</p><p>这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范，而 [“..”] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名。举例来说，如果要引用名称为 “Super-Fun!” 的属性，那就必须使用 [“Super-Fun!”] 语法访问，因为 Super-Fun! 并不是一个有效 的标识符属性名。</p><p>此外，由于 [“..”] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串，比如说：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">var</span> idx;<span class="hljs-keyword">if</span> (wantA) &#123;  idx = <span class="hljs-string">&quot;a&quot;</span>;&#125; <span class="hljs-comment">// 之后</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject[idx]); <span class="hljs-comment">// 2</span></code></pre></div><p>在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的 确是数字，但是在对象属性名中数字会被转换成字符串，所以当心不要搞混对象和数组中 数字的用法：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;&#125;;myObject[<span class="hljs-literal">true</span>] = <span class="hljs-string">&quot;foo&quot;</span>;myObject[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;bar&quot;</span>;myObject[myObject] = <span class="hljs-string">&quot;baz&quot;</span>;myObject[<span class="hljs-string">&quot;true&quot;</span>]; <span class="hljs-comment">// &quot;foo&quot;</span>myObject[<span class="hljs-string">&quot;3&quot;</span>]; <span class="hljs-comment">// &quot;bar&quot;</span>myObject[<span class="hljs-string">&quot;[object Object]&quot;</span>]; <span class="hljs-comment">// &quot;baz&quot;</span></code></pre></div><h4 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h4><p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&quot;foo&quot;</span>;<span class="hljs-keyword">var</span> myObject = &#123; [prefix + <span class="hljs-string">&quot;bar&quot;</span>]: <span class="hljs-string">&quot;hello&quot;</span>, [prefix + <span class="hljs-string">&quot;baz&quot;</span>]: <span class="hljs-string">&quot;world&quot;</span> &#125;;myObject[<span class="hljs-string">&quot;foobar&quot;</span>]; <span class="hljs-comment">// hello</span>myObject[<span class="hljs-string">&quot;foobaz&quot;</span>]; <span class="hljs-comment">// world</span></code></pre></div><p>可计算属性名最常用的场景可能是 ES6 的符号（Symbol）</p><h4 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h4><p>“函数”和“方法”在 JavaScript 中是可以互换的。</p><p>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);  &#125;,&#125;;<span class="hljs-keyword">var</span> someFoo = myObject.<span class="hljs-property">foo</span>;someFoo; <span class="hljs-comment">// function foo()&#123;..&#125;</span>myObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// function foo()&#123;..&#125;</span></code></pre></div><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组也支持 [] 访问形式，不过就像我们之前提到过的，数组有一套更加结构化的值存储机制（不过仍然不限制值的类型）。数组期望的是数值下标，也就是说值存储的位置（通 常被称为索引）是整数，比如说 0 和 42：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span>];myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span>myArray[<span class="hljs-number">0</span>]; <span class="hljs-comment">// &quot;foo&quot;</span>myArray[<span class="hljs-number">2</span>]; <span class="hljs-comment">// &quot;bar&quot;</span></code></pre></div><p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span>];myArray.<span class="hljs-property">baz</span> = <span class="hljs-string">&quot;baz&quot;</span>;myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span>myArray.<span class="hljs-property">baz</span>; <span class="hljs-comment">// &quot;baz&quot;</span></code></pre></div><p>可以看到虽然添加了命名属性（无论是通过 . 语法还是 [] 语法），数组的 length 值并未发 生变化。</p><p>你完全可以把数组当作一个普通的键 / 值对象来使用，并且不添加任何数值索引，但是这 并不是一个好主意。数组和普通的对象都根据其对应的行为和用途进行了优化，所以最好 只用对象来存储键 / 值对，只用数组来存储数值下标 / 值对</p><p>注意：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成 一个数值下标（因此会修改数组的内容而不是添加一个属性）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;bar&quot;</span>];myArray[<span class="hljs-string">&quot;3&quot;</span>] = <span class="hljs-string">&quot;baz&quot;</span>;myArray.<span class="hljs-property">length</span>; <span class="hljs-comment">// 4</span>myArray[<span class="hljs-number">3</span>]; <span class="hljs-comment">// &quot;baz&quot;</span></code></pre></div><h4 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">anotherFunction</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">/*..*/</span>&#125;<span class="hljs-keyword">var</span> anotherObject = &#123; <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> &#125;;<span class="hljs-keyword">var</span> anotherArray = [];<span class="hljs-keyword">var</span> myObject = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">b</span>: anotherObject, <span class="hljs-comment">// 引用，不是复本！</span>  <span class="hljs-attr">c</span>: anotherArray, <span class="hljs-comment">// 另一个引用！</span>  <span class="hljs-attr">d</span>: anotherFunction,&#125;;anotherArray.<span class="hljs-title function_">push</span>(anotherObject, myObject);</code></pre></div><p>如何准确地表示 myObject 的复制呢？</p><p>首先，我们应该判断它是浅复制还是深复制。对于浅拷贝来说，复制出的新对象中 a 的值会 复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用，它们 和旧对象中 b、c、d 引用的对象是一样的。对于深复制来说，除了复制 myObject 以外还会复 制 anotherObject 和 anotherArray。这时问题就来了，anotherArray 引用了 anotherObject 和 myObject，所以又需要复制 myObject，这样就会由于循环引用导致死循环。</p><p>对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解 析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法： </p><p>var newObj = JSON.parse( JSON.stringify( someObj ) ); </p><p>当然，这种方法需要保证对象是 JSON 安全的，所以只适用于部分情况相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..) 方 法来实现浅复制。Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个 或多个源对象。它会遍历一个或多个源对象的所有可枚举（enumerable，参见下面的代码） 的自有键（owned key，很快会介绍）并把它们复制（使用 = 操作符赋值）到目标对象，最 后返回目标对象，就像这样：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, myObject);newObj.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span>newObj.<span class="hljs-property">b</span> === anotherObject; <span class="hljs-comment">// true</span>newObj.<span class="hljs-property">c</span> === anotherArray; <span class="hljs-comment">// true</span>newObj.<span class="hljs-property">d</span> === anotherFunction; <span class="hljs-comment">// true</span></code></pre></div><p>由于 Object.assign(..) 就是使用 = 操作符来赋值，所 以源对象属性的一些特性（比如 writable）不会被复制到目标对象</p><h4 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h4><div class="code-wrapper"><pre><code class="hljs awk">var myObject = &#123; a: <span class="hljs-number">2</span> &#125;;Object.getOwnPropertyDescriptor(myObject, <span class="hljs-string">&quot;a&quot;</span>);<span class="hljs-regexp">//</span> &#123; <span class="hljs-regexp">//</span> value: <span class="hljs-number">2</span>,<span class="hljs-regexp">//</span> writable: true,<span class="hljs-regexp">//</span> enumerable: true,<span class="hljs-regexp">//</span> configurable: true<span class="hljs-regexp">//</span> &#125;</code></pre></div><p>如你所见，这个普通的对象属性对应的属性描述符（也被称为“数据描述符”，因为它 只保存一个数据值）可不仅仅只是一个 2。它还包含另外三个特性：writable（可写）、 enumerable（可枚举）和 configurable（可配置）。</p><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,&#125;);myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span></code></pre></div><p>我们使用 defineProperty(..) 给 myObject 添加了一个普通的属性并显式指定了一些特性。 然而，一般来说你不会使用这种方式，除非你想修改属性描述符。</p><p><strong>Writable</strong> </p><p>writable 决定是否可以修改属性的值</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！</span>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,&#125;);myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span></code></pre></div><p>如你所见，我们对于属性值的修改静默失败（silently failed）了。如果在严格模式下，这 种方法会出错：</p><div class="code-wrapper"><pre><code class="hljs js">(<span class="hljs-string">&quot;use strict&quot;</span>);<span class="hljs-keyword">var</span> myObject = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可写！</span>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,&#125;);myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// TypeError</span></code></pre></div><p>TypeError 错误表示我们无法修改一个不可写的属性。 </p><p>之后我们会介绍 getter 和 setter，不过简单来说，你可以把 writable:false 看 作是属性不可改变，相当于你定义了一个空操作 setter。严格来说，如果要 和 writable:false 一致的话，你的 setter 被调用时应当抛出一个 TypeError 错误</p><p><strong>Configurable</strong> </p><p>只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 3</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不可配置！</span>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,&#125;);myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 4</span>myObject.<span class="hljs-property">a</span> = <span class="hljs-number">5</span>;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 5</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-number">6</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,&#125;); <span class="hljs-comment">// TypeError</span></code></pre></div><p>最后一个 defineProperty(..) 会产生一个 TypeError 错误，不管是不是处于严格模式，尝 试修改一个不可配置的属性描述符都会出错。注意：如你所见，把 configurable 修改成 false 是单向操作，无法撤销！</p><p>要注意有一个小小的例外：即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。</p><p>除了无法修改，configurable:false 还会禁止删除这个属性：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><span class="hljs-keyword">delete</span> myObject.<span class="hljs-property">a</span>;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// undefined</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-string">&quot;a&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,&#125;);myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span><span class="hljs-keyword">delete</span> myObject.<span class="hljs-property">a</span>;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span></code></pre></div><p>在本例中，delete 只用来直接删除对象的（可删除）属性。如果对象的某个属性是某个 对象 / 函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象 / 函数就可以被垃圾回收。但是，不要把 delete 看作一个释放内存的工具（就像 C/C++ 中那 样），它就是一个删除对象属性的操作，仅此而已。 </p><p><strong>enumerable</strong></p><p>从名字就可以看出，这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍 然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。 用户定义的所有的普通属性默认都是 enumerable，这通常就是你想要的。但是如果你不希 望某些特殊属性出现在枚举中，那就把它设置成 enumerable:false。</p><h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><p>有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 ES5 中可以通过很 多种方法来实现。</p><p>很重要的一点是，所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和 它的直接属性。如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内 容不受影响，仍然是可变的： </p><div class="code-wrapper"><pre><code class="hljs js">myImmutableObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// [1,2,3] </span>myImmutableObject.<span class="hljs-property">foo</span>.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> ); myImmutableObject.<span class="hljs-property">foo</span>; <span class="hljs-comment">// [1,2,3,4]</span></code></pre></div><p>假设代码中的 myImmutableObject 已经被创建而且是不可变的，但是为了保护它的内容 myImmutableObject.foo，你还需要使用下面的方法让 foo 也不可变。</p><h5 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h5><p>结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、 重定义或者删除）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(myObject, <span class="hljs-string">&quot;FAVORITE_NUMBER&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,&#125;);</code></pre></div><h5 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h5><p>如 果 你 想 禁 止 一 个 对 象 添 加 新 属 性 并 且 保 留 已 有 属 性， 可 以 使 用 Object.preventExtensions(..)：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(myObject);myObject.<span class="hljs-property">b</span> = <span class="hljs-number">3</span>;myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span></code></pre></div><p>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。 </p><h5 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h5><p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。</p><p>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以 修改属性的值）</p><h5 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h5><p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值。</p><p>这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意 直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。</p><p>你可以“深度冻结”一个对象，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要小心，因为这样做有可能会在无意中冻结其他（共享）对象。</p><h4 id="Get"><a href="#Get" class="headerlink" title="[[Get]]"></a>[[Get]]</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span></code></pre></div><p>在语言规范中，myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作（有点像函数调 用：<a href="">[Get]</a>）。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。</p><p>然而，如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要 的行为。（其实就是遍历可能存在的 [[Prototype]] 链， 也就是原型链）</p><p>如果无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined：</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> myObject = &#123; a:<span class="hljs-number">2</span> &#125;;myObject.b; <span class="hljs-comment">// undefined</span></code></pre></div><p>注意，这种方法和访问变量时是不一样的。如果你引用了一个当前词法作用域中不存在的 变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常：</p><h4 id="Put"><a href="#Put" class="headerlink" title="[[Put]]"></a>[[Put]]</h4><p>既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 操作 </p><p>你可能会认为给对象的属性赋值会触发 [[Put]] 来设置或者创建这个属性。但是实际情况并不完全是这样。[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性（这是最重要的因素）。</p><p>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。 </p><ol><li><p>属性是否是访问描述符？如果是并且存在 setter 就调用 setter。 </p></li><li><p>属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在 严格模式下抛出 TypeError 异常。 </p></li><li><p>如果都不是，将该值设置为属性的值</p></li></ol><p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂</p><h4 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h4><p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取</p><p>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法 应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用。</p><p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述符”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;  <span class="hljs-comment">// 给 a 定义一个 getter</span>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  &#125;,&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(  myObject, <span class="hljs-comment">// 目标对象 &quot;b&quot;,</span>  <span class="hljs-comment">// 属性名</span>  &#123;    <span class="hljs-comment">// 描述符 // 给 b 设置一个 getter</span>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> * <span class="hljs-number">2</span>;    &#125;, <span class="hljs-comment">// 确保 b 会出现在对象的属性列表中</span>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,  &#125;);myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 4</span></code></pre></div><p>不管是对象文字语法中的 get a() { .. }，还是 defineProperty(..) 中的显式定义，二者 都会在对象中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数， 它的返回值会被当作属性访问的返回值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;  <span class="hljs-comment">// 给 a 定义一个 getter</span>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  &#125;,&#125;;myObject.<span class="hljs-property">a</span> = <span class="hljs-number">3</span>;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span></code></pre></div><p>由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，不会抛 出错误。而且即便有合法的 setter，由于我们自定义的 getter 只会返回 2，所以 set 操作是 没有意义的</p><p>为了让属性更合理，还应当定义 setter，和你期望的一样，setter 会覆盖单个属性默认的 [[Put]]（也被称为赋值）操作。通常来说 getter 和 setter 是成对出现的（只定义一个的话 通常会产生意料之外的行为）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;  <span class="hljs-comment">// 给 a 定义一个 getter</span>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_a_</span>;  &#125;, <span class="hljs-comment">// 给 a 定义一个 setter</span>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">val</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_a_</span> = val * <span class="hljs-number">2</span>;  &#125;,&#125;;myObject.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 4</span></code></pre></div><h4 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h4><p>in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中（参见第 5 章）。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。 </p><p>所 有 的 普 通 对 象 都 可 以 通 过 对 于 Object.prototype 的 委 托（ 参 见 第 5 章 ） 来 访 问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 Object. create(null) 来创建——参见第 5 章）。在这种情况下，hasOwnProperty(..) 就会失败。 </p><p>这 时 可 以 使 用 一 种 更 加 强 硬 的 方 法 来 进 行 判 断：Object.prototype.hasOwnProperty.call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定</p><p>看起来 in 操作符可以检查容器内是否有某个值，但是它实际上检查的是某 个属性名是否存在。对于数组来说这个区别非常重要，4 in [2, 4, 6] 的结 果并不是你期待的 True，因为 [2, 4, 6] 这个数组中包含的属性名是 0、1、 2，没有 4。</p><p>可以看到，myObject.b 确实存在并且有访问值，但是却不会出现在 for..in 循环中（尽管 可以通过 in 操作符来判断是否存在）。原因是“可枚举”就相当于“可以出现在对象属性 的遍历中”。 </p><p>在数组上应用 for..in 循环有时会产生出人意料的结果，因为这种枚举不 仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 for..in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引。</p><p>也可以通过另一种方式来区分属性是否可枚举：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObject = &#123;&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(  myObject,  <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-comment">// 让 a 像普通属性一样可以枚举</span>  &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125;);<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(  myObject,  <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-comment">// 让 b 不可枚举</span>  &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125;);myObject.<span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// true</span>myObject.<span class="hljs-title function_">propertyIsEnumerable</span>(<span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">// false</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(myObject); <span class="hljs-comment">// [&quot;a&quot;]</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(myObject); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span></code></pre></div><p>propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链 上）并且满足 enumerable:true。</p><p>Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举。</p><p>in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..)和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</p><p>（目前）并没有内置的方法可以获取 in 操作符使用的属性列表（对象本身的属性以 及 [[Prototype]] 链中的所有属性，参见第 5 章）。不过你可以递归遍历某个对象的整条 [[Prototype]] 链并保存每一层中使用 Object.keys(..) 得到的属性列表——只包含可枚举属性。</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链）。但是如何遍 历属性的值呢？</p><p>对于数值索引的数组来说，可以使用标准的 for 循环来遍历值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; myArray.<span class="hljs-property">length</span>; i++) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray[i]);&#125; <span class="hljs-comment">// 1 2 3</span></code></pre></div><p>这实际上并不是在遍历值，而是遍历下标来指向值，如 myArray[i]</p><p>ES5 中增加了一些数组的辅助迭代器，包括 forEach(..)、every(..) 和 some(..)。每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们 对于回调函数返回值的处理方式不同。</p><p>forEach(..) 会遍历数组中的所有值并忽略回调函数的返回值。every(..) 会一直运行直到回调函数返回 false（或者“假”值），some(..) 会一直运行直到回调函数返回 true（或者 “真”值）。every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似，它们会提前 终止遍历。使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可枚举属性，你需要手动获取属性值。</p><p>遍历数组下标时采用的是数字顺序（for 循环或者其他迭代器），但是遍历对 象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此， 在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们 是不可靠的。 </p><p>那么如何直接遍历值而不是数组下标（或者对象属性）呢？幸好，ES6 增加了一种用来遍 历数组的 for..of 循环语法（如果对象本身定义了迭代器的话也可以遍历对象）：</p><p>for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值数组有内置的 @@iterator，因此 for..of 可以直接应用在数组上。我们使用内置的 @@ iterator 来手动遍历数组</p><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h2><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引 用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p><p>注意：很快我们就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见</p><p>使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到 （并且是 enumerable，参见第 3 章）的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> anotherObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-comment">// 创建一个关联到 anotherObject 的对象</span><span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(anotherObject);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> myObject) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;found: &quot;</span> + k);&#125;<span class="hljs-comment">// found: a</span><span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">in</span> myObject; <span class="hljs-comment">// true</span></code></pre></div><h3 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h3><p>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。由于所有的“普通” （内置，不是特定主机的扩展）对象都“源于”（或者说把 [[Prototype]] 链的顶端设置为） 这个 Object.prototype 对象，所以它包含 JavaScript 中许多通用的功能。 </p><p>有 些 功 能 你 应 该 已 经 很 熟 悉 了， 比 如 说 .toString() 和 .valueOf(),.hasOwnProperty(..),.isPrototypeOf(..)，</p><h4 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h4><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">myObject.foo</span> = <span class="hljs-string">&quot;bar&quot;</span><span class="hljs-comment">;</span></code></pre></div><p>下面我们分析一下如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 myObject.foo = “bar” 会出现的三种情况</p><p>如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性（参见第 3 章）并且没 有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性。 </p><p>如果在 [[Prototype]] 链上层存在 foo，但是它被标记为只读（writable:false），那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 </p><p>如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter（参见第 3 章），那就一定会 调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这 个 setter</p><p>大多数开发者都认为如果向 [[Prototype]] 链上层已经存在的属性（[[Put]]）赋值，就一 定会触发屏蔽，但是如你所见，三种情况中只有一种（第一种）是这样的,如果你希望在第二种和第三种情况下也屏蔽 foo，那就不能使用 = 操作符来赋值，而是使 用 Object.defineProperty(..)（参见第 3 章）来向 myObject 添加 foo</p><p>第二种情况可能是最令人意外的，只读属性会阻止 [[Prototype]] 链下层 隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承。你可 以把原型链上层的 foo 看作是父类中的属性，它会被 myObject 继承（复 制），这样一来 myObject 中的 foo 属性也是只读，所以无法创建。但是一定 要注意，实际上并不会发生类似的继承复制（参见第 4 章和第 5 章）。这看 起来有点奇怪，myObject 对象竟然会因为其他对象中有一个只读 foo 就不 能包含 foo 属性。更奇怪的是，这个限制只存在于 = 赋值中，使用 Object.defineProperty(..) 并不会受到影响。</p><p>如果需要对屏蔽方法进行委托的话就不得不使用丑陋的显式伪多态（参见第 4 章）。通常 来说，使用屏蔽得不偿失，所以应当尽量避免使用。第 6 章会介绍另一种不使用屏蔽的更加简洁的设计模式</p><p>如果需要对屏蔽方法进行委托的话就不得不使用丑陋的显式伪多态（参见第 4 章）。通常 来说，使用屏蔽得不偿失，所以应当尽量避免使用。第 6 章会介绍另一种不使用屏蔽的更 加简洁的设计模式。 </p><p>有些情况下会隐式产生屏蔽，一定要当心。思考下面的代码</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> anotherObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(anotherObject);anotherObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span>anotherObject.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// true</span>myObject.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// false</span>myObject.<span class="hljs-property">a</span>++; <span class="hljs-comment">// 隐式屏蔽！</span>anotherObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 3</span>myObject.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// true</span></code></pre></div><p>尽管 myObject.a++ 看起来应该（通过委托）查找并增加 anotherObject.a 属性，但是别忘 了 ++ 操作相当于 myObject.a = myObject.a + 1。因此 ++ 操作首先会通过 [[Prototype]] 查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]] 将值 3 赋给 myObject 中新建的屏蔽属性 a，天呐！</p><p>修改委托属性时一定要小心。如果想让 anotherObject.a 的值增加，唯一的办法是 anotherObject.a++。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true</span><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();a.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true</span></code></pre></div><p>Foo.prototype 默认（在代码中第一行声明时！）有一个公有并且不可枚举（参见第 3 章） 的属性 .constructor，这个属性引用的是对象关联的函数（本例中是 Foo）。此外，我们可以看到通过“构造函数”调用 new Foo() 创建的对象也有一个 .constructor 属性，指向 </p><p>“创建这个对象的函数”。 实际上 a 本身并没有 .constructor 属性。而且，虽然 a.constructor 确实指 向 Foo 函数，但是这个属性并不是表示 a 由 Foo“构造”，</p><p>看起来 a.constructor === Foo 为真意味着 a 确 实有一个指向 Foo 的 .constructor 属性，但是事实不是这样。 实际上，.constructor 引用同样被委托给了 Foo.prototype，而 Foo.prototype.constructor 默认指向 Foo。</p><p>把 .constructor 属性指向 Foo 看作是 a 对象由 Foo“构造”非常容易理解，但这只不过 是一种虚假的安全感。a.constructor 只是通过默认的 [[Prototype]] 委托指向 Foo，这和“构造”毫无关系。相反，对于 .constructor 的错误理解很容易对你自己产生误导。 举例来说，Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性。如果 你创建了一个新对象并替换了函数默认的 .prototype 对象引用，那么新对象并不会自动获 得 .constructor 属性。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">/* .. */</span>&#125;<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-comment">/* .. */</span>&#125;; <span class="hljs-comment">// 创建一个新原型对象</span><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();a1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// false!</span>a1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// true!</span></code></pre></div><p>a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo. prototype。但是这个对象也没有 .constructor 属性（不过默认的 Foo.prototype 对象有这 个属性！），所以它会继续委托，这次会委托给委托链顶端的 Object.prototype。这个对象 有 .constructor 属性，指向内置的 Object(..) 函数。 </p><p>当然，你可以给 Foo.prototype 添加一个 .constructor 属性，不过这需要手动添加一个符 合正常行为的不可枚举</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">/* .. */</span>&#125;<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-comment">/* .. */</span>&#125;; <span class="hljs-comment">// 创建一个新原型对象</span><span class="hljs-comment">// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性</span><span class="hljs-comment">// 新对象属性起到 Foo.prototype 的作用</span><span class="hljs-comment">// 关于 defineProperty(..)，参见第 3 章</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Foo</span>, <span class="hljs-comment">// 让 .constructor 指向 Foo</span>&#125;);</code></pre></div><p>实际上，对象的 .constructor 会默认指向一个函数，这个函数可以通过对象的 .prototype 引用。“constructor”和“prototype”这两个词本身的含义可能适用也可能不适用。最好的 办法是记住这一点“constructor 并不表示被构造.constructor 并不是一个不可变属性。它是不可枚举（参见上面的代码）的，但是它的值 是可写的（可以被修改）。此外，你可以给任意 [[Prototype]] 链中的任意对象添加一个名 为 constructor 的属性或者对其进行修改，你可以任意对其赋值。</p><p>和 [[Get]] 算法查找 [[Prototype]] 链的机制一样，.constructor 属性引用的目标可能和 你想的完全不同。</p><h2 id="（原型）继承"><a href="#（原型）继承" class="headerlink" title="（原型）继承"></a>（原型）继承</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;&#125;<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params">name, label</span>) &#123;  <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);  <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span> = label;&#125; <span class="hljs-comment">// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype</span><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 注意！现在没有 Bar.prototype.constructor 了 // 如果你需要这个属性的话可能需要手动修复一下它</span><span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myLabel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span>;&#125;;<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;obj a&quot;</span>);a.<span class="hljs-title function_">myName</span>(); <span class="hljs-comment">// &quot;a&quot; a.myLabel(); // &quot;obj a&quot;</span></code></pre></div><p>这段代码的核心部分就是语句 Bar.prototype = Object.create( Foo.prototype )。调用Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo.prototype）。</p><p>换句话说，这条语句的意思是：“创建一个新的 Bar.prototype 对象并把它关联到 Foo. prototype”。</p><p>声明 function Bar() { .. } 时，和其他函数一样，Bar 会有一个 .prototype 关联到默认的 对象，但是这个对象并不是我们想要的 Foo.prototype。因此我们创建了一个新对象并把它关联到我们希望的对象上，直接把原始的关联对象抛弃掉。</p><p>注意，下面这两种方式是常见的错误做法，实际上它们都存在一些问题： </p><p>// 和你想要的机制不一样！ </p><p>Bar.prototype = Foo.prototype; </p><p>// 基本上满足你的需求，但是可能会产生一些副作用 :( </p><p>Bar.prototype = new Foo(); </p><p>Bar.prototype = Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只 是让 Bar.prototype 直接引用 Foo.prototype 对象。因此当你执行类似 Bar.prototype. myLabel = … 的赋值语句时会直接修改 Foo.prototype 对象本身。显然这不是你想要的结 果，否则你根本不需要 Bar 对象，直接使用 Foo 就可以了，这样代码也会更简单一些。</p><p>Bar.prototype = new Foo() 的确会创建一个关联到 Bar.prototype 的新对象。但是它使用 了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些副作用（比如写日志、修改状态、注 册到其他对象、给 this 添加数据属性，等等）的话，就会影响到 Bar() 的“后代”，后果 不堪设想</p><p>因此，要创建一个合适的关联对象，我们必须使用 Object.create(..) 而不是使用具有副 作用的 Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能 直接修改已有的默认对象。</p><p>如果能有一个标准并且可靠的方法来修改对象的 [[Prototype]] 关联就好了。在 ES6 之前， 我们只能通过设置 .<strong>proto</strong> 属性来实现，但是这个方法并不是标准并且无法兼容所有浏 览器。ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修 改关联。 </p><p>我们来对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法：</p><p>// ES6 之前需要抛弃默认的 Bar.prototype </p><p>Bar.ptototype = Object.create( Foo.prototype ); </p><p>// ES6 开始可以直接修改现有的 Bar.prototype </p><p>Object.setPrototypeOf( Bar.prototype, Foo.prototype );</p><p>如果忽略掉 Object.create(..) 方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比 ES6 及其之后的方法更短而且可读性更高。不过无论如何，这是两种完 全不同的语法</p><h4 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h4><p>假设有对象 a，如何寻找对象 a 委托的对象（如果存在的话）呢？在传统的面向类环境中，检查一个实例（JavaScript 中的对象）的继承祖先（JavaScript 中的委托关联）通常被称为 内省（或者反射）。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// ... </span>&#125;<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">blah</span> = ...;  <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()</code></pre></div><p>我们如何通过内省找出 a 的“祖先”（委托关联）呢？第一种方法是站在“类”的角度来 判断</p><div class="code-wrapper"><pre><code class="hljs js">a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>; <span class="hljs-comment">// true</span></code></pre></div><p>instanceof 操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof 回答 的问题是：在 a 的整条 [[Prototype]] 链中是否有指向 Foo.prototype 的对象</p><p>可惜，这个方法只能处理对象（a）和函数（带 .prototype 引用的 Foo）之间的关系。如 果你想判断两个对象（比如 a 和 b）之间是否通过 [[Prototype]] 链关联，只用 instanceof 无法实现。 </p><p>如果使用内置的 .bind(..) 函数来生成一个硬绑定函数（参见第 2 章）的话， 该函数是没有 .prototype 属性的。在这样的函数上使用 instanceof 的话， 目标函数的 .prototype 会代替硬绑定函数的 .prototype。</p><p>通常我们不会在“构造函数调用”中使用硬绑定函数，不过如果你这么 做的话，实际上相当于直接调用目标函数。同理，在硬绑定函数上使用 instanceof 也相当于直接在目标函数上使用 instanceof。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 用来判断 o1 是否关联到（委托）o2 的辅助函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isRelatedTo</span>(<span class="hljs-params">o1, o2</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o2;  <span class="hljs-keyword">return</span> o1 <span class="hljs-keyword">instanceof</span> F;&#125;<span class="hljs-keyword">var</span> a = &#123;&#125;;<span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(a);<span class="hljs-title function_">isRelatedTo</span>(b, a); <span class="hljs-comment">// true</span></code></pre></div><p>isRelatedTo(..) 内部我们声明了一个一次性函数 F，把它的 .prototype 重新赋值并指 向对象 o2，然后判断 o1 是否是 F 的一个“实例”。显而易见，o1 实际上并没有继承 F 也不 是由 F 构造，所以这种方法非常愚蠢并且容易造成误解。问题的关键在于思考的角度，强行在 JavaScript 中应用类的语义（在本例中就是使用 instanceof）就会造成这种尴尬的局 面。</p><p>下面是第二种判断 [[Prototype]] 反射的方法，它更加简洁：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>( a ); <span class="hljs-comment">// true</span></code></pre></div><p>注意，在本例中，我们实际上并不关心（甚至不需要）Foo，我们只需要一个可以用来判 断的对象（本例中是 Foo.prototype）就行。isPrototypeOf(..) 回答的问题是：在 a 的整 条 [[Prototype]] 链中是否出现过 Foo.prototype ？</p><p>同样的问题，同样的答案，但是在第二种方法中并不需要间接引用函数（Foo），它 的 .prototype 属性会被自动访问。</p><p>我们只需要两个对象就可以判断它们之间的关系。举例来说:</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 非常简单：b 是否出现在 c 的 [[Prototype]] 链中？ b.isPrototypeOf( c );</span></code></pre></div><p>注意，这个方法并不需要使用函数（“类”），它直接使用 b 和 c 之间的对象引用来判断它 们的关系。换句话说，语言内置的 isPrototypeOf(..) 函数就是我们的 isRelatedTo(..) 函 数</p><p>我们也可以直接获取一个对象的 [[Prototype]] 链。在 ES5 中，标准的方法是： </p><p>Object.getPrototypeOf( a ); </p><p>可以验证一下，这个对象引用是否和我们想的一样： </p><p>Object.getPrototypeOf( a ) === Foo.prototype; // true </p><p>绝大多数（不是所有！）浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性： </p><p>a.<strong>proto</strong> === Foo.prototype; // true </p><p>这个奇怪的 .__proto__（在 ES6 之前并不是标准！）属性“神奇地”引用了内部的 [[Prototype]] 对象，如果你想直接查找（甚至可以通过 .<strong>proto</strong>.<strong>ptoto</strong>… 来遍历） 原型链的话，这个方法非常有用。</p><p>和我们之前说过的 .constructor 一样，.<strong>proto</strong> 实际上并不存在于你正在使用的对象中 （本例中是 a）。实际上，它和其他的常用函数（.toString()、.isPrototypeOf(..)，等等）一样，存在于内置的 Object.prototype 中。（它们是不可枚举的).此外，.<strong>proto</strong> 看起来很像一个属性，但是实际上它更像一个 getter/setter.</p><p>.<strong>proto</strong> 的实现大致上是这样的:</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;__proto__&quot;</span>, &#123;  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-variable language_">this</span>);  &#125;,  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) &#123;    <span class="hljs-comment">// ES6 中的 setPrototypeOf(..)</span>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-variable language_">this</span>, o);    <span class="hljs-keyword">return</span> o;  &#125;,&#125;);</code></pre></div><p>因此，访问（获取值）a.<strong>proto</strong> 时，实际上是调用了 a.<strong>proto</strong>()（调用 getter 函 数）。虽然 getter 函数存在于 Object.prototype 对象中，但是它的 this 指向对象 a，所以和 Object.getPrototypeOf( a ) 结果相同</p><p>.<strong>proto</strong> 是可设置属性，之前的代码中使用 ES6 的 Object.setPrototypeOf(..) 进行设置。然而，通常来说你不需要修改已有对象的 [[Prototype]]。</p><h2 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h2><p>[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他 对象。 </p><p>通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的 引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;  <span class="hljs-attr">something</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Tell me something good...&quot;</span>);  &#125;,&#125;;<span class="hljs-keyword">var</span> bar = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(foo);bar.<span class="hljs-title function_">something</span>(); <span class="hljs-comment">// Tell me something good...</span></code></pre></div><p>Object.create(..) 会创建一个新对象（bar）并把它关联到我们指定的对象（foo），这样我们就可以充分发挥 [[Prototype]] 机制的威力（委托）并且避免不必要的麻烦（比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用）。</p><p>Object.create(null) 会 创 建 一 个 拥 有 空（ 或 者 说 null）[[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符（之前解释过）无法进行判断，因此总是会返回 false。 这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原 型链的干扰，因此非常适合用来存储数据。 </p><p>Object.create()的polyfill代码</p><p>Object.create(..) 是在 ES5 中新增的函数，所以在 ES5 之前的环境中（比如旧 IE）如果要支持这个功能的话就需要使用一段简单的 polyfill 代码，它部分实现了 Object. create(..) 的功能：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span>) &#123;  <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) &#123;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();  &#125;;&#125;</code></pre></div><p>这段 polyfill 代码使用了一个一次性函数 F，我们通过改写它的 .prototype 属性使其指向想 要关联的对象，然后再使用 new F() 来构造一个新对象进行关联。</p><p>由于 Object.create(..c) 可以被模拟，因此这个函数被应用得非常广泛。标准 ES5 中内 置的 Object.create(..) 函数还提供了一系列附加功能,她可以为属性定义属于自己的属性描述符：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> anotherObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(anotherObject, &#123;  <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> &#125;,  <span class="hljs-attr">c</span>: &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">4</span> &#125;,&#125;);myObject.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// false</span>myObject.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">// true</span>myObject.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;c&quot;</span>); <span class="hljs-comment">// true</span>myObject.<span class="hljs-property">a</span>; <span class="hljs-comment">// 2</span>myObject.<span class="hljs-property">b</span>; <span class="hljs-comment">// 3</span>myObject.<span class="hljs-property">c</span>; <span class="hljs-comment">// 4</span></code></pre></div><p>当你给开发者设计软件时，假设要调用 myObject.cool()，如果 myObject 中不存在 cool() 时这条语句也可以正常工作的话，那你的 API 设计就会变得很“神奇”，对于未来维护你 软件的开发者来说这可能不太好理解。</p><p>但是你可以让你的 API 设计不那么“神奇”，同时仍然能发挥 [[Prototype]] 关联的威力：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> anotherObject = &#123;  <span class="hljs-attr">cool</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;cool!&quot;</span>);  &#125;,&#125;;<span class="hljs-keyword">var</span> myObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(anotherObject);myObject.<span class="hljs-property">doCool</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cool</span>(); <span class="hljs-comment">// 内部委托！</span>&#125;;myObject.<span class="hljs-title function_">doCool</span>(); <span class="hljs-comment">// &quot;cool!&quot;</span></code></pre></div><p>这里我们调用的 myObject.doCool() 是实际存在于 myObject 中的，这可以让我们的 API 设 计更加清晰（不那么“神奇”）。从内部来说，我们的实现遵循的是委托设计模式。通过 [[Prototype]] 委托到 anotherObject.cool()。</p><p>换句话说，内部委托比起直接委托可以让 API 接口设计更加清晰</p><h1 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h1>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>你不知道的JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>decimal.js</title>
    <link href="/2022/12/15/decimal-js/"/>
    <url>/2022/12/15/decimal-js/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>decimal.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>decimal.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web性能权威指南</title>
    <link href="/2022/12/09/web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2022/12/09/web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="web性能权威指南"><a href="#web性能权威指南" class="headerlink" title="web性能权威指南"></a>web性能权威指南</h1><h2 id="网络技术概览"><a href="#网络技术概览" class="headerlink" title="网络技术概览"></a>网络技术概览</h2><p>网络通信决定性影响的两个方面：延迟与带宽</p><p>延迟：分组从信息源发送到目的地所需要的时间</p><p>带宽：逻辑或者物理通信路径最大的吞吐量</p><p><strong>延迟的构成</strong></p><p>传播延迟：消息从发送端到接收端所需要的时间，是信号传播距离和速度的函数</p><p>传输延迟：把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数</p><p>处理延迟：处理分组首部，检查位错误及确定分组目标</p><p>排队延迟：到来的分组排队等待处理的时间</p><p>以上加起来的时间就是客户端到服务器的总延迟时间。传播时间取决于距离和信号通过的媒介。另外传播速度一般不超过光速，而传输时延是由传输链路上的速率来决定的，与客户端和服务器的距离无关。假设有一个 10 MB 的文件，分别通过两个链路传输，一个1Mbit/s，另一个 100 Mbit/s。在 1 Mbit/s 的链路上，需要花10 s，而在 100 Mbit/s 的链路上，只需 0.1 s。</p><p>接着，分组到达路由器。路由器必须检测分组的首部，以确定出站路由，并且还可能对数据进行检查，这些都要花时间。由于这些检查通常由硬件完成，因此相应的延迟一般非常短，但再短也还是存在。最后，如果分组到达的速度超过了路由器的处理能力，那么分组就要在入站缓冲区排队。数据在缓冲区排队等待的时间，当然就是排队延迟。</p><p>每个分组在通过网络时都会遇到这样或那样的延迟。发送端与接收端的距离越远，传播时间就越长。一路上经过的路由器越多，每个分组的处理和传输延迟就越多。最后，网络流量越拥挤，分组在入站缓冲区中被延迟的可能性就越大。</p><h2 id="浏览器网络概述"><a href="#浏览器网络概述" class="headerlink" title="浏览器网络概述"></a>浏览器网络概述</h2><p>现代浏览器完全包括数百个组件的操作系统，包括进程管理，安全沙箱，分层的优化缓存，javascript虚拟机，图形渲染，GPU管道，存储系统，传感器，音频与视频，网络机制，等等。</p><p>显然，浏览器乃至运行在其中的应用的性能，取决于若干组件：解析、布局、HTML 与 CSS 的样式计算、JavaScript 执行速度、渲染管道，当然还有网络相关各层协议的配合。其中每个组件的角色都很重要，而网络组件通常是加倍重要，因为浏览器慢就慢在等待网络资源上，等待造成后续环节被阻塞！</p><p>运行在浏览器中的 Web 应用并不负责管理个别网络套接字的生命周期，这是好事。通过把这个任务委托给浏览器，可以自动化很多重要的性能优化任务，包括套接字重用、请求优先级排定、晚绑定、协议协商、施加连接数限制，等等。事实上，浏览器是有意把请求管理生命周期与套接字管理分开的</p><p>套接字是以池的形式进行管理的（图 14-2），即按照来源，每个池都有自己的连接限制和安全约束。挂起的请求是排好队的、有优先次序的，然后再适时把它们绑定到池中个别的套接字上。除非服务器有意关闭连接，否则同一个套接字可以自动用于多个请求</p><p><strong>来源</strong></p><p>由应用协议、域名和端口三个要件构成，比如 (http, <a href="http://www.example.com/">www.example.com</a>, 80) 与(https, <a href="http://www.example.com/">www.example.com</a>, 443) 就是两个不同的来源。</p><p><strong>套接字池</strong></p><p>属于同一个来源的一组套接字。实践中，所有主流浏览器的最大池规模都是 6 个套接字。</p><p>自动化的套接字池管理会自动重用 TCP 连接，从而有效保障性能，除此之外，这种架构设计还提供了其他优化的机会：</p><ul><li>浏览器可以按照优先次序发送排队的请求；</li><li>浏览器可以重用套接字以最小化延迟并提升吞吐量；</li><li>浏览器可以预测请求提前打开套接字；</li><li>浏览器可以优化何时关闭空闲套接字；</li><li>浏览器可以优化分配给所有套接字的带宽</li></ul><h3 id="网络安全与沙箱"><a href="#网络安全与沙箱" class="headerlink" title="网络安全与沙箱"></a>网络安全与沙箱</h3><p>将个别套接字的管理任务委托给浏览器还有另一个重要的用意：可以让浏览器运用沙箱机制，对不受信任的应用代码采取一致的安全与策略限制。比如，浏览器不允许直接访问原始网络套接字 API，因为这样给恶意应用向任意主机发起任意请求（端口扫描、连接邮件服务器或发送未知消息）提供可乘之机</p><p><strong>连接限制</strong></p><p>浏览器管理所有打开的套接字池并强制施加连接数限制，保护客户端和服务器的资源不会被耗尽</p><p><strong>请求格式化与响应处理</strong></p><p>浏览器格式化所有外发请求以保证格式一致和符合协议的语义，从而保护服务器。类似地，响应解码也会自动完成，以保护用户。</p><p><strong>TLS协商</strong></p><p>浏览器执行 TLS 握手和必要的证书检查。任何证书有问题（比如服务器正在使用自已签发的证书），用户都会收到通知。</p><p><strong>同源策略</strong></p><p>浏览器会限制应用只能向哪个来</p><h3 id="资源与客户端状态缓存"><a href="#资源与客户端状态缓存" class="headerlink" title="资源与客户端状态缓存"></a>资源与客户端状态缓存</h3><p>最好最快的请求是没有请求。在分派请求之前，浏览器会自动检查其资源缓存，执行必要的验证，然后在满足限制条件的情况下返回资源的本地副本。类似地，如果某本地资源不在缓存中，那么浏览器就会发送网络请求，将响应自动填充到缓存中，以备后续访问使用。</p><p>• 浏览器针对每个资源自动执行缓存指令。</p><p>• 浏览器会尽可能恢复失效资源的有效性。</p><p>• 浏览器会自动管理缓存大小及资源回收。</p><p>高效、最优地管理缓存很困难。所幸，浏览器会替我们照管这一切，我们要做的，只是确保服务器返回适当的缓存指令Cache-Control、ETag 和 Last-Modified。最后，浏览器还有一个经常被人忽视的重要功能，那就是提供会话认证和 cookie 管理。浏览器为每个来源维护着独立的 cookie 容器，为读写新 cookie、会话和认证数据提供必要的应用及服务器 API，还会为我们自动追加和处理 HTTP 首部，让一切都自动化。</p><h3 id="应用API与协议"><a href="#应用API与协议" class="headerlink" title="应用API与协议"></a>应用API与协议</h3><table><thead><tr><th></th><th>XmlHttpRequest</th><th>Server-Sent Event</th><th>WebSocket</th></tr></thead><tbody><tr><td>请求流</td><td>否</td><td>否</td><td>是</td></tr><tr><td>响应流</td><td>受限</td><td>否</td><td>是</td></tr><tr><td>分帧机制</td><td>HTTP</td><td>事件流</td><td>二进制分帧</td></tr><tr><td>二进制数据传输</td><td>是</td><td>否(base64)</td><td>是</td></tr><tr><td>压缩</td><td>是</td><td>是</td><td>受限</td></tr><tr><td>应用传输协议</td><td>HTTP</td><td>TCP</td><td>WebSocket</td></tr><tr><td>网络传输协议</td><td>TCP</td><td>TCP</td><td>TCP</td></tr></tbody></table><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>这就意味着浏览器会自动帮</p><p>我们完成所有底层的连接管理、协议协商、HTTP 请求格式化，以及更多工作：XHR不仅实现了浏览器的异步通信，还极大的简化的这个过程，XH R是浏览器提供的应用API.这就意味着浏览器会自动帮我们完成所有底层的连接管理、协议协商、HTTP 请求格式化，以及更多工作：</p><p>浏览器管理着连接建立、套接字池和连接终止；</p><p>浏览器决定最佳的 HTTP（S）传输协议（HTTP 1.0、1.x 和 2.0）； </p><p>浏览器处理 HTTP 缓存、重定向和内容类型协商；</p><p>浏览器保障安全、验证和隐私；</p><p>等等</p><h4 id="跨源资源共享（CORS）"><a href="#跨源资源共享（CORS）" class="headerlink" title="跨源资源共享（CORS）"></a>跨源资源共享（CORS）</h4><p>XHR 是一个浏览器层面的 API，向我们隐藏了大量底层处理，包括缓存、重定向、内容协商、认证，等等。这样做有两个目的。第一，XHR 的 API 因此非常简单，开发人员可以专注业务逻辑。其次，浏览器可以采用沙箱机制，对应用代码强制施加一套安全限制。</p><p>XHR 接口强制要求每个请求都严格具备 HTTP 语义：应用提供数据和 URL，浏览器格式化请求并管理每个连接的完整生命周期。类似地，虽然 XHR API 允许应用添加自定义的 HTTP 首部（通过 setRequestHeader() 方法），同时也有一些首部是应用代码不能设定的：</p><p>• Accept-Charset、Accept-Encoding、Access-Control-*</p><p>• Host、Upgrade、Connection、Referer、Origin</p><p>• Cookie、Sec-<em>、Proxy-</em> 以及很多其他首部</p><p>浏览器会拒绝对不安全首部的重写，以此保证应用不能假扮用户代理、用户或请求来源。事实上，保护来源（Origin）首部特别重要，因为这是对所有 XHR 请求应用“同源策略”的关键。</p><p>CORS 请求也使用相同的 XHR API，区别仅在于请求资源用的 URL 与当前脚本并不同源。</p><p>针对 CORS 请求的选择同意认证机制由底层处理：请求发出后，浏览器自动追加受保护的 Origin HTTP 首部，包含着发出请求的来源。相应地，远程服务器可以检查 Origin首部，决定是否接受该请求，如果接受就返回 Access-Control-Allow-Origin 响应首部：</p><div class="code-wrapper"><pre><code class="hljs awk">=&gt; 请求GET <span class="hljs-regexp">/resource.js HTTP/</span><span class="hljs-number">1.1</span>Host: thirdparty.comOrigin: http:<span class="hljs-regexp">//</span>example.com ➊<span class="hljs-regexp">//</span>Origin 首部由浏览器自动设置...&lt;= 响应HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OKAccess-Control-Allow-Origin: http:<span class="hljs-regexp">//</span>example.com ➋<span class="hljs-regexp">//</span> 选择同意首部由服务器设置</code></pre></div><p>假如它选择不同意接受这个请求，那么只要不在响应中包含 <em>Access-Control-Allow-Origin</em> 首部即可。这样，客户端的浏览器就会自动将发出的请求作废。</p><p>如果第三方服务器不支持 CORS，那么客户端请求同样会作废，因为客户端会验证响应中是否包含选择同意的首部。作为一个特例，CORS 还允许服务器返回一个通配值 (Access-Control-Allow-Origin: *)，表示它允许来自任何源的请求。</p><p><strong>因为 CORS 还会提前采取一系列安全措施，以确保服务器支持 CORS：</strong> </p><p>• CORS 请求会省略 cookie 和 HTTP 认证等用户凭据；</p><p>• 客户端被限制只能发送“简单的跨源请求”，包括只能使用特定的方法（GET、POST 和 HEAD），以及只能访问可以通过 XHR 发送并读取的 HTTP 首部。</p><p>要启用 cookie 和 HTTP 认证，客户端必须在发送请求时通过 XHR 对象发送额外的属性（withCredentials），而服务器也必须以适当的首部（<em>Access-Control-Allow**Credentials</em>）响应，表示它允许应用发送用户的隐私数据。</p><div class="code-wrapper"><pre><code class="hljs excel">=&gt; 预备请求OPTIONS /resource.js HTTP/<span class="hljs-number">1.1</span> ➊//验证许可的预备 OPTIONS 请求Ho<span class="hljs-symbol">st:</span> thirdparty.comOrig<span class="hljs-symbol">in:</span> ht<span class="hljs-symbol">tp:</span>//example.comAccess-Control-Request-Meth<span class="hljs-symbol">od:</span> POSTAccess-Control-Request-Heade<span class="hljs-symbol">rs:</span> My-Custom-Header...&lt;= 预备响应HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK ➋//第三方源的成功预备响应Access-Control-Allow-Orig<span class="hljs-symbol">in:</span> ht<span class="hljs-symbol">tp:</span>//example.comAccess-Control-Allow-Metho<span class="hljs-symbol">ds:</span> GET, POST, PUTAccess-Control-Allow-Heade<span class="hljs-symbol">rs:</span> My-Custom-Header...（正式的 HTTP 请求）➌//实际的 CORS 请求</code></pre></div><p>W3C 官方的 CORS 规范规定了何时何地必须使用预备请求：“简单的”请求可以跳过它，但很多条件下这个请求都是必需的，因此也会为验证许可而增加仅有一次往返的网络延迟。只要完成预备请求，客户端就会将结果缓存起来，后续请求就不必重复验证了</p><p><strong><u>CORS 得到了所有现代浏览器支持，参见：caniuse.com/cors。要全面了解CORS 的各种策略及实现，请参考 W3C 官方标准（<a href="http://www.w3.org/TR/cors/%EF%BC%89%E3%80%82">http://www.w3.org/TR/cors/）。</a></u></strong></p><h4 id="通过XHR下载数据"><a href="#通过XHR下载数据" class="headerlink" title="通过XHR下载数据"></a>通过XHR下载数据</h4><p>XHR 既可以传输文本数据，也可以传输二进制数据。事实上，浏览器可以自动为各种原生数据类型提供编码和解码服务，因此应用在直接将这些数据传给 XHR 时就已经编码 / 解码好了，反之亦然。浏览器可以自动解码的数据类型如下。</p><p>ArrayBuffer</p><p>固定长度的二进制数据缓冲区。</p><p>Blob</p><p>二进制大对象或不可变数据。</p><p>Document</p><p>解析后得到的 HTML 或 XML 文档。</p><p>JSON</p><p>表示简单数据结构的 JavaScript 对象。</p><p>Text</p><p>简单的文本字符串。</p><p>浏览器通过http的content-type信息，来推断出类型， 比 如 把application/json 响应解析为 JSON 对象），应用也可以在发起 XHR 请求时显式重写数据类型：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/images/photo.webp&#x27;</span>);xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;blob&#x27;</span>; ➊<span class="hljs-comment">//将返回数据类型设置为 Blob</span>xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123; <span class="hljs-keyword">var</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>); img.<span class="hljs-property">src</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>); ➋<span class="hljs-comment">//基于返回的对象创建唯一的对象 URI 并设置为图片的源</span> img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">src</span>); ➌<span class="hljs-comment">//图片加载完毕后立即释放对象</span> &#125; <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(img); &#125;&#125;;xhr.<span class="hljs-title function_">send</span>()</code></pre></div><p>注意，这里我们在以原生格式传输一张图片，没有使用 base64 编码，也没有使用数据 URI，而是在页面中添加了一个 <img> 元素。这样在 JavaScript 中处理接收到的二进制数据不会产生任何网络传输开销和编码开销！ XHR API 让我们得以通过脚本高效、动态地开发应用，无论操作什么数据类型都没问题，全部用 JavaScript搞定！</p><p><em><strong>这里的二进制大对象接口（Blob）属于 HTML5 的 File API，就像一个不透明的引用，可以指向任何数据块（二进制或文本）。这个对象本身没有太多功能，只能查询其大小、MIME 类型，或将它切分成更小的块。这个对象存在的真正目的，是作为各种 JavaScript API 之间的一种高效的互操作机制。</strong></em></p><h4 id="通过XHR上传数据"><a href="#通过XHR上传数据" class="headerlink" title="通过XHR上传数据"></a>通过XHR上传数据</h4><p>通过 XHR 上传任何类型的数据都很简单，而且高效。事实上，上传不同类型数据的代码都一样，只不过最后在调用 XHR 请求对象的 send() 方法时，要传入相应的数据对象。剩下的事就都由浏览器处理了：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-string">&#x27;/upload&#x27;</span>);xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;text string&quot;</span>); ➊<span class="hljs-comment">//把简单的文本字符串上传到服务器</span><span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(); ➋<span class="hljs-comment">//通过 FormData API 动态创建表单数据</span>formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-number">123456</span>);formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;topic&#x27;</span>, <span class="hljs-string">&#x27;performance&#x27;</span>);<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>);xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;xhr.<span class="hljs-title function_">send</span>(formData); ➌<span class="hljs-comment">//向服务器上传 multipart/form-data 对象</span><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>);xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;<span class="hljs-keyword">var</span> uInt8Array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); ➍<span class="hljs-comment">//创建无符号、8 字节整型的有类型数组（ArrayBuffer）</span>xhr.<span class="hljs-title function_">send</span>(uInt8Array.<span class="hljs-property">buffer</span>); ➎<span class="hljs-comment">//向服务器上传字节块</span></code></pre></div><p>XHR 对象的 send() 方法可以接受 DOMString、Document、FormData、Blob、File 及ArrayBuffer 对象，并自动完成相应的编码，设置适当的 HTTP 内容类型 (content-type)，然后再分派请求。需要发送二进制 Blob 或上传用户提交的文件？简单，取得对该对象的引用，传给 XHR</p><p>如果上传文件过大，还可以将文件分块上传</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> blob = ...; ➊<span class="hljs-comment">//任意数据（二进制或文本）的二进制对象</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BYTES_PER_CHUNK</span> = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; ➋<span class="hljs-comment">//将块大小设置为 1 MB</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SIZE</span> = blob.<span class="hljs-property">size</span>;<span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> end = <span class="hljs-variable constant_">BYTES_PER_CHUNK</span>;<span class="hljs-keyword">while</span>(start &lt; <span class="hljs-variable constant_">SIZE</span>) &#123; ➌<span class="hljs-comment">//以 1 MB 为步长迭代数据块</span> <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>); xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;; xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Range&#x27;</span>, start+<span class="hljs-string">&#x27;-&#x27;</span>+end+<span class="hljs-string">&#x27;/&#x27;</span>+<span class="hljs-variable constant_">SIZE</span>); ➍<span class="hljs-comment">//告诉服务器上传的数据范围（开始位置 - 结束位置 / 总大小）</span> xhr.<span class="hljs-title function_">send</span>(blob.<span class="hljs-title function_">slice</span>(start, end)); ➎<span class="hljs-comment">//通过 XHR 上传 1 MB 大小的数据片段</span> start = end; end = start + <span class="hljs-variable constant_">BYTES_PER_CHUNK</span>;&#125;</code></pre></div><p>XHR 不支持请求流，这意味着在调用 send() 时必须提供完整的文件。不过，前面的例子示范了一个简单的解决方案：切分文件，然后通过多个 XHR 请求分段上传。这种实现方案当然不能替代真正的请求流 API，但对某些应用来说却是一个可行的方案。</p><p><em><strong>切分大文件上传是个不错的技巧，适合连接不稳定或经常中断的场景。此时，假如某个块由于掉线而上传失败，应用可以随后只重新上传该块，而不必重新上传整个大文件。</strong></em></p><h4 id="监控下载和上传进度"><a href="#监控下载和上传进度" class="headerlink" title="监控下载和上传进度"></a>监控下载和上传进度</h4><p>因为网络连接可能中断，而延时或者带宽也是高度不稳定。XHR提供了监听进度的事件API</p><table><thead><tr><th>事件类型</th><th>说明</th><th>触发次数</th></tr></thead><tbody><tr><td>loadstart</td><td>传输已开始</td><td>一次</td></tr><tr><td>progress</td><td>正在传输</td><td>零或一次</td></tr><tr><td>error</td><td>传输出错</td><td>零或一次</td></tr><tr><td>abort</td><td>传输中止</td><td>零或一次</td></tr><tr><td>load</td><td>传输成功</td><td>零或一次</td></tr><tr><td>loadend</td><td>传输完成</td><td>一次·</td></tr></tbody></table><p>每个 XHR 请求开始时都会触发 loadstart 事件，而结束时都会触发 loadend 事件。在这两事件之间，还可能触发一或多个其他事件，表示传输状态。因此，要监控进度，可以在 XHR 对象上注册一系列 JavaScript 事件监听器：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;/resource&#x27;</span>);xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">5000</span>; <span class="hljs-comment">//➊设置请求的超时时间为 5000 ms（默认无超时限制）</span>xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;); <span class="hljs-comment">//➋为请求成功注册回调</span>xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;); <span class="hljs-comment">//➌为请求失败注册回调</span><span class="hljs-keyword">var</span> onProgressHandler = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123; <span class="hljs-keyword">if</span>(event.<span class="hljs-property">lengthComputable</span>) &#123; <span class="hljs-keyword">var</span> progress = (event.<span class="hljs-property">loaded</span> / event.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>; <span class="hljs-comment">//➍计算传输进度</span> ... &#125;&#125;xhr.<span class="hljs-property">upload</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;progress&#x27;</span>, onProgressHandler);<span class="hljs-comment">// ➎为上传进度事件注册回调</span>xhr.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;progress&#x27;</span>, onProgressHandler);<span class="hljs-comment">// ➏为下载进度事件注册回调</span>xhr.<span class="hljs-title function_">send</span>();</code></pre></div><p>无 论 load 和 error 中 的 哪 一 个 被 触 发 了， 都 代 表 XHR 传 输 的 最 终 状 态， 而progress 事件则可能触发任意多次，这就为监控传输状态提供了便利：我们可以比较 loaded 与 total 属性，估算传输完成的数据比例。</p><p><strong><u><em>要估算传输完成的数据量，服务器必须在其响应中提供内容长度（ContentLength）首部。而对于分块数据，由于响应的总长度未知，因此就无法估计进度了。</em></u></strong></p><p><strong><u><em>另外，XHR 请求默认没有超时限制，这意味着一个请求的“进度”可以无限长。作为最佳实践，一定要为应用设置合理的超时时间，并适当处理错误。</u></em></strong></p><h4 id="通过XHR实现流式数据传输"><a href="#通过XHR实现流式数据传输" class="headerlink" title="通过XHR实现流式数据传输"></a>通过XHR实现流式数据传输</h4><p>XHR很难实现流传输。</p><p><strong>上传时，send 方法只接受完整的载荷</strong></p><p><strong>response、responseText 和 responseXML 属性也不是为流设计的</strong></p><p>虽然没有官方的api为实现流的传输的，但是还有有人提供了一些方法来实现：</p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">Web</span> 应用必须有能力获得并操作各种形式的数据，包括随着时间推移逐渐可用的一系列数据。本规范定义了流的基本表示法、流触发的错误，以及通过编程方式读取和创建流的方式。——<span class="hljs-variable">W3C</span> <span class="hljs-built_in">Streams</span> <span class="hljs-variable">API</span></code></pre></div><p>但是这种xhr+streams的方式还没有浏览器实现，但是虽然通过上传无法实现这种方式，但是下载还是可以通过流传输的</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/stream&#x27;</span>);xhr.<span class="hljs-property">seenBytes</span> = <span class="hljs-number">0</span>;xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ➊<span class="hljs-comment">//预订状态和进度通知</span> <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> &gt; <span class="hljs-number">2</span>) &#123; <span class="hljs-keyword">var</span> newData = xhr.<span class="hljs-property">responseText</span>.<span class="hljs-title function_">substr</span>(xhr.<span class="hljs-property">seenBytes</span>); ➋<span class="hljs-comment">//从部分响应中提取新数据</span> <span class="hljs-comment">// 处理 newData</span> xhr.<span class="hljs-property">seenBytes</span> = xhr.<span class="hljs-property">responseText</span>.<span class="hljs-property">length</span>; ➌<span class="hljs-comment">//更新处理的字节偏移量</span> &#125;&#125;;xhr.<span class="hljs-title function_">send</span>();</code></pre></div><p>这个例子在多数现代浏览器中都可以运行，但性能并不理想。另外，还有很多关于实现的问题和注意事项。</p><p>我们是手工跟踪看到的字节的偏移量，然后再手工切分数据：responseText 则缓冲了完整的响应！对于少量数据传输而言，这不是问题。但如果下载的数据很大，特别是在内存十分有限的设备比如手机上，这就是问题了。释放缓冲数据的唯一方式就是完成当前请求，并且打开一个新请求。部分响应只能通过读取 responseText 属性获取，因此也就只能局限于文本数据了。没有办法部分读取二进制数据的响应。读取完部分数据后，我们必须自己标识数据的界限：应用代码必须定义自己的数据格式，然后再缓冲并解析数据流，提取出相应的信息。浏览器缓冲收到数据的方式也不相同：有的会立即释放，而有的只缓冲小响应，对较大的响应块则立即释放。浏览器允许递增读取的数据类型也不一样：有的允许 text/html，而有的只允许application/x-javascript。</p><p>虽然 XHR 满足不了我们的要求，我们还有其他办法，而且是专门为流式数据处理设计的：Server-Sent Events 提供方便的流 API，用于从服务器向客户端发送文本数据，而 WebSocket 则提供了高效、双向的流机制，而且同时支持二进制和文本数据。</p><h4 id="实时通知与交付"><a href="#实时通知与交付" class="headerlink" title="实时通知与交付"></a>实时通知与交付</h4><p>XHR 提供了一种简单有效的客户端与服务器同步的方式：必要时，客户端可以向服务器发送一个 XHR 请求，以更新服务器上的相应数据。然而，实现同样但相反的操作却要困难一些。如果服务器的数据更新了，那怎么通知客户端呢？主流浏览器对 XHR 流的支持有限，那我们就只能使用 XHR 轮询了</p><h5 id="通过XHR实现轮询"><a href="#通过XHR实现轮询" class="headerlink" title="通过XHR实现轮询"></a>通过XHR实现轮询</h5><p>从服务器取得更新的一个最简单的办法，就是客户端在后台定时发起 XHR 请求，也就是轮询（polling）。如果服务器有新数据，返回新数据，否则返回空响应。</p><p>轮询实现起来简单，但也经常效率很低。其中关键在于选择轮询间隔：长轮询间隔意味着延迟交付，而短轮询间隔会导致客户端与服务器间不必要的流量和协议开销</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkUpdates</span>(<span class="hljs-params">url</span>) &#123; <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, url); xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;; ➊ xhr.<span class="hljs-title function_">send</span>();&#125;<span class="hljs-built_in">setInterval</span>(<span class="hljs-string">&quot;checkUpdates(&#x27;/updates&#x27;), 60000&quot;</span>); ➋</code></pre></div><h5 id="通过XHR实现长轮询"><a href="#通过XHR实现长轮询" class="headerlink" title="通过XHR实现长轮询"></a>通过XHR实现长轮询</h5><p>定时轮询的一个大问题就是很可能造成大量没必要的空检查。我们需要对此进行改进，在没有更新的时候不再返回空响应，而是把连接保持到有更新的时候。</p><p>通过将连接一直保持打开到有更新（长轮询），就可以把更新立即从服务器发送给客户端。这样，长轮询就解决了消息交付延迟的问题，同时也消灭了空检查，减少了XHR 请求次数和轮询的整体开销。在交付更新后，长轮询请求完成，然后客户端再发送下一次长轮询请求，等待下一次更新：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkUpdates</span>(<span class="hljs-params">url</span>) &#123; <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, url); xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ➊<span class="hljs-comment">//处理更新并打开新的长轮询 XHR</span> ... <span class="hljs-title function_">checkUpdates</span>(<span class="hljs-string">&#x27;/updates&#x27;</span>); ➋<span class="hljs-comment">//发送长轮询请求并等待下次更新（如此不停循环）</span> &#125;; xhr.<span class="hljs-title function_">send</span>();&#125;<span class="hljs-title function_">checkUpdates</span>(<span class="hljs-string">&#x27;/updates&#x27;</span>); ➌<span class="hljs-comment">//发送第一次长轮询 XHR 请求</span></code></pre></div><p>这样的话，是不是可以说长轮询永远都比定时轮询好呢？除非更新到达频率已知且固定，否则长轮询的延迟总是最短的。如果延迟是一个重要考虑因素，那么长轮询就是最好方案</p><p>从另一方面看，还需要更仔细地分析一下开销。首先，每次更新都会伴有相同的HTTP 开销，即每次更新都需要一次独立的 HTTP 请求。如果更新频率很高，那么长轮询又会导致比定时轮询更多的 XHR 请求！</p><p>长轮询通过最小化延迟可以动态适应更新频率，这种行为可能是也可能不是我们所期望的。如果应用可以容许一定时间的延迟，那么定时轮询可能更有效。因为在更新频率很高的情况下，定时轮询就是一个简单的“更新累积”机制，不仅能减少请求次数，还能减少对手机电量的消耗。</p><h3 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h3><p>Server-Sent Events（SSE）让服务器可以向客户端流式发送文本消息，比如服务器上生成的实时通知或更新。为达到这个目标，SSE 设计了两个组件：浏览器中的EventSource 和新的“事件流”数据格式。其中，EventSource 可以让客户端以 DOM事件的形式接收到服务器推送的通知，而新数据格式则用于交付每一次更新</p><p>EventSource API 和定义完善的事件流数据格式，使得 SSE 成为了在浏览器中处理实时数据的高效而不可或缺的工具：</p><p>通过一个长连接低延迟交付；</p><p>高效的浏览器消息解析，不会出现无限缓冲；</p><p>自动跟踪最后看到的消息及自动重新连接；</p><p>消息通知在客户端以 DOM 事件形式呈现。</p><p>实际上，SSE 提供的是一个高效、跨浏览器的 XHR 流实现，消息交付只使用一个长 HTTP 连接。然而，与我们自己实现 XHR 流不同，浏览器会帮我们管理连接、解析消息，从而让我们只关注业务逻辑。</p><h4 id="EventSource-API"><a href="#EventSource-API" class="headerlink" title="EventSource API"></a>EventSource API</h4><p>EventSource 接口通过一个简单的浏览器 API 隐藏了所有的底层细节，包括建立连接和解析消息。要使用它，只需指定 SSE 事件流资源的 URL，并在该对象上注册相应 JavaScript 事件监听器即可：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&quot;/path/to/stream-url&quot;</span>); <span class="hljs-comment">//➊打开到流终点的 SSE 连接</span>source.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; ... &#125;; <span class="hljs-comment">//➋可选的回调，建立连接时调用</span>source.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; ... &#125;;<span class="hljs-comment">//➌可选的回调，连接失败时调用</span>source.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123; <span class="hljs-comment">//➍监听 &quot;foo&quot; 事件，调用自定义代码</span> <span class="hljs-title function_">processFoo</span>(event.<span class="hljs-property">data</span>);&#125;);source.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123; <span class="hljs-comment">//➎监听所有事件，不明确指定事件类型</span> <span class="hljs-title function_">log_message</span>(event.<span class="hljs-property">id</span>, event.<span class="hljs-property">data</span>); <span class="hljs-keyword">if</span> (event.<span class="hljs-property">id</span>== <span class="hljs-string">&quot;CLOSE&quot;</span>) &#123; source.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">//➏如果服务器发送 &quot;CLOSE&quot; 消息 ID，关闭 SSE 连接</span> &#125;&#125;</code></pre></div><p><em><strong>EventSource 可以像常规 XHR 一样利用 CORS 许可及选择同意机制，实现客户端到远程服务器的流式事件数据传输。</strong></em></p><p><em><strong>SSE 实现了节省内存的 XHR 流。与原始的 XHR 流在连接关闭前会缓冲接收到的所有响应不同，SSE 连接会丢弃已经处理过的消息，而不会在内存中累积</strong></em></p><p>EventSource 接口还能自动重新连接并跟踪最近接收的消息：如果连接断开了，EventSource 会自动重新连接到服务器，还可以向服务器发送上一次接收到的消息 ID，以便服务器重传丢失的消息并恢复流。</p><p>针对不支持SSE的浏览器我们可以这么处理：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">EventSource</span>) &#123; <span class="hljs-comment">// 加载 JavaScript 腻子脚本</span>&#125;<span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventSource</span>(<span class="hljs-string">&quot;/event-stream-endpoint&quot;</span>);</code></pre></div><p>使用腻子脚本的好处，仍然是让我们只关注应用逻辑，而不是因浏览器支持情况闹心。</p><p>不支持的可以使用XHR的轮询。腻子脚本只是提供了一致的 API，底层的 XHR 传输机制依旧不那么高效：</p><p>XHR 轮询会导致消息延迟和很高的请求开销；</p><p>XHR 长轮询能最小化延迟，但开销还是很高；</p><p>XHR 对流的支持有限，且在内存中缓冲所有数据</p><h4 id="Event-Stream协议"><a href="#Event-Stream协议" class="headerlink" title="Event Stream协议"></a>Event Stream协议</h4><p>SSE 事件流是以流式 HTTP 响应形式交付的：客户端发起常规 HTTP 请求，服务器以自定义的“text/event-stream”内容类型响应，然后交付 UTF-8 编码的事件数据。</p><div class="code-wrapper"><pre><code class="hljs js">=&gt; 请求<span class="hljs-variable constant_">GET</span> /stream <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-comment">//➊ 客户端通过 EventSource 接口发起连接</span><span class="hljs-title class_">Host</span>: example.<span class="hljs-property">com</span><span class="hljs-title class_">Accept</span>: text/event-stream&lt;= 响应<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> <span class="hljs-variable constant_">OK</span> <span class="hljs-comment">//➋ 服务器以 &quot;text/event-stream&quot; 内容类型响应</span><span class="hljs-title class_">Connection</span>: keep-alive<span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/event-stream<span class="hljs-title class_">Transfer</span>-<span class="hljs-title class_">Encoding</span>: chunked<span class="hljs-attr">retry</span>: <span class="hljs-number">15000</span> <span class="hljs-comment">//➌ 服务器设置连接中断后重新连接的间隔时间（15 s）</span><span class="hljs-attr">data</span>: <span class="hljs-title class_">First</span> message is a simple string. <span class="hljs-comment">//➍ 不带消息类型的简单文本事件</span><span class="hljs-attr">data</span>: &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;JSON payload&quot;</span>&#125; <span class="hljs-comment">//➎ 不带消息类型的 JSON 数据载荷</span><span class="hljs-attr">event</span>: foo <span class="hljs-comment">//➏ 类型为 &quot;foo&quot; 的简单文本事件</span><span class="hljs-attr">data</span>: <span class="hljs-title class_">Message</span> <span class="hljs-keyword">of</span> type <span class="hljs-string">&quot;foo&quot;</span><span class="hljs-attr">id</span>: <span class="hljs-number">42</span> <span class="hljs-comment">// ➐带消息 ID 和类型的多行事件</span><span class="hljs-attr">event</span>: bar<span class="hljs-attr">data</span>: <span class="hljs-title class_">Multi</span>-line message <span class="hljs-keyword">of</span><span class="hljs-attr">data</span>: type <span class="hljs-string">&quot;bar&quot;</span> and id <span class="hljs-string">&quot;42&quot;</span><span class="hljs-attr">id</span>: <span class="hljs-number">43</span> <span class="hljs-comment">//➑带可选 ID 的简单文本事件</span><span class="hljs-attr">data</span>: <span class="hljs-title class_">Last</span> message, id <span class="hljs-string">&quot;43&quot;</span></code></pre></div><p>以上事件流协议很好理解，也很好实现：</p><p>• 事件载荷就是一或多个相邻 data 字段的值；</p><p>• 事件可以带 ID 和 event 表示事件类型；</p><p>• 事件边界用换行符标识。</p><p>在接收端，EventSource 接口通过检查换行分隔符来解析到来的数据流，从 data 字段中提取有效载荷，检查可选的 ID 和类型，最后再分派一个 DOM 事件告知应用。如果存在某个类型，那么就会触发自定义的 DOM 事件处理程序；否则，就会调用通用的 onmessage 回调</p><h5 id="SSE-中的-UTF-8-编码与二进制传输"><a href="#SSE-中的-UTF-8-编码与二进制传输" class="headerlink" title="SSE 中的 UTF-8 编码与二进制传输"></a>SSE 中的 UTF-8 编码与二进制传输</h5><p>EventSource 不会对实际载荷进行任何额外处理：从一或多个 data 字段中提取出来的消息，会被拼接起来直接交给应用。因此，服务器可以推送任何文本格式（例如，简单字符串、JSON，等等），应用必须自己解码。话虽如此，但所有事件源数据都是 UTF-8 编码的：SSE 不是为传输二进制载荷而设计的！如果有必要，可以把二进制对象编码为 base64 形式，然后再使用 SSE。但这样会导致很高（33%）的字节开销，担心 UTF-8 编码也会造成高开销？ SSE 连接本质上是 HTTP 流式响应，因此响应是可以压缩的（如 gzip 压缩），就跟压缩其他 HTTP 响应一样，而且是动态压缩！虽然 SSE 不是为传输二进制数据而设计的，但它却是一个高效的机制——只要让你的服务器对 SSE 流应用 gzip 压缩。不支持二进制传输是有意为之的。SSE 的设计目标是简单、高效，作为一种服务器向客户端传送文本数据的机制。如果你想传输二进制数据，WebSocket 才是更合适的选择</p><p>最后，除了自动解析事件数据，SSE 还内置支持断线重连，以及恢复客户端因断线而丢失的消息。默认情况下，如果连接中断，浏览器会自动重新连接。SSE 规范建议的间隔时间是 2~3 s，这也是大多数浏览器采用的默认值。不过，服务器也可以设置一个自定义的间隔时间，只要在推送任何消息时向客户端发送一个 retry 命令即可。</p><p>类似地，服务器还可以给每条消息关联任意 ID 字符串。浏览器会自动记录最后一次收到的消息 ID，并在发送重连请求时自动在 HTTP 首部追加“Last-Event-ID”值。下面看一个例子：</p><div class="code-wrapper"><pre><code class="hljs js">（既有 <span class="hljs-variable constant_">SSE</span> 连接）<span class="hljs-attr">retry</span>: <span class="hljs-number">4500</span> <span class="hljs-comment">//➊ 服务器将客户端的重连间隔设置为 4.5 s</span><span class="hljs-attr">id</span>: <span class="hljs-number">43</span> <span class="hljs-comment">//➋ 简单文本事件，ID:43</span><span class="hljs-attr">data</span>: <span class="hljs-title class_">Lorem</span> ipsum（连接断开）（<span class="hljs-number">4500</span> ms 后）=&gt; 请求<span class="hljs-variable constant_">GET</span> /stream <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-comment">//➌ 带最后一次事件 ID 的客户端重连请求</span><span class="hljs-title class_">Host</span>: example.<span class="hljs-property">com</span><span class="hljs-title class_">Accept</span>: text/event-stream<span class="hljs-title class_">Last</span>-<span class="hljs-title class_">Event</span>-<span class="hljs-attr">ID</span>: <span class="hljs-number">43</span>&lt;= 响应<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> <span class="hljs-variable constant_">OK</span> <span class="hljs-comment">//➍ 服务器以 &#x27;text/event-stream&#x27; 内容类型响应</span><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/event-stream<span class="hljs-title class_">Connection</span>: keep-alive<span class="hljs-title class_">Transfer</span>-<span class="hljs-title class_">Encoding</span>: chunked<span class="hljs-attr">id</span>: <span class="hljs-number">44</span> <span class="hljs-comment">//➎ 简单文本事件，ID:44</span><span class="hljs-attr">data</span>: dolor sit amet</code></pre></div><p>客户端应用不必为重新连接和记录上一次事件 ID 编写任何代码。这些都由浏览器自动完成，然后就是服务器负责恢复了。值得注意的是，根据应用的要求和数据流，服务器可以采取不同的实现策略。</p><p>如果丢失消息可以接受，就不需要事件 ID 或特殊逻辑，只要让客户端重连并恢复数据流即可。如果必须恢复消息，那服务器就需要指定相关事件的 ID，以便客户端在重连时报告最后接收到的 ID。同样，服务器也需要实现某种形式的本地缓存，以便恢复并向客户端重传错过的消息。</p><p>当然，像要保留多少条消息这种细节一定取决于具体的应用。另外，要知道 ID 是可选的事件流字段。而服务器也可以在交付的事件流中对特定消息设置检查点或者里程碑标记。一句话，根据你的需求，实现服务器逻辑。</p><h4 id="SSE使用场景及性能"><a href="#SSE使用场景及性能" class="headerlink" title="SSE使用场景及性能"></a>SSE使用场景及性能</h4><p>SSE 是服务器向客户端发送实时文本消息的高性能机制：服务器可以在消息刚刚生成就将其推送到客户端（低延迟），使用长连接的事件流协议，而且可以 gzip 压缩（低开销），浏览器负责解析消息，也没有无限缓冲。再加上超级简单的 EventSource API 能自动重新连接和把消息通知作为 DOM 事件，使得 SSE 成为处理实时数据不可或缺的得力工具！</p><p>SSE 主要有两个局限。一，只能从服务器向客户端发送数据，不能满足需要请求流的场景（比如向服务器流式上传大文件）；二，事件流协议设计为只能传输 UTF-8数据，即使可以传输二进制流，效率也不高。话虽如此，UTF-8 的限制往往可以在应用层克服：SSE 可以通知应用说服务器上有一个新的二进制文件可以下载了，应用只要再分派一个 XHR 请求去下载即可。虽然这样多了一次往返延迟，但也能利用上 XHR 提供的诸多便利：响应缓存、传输编码（压缩），等等。如果文件是流式下载的，那它就无法被浏览器缓存。</p><p>实时推送就像轮询一样，可能会极大影响电池的待机时间。首先，可以考虑批量处理消息，尽量少唤醒无线电模块。其次，避免不必要的长连接，SSE 连接在无线电空闲时不会断开。更多信息，请参考 “<strong>消除周期性及无效的数据传输</strong>”。</p><div class="code-wrapper"><pre><code class="hljs">                                         通过 TLS 实现 SSE 流SSE 通过常规 HTTP 连接实现了简单便捷的实时传输机制，服务器端容易部署，客户端也容易打补丁。可是，现有网络中间设备，比如代理服务器和防火墙，都不支持 SSE，而这有可能带来问题：中间设备可能会缓冲事件流数据，导致额外延迟，甚至彻底毁掉 SSE 连接。如果你碰到了这样或类似的问题，那么可以考虑通过 TLS 发送 SSE 事件流，具体请参考 4.1 节中的“Web 代理、中间设备、TLS 与新协议”。</code></pre></div><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 可以实现客户端与服务器间双向、基于消息的文本或二进制数据传输。它是浏览器中最靠近套接字的 API。但 WebSocket 连接远远不是一个网络套接字，因为浏览器在这个简单的 API 之后隐藏了所有的复杂性，而且还提供了更多服务：</p><p>连接协商和同源策略；</p><p>与既有 HTTP 基础设施的互操作；</p><p>基于消息的通信和高效消息分帧；</p><p>子协议协商及可扩展能力。</p><p>WebSocket 是浏览器中最通用最灵活的一个传输机制，其极简的 API 可以让我们在客户端和服务器之间以数据流的形式实现各种应用数据交换（包括 JSON 及自定义的二进制消息格式），而且两端都可以随时向另一端发送数据。</p><p>不过，自定义数据交换协议的问题通常也在于自定义。因为应用必须考虑状态管理、压缩、缓存及其他原来由浏览器提供的服务。设计限制和性能权衡始终会有，利用WebSocket 也不例外。简单来说，WebSocket 并不能取代 HTTP、XHR 或 SSE，而为了追求最佳性能，关键还是要利用这些机制的长处。</p><p>WebSocket 由多个标准构成：WebSocket API 是 W3C 定义的，而 WebSocket协议（RFC 6455）及其扩展则由 HyBi Working Group（IETF）定义</p><h4 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://example.com/socket&#x27;</span>); <span class="hljs-comment">//➊ 打开新的安全 WebSocket 连接（wss）</span>ws.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123; ... &#125; <span class="hljs-comment">//➋ 可选的回调，在连接出错时调用</span>ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; ... &#125; <span class="hljs-comment">//➌ 可选的回调，在连接终止时调用</span>ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//➍ 可选的回调，在 WebSocket 连接建立时调用</span> ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Connection established. Hello server!&quot;</span>); <span class="hljs-comment">//➎ 客户端先向服务器发送一条消息</span>&#125;ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123; <span class="hljs-comment">//➏回调函数，服务器每发回一条消息就调用一次</span> <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Blob</span>) &#123; <span class="hljs-comment">//➐ 根据接收到的消息，决定调用二进制还是文本处理逻辑</span> <span class="hljs-title function_">processBlob</span>(msg.<span class="hljs-property">data</span>); &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-title function_">processText</span>(msg.<span class="hljs-property">data</span>); &#125;&#125;</code></pre></div><h5 id="WS与WSS"><a href="#WS与WSS" class="headerlink" title="WS与WSS"></a>WS与WSS</h5><p>WebSocket 资源 URL 采用了自定义模式：ws 表示纯文本通信（如 ws://example.com/socket），wss 表示使用加密信道通信（TCP+TLS）。WebSocket 的主要目的，是在浏览器中的应用与服务器之间提供优化的、双向通信机制。可是，WebSocket 的连接协议也可以用于浏览器之外的场景，景，可以通过非 HTTP协商机制交换数据。考虑到这一点，HyBi Working Group 就选择采用了自定义的</p><p>URL 模式。</p><p><strong>使用自定义的 URL 模式虽然让非 HTTP 协商成为可能，但实践中还没有既定标准可以作为建立 WebSocket 会话的替代握手机制。</strong></p><h5 id="接收文本和二进制数据"><a href="#接收文本和二进制数据" class="headerlink" title="接收文本和二进制数据"></a>接收文本和二进制数据</h5><p>WebSocket 通信只涉及消息，应用代码无需担心缓冲、解析、重建接收到的数据。比如，服务器发来了一个 1 MB 的净荷，应用的 onmessage 回调只会在客户端接收到全部数据时才会被调用</p><p>此外，WebSocket 协议不作格式假设，对应用的净荷也没有限制：文本或者二进制数据都没问题。从内部看，协议只关注消息的两个信息：净荷长度和类型（前者是一个可变长度字段），据以区别 UTF-8 数据和二进制数据。</p><p>浏览器接收到新消息后，如果是文本数据，会自动将其转换成 DOMString 对象，如果是二进制数据或 Blob 对象，会直接将其转交给应用。唯一可以（作为性能暗示和优化措施）多余设置的，就是告诉浏览器把接收到的二进制数据转换成 ArrayBuffer而非 Blob：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://example.com/socket&#x27;</span>);ws.<span class="hljs-property">binaryType</span> = <span class="hljs-string">&quot;arraybuffer&quot;</span>; <span class="hljs-comment">//➊ 如果接收到二进制数据，将其强制转换成 ArrayBuffer</span>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123; <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ArrayBuffer</span>) &#123; <span class="hljs-title function_">processArrayBuffer</span>(msg.<span class="hljs-property">data</span>); &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-title function_">processText</span>(msg.<span class="hljs-property">data</span>); &#125;&#125;</code></pre></div><hr><p>用户代理可以将这个选项看作一个暗示，以决定如何处理接收到的二进制数</p><p>据：如果这里设置为“blob”，那就可以放心地将其转存到磁盘上；而如果</p><p>设置为“arraybuffer”，那很可能在内存里处理它更有效。自然地，我们鼓励</p><p>用户代理使用更细微的线索，以决定是否将到来的数据放到内存里……</p><p>——The WebSocket API </p><p>W3C Candidate Recommendation </p><p>Blob 对象一般代表一个不可变的文件对象或原始数据。如果你不需要修改它或者不需要把它切分成更小的块，那这种格式是理想的（比如，可以把一个完整的 Blob 对象传给 img 标签，参见 15.3 节“通过 XHR 下载数据”）。而如果你还需要再处理接收到的二进制数据，那么选择 ArrayBuffer 应该更合适。</p><div class="code-wrapper"><pre><code class="hljs js">使用 <span class="hljs-title class_">JavaScript</span> 解码二进制数据<span class="hljs-title class_">ArrayBuffer</span> 表示一个普通的、固定长度的二进制数据缓冲。不过，可以用<span class="hljs-title class_">ArrayBuffer</span> 创建一或多个 <span class="hljs-title class_">ArrayBufferView</span> 对象，每一个都可以通过特定的格式来展示缓冲中的内容。比如，假设我们需要处理下面类似 C 的二进制数据结构：struct someStruct &#123; char username[<span class="hljs-number">16</span>]; unsigned short id; float scores[<span class="hljs-number">32</span>];&#125;;在取得这个类型的 <span class="hljs-title class_">ArrayBuffer</span> 对象后，可以对同一个缓冲创建多个不同的视图，每个视图的偏移量和数据类型都可以不一样：<span class="hljs-keyword">var</span> buffer = msg.<span class="hljs-property">data</span>;<span class="hljs-keyword">var</span> usernameView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);<span class="hljs-keyword">var</span> idView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint16Array</span>(buffer, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">var</span> scoresView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(buffer, <span class="hljs-number">18</span>, <span class="hljs-number">32</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ID: &quot;</span> + idView[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; username: &quot;</span> + usernameView[<span class="hljs-number">0</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>；j++) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(scoresView[j]) &#125;每个视图都以父缓冲、开始字节偏移量和要处理的元素数作为参数，其中偏移量根据之前字段的大小计算。结果，<span class="hljs-title class_">ArrayBuffer</span> 和 <span class="hljs-title class_">WebSocket</span> 实际上为我们在浏览器中处理二进制数据提供了所有必要的工具。</code></pre></div><h5 id="发送文本和二进制数据"><a href="#发送文本和二进制数据" class="headerlink" title="发送文本和二进制数据"></a>发送文本和二进制数据</h5><p>建立了 WebSocket 连接后，客户端就可以随时发送或接收 UTF-8 或二进制消息。WebSocket 提供的是一条双向通信的信道，也就是说，在同一个 TCP 连接上，可以双向传输数据</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://example.com/socket&#x27;</span>);ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hello server!&quot;</span>); <span class="hljs-comment">//➊ 发送 UTF-8 编码的文本消息</span> socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<span class="hljs-string">&#x27;msg&#x27;</span>: <span class="hljs-string">&#x27;payload&#x27;</span>&#125;)); <span class="hljs-comment">//➋ 发送 UTF-8 编码的 JSON 净荷</span> <span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">128</span>); socket.<span class="hljs-title function_">send</span>(buffer); <span class="hljs-comment">//➌ 发送二进制 ArrayBuffer</span> <span class="hljs-keyword">var</span> intview = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(buffer); socket.<span class="hljs-title function_">send</span>(intview); <span class="hljs-comment">//➍ 发送二进制 ArrayBufferView</span> <span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([buffer]); socket.<span class="hljs-title function_">send</span>(blob); <span class="hljs-comment">//➎ 发送二进制 Blob</span>&#125;</code></pre></div><p>WebSocket API 可以接收 UTF-8 编码的 DOMString 对象，也可以接收 ArrayBuffer、ArrayBufferView 或 Blob 等二进制数据。但要注意，所有二进制数据类型只是为了简化 API：在传输中，只通过一位（bit）即可将 WebSocket 帧标记为二进制或者文本。假如应用或服务器需要传输其他的内容类型，就必须通过其他机制来沟通这个信息。这里的 send() 方法是异步的：提供的数据会在客户端排队，而函数则立即返回。特别是在传输大文件的时候，千万别因为返回快，就错误地以为数据已经发送出去了！要监控在浏览器中排队的数据量，可以查询套接字的 bufferedAmount 属性：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://example.com/socket&#x27;</span>);ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">subscribeToApplicationUpdates</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123; <span class="hljs-comment">//➊预订应用更新（如游戏状态更新）</span> <span class="hljs-keyword">if</span> (ws.<span class="hljs-property">bufferedAmount</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">//➋检查客户端缓冲的数据量</span> ws.<span class="hljs-title function_">send</span>(evt.<span class="hljs-property">data</span>); <span class="hljs-comment">//➌如果缓冲是空的，发送下一次更新</span> &#125;);&#125;</code></pre></div><p>前面的例子是要向服务器发送应用数据，但前提是客户端缓冲区已经没有之前待发送的数据了。为什么非要做这个检查？所有 WebSocket 消息都会按照它们在客户端排队的次序逐个发送。因此，大量排队的消息，甚至一个大消息，都可能导致排在它后面的消息延迟——队首阻塞！为解决这个问题，应用可以将大消息切分成小块，通过监控 bufferedAmount 的值来避免队首阻塞。甚至还可以实现自己的优先队列，而不是盲目都把它们送到套接字上排队。</p><div class="code-wrapper"><pre><code class="hljs">很多应用都会生成多种消息：有高优先级的更新，也有低优先级的更新。前者比如流量控制消息，后者比如后台传输。要实现最优化传输，应用必须关心任意时刻在套接字上排队的是什么消息</code></pre></div><h5 id="子协议协商"><a href="#子协议协商" class="headerlink" title="子协议协商"></a>子协议协商</h5><p>WebSocket 协议对每条消息的格式事先不作任何假设：仅用一位标记消息是文本还是二进制，以便客户端和服务器有效地解码数据，而除此之外的消息内容就是未知的</p><p>此外，与 HTTP 或 XHR 请求不同——它们是通过每次请求和响应的 HTTP 首部来沟通元数据，WebSocket 并没有等价的机制。因此，如果需要沟通关于消息的元数据，客户端和服务器必须达成沟通这一数据的子协议</p><p>客户端和服务器可以提前确定一种固定的消息格式，比如所有通信都通过 JSON编码的消息或者某种自定义的二进制格式进行，而必要的元数据作为这种数据结构的一个部分</p><p>如果客户端和服务器要发送不同的数据类型，那它们可以确定一个双方都知道的消息首部，利用它来沟通说明信息或有关净荷的其他解码信息</p><p>混合使用文本和二进制消息可以沟通净荷和元数据，比如用文本消息实现 HTTP首部的功能，后跟包含应用净荷的二进制消息。</p><p>以上只列举了几种可能的策略。与 WebSocket 消息的灵活性和低延迟对应的，就是应用逻辑必须复杂一点。不过，消息的串行化和元数据管理只是问题的一方面！确定了消息的串行格式化，怎么保证客户端和服务器相互理解，怎么确保它们同步呢？</p><p>好在，WebSocket 为此提供了一个简单便捷的子协议协商 API。客户端可以在初次连接握手时，告诉服务器自己支持哪种协议：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://example.com/socket&#x27;</span>, [<span class="hljs-string">&#x27;appProtocol&#x27;</span>, <span class="hljs-string">&#x27;appProtocol-v2&#x27;</span>]); <span class="hljs-comment">//➊ 在 WebSocket 握手期间发送子协议数组</span>ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">if</span> (ws.<span class="hljs-property">protocol</span> == <span class="hljs-string">&#x27;appProtocol-v2&#x27;</span>) &#123; <span class="hljs-comment">//➋ 检查服务器选择了哪个子协议</span> ... &#125; <span class="hljs-keyword">else</span> &#123; ... &#125;&#125;</code></pre></div><p>如这个例子所示，WebSocket 构造函数可以接受一个可选的子协议名字的数组，通过这个数组，客户端可以向服务器通告自己能够理解或希望服务器接受的协议。这个协议数组会发送给服务器，服务器可以从中挑选一个。</p><p>如果子协议协商成功，就会触发客户端的 onopen 回调，应用可以查询 WebSocket 对象上的 protocol 属性，从而得知服务器选定的协议。另一方面，服务器如果不支持客户端声明的任何一个协议，则 WebSocket 握手是不完整的，此时会触发 onerror 回调，连接断开。</p><p><u>子协议名由应用自己定义，且在初次 HTTP 握手期间发送给服务器。除此之外，指定的子协议对核心 WebSocket API 不会有任何影响。</u></p><h4 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h4><p>HyBi Working Group 制定的 WebSocket 通信协议（RFC 6455）包含两个高层组件：开放性 HTTP 握手用于协商连接参数，二进制消息分帧机制用于支持低开销的基于消息的文本和二进制数据传输</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">WebSocket</span> 协议尝试在既有 HTTP 基础设施中实现双向 HTTP 通信，因此也使用 HTTP 的 <span class="hljs-number">80</span> 和 <span class="hljs-number">443</span> 端口……不过，这个设计不限于通过 HTTP 实现WebSocket 通信，未来的实现可以在某个专用端口上使用更简单的握手，而不必重新定义么一个协议。</code></pre></div><p>WebSocket 协议是一个独立完善的协议，可以在浏览器之外实现。不过，它的主要应用目标还是实现浏览器应用的双向通信</p><h4 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h4><p>客户端和服务器 WebSocket 应用通过基于消息的 API 通信：发送端提供任意 UTF-8或二进制的净荷，接收端在整个消息可用时收到通知。为此，WebSocket 使用了自定义的二进制分帧格式（图 17-1），把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。</p><ul><li>帧</li></ul><p>最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分</p><p>应用消息。</p><ul><li>消息</li></ul><p>一系列帧，与应用消息对等。</p><p>是否把消息分帧由客户端和服务器实现决定。事实上，应用可以对个别 WebSocket帧或如何分帧毫无概念。即便如此，理解每个 WebSocket 帧也很重要。</p><ul><li><p>每一帧的第一位（FIN）表示当前帧是不是消息的最后一帧。一条消息有可能只对应一帧。</p></li><li><p>操作码（4 位）表示被传输帧的类型：传输应用数据时，是文本（1）还是二进制 （2）；连接有效性检查时，是关闭（8）、呼叫（ping，9）还是回应（pong，10）。</p></li><li><p>掩码位表示净荷是否有掩码（只适用于客户端发送给服务器的消息）。</p></li><li><p>净荷长度由可变长度字段表示：</p><ul><li>如果是 0~125，就是净荷长度；</li><li>如果是 126，则接下来 2 字节表示的 16 位无符号整数才是这一帧的长度；</li><li>如果是 127，则接下来 8 字节表示的 64 位无符号整数才是这一帧的长度</li></ul></li><li><p>掩码键包含 32 位值，用于给净荷加掩护。</p></li><li><p>净荷包含应用数据，如果客户端和服务器在建立连接时协商过，也可以包含自定义的扩展数据</p></li></ul><div class="code-wrapper"><pre><code class="hljs awk">所有客户端发送帧的净荷都要使用帧首部中指定的值加掩码，这样可以防止客户端中运行的恶意脚本对不支持 WebSocket 的中间设备进行缓存投毒攻击（cache poisoning attack）。要了解这种攻击的细节，请参考 W2SP <span class="hljs-number">2011</span> 的论文“Talking to Yourself <span class="hljs-keyword">for</span> Fun and Profit”（http:<span class="hljs-regexp">//</span>w2spconf.com/ <span class="hljs-number">2011</span><span class="hljs-regexp">/papers/</span>websocket.pdf）。</code></pre></div><p>算下来，服务器发送的每个 WebSocket 帧会产生 2<del>10 字节的分帧开销。而客户端必须发送掩码键，这又会增加 4 字节，结果就是 6</del>14 字节的开销。除此之外，没有其他元数据（比如首部字段或其他关于净荷的信息）：所有 WebSocket 通信都是通过交换帧实现的，而帧将净荷视为不透明的应用数据块。</p><p><strong>WebSocket 的多路复用及队首阻塞</strong></p><p>WebSocket 很容易发生队首阻塞的情况：消息可能会被分成一或多个帧，但不同消息的帧不能交错发送，因为没有与 HTTP 2.0 分帧机制中“流 ID”对等的字段</p><p>显然，如果一个大消息被分成多个 WebSocket 帧，就会阻塞其他消息的帧。如果你的应用不容许有交付延迟，那可以小心控制每条消息的净荷大小，甚至可以考虑把大消息拆分成多个小消息！</p><p>WebSocket 不支持多路复用，还意味着每个 WebSocket 连接都需要一个专门的TCP 连接。对于 HTTP 1.x 而言，由于浏览器针对每个来源有连接数量限制，因此可能会导致问题</p><p>好 在，HyBi Working Group 正 着 手 制 定 的 新 的“Multiplexing Extension for WebSockets”（WebSockets 多路复用扩展）会解决这个问题</p><p><em>这个扩展通过封装帧并加上信道 ID，可以让一个 TCP 连接支持多个虚拟 WebSocket 连接……这个多路复用扩展维护独立的逻辑信道，每个逻辑信道与独立的 WebSocket 连接没有差别，包括独立的握手首部。</em></p><p>有了这个扩展后，多个 WebSocket 连接（信道）就可能在同一个 TCP 连接上得到复用。可是，每个信道依旧容易产生队首阻塞问题！可能的解决方案是使用不同的信道，或者专用 TCP 连接，多路并行发送消息。</p><p>最后，注意前面的扩展仅对 HTTP 1.x 连接是必要的。虽然通过 HTTP 2.0 传输WebSocket 帧的官方规范尚未发布，但相对来说就容易多了。因为 HTTP 2.0 内置了流的多路复用，只要通过 HTTP 2.0 的分帧机制来封装 WebSocket 帧，多个WebSocket 连接就可以在一个会话中传输。</p><h5 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h5><p>WebSocket 规范允许对协议进行扩展：数据格式和 WebSocket 协议的语义可以通过新的操作码和数据字段扩展。虽然有些不同寻常，但这却是一个非常强大的特性，因为它允许客户端和服务器在基本的 WebSocket 分帧层之上实现更多功能，又不需要应用代码介入或协作。</p><p>WebSocket 协议扩展有哪些例子？负责制定 WebSocket 规范的 HyBi Working Group就进行了两项扩展。</p><ul><li>多路复用扩展（A Multiplexing Extension for WebSockets）这个扩展可以将 WebSocket 的逻辑连接独立出来，实现共享底层的 TCP 连接。</li><li>压缩扩展（Compression Extensions for WebSocket） 给 WebSocket 协议增加了压缩功能。</li></ul><p>如前所述，每个 WebSocket 连接都需要一个专门的 TCP 连接，这样效率很低。多路复用扩展解决了这个问题。它使用“信道 ID”扩展每个 WebSocket 帧，从而实现多个虚拟的 WebSocket 信道共享一个 TCP 连接。</p><p>类似地，基本的 WebSocket 规范没有压缩数据的机制或建议，每个帧中的净荷就是应用提供的净荷。虽然这对优化的二进制数据结构不是问题，但除非应用实现自己的压缩和解压缩逻辑，否则很多情况下都会造成传输载荷过大的问题。实际上，压缩扩展就相当于 HTTP 的传输编码协商。</p><h5 id="HTTP升级协商"><a href="#HTTP升级协商" class="headerlink" title="HTTP升级协商"></a>HTTP升级协商</h5><p>WebSocket 协议提供了很多强大的特性：基于消息的通信、自定义的二进制分帧层、子协议协商、可选的协议扩展，等等。换句话说，在交换数据之前，客户端必须与服务器协商适当的参数以建立连接。</p><p>利用 HTTP 完成握手有几个好处。首先，让 WebSockets 与现有 HTTP 基础设施兼容：WebSocket 服务器可以运行在 80 和 443 端口上，这通常是对客户端唯一开放的端口。其次，让我们可以重用并扩展 HTTP 的 Upgrade 流，为其添加自定义的WebSocket 首部，以完成协商</p><p><strong>Sec-WebSocket-Version</strong></p><p>客户端发送，表示它想使用的 WebSocket 协议版本（“13”表示 RFC 6455）。如果服务器不支持这个版本，必须回应自己支持的版本。</p><p><strong>Sec-WebSocket-Key</strong></p><p>客户端发送，自动生成的一个键，作为一个对服务器的“挑战”，以验证服务器支持请求的协议版本。</p><p><strong>Sec-WebSocket-Accept</strong></p><p>服务器响应，包含 Sec-WebSocket-Key 的签名值，证明它支持请求的协议版本。</p><p>有了这些协商字段，就可以在客户端和服务器之间进行 HTTP Upgrade 并协商新的WebSocket 连接了：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable constant_">GET</span> /socket <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span><span class="hljs-title class_">Host</span>: thirdparty.<span class="hljs-property">com</span><span class="hljs-title class_">Origin</span>: <span class="hljs-attr">http</span>:<span class="hljs-comment">//example.com</span><span class="hljs-title class_">Connection</span>: <span class="hljs-title class_">Upgrade</span><span class="hljs-title class_">Upgrade</span>: websocket <span class="hljs-comment">//➊ 请求升级到 WebSocket 协议</span><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Version</span>: <span class="hljs-number">13</span> <span class="hljs-comment">//➋ 客户端使用的 WebSocket 协议版本</span><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Key</span>: dGhlIHNhbXBsZSBub25jZQ== <span class="hljs-comment">//➌ 自动生成的键，以验证服务器对协议的支持</span><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Protocol</span>: appProtocol, appProtocol-v2 <span class="hljs-comment">//➍ 可选的应用指定的子协议列表</span><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Extensions</span>: x-webkit-deflate-message, x-custom-extension <span class="hljs-comment">//➎ 可选的客户端支持的协议扩展列表</span></code></pre></div><p>与浏览器中客户端发起的任何连接一样，WebSocket 请求也必须遵守同源策略：浏览器会自动在升级握手请求中追加 Origin 首部，远程服务器可能使用 CORS 判断接受或拒绝跨源请求 [ 参见 15.2 节“跨源资源共享（CORS）”]。要完成握手，服务器必须返回一个成功的“Switching Protocols”（切换协议）响应，并确认选择了客户端发送的哪个选项：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">101</span> <span class="hljs-title class_">Switching</span> <span class="hljs-title class_">Protocols</span> <span class="hljs-comment">//➊101 响应码确认升级到 WebSocket 协议</span><span class="hljs-title class_">Upgrade</span>: websocket<span class="hljs-title class_">Connection</span>: <span class="hljs-title class_">Upgrade</span><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: <span class="hljs-attr">http</span>:<span class="hljs-comment">//example.com ➋CORS 首部表示选择同意跨源连接</span><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= <span class="hljs-comment">//➌签名的键值验证协议支持</span><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Protocol</span>: appProtocol-v2 <span class="hljs-comment">//➍ 服务器选择的应用子协议</span><span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Extensions</span>: x-custom-extension <span class="hljs-comment">//➎ 服务器选择的 WebSocket 扩展</span></code></pre></div><p>所有兼容 RFC 6455 的 WebSocket 服务器都使用相同的算法计算客户端挑战的答案：将 Sec-WebSocket-Key 的内容与标准定义的唯一 GUID 字符串拼接起来，计算出 SHA1 散列值，结果是一个 base-64 编码的字符串，把这个字符串发给客户端即可。</p><p>最低限度，成功的 WebSocket 握手必须是客户端发送协议版本和自动生成的挑战值，服务器返回 101 HTTP 响应码（Switching Protocols）和散列形式的挑战答案，确认选择的协议版本：</p><p>客户端必须发送 Sec-WebSocket-Version 和 Sec-WebSocket-Key； </p><p>服务器必须返回 Sec-WebSocket-Accept 确认协议；</p><p>客户端可以通过 Sec-WebSocket-Protocol 发送应用子协议列表；</p><p>服务器必须选择一个子协议并通过 Sec-WebSocket-Protocol 返回协议名；如果服务器不支持任何一个协议，连接断开；</p><p>客户端可以通过 Sec-WebSocket-Extensions 发送协议扩展；</p><p>服务器可以通过 Sec-WebSocket-Extensions 确认一或多个扩展；如果服务器没有返回扩展，则连接不支持扩展</p><p>最后，前述握手完成后，如果握手成功，该连接就可以用作双向通信信道交换WebSocket 消息。从此以后，客户端与服务器之间不会再发生 HTTP 通信，一切由WebSocket 协议接管。</p><div class="code-wrapper"><pre><code class="hljs routeros">代理、中间设备与 WebSocket实践中，考虑到安全和保密，很多用户都只开放有限的端口，通常只有 80（HTTP）和 443（HTTPS）。正因为如此，WebSocket 协商是通过 HTTP<span class="hljs-built_in"> Upgrade</span><span class="hljs-built_in"></span>流进行的，这样可以确保与现有网络策略及基础设施兼容。不过，正如 4.1 节的“Web 代理、中间设备、TLS 与新协议”所说，很多现有的HTTP 中间设备可能不理解新的 WebSocket 协议，而这可能导致各种问题：盲目的连接升级、意外缓冲 WebSocket 帧、不明就里地修改内容、把 WebSocket 流量误当作不完整的 HTTP 通信，等等。WebSocket 的 Key 和 Accept 握手可以解决其中一些问题：这是服务器的一个安全策略，而盲目“升级”连接的中间设备可能并不理解 WebSocket 协议。虽然这个预防措施对某些代理可以解决问题，但对于那些“透明代理”还是不行，它们可能会分析并意外地修改数据。解决之道？建立一条端到端的安全通道。比如，使用 WSS ！在执行 HTTP <span class="hljs-built_in"></span><span class="hljs-built_in">Upgrade </span>握手之前，先协商一次 TLS 会话，在客户端与服务器之间建立一条加密通道，就可以解决前述所有问题。这个方案尤其适合移动客户端，因为它们的流量经常要穿越各种代理服务，这些代理服务很可能不认识 WebSocket。</code></pre></div><h4 id="WebSocket使用场景及性能"><a href="#WebSocket使用场景及性能" class="headerlink" title="WebSocket使用场景及性能"></a>WebSocket使用场景及性能</h4><p>WebSocket API 提供一个简单的接口，能够在客户端与服务器之间实现基于消息的双向通信，可以是文本数据，可以是二进制数据：</p><p>把 WebSocket URL 传递给构造函数，设置几个 JavaScript 回调函数，就好了——剩下的就全都由浏览器负责了。再加上 WebSocket 协议提供的二进制分帧、可扩展性以及子协议协商，使得WebSocket 成为在浏览器中采用自定义应用协议的最佳选择</p><h5 id="请求和响应流"><a href="#请求和响应流" class="headerlink" title="请求和响应流"></a>请求和响应流</h5><p>WebSocket 是唯一一个能通过同一个 TCP 连接实现双向通信的机制（图 17-2），客户端和服务器随时可以交换数据。因此，WebSocket 在两个方向上都能保证文本和二进制应用数据的低延迟交付</p><p>XHR 是专门为“事务型”请求 / 响应通信而优化的：客户端向服务器发送完整的、格式良好的 HTTP 请求，服务器返回完整的响应。这里不支持请求流，在Streams API 可用之前，没有可靠的跨浏览器响应流 API。</p><p>SSE 可以实现服务器到客户端的高效、低延迟的文本数据流：客户端发起 SSE 连接，服务器使用事件源协议将更新流式发送给客户端。客户端在初次握手后，不能向服务器发送任何数据</p><div class="code-wrapper"><pre><code class="hljs">传播与排队延迟把传输机制从 XHR 切换为 SSE 或 WebSocket 并不会减少客户端与服务器间的往返次数！不管什么传输机制，数据包的传播延迟都一样。不过，除了传播延迟，还有一个排队延迟——消息在被发送给另一端之前必须在客户端或服务器上等待的时间。对 XHR 轮询而言，排队延迟就是客户端轮询间隔：服务器上的消息可用之后，必须等到下一次客户端 XHR 请求才能发送（参见 15.7.1 节的“XHR 轮询的性能建模”）。相对来说，SSE 和 WebSocket 使用持久连接，这样服务器（和客户端——如果是 WebSocket）就可以在消息可用时立即发送它。综上所述，SSE 和 WebSocket 的“低延迟交付”专指消除了消息的排队延迟。我们还没发现怎么让 WebSocket 数据包跑得比光还快！</code></pre></div><h5 id="消息开销"><a href="#消息开销" class="headerlink" title="消息开销"></a>消息开销</h5><p>建立了 WebSocket 连接后，客户端和服务器通过 WebSocket 协议交换数据：应用消息会被拆分为一或多个帧，每个帧会添加 2~14 字节的开销。而且，由于分帧是按照自定义的二进制格式完成的，UTF-8 和二进制应用数据可以有效地通过相同的机制编码。这一点与 XHR 和 SSE 比如何呢？</p><p>1.SSE 会给每个消息添加 5 字节，但仅限于 UTF-8 内容</p><p>2.HTTP 1.x 请求（XHR 及其他常规请求）会携带 500~800 字节的 HTTP 元数据，加上 cookie，参见 11.5 节“度量和控制协议开销”。</p><p>3.HTTP 2.0 压缩 HTTP 元数据，这样可以显著减少开销，参见 12.3.8 节“首部压缩”。事实上，如果请求都不修改首部，那么开销可以低至 8 字节！</p><div class="code-wrapper"><pre><code class="hljs armasm">记住，这里的开销数不包括 <span class="hljs-built_in">IP</span>、TCP 和 TLS 分帧的开销，后者一共会给每个消息增加 <span class="hljs-number">60</span>~<span class="hljs-number">100</span> 字节，无论使用的是什么应用协议，参见 <span class="hljs-number">4</span>.<span class="hljs-number">7</span>.<span class="hljs-number">4</span> 节 “TLS 记录大小</code></pre></div><h5 id="数据效率及压缩"><a href="#数据效率及压缩" class="headerlink" title="数据效率及压缩"></a>数据效率及压缩</h5><p>通过常规的 HTTP 协商，每个 XHR 请求都可以协商最优的传输编码格式（如对文本数据采用 gzip 压缩）。类似地，SSE 局限于 UTF-8 文本数据，因此事件流数据可以在整个会话期间使用 gzip 压缩</p><p>而使用 WebSocket 时，情况要复杂一些：WebSocket 可以传输文本和二进制数据，因此压缩整个会话行不通。二进制的净荷也可能已经压缩过了！为此，WebSocket必须实现自己的压缩机制，并针对每个消息选择应用。</p><p>好在 HyBi 工作组正在为 WebSocket 协议制定以消息为单位的压缩扩展。只是这个扩展尚未得到任何浏览器支持。因此，除非应用通过细致优化自己的二进制净荷实现自己的压缩逻辑（参见 17.1.2 节的“使用 JavaScript 解码二进制数据”），同时也针对文本消息实现自己的压缩逻辑，否则传输数据过程中一定会产生很大的字节开销！</p><h5 id="自定义应用协议"><a href="#自定义应用协议" class="headerlink" title="自定义应用协议"></a>自定义应用协议</h5><p>浏览器是为 HTTP 数据传输而优化的，它理解 HTTP 协议，提供各种服务，比如认证、缓存、压缩，等等。于是，XHR 请求自然而然就继承了所有这些功能。</p><p>相对来说，流式数据处理可以让我们在客户端和服务器间自定义协议，代价是错过浏览器提供的很多服务：初次 HTTP 握手可以执行某些连接参数的协商，而一旦建立会话，所有后续客户端与服务器间的数据流对浏览器都将是不透明的。这样来看，自定义应用协议的灵活性也有缺点，应用可能必须实现自已的逻辑来填充某些功能空白，比如缓存、状态管理、元数据交付，等等</p><p>初始的 HTTP Upgrade 握手可以让服务器利用既有的 HTTP cookie 机制来验证用户。如果验证失败，服务器可以拒绝 WebSocket 升级</p><div class="code-wrapper"><pre><code class="hljs">利用浏览器和中间设备的缓存使用常规 HTTP 有很多明显的优势。问自己一个简单的问题：客户端会不会因缓存接收到的数据而受益？或者中间设备如果缓存数据，是否可以优化对该数据的交付？举个例子，WebSocket 支持二进制传输，因此应用可以流式传输任意图片而没有开销！然而，由于图片是采用自定义协议交付的，它不会被保存到浏览器或任何中间设备（如 CDN）的缓存中。结果，就可能给客户端造成不必要的下载，给来源服务器带来相当高的流量。同样的道理也适用于视频、文本等数据格式。因此，要根据应用选择合适的传输机制！一个简单但有效的策略，就是使用WebSocket 交付无需缓存的数据，如实时更新和应用“控制”消息，后者再触发XHR 请求通过 HTTP 协议取得其他资源。</code></pre></div><h5 id="部署WebSocket基础设施"><a href="#部署WebSocket基础设施" class="headerlink" title="部署WebSocket基础设施"></a>部署WebSocket基础设施</h5><p>HTTP 是专为短时突发性传输设计的。于是，很多服务器、代理和其他中间设备的HTTP 连接空闲超时设置都很激进。而这显然是我们在持久的 WebSocket 会话中所不愿意看到的。为解决这个问题，要考虑三个方面：</p><p>位于各自网络中的路由器、负载均衡器和代理；</p><p>外部网络中透明、确定的代理服务器（如 ISP 和运营商的代理）；</p><p>客户网络中的路由器、防火墙和代理。</p><p>我们没有权限控制客户网络的策略。事实上，某些网络甚至会完全屏蔽 WebSocket通信，而这正是必须有备用机制的原因。类似地，我们也没有权限控制外部网络中的代理。可是，这里可以借助 TLS ！通过建立一条端到端的加密信道，可以让WebSocket 通信绕过所有中间代理。</p><p>使用 TLS 不会阻止中间设备超时断开空闲的 TCP 连接。可是，实践中，WebSocket 会话协商的成功率越来越高，这样也有助于增加连接超时的间隔。</p><p>最后，就是我们自己部署并管理的基础设施，需要经常关注和调优。就跟我们经常抱怨客户和外部网络一样，我们自己家的问题其实一点也不少。通信路径上的每一台负载均衡器、路由器和 Web 服务器都必须针对长时连接进行调优。</p><p>例如，Nginx 1.3.13+ 可以代理 WebSocket 通信，但默认设置了激进的 60 秒超时！为了突破这个限制，我们必须明确定义更长的超时：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /websocket &#123; <span class="hljs-attribute">proxy_pass</span> http://backend; <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>; <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>; <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>; <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">3600</span>;// ➊设置两次读操作间的超时为 60 分钟 <span class="hljs-attribute">proxy_send_timeout</span> <span class="hljs-number">3600</span>; //➋设置两次写操作间的超时为 60 分钟&#125;</code></pre></div><p>类似地，Nginx 服务器前面经常少不了要部署一台负载均衡器，比如 HAProxy。毫不奇怪，在此也要采取相同的策略，以 HAProxy 为例：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">defaults</span> http timeout connect <span class="hljs-number">30s</span> timeout client <span class="hljs-number">30s</span> timeout server <span class="hljs-number">30s</span> timeout tunnel <span class="hljs-number">1h</span> //➊为专用信道设置 <span class="hljs-number">60</span> 分钟的不活动超时</code></pre></div><p>前面例子的关键在于额外的“信道”超时。对 HAProxy 来说，connect、client 和server 超时只适用于初始的 HTTP Upgrade 握手，而一旦升级完成，超时就会由信道（tunnel）值控制。</p><p>Nginx 和 HAProxy 只是我们数据中心内几百种服务器、代理和负载均衡器中的两种。我不可能在这里把所有可能的配置项都罗列出来。前面的例子只是为了说明大多数基础设施都需要自定义的配置，才能顺利处理长时会话。请记住，在实现应用的持久连接之前，首先要保证基础设施的配置正确。</p><p>长时连接和空闲会话会占用所有中间设备及服务器的内存和套接字资源。实际上，短超时经常被视为安全、资源管理及运维的预防措施。无论部署WebSocket、SSE，还是 HTTP 2.0，都有赖于长时会话，都会对运维提出新的挑战。</p><h4 id="性能检查表"><a href="#性能检查表" class="headerlink" title="性能检查表"></a>性能检查表</h4><p>部署高性能的 WebSocket 服务要求细致地调优和考量，无论在客户端还是在服务器上。可以参考下列要点</p><p>• 使用安全 WebSocket（基于 TLS 的 WSS）实现可靠的部署。</p><p>• 密切关注腻子脚本的性能（如果使用腻子脚本）。</p><p>• 利用子协议协商确定应用协议。</p><p>• 优化二进制净荷以最小化传输数据。</p><p>• 考虑压缩 UTF-8 内容以最小化传输数据。</p><p>• 设置正确的二进制类型以接收二进制净荷。</p><p>• 监控客户端缓冲数据的量。</p><p>• 切分应用消息以避免队首阻塞。</p><p>• 合用的情况下利用其他传输机制。</p><p>最后但同样重要的是，为移动应用而优化！实时推送对于手持设备而言，反倒可能造成负面影响，因为手持设备的电池始终很宝贵。这并不代表不能在移动应用中使用 WebSocket。相反，WebSocket 其实是一个高效的传输机制，但一定要确保注意以下问题：</p><p>“节约用电”；</p><p>“消除周期性及无效的数据传输”；</p><p>“内格尔及有效的服务器推送”；</p><p>“消除不必要的长连接”。</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="Web性能要点"><a href="#Web性能要点" class="headerlink" title="Web性能要点"></a><strong>Web</strong>性能要点</h4><p>• 延迟和带宽对 Web 性能的影响；</p><p>• 传输协议（TCP）对 HTTP 的限制；</p><p>• HTTP 协议自身的功能和缺陷；</p><p>• Web 应用的发展趋势及性能需求；</p><p>• 浏览器局限性和优化思路</p><p><strong>时间和用户感觉</strong></p><table><thead><tr><th>时间</th><th>感觉</th></tr></thead><tbody><tr><td>0-100ms</td><td>很快</td></tr><tr><td>100-300ms</td><td>有一点慢</td></tr><tr><td>300-1000ms</td><td>机器在工作</td></tr><tr><td>&gt;1000ms</td><td>先干点别的吧</td></tr><tr><td>&gt;10000ms</td><td>不能用了</td></tr></tbody></table><p>这个表格解释了 Web 性能社区总结的经验法则：必须 250 ms 内渲染页面，或者至少提供视觉反馈，才能保证用户不走开！</p><p>如果想让人感觉很快，就必须在几百 ms 内响应用户操作。超过 1 s，用户的预期流程就会中断，心思就会向其他任务转移，而超过 10 s，除非你有反馈，否则用户基本上就会终止任务！</p><p>现在，把 DNS 查询，随后的 TCP 握手，以及请求网页所需的几次往返时间都算上，光网络上的延迟就能轻易突破 100~1000 ms 的预算。难怪有那么多用户，特别是那些移动或无线用户，抱怨上网速度慢了！</p><p>谈到 Web 性能，必然要谈资源瀑布。事实上，资源瀑布很可能是我们可以用来分析网络性能，诊断网络问题的一个最有价值的工具。很多浏览器都内置了一些手段，让我们能查看资源瀑布。此外，还有一些不错的在线工具，比如 WebPageTest（<a href="http://www.webpagetest.org/%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%91%88%E7%8E%B0%E8%B5%84%E6%BA%90%E7%80%91%E5%B8%83%E3%80%82">http://www.webpagetest.org/），可以在不同的浏览器中呈现资源瀑布。</a></p><p>网络的瀑布图是个很强大的工具，有助于揭示任何页面或应用是否处于优化状态。前面分析和优化资源瀑布的过程，一般称为前端性能分析和优化。不过，这个称呼有误导性，好像所有性能瓶颈都在客户端似的。实际上，尽管 JavaScript、CSS 和渲染流水线很重要，而且资源对性能影响很大，但服务器响应时间和网络延迟（“后端性能”）对资源瀑布的影响也不容忽视。毕竟，如果网络被阻塞，也就谈不上什么解析或运行资源了！</p><p>限制 Web 性能的主要因素是客户端与服务器之间的网络往返延迟。</p><h5 id="性能来源：计算、渲染和网络访问"><a href="#性能来源：计算、渲染和网络访问" class="headerlink" title="性能来源：计算、渲染和网络访问"></a>性能来源：计算、渲染和网络访问</h5><p>Web 应用的执行主要涉及三个任务：取得资源、页面布局和渲染、JavaScript 执行。其中，渲染和脚本执行在一个线程上交错进行，不可能并发修改生成的 DOM,实际上，优化运行时的渲染和脚本执行是至关重要可是，就算优化了 JavaScript 执行和渲染管道，如果浏览器因网络阻塞而等待资源到来，那结果也好不到哪里去。对运行在浏览器中的应用来说，迅速而有效地获取网络资源是第一要义。</p><h5 id="更多带宽其实不（太）重要"><a href="#更多带宽其实不（太）重要" class="headerlink" title="更多带宽其实不（太）重要"></a>更多带宽其实不（太）重要</h5><h5 id="延迟是性能瓶颈"><a href="#延迟是性能瓶颈" class="headerlink" title="延迟是性能瓶颈"></a>延迟是性能瓶颈</h5><p>大多数 HTTP 数据流都是小型突发性数据流，而 TCP 则是为持久连接和大块数据传输而进行过优化的。网络往返时间在大多数情况下都是 TCP 吞吐量和性能的限制因素，详细信息可参见 2.5 节“针对 TCP 的优化建议”。于是，延迟自然也就成了 HTTP 及大多数基于 HTTP 交付的应用的性能瓶颈。</p><h5 id="针对浏览器的优化建议"><a href="#针对浏览器的优化建议" class="headerlink" title="针对浏览器的优化建议"></a>针对浏览器的优化建议</h5><p><strong>基于文档的优化</strong></p><p>熟悉网络协议，了解文档、CSS 和 JavaScript 解析管道，发现和优先安排关键网</p><p>络资源，尽早分派请求并取得页面，使其尽快达到可交互的状态。主要方法是优</p><p>先获取资源、提前解析等。</p><p><strong>推测性优化</strong></p><p>浏览器可以学习用户的导航模式，执行推测性优化，尝试预测用户的下一次操作。然后，预先解析 DNS、预先连接可能的目标。好消息是，所有这些优化都由浏览器替我们自动完成，经常可以节省几百 ms 的网络延迟。既然如此，那理解这些优化背后的原理就至关重要资• 源预取和排定优先次序</p><p>文档、CSS 和 JavaScript 解析器可以与网络协议层沟通，声明每种资源的优先级：初始渲染必需的阻塞资源具有最高优先级，而低优先级的请求可能会被临时</p><p>保存在队列中。</p><p>• DNS预解析</p><p>对可能的域名进行提前解析，避免将来 HTTP 请求时的 DNS 延迟。预解析可以通过学习导航历史、用户的鼠标悬停，或其他页面信号来触发。</p><p>• TCP预连接</p><p>DNS 解析之后，浏览器可以根据预测的 HTTP 请求，推测性地打开 TCP 连接。如果猜对的话，则可以节省一次完整的往返（TCP 握手）时间。</p><p>• 页面预渲染</p><p>某些浏览器可以让我们提示下一个可能的目标，从而在隐藏的标签页中预先渲染整个页面。这样，当用户真的触发导航时，就能立即切换过来了，这样才能利用浏览器的这些特性，提升应用性能。大多数浏览器都利用了如下四种技术</p><p>从外部看，现代浏览器的网络协议实现以简单的资源获取机制的面目示人，而从内部来说，它又极为复杂精密，为了解如何优化性能，非常值得深入钻研。那么，在探寻的过程中，我们怎么利用浏览器的这些机制呢？首先，要密切关注每个页面的结构和交付：</p><p>• CSS 和 JavaScript 等重要资源应该尽早在文档中出现；</p><p>• 应该尽早交付 CSS，从而解除渲染阻塞并让 JavaScript 执行；</p><p>• 非关键性 JavaScript 应该推迟，以避免阻塞 DOM 和 CSSOM 构建；</p><p>• HTML 文档由解析器递增解析，从而保证文档可以间隙性发送，以求得最佳性能。</p><p>除了优化页面结构，还可以在文档中嵌入提示，以触发浏览器为我们采用其他优化机制：</p><div class="code-wrapper"><pre><code class="hljs js">&lt;link rel=<span class="hljs-string">&quot;dns-prefetch&quot;</span> href=<span class="hljs-string">&quot;//hostname_to_resolve.com&quot;</span>&gt; <span class="hljs-comment">//➊预解析特定的域名</span>&lt;link rel=&quot;subresource&quot; href=&quot;/javascript/myapp.js&quot;&gt; //➋预取得页面后面要用到的关键性资源&lt;link rel=&quot;prefetch&quot; href=&quot;/images/big.jpeg&quot;&gt; //➌预取得将来导航要用的资源&lt;link rel=&quot;prerender&quot; href=&quot;//example.org/next_page.html&quot;&gt; //➍根据对用户下一个目标的预测，预渲染特定页面</code></pre></div><p>对大多数用户甚至 Web 开发者而言，DNS、TCP 和 SSL 延迟完全不可见，它们都是在网络层协商确定的，我们中很少有人关注它们。然而，这其中每一步都关乎整体的用户体验，因为每一次额外的网络往返都会增加几十甚至几百 ms 的网络延迟。通过帮助浏览器预测这些往返，可以消除这些瓶颈，从而向用户交付更快更好的体验。</p><h4 id="HTTP-1-x"><a href="#HTTP-1-x" class="headerlink" title="HTTP 1.x"></a><strong>HTTP 1.x</strong></h4><p>改进 HTTP 的性能是 HTTP 1.1 工作组的一个重要目标，后来这个版本也引入了大量增强性能的重要特性，其中一些大家比较熟知的有：</p><p>• 持久化连接以支持连接重用；</p><p>• 分块传输编码以支持流式响应；</p><p>• 请求管道以支持并行请求处理；</p><p>• 字节服务以支持基于范围的资源请求；　</p><p>• 改进的更好的缓存机制</p><h5 id="持久连接的优点"><a href="#持久连接的优点" class="headerlink" title="持久连接的优点"></a>持久连接的优点</h5><p>服务器处理时间无法预测，因为这个时间因资源和后端硬件而异。不过，这里的重点其实是由一个新 TCP 连接发送的 HTTP 请求所花的总时间，最少等于两次网络往返的时间：一次用于握手，一次用于请求和响应。这是所有非持久 HTTP 会话都要付出的固定时间成本。</p><p>实际上，这时候最简单的优化就是重用底层的连接！添加对 HTTP 持久连接的支持，就可以避免第二次 TCP 连接时的三次握手、消除另一次 TCP 慢启动的往返，节约整整一次网络延迟。</p><p>在我们两个请求的例子中，总共只节约了一次往返时间。但是，更常见的情况是一次 TCP 连接要发送 <em>N</em> 次 HTTP 请求，这时：</p><p>• 没有持久连接，每次请求都会导致两次往返延迟；</p><p>• 有持久连接，只有第一次请求会导致两次往返延迟，后续请求只会导致一次往返延迟</p><p>在启用持久连接的情况下，<em>N</em> 次请求节省的总延迟时间就是（<em>N</em>-1）×RTT。还记得吗，前面说过，在当代 Web 应用中，<em>N</em> 的平均值是 90，而且还在继续增加（10.2节“剖析现代 Web 应用”）。因此，依靠持久连接节约的时间，很快就可以用秒来衡量了！这充分说明持久化 HTTP 是每个 Web 应用的关键优化手段。</p><h5 id="客户端和服务器上的连接重用"><a href="#客户端和服务器上的连接重用" class="headerlink" title="客户端和服务器上的连接重用"></a>客户端和服务器上的连接重用</h5><div class="code-wrapper"><pre><code class="hljs armasm">好消息是，只要服务器愿意配合，所有现代浏览器都会尝试使用持久化 HTTP 连接。可以检查一下自己的应用和代理服务器配置，确保使用持久连接。为保证最好的结果，请使用 HTTP <span class="hljs-number">1</span>.<span class="hljs-number">1</span>，因为它默认启用持久连接。如果只能使用 HTTP <span class="hljs-number">1</span>.<span class="hljs-number">0</span>，则可以明确使用 Connection: <span class="hljs-meta">Keep</span>-Alive 首部声明使用持久连接。此外，还要注意 HTTP 库和框架的默认行为，因为很多库和框架经常会默认使用非持久连接，这种做法多数源于它们提供“更简单 API”的理念。只要使用原始<span class="hljs-symbol">HTTP</span> 连接，一定记得重用它们：重用连接的性能提升非常巨大！</code></pre></div><h5 id="HTTP管道"><a href="#HTTP管道" class="headerlink" title="HTTP管道"></a>HTTP管道</h5><p>持久 HTTP 可以让我们重用已有的连接来完成多次应用请求，但多次请求必须严格满足先进先出（FIFO）的队列顺序：发送请求，等待响应完成，再发送客户端队列中的下一个请求。HTTP 管道是一个很小但对上述工作流却非常重要的一次优化。管道可以让我们把 FIFO 队列从客户端（请求队列）迁移到服务器（响应队列）。要理解这样做的好处，首先，服务器处理完第一次请求后，会发生了一次完整的往返：先是响应回传，接着是第二次请求。在此期间服务器空闲。如果服务器能在处理完第一次请求后，立即开始处理第二次请求呢？甚至，如果服务器可以并行或在多线程上或者使用多个工作进程，同时处理两个请求呢？</p><p>通过尽早分派请求，不被每次响应阻塞，可以再次消除额外的网络往返。这样，就从非持久连接状态下的每个请求两次往返，变成了整个请求队列只需要两次网络往返</p><p>HTTP 1.1 管道的好处，主要就是消除了发送请求和响应的等待时间。这种并行处理请求的能力对提升应用性能的帮助非常之大。</p><p>现在我们暂停一会，回顾一下在性能优化方面的收获。一开始，每个请求要用两个TCP 连接（图 11-1），总延迟为 284 ms。在使用持久连接后（图 11-2），避免了一次握手往返，总延迟减少为 228 ms。最后，通过使用 HTTP 管道，又减少了两次请求之间的一次往返，总延迟减少为 172 ms。这样，从 284 ms 到 172 ms，这 40% 的性能提升完全拜简单的协议优化所赐。</p><p>而且，这 40% 的性能提升还不是固定不变的。这个数字与我们选择的网络延迟和两个请求的例子有关。希望读者自己能够尝试一些不同的情况，比如延迟更高、请求更多的情况。尝试之后，你会惊讶于性能提升效果比这里还要高得多。事实上，网络延迟越高，请求越多，节省的时间就越多。我觉得大家很有必要自己动手验证一下这个结果。因此，越是大型应用，网络优化的影响越大。</p><p>不过，这还不算完。眼光敏锐的读者可能已经发现了，我们可以在服务器上并行处理请求。理论上讲，没有障碍可以阻止服务器同时处理管道中的请求，从而再减少20 ms 的延迟。</p><p>图 11-4 演示了如下几个方面：</p><p>• HTML 和 CSS 请求同时到达，但先处理的是 HTML 请求；</p><p>• 服务器并行处理两个请求，其中处理 HTML 用时 40 ms，处理 CSS 用时 20 ms； </p><p>• CSS 请求先处理完成，但被缓冲起来以等候发送 HTML 响应；</p><p>• 发送完 HTML 响应后，再发送服务器缓冲中的 CSS 响应。</p><p>即使客户端同时发送了两个请求，而且 CSS 资源先准备就绪，服务器也会先发送HTML 响应，然后再交付 CSS。这种情况通常被称作队首阻塞，并经常导致次优化交付：不能充分利用网络连接，造成服务器缓冲开销，最终导致无法预测的客户端延迟。假如第一个请求无限期挂起，或者要花很长时间才能处理完，怎么办呢？在HTTP 1.1 中，所有后续的请求都将被阻塞，等待它完成在前面讨论 TCP 时，我们已经提到过队首阻塞的问题了。由于 TCP 要求严格按照顺序交付，丢失一个 TCP 分组就会阻塞所有高序号的分组，除非重传那个丢失的分组，这样就会导致额外的应用延迟，详细情况请参考 2.4节“队首阻塞”。</p><p>实际中，由于不可能实现多路复用，HTTP 管道会导致 HTTP 服务器、代理和客户端出现很多微妙的，不见文档记载的问题</p><p>• 一个慢响应就会阻塞所有后续请求；</p><p>• 并行处理请求时，服务器必须缓冲管道中的响应，从而占用服务器资源，如果有</p><p>个响应非常大，则很容易形成服务器的受攻击面；</p><p>• 响应失败可能终止 TCP 连接，从页强迫客户端重新发送对所有后续资源的请求，</p><p>导致重复处理；</p><p>• 由于可能存在中间代理，因此检测管道兼容性，确保可靠性很重要；</p><p>• 如果中间代理不支持管道，那它可能会中断连接，也可能会把所有请求串联起来。</p><p>由于存在这些以及其他类似的问题，而 HTTP 1.1 标准中也未对此做出说明，HTTP 管道技术的应用非常有限，虽然其优点毋庸置疑。今天，一些支持管道的浏览器，通常都将其作为一个高级配置选项，但大多数浏览器都会禁用它。换句话说，如果浏览器是 Web 应用的主要交付工具，那还是很难指望通过 HTTP 管道来提升性能。</p><div class="code-wrapper"><pre><code class="hljs tap">在浏览器外部使用 HTTP 管道在完全忽略 HTTP 管道的优点之前，有必要提醒一下大家，如果你对客户端和服务器拥有完全控制的权限，那么还是可以使用它的，并且效果非常好。事实上，苹果 iTunes 那个案例就说明了问题，参见本章开头的“让 iTunes 用户感受到<span class="hljs-number"> 3 </span>倍以上的性能增强”。如此巨大的性能提升，就来自启用持久 HTTP 连接，以及在服务器和 iTunes 客户端内启用 HTTP 管道。要在你自己的应用中启用管道，要注意如下事项：• 确保 HTTP 客户端支持管道；• 确保 HTTP 服务器支持管道；• 应用必须处理中断的连接并恢复；• 应用必须处理中断请求的幂等问题；• 应用必须保护自身不受出问题的代理的影响。实践中部署 HTTP 管道的最佳途径，就是在客户端和服务器间使用安全通道（HTTPS）。这样，就能可靠地避免那些不理解或不支持管道的中间代理的干扰。</code></pre></div><h5 id="域名分区"><a href="#域名分区" class="headerlink" title="域名分区"></a>域名分区</h5><p>HTTP 1.x 协议的一项空白强迫浏览器开发商引入并维护着连接池，每个主机最多 6 个 TCP 流。好的一方面是对这些连接的管理工作都由浏览器来处理。作为应用开发者，你根本不必修改自己的应用。不好的一方面呢，就是 6 个并行的连接对你的应用来说可能仍然不够用</p><p>根据 HTTP Archive 的统计，目前平均每个页面都包含 90 多个独立的资源，如果这些资源都来自同一个主机，那么仍然会导致明显的排队等待（图 11-5）。实际上，何必把自己只限制在一个主机上呢？我们不必只通过一个主机（例如 <a href="http://www.example.com）提供所有资源，而是可以手工将所有资源分散到多个子域名：{shard1">www.example.com）提供所有资源，而是可以手工将所有资源分散到多个子域名：{shard1</a>, shardn}.example.com。由于主机名称不一样了，就可以突破浏览器的连接限制，实现更高的并行能力。域名分区使用得越多，并行能力就越强！</p><p>当然，天下没有免费的午餐，域名分区也不例外：每个新主机名都要求有一次额外的 DNS 查询，每多一个套接字都会多消耗两端的一些资源，而更糟糕的是，站点作者必须手工分离这些资源，并分别把它们托管到多个主机上。</p><p>实践中，把多个域名（如 shard1.example.com、shard2.example.com）解析到同一个 IP 地址是很常见的做法。所有分区都通过 CNAME DNS 记录指向同一个服务器，而浏览器连接限制针对的是主机名，不是 IP 地址。另</p><p>外，每个分区也可以指向一个 CDN 或其他可以访问到的服务器。</p><p>怎么计算最优的分区数目呢？这个问题不好回答，因为没有简单的方程式。答案取决于页面中资源的数量（每个页面都可能不一样），以及客户端连接的可用带宽和延迟（因客户端而异）。实际上，我们能做的，就是在调查的基础上做出预测，然后使用固定数量的分区。幸运的话，多这么一点复杂性，还是能给大多数用户带来好处的。</p><p>实践中，域名分区经常会被滥用，导致几十个 TCP 流都得不到充分利用，其中很多永远也避免不了 TCP 慢启动，最坏的情况下还会降低性能。此外，如果使用的是HTTPS，那么由于 TLS 握手导致的额外网络往返，会使得上述代价更高。此时，请大家注意如下几条：</p><p>• 首先，把 TCP 利用好，参见 2.5 节“针对 TCP 的优化建议”；</p><p>• 浏览器会自动为你打开 6 个连接；</p><p>• 资源的数量、大小和响应时间都会影响最优的分区数目；</p><p>• 客户端延迟和带宽会影响最优的分区数目；</p><p>• 域名分区会因为额外的 DNS 查询和 TCP 慢启动而影响性能</p><p>域名分区是一种合理但又不完美的优化手段。请大家一定先从最小分区数目（不分区）开始，然后逐个增加分区并度量分区后对应用的影响。现实当中，真正因同时打开十几个连接而提升性能的站点并不多，如果你最终使用了很多分区，那么你会发现减少资源数量或者将它们合并为更少的请求，反而能带来更大的好处。</p><p>DNS 查询和 TCP 慢启动导致的额外消耗对高延迟客户端的影响最大。换句话说，移动（3G、4G）客户端经常是受过度域名分区影响最大的！</p><h5 id="度量和控制协议开销"><a href="#度量和控制协议开销" class="headerlink" title="度量和控制协议开销"></a>度量和控制协议开销</h5><p>HTTP 0.9 当初就是一个简单的只有一行的 ASCII 请求，用于取得一个超文本文档，这样导致的开销是最小的。HTTP 1.0 增加了请求和响应首部，以便双方能够交换有关请求和响应的元信息。最终，HTTP 1.1 把这种格式变成了标准：服务器和客户端都可以轻松扩展首部，而且始终以纯文本形式发送，以保证与之前 HTTP版本的兼容。</p><p>今天，每个浏览器发起的 HTTP 请求，都会携带额外 500<del>800 字节的 HTTP 元数据：用户代理字符串、很少改变的接收和传输首部、缓存指令，等等。有时候，500</del>800 字节都少说了，因为没有包含最大的一块：HTTP cookie。现代应用经常通过cookie 进行会话管理、记录个性选项或者完成分析。综合到一起，所有这些未经压缩的 HTTP 元数据经常会给每个 HTTP 请求增加几千字节的协议开销。</p><p><strong>RFC 2616（HTTP 1.1）没有对 HTTP 首部的大小规定任何限制。然而，实际中，很多服务器和代理都会将其限制在 8 KB 或 16 KB 之内。</strong></p><p>HTTP 首部的增多对它本身不是坏事，因为大多数首部都有其特定用途。然而，由于所有 HTTP 首部都以纯文本形式发送（不会经过任何压缩），这就会给每个请求附加较高的额外负荷，而这在某些应用中可能造成严重的性能问题。举个例子，API 驱动的 Web 应用越来越多，这些应用需要频繁地以序列化消息（如 JSON）的形式通信。在这些应用中，额外的 HTTP 开销经常会超过实际传输的数据静荷一个数量级：</p><div class="code-wrapper"><pre><code class="hljs awk">$&gt; curl --trace-ascii - -d<span class="hljs-string">&#x27;&#123;&quot;msg&quot;:&quot;hello&quot;&#125;&#x27;</span> http:<span class="hljs-regexp">//</span>www.igvita.com/api== Info: Connected to www.igvita.com=&gt; Send header, <span class="hljs-number">218</span> bytes <span class="hljs-regexp">//</span>➊ HTTP 请求首部：<span class="hljs-number">218</span> 字节POST <span class="hljs-regexp">/api HTTP/</span><span class="hljs-number">1.1</span>User-Agent: curl<span class="hljs-regexp">/7.24.0 (x86_64-apple-darwin12.0) libcurl/</span><span class="hljs-number">7.24</span>.<span class="hljs-number">0</span> ...Host: www.igvita.comAccept: */*Content-Length: <span class="hljs-number">15</span> <span class="hljs-regexp">//</span>➋应用静荷 <span class="hljs-number">15</span> 字节（&#123;<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;）Content-Type: application/x-www-form-urlencoded=&gt; Send data, <span class="hljs-number">15</span> bytes (<span class="hljs-number">0</span>xf)&#123;<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>&#125;&lt;= Recv header, <span class="hljs-number">134</span> bytes <span class="hljs-regexp">//</span>➌服务器的 <span class="hljs-number">204</span> 响应：<span class="hljs-number">134</span> 字节HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">204</span> No ContentServer: nginx/<span class="hljs-number">1.0</span>.<span class="hljs-number">11</span>Via: HTTP/<span class="hljs-number">1.1</span> GWADate: Thu, <span class="hljs-number">20</span> Sep <span class="hljs-number">2012</span> <span class="hljs-number">05</span>:<span class="hljs-number">41</span>:<span class="hljs-number">30</span> GMTCache-Control: max-age=<span class="hljs-number">0</span>, no-cache</code></pre></div><p>在前面的例子中，寥寥 15 个字符的 JSON 消息被 352 字节的 HTTP 首部包裹着，全部以纯文本形式发送——协议字节开销占 96%，而且这还是没有 cookie 的最好情况。减少要传输的首部数据（高度重复且未压缩），可以节省相当于一次往返的延迟时间，显著提升很多 Web 应用的性能。</p><h5 id="连接与拼合"><a href="#连接与拼合" class="headerlink" title="连接与拼合"></a>连接与拼合</h5><p>• 连接</p><p>把多个 JavaScript 或 CSS 文件组合为一个文件。</p><p>• 拼合</p><p>把多张图片组合为一个更大的复合的图片。</p><p>对 JavaScript 和 CSS 来说，只要保持一定的顺序，就可以做到把多个文件连接起来而不影响代码的行为和执行。类似地，多张图片可以组合为一个“图片精灵”，然后使用 CSS 选择这张大图中的适当部分，显示在浏览器中。这两种技术都具备两方面的优点。 </p><p>• 减少协议开销</p><p>通过把文件组合成一个资源，可以消除与文件相关的协议开销。如前所述，每个文件很容易招致 KB 级未压缩数据的开销。</p><p>• 应用层管道</p><p>说到传输的字节，这两种技术的效果都好像是启用了 HTTP 管道：来自多个响应的数据前后相继地连接在一起，消除了额外的网络延迟。实际上，就是把管道提高了一层，置入了应用中。</p><p>连接和拼合技术都属于以内容为中心的应用层优化，它们通过减少网络往返开销，可以获得明显的性能提升。可是，实现这些技术也要求额外的处理、部署和编码（比如选择图片精灵中子图的 CSS 代码），因而也会给应用带来额外的复杂性。此外，把多个资源打包到一块，也可能给缓存带来负担，影响页面的执行速度。</p><p>要理解为什么这些技术会伤害性能，可以考虑一种并不少见的情况：一个包含十来个 JavaScript 和 CSS 文件的应用，在产品状态下把所有文件合并为一个 CSS 文件和一个 JavaScript 文件。</p><p>• 相同类型的资源都位于一个 URL（缓存键）下面。</p><p>• 资源包中可能包含当前页面不需要的内容。</p><p>• 对资源包中任何文件的更新，都要求重新下载整个资源包，导致较高的字节开销。</p><p>• JavaScript 和 CSS 只有在传输完成后才能被解析和执行，因而会拖慢应用的执行速度。</p><p>实践中，大多数 Web 应用都不是只有一个页面，而是由多个视图构成。每个视图都有自己的资源，同时资源之间还有部分重叠：公用的 CSS、JavaScript 和图片。实际上，把所有资源都组合到一个文件经常会导致处理和加载不必要的字节。虽然可以把它看成一种预获取，但代价则是降低了初始启动的速度。</p><p>对很多应用来说，更新资源带来的问题更大。更新图片精灵或组合 JavaScript 文件中的某一处，可能就会导致重新传输几百 KB 数据。由于牺牲了模块化和缓存粒度，假如打包资源变动频率过高，特别是在资源包过大的情况下，很快就会得不偿失。如果你的应用真到了这种境地，那么可以考虑把“稳定的核心”，比如框架和库，转移到独立的包中。</p><p>内存占用也会成为问题。对图片精灵来说，浏览器必须分析整个图片，即便实际上只显示了其中的一小块，也要始终把整个图片都保存在内存中。浏览器是不会把不显示的部分从内存中剔除掉的！</p><div class="code-wrapper"><pre><code class="hljs tap">计算图片对内存的需求所有编码的图片经浏览器解析后都会以 RGBA 位图的形式保存于内存当中。每个RGBA 图片的像素需要占用<span class="hljs-number"> 4 </span>字节：红、绿、蓝通道各占<span class="hljs-number"> 1 </span>字节，Alpha（透明）通道占<span class="hljs-number"> 1 </span>字节。这样算下来，一张图片占用的内存量就是图片像素宽度 × 像素高度 ×4 字节。举个例子，800×600 像素的位图会占多大内存呢？800 ×<span class="hljs-number"> 600 </span>×<span class="hljs-number"> 4 </span>B =<span class="hljs-number"> 1 </span>920<span class="hljs-number"> 000 </span>B ≈ 1.83 MB 在资源受限的设备，比如手机上，内存占用很快就会成为瓶颈。对于游戏等严重依赖图片的应用来说，这个问题就会更明显。</code></pre></div><p>最后，为什么执行速度还会受影响呢？我们知道，浏览器是以递增方式处理HTML 的，而对于 JavaScript 和 CSS 的解析及执行，则要等到整个文件下载完毕。JavaScript 和 CSS 处理器都不允许递增式执行。</p><p><strong>CSS 和 JavaScript 文件大小与执行性能</strong></p><p>CSS 文件越大，浏览器在构建 CSSOM 前经历的阻塞时间就越长，从而推迟首次绘制页面的时间。类似地，JavaScript 文件越大，对执行速度的影响同样越大；小文件倒是能实现“递增式”执行。打包文件到底多大合适呢？可惜的是，没有理想的大小。然而，谷歌 PageSpeed</p><p>团队的测试表明，30~50 KB（压缩后）是每个 JavaScript 文件大小的合适范围：既大到了能够减少小文件带来的网络延迟，还能确保递增及分层式的执行。具体的结果可能会由于应用类型和脚本数量而有所不同。</p><p>总之，连接和拼合是在 HTTP 1.x 协议限制（管道没有得到普遍支持，多请求开销大）的现实之下可行的应用层优化。使用得当的话，这两种技术可以带来明显的性能提升，代价则是增加应用的复杂度，以及导致缓存、更新、执行速度，甚至渲染页面的问题。应用这两种优化时，要注意度量结果，根据实际情况考虑如下问题。</p><p>• 你的应用在下载很多小型的资源时是否会被阻塞？</p><p>• 有选择地组合一些请求对你的应用有没有好处？</p><p>• 放弃缓存粒度对用户有没有负面影响？</p><p>• 组合图片是否会占用过多内存？</p><p>• 首次渲染时是否会遭遇延迟执行？</p><p>在上述问题的答案间求得平衡是一种艺术</p><p><strong>优化 Gmail 性能</strong></p><p>Gmail 使用了大量 JavaScript，而且也不断拓展了现代浏览器的性能边界。要提升首次加载性能，Gmail 团队尝试了各种技术，目前包括如下这些：</p><p>• 把首次绘制所需的 CSS 单独拿出来，优先于其他 CSS 文件发送；</p><p>• 递增地交付较小的 JavaScript 块，以实现递增式执行；</p><p>• 使用定制的外部更新机制，即客户端在后台下载新的 JavaScript 文件，然后在页面刷新时更新。</p><p>鉴于 Gmail 如此庞大的用户数量，如果所有打开的浏览器都要更新脚本，那哪怕一次简单的 JavaScript 更新，都可能演变为一次自残式的 DoS 攻击。为此，Gmail会在用户使用旧版本页面时，在后台预先加载更新文件，这样既可以分散负荷，又能提升下一次刷新时的速度。这个过程每天都重复不止一次。在此基础上，为了让用户感觉第一次加载的速度很快，Gmail 团队还在 HTML 文档中嵌入了关键性 CSS 和 JavaScript，然后以块的形式递增加载其余 JavaScript 文件，以加快脚本执行——第一次打开 Gmail 时显示的进度条，反映的就是这个过程！</p><h5 id="嵌入资源"><a href="#嵌入资源" class="headerlink" title="嵌入资源"></a>嵌入资源</h5><p>嵌入资源是另一种非常流行的优化方法，把资源嵌入文档可以减少请求的次数。比如，JavaScript 和 CSS 代码，通过适当的 script 和 style 块可以直接放在页面中，而图片甚至音频或 PDF 文件，都可以通过数据 URI（data:[mediatype][;base64],data）的方式嵌入到页面中：</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAA</span><span class="hljs-string"> AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw==&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;1x1 transparent (GIF) pixel&quot;</span> /&gt;</code></pre></div><p>前面的例子是在文档中嵌入了一个 1×1 的透明 GIF 像素。而任何 MIME类型，只要浏览器能理解，都可以通过类似方式嵌入到页面中，包括PDF、音频、视频。不过，有些浏览器会限制数据 URI 的大小，比如 IE8最大只允许 32 KB。</p><p>数据 URI 适合特别小的，理想情况下，最好是只用一次的资源。以嵌入方式放到页面中的资源，应该算是页面的一部分，不能被浏览器、CDN 或其他缓存代理作为单独的资源缓存。换句话说，如果在多个页面中都嵌入同样的资源，那么这个资源将会随着每个页面的加载而被加载，从而增大每个页面的总体大小。另外，如果嵌入资源被更新，那么所有以前出现过它的页面都将被宣告无效，而由客户端重新从服务器获取。</p><p>最后，虽然 CSS 和 JavaScript 等基于文本的资源很容易直接嵌入页面，也不会带来多余的开销，但非文本性资源则必须通过 base64 编码，而这会导致开销明显增大：编码后的资源大小比原大小增大 33% ！</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">base64</span> 编码使用 <span class="hljs-number">64</span> 个 ASCII 符号和空白符将任意字节流编码为 ASCII字符串。编码过程中，base64 会导致被编码的流变成原来的 <span class="hljs-number">4</span>/<span class="hljs-number">3</span>，即增大<span class="hljs-number">33</span>% 的字节开销</code></pre></div><p>实践中，常见的一个经验规则是只考虑嵌入 1~2 KB 以下的资源，因为小于这个标准的资源经常会导致比它自身更高的 HTTP 开销。然而，如果嵌入的资源频繁变更，又会导致宿主文档的无效缓存率升高。嵌入资源也不是完美的方法。如果你的应用要使用很小的、个别的文件，在考虑是否嵌入时，可以参照如下建议：</p><p>• 如果文件很小，而且只有个别页面使用，可以考虑嵌入；</p><p>• 如果文件很小，但需要在多个页面中重用，应该考虑集中打包；</p><p>• 如果小文件经常需要更新，就不要嵌入了；</p><p>• 通过减少 HTTP cookie 的大小将协议开销最小化。</p><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a><strong>HTTP 2.0</strong></h4><p>HTTP 2.0 的目的就是通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。为达成这些目标，HTTP 2.0 还会给我们带来大量其他协议层面的辅助实现，比如新的流量控制、错误处理和更新机制。上述几种机制虽然不是全部，但却是最重要的，所有 Web 开发者都应该理解并在自己的应用中利用它们。</p><p>HTTP 2.0 不会改动 HTTP 的语义。HTTP 方法、状态码、URI 及首部字段，等等这些核心概念一如往常。但是，HTTP 2.0 修改了格式化数据（分帧）的方式，以及客户端与服务器间传输这些数据的方式。这两点统帅全局，通过新的组帧机制向我们的应用隐藏了所有复杂性。换句话说，所有原来的应用都可以不必修改而在新协议运行。这当然是好事。</p><p>可是，我们关心的不止是交付能用的应用，我们目标是交付最佳性能！ HTTP 2.0为我们的应用提供了很多新的优化机制，这些机制是前所未有的，而我们的工作就是把它们都利用好。下面我们就来详细介绍一下这些机制。</p><h5 id="历史及其与SPDY的渊源"><a href="#历史及其与SPDY的渊源" class="headerlink" title="历史及其与SPDY的渊源"></a>历史及其与SPDY的渊源</h5><p>SPDY 是谷歌开发的一个实验性协议，于 2009 年年中发布，其主要目标是通过解决HTTP 1.1 中广为人知的一些性能限制，来减少网页的加载延迟。大致上，这个项目设定的目标如下：</p><p>• 页面加载时间（PLT，Page Load Time）降低 50%； </p><p>• 无需网站作者修改任何内容；</p><p>• 把部署复杂性降至最低，无需变更网络基础设施；</p><p>• 与开源社区合作开发这个新协议；</p><p>• 收集真实性能数据，验证这个实验性协议是否有效。</p><p>为了达到降低 50% 页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现多向请求和响应、优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接；参见 10.3.2 节“延迟是性能瓶颈”。</p><h5 id="走向HTTP-2-0"><a href="#走向HTTP-2-0" class="headerlink" title="走向HTTP 2.0"></a>走向HTTP 2.0</h5><p>SPDY 是 HTTP 2.0 的催化剂，但 SPDY 并非 HTTP 2.0。2012 年初，W3C 向社会征集 HTTP 2.0 的建议，HTTP-WG 经过内部讨论，决定将 SPDY 规范作为制定标准的基础。从那时起，SPDY 已经经过了很多变化和改进，而且在 HTTP 2.0 官方标准公布之前，还将有很多变化和改进。</p><p>在此，有必要回顾一下 HTTP 2.0 宣言草稿，因为这份宣言明确了该协议的范围和关键设计要求：</p><p>HTTP/2.0 应该满足如下条件：</p><p>• 相对于使用 TCP 的 HTTP 1.1，用户在大多数情况下的感知延迟要有实质上、可度量的改进；</p><p>• 解决 HTTP 中的“队首阻塞”问题；</p><p>• 并行操作无需与服务器建立多个连接，从而改进 TCP 的利用率，特别是拥塞控制方面；</p><p>• 保持 HTTP 1.1 的语义，利用现有文档，包括（但不限于）HTTP 方法、状态码、URI，以及首部字段；</p><p>• 明确规定 HTTP 2.0 如何与 HTTP 1.x 互操作，特别是在中间介质上；</p><p>• 明确指出所有新的可扩展机制以及适当的扩展策略。</p><p>对现有的 HTTP 部署——特别是 Web 浏览器（桌面及移动）、非浏览器（“HTTP API”）、Web 服务（各种规模），以及中间介质（代理、公司防火墙、“反向”代理及 CDN）而言，最终规范应该满足上述这些目标。类似地，当前和未来对 HTTP/1.x 的语义扩展（如首部、方法、状态码、缓存指令）也应该得到新协议的支持。</p><p>​                                                                                                                                                                             ——HTTPbis WG 宣言 HTTP 2.0 </p><p>简言之，HTTP 2.0 致力于突破上一代标准众所周知的性能限制，但它也是对之前1.x 标准的扩展，而非替代。HTTP 的语义不变，提供的功能不变，HTTP 方法、状态码、URI 和首部字段，等等这些核心概念也不变；这些方面的变化都不在考虑之列。既然如此，那“2.0”还名副其实吗？</p><p>之所以要递增一个大版本到 2.0，主要是因为它改变了客户端与服务器之间交换数据的方式。为实现宏伟的性能改进目标，HTTP 2.0 增加了新的二进制分帧数据层，而这一层并不兼容之前的 HTTP 1.x 服务器及客户端——是谓 2.0。</p><p>HTTP/2.0 通过支持首部字段压缩和在同一连接上发送多个并发消息，让应用更有效地利用网络资源，减少感知的延迟时间。而且，它还支持服务器到客户端的主动推送机制。</p><h6 id="二进制分帧层-1"><a href="#二进制分帧层-1" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h6><p>HTTP 2.0 性能增强的核心，全在于新增的二进制分帧层（图 12-1），它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。</p><p>这里所谓的“层”，指的是位于套接字接口与应用可见的高层 HTTP API 之间的一个新机制：HTTP 的语义，包括各种动词、方法、首部，都不受影响，不同的是传输期间对它们的编码方式变了。HTTP 1.x 以换行符作为纯文本的分隔符，而 HTTP 2.0 将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。</p><p>这样一来，客户端和服务器为了相互理解，必须都使用新的二进制编码机制：HTTP 1.x 客户端无法理解只支持 HTTP 2.0 的服务器，反之亦然。不过不要紧，现有的应用不必担心这些变化，因为客户端和服务器会替它们完成必要的分帧工作。</p><p>HTTPS 是二进制分帧的另一个典型示例：所有 HTTP 消息都以透明的方式为我们编码和解码（参见 4.6 节“TLS 记录协议”），从而实现客户端与服务器安全通信，但不必对应用进行任何修改。HTTP 2.0 的工作原理差不多也是这样。</p><h6 id="流、消息和帧"><a href="#流、消息和帧" class="headerlink" title="流、消息和帧"></a>流、消息和帧</h6><p>新的二进制分帧机制改变了客户端与服务器之间交互数据的方式（图 12-2）。为了说明这个过程，我们需要了解 HTTP 2.0 的两个新概念。</p><p>• 流</p><p>已建立的连接上的双向字节流。</p><p>• 消息</p><p>与逻辑消息对应的完整的一系列数据帧。</p><p>• 帧</p><p>HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。</p><p>所有 HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。</p><p>HTTP 2.0 的所有帧都采用二进制编码，所有首部数据都会被压缩。因此，图 12-2 只是说明了数据流、消息和帧之间的关系，而非它们实际传输时的编码结果。要了解实际编码结果，请参考 12.4 节“二进制分帧简介”。</p><p>• 所有通信都在一个 TCP 连接上完成。</p><p>• 流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…<em>N</em>）。</p><p>• 消息是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。</p><p>• 帧是最小的通信单位，承载着特定类型的数据，如 HTTP 首部、负荷，等等。</p><p>简言之，HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。相应地，很多流可以并行地在同一个 TCP 连接上交换消息。</p><h6 id="多向请求与响应"><a href="#多向请求与响应" class="headerlink" title="多向请求与响应"></a>多向请求与响应</h6><p>在 HTTP 1.x 中，如果客户端想发送多个并行的请求以及改进性能，那么必须使用多个 TCP 连接（参见 11.3 节“使用多个 TCP 连接”）。这是 HTTP 1.x 交付模型的直接结果，该模型会保证每个连接每次只交付一个响应（多个响应必须排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。</p><p>HTTP 2.0 中新的二进制分帧层突破了这些限制，实现了多向请求和响应：客户端和服务器可以把 HTTP 消息分解为互不依赖的帧（图 12-3），然后乱序发送，最后再在另一端把它们重新组合起来。</p><p>把 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2.0 最重要的一项增强。事实上，这个机制会在整个 Web 技术栈中引发一系列连锁反应，从而带来巨大的性能提升，因为：</p><p>• 可以并行交错地发送请求，请求之间互不影响；</p><p>• 可以并行交错地发送响应，响应之间互不干扰；</p><p>• 只使用一个连接即可并行发送多个请求和响应；</p><p>• 消除不必要的延迟，从而减少页面加载的时间；</p><p>• 不必再为绕过 HTTP 1.x 限制而多做很多工作；</p><p>• 更多优势。</p><p>总之，HTTP 2.0 的二进制分帧机制解决了 HTTP 1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果，就是应用速度更快、开发更简单、部署成本更低。</p><p>支持多向请求与响应，可以省掉针对 HTTP 1.x 限制所费的那些脑筋和工作，比如拼接文件、图片精灵、域名分区（参见 13.2 节“针对 HTTP 1.x的优化建议”）。类似地，通过减少 TCP 连接的数量，HTTP 2.0 也会减少客户端和服务器的 CPU 及内存占用。</p><h6 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h6><p>把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，进一步提升性能。为了做到这一点，每个流都可以带有一个 31 比特的优先值：</p><p>• 0 表示最高优先级；</p><p>• 2^31-1 表示最低优先级。</p><p>有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。具体来讲，服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端</p><p><strong>浏览器请求优先级与 HTTP 2.0</strong></p><p>浏览器在渲染页面时，并非所有资源都具有相同的优先级：HTML 文档本身对构建 DOM 不可或缺，CSS 对构建 CSSOM 不可或缺，而 DOM 和 CSSOM 的构建都可能受到 JavaScript 资源的阻塞（参见 10.1 节的附注栏“DOM、CSSOM 和JavaScript”），其他资源（如图片）的优先级都可以降低。为加快页面加载速度，所有现代浏览器都会基于资源的类型以及它在页面中的位置排定请求的优先次序，甚至通过之前的访问来学习优先级模式——比如，之前的渲染如果被某些资源阻塞了，那么同样的资源在下一次访问时可能就会被赋予更高的优先级。在 HTTP 1.x 中，浏览器极少能利用上述优先级信息，因为协议本身并不支持多路复用，也没有办法向服务器通告请求的优先级。此时，浏览器只能依赖并行连接，且最多只能同时向一个域名发送 6 个请求。于是，在等连接可用期间，请求只能在客户端排队，从而增加了不必要的网络延迟。理论上，HTTP 管道可以解决这个问题，只是由于缺乏支持而无法付诸实践。HTTP 2.0 一举解决了所有这些低效的问题：浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。</p><p>HTTP 2.0 没有规定处理优先级的具体算法，只是提供了一种赋予数据优先级的机制，而且要求客户端与服务器必须能够交换这些数据。这样一来，优先值作为提示信息，对应的次序排定策略可能因客户端或服务器的实现而不同：客户端应该明确指定优先值，服务器应该根据该值处理和交付数据。在这个规定之下，尽管你可能无法控制客户端发送的优先值，但或许你可以控制服务器。因此，在选择 HTTP 2.0 服务器时，可以多留点心！为说明这一点，考虑下面几个问题</p><p>• 如果服务器对所有优先值视而不见怎么办？</p><p>• 高优先值的流一定优先处理吗？</p><p>• 是否存在不同优先级的流应该交错的情况？</p><p>如果服务器不理睬所有优先值，那么可能会导致应用响应变慢：浏览器明明在等关键的 CSS 和 JavaScript，服务器却在发送图片，从而造成渲染阻塞。不过，规定严格的优先级次序也可能带来次优的结果，因为这可能又会引入队首阻塞问题，即某个高优先级的慢请求会不必要地阻塞其他资源的交付。</p><p>服务器可以而且应该交错发送不同优先级别的帧。只要可能，高优先级流都应该先，包括分配处理资源和客户端与服务器间的带宽。不过，为了最高效地利用底层连接，不同优先级的混合也是必需的。</p><h6 id="每个来源一个连接"><a href="#每个来源一个连接" class="headerlink" title="每个来源一个连接"></a>每个来源一个连接</h6><p>有了新的分帧机制后，HTTP 2.0 不再依赖多个 TCP 连接去实现多流并行了。现在，每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别优先级。于是，所有HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。</p><p>实验表明，客户端使用更少的连接肯定可以降低延迟时间。HTTP 2.0 发送的总分组数量比 HTTP 差不多要少 40%。而服务器处理大量并发连接的情况也变成了可伸缩性问题，因为 HTTP 2.0 减轻了这个负担</p><p>每个来源一个连接显著减少了相关的资源占用：连接路径上的套接字管理工作量少了，内存占用少了，连接吞吐量大了。此外，从上到下所有层面上也都获得了相应的好处：</p><p>• 所有数据流的优先次序始终如一；</p><p>• 压缩上下文单一使得压缩效果更好；</p><p>• 由于 TCP 连接减少而使网络拥塞状况得以改观；</p><p>• 慢启动时间减少，拥塞和丢包恢复速度更快。</p><p>大多数 HTTP 连接的时间都很短，而且是突发性的，但 TCP 只在长时间连接传输大块数据时效率才最高。HTTP 2.0 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接。</p><p>HTTP 2.0 不仅能够减少网络延迟，还有助于提高吞吐量和降低运营成本！</p><p><strong>丢包、高 RTT 连接和 HTTP 2.0 性能</strong></p><p>• 虽然消除了 HTTP 队首阻塞现象，但 TCP 层次上仍然存在队首阻塞（参见 2.4节“队首阻塞”）；</p><p>• 如果 TCP 窗口缩放被禁用，那带宽延迟积效应可能会限制连接的吞吐量；</p><p>• 丢包时，TCP 拥塞窗口会缩小（参见 2.2.3 节“拥塞预防”）。</p><p>上述每一点都可能对 HTTP 2.0 连接的吞吐量和延迟性能造成不利影响。然而，除了这些局限性之外，实验表明一个 TCP 连接仍然是 HTTP 2.0 基础上的最佳部署策略：</p><p>目前为止的测试表明，压缩和优先级排定带来的性能提升，已经超过了</p><p>队首阻塞（特别是丢包情况下）造成的负面效果。</p><p>与所有性能优化过程一样，去掉一个性能瓶颈，又会带来新的瓶颈。对 HTTP 2.0 而言，TCP 很可能就是下一个性能瓶颈。这也是为什么服务器端 TCP 配置对HTTP 2.0 至关重要的一个原因。</p><p>目前，针对 TCP 性能优化的研究还在进行中：TCP 快速打开、比例降速、增大的初始拥塞窗口，等等不一而足。总之，一定要知道 HTTP 2.0 与之前的版本一样，并不强制使用 TCP。UDP 等其他传输协议也并非不可以。</p><h6 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h6><p>在同一个 TCP 连接上传输多个数据流，就意味着要共享带宽。标定数据流的优先级有助于按序交付，但只有优先级还不足以确定多个数据流或多个连接间的资源分配。为解决这个问题，HTTP 2.0 为数据流和连接的流量控制提供了一个简单的机制：</p><p>流量控制基于每一跳进行，而非端到端的控制；</p><p>• 流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及对整个连接要接收多少字节；</p><p>• 流量控制窗口大小通过 WINDOW_UPDATE 帧更新，这个字段指定了流 ID 和窗口大小递增值；</p><p>• 流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个连接设置任意窗口大小；</p><p>• 流量控制可以由接收方禁用，包括针对个别的流和针对整个连接。</p><p>HTTP 2.0 连接建立之后，客户端与服务器交换 SETTINGS 帧，目的是设置双向的流量控制窗口大小。除此之外，任何一端都可以选择禁用个别流或整个连接的流量控制。</p><p>上面这个列表是不是让你想起了 TCP 流量控制？应该是，这两个机制实际上是一样的，参见 2.2.1 节“流量控制”。然而，由于 TCP 流量控制不能对同一条 HTTP 2.0连接内的多个流实施差异化策略，因此光有它自己是不够的。这正是 HTTP 2.0 流量控制机制出台的原因。</p><p>HTTP 2.0 标准没有规定任何特定的算法、值，或者什么时候发送 WINDOW_UPDATE 帧。因此，实现可以选择自己的算法以匹配自己的应用场景，从而求得最佳性能。</p><p>优先级可以决定交付次序，而流量控制则可以控制 HTTP 2.0 连接中每个流占用的资源：接收方可以针对特定的流广播较低的窗口大小，以限制它的传输速度。</p><h6 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h6><p>HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源（图 12-4），而无需客户端明确地请求。</p><p>建立 HTTP 2.0 连接后，客户端与服务器交换 SETTINGS 帧，借此可以限定双向并发的流的最大数量。因此，客户端可以限定推送流的数量，或者通过把这个值设置为 0 而完全禁用服务器推送。</p><p>为什么需要这样一个机制呢？通常的 Web 应用都由几十个资源组成，客户端需要分析服务器提供的文档才能逐个找到它们。那为什么不让服务器提前就把这些资源推送给客户端，从而减少额外的时间延迟呢？服务器已经知道客户端下一步要请求什么资源了，这时候服务器推送即可派上用场。事实上，如果你在网页里嵌入过 CSS、JavaScript，或者通过数据 URI 嵌入过其他资源（参见 11.7 节“嵌入资源”），那你就已经亲身体验过服务器推送了</p><p>把资源直接插入到文档中，就是把资源直接推送给客户端，而无需客户端请求。在HTTP 2.0 中，唯一的不同就是可以把这个过程从应用中拿出来，放到 HTTP 协议本身来实现，而且还带来了如下好处：</p><p>• 客户端可以缓存推送过来的资源；</p><p>• 客户端可以拒绝推送过来的资源；</p><p>• 推送资源可以由不同的页面共享；</p><p>• 服务器可以按照优先级推送资源。</p><p>所有推送的资源都遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p><p>有了服务器推送后，HTTP 1.x 时代的大多数插入或嵌入资源的做法基本上也就过时了。唯一有必要直接在网页中插入资源的情况，就是该资源只供那一个网页使用，而且编码代价不大；此处仍然可以参考 11.7 节“嵌入资源”。除此之外，所有应用都应该使用 HTTP 2.0 服务器推送。</p><p><strong>PUSH_PROMISE</strong></p><p>所有服务器推送流都由 PUSH_PROMISE 发端，它是除了对原始请求的响应之外，服务器向客户端发出的有意推送所述资源的信号。PUSH_PROMISE 帧中只包含要约（promise）资源的 HTTP 首部。</p><p>客户端接收到 PUSH_PROMISE 帧之后，可以视自身需求选择拒绝这个流（比如，已经缓存了相应资源），而这是对 HTTP 1.x 的一个重要改进。嵌入资源作为针对HTTP 1.x 的一种流行“优化技巧”，实际上无异于“强制推送”：客户端无法取消</p><p>这种“推送”，而且也不能个别地缓存嵌入的资源。最后再说一说服务器推送的几点限制。首先，服务器必须遵循请求 - 响应的循环，只能借着对请求的响应推送资源。也就是说，服务器不能随意发起推送流。其次，PUSH_PROMISE 帧必须在返回响应之前发送，以免客户端出现竞态条件。否则，就可能出现比如这种情况：客户端请求的恰好是服务器打算推送的资源。</p><p><strong>实现HTTP 2.0服务器推送</strong></p><p>服务器推送为优化应用的资源交付提供了很多可能。然而，服务器到底如何确定哪些资源可以或应该推送呢？与确定优先级类似，HTTP 2.0 标准也没有就此规定某种算法，所以实现者就拥有了解释权。自然地，也就有可能出现多种策略，每种策略可能会考虑一种应用或服务器使用场景。</p><p>• 应用可以在自身的代码中明确发起服务器推送。这种情况要求与 HTTP 2.0 紧密耦合，但开发人员有控制权。</p><p>• 应用可以通过额外的 HTTP 首部向服务器发送信号，列出它希望推送的资源。这样可以将应用与 HTTP 服务器 API 分离。比如 Apache 的 mod_spdy 能够识别X-Associated-Content 首部，这个首部中列出了希望服务器推送的资源。</p><p>• 服务器可以不依赖应用而自动学习相关资源。服务器可以解析文档，推断出要推送的资源，或者可以分析流量，然后作出适当的决定。比如服务器可以根据Referer 首部收集依赖数据，然后自动向客户端推送关键资源。</p><p>当然，以上只是各种可能策略中的几个，但由此也可以知道可能性是很多的：可能是手工调用低级 API，也可能是一种全自动的实现。类似地，服务器应不应该重复推送相同的资源，还是应该实现一个更智能的策略？服务器可以根据自身的模型、客户端 cookie 或其他机制，智能推断出客户端缓存中有什么资源，然后再作出推送决定。简言之，服务器推送领域将爆出各种创新。</p><p>最后还有一点，就是推送的资源将直接进入客户端缓存，就像客户端请求了似的。不存在客户端 API 或 JavaScript 回调方法等通知机制，可以用于确定资源何时到达。整个过程对运行在浏览器中的 Web 应用来说好像根本不存在。</p><h6 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h6><p>HTTP 的每一次通信都会携带一组首部，用于描述传输的资源及其属性。在 HTTP 1.x 中，这些元数据都是以纯文本形式发送的，通常会给每个请求增加 500~800 字节的负荷。如果算上 HTTP cookie，增加的负荷通常会达到上千字节（参见 11.5 节“度量和控制协议开销”）。为减少这些开销并提升性能，HTTP 2.0 会压缩首部元数据：</p><p>• HTTP 2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</p><p>• 首部表在HTTP 2.0的连接存续期内始终存在，由客户端和服务器共同渐进地更新; </p><p>• 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</p><p>通信期间几乎不会改变的通用键－值对（用户代理、可接受的媒体类型，等等）只需发送一次。事实上，如果请求中不包含首部（例如对同一资源的轮询请求），那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部！</p><p><strong>SPDY、CRIME 和 HTTP 2.0 压缩</strong></p><p>SPDY 的早期版本使用 zlib 和自定义的字典压缩所有 HTTP 首部，可以减少85%<del>88% 的首部开销，从而显著减少加载页面的时间：在低速 DSL 连接中，上传速度只有 375 Kbit/s，仅压缩请求首部，即可显著减少某些（需要发送大量资源请求的）站点的页面加载时间。我们发现压缩首部可以节省 45</del>1142 ms 的页面加载时间。</p><p>​                                                                                                                                                                            ——SPDY 白皮书，chromium.org</p><p>然而，2012 年夏天，出现了针对 TLS 和 SPDY 压缩算法的“CRIME”安全攻击，它可以利用首部压缩拦截会话。于是，zlib 压缩算法被撤销，取而代之的是前面介绍的新索引表算法。索引表算法没有类似的安全问题，但可以实现相差无几的性能提升。要全面了解 HTTP 2.0 压缩算法，请看这里：<a href="http://tools.ietf.org/html/draft-ietf-httpbisheader-compression%E3%80%82">http://tools.ietf.org/html/draft-ietf-httpbisheader-compression。</a></p><h5 id="二进制分帧简介"><a href="#二进制分帧简介" class="headerlink" title="二进制分帧简介"></a>二进制分帧简介</h5><p>HTTP 2.0 的根本改进还是新增的长度前置的二进制分帧层。与 HTTP 1.x 使用换行符分隔纯文本不同，二进制分帧层更加简洁，通过代码处理起来更简单也更有效。建立了 HTTP 2.0 连接后，客户端与服务器会通过交换帧来通信，帧是基于这个新协议通信的最小单位。所有帧都共享一个 8 字节的首部（图 12-6），其中包含帧的长度、类型、标志，还有一个保留位和一个 31 位的流标识符。</p><p>• 16 位的长度前缀意味着一帧大约可以携带 64 KB 数据，不包括 8 字节首部。</p><p>• 8 位的类型字段决定如何解释帧其余部分的内容。</p><p>• 8 位的标志字段允许不同的帧类型定义特定于帧的消息标志。</p><p>• 1 位的保留字段始终置为 0。 </p><p>• 31 位的流标识符唯一标识 HTTP 2.0 的流。</p><p>知道了帧类型，解析器就知道该如何解释帧的其余内容了。HTTP 2.0 规定了如下帧类型。</p><p>• DATA：用于传输 HTTP 消息体。</p><p>• HEADERS：用于传输关于流的额外的首部字段。</p><p>• PRIORITY：用于指定或重新指定引用资源的优先级。</p><p>• RST_STREAM：用于通知流的非正常终止。</p><p>• SETTINGS：用于通知两端通信方式的配置数据。</p><p>• PUSH_PROMISE：用于发出创建流和服务器引用资源的要约。</p><p>• PING：用于计算往返时间，执行“活性”检查。</p><p>• GOAWAY：用于通知对端停止在当前连接中创建流。</p><p>• WINDOW_UPDATE：用于针对个别流或个别连接实现流量控制。</p><p>• CONTINUATION：用于继续一系列首部块片段。</p><p>服务器可以利用 GOAWAY 类型的帧告诉客户端要处理的最后一个流的 ID，从而消除一些请求竞争，而且浏览器也可以据此智能地重试或取消“悬着的”请求。这也是保证复用连接安全的一个重要和必要的功能！</p><p>前述各种类型帧的具体实现在很大程度上取决于服务器和客户端开发商，他们需要考虑流量控制、错误处理、连接终止等细节。好在，所有这些内容在官方标准中都有论述。好奇的话，可以查阅一下最新的草案。既然有了这个分帧层，即使它对我们的应用不可见，我们也应该更进一步，分析一下两种最常见的工作流：发起新流和交换应用数据。只有明白了一个请求或响应如何转换成一个一个的帧，才能理解 HTTP 2.0 对性能的提升来自哪里。</p><p>固定长度与可变长度字段</p><p>HTTP 2.0 只使用固定长度字段，HTTP 2.0 帧占用带宽很少（帧首部是 8 字节）。采用可变长度编码的确可以节省一点带宽和时延，但却无法抵偿由此带来的分析复杂性。即使可变长度编码能减少 50% 的带宽占用，那么在 1 Mbit/s 的连接上传输 1400 字节的分组，也只能节省 4 字节（0.3%）和每帧不到 100 纳秒的延迟时间。</p><p>• 客户端通过发送 HEADERS 帧来发起新流（图 12-7），这个帧里包含带有新流 ID 的公用首部、可选的 31 位优先值，以及一组 HTTP 键－值对首部；</p><p>• 服务器通过发送 PUSH_PROMISE 帧来发起推送流，这个帧与 HEADERS 帧等效，但它包含“要约流 ID”，没有优先值。</p><p>这两种帧的类型字段都只用于沟通新流的元数据，净荷会在 DATA 帧中单独发送。同样，由于两端都可以发起新流，流计数器偏置：客户端发起的流具有偶数 ID，服务器发起的流具有奇数 ID。这样，两端的流 ID 不会冲突，而且各自持有一个简单的计数器，每次发起新流时递增 ID 即可。由于流的元数据与应用数据是单独发送的，因此客户端和服务器可以分别给它们设定不同的优先级。比如，“控制流量”的流优先级可以高一些，但只将其应用给 DATA 帧。</p><h6 id="发送应用数据"><a href="#发送应用数据" class="headerlink" title="发送应用数据"></a>发送应用数据</h6><p>创建新流并发送 HTTP 首部之后，接下来就是利用 DATA 帧（图 12-8）发送应用数据。应用数据可以分为多个 DATA 帧，最后一帧要翻转帧首部的 END_STREAM 字段。</p><p>数据净荷不会被另行编码或压缩。编码方式取决于应用或服务器，纯文本、gzip 压缩、图片或视频压缩格式都可以。既然如此，关于 DATA 帧再也没有什么新东西好说了！整个帧由公用的 8 字节首部，后跟 HTTP 净荷组成。</p><p>从技术上说，DATA 帧的长度字段决定了每帧的数据净荷最多可达 216-1 （65 535）字节。可是，为减少队首阻塞，HTTP 2.0 标准要求 DATA 帧不能超过 214-1（16 383）字节。长度超过这个阀值的数据，就得分帧发送。</p><h4 id="优化应用的交付"><a href="#优化应用的交付" class="headerlink" title="优化应用的交付"></a>优化应用的交付</h4><p>我们无法控制客户端与服务器之间的网络环境，也不能控制客户的硬件或者其手持设备的配置，但除此之外的一切就掌握在我们手里了，包括服务器上的 TCP 和 TLS优化，以及针对不同物理层特性、不同 HTTP 协议版本和通用最佳实践的数十项应用优化。没错，要做到滴水不漏绝非易事，但这样做绝对值得！好，下面我们就来作一番综述。</p><p>通信信道的物理属性对所有应用而言都是一项硬性限制：光速及客户端与服务器之间的距离决定了信号传播的延迟，而媒介（有线或无线）决定了由每个数据分组带来的处理、传输、排队及其他延迟。事实上，影响绝大多数 Web 应用性能的并非带宽，而是延迟。网速虽然越来越快，但不幸的是，延迟似乎并没有缩短：</p><p>既然我们不能让信息跑得更快，那么关键就在于对传输层和应用层采取各种可能的优化手段，消除不必要的往返、请求，把每个分组的传输距离缩到最短——比如把服务器放到离客户更近的地方。</p><p>针对无线网络物理层的特有属性采取优化措施可以让任何应用受益，因为无线环境的延迟高且带宽总是那么贵。对 API 而言，有线与无线网络之间的差别特别明显，对此视而不见可不明智。只要对何时以及如何下载资源、信标进行简单的优化，就能显著改善用户感觉到的延迟、电池使用时间和应用的整体用户体验：</p><p>自物理层向上，接下来就是要保证任何一台服务器都要按照最新的 TCP 和 TLS 最佳实践进行配置。针对底层协议的优化能保证每个客户端在与服务器通信时，都可以获取最佳性能——高吞吐量和低延迟：</p><p>最后，就是应用层。无论从哪个角度讲，HTTP 都是出奇成功的一个协议。毕竟，它是数十亿客户端与服务器交流的“通用语言”，没有它就没有现代 Web（万维网）。可是，HTTP 也是一个不完美的协议，这就意味着我们在架构自己的应用时必须格外小心：</p><p>• 我们必须想方设法地绕过 HTTP 1.x 的种种限制；</p><p>• 我们必须掌握利用 HTTP 2.0 性能增强的方法；</p><p>• 我们必须在应用经典的性能最佳实践时保持警惕。</p><h5 id="经典的性能优化最佳实践"><a href="#经典的性能优化最佳实践" class="headerlink" title="经典的性能优化最佳实践"></a>经典的性能优化最佳实践</h5><p>无论什么网络，也不管所用网络协议是什么版本，所有应用都应该致力于消除或减少不必要的网络延迟，将需要传输的数据压缩至最少。这两条标准是经典的性能优化最佳实践，是其他数十条性能准则的出发点。</p><p>• 减少DNS查找</p><p>每一次主机名解析都需要一次网络往返，从而增加请求的延迟时间，同时还会阻塞后续请求。</p><p>• 重用TCP连接</p><p>尽可能使用持久连接，以消除 TCP 握手和慢启动延迟；参见 2.2.2 节“慢启动”。</p><p>• 减少HTTP重定向</p><p>HTTP 重定向极费时间，特别是不同域名之间的重定向，更加费时；这里面既有额外的 DNS 查询、TCP 握手，还有其他延迟。最佳的重定向次数为零。</p><p>• 使用CDN（内容分发网络）</p><p>把数据放到离用户地理位置更近的地方，可以显著减少每次 TCP 连接的网络延迟，增大吞吐量。这一条既适用于静态内容，也适用于动态内容；参见 4.7.2 节中的“不缓存的原始获取”。</p><p>• 去掉不必要的资源</p><p>任何请求都不如没有请求快。</p><p>说到这，所有建议都无需解释。延迟是瓶颈，最快的速度莫过于什么也不传输。然而，HTTP 也提供了很多额外的机制，比如缓存和压缩，还有与其版本对应的一些性能技巧。</p><p>• 在客户端缓存资源</p><p>应该缓存应用资源，从而避免每次请求都发送相同的内容。</p><p>• 传输压缩过的内容</p><p>传输前应该压缩应用资源，把要传输的字节减至最少：确保对每种要传输的资源采用最好的压缩手段。</p><p>• 消除不必要的请求开销</p><p>减少请求的 HTTP 首部数据（比如 HTTP cookie），节省的时间相当于几次往返</p><p>的延迟时间。</p><p>• 并行处理请求和响应</p><p>请求和响应的排队都会导致延迟，无论是客户端还是服务器端。这一点经常被忽视，但却会无谓地导致很长延迟。</p><p>• 针对协议版本采取优化措施</p><p>HTTP 1.x 支持有限的并行机制，要求打包资源、跨域分散资源，等等。相对而言，HTTP 2.0 只要建立一个连接就能实现最优性能，同时无需针对 HTTP 1.x 的那些优化方法。</p><h6 id="在客户端缓存资源"><a href="#在客户端缓存资源" class="headerlink" title="在客户端缓存资源"></a>在客户端缓存资源</h6><p>要说最快的网络请求，那就是不用发送请求就能获取资源。将之前下载过的数据缓存并维护好，就可以做到这一点。对于通过 HTTP 传输的资源，要保证首部包含适当的缓存字段：</p><p>• Cache-Control 首部用于指定缓存时间；</p><p>• Last-Modified 和 ETag 首部提供验证机制。</p><p>只要可能，就给每种资源都指定一个明确的缓存时间。这样客户端就可以直接使用本地副本，而不必每次都请求相同的内容。类似地，指定验证机制可以让客户端检查过期的资源是否有更新。没有更新，就没必要重新发送。</p><p>最后，还要注意应同时指定缓存时间和验证方法！只指定其中之一是最常见的错误，于是要么导致每次都在没有更新的情况下重发相同内容（这是没有指定验证），要么导致每次使用资源时都多余地执行验证检查（这是没有指定缓存时间）。</p><h6 id="压缩传输的数据"><a href="#压缩传输的数据" class="headerlink" title="压缩传输的数据"></a>压缩传输的数据</h6><p>利用本地缓存可以让客户端避免每次请求都重复取得数据。不过，还是有一些资源是必须取得的，比如原来的资源过期了，或者有新资源，再或者资源不能缓存。对于这些资源，应该保证传输的字节数最少。因此要保证对它们进行最有效的压缩。HTML、CSS 和JavaScript 等文本资源的大小经过 gzip 压缩平均可以减少 60%~80%。而图片则需要仔细考量：</p><p>• 图片一般会占到一个网页需要传输的总字节数的一半；</p><p>• 通过去掉不必要的元数据可以把图片文件变小；</p><p>• 要调整大小就在服务器上调整，避免传输不必要的字节；</p><p>• 应该根据图像选择最优的图片格式；</p><p>• 尽可能使用有损压缩。</p><p>不同图片格式的压缩率迥然不同，因为不同的格式是分别为不同使用场景设计的。事实上，如果选错了图片格式（比如，使用了 PNG 而非 JPG 或 WebP），多产生几百甚至上千 KB 数据是轻而易举的事。建议大家多找一些工具和自动化手段，以确定最佳图片格式。</p><p>选定图片格式后，其次就是不要让图片超过它需要的大小。如果在客户端对超出需要大小的图片做调整，那么除了额外传输不必要的字节之外，还会浪费 CPU、GPU和内存资源（参见 11.6 节的“计算图片对内存的需求”）。</p><p>最后，选择了正确的格式，确定了必需的大小，接下来就要研究使用哪一种有损图片格式，比如 JPEG 还是 WebP，以及压缩到哪个级别：较高压缩率可以明显减少字节数，同时图片品质不会有太大或太明显的损失，尤其是在较小（手机）的屏幕上看，不容易发现。</p><p><strong>WebP：Web 上的新图片格式</strong></p><p>WebP 是谷歌开发的一种新图片格式，得到了 Chrome 和 Opera 浏览器支持。这种格式的无损压缩和有损压缩效能都有所提升：</p><p>• WebP 的无损压缩图片比 PNG 的小 26%； </p><p>• WebP 的有损压缩图片比 JPG 的小 25%~34%； </p><p>• WebP 支持无损透明压缩，但因此仅增加 22% 的字节。</p><p>在现有网页平均 1 MB 大小，其中图片占一半的情况下，WebP 节省的 20%~30%，对每个页面而言就是几百 KB。这种格式需要客户端 CPU 多花点时间解码（大约相当于处理 JPG 的 1.4 倍），但字节的节省完全可以补偿处理时间的增长。此外，由于数据流量的限制和高速网络的存在，对很多用户而言，节省字节才是当务之急。事实上，Chrome Data Compression Proxy 和 Opera Turbo 等工具为用户降低带宽占用的主要手段，就是重新把每张图片编码为 WebP 格式。正常情况下，Chrome Data Compression Proxy 的数据压缩率可以达到 50%，这说明我们自己的应用也有很多可以通过压缩提升性能的空间。</p><p><strong>消除不必要的请求字节</strong></p><p>HTTP 是一种无状态协议，也就是说服务器不必保存每次请求的客户端的信息。然而，很多应用又依赖于状态信息以实现会话管理、个性化、分析等功能。为了实现这些功能，HTTP State Management Mechanism（RFC 2965）作为扩展，允许任何网站针对自身来源关联和更新 cookie 元数据：浏览器保存数据，而在随后发送给来源的每一个请求的 Cookie 首部中自动附加这些信息。</p><p>上述标准并未规定 cookie 最大不能超过多大，但实践中大多数浏览器都将其限制为4 KB。与此同时，该标准还规定每个站点针对其来源可以有多个关联的 cookie。于是，一个来源的 cookie 就有可能多达几十 KB ！不用说，这么多元数据随请求传递，必然会给应用带来明显的性能损失：</p><p>• 浏览器会在每个请求中自动附加关联的 cookie 数据；</p><p>• 在 HTTP 1.x 中，包括 cookie 在内的所有 HTTP 首部都会在不压缩的状态下传输；</p><p>• 在 HTTP 2.0 中，这些元数据经过压缩了，但开销依然不小；</p><p>• 最坏的情况下，过大的 HTTP cookie 会超过初始的 TCP 拥塞窗口，从而导致多余的网络往返。</p><p>应该认真对待和监控 cookie 的大小，确保只传输最低数量的元数据，比如安全会话令牌。同时，还应该利用服务器上共享的会话缓存，从中查询缓存的元数据。更好的结果，则是完全不用 cookie。比如，在请求图片、脚本和样式表等静态资源时，浏览器绝大多数情况下不必传输特定于客户端的元数据。</p><p>在使用 HTTP 1.x 的情况下，可以指定一个专门的“无需 cookie”的来源服务器。这个服务器可以用于交付那些不区分客户端的共用资源。</p><h6 id="并行处理请求和响应"><a href="#并行处理请求和响应" class="headerlink" title="并行处理请求和响应"></a>并行处理请求和响应</h6><p>为了让应用响应速度达到最快，应该尽可能第一时间就分派所有资源请求。可是，还有一点也要考虑到，那就是所有这些请求以及它们对应的响应，将会被服务器如何处理。如果我们的请求在服务器上按先来后到的顺序依次排队，那就又会导致不必要的延迟。要是想实现最佳性能，就要记住以下几点：</p><p>• 使用持久连接，从 HTTP 1.0 升级到 HTTP 1.1； </p><p>• 利用多个 HTTP 1.1 连接实现并行下载；</p><p>• 可能的情况下利用 HTTP 1.1 管道；</p><p>• 考虑升级到 HTTP 2.0 以提升性能；</p><p>• 确保服务器有足够的资源并行处理请求。</p><p>如果不使用持久连接，则每个 HTTP 请求都要建立一个 TCP 连接。由于 TCP 握手和慢启动，多个 TCP 会造成明显的延迟。在使用 HTTP 1.1 的情况下，最好尽可能重用已有连接。如果碰上能使用 HTTP 管道的机会，不要放过。更好的选择，则是升级到 HTTP 2.0，从而获得最佳性能</p><p>识别造成客户端和服务器延迟的不必要资源既是艺术也是技术：要仔细检查客户端资源瀑布（参见 10.2.2 节“分析资源瀑布”），以及服务器日志。常见问题如下：</p><p>• 服务器资源不足，造成不必要的资源处理延迟；</p><p>• 代理及负载均衡器容量不足，造成向应用服务器交付请求的延迟（请求排队）；</p><p>• 客户端资源阻塞导致页面构建延迟，参见 10.1 节的“DOM、CSSOM 和 JavaScript”。</p><h5 id="针对HTTP-1-x的优化建议"><a href="#针对HTTP-1-x的优化建议" class="headerlink" title="针对HTTP 1.x的优化建议"></a>针对HTTP 1.x的优化建议</h5><p>针对 HTTP 1.x 的优化次序很重要：首先要配置服务器以最大限度地保证 TCP 和TLS 的性能最优，然后再谨慎地选择和采用移动及经典的应用最佳实践，之后再度量，迭代。</p><p>采用了经典的应用优化措施和适当的性能度量手段，还要进一步评估是否有必要为应用采取特定于 HTTP 1.x 的优化措施（其实是权宜之计）。</p><p>• 利用HTTP管道</p><p>如果你的应用可以控制客户端和服务器这两端，那么使用管道可以显著减少网络延迟。</p><p>• 采用域名分区</p><p>如果你的应用性能受限于默认的每来源 6 个连接，可以考虑将资源分散到多个来源。</p><p>• 打包资源以减少HTTP请求</p><p>拼接和精灵图等技巧有助于降低协议开销，又能达成类似管道的性能提升。</p><p>• 嵌入小资源</p><p>考虑直接在父文档中嵌入小资源，从而减少请求数量。</p><p>管道缺乏支持，而其他优化手段又各有各的利弊。事实上，这些优化措施如果过于激进或使用不当，反倒会伤害性能（这一点请参考第 11 章的深入讨论）。总之，要有务实的态度，通过度量来评估各种措施对性能的影响，在此基础上再迭代改进。天底下就没有包治百病的灵丹妙药。</p><p>对了，还有最后一招儿——升级到 HTTP 2.0。仅此一招儿抵得上前面提到的大多数针对 HTTP 1.x 的优化手段！ HTTP 2.0 不光能让应用加载更快，还能让开发更简单</p><h5 id="针对HTTP-2-0的优化建议"><a href="#针对HTTP-2-0的优化建议" class="headerlink" title="针对HTTP 2.0的优化建议"></a>针对HTTP 2.0的优化建议</h5><p>HTTP 2.0 的主要目标就是提升传输性能，实现客户端与服务器间较低的延迟和较高的吞吐量。显然，在 TCP 和 TLS 之上实现最佳性能，同时消除不必要的网络延迟，从来没有如此重要过。最低限度：</p><p>• 服务器的初始 cwnd 应该是 10 个分组；</p><p>• 服务器应该通过 ALPN（针对 SPDY 则为 NPN）协商支持 TLS； </p><p>• 服务器应该支持 TLS 恢复以最小化握手延迟。</p><h6 id="去掉对1-x的优化"><a href="#去掉对1-x的优化" class="headerlink" title="去掉对1.x的优化"></a>去掉对1.x的优化</h6><p>针对 HTTP 2.0 和 HTTP 1.x 的优化策略没有什么重叠。因此，不仅不必担心 HTTP 1.x 协议的种种限制，而且要撤销原先那些必要的做法。</p><p>• 每个来源使用一个连接</p><p>HTTP 2.0 通过将一个 TCP 连接的吞吐量最大化来提升性能。事实上，在 HTTP 2.0 之下再使用多个连接（比如域名分区）反倒成了一种反模式，因为多个连接会抵消新协议中首部压缩和请求优先级的效用。</p><p>• 去掉不必要的文件合并和图片拼接</p><p>打包资源的缺点很多，比如缓存失效、占用内存、延缓执行，以及增加应用复杂性。有了 HTTP 2.0，很多小资源都可以并行发送，导致打包资源的效率反而更低。</p><p>• 利用服务器推送</p><p>之前针对 HTTP 1.x 而嵌入的大多数资源，都可以而且应该通过服务器推送来交付。这样一来，客户端就可以分别缓存每个资源，并在页面间实现重用，而不必把它们放到每个页面里了。</p><p>要获得最佳性能，应该尽可能把所有资源都集中在一个域名之下。域名分区在 HTTP 2.0 之下属于反模式，对发挥协议的性能有害：分区是开始，之后影响会逐渐扩散。打包资源不会影响 HTTP 2.0 协议本身，但对缓存性能和执行速度有负面影响。</p><p>类似地，把嵌入资源改为服务器推送能提升客户端的缓存性能，又不会导致额外网络延迟（参见 12.3.7 节中的“实现 HTTP 2.0 服务器推送”）。事实上，由于 3G 和4G 网络的往返时间更长，因而服务器推送对移动应用来说效果更明显。</p><p><strong>HTTP 2.0 中的打包与协议开销</strong></p><p>由于 HTTP 1.x 做不到多路复用，而且每次请求的协议开销很高，这才有了连接和拼合等打包技术。在 HTTP 2.0 之下，多路复用已经不成问题，首部压缩也可以降低每次 HTTP 请求要传输的元数据量，打包技术在多数情况下都不再需要了。不过，请求开销只是减少了，并没有等于零。少数情况下，某些资源必须一块使用，而且更新也不频繁，此时使用打包技术仍然可以提升性能。但这些情况很少见，可以算作例外。具体措施可以通过性能度量确定。</p><h6 id="双协议应用策略"><a href="#双协议应用策略" class="headerlink" title="双协议应用策略"></a>双协议应用策略</h6><p>遗憾的是，升级到 HTTP 2.0 不会在一夜之间完成。因此，很多应用都需要认真考虑双协议并存的部署策略，即同一个应用既能通过 HTTP 1.x 交付，也能通过 HTTP 2.0 交付，无需任何改动。然而，过于激进的 HTTP 1.x 优化可能伤害 HTTP 2.0 性能，反之亦然。</p><p>如果应用可以同时控制服务器和客户端，那倒简单了，因为它可以决定使用什么协议。但大多数应用不能也无法控制客户端，只有采用一种混合或自动策略，以适应两种协议并存的现实。下面我们就分析几种可能的情况。</p><p>• 相同的应用代码，双协议部署</p><p>相同的应用代码可能通过 HTTP 1.x 也可能通过 HTTP 2.0 交付。可能任何一种协议之下都达不到最佳性能，但可以追求性能足够好。所谓足够好，需要通过针对每一种应用单独度量来保证。这种情况下，第一步可以先撤销域名分区以实现HTTP 2.0 交付。然后，随着更多用户迁移到 HTTP 2.0，可以继续撤销资源打包并尽可能利用服务器推送。</p><p>• 分离应用代码，双协议部署</p><p>根据协议不同分别交付不同版本的应用。这样会增加运维的复杂性，但实践中对很多应用倒是十分可行。比如，一台负责完成连接的边界服务器可以根据协商后的协议版本，把客户端请求引导至适当的服务器。</p><p>• 动态HTTP 1.x和HTTP 2.0优化</p><p>某些自动化的 Web 优化框架，以及开源及商业产品，都可以在响应请求时动态重写交付的应用代码（包括连接、拼合、分区，等等）。此时，服务器也可以考虑协商的协议版本，并动态采用适当的优化策略。</p><p>• HTTP 2.0，单协议部署</p><p>如果应用可以控制服务器和客户端，那没理由不只使用 HTTP 2.0。事实上，如果真有这种可能，那就应该专一使用 HTTP 2.0。</p><p>选择路线时，要看当前的基础设施、应用的复杂程度，以及用户的构成。让人哭笑不得的是，那些在 HTTP 1.x 优化上投资很大的应用，反倒在这种情况下最难办。如果你能控制客户端，有自动的应用优化策略，或者没有使用任何特定于 1.x 的优化，那么就可以专注于 HTTP 2.0，而没有后顾之忧了。</p><h6 id="评估服务器质量与性能"><a href="#评估服务器质量与性能" class="headerlink" title="评估服务器质量与性能"></a>评估服务器质量与性能</h6><p>HTTP 2.0 服务器实现的质量对客户端性能影响很大。HTTP 服务器的配置当然是一</p><p>个重要因素，但服务器实现逻辑的质量同样与优先级、服务器推送、多路复用等性</p><p>能机制的发挥紧密相关。</p><p>• HTTP 2.0 服务器必须理解流优先级；</p><p>• HTTP 2.0 服务器必须根据优先级处理响应和交付资源；</p><p>• HTTP 2.0 服务器必须支持服务器推送；</p><p>• HTTP 2.0 服务器应该提供不同推送策略的实现。</p><p>HTTP 2.0 服务器的初级实现也能支持某些功能，但不能明确支持请求的优先级和服务器推送，可能导致次优性能。比如，发送大型、静态图片导致带宽饱和，而客户端又因为其他重要资源（如 CSS 或 JavaScript）被阻塞。</p><h6 id="2-0与TLS"><a href="#2-0与TLS" class="headerlink" title="2.0与TLS"></a>2.0与TLS</h6><p>实践中，由于存在很多不兼容的中间代理，早期的 HTTP 2.0 部署必然依赖加密信道。这样一来，我们就面临两种可能出现 ALPN 协商和 TLS 终止的情况：</p><p>• TLS 连接可能会在 HTTP 2.0 服务器上终止；</p><p>• TLS 连接可能会在上游（如负载均衡器）上终止</p><p>第一种情况要求 HTTP 2.0 服务器能够处理 TLS，除此之外就没有什么了。第二种情况复杂一些：TLS+ALPN 握手可能会在上游代理处终止（图 13-3），然后再从那里建立一条加密信道，或者直接将非加密的 HTTP 2.0 流发送到服务器。</p><p>代理和应用服务器之间使用安全信道还是非加密信道，取决于应用：只要能控制中间设备，就可以保证未加密的帧不会被修改或丢弃。那么，虽然大多数 HTTP 2.0 服务器都应该支持 TLS+ALPN 协商，但它们同时也应该在不加密的情况下实现HTTP 2.0 通信。</p><p>另外，智能负载均衡器也可以使用 TLS+ALPN 协商机制，根据协商后的协议，选择性地将不同的客户端路由到不同的服务器</p><h6 id="负载均衡器、代理及应用服务器"><a href="#负载均衡器、代理及应用服务器" class="headerlink" title="负载均衡器、代理及应用服务器"></a>负载均衡器、代理及应用服务器</h6><p>一台服务器对于大型应用是不够的。大型应用必须要添加一台负载均衡器，以分流大量请求。此时，负载均衡器可以终止 TLS 连接（参见 13.3.5 节“2.0 与TLS”），也可以经过配置作为 TCP 代理并直接将加密数据发送给应用服务器。</p><p>很多云提供商也会提供负载均衡器服务。然而，这些负载均衡器大多支持TLS 终止，却不支持 ALPN 协商，而这对于通过 TLS 实现 HTTP 2.0 通信是必需的。在这种情况下，应该将负载均衡器配置为 TCP 代理，即通过它们将加密数据发送给应用服务器，让应用服务器完成 TLS+ALPN 协商。</p><p>实践中，要回答的最重要的一个问题，就是你的基础设施中的哪个组件负责终止TLS 连接，以及它是否能够执行必要的 ALPN 协商？</p><p>• 要在 TLS 之上实现 HTTP 2.0 通信，终端服务器必须支持 ALPN； </p><p>• 尽可能在接近用户的地方终止 TLS，参见 4.7.2 节“尽早完成（握手）”；</p><p>• 如果无法支持 ALPN，那么选择 TCP 负载均衡模式；</p><p>• 如果无法支持 ALPN 且 TCP 负载均衡也做不到，那么就退而求其次，在非加密</p><p>信道上使用 HTTP 的 Upgrade 流，参见 12.3.9 节“有效的 HTTP 2.0 升级与发现”。</p>]]></content>
    
    
    <categories>
      
      <category>web性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web性能权威指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http权威指南</title>
    <link href="/2022/12/09/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2022/12/09/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http权威指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS权威指南</title>
    <link href="/2022/11/30/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2022/11/30/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="置换元素和非置换元素"><a href="#置换元素和非置换元素" class="headerlink" title="置换元素和非置换元素"></a>置换元素和非置换元素</h2><p>置换元素是指用来置换元素内容的部分不由文档内容直接表示，在html中，最常见的置换元素是img，input</p><p>非置换元素即元素的内容由用户代理通常是浏览器在元素自身生成的框中显示，文本，段落，标题，单元格，列表等其他都是非置换元素</p><h2 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h2><p>块级元素是独占一行，行内元素不会独占一行，在html中，块级元素不能出现在行内元素中，但是css不会限制他们的显示方式，可以互相嵌套</p><h2 id="把CSS应用到HTML的方式"><a href="#把CSS应用到HTML的方式" class="headerlink" title="把CSS应用到HTML的方式"></a>把CSS应用到HTML的方式</h2><h3 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h3><div class="code-wrapper"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;basic.css&quot;</span>&gt;</code></pre></div><p>多个link，会自动合成一个link</p><h3 id="style元素"><a href="#style元素" class="headerlink" title="style元素"></a>style元素</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;test/css&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>style中可以使用@import导入外部样式</p><h3 id="import指令"><a href="#import指令" class="headerlink" title="@import指令"></a>@import指令</h3><p>@import也可以引入外部样式，但是@import必须放在顶部，否则不起作用</p><p>可以使用多个@import</p><h3 id="HTTP链接"><a href="#HTTP链接" class="headerlink" title="HTTP链接"></a>HTTP链接</h3><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><h2 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h2><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/* 这是一段注释 */</span></code></pre></div><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><p>主要是指html元素</p><h3 id="群组选择器"><a href="#群组选择器" class="headerlink" title="群组选择器"></a>群组选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>:red&#125;</code></pre></div><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.warning</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;</code></pre></div><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.wraning</span><span class="hljs-selector-class">.help</span>&#123;<span class="hljs-attribute">background</span>:red&#125;</code></pre></div><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id选择器使用不能超过一次，id选择器的优先级高于类选择器</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#lead</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;</code></pre></div><h3 id="简单属性描述符"><a href="#简单属性描述符" class="headerlink" title="简单属性描述符"></a>简单属性描述符</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span><span class="hljs-selector-attr">[class]</span>&#123;<span class="hljs-attribute">color</span>:silver&#125;;  在<span class="hljs-selector-tag">h1</span>标签中有class属性的都设置<span class="hljs-attribute">color</span>*<span class="hljs-selector-attr">[title]</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125; ;  所有有title属性的<span class="hljs-attribute">font-weight</span>都设置为bold<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span><span class="hljs-selector-attr">[href]</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;; <span class="hljs-selector-tag">a</span>标签中存在title和href属性的<span class="hljs-attribute">font-weight</span>都设置为bold</code></pre></div><h3 id="精准的属性描述符"><a href="#精准的属性描述符" class="headerlink" title="精准的属性描述符"></a>精准的属性描述符</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;http://google.com&quot;</span>]</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;http://google.com&quot;</span>]</span><span class="hljs-selector-attr">[title=<span class="hljs-string">&quot;google&quot;</span>]</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;</code></pre></div><h3 id="使用属性选择器匹配子串"><a href="#使用属性选择器匹配子串" class="headerlink" title="使用属性选择器匹配子串"></a>使用属性选择器匹配子串</h3><div class="code-wrapper"><pre><code class="hljs prolog">[foo|=<span class="hljs-string">&#x27;bar&#x27;</span>] 选择的元素有foo属性，且以bar和-开头，或者是bar本身 例如 foo=<span class="hljs-string">&quot;bar-gerr&quot;</span>[foo~=<span class="hljs-string">&quot;bar&quot;</span>] 选择的元素有foo属性，且其值包含bar这个词的一组词，就是匹配以空格分隔的一组词的一个  例如foo=<span class="hljs-string">&quot;bar li&quot;</span>[foo*=<span class="hljs-string">&quot;bar&quot;</span>] 选择的元素有foo属性，且其值包含子串bar 例如foo=“bary”[foo^=<span class="hljs-string">&quot;bar&quot;</span>] 选择的元素有foo属性，且其值是以bar开头  [foo$=<span class="hljs-string">&quot;bar&quot;</span>] 选在的元素有foo属性，且其值是以bar结尾</code></pre></div><h3 id="不区分大小写的标识符"><a href="#不区分大小写的标识符" class="headerlink" title="不区分大小写的标识符"></a>不区分大小写的标识符</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href$=<span class="hljs-string">&#x27;.PDF&#x27;</span> i]</span></code></pre></div><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;<span class="hljs-attribute">color</span>:white&#125; //为所有符合条件的后代设置样式，无论层级多深</code></pre></div><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &gt; <span class="hljs-selector-tag">strong</span> &#123;<span class="hljs-attribute">color</span>:red&#125;  //只为子元素设置样式</code></pre></div><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-top</span>:<span class="hljs-number">0</span>;&#125;  //选择紧跟在<span class="hljs-selector-tag">h1</span>后面的<span class="hljs-selector-tag">p</span>元素，他们是同属于一个父元素</code></pre></div><h3 id="后继同胞选择器"><a href="#后继同胞选择器" class="headerlink" title="后继同胞选择器"></a>后继同胞选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span> ~<span class="hljs-selector-tag">ol</span>&#123;<span class="hljs-attribute">font-style</span>:italic;&#125;  //选择<span class="hljs-selector-tag">h2</span>中同属于一个父元素的所有兄弟<span class="hljs-selector-tag">ol</span>，和相邻兄弟选择器不同的是，相邻兄弟选择器只能匹配一个</code></pre></div><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span><span class="hljs-selector-pseudo">:hover</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;  <span class="hljs-comment">//鼠标悬停在未访问过的链接的时候</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span><span class="hljs-selector-pseudo">:hover</span>&#123;<span class="hljs-attribute">color</span>:maroon;&#125;  <span class="hljs-comment">//鼠标悬停在已访问过的链接的时候。</span></code></pre></div><p>这种伪类选择器的使用和伪类的顺序无关，但是不要使用互相排斥的伪类类如<code>a:link:visited</code></p><h4 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h4><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span>&#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid red&#125;  选择文档根元素，在<span class="hljs-selector-tag">html</span>中，根元素始终是<span class="hljs-selector-tag">html</span>元素，在xml中是不一样的<span class="hljs-selector-pseudo">:empty</span>伪类可以选择没有任何子代的元素，甚至连文本结点都没有包括空白文本，元素里面只有注释也是属于空元素*<span class="hljs-selector-pseudo">:empty</span>&#123;<span class="hljs-attribute">display</span>:none;&#125;可以匹配所有的空元素，但是这里有个陷阱，他可以匹配<span class="hljs-selector-tag">img</span>，<span class="hljs-selector-tag">input</span>，还有匹配没有内容的<span class="hljs-selector-tag">textarea</span><span class="hljs-selector-pseudo">:empty</span>是唯一考虑文本结点的css选择器</code></pre></div><p>选择唯一子代</p><div class="code-wrapper"><pre><code class="hljs typescript">a[href] <span class="hljs-attr">img</span>:only-child  <span class="hljs-comment">//有href属性的a标签中 有唯一的子后代元素img  文本不属于元素</span>在后代选择器中使用:only-child,列出的元素不一定是父子关系例如&lt;a href&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/&gt;</span></span>&lt;/a&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>都可以匹配到如果需要确保是父子关系的话必须使用&gt;a[href] &gt; <span class="hljs-attr">img</span>:only-child如果想匹配超链接中唯一的img，但是链接中还有其他内容，img不是a标签中的唯一子元素可以使用:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>a[href] <span class="hljs-attr">img</span>:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span> &#123;<span class="hljs-attr">border</span>:5px solid black;&#125;&lt;a href=<span class="hljs-string">&quot;#&quot;</span>&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/&gt;</span></span>&lt;/a&gt;only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>和last-child的区别是only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>会忽略其他子元素，只会匹配对应的元素，only-child只会匹配唯一的元素注意:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>指的是元素，不能用于其他例如：p.<span class="hljs-property">unique</span>:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span> &#123;<span class="hljs-attr">color</span>:red;&#125;&lt;div&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;unique&quot;</span>&gt;</span>this is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>this is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>&lt;/div&gt;这两个段落都不会被匹配，因为都是div的后代，不是唯一的类型，:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>前面必须是元素类型</code></pre></div><p>选择第一个和最后一个子代</p><p>:first-child 选择一个元素的第一个子元素</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<span class="hljs-attribute">font-weight</span>:bold;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<span class="hljs-attribute">text-transform</span>:uppercase;&#125;</code></pre></div><p>人们对p:first-child最大的误解就是认为他是选择p标签下的第一个子元素，如果想选择一个元素的第一个em子元素，应该是em:first-child,和:first-child对应的还有:last-child</p><p>选择第一个或者最后一个的某个元素</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:first</span>-of-type<span class="hljs-selector-pseudo">:last-of-type</span><span class="hljs-selector-tag">table</span><span class="hljs-selector-pseudo">:only-of-type</span> &#123;<span class="hljs-attribute">background</span>:color&#125;  等价于 <span class="hljs-selector-tag">table</span><span class="hljs-selector-pseudo">:first</span>-of-type<span class="hljs-selector-pseudo">:last-of-type</span> &#123;<span class="hljs-attribute">background</span>:color&#125;</code></pre></div><p>选择每第n个元素</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-meta">:first-child等价于:nth-child(1)</span>:nth-child(an+b) n=0,1,2,3,4..  元素是从1开始算起的，没有第0个元素，例如3n，则0，3，6，9，0是匹配不到的<span class="hljs-meta">:nth-child(2n+1)等价于 :nth-child(odd)</span><span class="hljs-meta">:nth-child(2n)等价于 :nth-child(even)</span>tr:nth-child(n+9)等价于 tr:nth-child(8) ~tr:nth-last-child是从后面开始算起的<span class="hljs-meta">:nth-child(1):nth-last-child(1)等价于:only-child</span>注意：nth-child(an<span class="hljs-code">+b)和：nth-of-type(an+</span>b)的区别</code></pre></div><h3 id="超链接伪类"><a href="#超链接伪类" class="headerlink" title="超链接伪类"></a>超链接伪类</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:link</span> 指未访问过的地址<span class="hljs-selector-pseudo">:visited</span> 指已访问过的地址</code></pre></div><h3 id="用户操作伪类"><a href="#用户操作伪类" class="headerlink" title="用户操作伪类"></a>用户操作伪类</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:focus</span> 指当前获得输入焦点的元素，即可以接受键盘输入或者以某种方式激活<span class="hljs-selector-pseudo">:hover</span> 指鼠标放置在上面的元素，例如鼠标悬停在超链接上<span class="hljs-selector-pseudo">:active</span> 指用户输入激活的元素，例如用户单击超链接，按下鼠标的那段时间</code></pre></div><p>可以处于:active状态的元素有链接，菜单项目，以及可以设定taindex属性的元素，这些元素包括其他交互元素如表单控件，可编辑内容的元素，还可以获得焦点，这些伪类最常用于超链接</p><p>这些伪类的顺序不可以随意改变</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">link-visited-focus-hover-active</span></code></pre></div><p>动态伪类引起的问题</p><p>例如：如果把link，visited设置为相同的font-size，而hover和active的时候增大字体</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">13px</span>;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>,<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">20px</span>;&#125;</code></pre></div><p>用户在鼠标悬停或者在触屏点击的时候字体增大可能会出现重排的情况</p><h3 id="UI状态伪类"><a href="#UI状态伪类" class="headerlink" title="UI状态伪类"></a>UI状态伪类</h3><table><thead><tr><th>伪类</th><th>说明</th></tr></thead><tbody><tr><td>:disabled</td><td>即指代禁用用户界面元素例如表单元素，即不接受输入元素</td></tr><tr><td>:checked</td><td>指代用户或者文档默认选中的radio/checkbox</td></tr><tr><td>:enabled</td><td>指代启用的用户界面元素例如表单元素，即接受输入的元素</td></tr><tr><td>:indeterminate</td><td>指代既未选中耶没有未选中的单选按钮或者复选框，这个状态只能由dom来设定，不能由用户设定</td></tr><tr><td>:default</td><td>指代默认选中的单选框或者复选框按钮</td></tr><tr><td>:valid</td><td>指代满足所有数据有效性语义的输入框</td></tr><tr><td>:invalid</td><td>指代不满足所有数据有效性语义的输入框</td></tr><tr><td>:in-range</td><td>指代输入的值在最小值和最大值之间的输入框</td></tr><tr><td>:out-of-range</td><td>指代输入的值小于控件允许的最小值或大于控件允许的最大值的输入框</td></tr><tr><td>:required</td><td>指代必须输入值的输入框</td></tr><tr><td>:optional</td><td>指代无需输入值的输入框</td></tr><tr><td>:read-write</td><td>指代可由用户编辑的输入框</td></tr><tr><td>:read-only</td><td>指代不能由用户编辑的输入框</td></tr></tbody></table><p>非ui元素也可以使用:focus</p><p>:default</p><p>这个伪类通常用于上下文菜单选项，button，选择列表，目录，如果有几个同名的redio，最开始选中的那个radio就会匹配，即使用户后来选中了其他radio，页面重新加载时，也会应用于默认的那个，select元素一开始选中多个option，也可以匹配:default,:default还可以匹配button，和菜单选项</p><div class="code-wrapper"><pre><code class="hljs pgsql">[<span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;checkbox&#x27;</span>]:<span class="hljs-keyword">default</span> + label &#123;font-size:italic;&#125;&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; id=&quot;chbx&quot; checked <span class="hljs-type">name</span>=&quot;foo&quot; <span class="hljs-keyword">value</span>=&quot;bar&quot;/&gt;&lt;label <span class="hljs-keyword">for</span>=&quot;chbx&quot;&gt;this <span class="hljs-keyword">is</span> checkbox&lt;/label&gt;</code></pre></div><p>:required</p><p>:required是匹配必填的表单控件，required属性在html5中指定，:optional匹配没有required属性的表单控件，或者required属性为false的元素</p><p>想要提交表单，:required要求元素必须有值，:optional的有值没有值都可以</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">input</span>:require &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:optional</span> &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;&#125;也可以这么写<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[required]</span> &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-attr">[required]</span>) &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;&#125;&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;email&quot;</span> placeholder=<span class="hljs-string">&quot;&quot;</span> required&gt;&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;email&quot;</span> placeholder=<span class="hljs-string">&quot;&quot;</span> &gt;&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;email&quot;</span> required=<span class="hljs-string">&quot;false&quot;</span> &gt;除了表单输入框意外，其他元素既不能必选也不能可选</code></pre></div><p>:valid和:invalid只适用于可以检查数据有效性的元素，div是不可以的，input可能匹配其中一个，这取决于用户界面当前的状态</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;email&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span>&#123;  <span class="hljs-attribute">background-position</span>:<span class="hljs-number">100%</span> <span class="hljs-number">50%</span>;  <span class="hljs-attribute">background-repeat</span>:no-repeat;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;email&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span><span class="hljs-selector-pseudo">:valid</span>&#123;  <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">...</span>)&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;emial&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span><span class="hljs-selector-pseudo">:invalid</span>&#123;  <span class="hljs-attribute">background</span>&#125;</code></pre></div><p>:in-range/:out-of-range</p><p>适用于有范围要求的表单控件</p><div class="code-wrapper"><pre><code class="hljs lua">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;number&#x27;</span> <span class="hljs-built_in">min</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-built_in">max</span>=<span class="hljs-string">&#x27;100&#x27;</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;number&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span> &#123;  <span class="hljs-attribute">background-position</span>:<span class="hljs-number">50%</span> <span class="hljs-number">50%</span>;  <span class="hljs-attribute">background-repeat</span>:no-repeat;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;number&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span><span class="hljs-selector-pseudo">:valid</span>&#123;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;number&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span><span class="hljs-selector-pseudo">:invalid</span>&#123;&#125;</code></pre></div><h3 id="target伪类"><a href="#target伪类" class="headerlink" title=":target伪类"></a>:target伪类</h3><p>URL中有个片段标识符，它指向的文档片段在css中称之为target，url片段标识符指向的目标元素可以使用:target伪类进行标识</p><p>例如</p><p><a href="http://www.w3.org/tr/css3/#target-pes">http://www.w3.org/tr/css3/#target-pes</a></p><p>target-pes这部分就是片段标识符，用#标识，对应着页面中🈶️id=“target-pes”的元素，这个元素就是片段标识符的target</p><p>利用:target,我们可以突出显示文档中的任何目标元素，或者为不同的target元素定义不同的样式，</p><div class="code-wrapper"><pre><code class="hljs css">*<span class="hljs-selector-pseudo">:target</span> &#123;<span class="hljs-attribute">border-left</span>:<span class="hljs-number">5px</span> solid gray;<span class="hljs-attribute">background</span>:yellow <span class="hljs-built_in">url</span>(<span class="hljs-string">target.png</span>) top right no-repeat&#125;</code></pre></div><p>:target定义的样式在以下情况不会应用：</p><p>1.页面的url中没有片段标识符</p><p>2.页面的url中有片段标识符，但是文档中没有与之匹配的元素</p><p>如果文档中有多个元素与之匹配，样式都会应用</p><h3 id="lang伪类"><a href="#lang伪类" class="headerlink" title=":lang伪类"></a>:lang伪类</h3><div class="code-wrapper"><pre><code class="hljs css">*<span class="hljs-selector-pseudo">:lang</span>(fr) &#123;<span class="hljs-attribute">font-style</span>:italic;&#125;*:[lang|=<span class="hljs-string">&#x27;fr&#x27;</span>] &#123;<span class="hljs-attribute">font-style</span>:italic;&#125;</code></pre></div><h3 id="not-否定伪类"><a href="#not-否定伪类" class="headerlink" title=":not()否定伪类"></a>:not()否定伪类</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.moreinfo</span>)&#123;<span class="hljs-attribute">font-style</span>:italic;&#125;<span class="hljs-selector-class">.link</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-tag">li</span>)<span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-tag">p</span>) &#123;<span class="hljs-attribute">font-style</span>:italic;&#125;</code></pre></div><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素和伪类的区别是伪类是：伪元素是：：</p><p>所有的伪元素选择器只能出现在选择器的最后，<code>p::first-line em</code> 这样是不允许的</p><p>::first-letter</p><p>用于修饰任何非行内元素的首字母，或者开头的标点符号或者首字母</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">color</span>:red;&#125;</code></pre></div><p>::first-letter常用于实现排版效果的首字母大写或者首字母下沉，你可以把每个p元素首字母的字号设置为其余内容的两倍大，不过最好应用于第一段文字的首字母上</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-of-type<span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">200%</span>;&#125;</code></pre></div><p>::first-line</p><p>用于修饰元素的首行文本，例如把首行文本字体变大</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">150%</span>;<span class="hljs-attribute">color</span>:purple;&#125;</code></pre></div><p><strong>对于::first-letter和::first-line的限制</strong></p><p>目前这两个伪元素只能用于块级元素上，不能用于行内元素，对于在::first-letter</p><table><thead><tr><th>::first-letter</th><th>::first-line</th></tr></thead><tbody><tr><td>所有字体属性</td><td>所有字体属性</td></tr><tr><td>所有背景属性</td><td>所有背景属性</td></tr><tr><td>所有文本修饰属性</td><td>所有外边距属性</td></tr><tr><td>所有行内排版属性</td><td>所有内边距属性</td></tr><tr><td>所有行内布局属性</td><td>所有边框属性</td></tr><tr><td>所有边框属性</td><td>所有文本装饰属性</td></tr><tr><td>box-shadow</td><td>所有行内排版属性</td></tr><tr><td>color</td><td>color</td></tr><tr><td>opacity</td><td>opacity</td></tr></tbody></table><p>::before和::after</p><h2 id="特指度"><a href="#特指度" class="headerlink" title="特指度"></a>特指度</h2><p>选择器的特指度是由选择器本身的组成来决定的，一个特指度值由四部分组成，0，0，0，0</p><p>选择器中的id属性值加0，1，0，0</p><p>选择器中的每个类属性，属性选择器，或者伪类加0010</p><p>选择器中的每个元素和伪元素加0001</p><p>连接符和通用选择器不加特指度</p><p>通用选择器的特指度为0000</p><p>连接符没有特指度</p><p>id选择器和选择id属性的属性选择器在特指度上是有区别的</p><p>例如</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &gt; <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">table</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-attr">[id=<span class="hljs-string">&#x27;totals&#x27;</span>]</span> <span class="hljs-selector-tag">td</span> <span class="hljs-selector-tag">ul</span> &gt;<span class="hljs-selector-tag">li</span> &#123;colors:maroon;&#125; //<span class="hljs-number">0017</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-id">#answer</span> &#123;<span class="hljs-attribute">color</span>:navy;&#125;  //<span class="hljs-number">0101</span></code></pre></div><p>行内样式的特指度为1000；</p><p>!important 会超多其他声明，但是不会改变特指度</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承指的是某些样式不仅会应用到所指的元素，还会应用到元素的后代</p><p>属性值不会向上传播，即元素的样式绝不会传给祖先元素</p><p>在html中，向上传播的规则又个例外，应用在body上的背景样式会传给html元素，htm是文档的根元素，用于定义渲染的画布，这种例外仅发生在body元素定义了背景而html元素没有定义背景的情况</p><p>border属性，盒模型的属性包括margin，padding，background，border不继承</p><p>零特指度战胜没有特指度</p><p>通用选择器会应用于所有元素，    而且特指度为零，所以他声明的color会覆盖继承的color，因为继承没有特指度，通用选择器可以匹配任何选择器，所有他会覆盖继承的值，所以不要滥用通用选择器</p><h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>css使用层叠机制把样式组合在一起，即结合继承和特指度的一些规则，css层叠的规则如下</p><p>找到匹配特定元素的所有规则</p><p>按显式权重排序应用到特定元素上的所有声明，以！important声明的规则比没有的高</p><p>按来源排序应用到特定元素上的所有声明，声明有三个来源，创作人员，读者，用户代理，创作者编写的样式优先级高于读者的样式，读者中！important声明的样式权重比其他样式高，包括创作者以！important编写的样式，创作者和读者编写的样式会覆盖用户代理编写的样式</p><p>按特指度排序的应用到特定元素上的所有声明，样式表或文档中靠后的声明权重较高，导入的样式声明会放在所有样式声明的最前面。</p><p><strong>按权重和来源排序</strong></p><p>如果两个规则应用在同一个元素上，有!important的会胜出</p><p>:如果都定义了!important,!important在行内样式的会胜出</p><p>如果显式权重相同，就要考虑来源，如果匹配元素的两个样式权重相同，而一个是创作者编写的样式，另外一个是读者编写的样式，最后创作者编写的样式会生效</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">em</span> &#123;<span class="hljs-attribute">color</span>:red&#125;  //创作者编写<span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">em</span> &#123;<span class="hljs-attribute">color</span>:red&#125;  //读者编写</code></pre></div><p>在声明的权重上，要考虑五个方面，下面按权重从高到低列出</p><p>1.读者提供的样式以!important声明</p><p>2.创作者编写的样式以!important声明</p><p>3.创作者编写的常规样式</p><p>4.读者提供的常规样式</p><p>5.用户代理提供的样式</p><p><strong>按特指度排序</strong></p><p>如果应用在一个元素上的声明有冲突，而且各个声明的显式权重和来源相同，那么因该按特指度排序，特指度最高的声明胜出。</p><p><strong>按前后顺序排序</strong></p><p>如果两个规则的显式权重，来源，和特指度都相同，那么在样式表靠后的规则会胜出</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>在css中，url和开始的括号之间不可以有空格</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>()&#125;  正确<span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background</span>:url ()&#125; 错误</code></pre></div><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><div class="code-wrapper"><pre><code class="hljs arduino">&lt;image&gt;的src可以有三种值urlimage-set  只有少量浏览器支持gradient 线性或径向渐变图像</code></pre></div><h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><p>css使用calc进行简单的数学计算</p><p>calc()会检查括号中各个值的类型，确保兼容，检查方式如下：</p><p>+和-两侧的值必须使用相同类型的值，或者是number，integer，结果为number，5+2.7是有效的5em+2.7是无效的，因为一边是长度单位，一边没有，5em+20px是有效的，因为都是长度单位</p><p>*计算的两个值中必须有一个是number，因此2.5rem * 2是有效的，2rem * 2.5rem是无效的，因为结果是5rem^2,这是面积单位不是长度单位</p><p>/计算的两个值右边必须是number，左边是integer时，值式number，否则单位和左边一样，30em/2.75是有效的，30/2.75em是无效的</p><p>任何情况下都不可以/0</p><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>在css中的颜色表示</p><ul><li>具名颜色</li><li>RGB颜色 可以使用百分比或者整数表示 rbg(100%,100%,100%) rgb(255,255,255),百分比的取值范围是0-100%，整数的范围0-255，都不能超过这个值，否则就会被裁减</li><li>RGBA颜色。会比RGB的基础上增加一个alpha，即red-green-blue-alpha。范围是0-1</li><li>十六进制的RGB   h1{color:#FFFFFF}. 如果16进制中每两个数值相同，可以省略一个，css允许使用简短语法，h1{color:#FFF;},为什么可以这么写，因为浏览器会把每个数字复制成两个，#F00 会变成#FF0000，#6FA变成#66FFAA，像#808080不能这么写</li><li>十六进制的RGBA。#663399AA可以写成#639A<ul><li>HSL和HSLa颜色。CSS3新增的颜色表示方法，HSL是Hue 色相 ，Satuation 饱和度，Lightness明度的简称色相是角度值取值范围是0-360，饱和度0-100的百分数明度是0-100的百分数。色相分布在一个色相环上，随着角度的旋转得到的色谱上的不同的颜色，0代表红色，旋转到360又回回到红色，p.one {color:hsl(0,%,0%)}</li></ul></li></ul><p><strong>颜色关键字</strong></p><p>有两个特殊的关键字可以在任何时候允许使用颜色值的地方使用，transparent，currentColor</p><p>transparent表示完全透明的颜色，按照css color module的定义，他与rgba(0,0,0,0)相同，这个关键字不用于定义文本颜色，主要用于定义背景色的默认值，还可以定义只占空间而不可见边框的元素，定义渐变也常用</p><p>currentColor是指当前元素color属性计算得到的值：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.main</span> &#123;<span class="hljs-attribute">color</span>:gray;<span class="hljs-attribute">border-color</span><span class="hljs-selector-pseudo">:current</span>Color;&#125;</code></pre></div><h2 id="角度"><a href="#角度" class="headerlink" title="角度"></a>角度</h2><p>deg。度数，完整的圆周是360度；</p><p>grad。百分度，完整的圆周是400百分度；</p><p>rad。 弧度，完整的圆周是2π</p><p>turn  圈数 一个完整的圆周是一圈，这个单位在旋转动画中最有用，</p><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>&#123;<span class="hljs-attr">--base-color</span>:<span class="hljs-number">#639</span>;<span class="hljs-attr">--highlight-color</span>:<span class="hljs-number">#AEA</span>;&#125;<span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--base-color);&#125;<span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--highlight-color);&#125;自定义标识符使用--作为开头，并使用<span class="hljs-selector-tag">var</span>进行调用，区分大小写，自定义属性还有范围<span class="hljs-selector-tag">html</span>&#123;<span class="hljs-attr">--base-color</span>:<span class="hljs-number">#639</span>;&#125;<span class="hljs-selector-tag">aside</span>&#123;<span class="hljs-attr">--base-color</span>:<span class="hljs-number">#F60</span>;&#125;<span class="hljs-selector-tag">aside</span>中的变量作用范围在<span class="hljs-selector-tag">aside</span>元素之下，<span class="hljs-selector-tag">html</span>则作用于<span class="hljs-selector-tag">html</span>元素之下</code></pre></div><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><h3 id="text-indent-文本缩进"><a href="#text-indent-文本缩进" class="headerlink" title="text-indent 文本缩进"></a>text-indent 文本缩进</h3><p>取值:length/percentage</p><p>初始值：0</p><p>适用于：块级元素</p><p>百分数：相对于所在块级元素的宽度</p><p>计算值：百分数如上，长度值得到绝对长度</p><p>继承性：是</p><p>动画性：是</p><p>text-indent可以把元素缩进到指定的长度，缩进的长度可以是负值，例如<code>text-indent:-9999px;</code>,常用语缩进段落的第一行</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">text-indent</span>:<span class="hljs-number">2em</span>;&#125;</code></pre></div><p>Text-indent可以用于任何块级元素，缩进将沿行内方向展开，text-indent不能用于行内元素，或者置换元素例如图像，如果图像在块级元素的第一行，他将随行中的其他文本一起后移。</p><p>如果想缩进行内元素的首行，可以通过内边距或者外边距来实现，</p><p>text-indent可以是负值，常用的用法是实现悬挂缩进，即首行相比元素的其他内容悬挂在一边</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">text-indent</span>:-<span class="hljs-number">4em</span>;&#125;</code></pre></div><p>在使用负值时，避免被浏览器放入边框吃掉，建议在外部加上padding或者magin</p><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><p>取值：start｜end｜left｜right｜center｜jutify｜match-parent｜start end</p><p>初始值：css3中是start，在css2.1中是由用户代理指定</p><p>适用于：块级元素</p><p>计算值：指定值，match-parent除外</p><p>继承性：是</p><p>动画性：否</p><p>在css2.1中，对从左到右书写的语言，text-align的默认值是left，从右至左的默认值是right，在css3中，对于纵向书写的语言，left和right对应着起边和终边。</p><p><strong>两端对齐。justify</strong></p><p>两端对齐的文本，一行的两端都要和父元素的边界对齐，单词和字母之间的空白会调整，从而保证每一行的长度一致，两端对齐的文本要经过拉升，正好正满父元素左右边界之间的空间，至于如何拉升，是由用户代理来决定的，css规定，letter-spcing设置了长度值，用户代理不因该在增加和减少字符之间的间距。</p><p><strong>和父元素保持一致</strong></p><p>match-parent ，浏览器不支持这个值，他的基本作用被inherit覆盖，</p><h3 id="text-align-last"><a href="#text-align-last" class="headerlink" title="text-align-last"></a>text-align-last</h3><p>对齐最后一行</p><p>取值 auto｜start｜end｜left｜right｜center｜justify</p><p>初始值 auto</p><p>适用于 块级元素</p><p>计算值 指定值</p><p>继承性 是</p><p>动画性 否</p><p>如果段落只有一行，就是第一行也是最后一行，test-align-last的优先级会高于text-align</p><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><p>指的是行的基线之间的距离，和font-size无关，line-height是控制行距，是除字体高度之外在文本行上方的额外空间，也就是说，line-height的值和字体之间的高度差就是行距</p><p>取值  number｜length｜percentage ｜normal</p><p>初始值 normal</p><p>适用于 所有元素</p><p>百分数 相当于font-size</p><p>计算值 长度和百分数，得到绝对值，否则，是指定值</p><p>继承性 是</p><p>动画性 是</p><p>对于块级元素而言，line-height定义元素中文本行基线之间的最小距离，定义的是最小距离，而不是固定值，基线之间的距离可能比line-height的值大,line-height不影响置换元素的布局，但是依旧会应用到置换元素上。</p><p><strong>行的构成</strong></p><p>文本行的每个元素构成一个内容去，其高度由字体的高度居定，随内容区出现的是一个inline box行内框 ，如果不考虑其他因素，他的高度和内容区的高度相同，line-height是影响内容区高度的因素之一。</p><p>元素的行距等于font-size-line-height，行距可能是负数，行距分为两半，分别是内容区的上半部分和下半部分，算上行距，就得到元素的行内距。例如font-size是14px line-height是18px 二者差4px，那么这就会被分为内容区的上半部分和下半部分，</p><p>确定一行内容的全部行内框之后，行框也就确定了，行框恰好包围最高那个行内框的顶部和最低那个行内框的底部</p><p><strong>line-height的值</strong>*</p><p>默认是normal时，行之间的距离是由用户代理来确定，不同的用户代理可能不同，不过一般是font-size的1.2倍，因此行高一般会比font-size大</p><p><strong>line-height的继承</strong></p><p>块级元素之间继承的line-height有点复杂，从父元素继承line-height值时，根据父元素的font-size进行计算，而不是根据子元素计算，</p><p>例如</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">line-height</span>:<span class="hljs-number">1em</span>;&#125;//<span class="hljs-number">10px</span>;<span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">18px</span>;&#125;</code></pre></div><p>Line-height使用纯数字的时候<code>line-height:1;</code>，纯数字就会应用到当前元素及其子元素上，元素的line-heigh将根据自身的font-size*1来计算</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">div</span>&#123;line-height:<span class="hljs-number">1</span>.<span class="hljs-number">5</span>&#125;<span class="hljs-attribute">p</span>&#123;font-size:<span class="hljs-number">18</span>px&#125;  //继承得到的line-height=<span class="hljs-number">18</span>*<span class="hljs-number">1</span>.<span class="hljs-number">5</span>px</code></pre></div><p>如果把line-height：inherit，元素的line-height将变成父元素line-height的计算值。</p><h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><p>Vertical-align只能用于置换元素如img，input等和行内元素，vertical-align不是继承属性</p><p>取值  baseline sub super top text-top middle bottom text-bottom 具体数值。百分比</p><p>初始值 baseline</p><p>适用于 行内元素和单元格</p><p>百分数。相对于元素的line-height的值</p><p>计算值 百分数和长度值，得到绝对长度，否则是指定的值</p><p>继承性 否</p><p>动画性 具体数值，百分比</p><p>备注。用于单元格上时，只能取baseline，top ，middle，bottom</p><p><strong>baseline</strong></p><p>强制元素的基线和父元素的基线对齐，正常情况下，一行中所有文本元素的底端都是对齐的</p><p>如果目标元素没有基线，像表单，图像，表单输入框，或者其他置换元素，元素底端和父元素的基线对齐</p><p><strong>sub</strong></p><p>sub把元素放在下标处，即元素的基线，对于置换元素来说就是底边线，低于父元素的基线，规范没有定义下沉🉐️距离，因此在不同🉐️1用户代理可能不同，super的·作用和sub相反，让元素的基线或者置换元素的底边线高于父元素的基线，高出的距离由用户代理来决定。</p><p>sub和super不会改变元素的font-size</p><p><strong>bottom</strong></p><p>bottom把元素所在的行内框的底边和行框的底边对齐。</p><p><strong>top</strong></p><p>top和bottom相反</p><p><strong>middle</strong></p><p>middle通常用于image上，middle把行内元素所在方框的中线与父元素基线向上偏移0.5ex处的线对齐，(1ex相当于父元素的font-size)</p><p>多数用户代理把1ex视作是半个em，因此middle把行内元素所在方框的中线与父元素基线向上偏移1/4em</p><p><strong>百分数</strong></p><p>百分数的效果是把元素的基线或者置换元素的底边相对于父元素的基线抬升或者下沉指定的量，指定的百分数是相对于元素自身而非父元素的line- height计算，</p><p>提升或者下沉文本不会和其他行重叠，，纵向对齐元素可能会改变行高，行框是包含最高的那个行内框的顶端和最低那个行内框的底端，这包括verticle-aligh的高度</p><h3 id="word-sapcing-单词间距"><a href="#word-sapcing-单词间距" class="headerlink" title="word-sapcing 单词间距"></a>word-sapcing 单词间距</h3><p>取值   具体数值 normal</p><p>默认值 normal</p><p>适用于所有元素</p><p>计算值 normal的绝对长度为0 否则为指定的具体的长度</p><p>继承性 是</p><p>动画性 是</p><h3 id="letter-spacing-字符间距"><a href="#letter-spacing-字符间距" class="headerlink" title="letter-spacing 字符间距"></a>letter-spacing 字符间距</h3><p>取值 具体数值 normal</p><p>初始值 normal</p><p>适用于 所有元素</p><p>计算值 长度得到绝对长度，否则是normal</p><p>继承性 是</p><p>动画性 是</p><h3 id="对齐方式对间距的影响"><a href="#对齐方式对间距的影响" class="headerlink" title="对齐方式对间距的影响"></a>对齐方式对间距的影响</h3><p>word-spacing的宽度可能会受到text-align的影响，如果text-align为两端对齐，为了让文字沾满整行，可能会调整文字间的宽度，word-spacing可能被调整，letter-spacing如果是数值则没有影响，如果是noraml，可能会改变距离。word-spacing和letter-spacing继承的都是计算后的值，而不是换算系数。为了让字符之间的间距和font-size成比例，必须给元素自身设置letter-spacing</p><h3 id="text-transform-文本转换"><a href="#text-transform-文本转换" class="headerlink" title="text-transform 文本转换"></a>text-transform 文本转换</h3><p>取值 uppercase lowercase capitalize none</p><p>初始值 none</p><p>适用于 所有值</p><p>计算值 指定值</p><p>继承性 是</p><p>动画性 是</p><h3 id="text-decoration-文本装饰"><a href="#text-decoration-文本装饰" class="headerlink" title="text-decoration 文本装饰"></a>text-decoration 文本装饰</h3><p>取值 none ｜underline ｜overline ｜line-through ｜ blink</p><p>初始值 none</p><p>适用于 所有元素</p><p>计算值 指定值</p><p>继承性 否</p><p>动画性 否</p><p>在一个规则中可以有多个装饰结果，如果有让a标签既有上划线又有下划线</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">text-decoration</span>:underline overline;&#125;</code></pre></div><p>如果是在同一个元素上使用多个text-decoration，注意特指度</p><p>text-decoration不能够被继承</p><p>text-decoration和vertical-align同时使用，还会发生奇怪的事情，例如</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">text-decoration</span>:overline;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12pt</span>;&#125;<span class="hljs-selector-tag">sup</span> &#123;<span class="hljs-attribute">vertical-align</span>:<span class="hljs-number">50%</span>;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12pt</span>;&#125;</code></pre></div><p>p元素上有上划线，sup元素是p的子元素，所以会出现sup元素被上划线穿过的情况</p><h3 id="text-rendering"><a href="#text-rendering" class="headerlink" title="text-rendering"></a>text-rendering</h3><p>svg属性，支持他的用户代理不会把它视为一个css属性</p><h3 id="text-shadow-文本阴影"><a href="#text-shadow-文本阴影" class="headerlink" title="text-shadow 文本阴影"></a>text-shadow 文本阴影</h3><p>取值 none ｜数值｜数值 数值 数值？</p><p>初始值 none</p><p>适用于 所有元素</p><p>继承性 否</p><p>动画性 是</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">text</span>-shadow：颜色 行横偏移距离 纵向偏移距离 可选 模糊半径</code></pre></div><p>大量的阴影或者模糊半径的文本阴影会损耗性能，尤其是在低损耗和CPU性能有限的情况下，例如移动设备</p><h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><p>他会影响用户代理对文档中的空格，换行符，制表符的处理方式</p><p>取值 noraml nowrap  pre pre-wrap pre-line</p><p>适用于 全部元素，块级元素</p><p>计算值 指定值</p><p>继承性 否</p><p>动画性 否</p><table><thead><tr><th>值</th><th>空白</th><th>换行符</th><th>自动换行</th></tr></thead><tbody><tr><td>pre-line</td><td>折叠</td><td>保留</td><td>允许</td></tr><tr><td>normal</td><td>折叠</td><td>忽略</td><td>允许</td></tr><tr><td>nowrap</td><td>折叠</td><td>保留</td><td>禁止</td></tr><tr><td>pre</td><td>保留</td><td>保留</td><td>禁止</td></tr><tr><td>pre-wrap</td><td>保留</td><td>保留</td><td>允许</td></tr></tbody></table><h2 id="视觉格式化基础"><a href="#视觉格式化基础" class="headerlink" title="视觉格式化基础"></a>视觉格式化基础</h2><h3 id="元素框基础"><a href="#元素框基础" class="headerlink" title="元素框基础"></a>元素框基础</h3>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
      <category>CSS权威指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS权威指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十四章 算法设计与技巧</title>
    <link href="/2022/11/25/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/11/25/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h1><p>了归并和排序算法。两者的共同点在于它们都是分而治之算法。分而治之是算法设计中的一种方法。它将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题</p><p>分而治之算法可以分成三个部分</p><p>(1) 分解原问题为多个子问题（原问题的多个小实例）。</p><p>(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子</p><p>问题。</p><p>(3) 组合这些子问题的解决方式，得到原问题的解。</p><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>二分搜索也可以用分而治之的方式来实现</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearchRecursive</span>(<span class="hljs-params"></span><span class="hljs-params">  array,</span><span class="hljs-params">  value,</span><span class="hljs-params">  low,</span><span class="hljs-params">  high,</span><span class="hljs-params">  compareFn = defaultCompare</span><span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (low &lt;= high) &#123;    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((low + high) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">const</span> element = array[mid];    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(element, value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, mid + <span class="hljs-number">1</span>, high, compareFn);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(element, value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, low, mid - <span class="hljs-number">1</span>, compareFn);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> mid;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">DOES_NOT_ESIST</span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch2</span>(<span class="hljs-params">array, value, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> sortedArray = <span class="hljs-title function_">quickSort</span>(array);  <span class="hljs-keyword">const</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> high = sortedArray.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, low, high, compareFn);&#125;</code></pre></div><p>在上面的算法中，我们有两个函数：binarySearch 和 binarySearchRecursive。binarySearch 函数用来暴露给开发者进行二分搜索。binarySearchRecursive 是分而治之算法。我们将 low 参数以 0 传递，将 high 参数以 sortedArray.length - 1 传递，来在已排序的数组中进行搜索。在计算 mid 元素的索引值后，我们确定待搜索的值比 mid 大还是小。如果小（行{1}）或大（行{2}），就再次调用 binarySearchRecursive 函数，但是这次，我们在子数组中进行搜索，改变 low 或 high 参数（不同于我们在第 13 章中那样移动指针）。如果不大也不小，表示我们找到了这个值（行{3}）并且这就是一种基本情形。还有一种情况是 low比 high 要大，这表示算法没有找到这个值（行{4}）。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p><p>注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题</p><p>用动态规划解决问题时，要遵循三个重要步骤：</p><p>(1) 定义子问题；</p><p>(2) 实现要反复执行来解决子问题的部分；</p><p>(3) 识别并求解出基线条件。</p><p>能用动态规划解决的一些著名问题如下。</p><p>背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。</p><p>最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。</p><p>矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。</p><p>硬币找零：给出面额为 <em>d</em>1, …, <em>d**n</em>的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。</p><p>图的全源最短路径：对所有顶点对(<em>u</em>, <em>v</em>)，找出从顶点 <em>u</em> 到顶点 <em>v</em> 的最短路径。我们在第 9章已经学习过这个问题的 Floyd-Warshall 算法。</p><h2 id="最少硬币找零问题"><a href="#最少硬币找零问题" class="headerlink" title="最少硬币找零问题"></a>最少硬币找零问题</h2><p>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 <em>d</em>1, …, <em>d**n</em>及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 <em>d</em>1, …, <em>d**n</em>及其数量，找到所需的最少的硬币个数。</p><p>例如，美国有以下面额（硬币）：<em>d</em>1 = 1，<em>d</em>2 = 5，<em>d</em>3 = 10，<em>d</em>4 = 25。</p><p>如果要找 36 美分的零钱，我们可以用 1 个 25 美分、1 个 10 美分和 1 个便士（1 美分）。</p><p>如何将这个解答转化成算法？</p><p>最少硬币找零的解决方案是找到 <em>n</em> 所需的最小硬币数。但要做到这一点，首先得找到对每个</p><p><em>x</em> &lt; <em>n</em> 的解。然后，我们可以基于更小的值的解来求解</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minCoinChange</span>(<span class="hljs-params">coins, amount</span>) &#123;  <span class="hljs-keyword">const</span> cache = [];  <span class="hljs-keyword">const</span> <span class="hljs-title function_">makeChange</span> = (<span class="hljs-params">value</span>) =&gt; &#123;    <span class="hljs-keyword">if</span> (!value) &#123;      <span class="hljs-keyword">return</span> [];    &#125;    <span class="hljs-keyword">if</span> (cahce[value]) &#123;      <span class="hljs-keyword">return</span> cache[value];    &#125;    <span class="hljs-keyword">let</span> min = [];    <span class="hljs-keyword">let</span> newMin;    <span class="hljs-keyword">let</span> newAmount;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">const</span> coin = coins[i];      newAmount = value - coin;      <span class="hljs-keyword">if</span> (newAmount &gt;= <span class="hljs-number">0</span>) &#123;        newMin = <span class="hljs-title function_">makeChange</span>(newAmount);      &#125;      <span class="hljs-keyword">if</span> (        newAmount &gt;= <span class="hljs-number">0</span> &amp;&amp;        (newMin.<span class="hljs-property">length</span> &lt; min.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> || !min.<span class="hljs-property">length</span>) &amp;&amp;        (newMin.<span class="hljs-property">length</span> || !newAmount)      ) &#123;        min = [coin].<span class="hljs-title function_">concat</span>(newMin);        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;new Min &quot;</span> + min + <span class="hljs-string">&quot; for &quot;</span> + amount);      &#125;    &#125;    <span class="hljs-keyword">return</span> (cahce[value] = min);  &#125;;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">makeChange</span>(amount);&#125;</code></pre></div><p>minCoinChange 参数接收 coins 参数，该参数代表问题中的面额。对美国的硬币系统而言，它是[1, 5, 10, 25]。我们可以随心所欲地传递任何面额。此外，为了更加高效且不重复计算值，我们使用了 cache（这个技巧称为记忆化）。接下来是 minCoinChange 函数中的 makeChange 方法，它也是一个递归函数，用来解决问题。makeChange 函数在行{13}被调用，amount 作为参数传入。由于 makeChange是一个内部函数，它也能访问到 cache 变量。</p><p>为了进一步帮助我们，我们基于 coins 参数（面额）解决问题。因此，对每个面额，我们都计算 newAmount的值，它的值会一直减小，直到能找零的最小钱数（别忘了本算法对所有的 x &lt; amount 都会计算 makeChange 结果）。若 newAmount 是合理的值（正值），</p><p>我们也会计算它的找零结果。最后，我们判断 newAmount 是否有效，minValue （最少硬币数）是否是最优解，与此同时 minValue 和 newAmount 是否是合理的值。若以上判断都成立，意味着有一个比之前更优的答案（——以 5 美分为例，可以给 5 便士或者 1 个 5 美分镍币，1 个 5 美分镍币是最优解）。最后，返回最终结果。</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 <em>W</em> 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过<em>W</em>，且总价值最大</p><p>下面是一个例子。</p><table><thead><tr><th>物品</th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>4</td></tr><tr><td>3</td><td>4</td><td>5</td></tr></tbody></table><p>考虑背包能够携带的重量只有 5。对于这个例子，我们可以说最佳解决方案是往背包里装入物品 1 和物品 2。这样，总重量为 5，总价值为 7</p><p>这个问题有两个版本。<strong>0-1</strong> 版本只能往背包里装完整的物品，而<strong>分数背包问题</strong>则允许装入分数物品。在这个例子里，我们将处理该问题的 0-1 版本。动态规划对分数版本无能为力，但本章稍后要学习的贪心算法可以解决它。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 0-1背包问题</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">knapSack</span>(<span class="hljs-params">capacity, weights, values, n</span>) &#123;  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">KS</span> = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;    <span class="hljs-comment">//&#123;1&#125;</span>    <span class="hljs-variable constant_">KS</span>[i] = [];  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> w = <span class="hljs-number">0</span>; w &lt;= capacity; w++) &#123;      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || w === <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//&#123;2&#125;</span>        <span class="hljs-variable constant_">KS</span>[i][w] = <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (weights[i - <span class="hljs-number">1</span>] &lt;= w) &#123;        <span class="hljs-comment">//&#123;3&#125;</span>        <span class="hljs-keyword">const</span> a = values[i - <span class="hljs-number">1</span>] + <span class="hljs-variable constant_">KS</span>[i - <span class="hljs-number">1</span>][w - weights[i - <span class="hljs-number">1</span>]];        <span class="hljs-keyword">const</span> b = <span class="hljs-variable constant_">KS</span>[i - <span class="hljs-number">1</span>][w];        <span class="hljs-variable constant_">KS</span>[i][w] = a &gt; b ? a : b; <span class="hljs-comment">// &#123;4&#125; max(a,b)</span>      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable constant_">KS</span>[i][w] = <span class="hljs-variable constant_">KS</span>[i - <span class="hljs-number">1</span>][w]; <span class="hljs-comment">// &#123;5&#125;</span>      &#125;    &#125;  &#125;  <span class="hljs-title function_">findValues</span>(n, capacity, <span class="hljs-variable constant_">KS</span>, weights, values); <span class="hljs-comment">// &#123;6&#125; 增加的代码</span>  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">KS</span>[n][capacity]; <span class="hljs-comment">// &#123;7&#125;</span>&#125;</code></pre></div><p>我们可以用开头的例子来测试这个算法。</p><div class="code-wrapper"><pre><code class="hljs reasonml">const values = <span class="hljs-literal">[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</span>, weights = <span class="hljs-literal">[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span>, capacity = <span class="hljs-number">5</span>, n = values.length; console.log(knap<span class="hljs-constructor">Sack(<span class="hljs-params">capacity</span>, <span class="hljs-params">weights</span>, <span class="hljs-params">values</span>, <span class="hljs-params">n</span>)</span>); <span class="hljs-comment">// 输出 7</span></code></pre></div><p>请注意，这个算法只输出背包携带物品价值的最大值，而不列出实际的物品。我们可以增加下面的附加函数来找出构成解决方案的物品。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findValues</span>(<span class="hljs-params">n, capacity, KS, weights, values</span>) &#123;  <span class="hljs-keyword">let</span> i = n;  <span class="hljs-keyword">let</span> k = capacity;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;构成解的物品：&quot;</span>);  <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">KS</span>[i][k] !== <span class="hljs-variable constant_">KS</span>[i - <span class="hljs-number">1</span>][k]) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(        <span class="hljs-string">`物品 <span class="hljs-subst">$&#123;i&#125;</span> 可以是解的一部分 w,v: <span class="hljs-subst">$&#123;weights[i - <span class="hljs-number">1</span>]&#125;</span>, <span class="hljs-subst">$&#123;values[i - <span class="hljs-number">1</span>]&#125;</span>`</span>      );      i--;      k -= <span class="hljs-variable constant_">LS</span>[i][k];    &#125; <span class="hljs-keyword">else</span> &#123;      i--;    &#125;  &#125;&#125;</code></pre></div><p>我们可以在 knapSack 函数的行{7}之前调用这个函数（在行{6}声明）。执行完整的算法，会得到如下输出。</p><p><strong>构成解的物品：</strong></p><p><strong>物品</strong> <strong>2</strong> <strong>可以是解的一部分</strong> <strong>w,v: 3,4</strong> </p><p><strong>物品</strong> <strong>1</strong> <strong>可以是解的一部分</strong> <strong>w,v: 2,3</strong> </p><p><strong>总价值</strong><strong>: 7</strong> </p><p>背包问题也可以写成递归形式。你可以在本书的源代码包中找到它的递归版本</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>另一个经常被当作编程挑战问题的动态规划问题是最长公共子序列（LCS）：找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//最长公共子序列</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">lcs</span>(<span class="hljs-params">wordX, wordY</span>) &#123;  <span class="hljs-keyword">const</span> m = wordX.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> n = wordY.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> l = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;    l[i] = []; <span class="hljs-comment">// &#123;1&#125;</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; i &lt;= n; j++) &#123;      l[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// &#123;2&#125;</span>    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || j === <span class="hljs-number">0</span>) &#123;        l[i][i] = <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wordX[i - <span class="hljs-number">1</span>] === wordY[j - <span class="hljs-number">1</span>]) &#123;        l[i][j] = l[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// &#123;3&#125;</span>      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> a = l[i - <span class="hljs-number">1</span>][j];        <span class="hljs-keyword">const</span> b = l[i][j - <span class="hljs-number">1</span>];        l[i][j] = a &gt; b ? a : b; <span class="hljs-comment">// &#123;4&#125; max(a,b)</span>      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> l[m][n]; <span class="hljs-comment">// &#123;5&#125;</span>&#125;</code></pre></div><p>如果比较背包问题和 LCS 算法，我们会发现两者非常相似。这项从顶部开始构建解决方案的技术被称为记忆化，而解决方案就在表格或矩阵的右下角。</p><p>像背包问题算法一样，这种方法只输出 LCS 的长度，而不包含 LCS 的实际结果。要提取这个信息，需要对算法稍作修改，声明一个新的 solution 矩阵</p><p>注意，代码中有一些注释，我们需要用以下代码替换这些注释。</p><p> 行{1}：solution[i] = [];</p><p> 行{2}：solution[i][j] = ‘0’;</p><p> 行{3}：solution[i][j] = ‘diagonal’;</p><p> 行{4}：solution[i][j]=(l[i][j] == l[i-1][j]) ? ‘top’ : ‘left’;</p><p> 行{5}：printSolution(solution, wordX, m, n)</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printSolution</span>(<span class="hljs-params">solution, wordX, m, n</span>) &#123;  <span class="hljs-keyword">let</span> a = m;  <span class="hljs-keyword">let</span> b = n;  <span class="hljs-keyword">let</span> x = solution[a][b];  <span class="hljs-keyword">let</span> answer = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">while</span> (x !== <span class="hljs-string">&quot;0&quot;</span>) &#123;    <span class="hljs-keyword">if</span> (solution[a][b] === <span class="hljs-string">&quot;diagonal&quot;</span>) &#123;      answer = wordX[a - <span class="hljs-number">1</span>] + answer;      a--;      b--;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (solution[a][b] === <span class="hljs-string">&quot;left&quot;</span>) &#123;      b--;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (solution[a][b] === <span class="hljs-string">&quot;top&quot;</span>) &#123;      a--;    &#125;    x = solution[a][b];  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;lcs: &quot;</span> + answer);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lcs2</span>(<span class="hljs-params">wordX, wordY</span>) &#123;  <span class="hljs-keyword">const</span> m = wordX.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> n = wordY.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> solution = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;    solution[i] = []; <span class="hljs-comment">// &#123;1&#125;</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; i &lt;= n; j++) &#123;      solution[i][j] = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">// &#123;2&#125;</span>    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || j === <span class="hljs-number">0</span>) &#123;        solution[i][i] = <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wordX[i - <span class="hljs-number">1</span>] === wordY[j - <span class="hljs-number">1</span>]) &#123;        solution[i][j] = <span class="hljs-string">&quot;diagonal&quot;</span>; <span class="hljs-comment">// &#123;3&#125;</span>      &#125; <span class="hljs-keyword">else</span> &#123;        solution[i][j] = solution[i][j] == solution[i - <span class="hljs-number">1</span>][j] ? <span class="hljs-string">&quot;top&quot;</span> : <span class="hljs-string">&quot;left&quot;</span>; <span class="hljs-comment">// &#123;4&#125; max(a,b)</span>      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">printSolution</span>(solution, wordX, m, n); <span class="hljs-comment">// &#123;5&#125;</span>&#125;</code></pre></div><p>LCS 问题也可以写成递归形式。你可以在本书的源代码包中找到它的递归版本</p><h2 id="矩阵链相乘"><a href="#矩阵链相乘" class="headerlink" title="矩阵链相乘"></a>矩阵链相乘</h2><p>矩阵链相乘是另一个可以用动态规划解决的著名问题。这个问题是要找出一组矩阵相乘的最佳方式（顺序）。</p><p>让我们试着更好地理解这个问题。<em>n</em> 行 <em>m</em> 列的矩阵 <strong>A</strong> 和 <em>m</em> 行 <em>p</em> 列的矩阵 <strong>B</strong> 相乘，结果是 <em>n</em> 行 <em>p</em> 列的矩阵 <strong>C</strong>。</p><p>考虑我们想做 <strong>A</strong><em><strong>B</strong></em><strong>C</strong>*<strong>D</strong> 的乘法。因为乘法满足结合律，所以我们可以让这些矩阵以任意顺序相乘。因此，考虑如下情况：</p><p> <strong>A</strong> 是一个 10 行 100 列的矩阵；</p><p> <strong>B</strong> 是一个 100 行 5 列的矩阵；</p><p> <strong>C</strong> 是一个 5 行 50 列的矩阵；</p><p> <strong>D</strong> 是一个 50 行 1 列的矩阵；</p><p> <strong>A</strong><em><strong>B</strong></em><strong>C</strong>*<strong>D</strong> 的结果是一个 10 行 1 列的矩阵。</p><p>在这个例子里，相乘的方式有五种。</p><p>(1) (<strong>A</strong>(<strong>B</strong>(<strong>CD</strong>)))：乘法运算的次数是 1750 次。</p><p>(2) ((<strong>AB</strong>)(<strong>CD</strong>))：乘法运算的次数是 5300 次。</p><p>(3) (((<strong>AB</strong>)<strong>C</strong>)<strong>D</strong>)：乘法运算的次数是 8000 次。</p><p>(4) ((<strong>A</strong>(<strong>BC</strong>))<strong>D</strong>)：乘法运算的次数是 75 500 次。</p><p>(5) (<strong>A</strong>((<strong>BC</strong>)<strong>D</strong>))：乘法运算的次数是 31 000 次。</p><p>相乘的顺序不一样，要进行的乘法运算总数也有很大差异。那么，要如何构建一个算法，求出最少的乘法运算次数？矩阵链相乘的算法如下。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//矩阵链相乘</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">matrixChainOrder</span>(<span class="hljs-params">p</span>) &#123;  <span class="hljs-keyword">const</span> n = p.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> m = [];  <span class="hljs-keyword">const</span> s = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    m[i] = [];    m[i][i] = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = <span class="hljs-number">2</span>; l &lt; n; l++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n - l + <span class="hljs-number">1</span>; i++) &#123;      <span class="hljs-keyword">const</span> j = i + l - <span class="hljs-number">1</span>;      m[i][j] = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt;= j - <span class="hljs-number">1</span>; k++) &#123;        <span class="hljs-keyword">const</span> q = m[i][k] + m[k + <span class="hljs-number">1</span>][j] + p[i - <span class="hljs-number">1</span>] * p[k] * p[j]; <span class="hljs-comment">//&#123;1&#125;</span>        <span class="hljs-keyword">if</span> (q &lt; m[i][j]) &#123;          m[i][j] = q; <span class="hljs-comment">//&#123;2&#125;</span>        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;</code></pre></div><p>整个算法中最重要的是行{1}，神奇之处全都在这一行。它计算了给定括号顺序的乘法运算次数，并将值保存在辅助矩阵 m 中。对开头的例子执行上面的算法，会得到结果 1750。正如我们前面提到的，这是最少的运算次数。看看下面的代码。</p><div class="code-wrapper"><pre><code class="hljs arcade">const p = [<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">5</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>]; <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(matrixChainOrder(p));</code></pre></div><p>然而，这个算法也不会给出最优解的括号顺序。为了得到这些信息，我们可以对代码做一些改动。</p><p>首先，需要通过以下代码声明并初始化一个辅助矩阵 s。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = []; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;  s[i] = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>; j &lt;= n; j++)&#123;  s[i][j] = <span class="hljs-number">0</span>;  &#125; &#125;</code></pre></div><p>然后，在 matrixChainOrder 函数的行{2}添加下面的代码。</p><div class="code-wrapper"><pre><code class="hljs js">s[i][j] = k;</code></pre></div><p>在行{3}，我们调用打印括号的函数，如下所示。</p><div class="code-wrapper"><pre><code class="hljs reasonml">print<span class="hljs-constructor">OptimalParenthesis(<span class="hljs-params">s</span>, 1, <span class="hljs-params">n</span>-1)</span>;</code></pre></div><p>最后，我们的 printOptimalParenthesis 函数如</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printOptimalParenthesis</span>(<span class="hljs-params">s, i, j</span>) &#123;  <span class="hljs-keyword">if</span> (i === j) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;(&quot;</span>);    <span class="hljs-title function_">printOptimalParenthesis</span>(s, i, s[i][j]);    <span class="hljs-title function_">printOptimalParenthesis</span>(s, s[i][j] + <span class="hljs-number">1</span>, j);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;)&quot;</span>);  &#125;&#125;</code></pre></div><p>执行修改后的算法，也能得到括号的最佳顺序(A<a href="A%5B2%5D(A%5B3%5DA%5B4%5D)">1</a>)，并可以转化为(A(B(CD)))。</p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。我们来看看如何用贪心算法解决动态规划话题中最少硬币找零问题和背包问题</p><p>我们在第 12 章介绍了一些其他的贪心算法，比如 Dijkstra 算法、Prim 算法和Kruskal 算法。</p><p>用贪心算法解决动态规划话题中最少硬币找零问题和背包问题</p><h2 id="最少硬币找零问题-1"><a href="#最少硬币找零问题-1" class="headerlink" title="最少硬币找零问题"></a>最少硬币找零问题</h2><p>最少硬币找零问题也能用贪心算法解决。大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minCoinChange</span>(<span class="hljs-params">coins, amount</span>) &#123;  <span class="hljs-keyword">const</span> change = [];  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = coins.<span class="hljs-property">length</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-comment">//&#123;1&#125;</span>    <span class="hljs-keyword">const</span> coin = coins[i];    <span class="hljs-keyword">while</span> (total + coin &lt;= amount) &#123;<span class="hljs-comment">//&#123;2&#125;</span>      change.<span class="hljs-title function_">push</span>(coin);<span class="hljs-comment">//&#123;3&#125;</span>      total += coin;<span class="hljs-comment">//&#123;4&#125;</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> change;&#125;</code></pre></div><p>不得不说贪心版本的 minCoinChange 比动态规划版本简单多了。对每个面额（行{1}——从大到小），把它的值和 total 相加后，total 需要小于 amount（行{2}）。我们会将当前面额coin 添加到结果中（行{3}），也会将它和 total 相加（行{4}）。</p><p>如你所见，这个贪心解法很简单。从最大面额的硬币开始，拿尽可能多的这种硬币找零。当无法再拿更多这种价值的硬币时，开始拿第二大价值的硬币，依次继续。</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(minCoinChange([<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">25</span>], <span class="hljs-number">36</span>))</code></pre></div><p>结果依然是[25, 10, 1]，和用 DP 得到的一样</p><p>然而，如果用[1, 3, 4]面额执行贪心算法，会得到结果[4, 1, 1]。如果用动态规划的解法，会得到最优的结果[3, 3]。</p><p>比起动态规划算法而言，贪心算法更简单、更快。然而，如我们所见，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。</p><h2 id="分数背包问题"><a href="#分数背包问题" class="headerlink" title="分数背包问题"></a>分数背包问题</h2><p>求解分数背包问题的算法与动态规划版本稍有不同。在 0-1 背包问题中，只能向背包里装入完整的物品，而在分数背包问题中，可以装入分数的物品。我们用前面用过的例子来比较两者的差异，如下所示。</p><table><thead><tr><th>物品</th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>4</td></tr><tr><td>3</td><td>4</td><td>5</td></tr></tbody></table><p>在动态规划的例子里，我们考虑背包能够携带的重量只有 5。在这个例子里，我们可以说最佳解决方案是往背包里装入物品 1 和物品 2，总重量为 5，总价值为 7。</p><p>如果在分数背包问题中考虑相同的容量，得到的结果是一样的。因此，我们考虑容量为 6 的情况。</p><p>在这种情况下，解决方案是装入物品 1 和物品 2，还有 25%的物品 3。这样，重量为 6 的物品总价值为 8.25</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">knapSack</span>(<span class="hljs-params">capacity, weights, values</span>) &#123;  <span class="hljs-keyword">const</span> n = values.<span class="hljs-property">length</span>;  <span class="hljs-keyword">let</span> load = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> val = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123; <span class="hljs-comment">// &#123;1&#125;</span>    <span class="hljs-keyword">if</span> (weights[i] &lt;= capacity - load) &#123; <span class="hljs-comment">// &#123;2&#125;</span>      val += values[i];      load += weights[i];    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">const</span> r = (capacity - load) / weights[i]; <span class="hljs-comment">// &#123;3&#125;</span>      val += r * values[i];      load += weights[i];    &#125;  &#125;  <span class="hljs-keyword">return</span> val;&#125;</code></pre></div><p>总重量少于背包容量（不能带超过容量的东西），我们会迭代物品（行{1}）。如果物品可以完整地装入背包（行{2}——小于等于背包容量），就将其价值和重量分别计入背包已装入物品的总价值（val）和总重量（load）。如果物品不能完整地装入背包，计算能够装入部分的比例（r）（行{3}——我们可以带的分数）</p><p>如果在 0-1 背包问题中考虑同样的容量 6，我们就会看到，物品 1 和物品 3 组成了解决方案。在这种情况下，对同一个问题应用不同的解决方法，会得到两种不同的结果。</p><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题</p><p>有一些可用回溯解决的著名问题：</p><p>骑士巡逻问题</p><p><em>N</em> 皇后问题</p><p>迷宫老鼠问题</p><p>数独解题器</p><h2 id="迷宫老鼠问题"><a href="#迷宫老鼠问题" class="headerlink" title="迷宫老鼠问题"></a>迷宫老鼠问题</h2><p>假设我们有一个大小为 <em>N</em> × <em>N</em> 的矩阵，矩阵的每个位置是一个方块。每个位置（或块）可以是空闲的（值为 1）或是被阻挡的（值为 0），如下图所示，其中 S 是起点，D 是终点</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2012.19.24.png"></p><p>矩阵就是迷宫，“老鼠”的目标是从位置[0][0]开始并移动到[n-1][n-1]（终点）。老鼠可以在垂直或水平方向上任何未被阻挡的位置间移动</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ratInAMaze</span>(<span class="hljs-params">maze</span>) &#123;  <span class="hljs-keyword">const</span> solution = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maze.<span class="hljs-property">length</span>; i++) &#123; <span class="hljs-comment">//&#123;1&#125;</span>    solution[i] = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; maze[i].<span class="hljs-property">length</span>; i++) &#123; <span class="hljs-comment">//&#123;2&#125;</span>      solution[i][j] = <span class="hljs-number">0</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">findPath</span>(maze, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, solution) === <span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">//&#123;3&#125;</span>    <span class="hljs-keyword">return</span> solution;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NO PATH FOUND&quot;</span>;&#125;</code></pre></div><p>首先创建一个包含解的矩阵。将每个位置初始化为零（行{1}）。对于老鼠采取的每步行动，我们将路径标记为 1。如果算法能够找到一个解（行{2}），就返回解决矩阵，否则返回一条错误信息（行{3}）。</p><p>然后，我们创建一个 findPath 方法，它会试着从位置 x 和 y 开始在给定的 maze 矩阵中找到一个解。和本章介绍的其他技巧一样，回溯技巧也使用了递归，这也是使这个算法有回溯能力的原因。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findPath</span>(<span class="hljs-params">maze, x, y, solution</span>) &#123;  <span class="hljs-keyword">const</span> n = maze.<span class="hljs-property">length</span>;  <span class="hljs-keyword">if</span> (x === n - <span class="hljs-number">1</span> &amp;&amp; y === n - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//&#123;4&#125;</span>    solution[x][y] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSafe</span>(maze, x, y) === <span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">//&#123;5&#125;</span>    solution[x][y] = <span class="hljs-number">1</span>; <span class="hljs-comment">//&#123;6&#125;</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">findPath</span>(maze, x + <span class="hljs-number">1</span>, y, solution)) &#123; <span class="hljs-comment">//&#123;7&#125;</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">findPath</span>(maze, x, y + <span class="hljs-number">1</span>, solution)) &#123; <span class="hljs-comment">//&#123;8&#125;</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    solution[x][y] = <span class="hljs-number">0</span>; <span class="hljs-comment">//&#123;9&#125;</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//&#123;10&#125;</span>&#125;</code></pre></div><p>算法的第一步是验证老鼠是否到达了终点（行{4}）。如果到了，就将最后一个位置标记为路径的一部分并返回 true，表示移动成功结束。如果不是最后一步，要验证老鼠能否安全移动至该位置（行{5}表示根据下面声明的 isSafe 方法判断出该位置空闲）。如果是安全的，我们将这步加入路径（行{6}）并试着在 maze 矩阵中水平移动（向右）到下一个位置（行{7}）。如果水平移动不可行，我们就试着垂直向下移动到下一个位置（行{8}）。如果水平和垂直都不能移动，那么将这步从路径中移除并回溯（行{9}），表示算法会尝试另一个可能的解。在算法尝试了所有可能的动作还是找不到解时，就返回 false（行{10}），表示这个问题无解。</p><div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isSafe</span>(<span class="hljs-params">maze, x, y</span>) &#123; <span class="hljs-keyword">const</span> n = maze.<span class="hljs-property">length</span>;  <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; maze[x][y] !== <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><p>用下面的代码进行测试。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> maze = [  [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] ]; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">ratInAMaze</span>(maze));</code></pre></div><p>输出如下。</p><div class="code-wrapper"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]]</code></pre></div><h2 id="数独解题器"><a href="#数独解题器" class="headerlink" title="数独解题器"></a>数独解题器</h2><p>数独是一个非常有趣的解谜游戏，也是史上最流行的游戏之一。目标是用数字 1～9 填满一个 9 × 9 的矩阵，要求每行和每列都由这九个数字构成。矩阵还包含了小方块（3 × 3 矩阵），它们同样需要分别用这九个数字填满。谜题在开始给出一个已填了部分数字的矩阵，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-02-04%2016.22.47.png"></p><p>数独解题器的回溯算法会尝试在每行每列中填入每个数字。和迷宫老鼠问题一样，我们从算法的主方法开始。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sudokuSolver</span>(<span class="hljs-params">matrix</span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">solveSudoku</span>(matrix) === <span class="hljs-literal">true</span>) &#123;  <span class="hljs-keyword">return</span> matrix;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;问题无解！&#x27;</span>; &#125;</code></pre></div><p>算法在找到解后会返回填满了缺失数字的矩阵，否则返回错误信息。现在，我们来看算法的主要逻辑。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">UNASSIGNED</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">solveSudoku</span>(<span class="hljs-params">matrix</span>) &#123;  <span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> checkBlankSpaces = <span class="hljs-literal">false</span>; <span class="hljs-comment">//是否空白</span>  <span class="hljs-keyword">for</span> (row = <span class="hljs-number">0</span>; row &lt; matrix.<span class="hljs-property">length</span>; row++) &#123; <span class="hljs-comment">//&#123;1&#125;</span>    <span class="hljs-keyword">for</span> (col = <span class="hljs-number">0</span>; col &lt;= matrix[row].<span class="hljs-property">length</span>; col++) &#123;      <span class="hljs-keyword">if</span> (matrix[row][col] === <span class="hljs-variable constant_">UNASSIGNED</span>) &#123;        checkBlankSpaces = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// &#123;2&#125;</span>        <span class="hljs-keyword">break</span>;      &#125;    &#125;    <span class="hljs-keyword">if</span> (checkBlankSpaces === <span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">// &#123;3&#125;</span>      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span> (checkBlankSpaces === <span class="hljs-literal">false</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &#123;4&#125;</span>  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>; num &lt;= <span class="hljs-number">9</span>; num++) &#123; <span class="hljs-comment">// &#123;5&#125;</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSafe</span>(matrix, row, col, num)) &#123;<span class="hljs-comment">// &#123;6&#125;</span>      matrix[row][col] = num; <span class="hljs-comment">// &#123;7&#125;</span>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">solveSudoku</span>(matrix)) &#123; <span class="hljs-comment">// &#123;8&#125;</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;      matrix[row][col] = <span class="hljs-variable constant_">UNASSIGNED</span>; <span class="hljs-comment">// &#123;9&#125;</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// &#123;10&#125;</span>&#125;</code></pre></div><p>第一步是验证谜题是否已被解决（行{1}）。如果没有空白的位置（值为 0 的位置），表示谜题已被完成（行{4}）。如果有空白位置（行{2}），我们要从两个循环中跳出（行{3}）并且 row和 col 变量会表示需要用 1～9 填写空白的位置。下面，算法会试着用 1～9 填写这个位置，一次填一个（行{5}）。我们会检查添加的数字是否符合规则（行{6}），也就是这个数字在这行、这列或在小矩阵（3 × 3 矩阵）中没有出现过。如果符合，我们就将这个数字填入（行{7}）并再次执行 solveSudoku 函数来尝试填写下一个位置（行{8}）。如果一个数字填在了不正确的位置，我们就再将这个位置标记为空（行{9}），并且算法会回溯（行{10}）再尝试一个其他数字</p><p>isSafe 声明如下，它包含检查填入的数字是否符合规则。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isSafe</span>(<span class="hljs-params">matrix, row, col, num</span>) &#123;  <span class="hljs-keyword">return</span> (    !<span class="hljs-title function_">usedInRow</span>(matrix, row, num) &amp;&amp;    !<span class="hljs-title function_">usedInCol</span>(matrix, col, num) &amp;&amp;    !<span class="hljs-title function_">usedInBox</span>(matrix, row - (row % <span class="hljs-number">3</span>), col - (col % <span class="hljs-number">3</span>), num)  );&#125;</code></pre></div><p>具体的检查声明如下。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">usedInRow</span>(<span class="hljs-params">matrix, row, num</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>; col &lt; matrix.<span class="hljs-property">length</span>; col++) &#123; <span class="hljs-comment">// &#123;11&#125;</span>    <span class="hljs-keyword">if</span> (matrix[row][col] === num) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">usedInCol</span>(<span class="hljs-params">matrix, col, num</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; matrix.<span class="hljs-property">length</span>; row++) &#123; <span class="hljs-comment">// &#123;12&#125;</span>    <span class="hljs-keyword">if</span> (matrix[row][col] === num) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">usedInBox</span>(<span class="hljs-params">matrix, boxStartRow, boxStartCol, num</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">3</span>; row++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> col = <span class="hljs-number">0</span>; col &lt; <span class="hljs-number">3</span>; col++) &#123;      <span class="hljs-keyword">if</span> (matrix[row + boxStartRow][col + boxStartCol] === num) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><p>首先，通过迭代矩阵中给定行 row 中的每个位置检查数字是否在行 row 中存在（行{11}）。然后，迭代所有的列来验证数字是否在给定的列中存在（行{12}）。最后的检查是通过迭代 3 × 3=矩阵中的所有位置来检查数字是否在小矩阵中存在（行{13}）</p><div class="code-wrapper"><pre><code class="hljs inform7">const sudokuGrid = <span class="hljs-comment">[ </span><span class="hljs-comment"> <span class="hljs-comment">[5, 3, 0, 0, 7, 0, 0, 0, 0]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[6, 0, 0, 1, 9, 5, 0, 0, 0]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[0, 9, 8, 0, 0, 0, 0, 6, 0]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[8, 0, 0, 0, 6, 0, 0, 0, 3]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[4, 0, 0, 8, 0, 3, 0, 0, 1]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[7, 0, 0, 0, 2, 0, 0, 0, 6]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[0, 6, 0, 0, 0, 0, 2, 8, 0]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[0, 0, 0, 4, 1, 9, 0, 0, 5]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[0, 0, 0, 0, 8, 0, 0, 7, 9]</span> </span><span class="hljs-comment">]</span>; console.log(sudokuSolver(sudokuGrid));结果<span class="hljs-comment">[<span class="hljs-comment">[5, 3, 4, 6, 7, 8, 9, 1, 2]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[6, 7, 2, 1, 9, 5, 3, 4, 8]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[1, 9, 8, 3, 4, 2, 5, 6, 7]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[8, 5, 9, 7, 6, 1, 4, 2, 3]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[4, 2, 6, 8, 5, 3, 7, 9, 1]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[7, 1, 3, 9, 2, 4, 8, 5, 6]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[9, 6, 1, 5, 3, 7, 2, 8, 4]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[2, 8, 7, 4, 1, 9, 6, 3, 5]</span>, </span><span class="hljs-comment"> <span class="hljs-comment">[3, 4, 5, 2, 8, 6, 1, 7, 9]</span>]</span></code></pre></div><h1 id="函数式编程简介"><a href="#函数式编程简介" class="headerlink" title="函数式编程简介"></a>函数式编程简介</h1><p>在命令式编程中，我们按部就班地编写程序代码，详细描述要完成的事情以及完成的顺序。</p><h2 id="函数式编程与命令式编程"><a href="#函数式编程与命令式编程" class="headerlink" title="函数式编程与命令式编程"></a>函数式编程与命令式编程</h2><p>以函数式范式进行开发并不简单，关键在于习惯这种范式的机制。我们编写一个例子来说明差异。</p><p>假设我们想打印一个数组中所有的元素。我们可以用命令式编程，声明的函数如下</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> printArray = <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array[i]);  &#125; &#125;; <span class="hljs-title function_">printArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);</code></pre></div><p>现在，我们试着把这个例子转换成函数式编程。在函数式编程中，函数就是摇滚明星。我们关注的重点是需要描述什么，而不是如何描述。回到这一句：“我们迭代数组，打印每一项。”那么，首先要关注的是迭代数据，然后进行操作，即打印数组项。下面的函数负责迭代数组。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> forEach = <span class="hljs-keyword">function</span> (<span class="hljs-params">array, action</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-title function_">action</span>(array[i]);  &#125;&#125;;</code></pre></div><p>接下来，要创建另一个负责把数组元素打印到控制台的函数（考虑为回调函数），如下所示</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> logItem = <span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);&#125;;</code></pre></div><p>最后，像下面这样使用声明的函数。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">forEach</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], logItem);</code></pre></div><ol><li>函数式编程的主要目标是描述数据，以及要对数据应用的转换。</li><li>在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。</li><li>函数和数据集合是函数式编程的核心。</li><li>在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。</li><li>在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本</li></ol><h2 id="ES2015-和函数式编程"><a href="#ES2015-和函数式编程" class="headerlink" title="ES2015+和函数式编程"></a>ES2015+和函数式编程</h2><p>有了 ES2015+的新功能，用 JavaScript 进行函数式编程就变得更加容易了</p><p>考虑我们要找出数组中最小的值。要用命令式编程完成这个任务，只要迭代数组，检查当前的最小值是否大于数组元素；如果是，就更新最小值，代码如下。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> findMinArray = <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>)&#123;  <span class="hljs-keyword">var</span> minValue = array[<span class="hljs-number">0</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;array.<span class="hljs-property">length</span>; i++)&#123;  <span class="hljs-keyword">if</span> (minValue &gt; array[i])&#123;  minValue = array[i];  &#125;  &#125;  <span class="hljs-keyword">return</span> minValue; &#125;; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findMinArray</span>([<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>])); <span class="hljs-comment">// 输出 4</span></code></pre></div><p>要用函数式编程完成相同的任务，可以使用 Math.min 函数，传入所有要比较的数组元素。我们可以像下面的例子里这样，使用 ES2015 的解构运算符（…），把数组转换成单个的元素。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> min_ = <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>)&#123;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...array) &#125;; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">min_</span>([<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>])); <span class="hljs-comment">// 输出 4</span></code></pre></div><p>使用 ES2015 的箭头函数，可以进一步简化上面的代码</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">min</span> = arr =&gt; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...arr); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">min</span>([<span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>]));</code></pre></div><p>我们可以用 ES2015 语法重写第一个示例。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">forEach</span> = (<span class="hljs-params">array, action</span>) =&gt; array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title function_">action</span>(item)); <span class="hljs-keyword">const</span> <span class="hljs-title function_">logItem</span> = (<span class="hljs-params">item</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);</code></pre></div><h2 id="JavaScript-函数式工具箱——map、filter-和-reduce"><a href="#JavaScript-函数式工具箱——map、filter-和-reduce" class="headerlink" title="JavaScript 函数式工具箱——map、filter 和 reduce"></a>JavaScript 函数式工具箱——<strong>map</strong>、<strong>filter</strong> 和 <strong>reduce</strong></h2><p>我们可以使用 map 函数，把一个数据集合转换或映射成另一个数据集合。先看一个命令式编程的例子</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> daysOfWeek = [  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125;,  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">7</span> &#125;,];<span class="hljs-keyword">let</span> daysOfWeekValues_ = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; daysOfWeek.<span class="hljs-property">length</span>; i++) &#123;  daysOfWeekValues_.<span class="hljs-title function_">push</span>(daysOfWeek[i].<span class="hljs-property">value</span>);&#125;</code></pre></div><p>再以函数式编程并使用 ES2015+语法来考虑同样的例子，代码如下</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> daysOfWeekValues = daysOfWeek.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">day</span> =&gt;</span> day.<span class="hljs-property">value</span>); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(daysOfWeekValues);</code></pre></div><p>我们可以使用 filter 函数过滤一个集合的值。下面来看一个例子。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> positiveNumbers_ = <span class="hljs-keyword">function</span> (<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">let</span> positive = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (array[i] &gt;= <span class="hljs-number">0</span>) &#123;      positive.<span class="hljs-title function_">push</span>(array[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> positive;&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">positiveNumbers_</span>([-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">2</span>]));</code></pre></div><p>我们可以把同样的代码写成函数式的</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">positiveNumbers</span> = (<span class="hljs-params">array</span>) =&gt; array.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> (num &gt;= <span class="hljs-number">0</span>)); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">positiveNumbers</span>([-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">2</span>]));</code></pre></div><p>我们也可以使用 reduce 函数，把一个集合归约成一个特定的值。比如，对一个数组中的值求和</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sumValues = <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">let</span> total = array[<span class="hljs-number">0</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i&lt;array.<span class="hljs-property">length</span>; i++) &#123;  total += array[i];  &#125;  <span class="hljs-keyword">return</span> total; &#125;; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumValues</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]));</code></pre></div><p>上面的代码也可以写成这样</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sum_ = <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>)&#123;  <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)&#123;  <span class="hljs-keyword">return</span> a + b;  &#125;) &#125;; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum_</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]));</code></pre></div><p>我们还可以把这些函数与 ES2015 的功能结合起来，比如解构运算符和箭头函数，代码如下</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = arr =&gt; arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]));</code></pre></div><p>我们再看另一个例子。考虑我们需要写一个函数，把几个数组连接起来。为此，可以创建另一个数组，用于存放其他数组的元素。可以执行以下命令式的代码。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mergeArrays_ = <span class="hljs-keyword">function</span>(<span class="hljs-params">arrays</span>)&#123;  <span class="hljs-keyword">const</span> count = arrays.<span class="hljs-property">length</span>;  <span class="hljs-keyword">let</span> newArray = [];  <span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; arrays[i].<span class="hljs-property">length</span>; j++)&#123;  newArray[k++] = arrays[i][j];  &#125;  &#125;  <span class="hljs-keyword">return</span> newArray; &#125;; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">mergeArrays_</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>]]));</code></pre></div><p>注意，在这个例子中，我们声明了变量，还使用了循环。现在，我们用 JavaScript 函数式编程把上面的代码重写如下</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mergeArraysConcat = <span class="hljs-keyword">function</span>(<span class="hljs-params">arrays</span>)&#123;  <span class="hljs-keyword">return</span> arrays.<span class="hljs-title function_">reduce</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">p,n</span>)&#123;  <span class="hljs-keyword">return</span> p.<span class="hljs-title function_">concat</span>(n);  &#125;); &#125;; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">mergeArraysConcat</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>]]));</code></pre></div><p>上面的代码完成了同样的任务，但它是面向函数的。我们也可以用 ES2015 使代码更加精简，如下所示。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mergeArrays</span> = (<span class="hljs-params">...arrays</span>) =&gt; [].<span class="hljs-title function_">concat</span>(...arrays); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">mergeArrays</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>]));</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十三章 排序和搜索算法</title>
    <link href="/2022/11/23/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/23/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Util.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">EQUALS</span>: <span class="hljs-number">0</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Swap</span>(<span class="hljs-params">array, a, b</span>) &#123;  <span class="hljs-keyword">const</span> temp = array[a];  array[a] = array[b];  array[b] = temp;&#125;<span class="hljs-comment">//es6写法  有一个公开的问题表示解构操作比正常的赋值操作性能更差</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">swap1</span> = (<span class="hljs-params">array, a, b</span>) =&gt;  ([array[a], array[b]] = [array[b], array[a]]);<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Colors</span> = &#123;  <span class="hljs-attr">WHITE</span>: <span class="hljs-number">0</span>,  <span class="hljs-attr">GREY</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">BLACK</span>: <span class="hljs-number">2</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">initialzecolor</span> = (<span class="hljs-params">vertices</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> color = &#123;&#125;;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vertices.<span class="hljs-property">length</span>; i++) &#123;    color[vertices[i]] = colors.<span class="hljs-property">WHITE</span>;  &#125;  <span class="hljs-keyword">return</span> color;&#125;;</code></pre></div><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//冒泡排序</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">array, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = o; i &lt; length; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - <span class="hljs-number">1</span>; j++) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(array[j], array[j + <span class="hljs-number">1</span>]) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;        <span class="hljs-title class_">Swap</span>(array, j, j + <span class="hljs-number">1</span>);      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 改进后的冒泡排序</span><span class="hljs-comment"> * 如果从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">modifiedBubbleSort</span>(<span class="hljs-params">array, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; length - i - <span class="hljs-number">1</span>; j++) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(array[j], array[j + <span class="hljs-number">1</span>]) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;        <span class="hljs-title class_">Swap</span>(array, j, j + <span class="hljs-number">1</span>);      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-comment">//冒泡排序的时间复杂读为O(n^2),冒泡排序是非分布式排序算法</span></code></pre></div><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//选择排序</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">array, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">let</span> minIndex;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) &#123;    minIndex = i;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; length; j++) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(array[minIndex], array[j]) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;        minIndex = j;      &#125;    &#125;    <span class="hljs-keyword">if</span> (minIndex !== i) &#123;      <span class="hljs-title class_">Swap</span>(array, minIndex, i);    &#125;  &#125;  <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 选择排序同样也是一个复杂度为 O(n2)的算法。和冒泡排序一样，它包含有嵌套的两个循环，</span><span class="hljs-comment">这导致了二次方的复杂度</span><span class="hljs-comment"> */</span></code></pre></div><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，</span><span class="hljs-comment">// 它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确</span><span class="hljs-comment">// 排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推。</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">array, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">let</span> temp;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;    <span class="hljs-keyword">let</span> j = i;    temp = array[i];    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-title function_">compareFn</span>(array[j - <span class="hljs-number">1</span>], temp) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      array[j] = array[j + <span class="hljs-number">1</span>];      j--;    &#125;    array[j] = temp;  &#125;  <span class="hljs-keyword">return</span> array;&#125;</code></pre></div><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//归并排序,归并排序是第一个可以实际使用的排序算法,归并排序是第一个可以实际使用的排序算法</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以</span><span class="hljs-comment">排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪</span><span class="hljs-comment">个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用</span><span class="hljs-comment">归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了</span><span class="hljs-comment">一个快速排序的变体</span><span class="hljs-comment"></span><span class="hljs-comment">归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只</span><span class="hljs-comment">有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</span><span class="hljs-comment"></span><span class="hljs-comment">由于是分治法，归并排序也是递归的。我们要将算法分为两个函数：第一个负责将一个大数</span><span class="hljs-comment">组分为多个小数组并调用用来排序的辅助函数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">array, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">const</span> &#123; length &#125; = array;    <span class="hljs-keyword">const</span> middle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(length / <span class="hljs-number">2</span>);    <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">mergeSort</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, middle), compareFn);    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">mergeSort</span>(array.<span class="hljs-title function_">slice</span>(middle, length), compareFn);    array.<span class="hljs-title function_">merge</span>(left, right, compareFn);  &#125;  <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right, compareFn</span>) &#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> result = [];  <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-property">length</span> &amp;&amp; j &lt; right.<span class="hljs-property">length</span>) &#123;    result.<span class="hljs-title function_">push</span>(      <span class="hljs-title function_">compareFn</span>(left[i], right[j]) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>        ? left[i++]        : right[j++]    );  &#125;  result.<span class="hljs-title function_">concat</span>(i &lt; left.<span class="hljs-property">length</span> ? left.<span class="hljs-title function_">slice</span>(i) : right.<span class="hljs-title function_">slice</span>(j));  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 快速排序</span><span class="hljs-comment"> * 快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度</span><span class="hljs-comment">为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组</span><span class="hljs-comment">分为较小的数组（但它没有像归并排序那样将它们分割开）。</span><span class="hljs-comment">(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。</span><span class="hljs-comment">(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移</span><span class="hljs-comment">动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后</span><span class="hljs-comment">交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元</span><span class="hljs-comment">之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。</span><span class="hljs-comment">(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的</span><span class="hljs-comment">子数组）重复之前的两个步骤，直至数组已完全排序。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">array, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">quick</span>(array, <span class="hljs-number">0</span>, array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, compareFn);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">quick</span>(<span class="hljs-params">array, left, right, compareFn</span>) &#123;  <span class="hljs-keyword">let</span> index;  <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) &#123;    index = <span class="hljs-title function_">parition</span>(array, left, right, compareFn);    <span class="hljs-keyword">if</span> (left &lt; index - <span class="hljs-number">1</span>) &#123;      <span class="hljs-title function_">quick</span>(array, left, index - <span class="hljs-number">1</span>, compareFn);    &#125;    <span class="hljs-keyword">if</span> (index &lt; right) &#123;      <span class="hljs-title function_">quick</span>(array, index, left, compareFn);    &#125;  &#125;  <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">parition</span>(<span class="hljs-params">array, left, right, compareFn</span>) &#123;  <span class="hljs-keyword">const</span> pivot = array[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((right + left) / <span class="hljs-number">2</span>)];  <span class="hljs-keyword">let</span> i = left;  <span class="hljs-keyword">let</span> j = right;  <span class="hljs-keyword">while</span> (i &lt;= j) &#123;    <span class="hljs-keyword">while</span> (<span class="hljs-title function_">compareFn</span>(array[i], pivot) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      i++;    &#125;    <span class="hljs-keyword">while</span> (<span class="hljs-title function_">compareFn</span>(array[j], pivot) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      j--;    &#125;    <span class="hljs-keyword">if</span> (i &lt;= j) &#123;      <span class="hljs-title class_">Swap</span>(array, i, j);    &#125;  &#125;  <span class="hljs-keyword">return</span> i;&#125;</code></pre></div><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//计数排序,计数排序是一种分布式排序，分布式排序使用已组织好的辅助数据结，构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始</span><span class="hljs-comment">// 数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序</span><span class="hljs-comment">// 后的结果数组。它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">countingSort</span>(<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &gt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">return</span> array;  &#125;  <span class="hljs-keyword">const</span> maxValue = <span class="hljs-title function_">findMaxValue</span>(array);  <span class="hljs-keyword">const</span> counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(maxValue + <span class="hljs-number">1</span>);  array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (!counts[item]) &#123;      <span class="hljs-comment">//如果值不存在则初始化</span>      count[item] = <span class="hljs-number">0</span>;    &#125;    count[item]++;  &#125;);  <span class="hljs-keyword">let</span> sortedIndex = <span class="hljs-number">0</span>;  counts.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">count, index</span>) =&gt;</span> &#123;    <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;      array[sortedIndex++] = index;      count--;    &#125;  &#125;);  <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">findMaxValue</span>(<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">let</span> max = array[<span class="hljs-number">0</span>];  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;    <span class="hljs-keyword">if</span> (max &lt; array[i]) &#123;      max = array[i];    &#125;  &#125;  <span class="hljs-keyword">return</span> max;&#125;</code></pre></div><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//桶排序</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），</span><span class="hljs-comment">再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行</span><span class="hljs-comment">排序。然后，它将所有的桶合并为结果数组</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">bucketSort</span>(<span class="hljs-params">array, bucketSize = <span class="hljs-number">5</span></span>) &#123;  <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">return</span> array;  &#125;  <span class="hljs-keyword">const</span> buckets = <span class="hljs-title function_">createBuckets</span>(array, bucketSize);  <span class="hljs-keyword">return</span> <span class="hljs-title function_">sortBuckets</span>(buckets);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createBuckets</span>(<span class="hljs-params">array, bucketSize</span>) &#123;  <span class="hljs-keyword">let</span> minValue = array[<span class="hljs-number">0</span>];  <span class="hljs-keyword">let</span> maxValue = array[<span class="hljs-number">0</span>];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (array[i] &lt; minValue) &#123;      minValue = array[i];    &#125;    <span class="hljs-keyword">if</span> (array[i] &gt; maxValue) &#123;      maxValue = array[i];    &#125;  &#125;  <span class="hljs-keyword">const</span> bucketCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>;  <span class="hljs-keyword">const</span> buckets = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;    buckets[i] = [];  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">const</span> bucketIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((array[i] - minValue) / bucketSize);    buckets[bucketIndex].<span class="hljs-title function_">push</span>(array[i]);  &#125;  <span class="hljs-keyword">return</span> buckets;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sortBuckets</span>(<span class="hljs-params">buckets</span>) &#123;  <span class="hljs-keyword">const</span> sortedArray = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buckets.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (buckets[i] != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-title function_">insertionSort</span>(buckets[i]);      sortedArray.<span class="hljs-title function_">push</span>(...buckets[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> sortedArray;&#125;</code></pre></div><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">radixSort</span>(<span class="hljs-params">array, radixBase = <span class="hljs-number">10</span></span>) &#123;  <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) &#123;    <span class="hljs-keyword">return</span> array;  &#125;  <span class="hljs-keyword">const</span> minValue = <span class="hljs-title function_">findMinValue</span>(array);  <span class="hljs-keyword">const</span> maxValue = <span class="hljs-title function_">findMaxValue</span>(array);  <span class="hljs-keyword">let</span> significantDigit = <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> ((maxValue - minValue) / significantDigit &gt;= <span class="hljs-number">1</span>) &#123;    array = <span class="hljs-title function_">countingSortForRadix</span>(array, radixBase, significantDigit, minValue);    significantDigit *= radixBase;  &#125;  <span class="hljs-keyword">return</span> array;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">countingSortForRadix</span>(<span class="hljs-params">array, radixBase, significantDigit, minValue</span>) &#123;  <span class="hljs-keyword">let</span> bucksIndex;  <span class="hljs-keyword">const</span> buckets = [];  <span class="hljs-keyword">const</span> aux = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; radixBase; i++) &#123;    buckets[i] = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;    bucksIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(      ((array[i] - minValue) / significantDigit) % radixBase    );    buckets[bucksIndex++];  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; radixBase; i++) &#123;    buckets[i] += buckets[i - <span class="hljs-number">1</span>];  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;    bucksIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(      ((array[i] - minValue) / significantDigit) % radixBase    );    aux[--buckets[bucketIndex]] = array[i];  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;    array[i] = aux[i];  &#125;  <span class="hljs-keyword">return</span> array;&#125;</code></pre></div><h2 id="顺序搜索"><a href="#顺序搜索" class="headerlink" title="顺序搜索"></a>顺序搜索</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 顺序搜索</span><span class="hljs-comment"> * 顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DOES_NOT_ESIST</span> = -<span class="hljs-number">1</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sequentialSearch</span>(<span class="hljs-params">array, value, equalFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">equalFn</span>(array[i], value) === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> i;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">DOES_NOT_ESIST</span>;&#125;</code></pre></div><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 二分搜索</span><span class="hljs-comment"> * 二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个 1～100 的数”的</span><span class="hljs-comment">游戏。我们每回应一个数，那个人就会说这个数是高了、低了还是对了。</span><span class="hljs-comment">这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。</span><span class="hljs-comment">(1) 选择数组的中间值。</span><span class="hljs-comment">(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。</span><span class="hljs-comment">(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。</span><span class="hljs-comment">(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">array, value, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> sortedArray = <span class="hljs-title function_">quickSort</span>(array);  <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> high = sortedArray.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (<span class="hljs-title function_">lesserOrEquals</span>(low, high, compareFn)) &#123;    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((low + high) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">const</span> element = <span class="hljs-title function_">sortedArray</span>(mid);    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(element, value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      low = mid + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(element, value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      high = mid - <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> mid;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">DOES_NOT_ESIST</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">lesserOrEquals</span>(<span class="hljs-params">low, high, compareFn</span>) &#123;  <span class="hljs-keyword">const</span> comp = <span class="hljs-title function_">compareFn</span>(low, high);  <span class="hljs-keyword">return</span> comp === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> || <span class="hljs-title class_">Compare</span>.<span class="hljs-property">EQUALS</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearchRecursive</span>(<span class="hljs-params"></span><span class="hljs-params">  array,</span><span class="hljs-params">  value,</span><span class="hljs-params">  low,</span><span class="hljs-params">  high,</span><span class="hljs-params">  compareFn = defaultCompare</span><span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (low &lt;= high) &#123;    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((low + high) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">const</span> element = array[mid];    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(element, value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, mid + <span class="hljs-number">1</span>, high, compareFn);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(element, value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, low, mid - <span class="hljs-number">1</span>, compareFn);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> mid;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">DOES_NOT_ESIST</span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch2</span>(<span class="hljs-params">array, value, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> sortedArray = <span class="hljs-title function_">quickSort</span>(array);  <span class="hljs-keyword">const</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> high = sortedArray.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, low, high, compareFn);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 第 10 章中，我们实现的 BinarySearchTree 类有一个 search 方法，和这个</span><span class="hljs-comment">二分搜索完全一样，只不过前者是针对树数据结构的。</span><span class="hljs-comment"> */</span></code></pre></div><h2 id="内插搜索"><a href="#内插搜索" class="headerlink" title="内插搜索"></a>内插搜索</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 内插搜索</span><span class="hljs-comment"> * 内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根</span><span class="hljs-comment">据要搜索的值检查数组中的不同地方</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">interpolationSearch</span>(<span class="hljs-params"></span><span class="hljs-params">  array,</span><span class="hljs-params">  value,</span><span class="hljs-params">  compareFn = defaultCompare,</span><span class="hljs-params">  equalFn = defaultEquals,</span><span class="hljs-params">  diffFn = defaultDiff</span><span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> &#123; length &#125; = array;  <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">let</span> high = length - <span class="hljs-number">1</span>;  <span class="hljs-keyword">let</span> position = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">let</span> delta = -<span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (    low &lt;= high &amp;&amp;    <span class="hljs-title function_">biggerOrEquals</span>(value, array[low], compareFn) &amp;&amp;    <span class="hljs-title function_">lesserOrEquals</span>(valuw, array[high], compareFn)  ) &#123;    position = low + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((high - low) * delta);    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">equalFn</span>(array[position], value)) &#123;      <span class="hljs-keyword">return</span> position;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(array[position], value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      low = position + <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      high = position - <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">DOES_NOT_ESIST</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">biggerOrEquals</span>(<span class="hljs-params">a, b, compareFn</span>) &#123;  <span class="hljs-keyword">const</span> comp = <span class="hljs-title function_">compareFn</span>(a, b);  <span class="hljs-keyword">return</span> comp === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span> || comp === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">EQUALS</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">lesserOrEquals</span>(<span class="hljs-params">a, b, compareFn</span>) &#123;  <span class="hljs-keyword">const</span> comp = <span class="hljs-title function_">compareFn</span>(a, b);  <span class="hljs-keyword">return</span> comp === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> || comp === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">EQUALS</span>;&#125;</code></pre></div><h2 id="Fisher-Yates-随机算法"><a href="#Fisher-Yates-随机算法" class="headerlink" title="Fisher-Yates 随机算法"></a>Fisher-Yates 随机算法</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Fisher-Yates 随机算法</span><span class="hljs-comment"> * 这个算法由 Fisher 和 Yates 创造，并由高德纳（Donald E. Knuth）在《计算机程序设计艺术》</span><span class="hljs-comment">系列图书①中推广</span><span class="hljs-comment">它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位</span><span class="hljs-comment">置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越</span><span class="hljs-comment">多，随机效果越差）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">array</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;    <span class="hljs-keyword">const</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));    <span class="hljs-title function_">swap</span>(array, i, randomIndex);  &#125;  <span class="hljs-keyword">return</span> array;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十二章 图</title>
    <link href="/2022/11/22/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%9B%BE/"/>
    <url>/2022/11/22/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Dictionary</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../Dictinoary/Dictionary.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Colors</span>, initialzecolor &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">Queue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../Queue/Queue.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">isDirected = <span class="hljs-literal">false</span></span>) &#123;    <span class="hljs-comment">//判断是否是有向还是无向</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDirected</span> = isDirected;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span> = [];    <span class="hljs-comment">//用字典进行映射</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dictionary</span>();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 用来向图中添加一个新的顶点（因为图实例化后是空的）</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">v</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">addVertex</span>(<span class="hljs-params">v</span>) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">includes</span>(v)) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">push</span>(v);      <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">set</span>(v, []);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 添加对应的边</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">v</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">w</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">addEdge</span>(<span class="hljs-params">v, w</span>) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(v)) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addVertex</span>(v);    &#125;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(w)) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addVertex</span>(w);    &#125;    !<span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(v).<span class="hljs-title function_">includes</span>(w) &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(v).<span class="hljs-title function_">push</span>(w);    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isDirected</span>) &#123;      !<span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(w).<span class="hljs-title function_">includes</span>(v) &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(w).<span class="hljs-title function_">push</span>(v);    &#125;  &#125;  <span class="hljs-title function_">getVertices</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>;  &#125;  <span class="hljs-title function_">getAdjList</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>.<span class="hljs-property">length</span>; i++) &#123;      s += <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.vertices[i]&#125;</span> -&gt; `</span>;      <span class="hljs-keyword">const</span> neighbors = <span class="hljs-variable language_">this</span>.<span class="hljs-property">adjList</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vertices</span>[i]);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; neighbors.<span class="hljs-property">length</span>; j++) &#123;        s += <span class="hljs-string">`<span class="hljs-subst">$&#123;neighbors[j]&#125;</span> `</span>;      &#125;      s += <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// &#123;18&#125;</span>    &#125;    <span class="hljs-keyword">return</span> s;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 广度优先搜索</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">breadthFirstSearch</span> = (<span class="hljs-params">graph, startVertex, callback</span>) =&gt; &#123;  <span class="hljs-comment">//获取图的结点</span>  <span class="hljs-keyword">const</span> vertices = graph.<span class="hljs-title function_">getVertices</span>();  <span class="hljs-comment">//获取图的结点映射</span>  <span class="hljs-keyword">const</span> adjList = graph.<span class="hljs-title function_">getAdjList</span>();  <span class="hljs-comment">//初始化</span>  <span class="hljs-keyword">const</span> color = <span class="hljs-title function_">initialzecolor</span>(vertices);  <span class="hljs-comment">//初始化队列</span>  <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();  <span class="hljs-comment">//入队</span>  queue.<span class="hljs-title function_">enqueue</span>(startVertex);  <span class="hljs-comment">//循环队列</span>  <span class="hljs-keyword">while</span> (!queue.<span class="hljs-title function_">isEmpty</span>()) &#123;    <span class="hljs-comment">//出队</span>    <span class="hljs-keyword">const</span> u = queue.<span class="hljs-title function_">dequeue</span>();    <span class="hljs-comment">//获取结点对应的映射</span>    <span class="hljs-keyword">const</span> neighbors = adjList.<span class="hljs-title function_">get</span>(u);    <span class="hljs-comment">//设置访问过的结点</span>    color[u] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">GREY</span>;    <span class="hljs-comment">//for循环映射</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; neighbors.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">const</span> w = neighbors[i];      <span class="hljs-comment">//如果该结点没有被访问过</span>      <span class="hljs-keyword">if</span> (color[w] === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">WHITE</span>) &#123;        <span class="hljs-comment">//设置为已访问过</span>        color[w] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">GREY</span>;        <span class="hljs-comment">//入队</span>        queue.<span class="hljs-title function_">enqueue</span>(w);      &#125;    &#125;    <span class="hljs-comment">//当该相关的映射全部入对即已访问过了，则标记</span>    color[u] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;    <span class="hljs-comment">//执行回调函数</span>    <span class="hljs-keyword">if</span> (callback) &#123;      <span class="hljs-title function_">callback</span>(u);    &#125;  &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用 BFS 寻找最短路径</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计）。</span><span class="hljs-comment">对于给定顶点 v，广度优先算法会访问所有与其距离为 1 的顶点，接着是距离为 2 的顶点，</span><span class="hljs-comment">以此类推。所以，可以用广度优先算法来解这个问题。我们可以修改 breadthFirstSearch 方</span><span class="hljs-comment">法以返回给我们一些信息：</span><span class="hljs-comment"> 从 v 到 u 的距离 distances[u]；</span><span class="hljs-comment"> 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">BFS</span> = (<span class="hljs-params">graph, startVertex</span>) =&gt; &#123;  <span class="hljs-comment">//获得所有的结点</span>  <span class="hljs-keyword">const</span> vertices = graph.<span class="hljs-title function_">getVertices</span>();  <span class="hljs-comment">//获得所有结点对应的映射</span>  <span class="hljs-keyword">const</span> adjList = graph.<span class="hljs-title function_">getAdjList</span>();  <span class="hljs-comment">//初始化数据</span>  <span class="hljs-keyword">const</span> color = <span class="hljs-title function_">initialzecolor</span>(vertices);  <span class="hljs-comment">//初始化队列</span>  <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();  <span class="hljs-comment">//定义起始结点到各个结点的距离</span>  <span class="hljs-keyword">const</span> distances = &#123;&#125;;  <span class="hljs-comment">//每个结点的前导结点</span>  <span class="hljs-keyword">const</span> predecessors = &#123;&#125;;  <span class="hljs-comment">//起始结点入队</span>  queue.<span class="hljs-title function_">enqueue</span>(startVertex);  <span class="hljs-comment">//初始化</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vertices.<span class="hljs-property">length</span>; i++) &#123;    distances[vertices[i]] = <span class="hljs-number">0</span>;    predecessors[vertices[i]] = <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-comment">//遍历队列</span>  <span class="hljs-keyword">while</span> (!queue.<span class="hljs-title function_">isEmpty</span>()) &#123;    <span class="hljs-keyword">const</span> u = queue.<span class="hljs-title function_">dequeue</span>();    <span class="hljs-keyword">const</span> neighbors = adjList.<span class="hljs-title function_">get</span>(u);    color[u] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">GREY</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; neighbors.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">const</span> w = neighbors[i];      <span class="hljs-keyword">if</span> (color[w] === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">WHITE</span>) &#123;        color[w] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">GREY</span>;        distances[w] = distances[u] + <span class="hljs-number">1</span>;        predecessors[w] = u;        queue.<span class="hljs-title function_">enqueue</span>(w);      &#125;    &#125;    color[u] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;  &#125;  <span class="hljs-keyword">return</span> &#123;    distances,    predecessors,  &#125;;&#125;;<span class="hljs-comment">//深度优先遍历算法</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">depthFirstSearch</span> = (<span class="hljs-params">graph, callback</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> vertices = graph.<span class="hljs-title function_">getVertices</span>();  <span class="hljs-keyword">const</span> adjList = graph.<span class="hljs-title function_">getAdjList</span>();  <span class="hljs-keyword">const</span> color = <span class="hljs-title function_">initialzecolor</span>(vertices);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vertices.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (color[vertices[i]] === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">WHITE</span>) &#123;      <span class="hljs-title function_">depthFirstSearchVisit</span>(vertices[i], color, adjList, callback);    &#125;  &#125;&#125;;<span class="hljs-keyword">const</span> <span class="hljs-title function_">depthFirstSearchVisit</span> = (<span class="hljs-params">u, color, adjList, callback</span>) =&gt; &#123;  color[u] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">GREY</span>;  <span class="hljs-keyword">if</span> (callback) &#123;    <span class="hljs-title function_">callback</span>(u);  &#125;  <span class="hljs-keyword">const</span> neighbors = adjList.<span class="hljs-title function_">get</span>(u);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; neighbors.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">const</span> w = neighbors[i];    <span class="hljs-keyword">if</span> (color[w] === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">WHITE</span>) &#123;      <span class="hljs-title function_">depthFirstSearchVisit</span>(w, color, adjList, callback);    &#125;  &#125;  color[u] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 我们可以用该算法做更多的事情，而不只是输出被访问顶点的顺序。对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树</span><span class="hljs-comment">的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。我们可以修改 depthFirstSearch 函数来返回一些信息：</span><span class="hljs-comment"> 顶点 u 的发现时间 d[u]；</span><span class="hljs-comment"> 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]； </span><span class="hljs-comment"> 顶点 u 的前溯点 p[u]。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">DFS</span> = (<span class="hljs-params">graph, callback</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> vertices = graph.<span class="hljs-title function_">getVertices</span>();  <span class="hljs-keyword">const</span> adjList = graph.<span class="hljs-title function_">getAdjList</span>();  <span class="hljs-keyword">const</span> color = <span class="hljs-title function_">initialzecolor</span>(vertices);  <span class="hljs-comment">//结点的发现时间</span>  <span class="hljs-keyword">const</span> d = &#123;&#125;;  <span class="hljs-comment">//子结点遍历玩的时间</span>  <span class="hljs-keyword">const</span> f = &#123;&#125;;  <span class="hljs-comment">//前置结点</span>  <span class="hljs-keyword">const</span> p = &#123;&#125;;  <span class="hljs-comment">//计时</span>  <span class="hljs-keyword">const</span> time = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;  <span class="hljs-comment">//初始化每个结点</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vertices.<span class="hljs-property">length</span>; i++) &#123;    d[vertices[i]] = <span class="hljs-number">0</span>;    f[vertices[i]] = <span class="hljs-number">0</span>;    p[vertices[i]] = <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vertices.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (color[vertices[i]] === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">WHITE</span>) &#123;      <span class="hljs-title class_">DFSVisit</span>(vertices[i], color, d, f, p, time, adjList);    &#125;  &#125;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">discovery</span>: d,    <span class="hljs-attr">finished</span>: f,    <span class="hljs-attr">predecessors</span>: p,  &#125;;&#125;;<span class="hljs-keyword">const</span> <span class="hljs-title function_">DFSVisit</span> = (<span class="hljs-params">u, color, d, f, p, time, adjList</span>) =&gt; &#123;  color[u] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">GREY</span>;  d[u] = ++time.<span class="hljs-property">count</span>;  <span class="hljs-keyword">const</span> neighbors = adjList.<span class="hljs-title function_">get</span>(u);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; neighbors.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">const</span> w = neighbors[i];    <span class="hljs-keyword">if</span> (color[w] === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">WHITE</span>) &#123;      p[w] = u;      <span class="hljs-title class_">DFSVisit</span>(w, color, d, f, p, time, adjList);    &#125;  &#125;  color[u] = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;  f[u] = ++time.<span class="hljs-property">count</span>;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 对于改进过的深度优先搜索，有两点需要我们注意</span><span class="hljs-comment"> * 时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；</span><span class="hljs-comment"> * 对于所有的顶点 u，d[u]&lt;f[u]（意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了）</span><span class="hljs-comment"> * 在这两个假设下，我们有如下的规则。1 &lt;= d [u] &lt; f [u] &lt;= 2|V|</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 拓扑排序——使用深度优先搜索</span><span class="hljs-comment"> */</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十一章 二叉队和堆排序</title>
    <link href="/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E4%BA%8C%E5%8F%89%E9%98%9F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E4%BA%8C%E5%8F%89%E9%98%9F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉队和堆排序"><a href="#二叉队和堆排序" class="headerlink" title="二叉队和堆排序"></a>二叉队和堆排序</h1><h2 id="Util-js"><a href="#Util-js" class="headerlink" title="Util.js"></a>Util.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Swap</span>(<span class="hljs-params">array, a, b</span>) &#123;  <span class="hljs-keyword">const</span> temp = array[a];  array[a] = array[b];  array[b] = temp;&#125;<span class="hljs-comment">//es6写法  有一个公开的问题表示解构操作比正常的赋值操作性能更差</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">swap1</span> = (<span class="hljs-params">array, a, b</span>) =&gt;  ([array[a], array[b]] = [array[b], array[a]]);</code></pre></div><h2 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare, <span class="hljs-title class_">Swap</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinHeap</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compareFn</span> = compareFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span> = [];  &#125;  <span class="hljs-comment">//获取左侧节点的位置</span>  <span class="hljs-title function_">getLeftIndex</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-comment">//获取右侧结点的位置</span>  <span class="hljs-title function_">getRightIndex</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;  &#125;  <span class="hljs-comment">//获取父节点的位置</span>  <span class="hljs-title function_">getParentIndex</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 这个方法向堆中插入一个新的值。如果插入成功，它返回 true，否则返回 false</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">value</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-title function_">push</span>(value);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">siftUp</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">//表示我们将要将这个值和它的父节点进行交换，直到父节点小于这个插入的值。这个上移操作也被称为 up head、percolate up、bubble up、heapify up 或 cascade up</span>  <span class="hljs-title function_">siftUp</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-comment">//获取父节点的索引</span>    <span class="hljs-keyword">let</span> parent = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getParentIndex</span>(index);    <span class="hljs-comment">//小根堆做法</span>    <span class="hljs-keyword">while</span> (      index &gt; <span class="hljs-number">0</span> &amp;&amp;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[parent], <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[index]) ===        <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>    ) &#123;      <span class="hljs-title class_">Swap</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>, paren, index);      index = parent;      parent = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getParentIndex</span>(index);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 移除最小值(小根堆)或者最大值(大根堆)并且返回该值</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">extract</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-title function_">shift</span>();    &#125;    <span class="hljs-keyword">const</span> removedValue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-title function_">shift</span>();    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">siftDown</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> removedValue;  &#125;  <span class="hljs-title function_">siftDown</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">let</span> element = index;    <span class="hljs-keyword">const</span> left = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getLeftIndex</span>(index);    <span class="hljs-keyword">const</span> right = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRightIndex</span>(index);    <span class="hljs-keyword">const</span> size = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>();    <span class="hljs-keyword">if</span> (      left &lt; size &amp;&amp;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[element], <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[left]) ===        <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>    ) &#123;      element = left;    &#125;    <span class="hljs-keyword">if</span> (      left &lt; size &amp;&amp;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[element], <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[right]) ===        <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>    ) &#123;      element = right;    &#125;    <span class="hljs-keyword">if</span> (index !== element) &#123;      <span class="hljs-title class_">Swap</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>, index, element);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">siftDown</span>(element);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回小根堆的最小值或者大根堆的最大值但不会删除该值</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">findMinimum</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[<span class="hljs-number">0</span>] : <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-property">length</span>;  &#125;  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">0</span>;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十章 树</title>
    <link href="/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%A0%91/"/>
    <url>/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-comment">//util.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;</code></pre></div><p>//</p><h2 id="树的基本构造"><a href="#树的基本构造" class="headerlink" title="树的基本构造"></a>树的基本构造</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key; <span class="hljs-comment">//节点值</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">//左侧子节点引用</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">//右侧节点引用</span>  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compareFn</span> = compareFn; <span class="hljs-comment">//用来比较节点的值</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">//node类型的根节点</span>  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 向树中插入一个新的键</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);    &#125;  &#125;  <span class="hljs-title function_">insertNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span>) &#123;        node.<span class="hljs-property">left</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">left</span>, key);      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;        node.<span class="hljs-property">right</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">right</span>, key);      &#125;    &#125;  &#125;  <span class="hljs-title function_">serachNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">serachNode</span>(node.<span class="hljs-property">left</span>, key);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">serachNode</span>(node.<span class="hljs-property">right</span>, key);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 在树中查找一个键。如果节点存在，则返回 true；如果不存在，则返回false</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">search</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">serachNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);  &#125;  <span class="hljs-title function_">inOrderTraverseNode</span>(<span class="hljs-params">node, callback</span>) &#123;    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inOrderTraverseNode</span>(node.<span class="hljs-property">left</span>, callback);      <span class="hljs-title function_">callback</span>(node.<span class="hljs-property">key</span>);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inOrderTraverseNode</span>(node.<span class="hljs-property">right</span>, callback);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 通过中序遍历方式遍历所有节点</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">inOrderTraverse</span>(<span class="hljs-params">callback</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inOrderTraverseNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, callback);  &#125;  <span class="hljs-title function_">preOrderTraverseNode</span>(<span class="hljs-params">node, callback</span>) &#123;    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-title function_">callback</span>(node.<span class="hljs-property">key</span>);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preOrderTraverseNode</span>(node.<span class="hljs-property">left</span>, callback);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preOrderTraverseNode</span>(node.<span class="hljs-property">right</span>, callback);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 通过先序遍历方式遍历所有节点</span><span class="hljs-comment">   * preOrderTraverse</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">preOrderTraverse</span>(<span class="hljs-params">callback</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preOrderTraverseNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, callback);  &#125;  <span class="hljs-title function_">postOrderTraverseNode</span>(<span class="hljs-params">node, callback</span>) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postOrderTraverseNode</span>(node.<span class="hljs-property">left</span>, callback);    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postOrderTraverseNode</span>(node.<span class="hljs-property">right</span>, callback);    <span class="hljs-title function_">callback</span>(node.<span class="hljs-property">key</span>);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 通过后序遍历方式遍历所有节点</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">postOrderTraverse</span>(<span class="hljs-params">callback</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postOrderTraverseNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, callback);  &#125;  <span class="hljs-title function_">minNode</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">let</span> current = node;    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">left</span> != <span class="hljs-literal">null</span>) &#123;      current = current.<span class="hljs-property">left</span>;    &#125;    <span class="hljs-keyword">return</span> current;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回树中最小的值/键</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">min</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">minNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>);  &#125;  <span class="hljs-title function_">maxNode</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">let</span> current = node;    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">right</span> != <span class="hljs-literal">null</span>) &#123;      current = current.<span class="hljs-property">right</span>;    &#125;    <span class="hljs-keyword">return</span> current;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回树中最大的值/键</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">max</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">maxNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>);  &#125;  <span class="hljs-title function_">removeNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      node.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeNode</span>(node.<span class="hljs-property">left</span>, key);      <span class="hljs-keyword">return</span> node;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeNode</span>(node.<span class="hljs-property">right</span>, key);      <span class="hljs-keyword">return</span> node;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//第一种情况，是删除叶节点</span>      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;        node = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> node;        <span class="hljs-comment">//第二种情况左子树为null</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span>) &#123;        node = node.<span class="hljs-property">right</span>;        <span class="hljs-keyword">return</span> node;        <span class="hljs-comment">//第三种情况右子树为null</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;        node = node.<span class="hljs-property">left</span>;        <span class="hljs-keyword">return</span> node;        <span class="hljs-comment">//第四种情况，左右子树都存在，需要找到右子树的自小节点或者左子树的最大节点来替换node</span>      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> aux = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">minNode</span>(node.<span class="hljs-property">right</span>);        node.<span class="hljs-property">key</span> = aux.<span class="hljs-property">key</span>;        node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeNode</span>(node.<span class="hljs-property">right</span>, aux.<span class="hljs-property">key</span>);        <span class="hljs-keyword">return</span> node;      &#125;    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 从树中移除某个键</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);  &#125;&#125;</code></pre></div><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">BinarySearchTree</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Node</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">BalancerFactor</span> = &#123;  <span class="hljs-attr">UNBALANCED_RIGHT</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">SLIGHTLY_UNBALANCED_RIGHT</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">BALANCED</span>: <span class="hljs-number">3</span>,  <span class="hljs-attr">SLIGHTLY_UNBALANCED_LEFT</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">UNBALANCED_LEFT</span>: <span class="hljs-number">5</span>,&#125;;<span class="hljs-comment">//avl树就是自平衡二叉树，就是节点的左右子树的高度差不会超过1</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BinarySearchTree</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">super</span>(compareFn);  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);  &#125;  <span class="hljs-title function_">insertNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-comment">//当这棵树是空树的时候</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key);      <span class="hljs-comment">//小于向前节点</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      node.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">left</span>, key);      <span class="hljs-comment">//大于当前节点</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">right</span>, key);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//和当前节点值相同时</span>      <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-comment">//判断是否平衡</span>    <span class="hljs-keyword">const</span> balancerFactor = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node);    <span class="hljs-keyword">if</span> (balancerFactor === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_LEFT</span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">left</span>.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;        node = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(node);      &#125; <span class="hljs-keyword">else</span> &#123;        node = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLR</span>(node);      &#125;    &#125;    <span class="hljs-keyword">if</span> (balancerFactor === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_RIGHT</span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">right</span>.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;        node = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(node);      &#125; <span class="hljs-keyword">else</span> &#123;        node = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRL</span>(node);      &#125;    &#125;    <span class="hljs-keyword">return</span> node;  &#125;  <span class="hljs-title function_">removeNode</span>(<span class="hljs-params">node, key</span>) &#123;    node = <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">removeNode</span>(node, key);    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-comment">//空树也是平衡树</span>      <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-keyword">const</span> balancerFactor = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node);    <span class="hljs-keyword">if</span> (balancerFactor === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_LEFT</span>) &#123;      <span class="hljs-keyword">const</span> balancerFactorLeft = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node.<span class="hljs-property">left</span>);      <span class="hljs-keyword">if</span> (        balancerFactorLeft === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_LEFT</span> ||        balancerFactorLeft === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">SLIGHTLY_UNBALANCED_LEFT</span>      ) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(node);      &#125;      <span class="hljs-keyword">if</span> (balancerFactorLeft === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">SLIGHTLY_UNBALANCED_RIGHT</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLR</span>(node.<span class="hljs-property">left</span>);      &#125;    &#125;    <span class="hljs-keyword">if</span> (balancerFactor === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_RIGHT</span>) &#123;      <span class="hljs-keyword">const</span> balancerFactorRight = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node.<span class="hljs-property">right</span>);      <span class="hljs-keyword">if</span> (        balancerFactorRight === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_RIGHT</span> ||        balancerFactorRight === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">SLIGHTLY_UNBALANCED_RIGHT</span>      ) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(node);      &#125;      <span class="hljs-keyword">if</span> (balancerFactorRight === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">SLIGHTLY_UNBALANCED_LEFT</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRL</span>(node.<span class="hljs-property">right</span>);      &#125;    &#125;    <span class="hljs-keyword">return</span> node;  &#125;  <span class="hljs-comment">// 计算一个节点高度</span>  <span class="hljs-title function_">getNodeHeight</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNodeHeight</span>(node.<span class="hljs-property">left</span>),      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNodeHeight</span>(node.<span class="hljs-property">right</span>)    );  &#125;  <span class="hljs-comment">// 计算一个节点的平衡因子并返回其值</span>  <span class="hljs-title function_">getBalanceFactor</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> heightDifference =      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNodeHeight</span>(node.<span class="hljs-property">left</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNodeHeight</span>(node.<span class="hljs-property">right</span>);    <span class="hljs-keyword">switch</span> (heightDifference) &#123;      <span class="hljs-keyword">case</span> -<span class="hljs-number">2</span>:        <span class="hljs-keyword">break</span>;      <span class="hljs-attr">default</span>:        <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-comment">// 左左（LL）：向右的单旋转</span>  <span class="hljs-title function_">rotationLL</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> temp = node.<span class="hljs-property">left</span>;    node.<span class="hljs-property">right</span> = temp.<span class="hljs-property">left</span>;    temp.<span class="hljs-property">right</span> = node;    <span class="hljs-keyword">return</span> temp;  &#125;  <span class="hljs-title function_">rotationRR</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> temp = node.<span class="hljs-property">right</span>;    node.<span class="hljs-property">left</span> = temp.<span class="hljs-property">right</span>;    temp.<span class="hljs-property">left</span> = node;    <span class="hljs-keyword">return</span> temp;  &#125;  <span class="hljs-title function_">rotationLR</span>(<span class="hljs-params">node</span>) &#123;    node.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(node.<span class="hljs-property">left</span>);    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(node);  &#125;  <span class="hljs-title function_">rotationRL</span>(<span class="hljs-params">node</span>) &#123;    node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(node.<span class="hljs-property">right</span>);    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(node);  &#125;&#125;</code></pre></div><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 在红黑树中，每个节点都遵循以下规则：</span><span class="hljs-comment">// (1) 顾名思义，每个节点不是红的就是黑的；</span><span class="hljs-comment">// (2) 树的根节点是黑的；</span><span class="hljs-comment">// (3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；</span><span class="hljs-comment">// (4) 如果一个节点是红的，那么它的两个子节点都是黑的；</span><span class="hljs-comment">// (5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；</span><span class="hljs-comment">// (6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">BinarySearchTree</span>, &#123; <span class="hljs-title class_">Node</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.js&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">super</span>(key);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> = <span class="hljs-literal">null</span>;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Colors</span> = &#123;  <span class="hljs-attr">RED</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">BLACK</span>: <span class="hljs-number">2</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BinarySearchTree</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">super</span>(compareFn);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compareFn</span> = compareFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-title function_">isRed</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">isRed</span>;  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);  &#125;  <span class="hljs-title function_">insertNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span>) &#123;        node.<span class="hljs-property">left</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedBlackNode</span>(key);        node.<span class="hljs-property">left</span>.<span class="hljs-property">parent</span> = node;        <span class="hljs-keyword">return</span> node.<span class="hljs-property">left</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">left</span>, key);      &#125;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;        node.<span class="hljs-property">right</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedBlackNode</span>(key);        node.<span class="hljs-property">right</span>.<span class="hljs-property">parent</span> = node;        <span class="hljs-keyword">return</span> node.<span class="hljs-property">right</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">right</span>, key);      &#125;    &#125;  &#125;  <span class="hljs-title function_">fixTreeProperties</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">while</span> (      node &amp;&amp;      node.<span class="hljs-property">parent</span> &amp;&amp;      node.<span class="hljs-property">parent</span>.<span class="hljs-property">color</span>.<span class="hljs-title function_">isRed</span>() &amp;&amp;      node.<span class="hljs-property">color</span> !== <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>    ) &#123;      <span class="hljs-keyword">let</span> parent = node.<span class="hljs-property">parent</span>;      <span class="hljs-keyword">const</span> grendparent = parent.<span class="hljs-property">parent</span>;      <span class="hljs-comment">// 情形 A1：父节点是左侧子节点</span>      <span class="hljs-keyword">if</span> (grendparent &amp;&amp; grendparent.<span class="hljs-property">left</span> === parent) &#123;        <span class="hljs-keyword">const</span> uncle = grendparent.<span class="hljs-property">right</span>;        <span class="hljs-keyword">if</span> (uncle &amp;&amp; uncle.<span class="hljs-property">color</span> === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>) &#123;          grendparent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;          uncle.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          parent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          node = grendparent;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 情形 2A：节点是右侧子节点——左旋转</span>          <span class="hljs-keyword">if</span> (node === parent.<span class="hljs-property">right</span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(parent);            node = parent;            parent = node.<span class="hljs-property">parent</span>;          &#125;          <span class="hljs-comment">// 情形 3A：节点是左侧子节点——右旋转</span>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(grendparent);          parent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          grendparent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;          node = parent;        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> uncle = grendparent.<span class="hljs-property">left</span>;        <span class="hljs-keyword">if</span> (uncle &amp;&amp; uncle.<span class="hljs-property">color</span> === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>) &#123;          grendparent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;          uncle.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          parent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          node = grendparent;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 情形 2B：节点是左侧子节点——右旋转</span>          <span class="hljs-keyword">if</span> (node === parent.<span class="hljs-property">left</span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(parent);            node = parent;            parent = node.<span class="hljs-property">parent</span>;          &#125;          <span class="hljs-comment">// 情形 3B：节点是右侧子节点——左旋转</span>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(grendparent);          parent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          grendparent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;          node = parent;        &#125;      &#125;    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;  &#125;  <span class="hljs-title function_">rotationLL</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> temp = node.<span class="hljs-property">left</span>;    node.<span class="hljs-property">left</span> = temp.<span class="hljs-property">right</span>;    <span class="hljs-keyword">if</span> (temp.<span class="hljs-property">right</span> &amp;&amp; temp.<span class="hljs-property">right</span>.<span class="hljs-property">key</span>) &#123;      temp.<span class="hljs-property">right</span>.<span class="hljs-property">parent</span> = node;    &#125;    temp.<span class="hljs-property">parent</span> = node.<span class="hljs-property">parent</span>;    <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">parent</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = temp;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (node === node.<span class="hljs-property">parent</span>.<span class="hljs-property">left</span>) &#123;        node.<span class="hljs-property">parent</span>.<span class="hljs-property">left</span> = temp;      &#125; <span class="hljs-keyword">else</span> &#123;        node.<span class="hljs-property">parent</span>.<span class="hljs-property">right</span> = temp;      &#125;    &#125;    temp.<span class="hljs-property">right</span> = node;    node.<span class="hljs-property">parent</span> = temp;  &#125;  <span class="hljs-title function_">rotationRR</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> temp = node.<span class="hljs-property">right</span>;    node.<span class="hljs-property">right</span> = temp.<span class="hljs-property">left</span>;    <span class="hljs-keyword">if</span> (temp.<span class="hljs-property">left</span> &amp;&amp; temp.<span class="hljs-property">left</span>.<span class="hljs-property">key</span>) &#123;      temp.<span class="hljs-property">left</span>.<span class="hljs-property">parent</span> = node;    &#125;    temp.<span class="hljs-property">parent</span> = node.<span class="hljs-property">parent</span>;    <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">parent</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = temp;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (node === node.<span class="hljs-property">parent</span>.<span class="hljs-property">left</span>) &#123;        node.<span class="hljs-property">parent</span>.<span class="hljs-property">left</span> = temp;      &#125; <span class="hljs-keyword">else</span> &#123;        node.<span class="hljs-property">parent</span>.<span class="hljs-property">right</span> = temp;      &#125;    &#125;    temp.<span class="hljs-property">right</span> = node;    node.<span class="hljs-property">parent</span> = temp;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第八章 字典和散列表</title>
    <link href="/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <url>/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="字典和散列表"><a href="#字典和散列表" class="headerlink" title="字典和散列表"></a>字典和散列表</h1><h2 id="Util-js"><a href="#Util-js" class="headerlink" title="Util.js"></a>Util.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;</code></pre></div><h2 id="linked-list-models-js"><a href="#linked-list-models-js" class="headerlink" title="linked-list-models.js"></a>linked-list-models.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义每个节点的信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">undefined</span>;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element, next, prev</span>) &#123;    <span class="hljs-variable language_">super</span>(element, next);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = prev;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePair</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`[<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.key&#125;</span>,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.value&#125;</span>]`</span>;  &#125;&#125;</code></pre></div><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ValuePair</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; defaultToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dictionary</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">toStrFn = defaultToString</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span> = toStrFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 向字典中添加新元素。如果 key 已经存在，那么已存在的 value 会 被新的值覆盖。</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">value</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> &amp;&amp; value != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key)] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(key, value);      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">//通过使用键值作为参数来从字典中移除键值对应的数据值</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasKey</span>(key)) &#123;      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key)];      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 如果某个键值存在于该字典中，返回 true，否则返回 false</span>  <span class="hljs-title function_">hasKey</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key)] != <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-comment">//  通过以键值作为参数查找特定的数值并返回</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> valuePair = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span>[key]];    <span class="hljs-keyword">return</span> valuePair == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;undefined&quot;</span> : valuePair.<span class="hljs-property">value</span>;  &#125;  <span class="hljs-comment">//删除该字典中的所有值</span>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">//返回字典所包含值的数量。与数组的 length 属性类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>).<span class="hljs-property">length</span>;  &#125;  <span class="hljs-comment">//在 size 等于零的时候返回 true，否则返回 false</span>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 将字典所包含的所有键名以数组形式返回</span>  <span class="hljs-title function_">keys</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">keyValues</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">valuePair</span>) =&gt;</span> valuePair.<span class="hljs-property">key</span>);  &#125;  <span class="hljs-comment">// 将字典所包含的所有数值以数组形式返回</span>  <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">keyValues</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">valuePair</span>) =&gt;</span> valuePair.<span class="hljs-property">value</span>);  &#125;  <span class="hljs-comment">//将字典中所有[键，值]对返回</span>  <span class="hljs-title function_">keyValues</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// return Object.values(this.table);</span>    <span class="hljs-keyword">const</span> valuePairs = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasKey</span>(key)) &#123;        valuePairs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[key]);      &#125;    &#125;    <span class="hljs-keyword">return</span> valuePairs;  &#125;  <span class="hljs-comment">//迭代字典中所有的键值对。callbackFn 有两个参数:key 和value。该方法可以在回调函数返回 false 时被中止(和 Array 类中的 every 方法相似)。</span>  <span class="hljs-title function_">foreach</span>(<span class="hljs-params">callbackFN</span>) &#123;    <span class="hljs-keyword">const</span> valuePairs = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">keyValues</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; valuePairs.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callbackFN</span>(valuePairs[i].<span class="hljs-property">key</span>, valuePairs[i].<span class="hljs-property">value</span>);      <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;    <span class="hljs-keyword">const</span> valuePairs=<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">keyValues</span>()    <span class="hljs-keyword">let</span> str=valuePairs[<span class="hljs-number">0</span>].<span class="hljs-title function_">toString</span>()    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>=<span class="hljs-number">1</span>;i&lt;valuePairs.<span class="hljs-property">length</span>;i++)&#123;      str+=<span class="hljs-string">`,<span class="hljs-subst">$&#123;valuePairs[i].toString()&#125;</span>`</span>    &#125;    <span class="hljs-keyword">return</span> str  &#125;&#125;</code></pre></div><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>HashTable 类，也叫 HashMap 类，它是 Dictionary 类的一种散列表实现方式。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ValuePair</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models&quot;</span>;<span class="hljs-keyword">import</span> &#123; defaultToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 基础版，相同的hashkey的话会被覆盖</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">toStrFn = defaultToString</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span> = toStrFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 向散列表增加一个新的项（也能更新散列表）</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">value</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(position, value);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-comment">// 根据键值从散列表中移除值</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> hash = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hashCode</span>[key];    <span class="hljs-keyword">const</span> valuePair = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[hash];    <span class="hljs-keyword">if</span> (valuePair != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[hash];      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 返回根据键值检索到的特定的值</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> valuePair = thia.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key)];    <span class="hljs-keyword">return</span> valuePair == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : valuePair.<span class="hljs-property">value</span>;  &#125;  <span class="hljs-title function_">loseloseHashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">&quot;number&quot;</span>) &#123;      <span class="hljs-keyword">return</span> key;    &#125;    <span class="hljs-keyword">const</span> tableKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key);    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tableKey.<span class="hljs-property">length</span>; i++) &#123;      hash += <span class="hljs-variable language_">this</span>.<span class="hljs-property">tableKey</span>.<span class="hljs-title function_">charCodeAt</span>(tableKey[i]);    &#125;    <span class="hljs-keyword">return</span> hash % <span class="hljs-number">37</span>;  &#125;  <span class="hljs-title function_">hashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loseloseHashCode</span>(key);  &#125;&#125;</code></pre></div><h2 id="处理散列表中的冲突"><a href="#处理散列表中的冲突" class="headerlink" title="处理散列表中的冲突"></a>处理散列表中的冲突</h2><p>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defaultToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../LinkedList/LinkedList&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ValuePair</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTableSeparateChaining</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">toStrFn = defaultToString</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span> = toStrFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-title function_">loseloseHashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">&quot;number&quot;</span>) &#123;      <span class="hljs-keyword">return</span> key;    &#125;    <span class="hljs-keyword">const</span> tableKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key);    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tableKey.<span class="hljs-property">length</span>; i++) &#123;      hash += <span class="hljs-variable language_">this</span>.<span class="hljs-property">tableKey</span>.<span class="hljs-title function_">charCodeAt</span>(tableKey[i]);    &#125;    <span class="hljs-keyword">return</span> hash % <span class="hljs-number">37</span>;  &#125;  <span class="hljs-title function_">hashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loseloseHashCode</span>(key);  &#125;  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> || value != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position] == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();      &#125;      <span class="hljs-keyword">const</span> valuePair = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(key, value);      <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position].<span class="hljs-title function_">push</span>(valuePair);      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">const</span> linkedList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position];    <span class="hljs-keyword">if</span> (linkedList != <span class="hljs-literal">null</span> &amp;&amp; !linkedList.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">let</span> current = linkedList.<span class="hljs-title function_">getHead</span>();      <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">element</span>.<span class="hljs-property">key</span> === key) &#123;          <span class="hljs-keyword">return</span> current.<span class="hljs-property">element</span>.<span class="hljs-property">value</span>;        &#125;        current = current.<span class="hljs-property">next</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">const</span> linkedList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position];    <span class="hljs-keyword">if</span> (linkedList != <span class="hljs-literal">null</span> &amp;&amp; !linkedList.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">let</span> current = linkedList.<span class="hljs-title function_">getHead</span>();      <span class="hljs-keyword">while</span> (!current) &#123;        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">element</span>.<span class="hljs-property">key</span> === key) &#123;          linkedList.<span class="hljs-title function_">remove</span>(current.<span class="hljs-property">element</span>);          <span class="hljs-keyword">if</span> (linkedList.<span class="hljs-title function_">isEmpty</span>()) &#123;            <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position];          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        current = current.<span class="hljs-property">next</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;&#125;</code></pre></div><p>另一种解决冲突的方法是线性探查。之所以称作线性，是因为它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defaultToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../LinkedList/LinkedList&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ValuePair</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTableLinearProbing</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">toStrFn = defaultToString</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span> = toStrFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-title function_">loseloseHashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">&quot;number&quot;</span>) &#123;      <span class="hljs-keyword">return</span> key;    &#125;    <span class="hljs-keyword">const</span> tableKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key);    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tableKey.<span class="hljs-property">length</span>; i++) &#123;      hash += <span class="hljs-variable language_">this</span>.<span class="hljs-property">tableKey</span>.<span class="hljs-title function_">charCodeAt</span>(tableKey[i]);    &#125;    <span class="hljs-keyword">return</span> hash % <span class="hljs-number">37</span>;  &#125;  <span class="hljs-comment">//另外一种散列函数</span>  <span class="hljs-title function_">djb2HashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> tableKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key);    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">5381</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tableKey.<span class="hljs-property">length</span>; i++) &#123;      hash = hash * <span class="hljs-number">33</span> + tableKey.<span class="hljs-title function_">charCodeAt</span>(i);    &#125;    <span class="hljs-keyword">return</span> hash % <span class="hljs-number">1013</span>;  &#125;  <span class="hljs-title function_">hashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loseloseHashCode</span>(key);  &#125;  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> &amp;&amp; value != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position]) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(key, value);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> index = position + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index]) &#123;          index++;        &#125;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(key, value);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position]) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position].<span class="hljs-property">key</span> === key) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position].<span class="hljs-property">value</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> index = position + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> !== key) &#123;          index++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> === key) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">value</span>;        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position]) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position].<span class="hljs-property">key</span> === key) &#123;        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position];        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">verifyRemoveSideEffect</span>(key, position);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> index = position + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> !== key) &#123;          index++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> === key) &#123;          <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index];          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">verifyRemoveSideEffect</span>(key, index);          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-title function_">verifyRemoveSideEffect</span>(<span class="hljs-params">key, removedPosition</span>) &#123;    <span class="hljs-keyword">const</span> hash = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">let</span> index = removedPosition + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> posHash = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span>];      <span class="hljs-keyword">if</span> (posHash &lt;= hash || posHash &lt;= removedPosition) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[removedPosition] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index];        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index];        removedPosition = index;      &#125;      index++;    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第七章 集合</title>
    <link href="/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9B%86%E5%90%88/"/>
    <url>/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set1</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">// 向集合添加一个新元素</span>  <span class="hljs-title function_">add</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(element)) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[element] = element;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 从集合移除一个元素</span>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(element)) &#123;      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[element];      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 如果元素在集合中，返回 true，否则返回 false</span>  <span class="hljs-title function_">has</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-comment">// return element in this.items;</span>    <span class="hljs-comment">// 优化</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 我们也可以在代码中使用 this.items.hasOwnProperty(element)。但是， 如果这样的话，代码检查工具如 ESLint 会抛出一个错误。错误的原因为不是所 有的对象都继承了 Object.prototype，甚至继承了 Object.prototype 的对 象上的 hasOwnProperty 方法也有可能被覆盖，导致代码不能正常工作。要避 免出现任何问题，使用 Object.prototype.hasOwnProperty.call 是更安 全的做法。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>, element);  &#125;  <span class="hljs-comment">// 移除集合中的所有元素</span>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">// 返回集合所包含元素的数量。它与数组的 length 属性类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>).<span class="hljs-property">length</span>;  &#125;  <span class="hljs-comment">// 返回一个包含集合中所有值(元素)的数组</span>  <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>);  &#125;  <span class="hljs-comment">// union 并集:对于给定的两个集合，返回一个包含两个集合中所有元素的新集合</span>  <span class="hljs-title function_">union</span>(<span class="hljs-params">otherElements</span>) &#123;    <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set1</span>();    <span class="hljs-keyword">const</span> otherValue = otherElements.<span class="hljs-title function_">values</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; otherValue.<span class="hljs-property">length</span>; i++) &#123;      set.<span class="hljs-title function_">add</span>(otherValue[i]);    &#125;    <span class="hljs-keyword">const</span> values = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">values</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;      set.<span class="hljs-title function_">add</span>(values[i]);    &#125;    <span class="hljs-keyword">return</span> set;  &#125;  <span class="hljs-title function_">intersection</span>(<span class="hljs-params">otherSet</span>) &#123;    <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set1</span>();    <span class="hljs-comment">// const values = this.values();</span>    <span class="hljs-comment">// for (let i = 0; i &lt; values.length; i++) &#123;</span>    <span class="hljs-comment">//   if (otherSet.has(values[i])) &#123;</span>    <span class="hljs-comment">//     set.add(values[i]);</span>    <span class="hljs-comment">//   &#125;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">//针对长度不同的set做交集的时候的优化</span>    <span class="hljs-keyword">let</span> values = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">values</span>();    <span class="hljs-keyword">let</span> otherValues = otherSet.<span class="hljs-title function_">values</span>();    <span class="hljs-keyword">let</span> biggerSet = values;    <span class="hljs-keyword">let</span> smallerSet = otherValues;    <span class="hljs-keyword">if</span> (biggerSet.<span class="hljs-property">length</span> - smallerSet.<span class="hljs-property">length</span> &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">let</span> middle = biggerSet;      biggerSet = smallerSet;      smallerSet = middle;    &#125;    smallerSet.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (biggerSet.<span class="hljs-title function_">includes</span>(item)) &#123;        set.<span class="hljs-title function_">add</span>(item);      &#125;    &#125;);    <span class="hljs-keyword">return</span> set;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集</span><span class="hljs-comment">合的元素的新集合</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; otherSet </span><span class="hljs-comment">   * <span class="hljs-doctag">@returns</span> </span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">difference</span>(<span class="hljs-params">otherSet</span>) &#123;    <span class="hljs-keyword">const</span> differenceSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set1</span>();    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (!otherSet.<span class="hljs-title function_">has</span>(item)) &#123;        differenceSet.<span class="hljs-title function_">add</span>(item);      &#125;    &#125;);    <span class="hljs-keyword">return</span> differenceSet;  &#125;  <span class="hljs-title function_">isSubsetOf</span>(<span class="hljs-params">otherSet</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() &gt; otherSet.<span class="hljs-title function_">size</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">let</span> isSubset = <span class="hljs-literal">true</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (!otherSet.<span class="hljs-title function_">has</span>(item)) &#123;        isSubset = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;);    <span class="hljs-keyword">return</span> isSubset;  &#125;&#125;<span class="hljs-comment">// const set = new Set1();</span><span class="hljs-comment">// set.add(1);</span><span class="hljs-comment">// console.log(set.values()); // 输出[1] console.log(set.has(1)); // 输出true console.log(set.size()); // 输出1</span><span class="hljs-comment">// set.add(2);</span><span class="hljs-comment">// console.log(set.values()); // 输出[1, 2] console.log(set.has(2)); // 输出true console.log(set.size()); // 输出2</span><span class="hljs-comment">// set.delete(1);</span><span class="hljs-comment">// console.log(set.values()); // 输出[2]</span><span class="hljs-comment">// set.delete(2);</span><span class="hljs-comment">// console.log(set.values()); // 输出[]</span><span class="hljs-comment">// const setA = new Set1();</span><span class="hljs-comment">// setA.add(1);</span><span class="hljs-comment">// setA.add(2);</span><span class="hljs-comment">// setA.add(3);</span><span class="hljs-comment">// const setB = new Set1();</span><span class="hljs-comment">// setB.add(3);</span><span class="hljs-comment">// setB.add(4);</span><span class="hljs-comment">// setB.add(5);</span><span class="hljs-comment">// setB.add(6);</span><span class="hljs-comment">// const unionAB = setA.union(setB);</span><span class="hljs-comment">// console.log(unionAB.values());</span><span class="hljs-comment">// const setA = new Set1();</span><span class="hljs-comment">// setA.add(1);</span><span class="hljs-comment">// setA.add(2);</span><span class="hljs-comment">// setA.add(3);</span><span class="hljs-comment">// const setB = new Set1();</span><span class="hljs-comment">// setB.add(2);</span><span class="hljs-comment">// setB.add(3);</span><span class="hljs-comment">// setB.add(4);</span><span class="hljs-comment">// const intersectionAB = setA.intersection(setB);</span><span class="hljs-comment">// console.log(intersectionAB.values());</span><span class="hljs-comment">// const setA = new Set1();</span><span class="hljs-comment">// setA.add(1);</span><span class="hljs-comment">// setA.add(2);</span><span class="hljs-comment">// const setB = new Set1();</span><span class="hljs-comment">// setB.add(1);</span><span class="hljs-comment">// setB.add(2);</span><span class="hljs-comment">// setB.add(3);</span><span class="hljs-comment">// const setC = new Set1();</span><span class="hljs-comment">// setC.add(2);</span><span class="hljs-comment">// setC.add(3);</span><span class="hljs-comment">// setC.add(4);</span><span class="hljs-comment">// console.log(setA.isSubsetOf(setB));</span><span class="hljs-comment">// console.log(setA.isSubsetOf(setC));</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Set1</span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层</title>
    <link href="/2022/11/20/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2022/11/20/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="/2022/11/20/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2022/11/20/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2022/11/20/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2022/11/20/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层</title>
    <link href="/2022/11/20/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2022/11/20/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Puppeteer</title>
    <link href="/2022/11/08/Puppeteer/"/>
    <url>/2022/11/08/Puppeteer/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Puppeteer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>物理层</title>
    <link href="/2022/11/06/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2022/11/06/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="物理层的接口特性"><a href="#物理层的接口特性" class="headerlink" title="物理层的接口特性"></a>物理层的接口特性</h2><p>物理层解决如何在连接各种计算机的传输媒体上传输比特流数据，而不是指具体的传输媒体，就是具体的010101</p><p>物理层的主要任务：确定与传输媒体接口相关的一些特性</p><p>1.机械特性。定义物理连接的特性，规定物理连接时所采用的规格，接口形状，引脚数量和排列状况</p><p>2.电气特性。规定传输二进制位时，线路上信号的电压范围，阻抗匹配，传输速率·和距离限制等</p><p>3.功能特性。指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</p><p>4.规程特性（过程特性）定义各条物理线路的工作规程和时许关系</p><h2 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h2><p>通信的目的是传输消息</p><p>数据：传输信息的实体，通常是有意义的符号序列</p><p>信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式</p><p>​            数字信号/离散信号：代表信息的参数的取值是离散的</p><p>​            模拟信号/连续信号：代表消息的参数的取值是连续的</p><p>信源：产生和发送数据的源头</p><p>信宿：接受数据的终点</p><p>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和接受信道</p><p>信道 按传输信号分为 模拟信道和数字信道，按传输介质分为有线信道和无线信道</p><h2 id="设计数据通信系统要考虑3个问题"><a href="#设计数据通信系统要考虑3个问题" class="headerlink" title="设计数据通信系统要考虑3个问题"></a>设计数据通信系统要考虑3个问题</h2><ul><li><p>采用单工通信/半双工通信/全双工通信方式？</p></li><li><p>采用串行通信/并行通信？</p></li><li><p>采用同步通信还是异步通信</p></li></ul><h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><p>单工通信</p><p>​    只有一个方向的通信而没有反方向的交互，仅需一条信道</p><p>半双工通信/双向交替通信</p><p>​    通信的双方都可以发送或者接受信息，但是任何一方都不能同时发送或者接受</p><p>全双工/双向同时通信</p><p>​    通信双方可以同时发送或者接受信息，也需要两条信道</p><h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><p>串行传输。将表示一个字符的8位二进制数按由低位到高位的顺序依次发送，速度慢，费用低，适合远距离传输</p><p>并行传输。将表示一个字符的8位二进制数同时通过8条信道发送。速度快，费用高，适合近距离传输，计算机内部就是并行传输</p><p>同步传输。 在同步传输模式下，数据的传送是以一个数据块为单位，因此同步传输又称为区块传输，在传输数据时，需要先送出一个或者多个同步字符，再送出一批数据</p><p>异步传输。异步传输是将比特分成小组进行传输，小组可以是8位的一个字符或者更长，发送方可以在任何时候发送这些比特组，而接收方不知道他们会在什么时候到达，传送数据时，加一个字符起始位和字符终止位</p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>码元是指一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称之为k进制码元，而该时长称之为码元宽度，当码元的离散状态有m个时（m&gt;2），此时码元称之为m进制码元。</p><p>一码元可以携带多个比特的信息量，例如使用二进制码元的时候只有两种状态·的码元，1，0</p><p>k进制码元，例如4进制码元，码元的离散状态有4个，四种高低不同的码元，00，01，10，11</p><h2 id="数字通信系统数据传输速率的两种表示方法"><a href="#数字通信系统数据传输速率的两种表示方法" class="headerlink" title="数字通信系统数据传输速率的两种表示方法"></a>数字通信系统数据传输速率的两种表示方法</h2><p>速率也叫数据率，是指数据的传输速率，表示单位时间传输的数据量，可以用码元传输速率和信息传输速率来表示</p><p>码元传输速率：也叫码元速率，波形速率，调制速率，符号速率，他表示单位时间内数字通信系统所传输的码元个数（也称为脉冲个数或者信号变化的次数），单位是波特(Baud),1波特表示数字通信每秒传输一个码元</p><p>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关。<br>$$<br>R=1/T(B)<br>$$<br>信息传输速率：别名信息速率，比特率，表示单位时间内数字通信系统传输的二进制码元个数即比特数，单位是比特/秒（b/s）</p><p>关系：若一个码元携带nbit的信息量，则M Baud的码元传输速率所对应的信息传输速率为Mxnbit/s</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="/2022/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2022/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="计算机网路的概念"><a href="#计算机网路的概念" class="headerlink" title="计算机网路的概念"></a>计算机网路的概念</h4><p>计算机网络是一个将分散的，具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</p><p>计算机网络是互连的，自治的计算机集合</p><p>互连-通过通信链路互联互通</p><p>自治-无主从关系</p><h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><p>数据通信</p><p>资源共享</p><p>分布式处理</p><p>提高可靠性</p><p>负载均衡</p><h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><p>组成部分：硬件，软件，协议（一系列规则和约定的集合）</p><p>工作方式：</p><p>​    1.边缘部分  为用户直接使用的 ：c/s方式。 P2P方式</p><p>​    2.核心部分  为边缘部分服务</p><p>功能组成：</p><p>​    分为通信子网和资源子网，通信子网实现数据通信，资源子网实现资源共享和数据处理</p><p>​    资源子网是实现资源共享功能的设备和软件的集合，包括OSI参考模型中的应用层，表示层，会话层</p><p>​    通信子网是由各种传输介质，通信设备，相应的网络协议组成，包括OSI参考模型中的传输层，网络层，数据链路层，物理层等组成</p><h4 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h4><ol><li>按分布范围分广域网(WAN),城域网(MAN)，局域网(LAN),个人区域网(PAN)，前两者使用的是交换技术，后两者使用的是广播技术</li><li>按使用者分为公共网和专用网</li><li>按交换技术分为电路交换 报文交换分组交换</li><li>按拓扑结构分为 总线型 星型 环型网状型</li><li>按传播技术分为广播式网络（共享公共通信信道）点对点网络 （是用分组存储转发和路由选择机制）</li></ol><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h5><p>速率就是数据率或者数据传输率或者比特率</p><p>比特 由0/1组成</p><p>连接计算机网络上的主机在数字信道上传送数据位数的速率</p><p>单位是b/s kb/s Mb/s Gb/s Tb/s</p><p>速率使用小写的b表示，而存储容量 1Byte 字节=8 bit</p><p>1kb/s=10^3b/s</p><p>1Mb/s=10^3 kb/s =10^6b/s</p><p>1Gb/s=10^3 Mb/s =10^6 kb/s=10^9 b/s</p><p>1Tb/s=10^3 Gb/s=….</p><h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><p>原本指的是某个信号具有的频带宽度，及最高频率和最低频率之差，单位是赫兹hz</p><p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一个点到另一个点所能通过的最高数据率，单位是比特每秒 b/s kb/s mb/s gb/s tb/s</p><p>网络设备具备的最高速度</p><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>表示单位时间内通过的某个网络(或者信道，接口)的数据量，单位是b/s Kb/s Mb/s</p><p>吞吐量受网络带宽或者网络的额定速率的限制</p><h5 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h5><p>指数据(报文/分组/比特流)从网络或早或者链路的一端传送到另一端所需要的时间，也叫时延或者迟延，单位是s</p><p>时延分为发送时延(传输时延)，传播时延，排队时延，处理时延</p><p>发送时延：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需要的时间<br>$$<br>发送时延=数据长度/信号带宽(发送速率)<br>$$<br>传播时延：取决于电磁波传播速度和链路长度<br>$$<br>传播时延=信道长度/电磁波在信道上的传播速率<br>$$<br>排队时延：等待输入/出链路可用</p><p>处理时延：检错找出口</p><h5 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h5><p>$$<br>时延带宽积=传播时延*带宽<br>$$</p><p>时延带宽积又称为以比特为单位的链路长度，既某段链路现在有多少比特。 容量</p><h5 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h5><p>从发送方发送数据开始到发送方到接收方确认（接收方收到数据后立即发送确认）总共经历的时延</p><p>RTT包括末端处理时间，往返传播时延=传播时延*2</p><h5 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h5><p>$$<br>信道利用率=有数据通过的时间/（有+无）数据通过的时间<br>$$</p><p>$$<br>网络利用率=信道利用率加权平均值<br>$$</p><h4 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h4><p>网络体系分层结构是从功能上描述计算机网络的结构</p><p>计算机网络体系结构简称计算机网络体系结构是分层结构</p><p>每层遵循某些网络协议以完成本层的功能</p><p>计算机网络体系结构是计算机网络的各层及其协议的集合</p><p>第n层在向n+1层提供服务的时候，该服务不仅包括第n层本身的功能，海波啊哭哦由下层服务提供的功能</p><p>仅仅在相邻层间有街口，且所提供的服务的具体实现细节对上一层完全屏蔽</p><p>体系结构是抽象的·，而实现是指运行的一些软件和硬件</p><h4 id="OSI-ISO参考模型"><a href="#OSI-ISO参考模型" class="headerlink" title="OSI/ISO参考模型"></a>OSI/ISO参考模型</h4><p>应用层</p><p>​    所有能和用户交互产生网络流量的程序</p><p>​    典型的应用层服务：</p><p>​            文件传输（FTP）</p><p>​            电子邮件 （SMTP）</p><p>​            万维网（http）</p><p>表示层</p><p>​    用于处理在两个通信系统中交换信息的表达方式(语法和语义)</p><p>​    功能一：数据格式变换</p><p>​    功能二：数据加密解密</p><p>​    功能三：数据压缩和恢复</p><p>​    主要协议：JPEG,ASCII</p><p>会话层</p><p>​     向表示层实体/用户进程提供建立连接并在连接上有序地传输数据，这是会话，也是建立同步(SYN)</p><p>​     功能一：建立，管理，终止会话</p><p>​     功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步，适用于传输大文件</p><p>​     主要协议：ADSP，ASP</p><p>传输层</p><p>​     负责主机中两个进程的通信，即端对端的通信，传输单位是报文段或者用户数据报</p><p>​     功能一：可靠传输，不可靠传输</p><p>​     功能二：差错控制</p><p>​     功能三：流量控制</p><p>​    主要协议：TCP,UDP</p><p>网络层</p><p>​     主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报</p><p>​     功能一：路由选择 最佳路径</p><p>​     功能二：流量控制</p><p>​     功能三：差错控制</p><p>​     功能四：拥塞控制</p><p>​    若所有的结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞</p><p>​    主要协议：IP,IPX,ICMP,IGMP,ARP,RARP,OSPF</p><p>数据链路层</p><p>​    主要任务是把网络层传下来的数据报组装成帧。数据链路层的传输单位是帧。</p><p>​    功能一：成帧（定义帧的开始和结束）</p><p>​    功能二：差错控制 帧错+位错</p><p>​    功能三：流量控制</p><p>​    功能四：访问（接入）控制 控制对信道的访问</p><p>​    主要协议：SDLC,HDLC,PPP,STP</p><p>物理层</p><p>​    主要任务是在物理媒体上实现比特流的透明传输。物理层传输单位是比特。</p><p>​    透明传输：指不管所传数据是怎什么样的比特组合，都应当能够在链路上传送。</p><p>​    功能一：定义接口特性</p><p>​    功能二：定义传输模式 单工  半双工 双工</p><p>​    功能三： 定义传输速率</p><p>​    功能四：比特同步</p><p>​    功能五：比特编码</p><p>​    主要协议：Rj45，802.3</p><h5 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h5><p>传输过程中上面4层是端对端协议传输，下面是点对点传输会经过中间系统 ，中间系统只有下三层，OSI参考模型的传输过程经历打包和拆包的过程，在应用层数据向下传输的过程中要加首部header，从表示层向下传输也要加header，数据链路层首尾都要加header，物理层不需要，因为物理层已经是010101，解包就是通过对应的协议解析header</p><h5 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h5><p>TCP/IP参考模型由应用层，传输层，网际层，网络接口层组成，应用层对应应用层，表示层，会话层，传输层就是对应传输层，网际层就是对应网络层，网络接口层对应的是数据链路层和物理层。</p><p>应用层对应的协议是HTTP,FTP,DNS</p><p>传输层对应的协议是TCP,UDP</p><p>网际层对应的协议是IP</p><p>网络接口层对应的协议是Ethernet，ATM，Frame Relay</p><h6 id="osi参考模型和tcp-ip参考模型"><a href="#osi参考模型和tcp-ip参考模型" class="headerlink" title="osi参考模型和tcp/ip参考模型"></a>osi参考模型和tcp/ip参考模型</h6><p>相同点：</p><p>​    都分层</p><p>​    基于独立的协议栈的概念</p><p>​    可以实现异构网络互联</p><p>不同点</p><p>面向连接分为三个阶段，第一个是建立连接，在此阶段，发出一个建立连接的请求。只有在连接建立成功之后才能进行数据传输，当数据传输完成就必须释放连接，面向无连接没有三个阶段，他直接进行传输</p><p>osi定义了三点：服务，协议，接口</p><p>osi先出现，参考模型先于协议发明，不偏向特定协议</p><p>tcp/ip设计之初考虑到了异构网互联问题，将IP作为重要层次</p><p>osi参考模型网络层是面向无连接和面向连接的，tcp/ip是面向无连接的</p><p>传输层osi是无连接的。tcp/ip是面向有连接和无连接的</p><h5 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h5><p>结合了osi和tcp/ip的优点</p><p>应用层 支持各种网络应用   FTP. SMTP. HTTP</p><p>表示层  进程和进程间的数据传输 TCP UDP</p><p>网络层 源主机到目的主机的数据分组路由与转发 IP ICMP OSPF等</p><p>数据链路层 将网络层传下来的数据报文组装成帧。 Ethernet ，PPP </p><p>物理层  进行比特传输</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react源码</title>
    <link href="/2022/11/02/react%E6%BA%90%E7%A0%81/"/>
    <url>/2022/11/02/react%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><a href="https://7kms.github.io/react-illustration-series/">https://7kms.github.io/react-illustration-series/</a></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>react源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scss笔记</title>
    <link href="/2022/10/30/scss%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/30/scss%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$font-stack</span>: Helvetica, sans-serif;<span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#333</span>;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> <span class="hljs-variable">$font-stack</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;&#125;</code></pre></div><p>scss的变量是以$开头的，css也有自己的变量，他和scss不同，scss变量会被scss编译，css变量会包含在输出文件中，css变量对不同的元素有不同的值，scss变量一次只有一个值，scss变量是命令式的，这意味着如果你使用一个变量然后改变它的值，之前使用的值不变，css是声明事的，如果中途改变了值，拿他之前和之后的值都会发生变化</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$variable</span>: value <span class="hljs-number">1</span>;<span class="hljs-selector-class">.rule-1</span> &#123;  value: <span class="hljs-variable">$variable</span>;&#125;<span class="hljs-variable">$variable</span>: value <span class="hljs-number">2</span>;<span class="hljs-selector-class">.rule-2</span> &#123;  value: <span class="hljs-variable">$variable</span>;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.rule-1</span> &#123;  value: value <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.rule-2</span> &#123;  value: value <span class="hljs-number">2</span>;&#125;</code></pre></div><p>Sass 变量与所有 Sass 标识符一样，将连字符和下划线视为相同。这意味着<code>$font-size</code>and<code>$font_size</code>都指的是同一个变量。这是 Sass 早期的历史遗留问题，当时<em>它只</em>允许在标识符名称中使用下划线。一旦 Sass 添加了对连字符的支持以匹配CSS的语法，这两者就等同于使迁移更容易。</p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>!default scss提供了这个符号来编写默认变量，特别是当你编写scss库的时候</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// _library.scss</span><span class="hljs-variable">$black</span>: <span class="hljs-number">#000</span> !default;<span class="hljs-variable">$border-radius</span>: <span class="hljs-number">0.25rem</span> !default;<span class="hljs-variable">$box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.5rem</span> <span class="hljs-number">1rem</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-variable">$black</span>, <span class="hljs-number">0.15</span>) !default;<span class="hljs-selector-tag">code</span> &#123;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$border-radius</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">$box-shadow</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// style.scss</span><span class="hljs-keyword">@use</span> <span class="hljs-string">&#x27;library&#x27;</span> with (  <span class="hljs-variable">$black</span>: <span class="hljs-number">#222</span>,会覆盖默认的变量值  <span class="hljs-variable">$border-radius</span>: <span class="hljs-number">0.1rem</span>);</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-tag">code</span> &#123;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0.1rem</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.5rem</span> <span class="hljs-number">1rem</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">34</span>, <span class="hljs-number">34</span>, <span class="hljs-number">34</span>, <span class="hljs-number">0.15</span>);&#125;</code></pre></div><p>不能修改由<a href="https://sass-lang.com/documentation/modules">内置模块</a>定义的变量</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;sass:math&quot;</span> as math;<span class="hljs-comment">// This assignment will fail.</span>math.<span class="hljs-variable">$pi</span>: <span class="hljs-number">0</span>;</code></pre></div><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>在样式表顶层声明的变量是<em>全局</em>的。这意味着在声明它们之后，可以在其模块中的任何地方访问它们。但并非所有变量都是如此。在块中声明的那些（ SCSS中的花括号或 Sass 中的缩进代码）通常是<em>local</em>，并且只能在它们声明的块中访问。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$global-variable</span>: global value;<span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-variable">$local-variable</span>: local value;  global: <span class="hljs-variable">$global-variable</span>;  local: <span class="hljs-variable">$local-variable</span>;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  global: <span class="hljs-variable">$global-variable</span>;  <span class="hljs-comment">// This would fail, because $local-variable isn&#x27;t in scope:</span>  <span class="hljs-comment">// local: $local-variable;</span>&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.content</span> &#123;  global: global value;  local: local value;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  global: global value;&#125;</code></pre></div><p>局部变量甚至可以声明为与全局变量同名。如果发生这种情况，实际上有两个不同的变量同名：一个是本地的，一个是全局的。这有助于确保编写局部变量的作者不会意外更改他们甚至不知道的全局变量的值。</p><div class="code-wrapper"><pre><code class="hljs css">$variable: global value;<span class="hljs-selector-class">.content</span> &#123;  $variable: local value;  value: $variable;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  value: $variable;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123;  value: second global value;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  value: second global value;&#125;</code></pre></div><p>如果您需要在本地范围内（例如在 mixin 中）设置全局变量的值，则可以使用该<code>!global</code>标志。标记为的变量声明<code>!global</code>将<em>始终</em>分配给全局范围。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$variable</span>: first global value;<span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-variable">$variable</span>: second global value !global;  value: <span class="hljs-variable">$variable</span>;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  value: <span class="hljs-variable">$variable</span>;&#125;</code></pre></div><p>Css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123;  value: second global value;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  value: second global value;&#125;</code></pre></div><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$dark-theme</span>: true !default;<span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#f8bbd0</span> !default;<span class="hljs-variable">$accent-color</span>: <span class="hljs-number">#6a1b9a</span> !default;<span class="hljs-keyword">@if</span> <span class="hljs-variable">$dark-theme</span> &#123;  <span class="hljs-variable">$primary-color</span>: <span class="hljs-built_in">darken</span>(<span class="hljs-variable">$primary-color</span>, <span class="hljs-number">60%</span>);  <span class="hljs-variable">$accent-color</span>: <span class="hljs-built_in">lighten</span>(<span class="hljs-variable">$accent-color</span>, <span class="hljs-number">60%</span>);&#125;<span class="hljs-selector-class">.button</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$primary-color</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-variable">$accent-color</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.button</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#750c30</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#f5ebfc</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;&#125;</code></pre></div><h3 id="⚠️注意！"><a href="#⚠️注意！" class="headerlink" title="⚠️注意！"></a>⚠️注意！</h3><p>流控制范围内的变量可以修改外部范围内的现有变量，但它们不能在那里声明新变量。确保变量在分配之前已经声明，即使您需要将其声明为 <code>null</code>.</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-tag">nav</span> &#123;  <span class="hljs-selector-tag">ul</span> &#123;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">list-style</span>: none;  &#125;  <span class="hljs-selector-tag">li</span> &#123; <span class="hljs-attribute">display</span>: inline-block; &#125;  <span class="hljs-selector-tag">a</span> &#123;    <span class="hljs-attribute">display</span>: block;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">6px</span> <span class="hljs-number">12px</span>;    <span class="hljs-attribute">text-decoration</span>: none;  &#125;&#125;</code></pre></div><h3 id="scss片段"><a href="#scss片段" class="headerlink" title="scss片段"></a>scss片段</h3><p>你可以创建一个scss片段进行重复利用，例如编写一个以下环线开头的scss文件，而这个文件不会被编写成css文件，他可以在其他scss中被引用，使用@use进行引用这个文件</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// _base.scss</span><span class="hljs-variable">$font-stack</span>: Helvetica, sans-serif;<span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#333</span>;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> <span class="hljs-variable">$font-stack</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// styles.scss</span><span class="hljs-keyword">@use</span> <span class="hljs-string">&#x27;base&#x27;</span>;<span class="hljs-selector-class">.inverse</span> &#123;  <span class="hljs-attribute">background-color</span>: base.<span class="hljs-variable">$primary-color</span>;  <span class="hljs-attribute">color</span>: white;&#125;</code></pre></div><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> theme(<span class="hljs-variable">$theme</span>: DarkGray) &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-variable">$theme</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-variable">$theme</span>, .<span class="hljs-number">25</span>);  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.info</span> &#123;  <span class="hljs-keyword">@include</span> theme;&#125;<span class="hljs-selector-class">.alert</span> &#123;  <span class="hljs-keyword">@include</span> theme(<span class="hljs-variable">$theme</span>: DarkRed);&#125;<span class="hljs-selector-class">.success</span> &#123;  <span class="hljs-keyword">@include</span> theme(<span class="hljs-variable">$theme</span>: DarkGreen);&#125;</code></pre></div><p>转化成</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.info</span> &#123;  <span class="hljs-attribute">background</span>: DarkGray;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">169</span>, <span class="hljs-number">169</span>, <span class="hljs-number">169</span>, <span class="hljs-number">0.25</span>);  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.alert</span> &#123;  <span class="hljs-attribute">background</span>: DarkRed;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">139</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>);  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.success</span> &#123;  <span class="hljs-attribute">background</span>: DarkGreen;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>);  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;</code></pre></div><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">/* This CSS will print because %message-shared is extended. */</span>%message-shared &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-comment">// This CSS won&#x27;t print because %equal-heights is never extended.</span>%equal-heights &#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">flex-wrap</span>: wrap;&#125;<span class="hljs-selector-class">.message</span> &#123;  <span class="hljs-keyword">@extend</span> %message-shared;&#125;<span class="hljs-selector-class">.success</span> &#123;  <span class="hljs-keyword">@extend</span> %message-shared;  <span class="hljs-attribute">border-color</span>: green;&#125;<span class="hljs-selector-class">.error</span> &#123;  <span class="hljs-keyword">@extend</span> %message-shared;  <span class="hljs-attribute">border-color</span>: red;&#125;<span class="hljs-selector-class">.warning</span> &#123;  <span class="hljs-keyword">@extend</span> %message-shared;  <span class="hljs-attribute">border-color</span>: yellow;&#125;</code></pre></div><h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;sass:math&quot;</span>;<span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-tag">article</span><span class="hljs-selector-attr">[role=<span class="hljs-string">&quot;main&quot;</span>]</span> &#123;  <span class="hljs-attribute">width</span>: math.<span class="hljs-built_in">div</span>(<span class="hljs-number">600px</span>, <span class="hljs-number">960px</span>) * <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-tag">aside</span><span class="hljs-selector-attr">[role=<span class="hljs-string">&quot;complementary&quot;</span>]</span> &#123;  <span class="hljs-attribute">width</span>: math.<span class="hljs-built_in">div</span>(<span class="hljs-number">300px</span>, <span class="hljs-number">960px</span>) * <span class="hljs-number">100%</span>;  <span class="hljs-attribute">margin-left</span>: auto;&#125;</code></pre></div><h3 id="选择器列表"><a href="#选择器列表" class="headerlink" title="选择器列表"></a>选择器列表</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.alert</span>, <span class="hljs-selector-class">.warning</span> &#123;  <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">0</span>;  &#125;&#125;</code></pre></div><p>转成css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.alert</span> <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-class">.alert</span> <span class="hljs-selector-tag">p</span>, <span class="hljs-selector-class">.warning</span> <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-class">.warning</span> <span class="hljs-selector-tag">p</span> &#123;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="选择器组合器"><a href="#选择器组合器" class="headerlink" title="选择器组合器"></a>选择器组合器</h3><p>您也可以嵌套使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators#Combinators">组合</a>器的选择器。您可以将组合器放在外部选择器的末尾，内部选择器的开头，或者甚至都放在两者之间。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-tag">ul</span> &gt; &#123;  <span class="hljs-selector-tag">li</span> &#123;    <span class="hljs-attribute">list-style-type</span>: none;  &#125;&#125;<span class="hljs-selector-tag">h2</span> &#123;  + <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid gray;  &#125;&#125;<span class="hljs-selector-tag">p</span> &#123;  ~ &#123;    <span class="hljs-selector-tag">span</span> &#123;      <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;    &#125;  &#125;&#125;</code></pre></div><p>等价于css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">list-style-type</span>: none;&#125;<span class="hljs-selector-tag">h2</span> + <span class="hljs-selector-tag">p</span> &#123;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid gray;&#125;<span class="hljs-selector-tag">p</span> ~ <span class="hljs-selector-tag">span</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;&#125;</code></pre></div><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>您可以使用<a href="https://sass-lang.com/documentation/interpolation">插值</a>将 变量和函数调用等<a href="https://sass-lang.com/documentation/syntax/structure#expressions">表达式中的值注入选择器。</a>这在您编写<a href="https://sass-lang.com/documentation/at-rules/mixin">mixins</a>时特别有用，因为它允许您根据用户传入的参数创建选择器。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> define-emoji(<span class="hljs-variable">$name</span>, <span class="hljs-variable">$glyph</span>) &#123;  <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.emoji-</span>#&#123;<span class="hljs-variable">$name</span>&#125; &#123;    <span class="hljs-attribute">font-family</span>: IconFont;    <span class="hljs-attribute">font-variant</span>: normal;    <span class="hljs-attribute">font-weight</span>: normal;    <span class="hljs-attribute">content</span>: <span class="hljs-variable">$glyph</span>;  &#125;&#125;<span class="hljs-keyword">@include</span> define-emoji(<span class="hljs-string">&quot;women-holding-hands&quot;</span>, <span class="hljs-string">&quot;👭&quot;</span>);</code></pre></div><p>转成css</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@charset</span> <span class="hljs-string">&quot;UTF-8&quot;</span>;<span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.emoji-women-holding-hands</span> &#123;  <span class="hljs-attribute">font-family</span>: IconFont;  <span class="hljs-attribute">font-variant</span>: normal;  <span class="hljs-attribute">font-weight</span>: normal;  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;👭&quot;</span>;&#125;</code></pre></div><p>插值几乎可以在 Sass 样式表中的任何地方使用，以将<a href="https://sass-lang.com/documentation/syntax/structure#expressions">SassScript 表达式</a>的结果嵌入到 CSS 块中。只需在以下任何地方包装一个表达式<code>#&#123;&#125;</code>：</p><h4 id="在sassscript中使用"><a href="#在sassscript中使用" class="headerlink" title="在sassscript中使用"></a>在sassscript中使用</h4><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> inline-animation(<span class="hljs-variable">$duration</span>) &#123;  <span class="hljs-variable">$name</span>: inline-#&#123;<span class="hljs-built_in">unique-id</span>()&#125;;  <span class="hljs-keyword">@keyframes</span> #&#123;<span class="hljs-variable">$name</span>&#125; &#123;    <span class="hljs-keyword">@content</span>;  &#125;  <span class="hljs-attribute">animation-name</span>: <span class="hljs-variable">$name</span>;  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-variable">$duration</span>;  <span class="hljs-attribute">animation-iteration-count</span>: infinite;&#125;<span class="hljs-selector-class">.pulse</span> &#123;  <span class="hljs-keyword">@include</span> inline-animation(<span class="hljs-number">2s</span>) &#123;    from &#123; <span class="hljs-attribute">background-color</span>: yellow &#125;    to &#123; <span class="hljs-attribute">background-color</span>: red &#125;  &#125;&#125;</code></pre></div><p>转成css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.pulse</span> &#123;  <span class="hljs-attribute">animation-name</span>: inline-uoqjh6kaq;  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">2s</span>;  <span class="hljs-attribute">animation-iteration-count</span>: infinite;&#125;<span class="hljs-keyword">@keyframes</span> inline-uoqjh6kaq &#123;  <span class="hljs-selector-tag">from</span> &#123;    <span class="hljs-attribute">background-color</span>: yellow;  &#125;  <span class="hljs-selector-tag">to</span> &#123;    <span class="hljs-attribute">background-color</span>: red;  &#125;&#125;</code></pre></div><h4 id="引用字符串"><a href="#引用字符串" class="headerlink" title="引用字符串"></a>引用字符串</h4><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.example</span> &#123;  unquoted: #&#123;&quot;string&quot;&#125;;&#125;</code></pre></div><p>Css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.example</span> &#123;  unquoted: #&#123;&quot;string&quot;&#125;;&#125;</code></pre></div><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><p>在sass中和在css中一样，属性声明定义匹配元素选择器的样式，但是sass添加了额外的功能，例如样式的值可以是任何变量</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.circle</span> &#123;  <span class="hljs-variable">$size</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-variable">$size</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-variable">$size</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$size</span> * <span class="hljs-number">0.5</span>;&#125;</code></pre></div><p>转成css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.circle</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>;&#125;</code></pre></div><p>属性的名称可以包含<a href="https://sass-lang.com/documentation/interpolation">插值</a>，这使得可以根据需要动态生成属性。您甚至可以插入整个属性名称！</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> prefix(<span class="hljs-variable">$property</span>, <span class="hljs-variable">$value</span>, <span class="hljs-variable">$prefixes</span>) &#123;  <span class="hljs-keyword">@each</span> <span class="hljs-variable">$prefix</span> in <span class="hljs-variable">$prefixes</span> &#123;    -#&#123;<span class="hljs-variable">$prefix</span>&#125;-#&#123;<span class="hljs-variable">$property</span>&#125;: <span class="hljs-variable">$value</span>;  &#125;  #&#123;<span class="hljs-variable">$property</span>&#125;: <span class="hljs-variable">$value</span>;&#125;<span class="hljs-selector-class">.gray</span> &#123;  <span class="hljs-keyword">@include</span> prefix(filter, grayscale(<span class="hljs-number">50%</span>), moz webkit);&#125;</code></pre></div><p>转成</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.gray</span> &#123;  -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">50%</span>);  -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">50%</span>);  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">50%</span>);&#125;</code></pre></div><p>许多CSS属性都以作为一种命名空间的相同前缀开头。例如，<code>font-family</code>，<code>font-size</code>，并且<code>font-weight</code>都以 开头<code>font-</code>。Sass 通过允许嵌套属性声明使这变得更容易且更少冗余。外部属性名称被添加到内部，用连字符分隔。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.enlarge</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">transition</span>: &#123;    property: font-size;    duration: <span class="hljs-number">4s</span>;    delay: <span class="hljs-number">2s</span>;  &#125;  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>; &#125;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.enlarge</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">transition-property</span>: font-size;  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">4s</span>;  <span class="hljs-attribute">transition-delay</span>: <span class="hljs-number">2s</span>;&#125;<span class="hljs-selector-class">.enlarge</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>;&#125;</code></pre></div><p>其中一些CSS属性具有使用命名空间作为属性名称的简写版本。对于这些，您可以编写简写值<em>和</em> 更明确的嵌套版本</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.info-page</span> &#123;  <span class="hljs-attribute">margin</span>: auto &#123;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;  &#125;&#125;</code></pre></div><p>Css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.info-page</span> &#123;  <span class="hljs-attribute">margin</span>: auto;  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">2px</span>;&#125;</code></pre></div><p>如果希望通过true/false来控制属性的隐藏和展示，如果一个声明的值是<a href="https://sass-lang.com/documentation/values/null"><code>null</code></a>或一个空的未加<a href="https://sass-lang.com/documentation/values/strings#unquoted">引号的字符串</a>，Sass 根本不会将该声明编译成CSS。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$rounded-corners</span>: false;<span class="hljs-selector-class">.button</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-built_in">if</span>(<span class="hljs-variable">$rounded-corners</span>, <span class="hljs-number">5px</span>, null);&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;&#125;</code></pre></div><p>定义css变量</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$primary</span>: <span class="hljs-number">#81899b</span>;<span class="hljs-variable">$accent</span>: <span class="hljs-number">#302e24</span>;<span class="hljs-variable">$warn</span>: <span class="hljs-number">#dfa612</span>;<span class="hljs-selector-pseudo">:root</span> &#123;  <span class="hljs-attr">--primary</span>: #&#123;<span class="hljs-variable">$primary</span>&#125;;  <span class="hljs-attr">--accent</span>: #&#123;<span class="hljs-variable">$accent</span>&#125;;  <span class="hljs-attr">--warn</span>: #&#123;<span class="hljs-variable">$warn</span>&#125;;  <span class="hljs-comment">// Even though this looks like a Sass variable, it&#x27;s valid CSS so it&#x27;s not</span>  <span class="hljs-comment">// evaluated.</span>  <span class="hljs-attr">--consumed-by-js</span>: <span class="hljs-variable">$primary</span>;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;  <span class="hljs-attr">--primary</span>: <span class="hljs-number">#81899b</span>;  <span class="hljs-attr">--accent</span>: <span class="hljs-number">#302e24</span>;  <span class="hljs-attr">--warn</span>: <span class="hljs-number">#dfa612</span>;  <span class="hljs-attr">--consumed-by-js</span>: $primary;&#125;</code></pre></div><h3 id="父选择器"><a href="#父选择器" class="headerlink" title="父选择器"></a>父选择器</h3><p>父选择器<code>&amp;</code>是 Sass 发明的一种特殊选择器，在<a href="https://sass-lang.com/documentation/style-rules#nesting">嵌套选择器</a>中用于引用外部选择器。它可以以更复杂的方式重用外部选择器，例如添加<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">伪类</a>或在父级<em>之前添加选择器。</em></p><p>当在内部选择器中使用父选择器时，它会被相应的外部选择器替换。发生这种情况而不是正常的嵌套行为</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.alert</span> &#123;  <span class="hljs-comment">// The parent selector can be used to add pseudo-classes to the outer</span>  <span class="hljs-comment">// selector.</span>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;    <span class="hljs-attribute">font-weight</span>: bold;  &#125;  <span class="hljs-comment">// It can also be used to style the outer selector in a certain context, such</span>  <span class="hljs-comment">// as a body set to use a right-to-left language.</span>  <span class="hljs-selector-attr">[dir=rtl]</span> &amp; &#123;    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;  &#125;  <span class="hljs-comment">// You can even use it as an argument to pseudo-class selectors.</span>  <span class="hljs-selector-pseudo">:not</span>(&amp;) &#123;    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;  &#125;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.alert</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">font-weight</span>: bold;&#125;<span class="hljs-selector-attr">[dir=rtl]</span> <span class="hljs-selector-class">.alert</span> &#123;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.alert</span>) &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;&#125;</code></pre></div><p>您还可以使用父选择器向外部选择器添加额外的后缀。<a href="http://getbem.com/">这在使用像BEM</a> 这样使用高度结构化类名的方法时特别有用。只要外部选择器以字母数字名称结尾（如类、ID和元素选择器），您就可以使用父选择器附加附加文本。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.accordion</span> &#123;  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">4rem</span> auto;  <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Raleway&quot;</span>, sans-serif;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f4f4f4</span>;  &amp;__copy &#123;    <span class="hljs-attribute">display</span>: none;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span> <span class="hljs-number">1.5rem</span> <span class="hljs-number">2rem</span> <span class="hljs-number">1.5rem</span>;    <span class="hljs-attribute">color</span>: gray;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">500</span>;    &amp;<span class="hljs-attr">--open</span> &#123;      <span class="hljs-attribute">display</span>: block;    &#125;  &#125;&#125;</code></pre></div><p>Css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.accordion</span> &#123;  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">4rem</span> auto;  <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Raleway&quot;</span>, sans-serif;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f4f4f4</span>;&#125;<span class="hljs-selector-class">.accordion__copy</span> &#123;  <span class="hljs-attribute">display</span>: none;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span> <span class="hljs-number">1.5rem</span> <span class="hljs-number">2rem</span> <span class="hljs-number">1.5rem</span>;  <span class="hljs-attribute">color</span>: gray;  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">500</span>;&#125;<span class="hljs-selector-class">.accordion__copy--open</span> &#123;  <span class="hljs-attribute">display</span>: block;&#125;</code></pre></div><h3 id="占位符选择器"><a href="#占位符选择器" class="headerlink" title="占位符选择器"></a>占位符选择器</h3><p>占位符选择器是以%开头的选择器，他不会包含在输出css文件中，</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.alert</span><span class="hljs-selector-pseudo">:hover</span>, %<span class="hljs-selector-tag">strong</span>-alert &#123;  <span class="hljs-attribute">font-weight</span>: bold;&#125;%<span class="hljs-selector-tag">strong</span>-alert<span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">color</span>: red;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.alert</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">font-weight</span>: bold;&#125;</code></pre></div><p>占位符的使用</p><div class="code-wrapper"><pre><code class="hljs scss">%toolbelt &#123;  <span class="hljs-attribute">box-sizing</span>: border-box;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">#000</span>, .<span class="hljs-number">12</span>) solid;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span> <span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">#000</span>, .<span class="hljs-number">5</span>) solid; &#125;&#125;<span class="hljs-selector-class">.action-buttons</span> &#123;  <span class="hljs-keyword">@extend</span> %toolbelt;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#4285f4</span>;&#125;<span class="hljs-selector-class">.reset-buttons</span> &#123;  <span class="hljs-keyword">@extend</span> %toolbelt;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#cddc39</span>;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.action-buttons</span>, <span class="hljs-selector-class">.reset-buttons</span> &#123;  <span class="hljs-attribute">box-sizing</span>: border-box;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.12</span>) solid;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span> <span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-class">.action-buttons</span><span class="hljs-selector-pseudo">:hover</span>, <span class="hljs-selector-class">.reset-buttons</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>) solid;&#125;<span class="hljs-selector-class">.action-buttons</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#4285f4</span>;&#125;<span class="hljs-selector-class">.reset-buttons</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#cddc39</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
      <category>scss</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在webpack中配置typescript</title>
    <link href="/2022/10/24/%E5%9C%A8webpack%E4%B8%AD%E9%85%8D%E7%BD%AEtypescript/"/>
    <url>/2022/10/24/%E5%9C%A8webpack%E4%B8%AD%E9%85%8D%E7%BD%AEtypescript/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack,typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript类型体操</title>
    <link href="/2022/10/23/typescript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"/>
    <url>/2022/10/23/typescript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="内置工具和类型体操"><a href="#内置工具和类型体操" class="headerlink" title="内置工具和类型体操"></a><strong>内置工具和类型体操</strong></h1><p><strong>类型系统其实在很多语言里面都是有的，比如Java、Swift、C++等等，但是相对来说TypeScript的类型非常灵活：</strong></p><p>这是因为TypeScript的目的是为JavaScript添加一套类型校验系统，因为JavaScript本身的灵活性，也让TypeScript类型系统</p><p>不得不增加更附加的功能以适配JavaScript的灵活性；</p><p>所以TypeScript是一种可以支持类型编程的类型系统； </p><p><strong>这种类型编程系统为TypeScript增加了很大的灵活度，同时也增加了它的难度：</strong></p><p>如果你不仅仅在开发业务的时候为自己的JavaScript代码增加上类型约束，那么基本不需要太多的类型编程能力；</p><p>但是如果你在开发一些框架、库，或者通用性的工具，为了考虑各种适配的情况，就需要使用类型编程； </p><p><strong>TypeScript本身为我们提供了类型工具，帮助我们辅助进行类型转换（前面有用过关于this的类型工具）。</strong></p><p><strong>很多开发者为了进一步增强自己的TypeScript编程能力，还会专门去做一些类型体操的题目：</strong></p><p><a href="https://github.com/type-challenges/type-challenges">https://github.com/type-challenges/type-challenges</a></p><p><a href="https://ghaiklor.github.io/type-challenges-solutions/en/">https://ghaiklor.github.io/type-challenges-solutions/en/</a></p><h3 id="条件类型（Conditional-Types）"><a href="#条件类型（Conditional-Types）" class="headerlink" title="条件类型（Conditional Types）"></a><strong>条件类型（Conditional Types）</strong></h3><p>很多时候，日常开发中我们需要基于输入的值来决定输出的值，同样我们也需要基于输入的值的类型来决定输出的值的类型</p><p><strong>条件类型（</strong>Conditional types）就是用来帮助我们描述输入类型和输出类型之间的关系。</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-title function_">live</span>(): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-title function_">woof</span>(): <span class="hljs-built_in">void</span>;&#125; <span class="hljs-keyword">type</span> <span class="hljs-title class_">Example1</span> = <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>; <span class="hljs-keyword">type</span> <span class="hljs-title class_">Example2</span> = <span class="hljs-title class_">RegExp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-comment">// 举个栗子: 函数的重载</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1: <span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1: <span class="hljs-built_in">string</span>, num2: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><span class="hljs-comment">// 错误的做法: 类型扩大化</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span><span class="hljs-comment">//正确的写法</span><span class="hljs-keyword">function</span> sum&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;(<span class="hljs-attr">num1</span>: T, <span class="hljs-attr">num2</span>: T): T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>? <span class="hljs-attr">number</span>:<span class="hljs-built_in">string</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-keyword">return</span> num1 + num2&#125;</code></pre></div><p>条件类型看起来有点像 JavaScript 中的条件表达式（<code>条件 ? true 表达式 : false 表达式</code>）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">SomeType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OtherType</span> ? <span class="hljs-title class_">TrueType</span> : <span class="hljs-title class_">FalseType</span>;</code></pre></div><h4 id="条件类型约束"><a href="#条件类型约束" class="headerlink" title="条件类型约束"></a>条件类型约束</h4><p>通常，条件类型的检查将为我们提供一些新信息。 就像使用类型守卫缩小范围可以给我们提供更具体的类型一样，条件类型的 true 分支将根据我们检查的类型进一步约束泛型。</p><p>让我们来看看下面的例子：</p><div class="code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">type</span> MessageOf&lt;<span class="hljs-built_in">T</span>&gt; = <span class="hljs-built_in">T</span>[<span class="hljs-string">&quot;message&quot;</span>];<span class="hljs-built_in">Type</span> &#x27;<span class="hljs-string">&quot;message&quot;</span>&#x27; cannot be used to <span class="hljs-built_in">index</span> <span class="hljs-built_in">type</span> &#x27;<span class="hljs-built_in">T</span>&#x27;.<span class="hljs-built_in">Type</span> &#x27;<span class="hljs-string">&quot;message&quot;</span>&#x27; cannot be used to <span class="hljs-built_in">index</span> <span class="hljs-built_in">type</span> &#x27;<span class="hljs-built_in">T</span>&#x27;.</code></pre></div><p>在本例中，TypeScript 产生错误是因为不知道 <code>T</code> 有一个名为 <code>message</code> 的属性。 我们可以约束 <code>T</code>，TypeScript 也不会再抱怨了：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MessageOf</span>&lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-built_in">unknown</span> &#125;&gt; = T[<span class="hljs-string">&quot;message&quot;</span>]; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Email</span> &#123;  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;&#125; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> &#123;  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;&#125; <span class="hljs-keyword">type</span> <span class="hljs-title class_">EmailMessageContents</span> = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Email</span>&gt;;</code></pre></div><p>然而，如果我们希望 <code>MessageOf</code> 接受任何类型，并且在 <code>message</code> 属性不可用的情况下默认为 <code>never</code> 之类的类型，我们应该怎么做呢？ 我们可以通过移出约束并引入条件类型来实现这一点：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MessageOf</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-built_in">unknown</span> &#125; ? T[<span class="hljs-string">&quot;message&quot;</span>] : <span class="hljs-built_in">never</span>; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Email</span> &#123;  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;&#125; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> &#123;  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;&#125; <span class="hljs-keyword">type</span> <span class="hljs-title class_">EmailMessageContents</span> = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Email</span>&gt;; <span class="hljs-keyword">type</span> <span class="hljs-title class_">DogMessageContents</span> = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Dog</span>&gt;;</code></pre></div><p>在 true 分支中，TypeScript 知道 <code>T</code> <em>将</em> 有一个 <code>message</code> 属性。</p><p>作为另一个示例，我们还可以编写一个名为 <code>Flatten</code> 的类型，它将数组类型扁平为它们的元素类型，但在其他情况下不会处理它们：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Flatten</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[] ? T[<span class="hljs-built_in">number</span>] : T; <span class="hljs-comment">// Extracts out the element type.</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Str</span> = <span class="hljs-title class_">Flatten</span>&lt;<span class="hljs-built_in">string</span>[]&gt;;<span class="hljs-comment">//type Str = string</span> <span class="hljs-comment">// Leaves the type alone.</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Num</span> = <span class="hljs-title class_">Flatten</span>&lt;<span class="hljs-built_in">number</span>&gt;;<span class="hljs-comment">//number</span></code></pre></div><h4 id="在条件类型中推断（infer）"><a href="#在条件类型中推断（infer）" class="headerlink" title="在条件类型中推断（infer）"></a><strong>在条件类型中推断（infer）</strong></h4><p>我们发现自己使用条件类型来应用约束，然后提取出类型。 这最终成为一种非常常见的操作，条件类型使其变得更容易。</p><p>条件类型为我们提供了一种使用 <code>infer</code> 关键字从 true 分支中与之进行比较的类型中进行推断的方法。 例如，我们可以在 <code>Flatten</code> 中推断元素类型，而不是使用索引访问类型“手动”提取它：</p><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">Flatten&lt;<span class="hljs-keyword">Type</span>&gt; </span>= <span class="hljs-keyword">Type</span> <span class="hljs-type">extends </span><span class="hljs-keyword">Array</span>&lt;infer Item&gt; ? Item : <span class="hljs-type">Type</span>;</code></pre></div><p>在这里，我们使用 <code>infer</code> 关键字以声明方式引入一个名为 <code>Item</code> 的新泛型类型变量，而不是指定如何在 true 分支中检索元素类型 <code>T</code>。 这使我们不必考虑如何挖掘和探索我们感兴趣的类型的结构。</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">CalcFnType</span> = <span class="hljs-function">(<span class="hljs-params">num1: <span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>&#125;<span class="hljs-comment">// 总结类型体操题目: MyReturnType：推断返回值  传入的值必须是函数 </span><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R? <span class="hljs-attr">R</span>: <span class="hljs-built_in">never</span><span class="hljs-comment">//推断参数类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyParameterType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer A) =&gt; <span class="hljs-built_in">any</span>? <span class="hljs-attr">A</span>: <span class="hljs-built_in">never</span><span class="hljs-comment">// 获取一个函数的返回值类型: 内置工具 returntypeß</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">CalcReturnType</span> = <span class="hljs-title class_">MyReturnType</span>&lt;<span class="hljs-title class_">CalcFnType</span>&gt;<span class="hljs-keyword">type</span> <span class="hljs-title class_">FooReturnType</span> = <span class="hljs-title class_">MyReturnType</span>&lt;<span class="hljs-keyword">typeof</span> foo&gt;<span class="hljs-comment">// type FooReturnType2 = MyReturnType&lt;boolean&gt;</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">CalcParameterType</span> = <span class="hljs-title class_">MyParameterType</span>&lt;<span class="hljs-title class_">CalcFnType</span>&gt;<span class="hljs-keyword">export</span> &#123;&#125;</code></pre></div><p>我们可以使用 <code>infer</code> 关键字编写一些有用的助手类型别名。 例如，对于简单的情况，我们可以从函数类型中提取返回类型：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-title class_">Type</span>&gt; = <span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">never</span>[]) =&gt; infer <span class="hljs-title class_">Return</span>  ? <span class="hljs-title class_">Return</span>  : <span class="hljs-built_in">never</span>; <span class="hljs-keyword">type</span> <span class="hljs-title class_">Num</span> = <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">number</span>&gt;;<span class="hljs-comment">//type Num = number</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Str</span> = <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>&gt;;<span class="hljs-comment">//type Str = string</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Bools</span> = <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">boolean</span>, b: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>[]&gt;;<span class="hljs-comment">//type Bools = boolean[]</span></code></pre></div><h4 id="分发条件类型（Distributive-Conditional-Types）"><a href="#分发条件类型（Distributive-Conditional-Types）" class="headerlink" title="分发条件类型（Distributive Conditional Types）"></a><strong>分发条件类型（Distributive Conditional Types）</strong></h4><p><strong>当在泛型中使用条件类型的时候，如果传入一个联合类型，就会变成</strong> <strong>分发的（</strong>distributive****）</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> toArray&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>? T[]: <span class="hljs-built_in">never</span><span class="hljs-comment">// number[]|string[]</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumArray</span> = toArray&lt;<span class="hljs-built_in">number</span>&gt;<span class="hljs-comment">// number[]|string[] 而不是 (number|string)[]</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumAndStrArray</span> = toArray&lt;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>&gt;</code></pre></div><p>通常，分布性是所需的行为。 要避免这种行为，可以用方括号括起 <code>extends</code> 关键字的两边。</p><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">ToArrayNonDist&lt;<span class="hljs-keyword">Type</span>&gt; </span>= [<span class="hljs-keyword">Type</span>] extends [any] ? <span class="hljs-keyword">Type</span>[] : <span class="hljs-type">never</span>; // <span class="hljs-symbol">&#x27;StrOrNumArr</span>&#x27; 不再是一个联合类型<span class="hljs-keyword">type</span> <span class="hljs-type">StrOrNumArr </span>= ToArrayNonDist&lt;string | number&gt;;//<span class="hljs-keyword">type</span> <span class="hljs-type">StrOrNumArr </span>= (string | number)[]</code></pre></div><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<Type></h3><p><strong>用于构造一个Type下面的所有属性都设置为可选的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYPartial</span>&lt;T&gt; = &#123;  [P <span class="hljs-keyword">in</span> keyof T]?: T[P] &#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKunOptional</span> = <span class="hljs-title class_">HYPartial</span>&lt;<span class="hljs-title class_">IKun</span>&gt;</code></pre></div><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a><strong>Required<Type></strong></h3><p>用于构造一个Type下面的所有属性全都设置为必填的类型，这个工具类型跟 Partial 相反。</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYRequired</span>&lt;T&gt; = &#123;  [P <span class="hljs-keyword">in</span> keyof T]-?: T[P] &#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun2</span> = <span class="hljs-title class_">Required</span>&lt;<span class="hljs-title class_">IKun</span>&gt;</code></pre></div><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a><strong>Readonly<Type></strong></h3><p><strong>用于构造一个Type下面的所有属性全都设置为只读的类型，意味着这个类型的所有的属性全都不可以重新赋值</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYReadonly</span>&lt;T&gt; = &#123;  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P] &#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun2</span> = <span class="hljs-title class_">HYReadonly</span>&lt;<span class="hljs-title class_">IKun</span>&gt;</code></pre></div><h3 id="Record-lt-Keys-Type-gt"><a href="#Record-lt-Keys-Type-gt" class="headerlink" title="Record&lt;Keys, Type&gt;"></a><strong>Record&lt;Keys, Type&gt;</strong></h3><p><strong>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;  slogan?: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-comment">// name | age | slogan</span><span class="hljs-keyword">type</span> keys = keyof <span class="hljs-title class_">IKun</span>; <span class="hljs-comment">//keyof 会变成联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Res</span> = keyof <span class="hljs-built_in">any</span>; <span class="hljs-comment">// =&gt; number|string|symbol type Res = string | number | symbol</span><span class="hljs-comment">// 确实keys一定是可以作为key的联合类型 keyof any=&gt;string | number | symbol 一定可以作为对象的key</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYRecord</span>&lt;<span class="hljs-title class_">Keys</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>, T&gt; = &#123;  [P <span class="hljs-keyword">in</span> <span class="hljs-title class_">Keys</span>]: T;&#125;;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> t1 = <span class="hljs-string">&quot;上海&quot;</span> | <span class="hljs-string">&quot;北京&quot;</span> | <span class="hljs-string">&quot;洛杉矶&quot;</span>;<span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYRecord</span>&lt;t1, <span class="hljs-title class_">IKun</span>&gt;;<span class="hljs-keyword">const</span> <span class="hljs-attr">ikuns</span>: <span class="hljs-title class_">IKuns</span> = &#123;  上海: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xxx&quot;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,  &#125;,  北京: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;yyy&quot;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>,  &#125;,  洛杉矶: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zzz&quot;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,  &#125;,&#125;;</code></pre></div><h3 id="Pick-lt-Type-Keys-gt"><a href="#Pick-lt-Type-Keys-gt" class="headerlink" title="Pick&lt;Type, Keys&gt;"></a><strong>Pick&lt;Type, Keys&gt;</strong></h3><p>用于构造一个类型，它是从Type类型里面挑了一些属性Keys</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYPick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;  [P <span class="hljs-keyword">in</span> K]: T[P]&#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYPick</span>&lt;<span class="hljs-title class_">IKun</span>, <span class="hljs-string">&quot;slogan&quot;</span>|<span class="hljs-string">&quot;name&quot;</span>&gt;</code></pre></div><h3 id="Omit-lt-Type-Keys-gt"><a href="#Omit-lt-Type-Keys-gt" class="headerlink" title="Omit&lt;Type, Keys&gt;"></a><strong>Omit&lt;Type, Keys&gt;</strong></h3><p><strong>用于构造一个类型，它是从Type类型里面过滤了一些属性Keys</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYOmit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;  [P <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> P <span class="hljs-keyword">extends</span> K ? <span class="hljs-attr">never</span>: P]: T[P]&#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYOmit</span>&lt;<span class="hljs-title class_">IKun</span>, <span class="hljs-string">&quot;slogan&quot;</span>|<span class="hljs-string">&quot;name&quot;</span>&gt;<span class="hljs-keyword">export</span> &#123;&#125;</code></pre></div><h3 id="Exclude-lt-UnionType-ExcludedMembers-gt"><a href="#Exclude-lt-UnionType-ExcludedMembers-gt" class="headerlink" title="Exclude&lt;UnionType, ExcludedMembers&gt;"></a><strong>Exclude&lt;UnionType, ExcludedMembers&gt;</strong></h3><p>从联合类型中排除一些类型</p><div class="code-wrapper"><pre><code class="hljs fsharp"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sing&quot;</span> <span class="hljs-operator">|</span> <span class="hljs-string">&quot;dance&quot;</span> <span class="hljs-operator">|</span> <span class="hljs-string">&quot;rap&quot;</span><span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYExclude</span><span class="hljs-operator">&lt;</span>T, E<span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span> T extends E<span class="hljs-operator">?</span> never<span class="hljs-operator">:</span> T<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> <span class="hljs-operator">=</span> HYExclude<span class="hljs-operator">&lt;</span>IKun, <span class="hljs-string">&quot;rap&quot;</span><span class="hljs-operator">&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>&gt;;<span class="hljs-comment">//type T0 = &quot;b&quot; | &quot;c&quot;</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span>&gt;;<span class="hljs-comment">//type T1 = &quot;c&quot;</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-title class_">Function</span>&gt;;<span class="hljs-comment">//type T2 = string | number</span></code></pre></div><h3 id="Extract-lt-Type-Union-gt"><a href="#Extract-lt-Type-Union-gt" class="headerlink" title="Extract&lt;Type, Union&gt;"></a><strong>Extract&lt;Type, Union&gt;</strong></h3><p><strong>用于构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;f&quot;</span>&gt;;<span class="hljs-comment">//type T0 = &quot;a&quot;</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-title class_">Function</span>&gt;;<span class="hljs-comment">//type T1 = () =&gt; void</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun</span> = <span class="hljs-string">&quot;sing&quot;</span> | <span class="hljs-string">&quot;dance&quot;</span> | <span class="hljs-string">&quot;rap&quot;</span><span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYExtract</span>&lt;T, E&gt; = T <span class="hljs-keyword">extends</span> E? <span class="hljs-attr">T</span>: <span class="hljs-built_in">never</span><span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYExtract</span>&lt;<span class="hljs-title class_">IKun</span>, <span class="hljs-string">&quot;rap&quot;</span>|<span class="hljs-string">&quot;dance&quot;</span>&gt;</code></pre></div><h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a><strong>NonNullable<Type></strong></h3><p><strong>用于构造一个类型，这个类型从Type中排除了所有的null、undefined的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun</span> = <span class="hljs-string">&quot;sing&quot;</span> | <span class="hljs-string">&quot;dance&quot;</span> | <span class="hljs-string">&quot;rap&quot;</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span><span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYNonNullable</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span>|<span class="hljs-literal">undefined</span> ? <span class="hljs-attr">never</span>: T<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYNonNullable</span>&lt;<span class="hljs-title class_">IKun</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;;<span class="hljs-comment">//type T0 = string | number</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span>[] | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>&gt;;<span class="hljs-comment">//type T1 = string[]</span></code></pre></div><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a><strong>ReturnType<Type></strong></h3><p><strong>用于构造一个含有Type函数的返回值的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>): &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> &#125;; <span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;;     <span class="hljs-comment">//type T0 = string</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;;     <span class="hljs-comment">//type T1 = void</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ReturnType</span>&lt;&lt;T&gt;<span class="hljs-function">() =&gt;</span> T&gt;;     <span class="hljs-comment">//type T2 = unknown</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">ReturnType</span>&lt;&lt;T <span class="hljs-keyword">extends</span> U, U <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>[]&gt;<span class="hljs-function">() =&gt;</span> T&gt;;     <span class="hljs-comment">//type T3 = number[]</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> f1&gt;;     <span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>;    <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">any</span>&gt;;     <span class="hljs-comment">//type T5 = any</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">never</span>&gt;;     <span class="hljs-comment">//type T6 = never</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T7</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">string</span>&gt;;<span class="hljs-comment">//Type &#x27;string&#x27; does not satisfy the constraint &#x27;(...args: any) =&gt; any&#x27;.</span></code></pre></div><h3 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a><strong>InstanceType<Type></strong></h3><p><strong>用于构造一个由所有Type的构造函数的实例类型组成的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYInstanceType</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R  ? R  : <span class="hljs-built_in">never</span>;<span class="hljs-keyword">const</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">// typeof Person: 构造函数具体的类型</span><span class="hljs-comment">// InstanceType构造函数创建出来的实例对象的类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYPerson</span> = <span class="hljs-title class_">HYInstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>&gt;;<span class="hljs-keyword">const</span> <span class="hljs-attr">p2</span>: <span class="hljs-title class_">HYPerson</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">// 构造函数的例子</span><span class="hljs-comment">// 通过的创建实例的工具函数时会用到这个InstanceType T必须是一个构造函数</span><span class="hljs-keyword">function</span> factory&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt;(  <span class="hljs-attr">ctor</span>: T): <span class="hljs-title class_">HYInstanceType</span>&lt;T&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">ctor</span>();&#125;<span class="hljs-keyword">const</span> p3 = <span class="hljs-title function_">factory</span>(<span class="hljs-title class_">Person</span>);<span class="hljs-keyword">const</span> d = <span class="hljs-title function_">factory</span>(<span class="hljs-title class_">Dog</span>);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>类型体操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tsconfig.js文件解读</title>
    <link href="/2022/10/23/tsconfig-js%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/"/>
    <url>/2022/10/23/tsconfig-js%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>tsconfig</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tsconfig</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS常见的布局方式</title>
    <link href="/2022/10/22/CSS%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/10/22/CSS%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="css常见的几种布局方式"><a href="#css常见的几种布局方式" class="headerlink" title="css常见的几种布局方式"></a>css常见的几种布局方式</h1><h2 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.wrapper</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">max-width</span>: <span class="hljs-number">960px</span>;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>      内容内容 内容内容 内容内容 内容内容 内容内容 内容内容 内容内容    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>单列布局是指在页面中居中布局，margin：auto 0，可以让块级元素居中显示，max-width被设置，在页面中当页面宽度大于960px时，会以max-width进行布局，当页面小于max-width时就会缩小宽度</p><h2 id="两列自适应布局"><a href="#两列自适应布局" class="headerlink" title="两列自适应布局"></a>两列自适应布局</h2><h3 id="两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式"><a href="#两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式" class="headerlink" title="两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式"></a><strong>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式</strong></h3><h4 id="float-overflow-hidden"><a href="#float-overflow-hidden" class="headerlink" title="float+overflow:hidden"></a>float+overflow:hidden</h4><p>如果是普通的两列布局，<strong>浮动+普通元素的margin</strong>便可以实现，但如果是自适应的两列布局，利用<strong>float+overflow:hidden</strong>便可以实现，这种办法主要通过overflow触发BFC,而BFC不会重叠浮动元素。由于设置overflow:hidden并不会触发IE6-浏览器的haslayout属性，所以需要设置zoom:1来兼容IE6-浏览器。具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.parent</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">        zoom: <span class="hljs-number">1</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: brown;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">        zoom: <span class="hljs-number">1</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><strong>注意点:如果侧边栏在右边时，注意渲染顺序。即在HTML中，先写侧边栏后写主内容</strong></p><h4 id="使用flex布局"><a href="#使用flex布局" class="headerlink" title="使用flex布局"></a>使用flex布局</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.parent</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: brown;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="使用grid布局"><a href="#使用grid布局" class="headerlink" title="使用grid布局"></a>使用grid布局</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.parent</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: grid;</span><span class="language-css">        <span class="hljs-attribute">grid-template-columns</span>: auto <span class="hljs-number">1</span>fr;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><span class="language-css">        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">10px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: brown;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>三栏布局就是中间宽度可以自由缩放，两边宽度是固定的</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是dom结构必须是先写中间列部分，这样实现中间列可以优先加载</strong>。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        <span class="hljs-attribute">left</span>: -<span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: blue;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        <span class="hljs-attribute">right</span>: -<span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>圣杯布局<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>圣杯布局父元素需要设置中间的div的padding，使用float进行布局，当中间元素占据width：100%时，左右两边的div会被挤下去，所以需要使用margin，和position进行定位</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>三个部分都设定为左浮动，<strong>否则左右两边内容上不去，就不可能与中间列同一行</strong>。然后设置center的宽度为100%(<strong>实现中间列内容自适应</strong>)，此时，left和right部分会跳到下一行</li></ul><p><img src="https://pic1.zhimg.com/v2-4f1da13dbb42ee61e7986fe27bca776c_r.jpg" alt="img"></p><ul><li>通过设置margin-left为负值让left和right部分回到与center部分同一行</li></ul><p><img src="https://pic4.zhimg.com/80/v2-6d1a7a6762acbe5ab9c315d01554031b_1440w.webp" alt="img"></p><ul><li>通过设置父容器的padding-left和padding-right，让左右两边留出间隙。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-c7a36f977b49d4fa46f0f5a9782c2be6_1440w.webp" alt="img"></p><ul><li>通过设置相对定位，让left和right部分移动到两边。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-b7e5a97b8d57e023ee457dc13f0206d2_1440w.webp" alt="img"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行</li><li>如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决，下文会介绍)</li></ul><p><img src="https://pic3.zhimg.com/80/v2-8bb2a97acd1f52376d69638faf64c4a2_1440w.webp" alt="img"></p><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p><strong>同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题</strong>。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">min-width</span>: <span class="hljs-number">600px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span> <span class="hljs-selector-class">.inner</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>; //新增部分</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: blue;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span>双飞翼布局<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="实现步骤-前两步与圣杯布局一样"><a href="#实现步骤-前两步与圣杯布局一样" class="headerlink" title="实现步骤(前两步与圣杯布局一样)"></a>实现步骤(前两步与圣杯布局一样)</h4><ul><li>三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；</li><li>通过设置margin-left为负值让left和right部分回到与center部分同一行；</li><li>center部分增加一个内层div，并设margin: 0 200px；</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p><strong>多加一层 dom 树节点，增加渲染树生成的计算量</strong>。</p><h4 id="两种布局实现方式对比"><a href="#两种布局实现方式对比" class="headerlink" title="两种布局实现方式对比:"></a>两种布局实现方式对比:</h4><ul><li>两种布局方式都是把主列放在文档流最前面，使主列优先加载。</li><li>两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。</li><li>两种布局方式的不同之处在于如何处理中间主列的位置： <strong>圣杯布局是利用父容器的左、右内边距+两个从列相对定位</strong>； <strong>双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整</strong></li></ul><h2 id="等高布局"><a href="#等高布局" class="headerlink" title="等高布局"></a>等高布局</h2><p>等高布局是指子元素在父元素中高度相等的布局方式。接下来我们介绍常见几种实现方式：</p><h3 id="利用正padding-负margin"><a href="#利用正padding-负margin" class="headerlink" title="利用正padding+负margin"></a>利用正padding+负margin</h3><p>我们通过等布局便可解决圣杯布局的第二点缺点，因为背景是在 padding 区域显示的，<strong>设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉</strong>。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器。新增代码如下：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        <span class="hljs-attribute">left</span>: -<span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: blue;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        <span class="hljs-attribute">right</span>: -<span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span>,</span><span class="language-css">      <span class="hljs-selector-class">.left</span>,</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">10000px</span>;</span><span class="language-css">        <span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">10000px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-comment">/* 把溢出背景切掉 */</span></span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>等高布局<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="利用背景图片"><a href="#利用背景图片" class="headerlink" title="利用背景图片"></a>利用背景图片</h3><p>这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的css样式就可以轻松实现,但此方法不适合流体布局等高列的布局。</p><p>在制作样式之前需要一张类似下面的背景图：</p><p><img src="https://pic1.zhimg.com/80/v2-c4a4a0bfe32023c4773ee8f10e3918fc_1440w.webp" alt="img"></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”container</span> <span class="hljs-attr">clearfix</span>”&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”left”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">”content”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”right”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>.container &#123;  background: url(&quot;column.png&quot;) repeat-y;  width: 960px;  margin: 0 auto;&#125;.left &#123;  float: left;  width: 220px;&#125;.content &#123;  float: left;  width: 480px;&#125;.right &#123;  float: left;  width: 220px;&#125;</code></pre></div><h3 id="模仿表格布局"><a href="#模仿表格布局" class="headerlink" title="模仿表格布局"></a>模仿表格布局</h3><p>这是一种非常简单，易于实现的方法。不过兼容性不好，在ie6-7无法正常运行。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.table</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: auto;</span><span class="language-css">        <span class="hljs-attribute">min-width</span>: <span class="hljs-number">1000px</span>;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">display</span>: table;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.tableRow</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: table-row;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.tableCell</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: table-cell;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">33%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.cell1</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#f00</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.cell2</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#0f0</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.cell3</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#00f</span>;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container table&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;containerInner tableRow&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column tableCell cell1&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left aside&quot;</span>&gt;</span>....<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column tableCell cell2&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content section&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column tableCell cell3&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right aside&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="使用边框和定位"><a href="#使用边框和定位" class="headerlink" title="使用边框和定位"></a>使用边框和定位</h3><p>这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#wrapper</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">960px</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;<span class="hljs-selector-id">#mainContent</span> &#123;  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">220px</span> solid <span class="hljs-number">#dfdfdf</span>;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">width</span>: <span class="hljs-number">740px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;    <span class="hljs-attribute">background</span>: green;&#125;<span class="hljs-selector-id">#sidebar</span> &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#dfdfdf</span>;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">740px</span>;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">220px</span>;&#125;&lt;<span class="hljs-selector-tag">div</span> id=&quot;wrapper&quot;&gt;    &lt;<span class="hljs-selector-tag">div</span> id=&quot;mainContent&quot;&gt;...&lt;/<span class="hljs-selector-tag">div</span>&gt;    &lt;<span class="hljs-selector-tag">div</span> id=&quot;sidebar&quot;&gt;...&lt;/<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;</code></pre></div><h2 id="粘连布局"><a href="#粘连布局" class="headerlink" title="粘连布局"></a>粘连布局</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>有一块内容<code>&lt;main&gt;</code>，当<code>&lt;main&gt;</code>的高康足够长的时候，紧跟在<code>&lt;main&gt;</code>后面的元素<code>&lt;footer&gt;</code>会跟在<code>&lt;main&gt;</code>元素的后面。</li><li>当<code>&lt;main&gt;</code>元素比较短的时候(比如小于屏幕的高度),我们期望这个<code>&lt;footer&gt;</code>元素能够“粘连”在屏幕的底部</li></ul><p><img src="https://pic1.zhimg.com/80/v2-08f08fceaca93e547a19441984cc8720_1440w.webp" alt="img"></p><p>具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      * &#123;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-tag">html</span>,</span><span class="language-css">      <span class="hljs-selector-tag">body</span> &#123;</span><span class="language-css">        <span class="hljs-comment">/* //高度一层层继承下来 */</span></span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-id">#wrap</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: pink;</span><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-id">#wrap</span> <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">50px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-id">#footer</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: deeppink;</span><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><span class="language-css">        <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>        main <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>        main <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>        main <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><h3 id="1-footer必须是一个独立的结构，与wrap没有任何嵌套关系"><a href="#1-footer必须是一个独立的结构，与wrap没有任何嵌套关系" class="headerlink" title="(1)footer必须是一个独立的结构，与wrap没有任何嵌套关系"></a>(1)footer必须是一个独立的结构，与wrap没有任何嵌套关系</h3><h3 id="2-wrap区域的高度通过设置min-height，变为视口高度"><a href="#2-wrap区域的高度通过设置min-height，变为视口高度" class="headerlink" title="(2)wrap区域的高度通过设置min-height，变为视口高度"></a>(2)wrap区域的高度通过设置min-height，变为视口高度</h3><h3 id="3-footer要使用margin为负来确定自己的位置"><a href="#3-footer要使用margin为负来确定自己的位置" class="headerlink" title="(3)footer要使用margin为负来确定自己的位置"></a>(3)footer要使用margin为负来确定自己的位置</h3><h3 id="4-在main区域需要设置-padding-bottom。这也是为了防止负-margin-导致-footer-覆盖任何实际内容。"><a href="#4-在main区域需要设置-padding-bottom。这也是为了防止负-margin-导致-footer-覆盖任何实际内容。" class="headerlink" title="(4)在main区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。"></a>(4)在main区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。</h3>]]></content>
    
    
    
    <tags>
      
      <tag>css布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grid布局</title>
    <link href="/2022/10/19/Grid%E5%B8%83%E5%B1%80/"/>
    <url>/2022/10/19/Grid%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="网格布局的基本概念"><a href="#网格布局的基本概念" class="headerlink" title="网格布局的基本概念"></a>网格布局的基本概念</h1><p>Grid是二维的网格布局系统，可用于布局页面主要的区域布局或小型组件，flex是一维的布局</p><h2 id="什么是网格？"><a href="#什么是网格？" class="headerlink" title="什么是网格？"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E6%A0%BC%EF%BC%9F">什么是网格？</a></h2><p>网格是一组相交的水平线和垂直线，它定义了网格的列和行。我们可以将网格元素放置在与这些行和列相关的位置上。CSS 网格布局具有以下特点</p><h3 id="固定的位置和弹性的轨道的大小"><a href="#固定的位置和弹性的轨道的大小" class="headerlink" title="固定的位置和弹性的轨道的大小"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%9B%BA%E5%AE%9A%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%BC%B9%E6%80%A7%E7%9A%84%E8%BD%A8%E9%81%93%E7%9A%84%E5%A4%A7%E5%B0%8F">固定的位置和弹性的轨道的大小</a></h3><p>你可以使用固定的单位尺寸来构建网格，例如px,或者使用专门为grid创建的新的单位fr用来创建弹性网格。</p><h3 id="元素位置"><a href="#元素位置" class="headerlink" title="元素位置"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE">元素位置</a></h3><p>你可以用使用行好，行名或者一个标定来精确的定位每个网格的排列</p><h3 id="创建额外的轨道来包含元素"><a href="#创建额外的轨道来包含元素" class="headerlink" title="创建额外的轨道来包含元素"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%88%9B%E5%BB%BA%E9%A2%9D%E5%A4%96%E7%9A%84%E8%BD%A8%E9%81%93%E6%9D%A5%E5%8C%85%E5%90%AB%E5%85%83%E7%B4%A0">创建额外的轨道来包含元素</a></h3><p>可以使用网格布局定义一个显式网格，但是根据规范它会处理你加在网格外面的内容，当必要时它会自动增加行和列，它会尽可能多的容纳所有的列。</p><h3 id="创建额外的轨道来包含元素-1"><a href="#创建额外的轨道来包含元素-1" class="headerlink" title="创建额外的轨道来包含元素"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%88%9B%E5%BB%BA%E9%A2%9D%E5%A4%96%E7%9A%84%E8%BD%A8%E9%81%93%E6%9D%A5%E5%8C%85%E5%90%AB%E5%85%83%E7%B4%A0">创建额外的轨道来包含元素</a></h3><p>可以使用网格布局定义一个显式网格，但是根据规范它会处理你加在网格外面的内容，当必要时它会自动增加行和列，它会尽可能多的容纳所有的列。</p><p>使用display:grid/inline-grid就可以是用网格</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Four<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Five<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">display</span>: grid;&#125;</code></pre></div><p><img src="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/1-grid-inspector.png" alt="Using the Grid Highlighter in DevTools to view a grid"></p><p>我们通过 <strong>grid-template-columns</strong> 和 <strong>grid-template-rows</strong> 属性来定义网格中的行和列,这些属性定义了网格的轨道。一个网格轨道就是网格中任意两条线之间的空间。在下图中你可以看到一个高亮的轨道——网格的第一个行轨道。</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;div <span class="hljs-keyword">class</span>=&quot;wrapper&quot;&gt;   &lt;div&gt;One&lt;/div&gt;   &lt;div&gt;Two&lt;/div&gt;   &lt;div&gt;Three&lt;/div&gt;   &lt;div&gt;Four&lt;/div&gt;   &lt;div&gt;Five&lt;/div&gt;&lt;/div&gt;.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">200</span>px <span class="hljs-number">200</span>px <span class="hljs-number">200</span>px;//每一列的宽度都是<span class="hljs-number">200</span>px，分为三列&#125;</code></pre></div><h3 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h3><p>f r是专门用于grid的单位，新的<code>fr</code>单位代表网格容器中可用空间的一等份。下一个网格定义将创建三个相等宽度的轨道，这些轨道会随着可用空间增长和收缩。</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;div <span class="hljs-keyword">class</span>=&quot;wrapper&quot;&gt;   &lt;div&gt;One&lt;/div&gt;   &lt;div&gt;Two&lt;/div&gt;   &lt;div&gt;Three&lt;/div&gt;   &lt;div&gt;Four&lt;/div&gt;   &lt;div&gt;Five&lt;/div&gt;&lt;/div&gt;.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;//这样将等分为三分&#125;.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;//这样就是分为四分，其中第一个div站两份&#125;.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">500</span>px <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;//还可以和其他单位混用，第一个是固定单位，其他剩余的等分&#125;</code></pre></div><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;&#125;</code></pre></div><p>也可以写成</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);//<span class="hljs-number">1</span>fr重复<span class="hljs-number">3</span>次，就是三等分&#125;</code></pre></div><p>Repeat 语句可以用于重复轨道列表中的一部分。在下面的例子中我创建了一个网格：它起始轨道为 20 像素，接着重复了 6 个<code>1fr</code>的轨道，最后再添加了一个 20 像素的轨道。</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">20</span>px repeat(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>fr) <span class="hljs-number">20</span>px;&#125;</code></pre></div><p>Repeat 语句可以传入一个轨道列表，因此你可以用它来创建一个多轨道模式的重复轨道列表。在下一个例子中，网格将有共计 10 个轨道，为 1 个<code>1fr</code>轨道后面跟着 1 个<code>2fr</code>轨道，该模式重复 5 次。</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr);&#125;</code></pre></div><h3 id="grid-auto-rows和grid-auto-columns"><a href="#grid-auto-rows和grid-auto-columns" class="headerlink" title="grid-auto-rows和grid-auto-columns"></a>grid-auto-rows和grid-auto-columns</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Four<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Five<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>.wrapper &#123;  display: grid;  grid-template-columns: repeat(3, 1fr);  grid-auto-rows: 200px;&#125;</code></pre></div><p>Grid-auto-rows是用来定义每一行的默认高度，或者定义1fr的宽度，grid-auto-columns也是一样</p><p>网格用 minmax() 函数来解决这个问题。在下一个例子中我用 minmax() 作为 grid-auto-rows 的值。自动创建的行高将会是最小 100 像素，最大为 auto。用 auto 意味着行的尺寸将会根据内容的大小来自动变换：根据本行中最高的单元，把空间扩展到足够容纳该单元</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);  grid-auto-<span class="hljs-keyword">rows</span>: minmax(<span class="hljs-number">100</span>px, auto);//还可以使用minax来定义每个轨道的区间，这个定义的是最小值为<span class="hljs-number">100</span>px，最大值为auto，可以由内容撑开&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I have some more content in.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This makes me taller than 100 pixels.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Four<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Five<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><iframe class="sample-code-frame" title="轨道大小和minmax()" id="frame_轨道大小和_minmax" width="230" height="490" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E8%BD%A8%E9%81%93%E5%A4%A7%E5%B0%8F%E5%92%8C_minmax.html" loading="lazy"></iframe><h3 id="跨轨道放置网格元素"><a href="#跨轨道放置网格元素" class="headerlink" title="跨轨道放置网格元素"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E8%B7%A8%E8%BD%A8%E9%81%93%E6%94%BE%E7%BD%AE%E7%BD%91%E6%A0%BC%E5%85%83%E7%B4%A0">跨轨道放置网格元素</a></h3><p>grid-column-start：是用于从哪条列网格线开始，开始的索引是1，而不是0</p><p>grid-column-end：是从哪一条列网格线结束</p><p>grid-row-start：从哪条线开始行</p><p>grid-row-end：结束行</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;    display: grid;    grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);    grid-auto-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px;&#125;.box1 &#123;    grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;//从第一条列线开始    grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;//到第<span class="hljs-number">4</span>条列线结束    grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;//从第一条航线开始    grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;//到第三条航线结束&#125;.box2 &#123;    grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;    grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">3</span>;    grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">5</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="跨轨道放置网格元素 sample" id="frame_跨轨道放置网格元素" width="220" height="410" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E8%B7%A8%E8%BD%A8%E9%81%93%E6%94%BE%E7%BD%AE%E7%BD%91%E6%A0%BC%E5%85%83%E7%B4%A0.html" loading="lazy"></iframe><h2 id="网格单元"><a href="#网格单元" class="headerlink" title="网格单元"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E7%BD%91%E6%A0%BC%E5%8D%95%E5%85%83">网格单元</a></h2><p>网格单元就是指最小的网格单位</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/1_grid_cell.png" alt="The first cell of the grid highlighted"></p><h2 id="网格区域"><a href="#网格区域" class="headerlink" title="网格区域"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E7%BD%91%E6%A0%BC%E5%8C%BA%E5%9F%9F">网格区域</a></h2><p>是指每一个所占的区域</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/1_grid_area.png" alt="A grid area"></p><h2 id="网格间距"><a href="#网格间距" class="headerlink" title="网格间距"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E7%BD%91%E6%A0%BC%E9%97%B4%E8%B7%9D">网格间距</a></h2><p>是指每个网格之间间距</p><p>column-gap：指的是两列之间的间距</p><p>row-gap：指两行之间的间距</p><p>gap：是row-gap和column-gap的缩写</p><div class="code-wrapper"><pre><code class="hljs angelscript">.wrapper &#123;   display: grid;   grid-template-columns: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1f</span>r);   column-gap: <span class="hljs-number">10</span>px;   row-gap: <span class="hljs-number">1</span>em;&#125;&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><iframe class="sample-code-frame" title="网格间距 sample" id="frame_网格间距" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E7%BD%91%E6%A0%BC%E9%97%B4%E8%B7%9D.html" loading="lazy"></iframe><p>间距使用的空间会在 使用弹性长度 fr 的轨道的空间计算前就被留出来，间距的尺寸定义行为和普通轨道一致，但不同的是你不能向其中插入任何内容。从以基线定位的角度来说，间距就像一条很宽的基线。</p><h2 id="嵌套网格"><a href="#嵌套网格" class="headerlink" title="嵌套网格"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%B5%8C%E5%A5%97%E7%BD%91%E6%A0%BC">嵌套网格</a></h2><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box1</span>&quot;&gt;        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">nested</span>&quot;&gt;<span class="hljs-symbol">a</span>&lt;/<span class="hljs-symbol">div</span>&gt;        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">nested</span>&quot;&gt;<span class="hljs-symbol">b</span>&lt;/<span class="hljs-symbol">div</span>&gt;        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">nested</span>&quot;&gt;<span class="hljs-symbol">c</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><p><img src="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/1_nested_grids_in_flow.png" alt="Nested grid in flow"></p><p>如果把 <code>box1</code> 设置成 <code>display: grid</code> 你可以给它定义轨道然后它也会变成一个网格元素，它的子级元素也会排列在这个新网格元素中。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">3</span>;   <span class="hljs-attribute">display</span>: grid;   <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);&#125;</code></pre></div><iframe class="sample-code-frame" title="嵌套网格 sample" id="frame_嵌套网格" width="600" height="410" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E5%B5%8C%E5%A5%97%E7%BD%91%E6%A0%BC.html" loading="lazy"></iframe><h2 id="使用z-index控制层级"><a href="#使用z-index控制层级" class="headerlink" title="使用z-index控制层级"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E4%BD%BF%E7%94%A8z-index%E6%8E%A7%E5%88%B6%E5%B1%82%E7%BA%A7">使用<code>z-index</code>控制层级</a></h2><p>多个网格项目可以占用同一个网格单位。如果我们回到之前根据网格线编号放置网格项目的话，我们可以更改此项来使两个网格项目重叠。</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;   display: grid;   grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);   grid-auto-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px;&#125;.box1 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;&#125;.box2 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">2</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="使用z-index控制层级" id="frame_l_ex" width="210" height="410" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.l_ex.html" loading="lazy"></iframe><p>网格项目 <code>box2</code> 现在覆盖于 <code>box1 之上，其覆盖顺序遵循文档流的原始顺序（后来居上）</code></p><h3 id="控制顺序"><a href="#控制顺序" class="headerlink" title="控制顺序"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E6%8E%A7%E5%88%B6%E9%A1%BA%E5%BA%8F">控制顺序</a></h3><p>我们可以在网格项目发生重叠时使用 <code>z-index</code> 属性控制重叠的顺序——就像放置网格项目一样。如果我们给 <code>box2</code> 设定一个低于 <code>box1</code> 的 <code>z-index</code> 值的话，<code>box2</code> 将会显示在 box1 的下方。</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;   display: grid;   grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);   grid-auto-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px;&#125;.box1 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;   z-<span class="hljs-keyword">index</span>: <span class="hljs-number">2</span>;&#125;.box2 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">2</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;   z-<span class="hljs-keyword">index</span>: <span class="hljs-number">1</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="控制顺序 sample" id="frame_控制顺序" width="210" height="410" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E6%8E%A7%E5%88%B6%E9%A1%BA%E5%BA%8F.html" loading="lazy"></iframe><h2 id="grid-column-和-grid-row-的简写"><a href="#grid-column-和-grid-row-的简写" class="headerlink" title="grid-column 和 grid-row 的简写"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#grid-column_%E5%92%8C_grid-row_%E7%9A%84%E7%AE%80%E5%86%99"><code>grid-column</code> 和 <code>grid-row</code> 的简写</a></h2><p>grid-column-start和grid-column-end的缩写是grid-column，grid-row-start和grid-row-end的缩写</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> /  <span class="hljs-number">2</span>;&#125;<span class="hljs-selector-class">.box4</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="grid-column 和 grid-row 的简写 sample" id="frame_grid-column_和_grid-row_的简写" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.grid-column_%E5%92%8C_grid-row_%E7%9A%84%E7%AE%80%E5%86%99.html" loading="lazy"></iframe><h2 id="默认跨度"><a href="#默认跨度" class="headerlink" title="默认跨度"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E9%BB%98%E8%AE%A4%E8%B7%A8%E5%BA%A6">默认跨度</a></h2><p>实际上如果一个元素只延伸一个轨道的话，你可以省略 <code>grid-column-end</code> 或 <code>grid-row-end</code> 值。元素默认延伸一个轨道</p><h3 id="默认跨度的普通写法"><a href="#默认跨度的普通写法" class="headerlink" title="默认跨度的普通写法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E9%BB%98%E8%AE%A4%E8%B7%A8%E5%BA%A6%E7%9A%84%E6%99%AE%E9%80%9A%E5%86%99%E6%B3%95">默认跨度的普通写法</a></h3><p>我们最初的示例的普通写法会是这样：</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">3</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.box4</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;   <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">3</span>;&#125;</code></pre></div><h3 id="默认跨度的简写"><a href="#默认跨度的简写" class="headerlink" title="默认跨度的简写"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E9%BB%98%E8%AE%A4%E8%B7%A8%E5%BA%A6%E7%9A%84%E7%AE%80%E5%86%99">默认跨度的简写</a></h3><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> ;//可以省略第二个值   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span> ;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> ;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> ;&#125;<span class="hljs-selector-class">.box4</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span> ;&#125;</code></pre></div><iframe class="sample-code-frame" title="默认跨度的简写 sample" id="frame_默认跨度的简写" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.%E9%BB%98%E8%AE%A4%E8%B7%A8%E5%BA%A6%E7%9A%84%E7%AE%80%E5%86%99.html" loading="lazy"></iframe><h2 id="grid-area-属性"><a href="#grid-area-属性" class="headerlink" title="grid-area 属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#grid-area_%E5%B1%9E%E6%80%A7"><code>grid-area</code> 属性</a></h2><p>我们可以更进一步，给每个元素只定义一个属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-area"><code>grid-area</code></a>。值的顺序如下</p><ul><li>grid-row-start</li><li>grid-column-start</li><li>grid-row-end</li><li>grid-column-end</li></ul><div class="code-wrapper"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;   &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;One&lt;/<span class="hljs-keyword">div</span>&gt;   &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;Two&lt;/<span class="hljs-keyword">div</span>&gt;   &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;Three&lt;/<span class="hljs-keyword">div</span>&gt;   &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box4&quot;</span>&gt;Four&lt;/<span class="hljs-keyword">div</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;.box1 &#123;   grid-area: <span class="hljs-number">1</span> <span class="hljs-regexp">/ 1 /</span> <span class="hljs-number">4</span> / <span class="hljs-number">2</span>;&#125;.box2 &#123;   grid-area: <span class="hljs-number">1</span> <span class="hljs-regexp">/ 3 /</span> <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;&#125;.box3 &#123;   grid-area: <span class="hljs-number">1</span> <span class="hljs-regexp">/ 2 /</span> <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;&#125;.box4 &#123;   grid-area: <span class="hljs-number">3</span> <span class="hljs-regexp">/ 2 /</span> <span class="hljs-number">4</span> / <span class="hljs-number">4</span>;&#125;</code></pre></div><p><code>grid-area</code> 的值的顺序看起来可能有点奇怪，比如说它正好和定义 margin 和 padding 的简写的值的顺序相反。但如果说是因为它与 CSS 书写模式规范中的书写方向相关就不难理解了。我们会在之后的文章中探讨网格与书写模式的关系，但我们有 4 个书写流关联的方向：</p><ul><li>块起始（block-start）</li><li>块结束（block-end）</li><li>行起始（inline-start）</li><li>行结束（inline-end）</li></ul><h2 id="反方向计数"><a href="#反方向计数" class="headerlink" title="反方向计数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E5%8F%8D%E6%96%B9%E5%90%91%E8%AE%A1%E6%95%B0">反方向计数</a></h2><p>我们也可以从行和块结束线开始反方向计数，对于英语来说就是右端的列线和底端的行线。这些线会被记为 <code>-1</code>，然后你可以从这往前数，所以倒数第 2 条线会被记为 <code>-2</code>。值得注意的是最后一条线是指显式定义网格的最后一条线，即由 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 定义的网格，并不把隐式定义网格的加入的行和列纳入考虑。</p><p>下面这个示例中，我们通过从右端和底端开始定义布局，把之前的示例的布局翻转了。</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;div <span class="hljs-keyword">class</span>=&quot;wrapper&quot;&gt;   &lt;div <span class="hljs-keyword">class</span>=&quot;box1&quot;&gt;One&lt;/div&gt;   &lt;div <span class="hljs-keyword">class</span>=&quot;box2&quot;&gt;Two&lt;/div&gt;   &lt;div <span class="hljs-keyword">class</span>=&quot;box3&quot;&gt;Three&lt;/div&gt;   &lt;div <span class="hljs-keyword">class</span>=&quot;box4&quot;&gt;Four&lt;/div&gt;&lt;/div&gt;.box1 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-1</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-2</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-4</span>;&#125;.box2 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-3</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-4</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-3</span>;&#125;.box3 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-2</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-3</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-2</span>;&#125;.box4 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-2</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-4</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-3</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-4</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="反方向计数 sample" id="frame_反方向计数" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.%E5%8F%8D%E6%96%B9%E5%90%91%E8%AE%A1%E6%95%B0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="使元素跨越整个网格"><a href="#使元素跨越整个网格" class="headerlink" title="使元素跨越整个网格"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E4%BD%BF%E5%85%83%E7%B4%A0%E8%B7%A8%E8%B6%8A%E6%95%B4%E4%B8%AA%E7%BD%91%E6%A0%BC">使元素跨越整个网格</a></h3><p>拥有从开始计数和从末尾计数这两种定位方法使得使一个元素跨越整个网格变得很方便：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="间距"><a href="#间距" class="headerlink" title="间距"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E9%97%B4%E8%B7%9D">间距</a></h2><p>CSS 网格规范加入了用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/row-gap"><code>row-gap</code></a> 属性定义列间距和行间距的能力。这两个属性的行为和多列布局中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a> 属性很像。</p><p><strong>备注：</strong> 在浏览器首次引入网格属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/row-gap"><code>row-gap</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/gap"><code>gap</code></a> 时，具有 <code>grid-</code> 前缀。分别是 <code>grid-column-gap</code>、<code>grid-row-gap</code> 和 <code>grid-gap</code>。</p><p>浏览器正在更新它们的渲染引擎，以删除这一前缀，但是携带有前缀的版本将以别名的形式进行维护，使得它们可以被安全地使用。</p><p>间距只出现在网格轨道与轨道之间，它们并不会出现在网格容器的四周。通过在网格容器上定义这些属性，我们给上例加上了间距：</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> ;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span> ;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> ;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> ;&#125;<span class="hljs-selector-class">.box4</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span> ;&#125;<span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">100px</span>);    <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">row-gap</span>: <span class="hljs-number">1em</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="间距 sample" id="frame_间距" width="300" height="350" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.%E9%97%B4%E8%B7%9D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>间距可以使用gap进行简写</p><h2 id="使用-span-关键字"><a href="#使用-span-关键字" class="headerlink" title="使用 span 关键字"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E4%BD%BF%E7%94%A8_span_%E5%85%B3%E9%94%AE%E5%AD%97">使用 <code>span</code> 关键字</a></h2><p>除了”起始线与结束线“的定位方法，你还可以使用”起始线与跨越轨道数量“的定位方法</p><div class="code-wrapper"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;   &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box1&quot;</span>&gt;One&lt;/div&gt;   &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box2&quot;</span>&gt;Two&lt;/div&gt;   &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box3&quot;</span>&gt;Three&lt;/div&gt;   &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box4&quot;</span>&gt;Four&lt;/div&gt;&lt;/div&gt;<span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.box4</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / span <span class="hljs-number">2</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="使用 span 关键字 sample" id="frame_使用_span_关键字" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.%E4%BD%BF%E7%94%A8_span_%E5%85%B3%E9%94%AE%E5%AD%97.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, &quot;system-ui&quot;, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><p>你也可以在 <code>grid-row-start</code>/<code>grid-row-end</code> 和 <code>grid-column-start</code>/<code>grid-column-end</code> 属性中使用 <code>span</code> 关键字。接下来两个例子会创建同样的网格。第一个例子中我们设定了起始行，然后说我们想结束线在跨越 3 条线之后。那这个元素就会从 1 号线开始，跨越 3 条线，到 4 号线结束。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row-end</span>: span <span class="hljs-number">3</span>;&#125;</code></pre></div><p>第二个例子中，我们定义了结束行线，然后设置起始线为跨越 3 条线。意味着这个元素会从指定的线往上跨越 3 条线。这个元素会从 4 号线开始，跨越 3 条线到 1 号线。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row-start</span>: span <span class="hljs-number">3</span>;    <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">4</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
      <category>Grid</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Grid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-testing-library单元测试组件库学习</title>
    <link href="/2022/10/16/react-testing-librar%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/10/16/react-testing-librar%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Testing-Library"><a href="#React-Testing-Library" class="headerlink" title="React Testing Library"></a>React Testing Library</h1><p><a href="https://github.com/testing-library/react-testing-library"><code>React Testing Library</code></a>是在DOM Testing Library的基础上增加了一些API用于React组件测试，如果项目通过create-react-app创建的项目提供了开箱即用的<strong>React Testing Library</strong>.，如果你不是使用creact-react-app创建项目，可以使用例如·npm/yarn</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install --save-dev @testing-library/react</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">yarn add <span class="hljs-attr">--dev</span> <span class="hljs-keyword">@testing-library</span>/react</code></pre></div><h2 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem<a href="https://testing-library.com/docs/react-testing-library/intro/#the-problem"></a></h2><p>如果你想写可持续性的测试为你的组件，作为这个目标的一部分，如果你想避免你的测试包含组件的详细的细节，并且专注于你的测试给你的组件带来信心，你的测试是可维护的，并且重构你的组件并不会破坏测试，和减慢你开发的进度</p><h2 id="This-solution"><a href="#This-solution" class="headerlink" title="This solution"></a>This solution<a href="https://testing-library.com/docs/react-testing-library/intro/#this-solution"></a></h2><p>React Testing Library测试库是非常轻量化的解决方案，它提供了基于react-dom和react-dom/test-utils，您的测试与您的软件使用方式越相似，它们能给您的信心就越大。你的测试将使用实际的DOM节点，而不是处理渲染的组件实例，这个工具库将提供函数有助于和用户相同的方式访问DOM，以更贴近用户的使用的方式测试组件，这个库可以作为enzyme的替代品</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123;rest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;msw&#x27;</span><span class="hljs-keyword">import</span> &#123;setupServer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;msw/node&#x27;</span><span class="hljs-comment">//用于mock 数据请求</span><span class="hljs-keyword">import</span> &#123;render, fireEvent, waitFor, screen&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@testing-library/jest-dom&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Fetch</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../fetch&#x27;</span><span class="hljs-comment">//mock 请求数据的接口，模拟返回的数据</span><span class="hljs-keyword">const</span> server = <span class="hljs-title function_">setupServer</span>(  rest.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/greeting&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, ctx</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title function_">res</span>(ctx.<span class="hljs-title function_">json</span>(&#123;<span class="hljs-attr">greeting</span>: <span class="hljs-string">&#x27;hello there&#x27;</span>&#125;))  &#125;),)<span class="hljs-comment">//建立api 的mock 在所有测试以前</span><span class="hljs-title function_">beforeAll</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title function_">listen</span>())<span class="hljs-comment">//每次测试完后都重置请求</span><span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title function_">resetHandlers</span>())<span class="hljs-comment">//关闭请求</span><span class="hljs-title function_">afterAll</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title function_">close</span>())<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;loads and displays greeting&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fetch</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/greeting&quot;</span> /&gt;</span></span>)<span class="hljs-comment">//模拟用户点击事件</span>  fireEvent.<span class="hljs-title function_">click</span>(screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-string">&#x27;Load Greeting&#x27;</span>))<span class="hljs-comment">//等待直到获取请求成功并且组件调用setState和重新渲染</span>  <span class="hljs-comment">//waitFor会等待直到回调函数响应成功</span>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitFor</span>(<span class="hljs-function">() =&gt;</span> screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;heading&#x27;</span>))<span class="hljs-comment">// assert that the alert message is correct using</span><span class="hljs-comment">// toHaveTextContent, a custom matcher from jest-dom.</span>  <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;heading&#x27;</span>)).<span class="hljs-title function_">toHaveTextContent</span>(<span class="hljs-string">&#x27;hello there&#x27;</span>)  <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;button&#x27;</span>)).<span class="hljs-title function_">toBeDisabled</span>()&#125;)<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;handles server error&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-comment">//重写测试接口</span>  server.<span class="hljs-title function_">use</span>(    rest.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/greeting&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, ctx</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">res</span>(ctx.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>))    &#125;),  )  <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fetch</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/greeting&quot;</span> /&gt;</span></span>)  fireEvent.<span class="hljs-title function_">click</span>(screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-string">&#x27;Load Greeting&#x27;</span>))  <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitFor</span>(<span class="hljs-function">() =&gt;</span> screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;alert&#x27;</span>))  <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;alert&#x27;</span>)).<span class="hljs-title function_">toHaveTextContent</span>(<span class="hljs-string">&#x27;Oops, failed to fetch!&#x27;</span>)  <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;button&#x27;</span>)).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeDisabled</span>()&#125;)</code></pre></div><p>推荐使用<a href="https://github.com/mswjs/msw">Mock Service Worker</a> 这个库来mock window.fetch API</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><span class="hljs-keyword">const</span> initialState = &#123;  <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,  <span class="hljs-attr">greeting</span>: <span class="hljs-literal">null</span>,&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">greetingReducer</span>(<span class="hljs-params">state, action</span>) &#123;  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SUCCESS&#x27;</span>: &#123;      <span class="hljs-keyword">return</span> &#123;        <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">greeting</span>: action.<span class="hljs-property">greeting</span>,      &#125;    &#125;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ERROR&#x27;</span>: &#123;      <span class="hljs-keyword">return</span> &#123;        <span class="hljs-attr">error</span>: action.<span class="hljs-property">error</span>,        <span class="hljs-attr">greeting</span>: <span class="hljs-literal">null</span>,      &#125;    &#125;    <span class="hljs-attr">default</span>: &#123;      <span class="hljs-keyword">return</span> state    &#125;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fetch</span>(<span class="hljs-params">&#123;url&#125;</span>) &#123;  <span class="hljs-keyword">const</span> [&#123;error, greeting&#125;, dispatch] = <span class="hljs-title function_">useReducer</span>(    greetingReducer,    initialState,  )  <span class="hljs-keyword">const</span> [buttonClicked, setButtonClicked] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchGreeting</span> = <span class="hljs-keyword">async</span> url =&gt;    axios      .<span class="hljs-title function_">get</span>(url)      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> &#123;data&#125; = response        <span class="hljs-keyword">const</span> &#123;greeting&#125; = data        <span class="hljs-title function_">dispatch</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SUCCESS&#x27;</span>, greeting&#125;)        <span class="hljs-title function_">setButtonClicked</span>(<span class="hljs-literal">true</span>)      &#125;)      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;        <span class="hljs-title function_">dispatch</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ERROR&#x27;</span>, error&#125;)      &#125;)  <span class="hljs-keyword">const</span> buttonText = buttonClicked ? <span class="hljs-string">&#x27;Ok&#x27;</span> : <span class="hljs-string">&#x27;Load Greeting&#x27;</span>  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> fetchGreeting(url)&#125; disabled=&#123;buttonClicked&#125;&gt;</span><span class="language-xml">        &#123;buttonText&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      &#123;greeting &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>&#125;</span><span class="language-xml">      &#123;error &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>Oops, failed to fetch!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;</code></pre></div><h1 id="和Jest一起使用"><a href="#和Jest一起使用" class="headerlink" title="和Jest一起使用"></a>和Jest一起使用</h1><h3 id="jest28"><a href="#jest28" class="headerlink" title="jest28"></a>jest28</h3><div class="code-wrapper"><pre><code class="hljs livecodeserver">yarn <span class="hljs-built_in">add</span> <span class="hljs-comment">--dev jest-environment-jsdom</span></code></pre></div><p>jsdom 也不再是默认环境。您可以通过编辑 jest.config.js 全局启用 jsdom：</p><div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;+  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">&#x27;jsdom&#x27;</span>,   <span class="hljs-comment">// ... other options ...</span> &#125;</code></pre></div><p>或者，如果您只在某些测试中需要 jsdom，则可以在需要时使用 docblocks 启用它：</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@jest</span>-environment jsdom</span><span class="hljs-comment"> */</span></code></pre></div><h3 id="Jest-27"><a href="#Jest-27" class="headerlink" title="Jest 27"></a>Jest 27</h3><p>jest27的配置方式</p><div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;+  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">&#x27;jest-environment-jsdom&#x27;</span>,   <span class="hljs-comment">// ... other options ...</span> &#125;</code></pre></div><h3 id="Jest-24-or-lower-and-defaults"><a href="#Jest-24-or-lower-and-defaults" class="headerlink" title="Jest 24 (or lower) and defaults"></a>Jest 24 (or lower) and defaults<a href="https://testing-library.com/docs/react-testing-library/setup#jest-24-or-lower-and-defaults"></a></h3><p>如果使用24或者更低的版本，需要安装，并把这个作为jest的环境</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">yarn <span class="hljs-built_in">add</span> <span class="hljs-comment">--dev jest-environment-jsdom-fifteen</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;+  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">&#x27;jest-environment-jsdom-fifteen&#x27;</span>,   <span class="hljs-comment">// ... other options ...</span> &#125;</code></pre></div><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>React 测试库重新导出 DOM 测试库中的所有内容以及这些方法：</p><h2 id="render"><a href="#render" class="headerlink" title="render"></a><code>render</code></h2><p>render会把内容渲染都document.body容器中</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span><span class="hljs-params">  ui: React.ReactElement&lt;<span class="hljs-built_in">any</span>&gt;,<span class="hljs-comment">//第一个参数是需要渲染的组件或者元素</span></span><span class="hljs-params">  options?: &#123;</span><span class="hljs-params">    /* You won<span class="hljs-string">&#x27;t often use this, expand below for docs on options */</span></span><span class="hljs-string"><span class="hljs-params">  &#125;,</span></span><span class="hljs-string"><span class="hljs-params">): RenderResult</span></span></code></pre></div><h2 id="render-Options"><a href="#render-Options" class="headerlink" title="render Options"></a><code>render</code> Options</h2><p>render函数的第二个参数</p><h3 id="container"><a href="#container" class="headerlink" title="container"></a><code>container</code></h3><p>默认情况下，React 测试库将创建一个 div 并将该 div 附加到 document.body，这就是您的 React 组件将被渲染的地方。如果您通过此选项提供自己的 HTMLElement 容器，它将不会自动附加到 document.body。</p><p>例如，如果你想使用table作为容器</p><div class="code-wrapper"><pre><code class="hljs react">const table = document.createElement(&#x27;table&#x27;)const &#123;container&#125; = render(&lt;TableBody &#123;...props&#125; /&gt;, &#123;  container: document.body.appendChild(table),&#125;)</code></pre></div><h3 id="baseElement"><a href="#baseElement" class="headerlink" title="baseElement"></a><code>baseElement</code></h3><h3 id="hydrate"><a href="#hydrate" class="headerlink" title="hydrate"></a><code>hydrate</code></h3><h3 id="legacyRoot"><a href="#legacyRoot" class="headerlink" title="legacyRoot"></a><code>legacyRoot</code></h3><h3 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a><code>wrapper</code></h3><h3 id="queries"><a href="#queries" class="headerlink" title="queries"></a><code>queries</code></h3><h2 id="render-Result"><a href="#render-Result" class="headerlink" title="render Result"></a><code>render</code> Result</h2><p>render函数的返回值</p><h3 id="queries-1"><a href="#queries-1" class="headerlink" title="...queries"></a><code>...queries</code><a href="https://testing-library.com/docs/react-testing-library/api#queries-1"></a></h3><p>render 最重要的特性是来自 DOM 测试库的query会自动返回，其第一个参数绑定到 baseElement，默认为 document.body。</p><p>例如</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> &#123;getByLabelText, queryAllByTestId&#125; = <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> /&gt;</span></span>)</code></pre></div><h3 id="container-1"><a href="#container-1" class="headerlink" title="container"></a><code>container</code></h3><p>渲染的 React 元素的包含 DOM 节点（使用 ReactDOM.render 渲染）。这是一个div。这是一个常规 DOM 节点，因此您可以调用 container.querySelector 等来检查子节点。</p><p>要获取渲染元素的根元素，请使用 container.firstChild。</p><p>🚨 If you find yourself using <code>container</code> to query for rendered elements then you should reconsider! The other queries are designed to be more resilient to changes that will be made to the component you’re testing. Avoid using <code>container</code> to query for elements!</p><h3 id="baseElement-1"><a href="#baseElement-1" class="headerlink" title="baseElement"></a><code>baseElement</code></h3><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a><code>debug</code></h3><h3 id="rerender"><a href="#rerender" class="headerlink" title="rerender"></a><code>rerender</code></h3><p>如果您测试进行 prop 更新的组件以确保正确更新 props 可能会更好。也就是说，如果您希望在测试中更新渲染组件的 props，则可以使用此函数更新渲染组件的 props。</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;render&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-keyword">const</span> &#123;rerender&#125; = <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberDisplay</span> <span class="hljs-attr">number</span>=<span class="hljs-string">&#123;1&#125;</span> /&gt;</span></span>)<span class="hljs-comment">// re-render the same component with different props</span><span class="hljs-title function_">rerender</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberDisplay</span> <span class="hljs-attr">number</span>=<span class="hljs-string">&#123;2&#125;</span> /&gt;</span></span>)</code></pre></div><h3 id="unmount"><a href="#unmount" class="headerlink" title="unmount"></a><code>unmount</code></h3><p>这将导致渲染的组件被卸载。这对于测试当您的组件从页面中移除时会发生什么情况很有用（例如测试您不会让事件处理程序闲置导致内存泄漏）。</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;render&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-keyword">const</span> &#123;container, unmount&#125; = <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span> /&gt;</span></span>)<span class="hljs-title function_">unmount</span>()<span class="hljs-comment">// your component has been unmounted and now: container.innerHTML === &#x27;&#x27;</span></code></pre></div><h3 id="asFragment"><a href="#asFragment" class="headerlink" title="asFragment"></a><code>asFragment</code></h3><p>返回呈现组件的 DocumentFragment。如果您需要避免实时绑定并查看您的组件如何对事件做出反应，这将很有用。</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123;render, fireEvent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">TestComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-keyword">const</span> [count, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCounter(count =&gt; count + 1)&#125;&gt;</span><span class="language-xml">      Click to increase: &#123;count&#125;</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>  )&#125;<span class="hljs-keyword">const</span> &#123;getByText, asFragment&#125; = <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TestComponent</span> /&gt;</span></span>)<span class="hljs-keyword">const</span> firstRender = <span class="hljs-title function_">asFragment</span>()fireEvent.<span class="hljs-title function_">click</span>(<span class="hljs-title function_">getByText</span>(<span class="hljs-regexp">/Click to increase/</span>))<span class="hljs-comment">// This will snapshot only the difference between the first render, and the</span><span class="hljs-comment">// state of the DOM after the click event.</span><span class="hljs-comment">// See https://github.com/jest-community/snapshot-diff</span><span class="hljs-title function_">expect</span>(firstRender).<span class="hljs-title function_">toMatchDiffSnapshot</span>(<span class="hljs-title function_">asFragment</span>())</code></pre></div><h2 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup"></a><code>cleanup</code></h2><p>卸载使用 render 挂载的 React 树。</p><p>请注意，如果您使用的测试框架支持 afterEach 全局并且它被注入到您的测试环境（如 mocha、Jest 和 Jasmine），那么这是自动完成的。如果没有，您将需要在每次测试后进行手动清理。</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;cleanup, render&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ava&#x27;</span>test.<span class="hljs-title function_">afterEach</span>(cleanup)<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;renders into document&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span>)  <span class="hljs-comment">// ...</span>&#125;)</code></pre></div><h2 id="act"><a href="#act" class="headerlink" title="act"></a><code>act</code></h2><p>This is a light wrapper around the <a href="https://reactjs.org/docs/test-utils.html#act"><code>react-dom/test-utils</code> <code>act</code> function</a>. All it does is forward all arguments to the act function if your version of react supports <code>act</code>. It is recommended to use the import from <code>@testing-library/react</code> over <code>react-dom/test-utils</code> for consistency reasons.</p><h2 id="renderHook"><a href="#renderHook" class="headerlink" title="renderHook"></a><code>renderHook</code></h2><p>这是一个带有自定义测试组件的渲染器的便捷包装器。该 API 源自一种流行的测试模式，主要用于发布hook的库。您应该更喜欢渲染，因为自定义测试组件会导致更具可读性和健壮性的测试，因为您要测试的东西并没有隐藏在抽象之后。</p><p>因该是用来测试hook</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> renderHook&lt;<span class="hljs-title class_">Result</span>, <span class="hljs-title class_">Props</span>&gt;(  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">props: Props</span>) =&gt;</span> <span class="hljs-title class_">Result</span>,  options?: <span class="hljs-title class_">RenderHookOptions</span>&lt;<span class="hljs-title class_">Props</span>&gt;,): <span class="hljs-title class_">RenderHookResult</span>&lt;<span class="hljs-title class_">Result</span>, <span class="hljs-title class_">Props</span>&gt;</code></pre></div><p>Example:</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;renderHook&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;returns logged in user&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> &#123;result&#125; = <span class="hljs-title function_">renderHook</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">useLoggedInUser</span>())  <span class="hljs-title function_">expect</span>(result.<span class="hljs-property">current</span>).<span class="hljs-title function_">toEqual</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>&#125;)&#125;)</code></pre></div><h2 id="renderHook-Options"><a href="#renderHook-Options" class="headerlink" title="renderHook Options"></a><code>renderHook</code> Options</h2><h3 id="renderHook-Options-initialProps"><a href="#renderHook-Options-initialProps" class="headerlink" title="renderHook Options initialProps"></a><code>renderHook</code> Options <code>initialProps</code></h3><p>声明在首次调用时传递给渲染回调。如果您在没有道具的情况下调用重新渲染的props，这些将不会被传递。</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;renderHook&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;returns logged in user&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> &#123;result, rerender&#125; = <span class="hljs-title function_">renderHook</span>(<span class="hljs-function">(<span class="hljs-params">props = &#123;&#125;</span>) =&gt;</span> props, &#123;    <span class="hljs-attr">initialProps</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>&#125;,  &#125;)  <span class="hljs-title function_">expect</span>(result.<span class="hljs-property">current</span>).<span class="hljs-title function_">toEqual</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>&#125;)  <span class="hljs-title function_">rerender</span>()  <span class="hljs-title function_">expect</span>(result.<span class="hljs-property">current</span>).<span class="hljs-title function_">toEqual</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span>&#125;)&#125;)</code></pre></div><p>将 renderHook 与 wrapper 和 initialProps 选项结合使用时，initialProps 不会传递给 wrapper 组件。要为包装器组件提供props，请考虑这样的解决方案：</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">createWrapper</span> = (<span class="hljs-params">Wrapper, props</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">CreatedWrapper</span>(<span class="hljs-params">&#123; children &#125;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span> &#123;<span class="hljs-attr">...props</span>&#125;&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span></span>;  &#125;;&#125;;...&#123;  <span class="hljs-attr">wrapper</span>: <span class="hljs-title function_">createWrapper</span>(<span class="hljs-title class_">Wrapper</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;),&#125;</code></pre></div><h3 id="renderHook-Options-wrapper"><a href="#renderHook-Options-wrapper" class="headerlink" title="renderHook Options wrapper"></a><code>renderHook</code> Options <code>wrapper</code></h3><p>See <a href="https://testing-library.com/docs/react-testing-library/api#wrapper"><code>wrapper</code> option for <code>render</code></a></p><h2 id="renderHook-Result"><a href="#renderHook-Result" class="headerlink" title="renderHook Result"></a><code>renderHook</code> Result<a href="https://testing-library.com/docs/react-testing-library/api#renderhook-result"></a></h2><h3 id="result"><a href="#result" class="headerlink" title="result"></a><code>result</code></h3><p>hooks的返回值</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;renderHook&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-keyword">const</span> &#123;result&#125; = <span class="hljs-title function_">renderHook</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>)  &#125;, [])  <span class="hljs-keyword">return</span> name&#125;)<span class="hljs-title function_">expect</span>(result.<span class="hljs-property">current</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>)</code></pre></div><p>请注意，该值保存在 result.current 中。将 result 视为最近提交的值的引用。</p><h3 id="rerender-1"><a href="#rerender-1" class="headerlink" title="rerender"></a><code>rerender</code></h3><p>使用新props渲染先前渲染的渲染回调：就是为之前的回调函数传入新的值</p><div class="code-wrapper"><pre><code class="hljs JSX"><span class="hljs-keyword">import</span> &#123;renderHook&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-keyword">const</span> &#123;rerender&#125; = <span class="hljs-title function_">renderHook</span>(<span class="hljs-function">(<span class="hljs-params">&#123;name = <span class="hljs-string">&#x27;Alice&#x27;</span>&#125; = &#123;&#125;</span>) =&gt;</span> name)<span class="hljs-comment">// re-render the same hook with different props</span><span class="hljs-title function_">rerender</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>react-testing-library,单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canvas笔记</title>
    <link href="/2022/10/12/canvas%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/12/canvas%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mobx的使用3⃣️</title>
    <link href="/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%89/"/>
    <url>/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>mobx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mobx的使用二</title>
    <link href="/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C/"/>
    <url>/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="集成React（react-integration）"><a href="#集成React（react-integration）" class="headerlink" title="集成React（react-integration）"></a>集成React（react-integration）</h1><p>用法:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span> <span class="hljs-comment">// Or &quot;mobx-react&quot;.</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-title class_">ReactElement</span>)</code></pre></div><p>MobX 可以独立于 React 运行, 但是他们通常是结合在一起使用, 在 <a href="https://zh.mobx.js.org/the-gist-of-mobx.html">Mobx的宗旨（The gist of MobX）</a> 一文中你会经常看见集成React最重要的一部分：用于包裹React Component的 <code>observer</code> <a href="https://reactjs.org/docs/higher-order-components.html">HOC</a>方法。</p><p><code>observer</code> 是你可以自主选择的，<a href="https://zh.mobx.js.org/installation.html#installation">在安装时（during installation）</a>独立提供的 React bindings 包。 在下面的例子中,我们将使用更加轻量的<a href="https://github.com/mobxjs/mobx/tree/main/packages/mobx-react-lite"><code>mobx-react-lite</code> 包</a>。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;    secondsPassed = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> += <span class="hljs-number">1</span>    &#125;&#125;<span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>()<span class="hljs-comment">//被`observer`包裹的函数式组件会被监听在它每一次调用前发生的任何变化</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; timer &#125;</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> <span class="hljs-attr">timer</span>=<span class="hljs-string">&#123;myTimer&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;    myTimer.<span class="hljs-title function_">increaseTimer</span>()&#125;, <span class="hljs-number">1000</span>)</code></pre></div><p><code>observer</code> HOC 将自动订阅 React components 中任何 <em>在渲染期间</em> 被使用的 <em>可被观察的对象</em> 。 因此, 当任何可被观察的对象 <em>变化</em> 发生时候 组件会自动进行重新渲染（re-render）。 它还会确保组件在 <em>没有变化</em> 发生的时候不会进行重新渲染（re-render）。 但是, 更改组件的可观察对象的不可读属性, 也不会触发重新渲染（re-render）。</p><p>在实际项目中，这一特性使得MobX应用程序能够很好的进行开箱即用的优化，并且通常不需要任何额外的代码来防止过度渲染。</p><p>要想让<code>observer</code>生效, 并不需要关心这些对象 <em>如何传递到</em> 组件的（它们只要能传递给组件即可 ·译者注）, 只需要关心他们是否是可读的。 深层嵌套的可观察对象也没有问题, 复杂的表达式类似 <code>todos[0].author.displayName</code> 也是可以使用的。 与其他必须显式声明或预先计算数据依赖关系的框架（例如 selectors）相比，这种发生的订阅机制就显得更加精确和高效。</p><h3 id="observer-组件中使用外部状态-（Using-external-state-in-observer-components）"><a href="#observer-组件中使用外部状态-（Using-external-state-in-observer-components）" class="headerlink" title="observer 组件中使用外部状态 （Using external state in observer components）"></a><code>observer</code> 组件中使用外部状态 （Using external state in <code>observer</code> components）</h3><p>使用props的方式</p><p>可被观察对象可以通过组件的props属性传入 (在下面的例子中):</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>() <span class="hljs-comment">// See the Timer definition above.</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; timer &#125;</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>)<span class="hljs-comment">// 通过props传递myTimer.</span><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> <span class="hljs-attr">timer</span>=<span class="hljs-string">&#123;myTimer&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>使用全局变量的方式</p><p>虽然我们不关心是 <em>如何</em> 引用（reference）的可观察对象,但是我们可以使用 （consume） 外部作用域（outer scopes directly）的可观察对象 (类似通过 import这样的方法, 等等)：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>() <span class="hljs-comment">//  Timer 定义在上面.</span><span class="hljs-comment">// 没有props, `myTimer` 立刻变成了闭包。</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;myTimer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>直接使用可观察对象效果很好，但是这通常会是通过模块引入，这种写法可能会使单元测试变得复杂。 因此，我们建议使用React Context。</p><p>使用<a href="https://reactjs.org/docs/context.html">React Context</a>共享整个可观察子树是一种很不错的选择：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;observer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mobx-react-lite&#x27;</span><span class="hljs-keyword">import</span> &#123;createContext, useContext&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerContext</span> = createContext&lt;<span class="hljs-title class_">Timer</span>&gt;()<span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 从context中获取timer.</span>    <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">TimerContext</span>) <span class="hljs-comment">// 可以在上面查看 Timer的定义。</span>    <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>    )&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;new</span> <span class="hljs-attr">Timer</span>()&#125;&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">TimerContext.Provider</span>&gt;</span></span>,    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>需要注意的是我们并不推荐每一个不同的 <code>值（value）</code> 都通过不同的 <code>Provider</code>来传递 . 在使用Mobx的过程中不需要这样做, 因为共享的可观察对象会更新他自己。</p><h3 id="在observer-组件中使用全局可观察对象（Using-local-observable-state-in-observer-components）"><a href="#在observer-组件中使用全局可观察对象（Using-local-observable-state-in-observer-components）" class="headerlink" title="在observer 组件中使用全局可观察对象（Using local observable state in observer components）"></a>在<code>observer</code> 组件中使用全局可观察对象（Using local observable state in <code>observer</code> components）</h3><p>因为使用 <code>observer</code> 的可观察对象可以来自任何地方, 他们也可以使用local state（全局的state·译者注）。 再次声明，不同操作方式对于我们而言都是有价值的。</p><p>使用全局可观察对象的最简单的方式就是通过<code>useState</code>去存储一个全局可观察对象的引用。 需要注意的是, 因为我们不需要替换全局可观察对象的引用,所以我们其实可以完全不声明<code>useState</code>的更新方法:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> [timer] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>()) <span class="hljs-comment">// Timer的定义在上面（正如上面所说的那样这里我们忽略了更新方法的定义·译者注）。</span>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>如果你想要类似我们官方的例子那样自动更新 timer , 使用<code>useEffect</code> 可能是 React 中比较典型的写法：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> handle = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;        timer.<span class="hljs-title function_">increaseTimer</span>()    &#125;, <span class="hljs-number">1000</span>)    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">clearInterval</span>(handle)    &#125;&#125;, [timer])</code></pre></div><p>如刚才说的那样, 直接创建一个可观察的对象，而不是使用classes（这里的类指的是全局定义的Mobx state，在它们是使用class声明的）。 我们可以参考 <a href="https://zh.mobx.js.org/observable-state.html#observable">observable</a>这篇文章：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; observable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> [timer] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span>        <span class="hljs-title function_">observable</span>(&#123;            <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>,            <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;                <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span>++            &#125;        &#125;)    )    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p><code>const [store] = useState(() =&gt; observable(&#123; /* something */&#125;))</code> 是非常通用的一套写法， 为了简化这个写法我们可以调用<code>mobx-react-lite</code> 包中的 <a href="https://github.com/mobxjs/mobx-react#uselocalobservable-hook"><code>useLocalObservable</code></a> hook ,可以将上面的例子简化成：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer, useLocalObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useLocalObservable</span>(<span class="hljs-function">() =&gt;</span> (&#123;        <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>,        <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span>++        &#125;    &#125;))    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><h3 id="不要将可观察对象传递到-不是observer的组件中（Don’t-pass-observables-into-components-that-aren’t-observer）"><a href="#不要将可观察对象传递到-不是observer的组件中（Don’t-pass-observables-into-components-that-aren’t-observer）" class="headerlink" title="不要将可观察对象传递到 不是observer的组件中（Don’t pass observables into components that aren’t observer）"></a>不要将可观察对象传递到 不是<code>observer</code>的组件中（Don’t pass observables into components that aren’t <code>observer</code>）</h3><p>通过<code>observer</code>包裹的组件 <em>只可以</em> 订阅到在 <em>他们自己</em> 渲染的期间的可观察对象. 如果要将可观察对象 objects / arrays / maps 传递到子组件中, 他们必须被 <code>observer</code> 包裹。 通过callback回调的组件也是一样。</p><p>如果你非要传递可观察对象到未被<code>observer</code>包裹的组件中， 要么是因为它是第三方组件，要么你需要组件对Mobx无感知，那你必须在传递前 <a href="https://zh.mobx.js.org/observable-state.html#%E5%B0%86-observable-%E8%BD%AC%E6%8D%A2%E5%9B%9E%E6%99%AE%E9%80%9A%E7%9A%84-javascript-%E9%9B%86%E5%90%88">转换可观察对象为显式 （convert the observables to plain JavaScript values or structures）</a> 。</p><p>关于上述的详细描述, 可以看一下下面的使用 <code>todo</code> 对象的例子， 一个 <code>TodoView</code> (observer)组件和一个虚构的接收一组对象映射入参的不是<code>observer</code>的<code>GridRow</code>组件</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Todo</span> &#123;    title = <span class="hljs-string">&quot;test&quot;</span>    done = <span class="hljs-literal">true</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">TodoView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; todo &#125;: &#123; todo: Todo &#125;</span>) =&gt;</span>   <span class="hljs-comment">// 错误: GridRow 不能获取到 todo.title/ todo.done 的变更</span>   <span class="hljs-comment">//       因为他不是一个观察者（observer。</span>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;todo&#125;</span> /&gt;</span></span>   <span class="hljs-comment">// 正确:在 `TodoView` 中显式的声明相关的`todo` ，</span>   <span class="hljs-comment">//      到data中。</span>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;&#123;</span></span></span><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">title:</span> <span class="hljs-attr">todo.title</span>,</span></span><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">done:</span> <span class="hljs-attr">todo.done</span></span></span><span class="hljs-tag"><span class="language-xml">   &#125;&#125; /&gt;</span></span>   <span class="hljs-comment">// 正确: 使用 `toJS`也是可以的, 并且是更清晰直白的方式。</span>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;toJS(todo)&#125;</span> /&gt;</span></span>)</code></pre></div><h3 id="回调组件可能会需要-lt-Observer-gt-（-Callback-components-might-require-lt-Observer-gt-）"><a href="#回调组件可能会需要-lt-Observer-gt-（-Callback-components-might-require-lt-Observer-gt-）" class="headerlink" title="回调组件可能会需要&lt;Observer&gt;（ Callback components might require &lt;Observer&gt;）"></a>回调组件可能会需要<code>&lt;Observer&gt;</code>（ Callback components might require <code>&lt;Observer&gt;</code>）</h3><p>想象一下在同样的例子中, <code>GridRow</code> 携带一个 <code>onRender</code>回调函数。 <code>onRender</code> 是 <code>GridRow</code>渲染生命周期的一部分, 而不是 <code>TodoView</code> 的render (甚至在语法层面都能看出来)，我们不得不保证回调组件是一个 <code>observer</code> 组件。 或者，我们可以使用 <a href="https://github.com/mobxjs/mobx-react#observer">``</a>创建一个匿名观察者：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TodoView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; todo &#125;: &#123; todo: Todo &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 错误: GridRow.onRender 不能获得 todo.title / todo.done 中的改变</span>    <span class="hljs-comment">//        因为它不是一个观察者（observer） 。</span>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">onRender</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;todo.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>&#125; /&gt;</span>    <span class="hljs-comment">// 正确: 将回调组件通过Observer包裹将会正确的获得变化。</span>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">onRender</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">Observer</span>&gt;</span>&#123;() =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;todo.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Observer</span>&gt;</span>&#125; /&gt;</span>&#125;)</code></pre></div><p><strong>mobx-react vs. mobx-react-lite</strong></p><p>在本文中我们使用 <code>mobx-react-lite</code> 作为默认包。 <a href="https://github.com/mobxjs/mobx-react/">mobx-react</a> 是他的大兄弟，它里面也引用了 <code>mobx-react-lite</code> 包。 它提供了很多在新项目中不再需要的特性， mobx-react附加的特性有：</p><ol><li>对于React class components的支持。</li><li><code>Provider</code> 和<code>inject</code>. MobX的这些东西在有 React.createContext 替代后变得不必要了。</li><li>特殊的观察对象 <code>propTypes</code>。</li></ol><p>要注意 <code>mobx-react</code> 是全量包，也会暴露 <code>mobx-react-lite</code>包中的任何方法,其中包含对函数组件的支持。 如果你使用 <code>mobx-react</code>，那就不要添加 <code>mobx-react-lite</code> 的依赖和引用了。</p><p><strong>observer 🆚 React.memo</strong></p><p><code>observer</code> 会自动的使用 <code>memo</code>, 所以 <code>observer</code> 不需要再包裹 <code>memo</code>。 <code>memo</code> 会被 observer 组件安全的使用，因为任何在props中的改变(很深的) 都会被<code>observer</code>响应。</p><p><strong>应用<code>observer</code> 到基于class的组件</strong></p><p>如上所述，class 组件只在<code>mobx-react</code>包中得到支持， <code>mobx-react-lite</code>并不支持。 简而言之，你可以和函数式组件一样使用 <code>observer</code>包裹class 组件：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;React&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-keyword">const</span> &#123; timer &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>        &#125;    &#125;)</code></pre></div><p>可以阅读 <a href="https://github.com/mobxjs/mobx-react#api-documentation">mobx-react 文档</a> 获得更详细的信息。</p><p><strong>当你想要将<code>observer</code> 和其他高阶组件（HOC·译者注）一起使用, 需要首先调用 <code>observer</code></strong></p><p>当 <code>observer</code> 需要和装饰器或者其他高阶组件（HOC）一起使用时，请确保 <code>observer</code> 是最内层的 (最先调用的) 装饰器，否则的话它可能不会工作</p><p><strong>从 props导出计算属性</strong></p><p>在某些情况下你的组件本地可观察对象（local observables）的计算属性可能依赖于一些你组件接受到的参数（props）。 但是,这一系列从React组件接收到的参数（props）本身并不是可观察对象，所以更改这些组件的属性（props）并不会使得计算属性响应。你可能需要手动的从最新的数据来更新全局可观察对象的状态来触发计算属性更新。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer, useLocalObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; offset &#125;</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useLocalObservable</span>(<span class="hljs-function">() =&gt;</span> (&#123;        offset, <span class="hljs-comment">// 初始化offset</span>        <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>,        <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span>++        &#125;,        <span class="hljs-keyword">get</span> <span class="hljs-title function_">offsetTime</span>() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">offset</span> <span class="hljs-comment">// 这里的&#x27;offset&#x27;不是&#x27;props&#x27;传入的那个</span>        &#125;    &#125;))    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">//同步来自 &#x27;props&#x27; 的偏差到可观察对象 &#x27;timer&#x27;</span>        timer.<span class="hljs-property">offset</span> = offset    &#125;, [offset])    <span class="hljs-comment">//作为demo用途，初始化一个定时器.</span>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">const</span> handle = <span class="hljs-built_in">setInterval</span>(timer.<span class="hljs-property">increaseTimer</span>, <span class="hljs-number">1000</span>)        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">clearInterval</span>(handle)        &#125;    &#125;, [])    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.offsetTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>在实际项目中你可能很少需要这种写法, 因为 <code>return &lt;span&gt;Seconds passed: &#123;timer.secondsPassed - offset&#125;&lt;/span&gt;</code> 更加简单, 虽然是稍微低效率的解决方案。</p><p><strong>useEffect 与 可观察对象</strong></p><p><code>useEffect</code> 可以被用于触发需要发生的副作用, 它将会被约束在React 组建的生命周期中。 使用 <code>useEffect</code>需要指定详细的依赖。 对于 MobX 却不是必须的, 因为 MobX 拥有一种真正的能检查到依赖发发生的方法， <code>autorun</code>。 结合 <code>autorun</code>可以很轻松的在生命周期组件中使用<code>useEffect</code>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer, useLocalObservable, useAsObservableSource &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useLocalObservable</span>(<span class="hljs-function">() =&gt;</span> (&#123;        <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>,        <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span>++        &#125;    &#125;))    <span class="hljs-comment">// 在Effect方法之上触发可观察对象变化。</span>    <span class="hljs-title function_">useEffect</span>(        <span class="hljs-function">() =&gt;</span>            <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;                <span class="hljs-keyword">if</span> (timer.<span class="hljs-property">secondsPassed</span> &gt; <span class="hljs-number">60</span>) <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Still there. It&#x27;s a minute already?!!&quot;</span>)            &#125;),        []    )    <span class="hljs-comment">// 作为demo用途在Effect里定义一个定时器。</span>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">const</span> handle = <span class="hljs-built_in">setInterval</span>(timer.<span class="hljs-property">increaseTimer</span>, <span class="hljs-number">1000</span>)        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">clearInterval</span>(handle)        &#125;    &#125;, [])    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>需要注意的是我们在effect方法返回了一个创建自<code>autorun</code> 的清除方法。 这一点是非常重要的, 因为他确保了 <code>autorun</code> 在组件卸载的时候被清除了！</p><p>依赖数组可以保持为空，除非是一个不可观察对象的值需要触发autorun重新运行，你才需要将它添加到这里面。 请确保你的格式正确,你可以创建一个<code>定时器（timer）</code> (上面的例子中) 作为依赖。 这是安全并且无副作用的， 因为它引用的依赖根本不会改变。</p><p>如果你不想显式的在Effect中定义可观察对象请使用<code>reaction</code>而不是<code>autorun</code>，他们的传参是完全相同的。</p><h1 id="优化React组件渲染-🚀"><a href="#优化React组件渲染-🚀" class="headerlink" title="优化React组件渲染 {🚀}"></a>优化React组件渲染 {🚀}</h1>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>mobx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>杀手级的TypeScript功能：const断言</title>
    <link href="/2022/10/06/%E6%9D%80%E6%89%8B%E7%BA%A7%E7%9A%84TypeScript%E5%8A%9F%E8%83%BD%EF%BC%9Aconst%E6%96%AD%E8%A8%80/"/>
    <url>/2022/10/06/%E6%9D%80%E6%89%8B%E7%BA%A7%E7%9A%84TypeScript%E5%8A%9F%E8%83%BD%EF%BC%9Aconst%E6%96%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><code>const assertions</code>是ts3.4新增的功能，们可以用这个新功能省略很多繁琐的类型声明</p><h3 id="const-assertions"><a href="#const-assertions" class="headerlink" title="const assertions"></a>const assertions</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello&quot;</span> &#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code></pre></div><p>官方的解释是</p><p>const断言是ts3.4新增的一种构造函数，他的语法是用const代替type的类型断言，例如 <code>123 as const</code>），当我们使用const进行断言literal expression的时候，会做以下处理</p><ol><li>该表达式的字面量类型不会被扩展</li><li>对象字面量获取的是readonly属性</li><li>array literals将会变成readonly tuples</li></ol><p>官方的解释会比较困惑</p><h3 id="No-type-widening-for-literal-types-文字类型没有类型扩展"><a href="#No-type-widening-for-literal-types-文字类型没有类型扩展" class="headerlink" title="No type widening for literal types [文字类型没有类型扩展]"></a>No type widening for literal types [文字类型没有类型扩展]</h3><p>通过const断言，文字类型不会被扩展为更加宽泛的类型，当我们使用const声明字面量变量的时候，类型就会等于右侧的字面量</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&#x27;x&#x27;</span>; <span class="hljs-comment">// x has the type &#x27;x&#x27;</span></code></pre></div><p>const关键字可以确保不会重新分配变量类型并且会保证更加严格的类型定义，但是，如果我们使用let替代const的时候，let就会变成更加宽泛的类型</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&#x27;x&#x27;</span>; <span class="hljs-comment">// has the type &#x27;x&#x27; </span><span class="hljs-keyword">let</span> y = <span class="hljs-string">&#x27;x&#x27;</span>;   <span class="hljs-comment">// has the type string</span></code></pre></div><p>y会扩展为更加宽泛的值，允许分配其他值给y,而x只能是字面量的x,如果我们向让let也可以这么做，就可以使用const断言</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> y = <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// y has type &#x27;x&#x27;</span></code></pre></div><h3 id="object-literals-get-readonly-properties-对象字面量获得只读属性"><a href="#object-literals-get-readonly-properties-对象字面量获得只读属性" class="headerlink" title="object literals get readonly properties [对象字面量获得只读属性]"></a>object literals get readonly properties [对象字面量获得只读属性]</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> action = &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, &#125; <span class="hljs-comment">// has type &#123; type: string &#125;</span></code></pre></div><p>const声明对象时，却依然会出现属性的扩展</p><p>如果你熟悉使用redux的时候，action用于执行修改变量，对外界来说，redux是全局不可修改的state store,state只能通过action在reducer中进行修改，reducer是纯函数，他会返回更新之后的state的版本，在action被dispatch之后、</p><p>在redux中，通常情况下，是在actionCreator中创建action,actionCreators是纯函数，它会返回redux action的字面量的对象，以及提供参数给action</p><p>用一个例子进行解释说明</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params">n: number</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n,  &#125;&#125;<span class="hljs-keyword">const</span> action = <span class="hljs-title function_">setCount</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">// action has type</span><span class="hljs-comment">// &#123; type: string, payload: number &#125;</span></code></pre></div><p>type的类型应该是字面量的，但是会被自动转换成更加宽泛的类型，在TS3.4以前，我们需要显示的指定返回值类型才可以达到类似的效果，</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetCount</span> &#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>;  <span class="hljs-attr">payload</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">const</span> setCount = (<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">SetCount</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n,  &#125;&#125;<span class="hljs-keyword">const</span> action = <span class="hljs-title function_">setCount</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">// action has type SetCount</span></code></pre></div><p>ts3.4以后使用const断言也可以实现同样的效果,而且是只读属性的</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">const</span>&gt;&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n  &#125;&#125;<span class="hljs-keyword">const</span> action = <span class="hljs-title function_">setCount</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">// action has type</span><span class="hljs-comment">//  &#123; readonly type: &quot;SET_COUNT&quot;; readonly payload: number &#125;;</span></code></pre></div><p>对于使用了联合类型的action,在没有使用const断言的时候会比较麻烦</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetCount</span> &#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>;  <span class="hljs-attr">payload</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResetCount</span> &#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;RESET_COUNT&#x27;</span>;&#125;<span class="hljs-keyword">const</span> setCount = (<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">SetCount</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n,  &#125;&#125;<span class="hljs-keyword">const</span> resetCount = (): <span class="hljs-function"><span class="hljs-params">ResetCount</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;RESET_COUNT&#x27;</span>,  &#125;&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">CountActions</span> = <span class="hljs-title class_">SetCount</span> | <span class="hljs-title class_">ResetCount</span></code></pre></div><p>通过使用const的用法</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">const</span>&gt;&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n  &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">resetCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">const</span>&gt;&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;RESET_COUNT&#x27;</span>  &#125;&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">CountActions</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> setCount&gt; | <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> resetCount&gt;;</code></pre></div><h3 id="Array-literals-become-readonly-tuples"><a href="#Array-literals-become-readonly-tuples" class="headerlink" title="Array literals become readonly tuples"></a>Array literals become <code>readonly</code> tuples</h3><div class="code-wrapper"><pre><code class="hljs sqf">const <span class="hljs-built_in">action</span> = &#123;  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;SET_HOURS&#x27;</span>,  payload: [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>],&#125;<span class="hljs-comment">//  &#123; type: string; payload: number[]; &#125;</span><span class="hljs-built_in">action</span>.payload.push(<span class="hljs-number">12</span>) <span class="hljs-comment">// no error</span></code></pre></div><p>action。payload是可以修改的</p><p>如果使用了const断言</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> action = &lt;<span class="hljs-keyword">const</span>&gt;&#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_HOURS&#x27;</span>,  <span class="hljs-attr">payload</span>: [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]&#125;<span class="hljs-comment">// &#123;</span><span class="hljs-comment">//  readonly type: &quot;SET_HOURS&quot;;</span><span class="hljs-comment">//  readonly payload: readonly [8, 12, 5, 8];</span><span class="hljs-comment">// &#125;</span>action.<span class="hljs-property">payload</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">12</span>);  <span class="hljs-comment">// error - Property &#x27;push&#x27; does not exist on type &#x27;readonly [8, 12, 5, 8]&#x27;.</span></code></pre></div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;  <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>,  <span class="hljs-attr">y</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>],  <span class="hljs-attr">z</span>: &#123;    <span class="hljs-attr">a</span>:      &#123;  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span> &#125;  &#125; &#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code></pre></div><p>转换成</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: &#123;  readonly <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>;  readonly <span class="hljs-attr">y</span>: readonly [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>];  readonly <span class="hljs-attr">z</span>: &#123;    readonly <span class="hljs-attr">a</span>: &#123;      readonly <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>;    &#125;;  &#125;;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React18+Typescript的使用</title>
    <link href="/2022/10/05/React18-Typescript%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/05/React18-Typescript%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>Typescript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Enzyme react 单元测试</title>
    <link href="/2022/09/25/Enzyme-react-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/09/25/Enzyme-react-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="enyzme不再支持react18，如果需要使用请使用官方的测试工具React-Testing-Library"><a href="#enyzme不再支持react18，如果需要使用请使用官方的测试工具React-Testing-Library" class="headerlink" title="enyzme不再支持react18，如果需要使用请使用官方的测试工具React Testing Library"></a>enyzme不再支持react18，如果需要使用请使用官方的测试工具React Testing Library</h1><p><strong>enzyme</strong> / ˈenzaɪm /</p><p>Enzyme是一种react的javascript的单元测试工具，可以轻松的测试react组件的输出，Enyzme的API主要是模仿jq的api来进行DOM的遍历和操作</p><p>安装方式</p><div class="code-wrapper"><pre><code class="hljs bash">npm i --save-dev enzyme enzyme-adapter-react-17</code></pre></div><p>enzyme的配置方式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Enzyme</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme-adapter-react-17&#x27;</span>;<span class="hljs-title class_">Enzyme</span>.<span class="hljs-title function_">configure</span>(&#123; <span class="hljs-attr">adapter</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>() &#125;);</code></pre></div><p>Enzyme的三种渲染组件的方式</p><h4 id="Shallow-Rendering"><a href="#Shallow-Rendering" class="headerlink" title="Shallow Rendering"></a>Shallow Rendering</h4><p>是对官方的Shallow Renderer的封装，将组件渲染成虚拟DOM对象，只会渲染第一层，子组件将不会渲染出来，因此效率非常高，不需要DOM环境，并且可以以JQ的方式访问组件</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; shallow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme&#x27;</span>;<span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);<span class="hljs-comment">// ...</span></code></pre></div><h5 id="常见的api"><a href="#常见的api" class="headerlink" title="常见的api"></a>常见的api</h5><h6 id="at-index-gt-ShallowWrapper"><a href="#at-index-gt-ShallowWrapper" class="headerlink" title=".at(index) =&gt; ShallowWrapper"></a><code>.at(index) =&gt; ShallowWrapper</code></h6><p>通过索引获取对应的wrapper</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);<span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">props</span>().<span class="hljs-property">foo</span>).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);</code></pre></div><p>和get方法相似，但是返回值是reactElement不是wrapper</p><p>first方法相当于at(0),last方法相当于返回最后一个</p><h6 id="childAt-index-gt-ShallowWrapper"><a href="#childAt-index-gt-ShallowWrapper" class="headerlink" title=".childAt(index) =&gt; ShallowWrapper"></a><code>.childAt(index) =&gt; ShallowWrapper</code></h6><p>通过索引找到第几个子元素，返回wrapper</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ToDoList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;items&#125;</span> /&gt;</span></span>);<span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;ul&#x27;</span>).<span class="hljs-title function_">childAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">type</span>()).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-string">&#x27;li&#x27;</span>);</code></pre></div><h6 id="children-selector-gt-ShallowWrapper"><a href="#children-selector-gt-ShallowWrapper" class="headerlink" title=".children([selector]) =&gt; ShallowWrapper"></a><code>.children([selector]) =&gt; ShallowWrapper</code></h6><p>找到所有子元素，可以传入可选参数，返回wrapper</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ToDoList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;items&#125;</span> /&gt;</span></span>);<span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;ul&#x27;</span>).<span class="hljs-title function_">children</span>()).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(items.<span class="hljs-property">length</span>);</code></pre></div><h6 id="closest-selector-gt-ShallowWrapper"><a href="#closest-selector-gt-ShallowWrapper" class="headerlink" title=".closest(selector) =&gt; ShallowWrapper"></a><code>.closest(selector) =&gt; ShallowWrapper</code></h6><p>返回匹配到的选择器的第一个选择器的wrapper</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);<span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">closest</span>(<span class="hljs-string">&#x27;.bar&#x27;</span>)).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">1</span>);</code></pre></div><h4 id="Full-DOM-Rendering"><a href="#Full-DOM-Rendering" class="headerlink" title="Full DOM Rendering"></a>Full DOM Rendering</h4><p>完全渲染，它将组件渲染加载成一个真实的DOM节点，用来测试DOM API的交互和组件的生命周期，用到了jsdom来模拟浏览器环境</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; mount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme&#x27;</span>;<span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">mount</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);</code></pre></div><h4 id="Static-Rendered-Markup"><a href="#Static-Rendered-Markup" class="headerlink" title="Static Rendered Markup"></a>Static Rendered Markup</h4><p>静态渲染，它将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库解析这段字符串，并返回一个Cheerio的实例对象，可以用来分析组件的html结构</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme&#x27;</span>;<span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);<span class="hljs-comment">// ...</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>单元测试</category>
      
      <category>Enzyme</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>secket.io笔记</title>
    <link href="/2022/09/24/secket-io%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/24/secket-io%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>目前是4.x版本</p><h2 id="什么是-Socket-IO"><a href="#什么是-Socket-IO" class="headerlink" title="什么是 Socket.IO"></a>什么是 Socket.IO</h2><p>Socket.IO 是一个库，可以在客户端和服务器之间实现 <strong>低延迟</strong>, <strong>双向</strong> 和 <strong>基于事件的</strong> 通信。</p><p><img src="https://socket.io/zh-CN/images/bidirectional-communication2.png" alt="Diagram of a communication between a server and a client"></p><p>它建立在 <a href="https://fr.wikipedia.org/wiki/WebSocket">WebSocket</a> 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。</p><p>这里只介绍socket.io在web端的使用</p><p>这是一个websocket的实例</p><p><em>服务器</em> (基于 <a href="https://github.com/websockets/ws">ws</a>)</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i ws</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">WebSocketServer</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ws&quot;</span>;<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServer</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span> &#125;);server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 向客户端发送消息</span>  socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;hello from server&quot;</span>,    <span class="hljs-attr">content</span>: [ <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span> ]  &#125;));  <span class="hljs-comment">// 从客户端接收消息</span>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> packet = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);    <span class="hljs-keyword">switch</span> (packet.<span class="hljs-property">type</span>) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello from server&quot;</span>:        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">break</span>;    &#125;  &#125;);&#125;);</code></pre></div><p>客户端</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">WebSocket</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ws&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:3000&quot;</span>);socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 向服务器发送消息</span>  socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;hello from server&quot;</span>,    <span class="hljs-attr">content</span>: [ <span class="hljs-number">3</span>, <span class="hljs-string">&quot;4&quot;</span> ]  &#125;));&#125;);<span class="hljs-comment">// 从服务器接收消息</span>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> packet = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);  <span class="hljs-keyword">switch</span> (packet.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello from server&quot;</span>:      <span class="hljs-comment">// ...</span>      <span class="hljs-keyword">break</span>;  &#125;&#125;);</code></pre></div><p>socket.io的示例,需要先安装socket.io和socket.io-client</p><p>服务端</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(<span class="hljs-number">3000</span>);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 向客户端发送消息</span>  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">4</span>]) &#125;);  <span class="hljs-comment">// 从客户端接收消息</span>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...</span>  &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;ws://localhost:3000&quot;</span>);<span class="hljs-comment">// 向服务器发送消息</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;6&quot;</span>, &#123; <span class="hljs-number">7</span>: <span class="hljs-title class_">Uint8Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">8</span>]) &#125;);<span class="hljs-comment">// 从服务器接收消息</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h2 id="Socket-IO-不是什么"><a href="#Socket-IO-不是什么" class="headerlink" title="Socket.IO 不是什么"></a>Socket.IO 不是什么</h2><p>Socket.IO <strong>不是</strong> WebSocket实现。是基于WebSocket协议</p><p>尽管 Socket.IO 确实在可能的情况下使用 WebSocket 进行传输，但它为每个数据包添加了额外的元数据。这就是为什么 WebSocket 客户端将无法成功连接到 Socket.IO 服务器，而 Socket.IO 客户端也将无法连接到普通 WebSocket 服务器。</p><div class="code-wrapper"><pre><code class="hljs abnf">// 警告：客户端将无法连接！const socket <span class="hljs-operator">=</span> io(<span class="hljs-string">&quot;ws://echo.websocket.org&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><h2 id="Socket-IO特点"><a href="#Socket-IO特点" class="headerlink" title="Socket.IO特点"></a>Socket.IO特点</h2><h3 id="HTTP-长轮询回退"><a href="#HTTP-长轮询回退" class="headerlink" title="HTTP 长轮询回退"></a>HTTP 长轮询回退</h3><p>如果无法建立 WebSocket 连接，连接将回退到 HTTP 长轮询。</p><h3 id="自动重新连接"><a href="#自动重新连接" class="headerlink" title="自动重新连接"></a>自动重新连接</h3><p>在某些特定情况下，服务器和客户端之间的 WebSocket 连接可能会中断，而双方都不知道链接的断开状态。</p><p>这就是为什么 Socket.IO 包含一个心跳机制，它会定期检查连接的状态。</p><p>当客户端最终断开连接时，它会以指数回退延迟自动重新连接，以免使服务器不堪重负。</p><h3 id="数据包缓冲"><a href="#数据包缓冲" class="headerlink" title="数据包缓冲"></a>数据包缓冲</h3><p>当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送</p><h3 id="收到后的回调"><a href="#收到后的回调" class="headerlink" title="收到后的回调"></a>收到后的回调</h3><p>Socket.IO 提供了一种方便的方式来发送事件和接收响应    </p><p><em>发件人</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response); <span class="hljs-comment">// &quot;got it&quot;</span>&#125;);</code></pre></div><p><em>接收者</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg, callback</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// &quot;world&quot;</span>  <span class="hljs-title function_">callback</span>(<span class="hljs-string">&quot;got it!&quot;</span>);&#125;);</code></pre></div><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p><a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/">在服务器端，您可以向所有连接的客户端</a>或<a href="https://socket.io/zh-CN/docs/v4/rooms/">客户端的子集</a>发送事件：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 到所有连接的客户端</span>io.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">// 致“news”房间中的所有连接客户端</span>io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;news&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);</code></pre></div><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>命名空间允许您在单个共享连接上拆分应用程序的逻辑。例如，如果您想创建一个只有授权用户才能加入的“管理员”频道，这可能很有用。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 普通用户</span>&#125;);io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 管理员用户</span>&#125;);</code></pre></div><h2 id="运作原理"><a href="#运作原理" class="headerlink" title="运作原理"></a>运作原理</h2><p>Socket.IO 服务器 (Node.js) 和 Socket.IO 客户端（浏览器, Node.js, or <a href="https://socket.io/zh-CN/docs/v4/#what-socketio-is">其他编程语言</a>）之间的双向通道尽可能使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket 连接</a>建立，并将使用 HTTP 长轮询作为后备。</p><p>Socket.IO 代码库分为两个不同的层：</p><ul><li>底层通道：我们称之为Engine.IO，Socket.IO内部的引擎</li><li>高级 API：Socket.IO 本身</li></ul><h2 id="Engine-IO"><a href="#Engine-IO" class="headerlink" title="Engine.IO"></a>Engine.IO</h2><p>Engine.IO 负责建立服务器和客户端之间的低级连接。它处理：</p><ul><li>各种<a href="https://socket.io/zh-CN/docs/v4/how-it-works/#transports">传输</a>和<a href="https://socket.io/zh-CN/docs/v4/how-it-works/#upgrade-mechanism">升级机制</a></li><li><a href="https://socket.io/zh-CN/docs/v4/how-it-works/#disconnection-detection">断线检测</a></li></ul><p>源代码可以在这里找到：</p><ul><li>服务器：<a href="https://github.com/socketio/engine.io">https://github.com/socketio/engine.io</a></li><li>客户端：<a href="https://github.com/socketio/engine.io-client">https://github.com/socketio/engine.io-client</a></li><li>解析器：<a href="https://github.com/socketio/engine.io-parser">https://github.com/socketio/engine.io-parser</a></li><li>协议说明：<a href="https://github.com/socketio/engine.io-protocol">https://github.com/socketio/engine.io-protocol</a></li></ul><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>目前有两种实现的传输:</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/how-it-works/#http-long-polling">HTTP 长轮询</a></li><li><a href="https://socket.io/zh-CN/docs/v4/how-it-works/#websocket">WebSocket</a></li></ul><h4 id="HTTP-长轮询"><a href="#HTTP-长轮询" class="headerlink" title="HTTP 长轮询"></a>HTTP 长轮询</h4><p>THTTP 长轮询传输（也简称为“轮询”）由连续的 HTTP 请求组成：</p><ul><li>长时间运行的 <code>GET</code> 请求，用于从服务器接收数据</li><li>短时 <code>POST</code> 请求，用于向服务器发送数据</li></ul><p>由于传输的性质，可能会在同一个 HTTP 请求中连接并发送连续的请求。</p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 传输由<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocket 连接</a>组成，它在服务器和客户端之间提供双向和低延迟的通信通道。</p><p>由于传输的性质，每个发射都在其自己的 WebSocket 帧中发送（有些发射甚至可能导致两个不同的 WebSocket 帧，更多信息<a href="https://socket.io/zh-CN/docs/v4/custom-parser/#the-default-parser">在这里</a>).</p><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>在 Engine.IO 连接开始时，服务器发送一些信息：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FSDjX-WRwSA4zTZMALqx&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;upgrades&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;websocket&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;pingInterval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25000</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;pingTimeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20000</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>复制</p><ul><li><code>sid</code> 是会话的ID，它必须包含在sid所有后续HTTP请求的查询参数中</li><li><code>upgrades</code> 数组包含服务器支持的所有“更好”传输的列表</li><li><code>pingInterval</code> 和 <code>pingTimeout</code> 值用于心跳</li></ul><h3 id="升级机制"><a href="#升级机制" class="headerlink" title="升级机制"></a>升级机制</h3><p>默认情况下，客户端使用 HTTP 长轮询传输建立连接。</p><p><strong>为什么呢?</strong></p><p>虽然 WebSocket 显然是建立双向通信的最佳方式，但经验表明，由于企业代理、个人防火墙、防病毒软件…</p><p>从用户的角度来看，一个不成功的 WebSocket 连接可以转化为等待实时应用程序开始交换数据的至少 10 秒。 这在<strong>感知</strong>上会损害用户体验。</p><p>总而言之，Engine.io首先关注可靠性和用户体验，其次关注潜在的 UX 改进和提高服务器性能。</p><p>要升级，客户端将：</p><ul><li>确保其传出缓冲区为空</li><li>将当前传输设置为只读模式</li><li>尝试与其他传输建立连接</li><li>如果成功，关闭第一个传输</li></ul><p>您可以在浏览器的网络监视器中查看：</p><p><img src="https://socket.io/zh-CN/assets/images/network-monitor-2e47dbe233100aa290595f8687a9fcba.png" alt="Successful upgrade"></p><ol><li>握手 (包含会话 ID — 此处, <code>zBjrh...AAAK</code> — 用于后续请求)</li><li>发送数据 (HTTP 长轮询)</li><li>接收数据 (HTTP 长轮询)</li><li>升级 (WebSocket)</li><li>接收数据 (HTTP 长轮询, WebSocket连接建立成功后关闭)</li></ol><h3 id="断线检测"><a href="#断线检测" class="headerlink" title="断线检测"></a>断线检测</h3><p>Engine.IO 连接在以下情况下被视为关闭：</p><ul><li>一个 HTTP 请求（GET 或 POST）失败（例如，当服务器关闭时）</li><li>WebSocket 连接关闭（例如，当用户关闭其浏览器中的选项卡时）</li><li><code>socket.disconnect()</code> 在服务器端或客户端调用</li></ul><p>还有一个心跳机制检查服务器和客户端之间的连接是否仍然正常运行：</p><p>在给定的时间间隔（ <code>pingInterval</code>握手中发送的值），服务器发送一个 PING 数据包，客户端有几秒钟（该<code>pingTimeout</code>值）发送一个 PONG 数据包。如果服务器没有收到返回的 PONG 数据包，则认为连接已关闭。反之，如果客户端在 内没有收到 PING 包<code>pingInterval + pingTimeout</code>，则认为连接已关闭。</p><h2 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h2><p>Socket.IO 通过 Engine.IO 连接提供了一些附加功能：</p><ul><li>自动重连</li><li><a href="https://socket.io/zh-CN/docs/v4/client-offline-behavior/#buffered-events">数据包缓冲</a></li><li><a href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">收到后的回调</a></li><li>广播 <a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/">到所有客户端</a> 或 <a href="https://socket.io/zh-CN/docs/v4/rooms/">客户端的子集</a>（我们称之为“房间”）</li><li><a href="https://socket.io/zh-CN/docs/v4/namespaces/">多路复用</a>（我们称之为“命名空间”）</li></ul><p>源代码可以在这里找到：</p><ul><li>服务器：<a href="https://github.com/socketio/socket.io">https://github.com/socketio/socket.io</a></li><li>客户端：<a href="https://github.com/socketio/socket.io-client">https://github.com/socketio/socket.io-client</a></li><li>解析器：<a href="https://github.com/socketio/socket.io-parser">https://github.com/socketio/socket.io-parser</a></li><li>协议说明：<a href="https://github.com/socketio/socket.io-protocol">https://github.com/socketio/socket.io-protocol</a></li></ul><h1 id="服务器安装"><a href="#服务器安装" class="headerlink" title="服务器安装"></a>服务器安装</h1><div class="code-wrapper"><pre><code class="hljs sh">npm install socket.io</code></pre></div><p>安装特定版本：</p><div class="code-wrapper"><pre><code class="hljs sh">npm install socket.io@version</code></pre></div><p>默认情况下，Socket.IO 使用<a href="https://www.npmjs.com/package/ws">ws</a>包提供的 WebSocket 服务器。</p><h1 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a>服务器初始化</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="只使用Socket"><a href="#只使用Socket" class="headerlink" title="只使用Socket"></a>只使用Socket</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//commonjs</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Server</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//esmodule</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p>您还可以将端口作为第一个参数传递：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(<span class="hljs-number">3000</span>, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><p>这隐式启动了一个 Node.js<a href="https://nodejs.org/docs/latest/api/http.html#http_class_http_server">HTTP 服务器</a>，可以通过 <code>io.httpServer</code>。</p><h3 id="使用HTTP服务器"><a href="#使用HTTP服务器" class="headerlink" title="使用HTTP服务器"></a>使用HTTP服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><h3 id="使用HTTPS服务器"><a href="#使用HTTPS服务器" class="headerlink" title="使用HTTPS服务器"></a>使用HTTPS服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(&#123;  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/key.pem&quot;</span>),  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/cert.pem&quot;</span>)&#125;);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p>使用客户端证书身份验证：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(&#123;  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-key.pem&quot;</span>),  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-cert.pem&quot;</span>),  <span class="hljs-attr">requestCert</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">ca</span>: [    <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-cert.pem&quot;</span>)  ]&#125;);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">rawSocket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// if you need the certificate details (it is no longer available once the handshake is completed)</span>  rawSocket.<span class="hljs-property">peerCertificate</span> = rawSocket.<span class="hljs-property">request</span>.<span class="hljs-property">client</span>.<span class="hljs-title function_">getPeerCertificate</span>();&#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">conn</span>.<span class="hljs-property">peerCertificate</span>);  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://example.com&quot;</span>, &#123;  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-key.pem&quot;</span>),  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-cert.pem&quot;</span>),  <span class="hljs-attr">ca</span>: [    <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-cert.pem&quot;</span>)  ]&#125;);</code></pre></div><h3 id="使用HTTP-2服务器"><a href="#使用HTTP-2服务器" class="headerlink" title="使用HTTP/2服务器"></a>使用HTTP/2服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> &#123; createSecureServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http2&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createSecureServer</span>(&#123;  <span class="hljs-attr">allowHTTP1</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/key.pem&quot;</span>),  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/cert.pem&quot;</span>)&#125;);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><h3 id="使用-Express"><a href="#使用-Express" class="headerlink" title="使用 Express"></a>使用 Express</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//esmodule</span><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//ts</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p><u>在这里使用<code>app.listen(3000)</code>将不起作用，因为它会创建一个新的 HTTP 服务器。</u></p><h3 id="使用-Koa"><a href="#使用-Koa" class="headerlink" title="使用 Koa"></a>使用 Koa</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app.<span class="hljs-title function_">callback</span>());<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app.<span class="hljs-title function_">callback</span>());<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><h3 id="使用-µWebSockets-js"><a href="#使用-µWebSockets-js" class="headerlink" title="使用 µWebSockets.js"></a>使用 µWebSockets.js</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">App</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;uWebSockets.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();io.<span class="hljs-title function_">attachApp</span>(app);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (!token) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;port already in use&quot;</span>);  &#125;&#125;);</code></pre></div><h3 id="使用-Fastify"><a href="#使用-Fastify" class="headerlink" title="使用 Fastify"></a>使用 Fastify</h3><p>您需要注册<a href="https://github.com/alemagio/fastify-socket.io"><code>fastify-socket.io</code></a>插件：</p><ul><li><p>CommonJS</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fastify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fastify&quot;</span>);<span class="hljs-keyword">const</span> fastifyIO = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fastify-socket.io&quot;</span>);<span class="hljs-keyword">const</span> server = <span class="hljs-title function_">fastify</span>();server.<span class="hljs-title function_">register</span>(fastifyIO);server.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, reply</span>) =&gt;</span> &#123;  server.<span class="hljs-property">io</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);&#125;);server.<span class="hljs-title function_">ready</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// we need to wait for the server to be ready, else `server.io` is undefined</span>  server.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...</span>  &#125;);&#125;);server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div></li><li><p>ES modules</p></li><li><p>```js<br>import fastify from “fastify”;<br>import fastifyIO from “fastify-socket.io”;</p><p>const server = fastify();<br>server.register(fastifyIO);</p><p>server.get(“/“, (req, reply) =&gt; {<br>  server.io.emit(“hello”);<br>});</p><p>server.ready().then(() =&gt; {<br>  // we need to wait for the server to be ready, else <code>server.io</code> is undefined<br>  server.io.on(“connection”, (socket) =&gt; {</p><div class="code-wrapper"><pre><code class="hljs">// ...</code></pre></div><p>  });<br>});</p><p>server.listen(3000);</p><div class="code-wrapper"><pre><code class="hljs moonscript">  - TypeScript```ts<span class="hljs-keyword">import</span> fastify <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fastify&quot;</span>;<span class="hljs-keyword">import</span> fastifyIO <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fastify-socket.io&quot;</span>;const server = fastify();server.register(fastifyIO);server.get(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-params">(req, reply)</span> =&gt;</span> &#123;  server.<span class="hljs-built_in">io</span>.emit(<span class="hljs-string">&quot;hello&quot;</span>);&#125;);server.ready().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  // we need to wait <span class="hljs-keyword">for</span> the server to be ready, <span class="hljs-keyword">else</span> `server.<span class="hljs-built_in">io</span>` is undefined  server.<span class="hljs-built_in">io</span>.on(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">(socket)</span> =&gt;</span> &#123;    // ...  &#125;);&#125;);server.listen(<span class="hljs-number">3000</span>);</code></pre></div></li></ul><h1 id="服务器实例"><a href="#服务器实例" class="headerlink" title="服务器实例"></a>服务器实例</h1><p>服务器实例（通常<code>io</code>在代码示例中调用）具有一些可能在您的应用程序中使用的属性。</p><p>它还继承了<a href="https://socket.io/zh-CN/docs/v4/namespaces/#main-namespace">主命名空间</a>的所有方法，例如<a href="https://socket.io/zh-CN/docs/v4/server-api/#namespaceusefn"><code>namespace.use()</code></a>（参见<a href="https://socket.io/zh-CN/docs/v4/middlewares/">此处</a>）或 <a href="https://socket.io/zh-CN/docs/v4/server-api/#namespaceallsockets"><code>namespace.allSockets()</code></a>.</p><h2 id="服务器-engine"><a href="#服务器-engine" class="headerlink" title="服务器#engine"></a>服务器#engine</h2><p>对底层 Engine.IO 服务器的引用。</p><p>它可用于获取当前连接的客户端数量：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = io.<span class="hljs-property">engine</span>.<span class="hljs-property">clientsCount</span>;<span class="hljs-comment">// 根据您的用法，可能与主命名空间中的Socket实例计数相似或不相似</span><span class="hljs-keyword">const</span> count2 = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">sockets</span>.<span class="hljs-property">size</span>;</code></pre></div><p>或者生成自定义会话 ID（<code>sid</code>查询参数）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> uuid = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;uuid&quot;</span>);io.<span class="hljs-property">engine</span>.<span class="hljs-property">generateId</span> = <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> uuid.<span class="hljs-title function_">v4</span>(); <span class="hljs-comment">// 必须在所有socket.io服务器上都是唯一的</span>&#125;</code></pre></div><p>从<code>socket.io@4.1.0</code>开始，Engine.IO 服务器发出三个特殊事件：</p><ul><li><code>initial_headers</code>: 将在编写会话的第一个 HTTP 请求（握手）的响应标头之前发出，允许您自定义它们。</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;initial_headers&quot;</span>, <span class="hljs-function">(<span class="hljs-params">headers, req</span>) =&gt;</span> &#123;  headers[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-string">&quot;123&quot;</span>;  headers[<span class="hljs-string">&quot;set-cookie&quot;</span>] = <span class="hljs-string">&quot;mycookie=456&quot;</span>;&#125;);</code></pre></div><ul><li><code>headers</code>: 将在编写会话的每个 HTTP 请求的响应头之前发出（包括 WebSocket 升级），允许您自定义它们。</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;headers&quot;</span>, <span class="hljs-function">(<span class="hljs-params">headers, req</span>) =&gt;</span> &#123;  headers[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-string">&quot;789&quot;</span>;&#125;);</code></pre></div><ul><li><code>connection_error</code>: 当连接异常关闭时发出</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">req</span>);      <span class="hljs-comment">// the request object</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">code</span>);     <span class="hljs-comment">// the error code, for example 1</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>);  <span class="hljs-comment">// the error message, for example &quot;Session ID unknown&quot;</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">context</span>);  <span class="hljs-comment">// some additional error context</span>&#125;);</code></pre></div><p>以下是可能的错误代码列表：</p><table><thead><tr><th>Code</th><th>Message</th></tr></thead><tbody><tr><td>0</td><td>“Transport unknown”</td></tr><tr><td>1</td><td>“Session ID unknown”</td></tr><tr><td>2</td><td>“Bad handshake method”</td></tr><tr><td>3</td><td>“Bad request”</td></tr><tr><td>4</td><td>“Forbidden”</td></tr><tr><td>5</td><td>“Unsupported protocol version”</td></tr></tbody></table><h3 id="socketsJoin"><a href="#socketsJoin" class="headerlink" title="socketsJoin"></a><code>socketsJoin</code></h3><p>此方法使匹配的 Socket 实例加入指定的房间：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances join the &quot;room1&quot; room</span>io.<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room1&quot;</span>);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room join the &quot;room2&quot; and &quot;room3&quot; rooms</span>io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsJoin</span>([<span class="hljs-string">&quot;room2&quot;</span>, <span class="hljs-string">&quot;room3&quot;</span>]);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace join the &quot;room2&quot; room</span>io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room2&quot;</span>);<span class="hljs-comment">// this also works with a single socket ID</span>io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room1&quot;</span>);</code></pre></div><h3 id="socketsLeave"><a href="#socketsLeave" class="headerlink" title="socketsLeave"></a><code>socketsLeave</code></h3><p>该方法使匹配的 Socket 实例离开指定房间：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances leave the &quot;room1&quot; room</span>io.<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room1&quot;</span>);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room leave the &quot;room2&quot; and &quot;room3&quot; rooms</span>io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsLeave</span>([<span class="hljs-string">&quot;room2&quot;</span>, <span class="hljs-string">&quot;room3&quot;</span>]);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace leave the &quot;room2&quot; room</span>io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room2&quot;</span>);<span class="hljs-comment">// this also works with a single socket ID</span>io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room1&quot;</span>);</code></pre></div><h3 id="disconnectSockets"><a href="#disconnectSockets" class="headerlink" title="disconnectSockets"></a><code>disconnectSockets</code></h3><p>此方法使匹配的 Socket 实例断开连接：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances disconnect</span>io.<span class="hljs-title function_">disconnectSockets</span>();<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room disconnect (and discard the low-level connection)</span>io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">disconnectSockets</span>(<span class="hljs-literal">true</span>);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace disconnect</span>io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">disconnectSockets</span>();<span class="hljs-comment">// this also works with a single socket ID</span>io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">disconnectSockets</span>();</code></pre></div><h3 id="fetchSockets"><a href="#fetchSockets" class="headerlink" title="fetchSockets"></a><code>fetchSockets</code></h3><p>此方法返回匹配的 Socket 实例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// return all Socket instances of the main namespace</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-comment">// return all Socket instances in the &quot;room1&quot; room of the main namespace</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-comment">// return all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-comment">// this also works with a single socket ID</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">fetchSockets</span>();</code></pre></div><p>上例中的<code>sockets</code>变量是一个对象数组，暴露了通常的 Socket 类的一个子集：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> socket <span class="hljs-keyword">of</span> sockets) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">handshake</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">data</span>);  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-comment">/* ... */</span>);  socket.<span class="hljs-title function_">join</span>(<span class="hljs-comment">/* ... */</span>);  socket.<span class="hljs-title function_">leave</span>(<span class="hljs-comment">/* ... */</span>);  socket.<span class="hljs-title function_">disconnect</span>(<span class="hljs-comment">/* ... */</span>);&#125;</code></pre></div><p><code>data</code>属性是一个任意对象，可用于在 Socket.IO 服务器之间共享信息：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-property">data</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;alice&quot;</span>;&#125;);<span class="hljs-comment">// server B</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sockets[<span class="hljs-number">0</span>].<span class="hljs-property">data</span>.<span class="hljs-property">username</span>); <span class="hljs-comment">// &quot;alice&quot;</span></code></pre></div><h3 id="serverSideEmit"><a href="#serverSideEmit" class="headerlink" title="serverSideEmit"></a><code>serverSideEmit</code></h3><p>此方法允许在<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">多服务器设置</a>中向集群的其他 Socket.IO 服务器发出事件。</p><p>语法：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div><p>在接收方：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// prints &quot;world&quot;</span>&#125;);</code></pre></div><p>也支持确认：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, responses</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(responses[<span class="hljs-number">0</span>]); <span class="hljs-comment">// prints &quot;pong&quot;</span>&#125;);<span class="hljs-comment">// server B</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;  <span class="hljs-title function_">cb</span>(<span class="hljs-string">&quot;pong&quot;</span>);&#125;);</code></pre></div><p>笔记：</p><ul><li><code>connection</code>，<code>connect</code> 和 <code>new_namespace</code> 字符串是保留的，不能在您的应用程序中使用。</li><li>您可以发送任意数量的参数，但目前不支持二进制结构（参数数组将被<code>JSON.stringify</code>-ed）</li></ul><p>例子：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-string">&quot;4&quot;</span> &#125;);</code></pre></div><ul><li>如果其他 Socket.IO 服务器在给定延迟后没有响应，则调用确认回调可能会出错</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, responses</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (err) &#123;    <span class="hljs-comment">// at least one Socket.IO server has not responded</span>    <span class="hljs-comment">// the &#x27;responses&#x27; array contains all the responses already received though</span>  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// success! the &#x27;responses&#x27; array contains one object per other Socket.IO server in the cluster</span>  &#125;&#125;);</code></pre></div><h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><p>Server 实例发出一个事件（好吧，从技术上讲是两个，但<code>connect</code>它是<code>connection</code>的别名）：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/server-instance/#connection"><code>connection</code></a></li></ul><h3 id="connection"><a href="#connection" class="headerlink" title="connection"></a><code>connection</code></h3><p>此事件在新连接时触发。第一个参数是一个<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/">Socket实例</a>.</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h1 id="Socket-实例（服务器端）"><a href="#Socket-实例（服务器端）" class="headerlink" title="Socket 实例（服务器端）"></a>Socket 实例（服务器端）</h1><p><code>Socket</code>是与客户端交互的基础类。它继承了 Node.js<a href="https://nodejs.org/api/events.html#class-eventemitter">EventEmitter</a>的所有方法，例如<a href="https://socket.io/zh-CN/docs/v4/server-api/#socketemiteventname-args">emit</a>, <a href="https://socket.io/zh-CN/docs/v4/server-api/#socketoneventname-callback">on</a>, <a href="https://socket.io/zh-CN/docs/v4/server-api/#socketonceeventname-listener">once</a> 或 <a href="https://socket.io/zh-CN/docs/v4/server-api/#socketremovelistenereventname-listener">removeListener</a>.</p><p><img src="https://socket.io/zh-CN/images/bidirectional-communication-socket.png" alt="Bidirectional communication between server and client"></p><p>除了：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/emitting-events/#basic-emit">发出</a> 和 <a href="https://socket.io/zh-CN/docs/v4/listening-to-events/">监听</a> 事件</li><li><a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients-except-the-sender">广播事件</a></li><li><a href="https://socket.io/zh-CN/docs/v4/rooms/#joining-and-leaving">加入和离开房间</a></li></ul><p>Socket 实例有一些可能在您的应用程序中使用的属性：</p><h2 id="Socket-id"><a href="#Socket-id" class="headerlink" title="Socket#id"></a>Socket#id</h2><p>每个新连接都分配有一个随机的 20 个字符的标识符。</p><p>此标识符与客户端的值同步。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// ojIckSD2jqNzOqIrAGzL</span>&#125;);<span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// ojIckSD2jqNzOqIrAGzL</span>&#125;);</code></pre></div><p>创建后，Socket 会加入由其自己的 id 标识的房间，这意味着您可以将其用于私人消息传递：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;private message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">anotherSocketId, msg</span>) =&gt;</span> &#123;    socket.<span class="hljs-title function_">to</span>(anotherSocketId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;private message&quot;</span>, socket.<span class="hljs-property">id</span>, msg);  &#125;);&#125;);</code></pre></div><p>注意：您不能覆盖此标识符，因为它在 Socket.IO 代码库的多个部分中使用。</p><h2 id="Socket-handshake"><a href="#Socket-handshake" class="headerlink" title="Socket#handshake"></a>Socket#handshake</h2><p>此对象包含有关在 Socket.IO 会话开始时发生的握手的一些详细信息。</p><div class="code-wrapper"><pre><code class="hljs text">&#123;  headers: /* the headers of the initial request */  query: /* the query params of the initial request */  auth: /* the authentication payload */  time: /* the date of creation (as string) */  issued: /* the date of creation (unix timestamp) */  url: /* the request URL string */  address: /* the ip of the client */  xdomain: /* whether the connection is cross-domain */  secure: /* whether the connection is secure */&#125;</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;headers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;user-agent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxx&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;accept&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*/*&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;example.com&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;connection&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;close&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;EIO&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;transport&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;polling&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;t&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NNjNltH&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;issued&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1606005226969</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/socket.io/?EIO=4&amp;transport=polling&amp;t=NNjNltH&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;::ffff:1.2.3.4&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;xdomain&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;secure&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="Socket-rooms"><a href="#Socket-rooms" class="headerlink" title="Socket#rooms"></a>Socket#rooms</h2><p>这是对 Socket 当前所在<a href="https://socket.io/zh-CN/docs/v4/rooms/">房间</a>的引用。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// Set &#123; &lt;socket.id&gt; &#125;</span>  socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;room1&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// Set &#123; &lt;socket.id&gt;, &quot;room1&quot; &#125;</span>&#125;);</code></pre></div><h2 id="Socket-data"><a href="#Socket-data" class="headerlink" title="Socket#data"></a>Socket#data</h2><p>可以与<code>fetchSockets()</code>实用程序方法结合使用的任意对象：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-property">data</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;alice&quot;</span>;&#125;);<span class="hljs-comment">// server B</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sockets[<span class="hljs-number">0</span>].<span class="hljs-property">data</span>.<span class="hljs-property">username</span>); <span class="hljs-comment">// &quot;alice&quot;</span></code></pre></div><h2 id="Socket-conn"><a href="#Socket-conn" class="headerlink" title="Socket#conn"></a>Socket#conn</h2><p>对底层 Engine.IO 套接字的引用（参见<a href="https://socket.io/zh-CN/docs/v4/how-it-works/">此处</a>）。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;initial transport&quot;</span>, socket.<span class="hljs-property">conn</span>.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// prints &quot;polling&quot;</span>  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;upgrade&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;upgraded transport&quot;</span>, socket.<span class="hljs-property">conn</span>.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// prints &quot;websocket&quot;</span>  &#125;);  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packet&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called for each packet received</span>  &#125;);  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packetCreate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called for each packet sent</span>  &#125;);  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;drain&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// called when the write buffer is drained</span>  &#125;);  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called when the underlying connection is closed</span>  &#125;);&#125;);</code></pre></div><h2 id="Additional-attributes"><a href="#Additional-attributes" class="headerlink" title="Additional attributes"></a>Additional attributes</h2><p>只要您不覆盖任何现有属性，您就可以将任何属性附加到 Socket 实例并在以后使用它：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// in a middleware</span>io.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (socket, next) =&gt; &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(socket);    socket.<span class="hljs-property">user</span> = user;  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unknown user&quot;</span>));  &#125;&#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">user</span>);  <span class="hljs-comment">// in a listener</span>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;set username&quot;</span>, <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> &#123;    socket.<span class="hljs-property">username</span> = username;  &#125;);&#125;);</code></pre></div><h2 id="Socket-middlewares"><a href="#Socket-middlewares" class="headerlink" title="Socket middlewares"></a>Socket middlewares</h2><p>这些中间件看起来很像通常的<a href="https://socket.io/zh-CN/docs/v4/middlewares/">中间价</a>，除了它们是为每个传入的数据包调用的：</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">[event, ...args], next</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something with the packet (logging, authorization, rate limiting...)</span>  <span class="hljs-comment">// do not forget to call next() at the end</span>  <span class="hljs-title function_">next</span>();&#125;);</code></pre></div><p>复制</p><p><code>next</code>也可以使用错误对象调用该方法。在这种情况下，事件将不会到达注册的事件处理程序，而<code>error</code>是会发出一个事件：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">[event, ...args], next</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUnauthorized</span>(event)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unauthorized event&quot;</span>));    &#125;    <span class="hljs-title function_">next</span>();  &#125;);  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err &amp;&amp; err.<span class="hljs-property">message</span> === <span class="hljs-string">&quot;unauthorized event&quot;</span>) &#123;      socket.<span class="hljs-title function_">disconnect</span>();    &#125;  &#125;);&#125;);</code></pre></div><p>复制</p><p>注意：此功能仅存在于服务器端。对于客户端，您可能对<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#catch-all-listeners">catch-all listeners</a>感兴趣。</p><h2 id="Events-1"><a href="#Events-1" class="headerlink" title="Events"></a>Events<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#events"></a></h2><p>在服务器端，Socket 实例发出两个特殊事件：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnect"><code>disconnect</code></a></li><li><a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnecting"><code>disconnecting</code></a></li></ul><h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a><code>disconnect</code><a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnect"></a></h3><p>此事件由 Socket 实例在断开连接时触发。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...</span>  &#125;);&#125;);</code></pre></div><p>复制</p><p>以下是可能的原因列表：</p><table><thead><tr><th>Reason</th><th>Description</th></tr></thead><tbody><tr><td><code>server namespace disconnect</code></td><td>socket被<a href="https://socket.io/zh-CN/docs/v4/server-api/#socketdisconnectclose">socket.disconnect</a>强行断开</td></tr><tr><td><code>client namespace disconnect</code></td><td>客户端使用<a href="https://socket.io/zh-CN/docs/v4/client-api/#socketdisconnect">socket.disconnect()</a>手动断开socket</td></tr><tr><td><code>server shutting down</code></td><td>服务器正在关闭</td></tr><tr><td><code>ping timeout</code></td><td><code>pingTimeout</code> 客户端在延迟中没有发送 PONG 数据包</td></tr><tr><td><code>transport close</code></td><td>连接已关闭（例如：用户失去连接，或网络从 WiFi 更改为 4G）</td></tr><tr><td><code>transport error</code></td><td>连接遇到错误</td></tr></tbody></table><h3 id="disconnecting"><a href="#disconnecting" class="headerlink" title="disconnecting"></a><code>disconnecting</code><a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnecting"></a></h3><p>当<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#socketrooms">Socket#rooms</a>集不为空时，此事件类似于<code>disconnect</code>但更早触发。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnecting&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> room <span class="hljs-keyword">of</span> socket.<span class="hljs-property">rooms</span>) &#123;      <span class="hljs-keyword">if</span> (room !== socket.<span class="hljs-property">id</span>) &#123;        socket.<span class="hljs-title function_">to</span>(room).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;user has left&quot;</span>, socket.<span class="hljs-property">id</span>);      &#125;    &#125;  &#125;);&#125;);</code></pre></div><p>注意：这些事件以及<code>connect</code>, <code>connect_error</code>, <code>newListener</code> 和 <code>removeListener</code>是不应在您的应用程序中使用的特殊事件:</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD, will throw an error</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;disconnect&quot;</span>);</code></pre></div><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件函数是为每个传入连接执行的函数。</p><p>中间件函数可用于：</p><ul><li>logging</li><li>authentication / authorization</li><li>rate limiting</li></ul><p>Note: this function will be executed only once per connection (even if the connection consists in multiple HTTP requests).</p><h2 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h2><p>中间件函数可以访问<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/">Socket 实例</a>和下一个注册的中间件函数。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValid</span>(socket.<span class="hljs-property">request</span>)) &#123;    <span class="hljs-title function_">next</span>();  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;invalid&quot;</span>));  &#125;&#125;);</code></pre></div><p>您可以注册几个中间件函数，它们将按顺序执行：</p><div class="code-wrapper"><pre><code class="hljs moonscript"><span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;  <span class="hljs-built_in">next</span>();&#125;);<span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;  <span class="hljs-built_in">next</span>(new Error(<span class="hljs-string">&quot;thou shall not pass&quot;</span>));//<span class="hljs-built_in">error</span>可以作为参数传递到下一层，其他不可以&#125;);<span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;  // <span class="hljs-keyword">not</span> executed, since the previous middleware has returned an <span class="hljs-built_in">error</span>  <span class="hljs-built_in">next</span>();&#125;);</code></pre></div><p>请确保在任何情况下都调用<code>next（）</code>。 否则，连接将一直挂起，直到在给定超时后关闭。</p><p><strong>重要提示</strong>：执行中间件时，Socket 实例实际上并未连接，这意味着<code>disconnect</code>如果连接最终失败，则不会发出任何事件。</p><p>例如，如果客户端手动关闭连接：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// next is called after the client disconnection</span>    <span class="hljs-title function_">next</span>();  &#125;, <span class="hljs-number">1000</span>);  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// not triggered</span>  &#125;);&#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// not triggered</span>&#125;);<span class="hljs-comment">// client-side</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>();<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  socket.<span class="hljs-title function_">disconnect</span>();&#125;, <span class="hljs-number">500</span>);</code></pre></div><h2 id="发送凭据"><a href="#发送凭据" class="headerlink" title="发送凭据"></a>发送凭据</h2><p><code>auth</code>客户端可以使用以下选项发送凭据：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// plain object</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;  <span class="hljs-attr">auth</span>: &#123;    <span class="hljs-attr">token</span>: <span class="hljs-string">&quot;abc&quot;</span>  &#125;&#125;);<span class="hljs-comment">// or with a function</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;  <span class="hljs-attr">auth</span>: <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;    <span class="hljs-title function_">cb</span>(&#123;      <span class="hljs-attr">token</span>: <span class="hljs-string">&quot;abc&quot;</span>    &#125;);  &#125;&#125;);</code></pre></div><p>可以在服务器端的<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#sockethandshake">握手</a>对象中访问这些凭据：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> token = socket.<span class="hljs-property">handshake</span>.<span class="hljs-property">auth</span>.<span class="hljs-property">token</span>;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h2 id="处理中间件错误"><a href="#处理中间件错误" class="headerlink" title="处理中间件错误"></a>处理中间件错误</h2><p>如果<code>next</code>使用 Error 对象调用该方法，则连接将被拒绝并且客户端将收到一个<code>connect_error</code>事件。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// prints the message associated with the error</span>&#125;);</code></pre></div><p>您可以将其他详细信息附加到错误对象：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;not authorized&quot;</span>);  err.<span class="hljs-property">data</span> = &#123; <span class="hljs-attr">content</span>: <span class="hljs-string">&quot;Please retry later&quot;</span> &#125;; <span class="hljs-comment">// additional details</span>  <span class="hljs-title function_">next</span>(err);&#125;);<span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>); <span class="hljs-comment">// true</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// not authorized</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">data</span>); <span class="hljs-comment">// &#123; content: &quot;Please retry later&quot; &#125;</span>&#125;);</code></pre></div><h2 id="与Express中间件的兼容性"><a href="#与Express中间件的兼容性" class="headerlink" title="与Express中间件的兼容性"></a>与Express中间件的兼容性</h2><p>大多数现有的<a href="http://expressjs.com/en/resources/middleware.html">Express 中间件</a>模块应该与 Socket.IO 兼容，您只需要一个小包装函数来使方法签名匹配：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = middleware =&gt; <span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> <span class="hljs-title function_">middleware</span>(socket.<span class="hljs-property">request</span>, &#123;&#125;, next);</code></pre></div><p>复制</p><p>结束请求-响应周期并且不调用的中间件函数<code>next()</code>将不起作用。</p><p><a href="https://www.npmjs.com/package/express-session">express-session</a>示例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(<span class="hljs-title function_">session</span>(&#123; <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;cats&quot;</span> &#125;)));io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> session = socket.<span class="hljs-property">request</span>.<span class="hljs-property">session</span>;&#125;);</code></pre></div><p><a href="http://www.passportjs.org/">Passport</a>示例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);<span class="hljs-keyword">const</span> passport = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;passport&quot;</span>);io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(<span class="hljs-title function_">session</span>(&#123; <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;cats&quot;</span> &#125;)));io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(passport.<span class="hljs-title function_">initialize</span>()));io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(passport.<span class="hljs-title function_">session</span>()));io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">request</span>.<span class="hljs-property">user</span>) &#123;    <span class="hljs-title function_">next</span>();  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unauthorized&quot;</span>))  &#125;&#125;);</code></pre></div><p>可以在<a href="https://github.com/socketio/socket.io/tree/master/examples/passport-example">此处</a>找到 Passport 的完整示例。</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>您将在下面找到在反向代理解决方案后面部署 Socket.IO 服务器所需的配置，例如：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nginx">NginX</a></li><li><a href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#apache-httpd">Apache HTTPD</a></li><li><a href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nodejs-http-proxy">Node.js <code>http-proxy</code></a></li></ul><p>在多服务器设置中，请查看<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">此处</a>的文档。</p><h2 id="NginX"><a href="#NginX" class="headerlink" title="NginX"></a>NginX</h2><p><code>/etc/nginx/nginx.conf</code>内容：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;  <span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> example.com;    <span class="hljs-section">location</span> / &#123;      <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;      <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;      <span class="hljs-attribute">proxy_pass</span> http://localhost:3000;      <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;      <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;      <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;    &#125;  &#125;&#125;</code></pre></div><p>有关的：</p><ul><li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass">proxy_pass 稳定</a></li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#nginx-configuration">多服务器设置中的配置</a></li></ul><p>如果您只想转发 Socket.IO 请求（例如当 NginX 处理静态内容时）：</p><div class="code-wrapper"><pre><code class="hljs text">http &#123;  server &#123;    listen 80;    root /var/www/html;    location /socket.io/ &#123;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection &quot;upgrade&quot;;    &#125;  &#125;&#125;</code></pre></div><p>或使用自定义<a href="https://socket.io/zh-CN/docs/v4/server-options/#path">路径</a>:</p><div class="code-wrapper"><pre><code class="hljs text">http &#123;  server &#123;    listen 80;    root /var/www/html;    location /my-custom-path/ &#123;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection &quot;upgrade&quot;;    &#125;  &#125;&#125;</code></pre></div><p>在这种情况下，必须相应地配置服务器和客户端：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123;  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/my-custom-path/&quot;</span>&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/my-custom-path/&quot;</span>&#125;);</code></pre></div><h2 id="Apache-HTTPD"><a href="#Apache-HTTPD" class="headerlink" title="Apache HTTPD"></a>Apache HTTPD</h2><p><code>/usr/local/apache2/conf/httpd.conf</code>内容：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Listen</span> <span class="hljs-number">80</span><span class="hljs-attribute">ServerName</span> example.com<span class="hljs-attribute">LoadModule</span> mpm_event_module             modules/mod_mpm_event.so<span class="hljs-attribute">LoadModule</span> authn_file_module            modules/mod_authn_file.so<span class="hljs-attribute">LoadModule</span> authn_core_module            modules/mod_authn_core.so<span class="hljs-attribute">LoadModule</span> authz_host_module            modules/mod_authz_host.so<span class="hljs-attribute">LoadModule</span> authz_groupfile_module       modules/mod_authz_groupfile.so<span class="hljs-attribute">LoadModule</span> authz_user_module            modules/mod_authz_user.so<span class="hljs-attribute">LoadModule</span> authz_core_module            modules/mod_authz_core.so<span class="hljs-attribute">LoadModule</span> headers_module               modules/mod_headers.so<span class="hljs-attribute">LoadModule</span> lbmethod_byrequests_module   modules/mod_lbmethod_byrequests.so<span class="hljs-attribute">LoadModule</span> proxy_module                 modules/mod_proxy.so<span class="hljs-attribute">LoadModule</span> proxy_balancer_module        modules/mod_proxy_balancer.so<span class="hljs-attribute">LoadModule</span> proxy_http_module            modules/mod_proxy_http.so<span class="hljs-attribute">LoadModule</span> proxy_wstunnel_module        modules/mod_proxy_wstunnel.so<span class="hljs-attribute">LoadModule</span> rewrite_module               modules/mod_rewrite.so<span class="hljs-attribute">LoadModule</span> slotmem_shm_module           modules/mod_slotmem_shm.so<span class="hljs-attribute">LoadModule</span> unixd_module                 modules/mod_unixd.so<span class="hljs-attribute">User</span> daemon<span class="hljs-attribute">Group</span> daemon<span class="hljs-attribute">ProxyPass</span> / http://localhost:<span class="hljs-number">3000</span>/<span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">on</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> websocket<span class="hljs-meta"> [NC]</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Connection&#125;</span> upgrade<span class="hljs-meta"> [NC]</span><span class="hljs-attribute">RewriteRule</span> ^/?(.*) <span class="hljs-string">&quot;ws://localhost:3000/$1&quot;</span><span class="hljs-meta"> [P,L]</span><span class="hljs-attribute">ProxyTimeout</span> <span class="hljs-number">3</span></code></pre></div><p>有关的：</p><ul><li><a href="https://httpd.apache.org/docs/2.4/en/mod/mod_proxy_wstunnel.html">mod_proxy_wstunnel 文档</a></li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration">多服务器设置中的配置</a></li></ul><h2 id="Node-js-http-proxy"><a href="#Node-js-http-proxy" class="headerlink" title="Node.js http-proxy"></a>Node.js <code>http-proxy</code><a href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nodejs-http-proxy"></a></h2><p>安装： <code>npm i http-proxy</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> httpProxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http-proxy&quot;</span>);httpProxy  .<span class="hljs-title function_">createProxyServer</span>(&#123;    <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,    <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,  &#125;)  .<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>);</code></pre></div><p>复制</p><p><a href="https://github.com/http-party/node-http-proxy#readme">Documentation</a></p><h2 id="Caddy-2"><a href="#Caddy-2" class="headerlink" title="Caddy 2"></a>Caddy 2</h2><p><a href="https://caddyserver.com/v2">Caddy 2</a>中<code>Caddyfile</code>的内容</p><div class="code-wrapper"><pre><code class="hljs text">example.com &#123;  rewrite /path /path/  handle /path/* &#123;    uri strip_prefix /path    rewrite * /socket.io&#123;path&#125;    reverse_proxy localhost:3000 &#123;      header_up Host &#123;host&#125;      header_up X-Real-IP &#123;remote&#125;    &#125;  &#125;&#125;</code></pre></div><p>有关的：</p><ul><li><a href="https://caddy.community/t/i-cant-get-socket-io-proxy-to-work-on-v2/8703/2">解决方案论坛帖子</a></li><li><a href="https://caddyserver.com/docs/caddyfile/directives">Caddyfile 指令</a></li></ul><h1 id="使用多个节点"><a href="#使用多个节点" class="headerlink" title="使用多个节点"></a>使用多个节点</h1><p>部署多个 Socket.IO 服务器时，需要注意两件事：</p><ul><li>如果启用了 HTTP 长轮询（这是默认设置），则启用粘性会话：见<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#enabling-sticky-session">下文</a></li><li>使用兼容的适配器，请参见<a href="https://socket.io/zh-CN/docs/v4/adapter/">此处</a></li></ul><h2 id="粘性负载平衡"><a href="#粘性负载平衡" class="headerlink" title="粘性负载平衡"></a>粘性负载平衡</h2><p>如果您计划在不同的进程或机器之间分配连接负载，则必须确保与特定会话 ID 关联的所有请求都到达发起它们的进程。</p><h3 id="为什么需要粘性会话"><a href="#为什么需要粘性会话" class="headerlink" title="为什么需要粘性会话"></a>为什么需要粘性会话</h3><p>这是因为 HTTP 长轮询传输在 Socket.IO 会话的生命周期内发送多个 HTTP 请求。</p><p>事实上，Socket.IO 在技术上可以在没有粘性会话的情况下工作，具有以下同步（虚线）：</p><p><img src="https://socket.io/zh-CN/assets/images/mutiple-nodes-no-sticky-babd7860f217e09eefc2db73e5012f91.png" alt="Using multiple nodes without sticky sessions"></p><p>虽然显然可以实现，但我们认为 Socket.IO 服务器之间的这种同步过程会对您的应用程序造成很大的性能影响。</p><p>评论：</p><ul><li>如果不启用粘性会话，由于“会话 ID 未知”，您将遇到 HTTP 400 错误</li><li>WebSocket 传输没有这个限制，因为它依赖于整个会话的单个 TCP 连接。这意味着如果您禁用 HTTP 长轮询传输，您将不需要粘性会话：</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://io.yourhost.com&quot;</span>, &#123;  <span class="hljs-comment">// WARNING: in that case, there is no fallback to long-polling</span>  <span class="hljs-attr">transports</span>: [ <span class="hljs-string">&quot;websocket&quot;</span> ] <span class="hljs-comment">// or [ &quot;websocket&quot;, &quot;polling&quot; ] (the order matters)</span>&#125;);</code></pre></div><p>文档：<a href="https://socket.io/zh-CN/docs/v4/client-options/#transports"><code>transports</code></a></p><h3 id="启用粘性会话的方式"><a href="#启用粘性会话的方式" class="headerlink" title="启用粘性会话的方式"></a>启用粘性会话的方式</h3><p>要实现粘性会话，主要有两种解决方案：</p><ul><li>基于 cookie 路由客户端（推荐解决方案）</li><li>根据客户端的原始地址路由客户端</li></ul><p>您将在下面找到一些常见负载平衡解决方案的示例：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#nginx-configuration">NginX</a> (基于IP)</li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration">Apache HTTPD</a> (基于cookie)</li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#haproxy-configuration">HAProxy</a> (基于cookie)</li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#traefik">Traefik</a> (基于cookie)</li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#using-nodejs-cluster">Node.js <code>cluster</code> module</a></li></ul><p><strong>重要提示</strong>：如果您处于 CORS 情况（前端域与服务器域不同）并且会话亲和性是通过 cookie 实现的，则需要允许凭据：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>)(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://front-domain.com&quot;</span>,    <span class="hljs-attr">methods</span>: [<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>],    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>  &#125;&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io-client&quot;</span>);<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>, &#123;  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>&#125;);</code></pre></div><p>没有它，浏览器将不会发送 cookie，您将遇到 HTTP 400“会话 ID 未知”响应。更多信息<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">在这里</a>.</p><h3 id="NginX-配置"><a href="#NginX-配置" class="headerlink" title="NginX 配置"></a>NginX 配置</h3><p>在文件的<code>http &#123; &#125;</code>部分中<code>nginx.conf</code>，您可以声明一个<code>upstream</code>包含要平衡负载的 Socket.IO 进程列表的部分：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;  <span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">3000</span>;    <span class="hljs-attribute">server_name</span> io.yourhost.com;    <span class="hljs-section">location</span> / &#123;      <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;      <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;      <span class="hljs-attribute">proxy_pass</span> http://nodes;      <span class="hljs-comment"># enable WebSockets</span>      <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;      <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;      <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;    &#125;  &#125;  <span class="hljs-section">upstream</span> nodes &#123;    <span class="hljs-comment"># enable sticky session with either &quot;hash&quot; (uses the complete IP address)</span>    <span class="hljs-attribute">hash</span> <span class="hljs-variable">$remote_addr</span> consistent;    <span class="hljs-comment"># or &quot;ip_hash&quot; (uses the first three octets of the client IPv4 address, or the entire IPv6 address)</span>    <span class="hljs-comment"># ip_hash;</span>    <span class="hljs-comment"># or &quot;sticky&quot; (needs commercial subscription)</span>    <span class="hljs-comment"># sticky cookie srv_id expires=1h domain=.example.com path=/;</span>    <span class="hljs-attribute">server</span> app01:<span class="hljs-number">3000</span>;    <span class="hljs-attribute">server</span> app02:<span class="hljs-number">3000</span>;    <span class="hljs-attribute">server</span> app03:<span class="hljs-number">3000</span>;  &#125;&#125;</code></pre></div><p>请注意<code>hash</code>指示连接将是粘性的说明。</p><p>确保您还在<code>worker_processes</code>最顶层配置以指示 NginX 应该使用多少工作人员。您可能还想研究调整块<code>worker_connections</code>内的设置<code>events &#123; &#125;</code>。</p><h3 id="Apache-HTTPD-配置"><a href="#Apache-HTTPD-配置" class="headerlink" title="Apache HTTPD 配置"></a>Apache HTTPD 配置<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration"></a></h3><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Header</span> add Set-Cookie <span class="hljs-string">&quot;SERVERID=sticky.%&#123;BALANCER_WORKER_ROUTE&#125;e; path=/&quot;</span> env=BALANCER_ROUTE_CHANGED<span class="hljs-section">&lt;Proxy <span class="hljs-string">&quot;balancer://nodes_polling&quot;</span>&gt;</span>    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app01:3000&quot;</span> route=app01    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app02:3000&quot;</span> route=app02    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app03:3000&quot;</span> route=app03    <span class="hljs-attribute">ProxySet</span> stickysession=SERVERID<span class="hljs-section">&lt;/Proxy&gt;</span><span class="hljs-section">&lt;Proxy <span class="hljs-string">&quot;balancer://nodes_ws&quot;</span>&gt;</span>    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app01:3000&quot;</span> route=app01    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app02:3000&quot;</span> route=app02    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app03:3000&quot;</span> route=app03    <span class="hljs-attribute">ProxySet</span> stickysession=SERVERID<span class="hljs-section">&lt;/Proxy&gt;</span><span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">On</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> =websocket<span class="hljs-meta"> [NC]</span><span class="hljs-attribute">RewriteRule</span> /(.*) balancer://nodes_ws/$<span class="hljs-number">1</span><span class="hljs-meta"> [P,L]</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> !=websocket<span class="hljs-meta"> [NC]</span><span class="hljs-attribute">RewriteRule</span> /(.*) balancer://nodes_polling/$<span class="hljs-number">1</span><span class="hljs-meta"> [P,L]</span><span class="hljs-attribute">ProxyTimeout</span> <span class="hljs-number">3</span></code></pre></div><p>链接：</p><ul><li><a href="https://github.com/socketio/socket.io/tree/master/examples/cluster-httpd">例子</a></li><li><a href="https://httpd.apache.org/docs/2.4/en/mod/mod_proxy.html#proxypass">文档</a></li></ul><h3 id="HAProxy-配置"><a href="#HAProxy-配置" class="headerlink" title="HAProxy 配置"></a>HAProxy 配置</h3><div class="code-wrapper"><pre><code class="hljs text"># Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/listen chat  bind *:80  default_backend nodesbackend nodes  option httpchk HEAD /health  http-check expect status 200  cookie io prefix indirect nocache # using the `io` cookie set upon handshake  server app01 app01:3000 check cookie app01  server app02 app02:3000 check cookie app02  server app03 app03:3000 check cookie app03</code></pre></div><p>链接：</p><ul><li><a href="https://github.com/socketio/socket.io/tree/master/examples/cluster-haproxy">例子</a></li><li><a href="http://cbonte.github.io/haproxy-dconv/2.4/configuration.html#cookie">文档</a></li></ul><h3 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h3><p>使用容器标签：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># docker-compose.yml</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">traefik:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">traefik:2.4</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span>    <span class="hljs-attr">links:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">server</span>  <span class="hljs-attr">server:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:latest</span>    <span class="hljs-attr">labels:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.http.routers.my-service.rule=PathPrefix(`/`)&quot;</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true</span></code></pre></div><p>使用<a href="https://doc.traefik.io/traefik/v2.0/providers/file/">文件提供程序</a>：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">## Dynamic configuration</span><span class="hljs-attr">http:</span>  <span class="hljs-attr">services:</span>    <span class="hljs-attr">my-service:</span>      <span class="hljs-attr">rule:</span> <span class="hljs-string">&quot;PathPrefix(`/`)&quot;</span>      <span class="hljs-attr">loadBalancer:</span>        <span class="hljs-attr">sticky:</span>          <span class="hljs-attr">cookie:</span>            <span class="hljs-attr">name:</span> <span class="hljs-string">server_id</span>            <span class="hljs-attr">httpOnly:</span> <span class="hljs-literal">true</span></code></pre></div><p>链接：</p><ul><li><a href="https://github.com/socketio/socket.io/tree/master/examples/cluster-traefik">例子</a></li><li><a href="https://doc.traefik.io/traefik/v2.0/routing/services/#sticky-sessions">文档</a></li></ul><h3 id="使用-Node-js-集群"><a href="#使用-Node-js-集群" class="headerlink" title="使用 Node.js 集群"></a>使用 Node.js 集群</h3><p>就像 NginX 一样，Node.js 通过<code>cluster</code>模块提供了内置的集群支持。</p><p>有几种解决方案，具体取决于您的用例：</p><table><thead><tr><th>NPM 包</th><th>这个怎么运作</th></tr></thead><tbody><tr><td><a href="https://github.com/darrachequesne/socket.io-sticky"><code>@socket.io/sticky</code></a></td><td>路由基于<code>sid</code>查询参数</td></tr><tr><td><a href="https://github.com/indutny/sticky-session"><code>sticky-session</code></a></td><td>路由是基于<code>connection.remoteAddress</code></td></tr><tr><td><a href="https://github.com/wzrdtales/socket-io-sticky-session"><code>socketio-sticky-session</code></a></td><td>基于<code>x-forwarded-for</code>报头的路由）</td></tr></tbody></table><p>示例<code>@socket.io/sticky</code>:</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cluster&quot;</span>);<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Server</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>);<span class="hljs-keyword">const</span> numCPUs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;os&quot;</span>).<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> &#123; setupMaster, setupWorker &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/sticky&quot;</span>);<span class="hljs-keyword">const</span> &#123; createAdapter, setupPrimary &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/cluster-adapter&quot;</span>);<span class="hljs-keyword">if</span> (cluster.<span class="hljs-property">isMaster</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Master <span class="hljs-subst">$&#123;process.pid&#125;</span> is running`</span>);  <span class="hljs-keyword">const</span> httpServer = http.<span class="hljs-title function_">createServer</span>();  <span class="hljs-comment">// setup sticky sessions</span>  <span class="hljs-title function_">setupMaster</span>(httpServer, &#123;    <span class="hljs-attr">loadBalancingMethod</span>: <span class="hljs-string">&quot;least-connection&quot;</span>,  &#125;);  <span class="hljs-comment">// setup connections between the workers</span>  <span class="hljs-title function_">setupPrimary</span>();  <span class="hljs-comment">// needed for packets containing buffers (you can ignore it if you only send plaintext objects)</span>  <span class="hljs-comment">// Node.js &lt; 16.0.0</span>  cluster.<span class="hljs-title function_">setupMaster</span>(&#123;    <span class="hljs-attr">serialization</span>: <span class="hljs-string">&quot;advanced&quot;</span>,  &#125;);  <span class="hljs-comment">// Node.js &gt; 16.0.0</span>  <span class="hljs-comment">// cluster.setupPrimary(&#123;</span>  <span class="hljs-comment">//   serialization: &quot;advanced&quot;,</span>  <span class="hljs-comment">// &#125;);</span>  httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numCPUs; i++) &#123;    cluster.<span class="hljs-title function_">fork</span>();  &#125;  cluster.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-function">(<span class="hljs-params">worker</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Worker <span class="hljs-subst">$&#123;worker.process.pid&#125;</span> died`</span>);    cluster.<span class="hljs-title function_">fork</span>();  &#125;);&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Worker <span class="hljs-subst">$&#123;process.pid&#125;</span> started`</span>);  <span class="hljs-keyword">const</span> httpServer = http.<span class="hljs-title function_">createServer</span>();  <span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer);  <span class="hljs-comment">// use the cluster adapter</span>  io.<span class="hljs-title function_">adapter</span>(<span class="hljs-title function_">createAdapter</span>());  <span class="hljs-comment">// setup connection with the primary process</span>  <span class="hljs-title function_">setupWorker</span>(io);  io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;    <span class="hljs-comment">/* ... */</span>  &#125;);&#125;</code></pre></div><h2 id="在节点之间传递事件"><a href="#在节点之间传递事件" class="headerlink" title="在节点之间传递事件"></a>在节点之间传递事件</h2><p>既然您有多个接受连接的Socket.IO 节点，如果您想向所有客户端（或某个<a href="https://socket.io/zh-CN/docs/v4/rooms/">房间</a>中的客户端）广播事件，您将需要某种方式在进程或计算机之间传递消息。</p><p>负责路由消息的接口就是我们所说的<a href="https://socket.io/zh-CN/docs/v4/adapter/">Adapter</a>。</p><h1 id="处理-CORS"><a href="#处理-CORS" class="headerlink" title="处理 CORS"></a>处理 CORS</h1><p>从 Socket.IO v3 开始，您需要显式启用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">跨域资源共享</a>(CORS)。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://example.com&quot;</span>  &#125;&#125;);</code></pre></div><p>所有选项都将转发到<a href="https://www.npmjs.com/package/cors">cors</a>包。可以在<a href="https://github.com/expressjs/cors#configuration-options">此处</a>找到完整的选项列表。</p><p>带有 cookie ( <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">withCredentials</a>) 和附加标头的示例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span><span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://example.com&quot;</span>,    <span class="hljs-attr">allowedHeaders</span>: [<span class="hljs-string">&quot;my-custom-header&quot;</span>],    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>  &#125;&#125;);<span class="hljs-comment">// client-side</span><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://api.example.com&quot;</span>, &#123;  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">extraHeaders</span>: &#123;    <span class="hljs-string">&quot;my-custom-header&quot;</span>: <span class="hljs-string">&quot;abcd&quot;</span>  &#125;&#125;);</code></pre></div><p>注意：如果您的 Web 应用程序和服务器不是从同一个端口提供服务，这也适用于 localhost</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;http://localhost:8080&quot;</span>  &#125;&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p>您可以使用以下选项禁止所有跨域请求<a href="https://socket.io/zh-CN/docs/v4/server-options/#allowrequest"><code>allowRequest</code></a> option:</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">allowRequest</span>: <span class="hljs-function">(<span class="hljs-params">req, callback</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> noOriginHeader = req.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span> === <span class="hljs-literal">undefined</span>;    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, noOriginHeader);  &#125;&#125;);</code></pre></div><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#troubleshooting"></a></h2><h3 id="缺少-CORS-标头“Access-Control-Allow-Origin”"><a href="#缺少-CORS-标头“Access-Control-Allow-Origin”" class="headerlink" title="缺少 CORS 标头“Access-Control-Allow-Origin”"></a>缺少 CORS 标头“Access-Control-Allow-Origin”<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#cors-header-access-control-allow-origin-missing"></a></h3><p>完整的错误信息：</p><blockquote><p><em>跨域请求被阻止：同源策略不允许读取位于 …/socket.io/?EIO=4&amp;transport=polling&amp;t=NMnp2WI 的远程资源。（原因：缺少 CORS 标头“Access-Control-Allow-Origin”）。</em></p></blockquote><p>如果您已正确配置您的服务器（见<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#configuration">上文</a>），这可能意味着您的浏览器无法访问 Socket.IO 服务器。</p><p>以下命令：</p><div class="code-wrapper"><pre><code class="hljs text">curl &quot;https://api.example.com/socket.io/?EIO=4&amp;transport=polling&quot;</code></pre></div><p>应该返回类似：</p><div class="code-wrapper"><pre><code class="hljs text">0&#123;&quot;sid&quot;:&quot;Lbo5JLzTotvW3g2LAAAA&quot;,&quot;upgrades&quot;:[&quot;websocket&quot;],&quot;pingInterval&quot;:25000,&quot;pingTimeout&quot;:20000&#125;</code></pre></div><p>如果不是这种情况，请检查您的服务器是否正在侦听并且实际上可以在给定端口上访问。</p><h3 id="如果-CORS-标头“Access-Control-Allow-Origin”为“-”，则不支持凭据"><a href="#如果-CORS-标头“Access-Control-Allow-Origin”为“-”，则不支持凭据" class="headerlink" title="如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭据"></a>如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭据<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#credential-is-not-supported-if-the-cors-header-access-control-allow-origin-is-"></a></h3><p>完整的错误信息：</p><blockquote><p><em>跨域请求被阻止：同源策略不允许读取位于“…/socket.io/?EIO=4&amp;transport=polling&amp;t=NvQfU77”的远程资源。（原因：如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭证）</em></p></blockquote><p>您不能同时设置<a href="https://socket.io/zh-CN/docs/v4/client-options/#withcredentials"><code>withCredentials</code></a> 为 <code>true</code> 和 <code>origin: *</code>，您需要使用特定的来源：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://my-frontend.com&quot;</span>,    <span class="hljs-comment">// or with an array of origins</span>    <span class="hljs-comment">// origin: [&quot;https://my-frontend.com&quot;, &quot;https://my-other-frontend.com&quot;, &quot;http://localhost:3000&quot;],</span>    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>  &#125;&#125;);</code></pre></div><h3 id="CORS-标头“Access-Control-Allow-Credentials”中预期为“true”"><a href="#CORS-标头“Access-Control-Allow-Credentials”中预期为“true”" class="headerlink" title="CORS 标头“Access-Control-Allow-Credentials”中预期为“true”"></a>CORS 标头“Access-Control-Allow-Credentials”中预期为“true”<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#expected-true-in-cors-header-access-control-allow-credentials"></a></h3><p>完整的错误信息：</p><blockquote><p><em>跨域请求被阻止：同源策略不允许读取位于 …/socket.io/?EIO=4&amp;transport=polling&amp;t=NvQny19 的远程资源。（原因：CORS 标头“Access-Control-Allow-Credentials”中预期为“true”）</em></p></blockquote><p>在这种情况下，在客户端上<a href="https://socket.io/zh-CN/docs/v4/client-options/#withcredentials"><code>withCredentials</code></a>设置为<code>true</code>，但服务器缺少选项<code>credentials</code>中的属性<a href="https://socket.io/zh-CN/docs/v4/server-options/#cors"><code>cors</code></a> 。请参见上面的示例。</p><h1 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h1><p>在下面的示例中，<code>io</code>对象来自：</p><ul><li>使用 <code>&lt;script&gt;</code> 引入</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>复制</p><ul><li>使用 ESM 引入</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://cdn.socket.io/4.3.2/socket.io.esm.min.js&quot;</span>;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>复制</p><ul><li>NPM</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;</code></pre></div><h2 id="来自同一域"><a href="#来自同一域" class="headerlink" title="来自同一域"></a>来自同一域<a href="https://socket.io/zh-CN/docs/v4/client-initialization/#from-the-same-domain"></a></h2><p>如果您的前端与您的服务器在同一个域上提供服务，您可以简单地使用：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>();</code></pre></div><p>服务器 URL 将从 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location">window.location</a>对象中推导出来</p><h2 id="来自不同的域"><a href="#来自不同的域" class="headerlink" title="来自不同的域"></a>来自不同的域<a href="https://socket.io/zh-CN/docs/v4/client-initialization/#from-a-different-domain"></a></h2><p>如果您的前端不是来自与服务器相同的域，则必须传递服务器的 URL。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>);</code></pre></div><p>在这种情况下，请确保在服务器上启用 <a href="https://socket.io/zh-CN/docs/v4/handling-cors/">跨域资源共享 (CORS)</a>。</p><h5 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h5><p>您可以使用<code>https</code> 或 <code>wss</code> (分别为, <code>http</code> 或 <code>ws</code>).</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// the following forms are similar</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>);<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;wss://server-domain.com&quot;</span>);<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;server-domain.com&quot;</span>); <span class="hljs-comment">// only in the browser when the page is served over https (will not work in Node.js)</span></code></pre></div><h2 id="自定义命名空间"><a href="#自定义命名空间" class="headerlink" title="自定义命名空间"></a>自定义命名空间<a href="https://socket.io/zh-CN/docs/v4/client-initialization/#custom-namespace"></a></h2><p>在上面的示例中，客户端将连接到主命名空间。对于大多数用例来说，仅使用主命名空间就足够了，但您可以使用以下命令指定命名空间：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// same origin version</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;/admin&quot;</span>);<span class="hljs-comment">// cross origin version</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com/admin&quot;</span>);</code></pre></div><p>您可以<a href="https://socket.io/zh-CN/docs/v4/namespaces/">在此处</a>找到有关名称空间的更多详细信息。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置<a href="https://socket.io/zh-CN/docs/v4/client-initialization/#options"></a></h2><p>可在<a href="https://socket.io/zh-CN/docs/v4/client-options/">此处</a>找到可用配置的完整列表</p><h1 id="Socket-实例（客户端）"><a href="#Socket-实例（客户端）" class="headerlink" title="Socket 实例（客户端）"></a>Socket 实例（客户端）</h1><p><code>Socket</code>是与服务器交互的基础类。它继承了 Node.js<a href="https://nodejs.org/api/events.html#class-eventemitter">EventEmitter</a>的大部分方法，例如 <a href="https://socket.io/zh-CN/docs/v4/client-api/#socketemiteventname-args">emit</a>, <a href="https://socket.io/zh-CN/docs/v4/client-api/#socketoneventname-callback">on</a>, <a href="https://socket.io/zh-CN/docs/v4/client-api/#socketonceeventname-callback">once</a> 或 <a href="https://socket.io/zh-CN/docs/v4/client-api/#socketoffeventname">off</a>。</p><p><img src="https://socket.io/zh-CN/images/bidirectional-communication-socket.png" alt="Bidirectional communication between server and client"></p><p>除了<a href="https://socket.io/zh-CN/docs/v4/emitting-events/">emitting</a> 和 <a href="https://socket.io/zh-CN/docs/v4/listening-to-events/">listening to</a>事件之外，Socket 实例还有一些可能在您的应用程序中使用的属性：</p><h2 id="Socket-id-1"><a href="#Socket-id-1" class="headerlink" title="Socket#id"></a>Socket#id<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketid"></a></h2><p>每个新连接都分配有一个随机的 20 个字符的标识符。</p><p>此标识符与服务器端的值同步。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// x8WIv7-mJelg7on_ALbx</span>&#125;);<span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// x8WIv7-mJelg7on_ALbx</span>&#125;);socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// undefined</span>&#125;);</code></pre></div><h2 id="Socket-connected"><a href="#Socket-connected" class="headerlink" title="Socket#connected"></a>Socket#connected<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketconnected"></a></h2><p>该属性描述套接字当前是否连接到服务器。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">connected</span>); <span class="hljs-comment">// true</span>&#125;);socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">connected</span>); <span class="hljs-comment">// false</span>&#125;);</code></pre></div><h2 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket#io"></a>Socket#io<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketio"></a></h2><p>对基础<a href="https://socket.io/zh-CN/docs/v4/client-api/#manager">Manager</a>的引用。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> engine = socket.<span class="hljs-property">io</span>.<span class="hljs-property">engine</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(engine.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// in most cases, prints &quot;polling&quot;</span>  engine.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;upgrade&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(engine.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// in most cases, prints &quot;websocket&quot;</span>  &#125;);  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packet&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called for each packet received</span>  &#125;);  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packetCreate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called for each packet sent</span>  &#125;);  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;drain&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// called when the write buffer is drained</span>  &#125;);  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called when the underlying connection is closed</span>  &#125;);&#125;);</code></pre></div><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#lifecycle"></a></h2><p><img src="https://socket.io/images/client_socket_events.png" alt="Lifecycle diagram"></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#events"></a></h2><p>Socket 实例发出三个特殊事件：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect"><code>connect</code></a></li><li><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect-error"><code>connect_error</code></a></li><li><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#disconnect"><code>disconnect</code></a></li></ul><p>请注意，从 Socket.IO v3 开始，Socket 实例不再发出任何与重新连接逻辑相关的事件。您可以直接监听 Manager 实例上的事件：</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;reconnect_attempt&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);socket.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;reconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><p>更多信息可以在<a href="https://socket.io/zh-CN/docs/v4/migrating-from-2-x-to-3-0/#the-socket-instance-will-no-longer-forward-the-events-emitted-by-its-manager">迁移指南</a>中找到</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a><code>connect</code><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect"></a></h3><p>此事件由 Socket 实例在连接<strong>和</strong>重新连接时触发。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><p>请注意，您不应在<code>connect</code>处理程序本身中注册事件处理程序，因为每次 Socket 重新连接时都会注册一个新的处理程序：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;);&#125;);<span class="hljs-comment">// GOOD</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;);</code></pre></div><h3 id="connect-error"><a href="#connect-error" class="headerlink" title="connect_error"></a><code>connect_error</code><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect_error"></a></h3><p>在以下情况下触发此事件：</p><ul><li>低级连接无法建立</li><li>服务器在<a href="https://socket.io/zh-CN/docs/v4/middlewares/">中间件功能</a>中拒绝连接</li></ul><p>在第一种情况下，Socket 会在 <a href="https://socket.io/zh-CN/docs/v4/client-options/#reconnectiondelay">给定的延迟</a>之后自动尝试重新连接。</p><p>在后一种情况下，您需要手动重新连接。您可能需要更新凭据：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// either by directly modifying the `auth` attribute</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  socket.<span class="hljs-property">auth</span>.<span class="hljs-property">token</span> = <span class="hljs-string">&quot;abcd&quot;</span>;  socket.<span class="hljs-title function_">connect</span>();&#125;);<span class="hljs-comment">// or if the `auth` attribute is a function</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;  <span class="hljs-attr">auth</span>: <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;    <span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>));  &#125;&#125;);socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    socket.<span class="hljs-title function_">connect</span>();  &#125;, <span class="hljs-number">1000</span>);&#125;);</code></pre></div><h3 id="disconnect-1"><a href="#disconnect-1" class="headerlink" title="disconnect"></a><code>disconnect</code><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#disconnect"></a></h3><p>此事件在断开连接时触发。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><p>复制</p><p>以下是可能的原因列表：</p><table><thead><tr><th>Reason</th><th>Description</th></tr></thead><tbody><tr><td><code>io server disconnect</code></td><td>服务器已使用<a href="https://socket.io/zh-CN/docs/v4/server-api/#socketdisconnectclose">socket.disconnect()</a>强制断开socket</td></tr><tr><td><code>io client disconnect</code></td><td>使用<a href="https://socket.io/zh-CN/docs/v4/client-api/#socketdisconnect">socket.disconnect()</a>手动断开socket</td></tr><tr><td><code>ping timeout</code></td><td>服务器未在该<code>pingInterval + pingTimeout</code>范围内发送 PING</td></tr><tr><td><code>transport close</code></td><td>连接已关闭（例如：用户失去连接，或网络从 WiFi 更改为 4G）</td></tr><tr><td><code>transport error</code></td><td>连接遇到错误（例如：服务器在 HTTP 长轮询周期中被杀死）</td></tr></tbody></table><p>前两种情况（显式断开），客户端不会尝试重新连接，需要手动调用<code>socket.connect()</code>.</p><p>在所有其他情况下，客户端将等待一个小的<a href="https://socket.io/zh-CN/docs/v4/client-options/#reconnectiondelay">随机延迟</a>，然后尝试重新连接：</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (reason === <span class="hljs-string">&quot;io server disconnect&quot;</span>) &#123;    <span class="hljs-comment">// the disconnection was initiated by the server, you need to reconnect manually</span>    socket.<span class="hljs-title function_">connect</span>();<span class="hljs-comment">//服务器断开的，需要手动执行重连</span>  &#125;  <span class="hljs-comment">// else the socket will automatically try to reconnect</span>&#125;);</code></pre></div><p>注意：这些事件以及<code>disconnecting</code>, <code>newListener</code> 和 <code>removeListener</code>是不应在您的应用程序中使用的特殊事件：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD, will throw an error</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;disconnect&quot;</span>);</code></pre></div><h1 id="离线行为"><a href="#离线行为" class="headerlink" title="离线行为"></a>离线行为</h1><h2 id="缓冲事件"><a href="#缓冲事件" class="headerlink" title="缓冲事件"></a>缓冲事件<a href="https://socket.io/zh-CN/docs/v4/client-offline-behavior/#buffered-events"></a></h2><p>默认情况下，在 Socket 未连接时发出的任何事件都将被缓冲，直到重新连接。</p><p>虽然在大多数情况下很有用（当重新连接延迟很短时），但它可能会在连接恢复时导致大量事件。</p><p>有几种解决方案可以防止这种行为，具体取决于您的用例：</p><ul><li>使用Socket 实例的<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketconnected">connected 属性</a> attribute of the Socket instance</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (socket.<span class="hljs-property">connected</span>) &#123;  socket.<span class="hljs-title function_">emit</span>( <span class="hljs-comment">/* ... */</span> );&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// ...</span>&#125;</code></pre></div><ul><li>使用 <a href="https://socket.io/zh-CN/docs/v4/emitting-events/#volatile-events">volatile 事件</a></li></ul><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>( <span class="hljs-comment">/* ... */</span> );</code></pre></div><h1 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h1><p>有几种方法可以在服务器和客户端之间发送事件。</p><h2 id="基本的-emit"><a href="#基本的-emit" class="headerlink" title="基本的 emit"></a>基本的 emit<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E5%9F%BA%E6%9C%AC%E7%9A%84-emit"></a></h2><p>Socket.IO API 的灵感来自 Node.js <a href="https://nodejs.org/docs/latest/api/events.html#events_events">EventEmitter</a>，这意味着您可以在一侧发出事件并在另一侧注册侦听器：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// world</span>&#125;);</code></pre></div><p>这也适用于另一个方向：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// world</span>  &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div><p>您可以发送任意数量的参数，并且支持所有可序列化的数据结构，包括像<a href="https://nodejs.org/docs/latest/api/buffer.html#buffer_buffer">Buffer</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">TypedArray</a>这样的二进制对象。</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">5</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">6</span>]) &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1, arg2, arg3</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// 1</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg2); <span class="hljs-comment">// &quot;2&quot;</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg3); <span class="hljs-comment">// &#123; 3: &#x27;4&#x27;, 5: ArrayBuffer (1) [ 6 ] &#125;</span>&#125;);</code></pre></div><p>无需<code>JSON.stringify()</code>，因为它会为您完成。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;));<span class="hljs-comment">// GOOD</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;);</code></pre></div><p>笔记：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a>对象将被转换为（并作为）它们的字符串表示形式，例如<code>1970-01-01T00:00:00.000Z</code></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>必须手动序列化：</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> serializedMap = [...myMap.<span class="hljs-title function_">entries</span>()];<span class="hljs-keyword">const</span> serializedSet = [...mySet.<span class="hljs-title function_">keys</span>()];</code></pre></div><ul><li>您可以使用该<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#tojson_behavior"><code>toJSON()</code></a>方法自定义对象的序列化</li></ul><p>一个类的例子：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;  #hp;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.#hp = <span class="hljs-number">42</span>;  &#125;  <span class="hljs-title function_">toJSON</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hp</span>: <span class="hljs-variable language_">this</span>.#hp &#125;;  &#125;&#125;socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;here&#x27;s a hero&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>());</code></pre></div><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E5%9B%9E%E8%B0%83"></a></h2><p>事件很棒，但在某些情况下，您可能需要更经典的请求-响应 API。在 Socket.IO 中，此功能称为确认。</p><p>您可以添加一个回调作为<code>emit()</code>的最后一个参数，一旦对方确认事件，就会调用此回调：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;update item&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1, arg2, callback</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// 1</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg2); <span class="hljs-comment">// &#123; name: &quot;updated&quot; &#125;</span>    <span class="hljs-title function_">callback</span>(&#123;      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;ok&quot;</span>    &#125;);  &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;update item&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;updated&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>); <span class="hljs-comment">// ok</span>&#125;);</code></pre></div><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E8%B6%85%E6%97%B6"></a></h2><p>从 Socket.IO v4.4.0 开始，您现在可以为每个发射分配超时：</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">timeout</span>(<span class="hljs-number">5000</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;my-event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (err) &#123;    <span class="hljs-comment">// the other side did not acknowledge the event in the given delay</span>  &#125;&#125;);</code></pre></div><p>You can also use both a timeout and an <a href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">acknowledgement</a>:</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">timeout</span>(<span class="hljs-number">5000</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;my-event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (err) &#123;    <span class="hljs-comment">// the other side did not acknowledge the event in the given delay</span>  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);  &#125;&#125;);</code></pre></div><h2 id="易失性事件"><a href="#易失性事件" class="headerlink" title="易失性事件"></a>易失性事件<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E6%98%93%E5%A4%B1%E6%80%A7%E4%BA%8B%E4%BB%B6"></a></h2><p>易失性事件是在底层连接未准备好时不会发送的事件（有点像<a href="https://fr.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>，在可靠性方面）。</p><p>例如，如果您需要发送在线游戏中角色的位置（因为只有最新的值才有用），这可能会很有趣。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;might or might not be received&quot;</span>);</code></pre></div><p>另一个用例是在客户端未连接时丢弃事件（默认情况下，事件会被缓冲直到重新连接）。</p><p>例子：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;connect&quot;</span>);  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);  &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;  socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;ping&quot;</span>, ++count);&#125;, <span class="hljs-number">1000</span>);</code></pre></div><p>如果重新启动服务器，您将在控制台中看到：</p><div class="code-wrapper"><pre><code class="hljs text">connect1234# the server is restarted, the client automatically reconnectsconnect91011</code></pre></div><p>如果没有<code>volatile</code>标志，您将看到：</p><div class="code-wrapper"><pre><code class="hljs text">connect1234# the server is restarted, the client automatically reconnects and sends its buffered eventsconnect567891011</code></pre></div><h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><p>有几种方法可以处理在服务器和客户端之间传输的事件。</p><h2 id="EventEmitter-方法"><a href="#EventEmitter-方法" class="headerlink" title="EventEmitter 方法"></a>EventEmitter 方法<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#eventemitter-methods"></a></h2><p>在服务器端，Socket 实例扩展了 Node.js <a href="https://nodejs.org/docs/latest/api/events.html#events_events">EventEmitter</a>类。</p><p>在客户端，Socket 实例使用<a href="https://github.com/component/emitter">component-emitter</a>库提供的事件发射器，它公开了 EventEmitter 方法的子集。</p><h3 id="socket-on-eventName-listener"><a href="#socket-on-eventName-listener" class="headerlink" title="socket.on(eventName, listener)"></a>socket.on(eventName, listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoneventname-listener"></a></h3><p>将<em>侦听器</em>函数添加到名为<em>eventName</em>的事件的侦听器数组的末尾。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;details&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h3 id="socket-once-eventName-listener"><a href="#socket-once-eventName-listener" class="headerlink" title="socket.once(eventName, listener)"></a>socket.once(eventName, listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketonceeventname-listener"></a></h3><p>为名为<em>eventName</em>的事件添加<strong>一次性</strong>监听函数</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;details&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h3 id="socket-off-eventName-listener"><a href="#socket-off-eventName-listener" class="headerlink" title="socket.off(eventName, listener)"></a>socket.off(eventName, listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoffeventname-listener"></a></h3><p>从名为<em>eventName</em>的事件的侦听器数组中移除指定的<em>侦听器</em>。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args);&#125;socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;details&quot;</span>, listener);<span class="hljs-comment">// and then later...</span>socket.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;details&quot;</span>, listener);</code></pre></div><h3 id="socket-removeAllListeners-eventName"><a href="#socket-removeAllListeners-eventName" class="headerlink" title="socket.removeAllListeners([eventName])"></a>socket.removeAllListeners([eventName])<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketremovealllistenerseventname"></a></h3><p>删除所有侦听器，或指定<em>eventName</em>的侦听器。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// for a specific event</span>socket.<span class="hljs-title function_">removeAllListeners</span>(<span class="hljs-string">&quot;details&quot;</span>);<span class="hljs-comment">// for all events</span>socket.<span class="hljs-title function_">removeAllListeners</span>();</code></pre></div><h2 id="Catch-all-侦听器"><a href="#Catch-all-侦听器" class="headerlink" title="Catch-all 侦听器"></a>Catch-all 侦听器<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#catch-all-listeners"></a></h2><p>从 Socket.IO v3 开始，受<a href="https://github.com/EventEmitter2/EventEmitter2">EventEmitter2</a>库启发的新 API 允许声明 Catch-all 侦听器。</p><p>此功能在客户端和服务器上均可用。</p><h3 id="socket-onAny-listener"><a href="#socket-onAny-listener" class="headerlink" title="socket.onAny(listener)"></a>socket.onAny(listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketonanylistener"></a></h3><p>添加一个监听器，当任何事件发出时将被触发。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">onAny</span>(<span class="hljs-function">(<span class="hljs-params">eventName, ...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h3 id="socket-prependAny-listener"><a href="#socket-prependAny-listener" class="headerlink" title="socket.prependAny(listener)"></a>socket.prependAny(listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketprependanylistener"></a></h3><p>添加一个监听器，当任何事件发出时将被触发。侦听器被添加到侦听器数组的开头。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">prependAny</span>(<span class="hljs-function">(<span class="hljs-params">eventName, ...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h3 id="socket-offAny-listener"><a href="#socket-offAny-listener" class="headerlink" title="socket.offAny([listener])"></a>socket.offAny([listener])<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoffanylistener"></a></h3><p>删除所有catch-all侦听器或给定的侦听器。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params">eventName, ...args</span>) =&gt; &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventName, args);&#125;socket.<span class="hljs-title function_">onAny</span>(listener);<span class="hljs-comment">// and then later...</span>socket.<span class="hljs-title function_">offAny</span>(listener);<span class="hljs-comment">// or all listeners</span>socket.<span class="hljs-title function_">offAny</span>();</code></pre></div><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#validation"></a></h2><p>事件参数的验证超出了 Socket.IO 库的范围。</p><p>JS 生态系统中有许多包涵盖了这个用例，其中包括：</p><ul><li><a href="https://www.npmjs.com/package/joi">joi</a></li><li><a href="https://www.npmjs.com/package/ajv">ajv</a></li><li><a href="https://www.npmjs.com/package/validatorjs">validatorjs</a></li></ul><p>带有<a href="https://joi.dev/api/">joi</a>和<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">acknowledgements</a>的示例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Joi</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;joi&quot;</span>);<span class="hljs-keyword">const</span> userSchema = <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">object</span>(&#123;  <span class="hljs-attr">username</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">max</span>(<span class="hljs-number">30</span>).required(),  <span class="hljs-attr">email</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">email</span>().required()&#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;create user&quot;</span>, <span class="hljs-function">(<span class="hljs-params">payload, callback</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;      <span class="hljs-comment">// not an acknowledgement</span>      <span class="hljs-keyword">return</span> socket.<span class="hljs-title function_">disconnect</span>();    &#125;    <span class="hljs-keyword">const</span> &#123; error, value &#125; = userSchema.<span class="hljs-title function_">validate</span>(payload);    <span class="hljs-keyword">if</span> (error) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(&#123;        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;KO&quot;</span>,        error      &#125;);    &#125;    <span class="hljs-comment">// do something with the value, and then</span>    <span class="hljs-title function_">callback</span>(&#123;      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;OK&quot;</span>    &#125;);  &#125;);&#125;);</code></pre></div><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#error-handling"></a></h2><p>Socket.IO 库中目前没有内置的错误处理，这意味着您必须捕获任何可能在侦听器中引发的错误。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;list items&quot;</span>, <span class="hljs-keyword">async</span> (callback) =&gt; &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">await</span> <span class="hljs-title function_">findItems</span>();      <span class="hljs-title function_">callback</span>(&#123;        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;OK&quot;</span>,        items      &#125;);    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-title function_">callback</span>(&#123;        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;NOK&quot;</span>      &#125;);    &#125;  &#125;);&#125;);</code></pre></div><p>在服务器端，使用<code>EventEmitter.captureRejections = true</code>（实验性，请参见<a href="https://nodejs.org/api/events.html#events_capture_rejections_of_promises">此处</a>）也可能很有趣，具体取决于您的用例。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>).<span class="hljs-property">captureRejections</span> = <span class="hljs-literal">true</span>;io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;list products&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">findProducts</span>();    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;products&quot;</span>, products);  &#125;);  socket[<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;nodejs.rejection&#x27;</span>)] = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;error&quot;</span>, err);  &#125;;&#125;);</code></pre></div><h1 id="广播事件"><a href="#广播事件" class="headerlink" title="广播事件"></a>广播事件</h1><p>Socket.IO 使向所有连接的客户端发送事件变得容易。</p><h5 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h5><p>请注意，广播是<strong>仅服务器</strong>功能。</p><h2 id="给所有连接的客户端"><a href="#给所有连接的客户端" class="headerlink" title="给所有连接的客户端"></a>给所有连接的客户端<a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients"></a></h2><p><img src="https://socket.io/zh-CN/images/broadcasting.png" alt="Broadcasting to all connected clients"></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div><h5 id="CAUTION"><a href="#CAUTION" class="headerlink" title="CAUTION"></a>CAUTION</h5><p>当前断开连接（或正在重新连接）的客户端将不会收到该事件。将此事件存储在某处（例如在数据库中）取决于您的用例。</p><h2 id="除发送者外的所有连接的客户端"><a href="#除发送者外的所有连接的客户端" class="headerlink" title="除发送者外的所有连接的客户端"></a>除发送者外的所有连接的客户端<a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients-except-the-sender"></a></h2><p><img src="https://socket.io/zh-CN/images/broadcasting2.png" alt="Broadcasting to all connected clients excepting the sender"></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-property">broadcast</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);&#125;);</code></pre></div><h5 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h5><p>在上面的示例中，使用<code>socket.emit(&quot;hello&quot;, &quot;world&quot;)</code>（不带<code>broadcast</code>标志）会将事件发送到“客户端 A”。您可以在<a href="https://socket.io/zh-CN/docs/v4/emit-cheatsheet/">备忘单</a>中找到发送事件的所有方式的列表。</p><h2 id="使用多个-Socket-IO-服务器"><a href="#使用多个-Socket-IO-服务器" class="headerlink" title="使用多个 Socket.IO 服务器"></a>使用多个 Socket.IO 服务器<a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#with-multiple-socketio-servers"></a></h2><p>广播也适用于多个 Socket.IO 服务器。</p><p>您只需将默认适配器替换为<a href="https://socket.io/zh-CN/docs/v4/adapter/">Redis 适配器</a>或其他<a href="https://socket.io/zh-CN/docs/v4/redis-adapter/">兼容的适配器</a>。</p><p><img src="https://socket.io/zh-CN/images/broadcasting-redis.png" alt="Broadcasting with Redis"></p><p>在某些情况下，您可能只想向连接到当前服务器的客户端广播。您可以使用<code>local</code>标志实现此目的：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">local</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div><p>复制</p><p><img src="https://socket.io/zh-CN/images/broadcasting-redis-local.png" alt="Broadcasting with Redis but local"></p><p>为了在广播时针对特定客户，请参阅有关<a href="https://socket.io/zh-CN/docs/v4/rooms/">Rooms</a>的文档。</p><h1 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h1><p>sockets可以<code>join</code> 和 <code>leave</code><em>房间</em>。它可用于向一部分客户端广播事件：</p><p><img src="https://socket.io/zh-CN/images/rooms.png" alt="Broadcasting to all clients in a room"></p><h5 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h5><p>请注意，房间是一个<strong>仅限服务器</strong>的概念（即客户端无权访问它已加入的房间列表）。</p><h2 id="加入和离开"><a href="#加入和离开" class="headerlink" title="加入和离开"></a>加入和离开<a href="https://socket.io/zh-CN/docs/v4/rooms/#joining-and-leaving"></a></h2><p>您可以调用<code>join</code>以将socket订阅到给定的频道：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;some room&quot;</span>);&#125;);</code></pre></div><p>然后在广播或发射时简单地使用<code>to</code> 或 <code>in</code>（它们是相同的）：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;some room&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);</code></pre></div><p>您可以同时发射到多个房间：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room2&quot;</span>).<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room3&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);</code></pre></div><p>在这种情况下，将执行<a href="https://en.wikipedia.org/wiki/Union_(set_theory)">联合</a>：至少在其中一个房间中的每个socket都将获得<strong>一次</strong>事件（即使socket在两个或更多房间中）。</p><p>您还可以从给定的socket广播到房间：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;some room&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);&#125;);</code></pre></div><p>在这种情况下，房间中<strong>除</strong>发送者之外的每个socket都会收到该事件。</p><p><img src="https://socket.io/zh-CN/images/rooms2.png" alt="Broadcasting to all clients in a room excepting the sender"></p><p>要离开频道，您调用<code>leave</code>的方式与<code>join</code>相同。</p><h2 id="默认房间"><a href="#默认房间" class="headerlink" title="默认房间"></a>默认房间<a href="https://socket.io/zh-CN/docs/v4/rooms/#default-room"></a></h2><p>Socket.IO 中的每一个<code>socket</code>都由一个随机的、不可猜测的、唯一的标识符<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#socketid">Socket#id</a>。为了您的方便，每个socket都会自动加入一个由其自己的 id 标识的房间。</p><p>这使得实现私人消息变得容易：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;private message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">anotherSocketId, msg</span>) =&gt;</span> &#123;    socket.<span class="hljs-title function_">to</span>(anotherSocketId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;private message&quot;</span>, socket.<span class="hljs-property">id</span>, msg);  &#125;);&#125;);</code></pre></div><h2 id="示例用例"><a href="#示例用例" class="headerlink" title="示例用例"></a>示例用例<a href="https://socket.io/zh-CN/docs/v4/rooms/#sample-use-cases"></a></h2><ul><li>向给定用户的每个设备/选项卡广播数据</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">async</span> (socket) =&gt; &#123;  <span class="hljs-keyword">const</span> userId = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserId</span>(socket);  socket.<span class="hljs-title function_">join</span>(userId);  <span class="hljs-comment">// and then later</span>  io.<span class="hljs-title function_">to</span>(userId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hi&quot;</span>);&#125;);</code></pre></div><p>复制</p><ul><li>发送有关给定实体的通知</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">async</span> (socket) =&gt; &#123;  <span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchProjects</span>(socket);  projects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">project</span> =&gt;</span> socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;project:&quot;</span> + project.<span class="hljs-property">id</span>));  <span class="hljs-comment">// and then later</span>  io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;project:4321&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;project updated&quot;</span>);&#125;);</code></pre></div><h2 id="断开"><a href="#断开" class="headerlink" title="断开"></a>断开<a href="https://socket.io/zh-CN/docs/v4/rooms/#disconnection"></a></h2><p>断开连接后，<code>leave</code>会自动将它们所属的所有通道连接起来，您不需要进行特殊的拆卸。</p><p>您可以通过监听<code>disconnecting</code>事件来获取 Socket 所在的房间：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnecting&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// the Set contains at least the socket ID</span>  &#125;);  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// socket.rooms.size === 0</span>  &#125;);&#125;);</code></pre></div><h2 id="使用多个-Socket-IO-服务器-1"><a href="#使用多个-Socket-IO-服务器-1" class="headerlink" title="使用多个 Socket.IO 服务器"></a>使用多个 Socket.IO 服务器<a href="https://socket.io/zh-CN/docs/v4/rooms/#with-multiple-socketio-servers"></a></h2><p>与<a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#with-multiple-socketio-servers">全局广播</a>一样，向房间广播也适用于多个 Socket.IO 服务器。</p><p>您只需要将默认的<a href="https://socket.io/zh-CN/docs/v4/glossary/#adapter">Adapter</a>替换为 Redis Adapter。更多关于它的信息在<a href="https://socket.io/zh-CN/docs/v4/redis-adapter/">这里</a>。</p><p><img src="https://socket.io/zh-CN/images/rooms-redis.png" alt="Broadcasting to all clients in a room with Redis"></p><h2 id="实施细节"><a href="#实施细节" class="headerlink" title="实施细节"></a>实施细节<a href="https://socket.io/zh-CN/docs/v4/rooms/#implementation-details"></a></h2><p>“房间”功能由我们称为适配器的东西实现。该适配器是一个服务器端组件，负责：</p><ul><li>存储 Socket 实例和房间之间的关系</li><li>向所有（或部分）客户端广播事件</li></ul><p>您可以在<a href="https://github.com/socketio/socket.io-adapter">此处</a>找到默认内存适配器的代码。</p><p>基本上，它包含两个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">ES6 Maps</a>:</p><ul><li><code>sids</code>: <code>Map&lt;SocketId, Set&lt;Room&gt;&gt;</code></li><li><code>rooms</code>: <code>Map&lt;Room, Set&lt;SocketId&gt;&gt;</code></li></ul><p>调用<code>socket.join(&quot;the-room&quot;)</code>将导致：</p><ul><li>在<code>sids</code> Map中，将“the-room”添加到由Socket ID 标识的 Set</li><li>在<code>rooms</code> Map 中，将Socket ID 添加到由字符串“the-room”标识的 Set 中</li></ul><p>然后在广播时使用这两个地图：</p><ul><li>对所有套接字的广播（<code>io.emit()</code>）循环通过<code>sids</code>Map，并将数据包发送到所有sockets</li><li>对给定房间的广播 ( <code>io.to(&quot;room21&quot;).emit()</code>）循环通过<code>rooms</code>Map 中的 Set，并将数据包发送到所有匹配的sockets</li></ul><p>您可以通过以下方式访问这些对象：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// main namespace</span><span class="hljs-keyword">const</span> rooms = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">rooms</span>;<span class="hljs-keyword">const</span> sids = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">sids</span>;<span class="hljs-comment">// custom namespace</span><span class="hljs-keyword">const</span> rooms = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/my-namespace&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">rooms</span>;<span class="hljs-keyword">const</span> sids = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/my-namespace&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">sids</span>;</code></pre></div><p>笔记：</p><ul><li>这些对象并不意味着直接修改，您应该始终使用<a href="https://socket.io/zh-CN/docs/v4/server-api/#socketjoinroom"><code>socket.join(...)</code></a> 和 <a href="https://socket.io/zh-CN/docs/v4/server-api/#socketleaveroom"><code>socket.leave(...)</code></a>来代替。</li><li>在<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">多服务器</a>设置中，<code>rooms</code> 和 <code>sids</code>对象不会在 Socket.IO 服务器之间共享（房间可能只“存在”在一个服务器上而不是另一个服务器上）。</li></ul><h2 id="房间事件"><a href="#房间事件" class="headerlink" title="房间事件"></a>房间事件<a href="https://socket.io/zh-CN/docs/v4/rooms/#room-events"></a></h2><p>从<code>socket.io@3.1.0</code>开始，底层适配器将发出以下事件：</p><ul><li><code>create-room</code> (argument: room)</li><li><code>delete-room</code> (argument: room)</li><li><code>join-room</code> (argument: room, id)</li><li><code>leave-room</code> (argument: room, id)</li></ul><p>例子：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;create-room&quot;</span>, <span class="hljs-function">(<span class="hljs-params">room</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`room <span class="hljs-subst">$&#123;room&#125;</span> was created`</span>);&#125;);io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;join-room&quot;</span>, <span class="hljs-function">(<span class="hljs-params">room, id</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`socket <span class="hljs-subst">$&#123;id&#125;</span> has joined room <span class="hljs-subst">$&#123;room&#125;</span>`</span>);&#125;);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>websocket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket.io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是websocket</title>
    <link href="/2022/09/24/%E4%BB%80%E4%B9%88%E6%98%AFwebsocket/"/>
    <url>/2022/09/24/%E4%BB%80%E4%B9%88%E6%98%AFwebsocket/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>webSocket是一种网络传输协议，可以在单个TCP连接上进行全双工通信，位于OSI模型的应用层，webSocket协议在2011年由IETF标准化为RFC6455,由RFC7936补充规范，WEB IDL中的webSocket api由W3C标准化，websocket是一种和http不同的协议，但是都是属于OSI模型的应用层，可以通过HTTP的80端口和443端口进行通信，支持HTTP代理和中介，和http协议兼容，为了实现兼容性，webSocket进行握手使用HTTP Upgrade头从http协议改成webSocket协议，websocket支持浏览器和服务器进行双向通信，可以进行实时通信，不需要客户端发起请求，目前大部分浏览器都支持websocket,和HTTP不同，websocket支持全双工通信，websocket还可以TCP之上实现消息流</p><p>websocket协议有两种标识符分别是ws和wss，分别是明文传输和加密传输。websocket不支持#，除了这些，其他都和http相同</p><div class="code-wrapper"><pre><code class="hljs awk">ws:<span class="hljs-regexp">//</span>example.com/wsapiwss:<span class="hljs-regexp">//</span>secure.example.com/wsapi</code></pre></div><h4 id="websocket的优点"><a href="#websocket的优点" class="headerlink" title="websocket的优点"></a>websocket的优点</h4><ul><li><p>比较少的控制开销，在服务器和客户端通信的时候，用于协议控制的数据包头部相对较小，在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2到10字节，对于客户端到服务器的内容，此头部还需要加额外的4字节的掩码，相对于http每次都要携带完整的头部，明显减少了开销</p></li><li><p>更强的实时性，由于协议是全双工的，所以服务器可以随时主动的给客户端发送数据，相对于HTTP请求需要客户端发送请求并且等待服务器响应，减少了等待时间，即使和Comet等类似的长轮询比较，它也可以在短时间传递更多的数据</p></li><li><p>保持连接状态，与HTTP不同的是，webSocket需要先建立连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息，而http每次请求可能需要携带验证信息</p></li><li><p>更好的二进制支持，webSocket定义了二进制帧，他会比HTTP更i轻松的处理二进制文件</p></li><li><p>更好的压缩效果，相对于HTTP压缩，websocket在适当的扩展的支持下，可以沿用之前的内容的上下文，在传递类似的数据的时候可以显著的提高压缩率</p></li></ul><p>webSocket是独立的，建立在TCP上的协议，websocket通过HTTP/1.1的101状态吗继续握手，为了建立Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“<a href="https://zh.m.wikipedia.org/wiki/%E6%8F%A1%E6%89%8B_(%E6%8A%80%E6%9C%AF)">握手</a>”（Handshaking）</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>客户端请求：</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==<span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://example.com<span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>chat, superchat<span class="hljs-attribute">Sec-WebSocket-Version</span><span class="hljs-punctuation">: </span>13</code></pre></div><p>服务器的回应</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>chat</code></pre></div><ul><li>Connection必须设置Upgrade，表示客户端希望连接升级。</li><li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li><li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算<a href="https://zh.m.wikipedia.org/wiki/SHA-1">SHA-1</a>摘要，之后进行<a href="https://zh.m.wikipedia.org/wiki/Base64">Base64</a>编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li><li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin字段是必须的。如果缺少origin字段，WebSocket服务器需要回复HTTP 403 状态码（禁止访问）。[<a href="https://zh.m.wikipedia.org/zh-hans/WebSocket#cite_note-16">16]</a></li><li>其他一些定义在HTTP协议中的字段，如<a href="https://zh.m.wikipedia.org/wiki/Cookie">Cookie</a>等，也可以在Websocket中使用。</li></ul><h4 id="websocket的基本使用"><a href="#websocket的基本使用" class="headerlink" title="websocket的基本使用"></a>websocket的基本使用</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;wss://echo.websocket.org&quot;</span>);ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection open ...&quot;</span>);   ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hello WebSockets!&quot;</span>);&#125;;ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Received Message: &quot;</span> + evt.<span class="hljs-property">data</span>);  ws.<span class="hljs-title function_">close</span>();&#125;;ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection closed.&quot;</span>);&#125;;</code></pre></div><blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:8080&#x27;</span>);</code></pre></div></blockquote><p>wenSocket作为构造函数，用于新建WebSocket实例，执行完上面的例子之后，客户端就会和服务器进行连接</p><h5 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h5><p>readyState属性是返回当前状态，共有四种状态</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (ws.<span class="hljs-property">readyState</span>) &#123;  <span class="hljs-keyword">case</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">CONNECTING</span>:    <span class="hljs-comment">// do something</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>:    <span class="hljs-comment">// do something</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">CLOSING</span>:    <span class="hljs-comment">// do something</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">CLOSED</span>:    <span class="hljs-comment">// do something</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-attr">default</span>:    <span class="hljs-comment">// this never happens</span>    <span class="hljs-keyword">break</span>;&#125;</code></pre></div><h5 id="open属性监听连接之后的回调函数"><a href="#open属性监听连接之后的回调函数" class="headerlink" title="open属性监听连接之后的回调函数"></a>open属性监听连接之后的回调函数</h5><div class="code-wrapper"><pre><code class="hljs javascript">ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Server!&#x27;</span>);&#125;<span class="hljs-comment">//执行多个回调函数可以使用addEventListener</span>ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;  ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Server!&#x27;</span>);&#125;);</code></pre></div><h5 id="实例对象的onclose属性，用于指定连接关闭后的回调函数"><a href="#实例对象的onclose属性，用于指定连接关闭后的回调函数" class="headerlink" title="实例对象的onclose属性，用于指定连接关闭后的回调函数"></a>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数</h5><div class="code-wrapper"><pre><code class="hljs js">ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-keyword">var</span> code = event.<span class="hljs-property">code</span>;  <span class="hljs-keyword">var</span> reason = event.<span class="hljs-property">reason</span>;  <span class="hljs-keyword">var</span> wasClean = event.<span class="hljs-property">wasClean</span>;  <span class="hljs-comment">// handle close event</span>&#125;;ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-keyword">var</span> code = event.<span class="hljs-property">code</span>;  <span class="hljs-keyword">var</span> reason = event.<span class="hljs-property">reason</span>;  <span class="hljs-keyword">var</span> wasClean = event.<span class="hljs-property">wasClean</span>;  <span class="hljs-comment">// handle close event</span>&#125;);</code></pre></div><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数</p><div class="code-wrapper"><pre><code class="hljs javascript">ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-keyword">var</span> data = event.<span class="hljs-property">data</span>;  <span class="hljs-comment">// 处理数据</span>&#125;;ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-keyword">var</span> data = event.<span class="hljs-property">data</span>;  <span class="hljs-comment">// 处理数据</span>&#125;);</code></pre></div><p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象</p><div class="code-wrapper"><pre><code class="hljs javascript">ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> event.<span class="hljs-property">data</span> === <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received data string&quot;</span>);  &#125;  <span class="hljs-keyword">if</span>(event.<span class="hljs-property">data</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ArrayBuffer</span>)&#123;    <span class="hljs-keyword">var</span> buffer = event.<span class="hljs-property">data</span>;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received arraybuffer&quot;</span>);  &#125;&#125;</code></pre></div><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 收到的是 blob 数据</span>ws.<span class="hljs-property">binaryType</span> = <span class="hljs-string">&quot;blob&quot;</span>;ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">size</span>);&#125;;<span class="hljs-comment">// 收到的是 ArrayBuffer 数据</span>ws.<span class="hljs-property">binaryType</span> = <span class="hljs-string">&quot;arraybuffer&quot;</span>;ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">byteLength</span>);&#125;;</code></pre></div></blockquote><p>实例对象的<code>send()</code>方法用于向服务器发送数据。</p><blockquote><div class="code-wrapper"><pre><code class="hljs javascript">ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;your message&#x27;</span>);</code></pre></div></blockquote><p>发送blob对象的例子</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> file = <span class="hljs-variable language_">document</span>  .<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input[type=&quot;file&quot;]&#x27;</span>)  .<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];ws.<span class="hljs-title function_">send</span>(file);</code></pre></div><p>发送ArrayBuffer对象的例子</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Sending canvas ImageData as ArrayBuffer</span><span class="hljs-keyword">var</span> img = canvas_context.<span class="hljs-title function_">getImageData</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">400</span>, <span class="hljs-number">320</span>);<span class="hljs-keyword">var</span> binary = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(img.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; img.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>; i++) &#123;  binary[i] = img.<span class="hljs-property">data</span>[i];&#125;ws.<span class="hljs-title function_">send</span>(binary.<span class="hljs-property">buffer</span>);</code></pre></div><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">10000000</span>);socket.<span class="hljs-title function_">send</span>(data);<span class="hljs-keyword">if</span> (socket.<span class="hljs-property">bufferedAmount</span> === <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 发送完毕</span>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 发送还没结束</span>&#125;</code></pre></div><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><blockquote><div class="code-wrapper"><pre><code class="hljs javascript">socket.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-comment">// handle error event</span>&#125;;socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-comment">// handle error event</span>&#125;)</code></pre></div></blockquote><h4 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h4><p>如果用node实现websocket</p><ul><li><a href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li><li><a href="http://socket.io/">Socket.IO</a></li><li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>websocket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>websocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx的使用</title>
    <link href="/2022/09/20/mobx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/20/mobx%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><em>任何可以从应用状态中派生出来的值都应该被自动派生出来。</em></p><p>MobX 是一个身经百战的库，它通过运用透明的函数式响应编程（Transparent Functional Reactive Programming，TFRP）使状态管理变得简单和可扩展。</p><p>😙</p><h5 id="简单直接"><a href="#简单直接" class="headerlink" title="简单直接"></a>简单直接</h5><p>编写无模板的极简代码来精准描述出你的意图。要更新一个记录字段？使用熟悉的 JavaScript 赋值就行。要在异步进程中更新数据？不需要特殊的工具，响应性系统会侦测到你所有的变更并把它们传送到其用武之地。</p><p>🚅</p><h5 id="轻松实现最优渲染"><a href="#轻松实现最优渲染" class="headerlink" title="轻松实现最优渲染"></a>轻松实现最优渲染</h5><p>所有对数据的变更和使用都会在运行时被追踪到，并构成一个截取所有状态和输出之间关系的依赖树。这样保证了那些依赖于状态的计算只有在真正需要时才会运行，就像 React 组件一样。无需使用记忆化或选择器之类容易出错的次优技巧来对组件进行手动优化。</p><p>🤹🏻‍♂️</p><h5 id="架构自由"><a href="#架构自由" class="headerlink" title="架构自由"></a>架构自由</h5><p>MobX 不会用它自己的规则来限制你，它可以让你在任意 UI 框架之外管理你的应用状态。这样会使你的代码低耦合、可移植和最重要的——容易测试。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span><span class="hljs-comment">// 对应用状态进行建模。</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;    secondsPassed = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">increase</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> += <span class="hljs-number">1</span>    &#125;    <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> = <span class="hljs-number">0</span>    &#125;&#125;<span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>()<span class="hljs-comment">// 构建一个使用 observable 状态的“用户界面”。</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; timer &#125;</span>) =&gt;</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> timer.reset()&#125;&gt;已过秒数：&#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>))<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> <span class="hljs-attr">timer</span>=<span class="hljs-string">&#123;myTimer&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)<span class="hljs-comment">// 每秒更新一次‘已过秒数：X’中的文本。</span><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;    myTimer.<span class="hljs-title function_">increase</span>()&#125;, <span class="hljs-number">1000</span>)</code></pre></div><p>围绕 React 组件 <code>TimerView</code> 的 <code>observer</code> 包装会自动侦测到依赖于 observable <code>timer.secondsPassed</code> 的渲染——即使这种依赖关系没有被明确定义出来。 响应性系统会负责在未来<em>恰好那个</em>字段被更新的时候将组件重新渲染。</p><p>每个事件（<code>onClick</code> 或 <code>setInterval</code>）都会调用一个用来更新 <em>observable 状态</em> <code>myTimer.secondsPassed</code> 的 <em>action</em>（<code>myTimer.increase</code> 或 <code>myTimer.reset</code>）。Observable 状态的变更会被精确地传送到 <code>TimerView</code> 中所有依赖于它们的<em>计算</em>和<em>副作用</em>里。</p><p><img src="https://zh.mobx.js.org/assets/zh.flow.png" alt="MobX 单向流"></p><h1 id="MobX-主旨"><a href="#MobX-主旨" class="headerlink" title="MobX 主旨"></a>MobX 主旨</h1><p>Mobx区分了应用程序的三个概念</p><ul><li>State</li><li>Actions</li><li>Derivations</li></ul><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><em>State(状态)</em> 是驱动你的应用程序的数据。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Todo</span> &#123;    id = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()    title = <span class="hljs-string">&quot;&quot;</span>    finished = <span class="hljs-literal">false</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">title</span>: observable,            <span class="hljs-attr">finished</span>: observable,            <span class="hljs-attr">toggle</span>: action        &#125;)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title    &#125;    <span class="hljs-title function_">toggle</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">finished</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">finished</span>    &#125;&#125;</code></pre></div><p>将 State 存储在任何您喜欢的数据结构中：普通对象、数组、类、循环数据结构或引用。这与MobX的工作方式无关。</p><p>只要确保所有响应式的属性都被标记为<code>observable</code></p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>action是用来改变state中的数据，比如用户事件处理、后端推送数据处理、调度器事件处理等等。</p><h3 id="创建-Derivations-以便自动对-State-变化进行响应"><a href="#创建-Derivations-以便自动对-State-变化进行响应" class="headerlink" title="创建 Derivations 以便自动对 State 变化进行响应"></a>创建 Derivations 以便自动对 State 变化进行响应</h3><p><em>任何</em> 来源是<em>State(状态)</em> 并且不需要进一步交互的东西都是 Derivation(派生)</p><p>Derivations 包括许多方式:</p><ul><li><em>用户界面</em></li><li><em>派生数据</em> , 比如剩余未完成<code>todos</code>的数量</li><li><em>后端集成</em> , 比如发送改变到服务器端</li></ul><p>Mobx 区分了两种 Derivation :</p><ul><li><em>Computed values</em>,总是可以通过纯函数从当前的可观测 State 中派生。</li><li><em>Reactions</em>, 当 State 改变时需要自动运行的副作用 (命令式编程和响应式编程之间的桥梁)</li></ul><p>当最开始使用MobX时，人们容易过度使用 <em>Reaction</em>。</p><p>黄金法则是，如果要基于当前 State 创建值，请始终使用 <em>computed</em></p><h4 id="通过-computed-对派生值进行建模"><a href="#通过-computed-对派生值进行建模" class="headerlink" title="通过 computed 对派生值进行建模"></a>通过 computed 对派生值进行建模</h4><p>你可以通过定义 getter 方法并使用 <code>makeObservable</code> 将其标记为 <code>computed</code> 的方式创建一个 <em>computed</em> 值。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TodoList</span> &#123;    todos = []    <span class="hljs-keyword">get</span> <span class="hljs-title function_">unfinishedTodoCount</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">finished</span>).<span class="hljs-property">length</span>    &#125;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">todos</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">todos</span>: observable,            <span class="hljs-attr">unfinishedTodoCount</span>: computed        &#125;)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span> = todos    &#125;&#125;</code></pre></div><p>Mobx 会确保 <code>unfinishedTodoCount</code> 会在todos数组发生变化中或者 todos中的一个对象中的 <code>finished</code>属性被修改时自动更新</p><h4 id="Reaction会产生副作用"><a href="#Reaction会产生副作用" class="headerlink" title="Reaction会产生副作用"></a>Reaction会产生副作用</h4><p>作为用户，要想在屏幕上看到状态或计算值的变化，就需要一个重新绘制部分GUI的 <em>reactions</em> 。</p><p>Reaction 和 computed 类似，但并不产生信息，而是产生副作用，如打印到控制台、发出网络请求、增量更新 React 组件树以便更新DOM等。</p><p>简而言之，<em>reaction</em> 是 <a href="https://en.wikipedia.org/wiki/Reactive_programming">响应式编程</a>和<a href="https://en.wikipedia.org/wiki/Imperative_programming">指令式编程</a>之间的桥梁。</p><p>到目前为止，最常用的 reaction 形式是UI组件。 注意，action 和 reaction 都可能引起副作用。 副作用应有一个清晰的、显式的起源，例如在提交表单时发出网络请求，应该从相关的事件处理程序显式触发。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>Mobx 使用单向数据流，利用 <em>action</em> 改变 <em>state</em> ，进而更新所有受影响的 <em>view</em></p><p><img src="https://zh.mobx.js.org/assets/action-state-view.png" alt="Action, State, View"></p><ol><li>所有的 <em>derivations</em> 将在 <em>state</em> 改变时<strong>自动且原子化地更新</strong>。因此不可能观察中间值。</li><li>所有的 <em>derivations</em> 默认将会<strong>同步</strong>更新，这意味着 <em>action</em> 可以在 <em>state</em> 改变 之后安全的直接获得 computed 值。</li><li><em>computed value</em> 的更新是<strong>惰性</strong>的，任何 computed value 在需要他们的副作用发生之前都是不激活的。</li><li>所有的 <em>computed value</em> 都应是<strong>纯函数</strong>,他们不应该修改 <em>state</em>。</li></ol><h2 id="Observable-state"><a href="#Observable-state" class="headerlink" title="Observable state"></a>Observable state</h2><p>属性，完整的对象，数组，Maps 和 Sets 都可以被转化为可观察对象。 使得对象可观察的基本方法是使用 <code>makeObservable</code> 为每个属性指定一个注解。 最重要的注解如下：</p><ul><li><code>observable</code> 定义一个存储 state 的可追踪字段。</li><li><code>action</code> 将一个方法标记为可以修改 state 的 action。</li><li><code>computed</code> 标记一个可以由 state 派生出新的值并且缓存其输出的 getter。</li></ul><p>像数组，Maps 和 Sets 这样的集合都将被自动转化为可观察对象</p><h4 id="makeObservable"><a href="#makeObservable" class="headerlink" title="makeObservable"></a><code>makeObservable</code></h4><p>用法：</p><ul><li><code>makeObservable(target, annotations?, options?)</code></li></ul><p>这个函数会将已存在的对象属性转换成可观察地对象，任何target对象包括class都可以作为target传递。一般情况下，<code>makeObservable</code> 是在类的构造函数中调用的，并且它的第一个参数是 <code>this</code> 。 <code>annotations</code> 参数将会为每一个成员映射 <a href="https://zh.mobx.js.org/observable-state.html#%E5%8F%AF%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3">注解</a>。需要注意的是，当使用 <a href="https://zh.mobx.js.org/enabling-decorators.html">装饰器</a> 时，<code>annotations</code> 参数将会被忽略。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, computed, action, flow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">value</span>: observable,            <span class="hljs-attr">double</span>: computed,            <span class="hljs-attr">increment</span>: action,            <span class="hljs-attr">fetch</span>: flow        &#125;)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">double</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;    *<span class="hljs-title function_">fetch</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/value&quot;</span>)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = response.<span class="hljs-title function_">json</span>()    &#125;&#125;所有带注解 的字段都是 不可配置的。所有的不可观察（无状态）的字段（action, flow）都是 不可写的。</code></pre></div><h4 id="makeAutoObservable"><a href="#makeAutoObservable" class="headerlink" title="makeAutoObservable"></a><code>makeAutoObservable</code></h4><p>使用：</p><ul><li><code>makeAutoObservable(target, overrides?, options?)</code></li></ul><p>相当于是加强版的makeObservable函数，他会自动根据传入的对象属性自动转成可观察属性，</p><p>与使用 <code>makeObservable</code> 相比，<code>makeAutoObservable</code> 函数更紧凑，也更容易维护，因为新成员不需要显式地提及。 然而，<code>makeAutoObservable</code> 不能被用于带有 super 的类或 <a href="https://zh.mobx.js.org/subclassing.html">子类</a></p><p>推断规则：</p><ul><li>所有 <em>自有</em> 属性都成为 <code>observable</code>。</li><li>所有 <code>get</code>ters 都成为 <code>computed</code>。</li><li>所有 <code>set</code>ters 都成为 <code>action</code>。</li><li>所有 <em>prototype 中的 functions</em> 都成为 <code>autoAction</code>。</li><li>所有 <em>prototype 中的 generator functions</em> 都成为 <code>flow</code>。（需要注意，generators 函数在某些编译器配置中无法被检测到，如果 flow 没有正常运行，请务必明确地指定 <code>flow</code> 注解。）</li><li>在 <code>overrides</code> 参数中标记为 <code>false</code> 的成员将不会被添加注解。例如，将其用于像标识符这样的只读字段。</li></ul><h4 id="observable"><a href="#observable" class="headerlink" title="observable"></a><code>observable</code></h4><p>用法：</p><ul><li><code>observable(source, overrides?, options?)</code></li></ul><p><code>observable</code> 注解可以作为一个函数进行调用，从而一次性将整个对象变成可观察的。 <code>source</code> 对象将会被克隆并且所有的成员都将会成为可观察的，类似于 <code>makeAutoObservable</code> 做的那样。 同样，你可以传入一个 <code>overrides</code> 对象来为特定的成员提供特定的注解。 </p><p>由 <code>observable</code> 返回的对象将会使用 Proxy 包装，这意味着之后被添加到这个对象中的属性也将被侦测并使其转化为可观察对象（除非禁用 <a href="https://zh.mobx.js.org/configuration.html#proxy-%E9%80%89%E9%A1%B9">proxy</a>）。</p><p><code>observable</code> 方法也可以被像 <a href="https://zh.mobx.js.org/api.html#observablearray">arrays</a>，<a href="https://zh.mobx.js.org/api.html#observablemap">Maps</a> 和 <a href="https://zh.mobx.js.org/api.html#observableset">Sets</a> 这样的集合调用。这些集合也将被克隆并转化为可观察对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observable, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">observable</span>([    &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Spoil tea&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">true</span> &#125;,    &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Make coffee&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> &#125;])<span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(        <span class="hljs-string">&quot;Remaining:&quot;</span>,        todos            .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">completed</span>)            .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">title</span>)            .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;, &quot;</span>)    )&#125;)<span class="hljs-comment">// 打印: &#x27;Remaining: Make coffee&#x27;</span>todos[<span class="hljs-number">0</span>].<span class="hljs-property">completed</span> = <span class="hljs-literal">false</span><span class="hljs-comment">// 打印: &#x27;Remaining: Spoil tea, Make coffee&#x27;</span>todos[<span class="hljs-number">2</span>] = &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Take a nap&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> &#125;<span class="hljs-comment">// 打印: &#x27;Remaining: Spoil tea, Make coffee, Take a nap&#x27;</span>todos.<span class="hljs-title function_">shift</span>()<span class="hljs-comment">// 打印: &#x27;Remaining: Make coffee, Take a nap&#x27;</span></code></pre></div><p>使用autorun可以在响应式的数据发生改变的时候，自动执行对应的回调函数</p><p>可观察的数组还有一些特别好用的实用函数：</p><ul><li><code>clear()</code> 从数组中清除所有元素。</li><li><code>replace(newItems)</code> 将数组中现有的元素全部替换成 newItems。</li><li><code>remove(value)</code> 根据 value 从数组中删除一个元素。如果找到并删除了元素，返回 <code>true</code>。</li></ul><p><strong>注意：基本数据类型和类的实例不能转换成可观察的对象</strong></p><p><strong><code>make(Auto)Observable</code> 和 <code>observable</code> 之间最主要的区别</strong>在于，<code>make(Auto)Observable</code> 会修改你作为第一个参数传入的对象，而 <code>observable</code> 会创建一个可观察的 <em>副本</em> 对象</p><p>第二个区别是，<code>observable</code> 会创建一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><code>Proxy</code></a> 对象，以便能够在你将该对象当作动态查询映射使用时捕获将要添加的属性。 如果你想把一个对象转化为可观察对象，而这个对象具有一个常规结构，其中所有的成员都是事先已知的，那么我们建议使用 <code>makeObservable</code>，因为非代理对象的速度稍快一些，而且它们在调试器和 <code>console.log</code> 中更容易检查。</p><p>因此，<code>make(Auto)Observable</code> 推荐在工厂函数中使用。 值得一提的是，可以将 <code>&#123; proxy: false &#125;</code> 作为 option 传入 <code>observable</code> 获取非代理副本</p><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><h3 id="使用-actions-更新-state"><a href="#使用-actions-更新-state" class="headerlink" title="使用 actions 更新 state"></a>使用 actions 更新 state</h3><p>用法：</p><ul><li><code>action</code> <em>（注解）</em></li><li><code>action(fn)</code></li><li><code>action(name, fn)</code></li></ul><p>actions就是用来修改state中的数据的，</p><p>尽管 <a href="https://zh.mobx.js.org/observable-state.html#makeautoobservable"><code>makeAutoObservable</code></a> 可以自动帮你声明一部分 actions，但是 MobX 还是要求你声明你的 actions。Actions 可以帮助你更好的组织你的代码并提供以下性能优势：</p><ol><li>它们在 <a href="https://zh.mobx.js.org/api.html#transaction">transactions</a> 内部运行。任何可观察对象在最外层的 action 完成之前都不会被更新，这一点保证了在 action 完成之前，action 执行期间生成的中间值或不完整的值对应用程序的其余部分都是不可见的。</li><li>默认情况下，不允许在 actions 之外改变 state。这有助于在代码中清楚地对状态更新发生的位置进行定位。</li></ol><p><code>action</code> 注解应该仅用于会<em>修改</em> state 的函数。派生其他信息（执行查询或者过滤数据）的函数<em>不应该</em>被标记为 actions，以便 MobX 可以对它们的调用进行跟踪。 带有 <code>action</code> 注解的成员是不可枚举的。</p><p>makeObservable</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">value</span>: observable,            <span class="hljs-attr">increment</span>: action        &#125;)    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 观察者不会看到中间状态.</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;&#125;</code></pre></div><p>makeAutoObservable</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;&#125;</code></pre></div><p>action.bound</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">value</span>: observable,            <span class="hljs-attr">increment</span>: action.<span class="hljs-property">bound</span>        &#125;)    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;&#125;<span class="hljs-keyword">const</span> doubler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Doubler</span>()<span class="hljs-comment">// 这样调用 increment 是安全的, 因为它已经被绑定了。</span><span class="hljs-built_in">setInterval</span>(doubler.<span class="hljs-property">increment</span>, <span class="hljs-number">1000</span>)</code></pre></div><p>Action(fn)</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">observable</span>(&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">action</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;    state.<span class="hljs-property">value</span>++    state.<span class="hljs-property">value</span>++&#125;)<span class="hljs-title function_">increment</span>(state)</code></pre></div><p>runInAction</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observable, runInAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">observable</span>(&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">runInAction</span>(<span class="hljs-function">() =&gt;</span> &#123;    state.<span class="hljs-property">value</span>++    state.<span class="hljs-property">value</span>++&#125;)</code></pre></div><h3 id="使用-action-包装函数"><a href="#使用-action-包装函数" class="headerlink" title="使用 action 包装函数"></a>使用 <code>action</code> 包装函数</h3><p>为了尽可能地利用 MobX 的事务性，actions 应该尽可能被传到外围。如果一个类方法会修改 state，可以将其标记为 action。把事件处理函数标记为 actions 就更好了，因为最外层的事务起着决定性作用。一个未被标记的、会接着调用两个 actions 的事件处理函数仍然将会生成两个事务。</p><p>为了帮助创建基于 action 的事件处理函数，<code>action</code> 不仅仅是一个注解，更是一个高阶函数。可以使用函数将它作为一个参数来调用，在这种情况下它将会返回一个有着相同签名的使用 <code>action</code> 包装过的函数。</p><p>例如在 React 中，可以按照下面的方式包装 <code>onClick</code> 事件处理函数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ResetButton</span> = (<span class="hljs-params">&#123; formState &#125;</span>) =&gt; (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;action(e</span> =&gt;</span> &#123;</span><span class="language-xml">            formState.resetPendingUploads()</span><span class="language-xml">            formState.resetValues()</span><span class="language-xml">            e.stopPropagation()</span><span class="language-xml">        &#125;)&#125;</span><span class="language-xml">    &gt;</span><span class="language-xml">        Reset form</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>)</code></pre></div><p>为了更好的调试体验，我们推荐为被包装的函数命名，或者将名称作为 <code>action</code> 的第一个参数进行传递    </p><p><strong>注意：actions不会被跟踪</strong>，就是不能触发autorun</p><p>actions 的另一个特征是它们是 <a href="https://zh.mobx.js.org/api.html#untracked">不可追踪</a> 的。当从副作用或者计算值（非常罕见）中调用 action 时，该 action 读取的可观察对象将不会算作该 derivation 的依赖项。</p><p><code>makeAutoObservable</code>，<code>extendObservable</code> 和 <code>observable</code> 使用一种特殊的 <code>action</code>， 叫做 <code>autoAction</code>， 它会在运行时确定函数是 derivation 还是 action。</p><h3 id="action-bound"><a href="#action-bound" class="headerlink" title="action.bound"></a><code>action.bound</code></h3><p>用法：</p><ul><li><code>action.bound</code> <em>（注解）</em></li></ul><p><code>action.bound</code> 注解可用于将方法自动绑定到正确的实例，这样 <code>this</code> 会始终被正确绑定在函数内部</p><p>使用makeAutoObservable(o,{},{autoBind:true}) 自动绑定所有的actions和flow</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123;&#125;, &#123; <span class="hljs-attr">autoBind</span>: <span class="hljs-literal">true</span> &#125;)    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;        *<span class="hljs-title function_">flow</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://example.com/value&quot;</span>)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-keyword">yield</span> response.<span class="hljs-title function_">json</span>()    &#125;&#125;</code></pre></div><h3 id="runInAction"><a href="#runInAction" class="headerlink" title="runInAction"></a><code>runInAction</code></h3><p>用法：</p><ul><li><code>runInAction(fn)</code></li></ul><p>使用这个工具函数来创建一个会被立即调用的临时 action。在异步进程中非常有用。 </p><h3 id="Actions-和继承"><a href="#Actions-和继承" class="headerlink" title="Actions 和继承"></a>Actions 和继承</h3><p>只有定义在<strong>原型</strong>上的函数可以被子类<strong>覆盖</strong>：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;    <span class="hljs-comment">// on instance class filed</span>    arrowAction = <span class="hljs-function">() =&gt;</span> &#123;&#125;    <span class="hljs-comment">// on prototype</span>    <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) &#123;&#125;    <span class="hljs-title function_">boundAction</span>(<span class="hljs-params"></span>) &#123;&#125;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">arrowAction</span>: action            <span class="hljs-attr">action</span>: action,            <span class="hljs-attr">boundAction</span>: action.<span class="hljs-property">bound</span>,        &#125;)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;    <span class="hljs-comment">// THROWS: TypeError: Cannot redefine property: arrowAction</span>    arrowAction = <span class="hljs-function">() =&gt;</span> &#123;&#125;    <span class="hljs-comment">// OK</span>    <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) &#123;&#125;    <span class="hljs-title function_">boundAction</span>(<span class="hljs-params"></span>) &#123;&#125;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">super</span>()        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">arrowAction</span>: override,            <span class="hljs-attr">action</span>: override,            <span class="hljs-attr">boundAction</span>: override,        &#125;)    &#125;&#125;</code></pre></div><p>想要将单个的 <em>action</em> <strong>绑定</strong> 到 <code>this</code>，可以使用 <code>action.bound</code> 代替箭头函数</p><h3 id="异步-actions"><a href="#异步-actions" class="headerlink" title="异步 actions"></a>异步 actions</h3><p>从本质上讲，异步进程在 MobX 中不需要任何特殊处理，因为不论是何时引发的所有 reactions 都将会自动更新。 而且因为可观察对象是可变的，因此在 action 执行过程中保持对它们的引用一般是安全的。 然而，在异步进程中更新可观察对象的每个步骤（tick）都应该被标识为 <code>action</code>。 我们可以通过利用上述的 API 以多种方式实现这一点，如下所示。</p><p>例如，在处理 Promise 时，更新 state 的处理程序应该被 <code>action</code> 包装起来，或者被标记为 actions，如下所示。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span> 的决议处理程序是我们以内联的方式处理的，但是会在一开始的 action 执行完成之后运行，因此需要使用 action 对它们进行包装：<span class="hljs-keyword">import</span> &#123; action, makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;    githubProjects = []    state = <span class="hljs-string">&quot;pending&quot;</span> <span class="hljs-comment">// &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-title function_">fetchGithubProjectsSomehow</span>().<span class="hljs-title function_">then</span>(            <span class="hljs-title function_">action</span>(<span class="hljs-string">&quot;fetchSuccess&quot;</span>, <span class="hljs-function"><span class="hljs-params">projects</span> =&gt;</span> &#123;                <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)                <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span>            &#125;),            <span class="hljs-title function_">action</span>(<span class="hljs-string">&quot;fetchError&quot;</span>, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span>            &#125;)        )    &#125;&#125;</code></pre></div><p>如果 Promise 的处理函数是类的字段，它们将由 <code>makeAutoObservable</code> 自动包装为 <code>action</code>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;    githubProjects = []    state = <span class="hljs-string">&quot;pending&quot;</span> <span class="hljs-comment">// &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-title function_">fetchGithubProjectsSomehow</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projectsFetchSuccess</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">projectsFetchFailure</span>)    &#125;    projectsFetchSuccess = <span class="hljs-function"><span class="hljs-params">projects</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span>    &#125;    projectsFetchFailure = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span>    &#125;&#125;</code></pre></div><p><code>await</code> 之后的任何操作都不与其同在一个 tick 中，因此它们需要使用 action 包装。 在这里，我们可以利用 <code>runInAction</code>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; runInAction, makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;    githubProjects = []    state = <span class="hljs-string">&quot;pending&quot;</span> <span class="hljs-comment">// &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchGithubProjectsSomehow</span>()            <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)            <span class="hljs-title function_">runInAction</span>(<span class="hljs-function">() =&gt;</span> &#123;                <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span>            &#125;)        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-title function_">runInAction</span>(<span class="hljs-function">() =&gt;</span> &#123;                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span>            &#125;)        &#125;    &#125;&#125;</code></pre></div><p>使用flow+generator</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; flow, makeAutoObservable, flowResult &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;    githubProjects = []    state = <span class="hljs-string">&quot;pending&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">fetchProjects</span>: flow        &#125;)    &#125;    <span class="hljs-comment">// 注意星号, 这是一个 generator 函数!</span>    *<span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// Yield 代替 await.</span>            <span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetchGithubProjectsSomehow</span>()            <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects        &#125; <span class="hljs-keyword">catch</span> (error) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span>        &#125;    &#125;&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>()<span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">await</span> <span class="hljs-title function_">flowResult</span>(store.<span class="hljs-title function_">fetchProjects</span>())</code></pre></div><h2 id="Computers"><a href="#Computers" class="headerlink" title="Computers"></a>Computers</h2><p>使用：</p><ul><li><code>computed</code> <em>（注解）</em></li><li><code>computed(options)</code> <em>（注解）</em></li><li><code>computed(fn, options?)</code></li></ul><p>计算值可以用来从其他可观察对象中派生信息。 计算值采用惰性求值，会缓存其输出，并且只有当其依赖的可观察对象被改变时才会重新计算。 它们在不被任何值观察时会被暂时停用。</p><p>计算值可以通过在 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">getters</a> 上添加 <code>computed</code> 注解来创建。 使用 <code>makeObservable</code> 将 getter 声明为 computed。或者如果你希望所有的 getters 被自动声明为 <code>computed</code>，可以使用 <code>makeAutoObservable</code>，<code>observable</code> 或者 <code>extendObservable</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, computed, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderLine</span> &#123;    price = <span class="hljs-number">0</span>    amount = <span class="hljs-number">1</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">price</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">price</span>: observable,            <span class="hljs-attr">amount</span>: observable,            <span class="hljs-attr">total</span>: computed        &#125;)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">total</span>() &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Computing...&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">amount</span>    &#125;&#125;<span class="hljs-keyword">const</span> order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderLine</span>(<span class="hljs-number">0</span>)<span class="hljs-keyword">const</span> stop = <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Total: &quot;</span> + order.<span class="hljs-property">total</span>)&#125;)<span class="hljs-comment">// Computing...</span><span class="hljs-comment">// Total: 0</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(order.<span class="hljs-property">total</span>)<span class="hljs-comment">// (不会重新计算!)</span><span class="hljs-comment">// 0</span>order.<span class="hljs-property">amount</span> = <span class="hljs-number">5</span><span class="hljs-comment">// Computing...</span><span class="hljs-comment">// (无需 autorun)</span>order.<span class="hljs-property">price</span> = <span class="hljs-number">2</span><span class="hljs-comment">// Computing...</span><span class="hljs-comment">// Total: 10</span><span class="hljs-title function_">stop</span>()order.<span class="hljs-property">price</span> = <span class="hljs-number">3</span><span class="hljs-comment">// 计算值和 autorun 都不会被重新计算.</span></code></pre></div><p>相比之下，如果 <code>total</code> 没有被注解，那么 <code>autorun</code> 会把副作用运行 3 次， 因为它将直接依赖于 <code>total</code> 和 <code>amount</code></p><p><img src="https://zh.mobx.js.org/assets/computed-example.png" alt="computed graph"></p><p>上图是为以上示例创建的依赖图。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>使用计算值时，请遵循下面的最佳实践：</p><ol><li>它们不应该有副作用或者更新其他可观察对象。</li><li>避免创建和返回新的可观察对象。</li><li>它们不应该依赖非可观察对象的值</li></ol><h2 id="使用-reactions-处理副作用-🚀"><a href="#使用-reactions-处理副作用-🚀" class="headerlink" title="使用 reactions 处理副作用 {🚀}"></a>使用 reactions 处理副作用 {🚀}</h2><p>为了理解 MobX，让我们看一下如何创建 reactions。 最简单的方式是使用 <a href="https://zh.mobx.js.org/reactions.html#autorun"><code>autorun</code></a> 工具函数。 除此之外，还有 <a href="https://zh.mobx.js.org/reactions.html#reaction"><code>reaction</code></a> 和 <a href="https://zh.mobx.js.org/reactions.html#when"><code>when</code></a></p><h3 id="Autorun"><a href="#Autorun" class="headerlink" title="Autorun"></a>Autorun</h3><p>用法：</p><ul><li><code>autorun(effect: (reaction) =&gt; void)</code></li></ul><p><code>autorun</code> 函数接受一个函数作为参数，每当该函数所观察的值发生变化时，它都应该运行。 当你自己创建 <code>autorun</code> 时，它也会运行一次。它仅仅对可观察状态的变化做出响应，比如那些你用 <code>observable</code> 或者 <code>computed</code> 注释的。</p><h3 id="tracking-如何工作"><a href="#tracking-如何工作" class="headerlink" title="tracking 如何工作"></a>tracking 如何工作</h3><p>Autorun 通过在<em>响应式上下文</em>运行 <code>effect</code> 来工作。在给定的函数执行期间，MobX 会持续跟踪被 effect 直接或间接<em>读取</em>过的所有可观察对象和计算值。 一旦函数执行完毕，MobX 将收集并订阅所有被读取过的可观察对象，并等待其中任意一个再次发生改变。 一旦有改变发生，<code>autorun</code> 将会再次触发，重复整个过程。</p><p><img src="https://zh.mobx.js.org/assets/autorun.png" alt="autorun"></p><p>这就是下面的示例的工作方式。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;    name    energyLevel    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> = <span class="hljs-number">100</span>        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">reduceEnergy</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> -= <span class="hljs-number">10</span>    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">isHungry</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> &lt; <span class="hljs-number">50</span>    &#125;&#125;<span class="hljs-keyword">const</span> giraffe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Gary&quot;</span>)<span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Energy level:&quot;</span>, giraffe.<span class="hljs-property">energyLevel</span>)&#125;)<span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (giraffe.<span class="hljs-property">isHungry</span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now I&#x27;m hungry!&quot;</span>)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I&#x27;m not hungry!&quot;</span>)    &#125;&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now let&#x27;s change state!&quot;</span>)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    giraffe.<span class="hljs-title function_">reduceEnergy</span>()&#125;</code></pre></div><p>运行上面的代码，你将会看到下面的输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">100</span><span class="hljs-attribute">I</span>&#x27;m not hungry!<span class="hljs-attribute">Now</span> let&#x27;s change state!<span class="hljs-attribute">Energy</span> level: <span class="hljs-number">90</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">80</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">70</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">60</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">50</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">40</span><span class="hljs-attribute">Now</span> I&#x27;m hungry!<span class="hljs-attribute">Energy</span> level: <span class="hljs-number">30</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">20</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">10</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">0</span></code></pre></div><p>autorun会比较前后值是否发生了改变，如果没有发生改变，就不会执行，当值发生变化的时候，才会重新执行</p><h3 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h3><p>用法：</p><ul><li><code>reaction(() =&gt; value, (value, previousValue, reaction) =&gt; &#123; sideEffect &#125;, options?)</code>.</li></ul><p>第一个参数，是指需要监听那个state的变化，第二个参数是当数据变化的时候需要执行的函数，reaction</p><p>和autorun比较，autorun是针对所有的state，reaction是针对特定的state，而且reaction在初始化，不会执行，只有在state</p><p>发生变化时才会执行</p><p>在下面的例子中，reaction 只会在 <code>isHungry</code> 发生改变时被触发一次。 在 <em>effect</em> 函数中使用的 <code>giraffe.energyLevel</code> 的更改，并不会触发 <em>effect</em> 函数。如果你想要 <code>reaction</code> 也对这个值的变化做出反应， 你需要在 <em>data</em> 函数中访问并返回它。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; makeAutoObservable, reaction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;    name    energyLevel    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> = <span class="hljs-number">100</span>        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">reduceEnergy</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> -= <span class="hljs-number">10</span>    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">isHungry</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> &lt; <span class="hljs-number">50</span>    &#125;&#125;<span class="hljs-keyword">const</span> giraffe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Gary&quot;</span>)<span class="hljs-title function_">reaction</span>(    <span class="hljs-function">() =&gt;</span> giraffe.<span class="hljs-property">isHungry</span>,    <span class="hljs-function"><span class="hljs-params">isHungry</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (isHungry) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now I&#x27;m hungry!&quot;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I&#x27;m not hungry!&quot;</span>)        &#125;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Energy level:&quot;</span>, giraffe.<span class="hljs-property">energyLevel</span>)    &#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now let&#x27;s change state!&quot;</span>)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    giraffe.<span class="hljs-title function_">reduceEnergy</span>()&#125;</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs pf">Now let&#x27;s change <span class="hljs-keyword">state</span>!Now I&#x27;m hungry!Energy level: <span class="hljs-number">40</span></code></pre></div><h3 id="When"><a href="#When" class="headerlink" title="When"></a>When</h3><p>使用：</p><ul><li><code>when(predicate: () =&gt; boolean, effect?: () =&gt; void, options?)</code></li><li><code>when(predicate: () =&gt; boolean, options?): Promise</code></li></ul><p><code>when</code> 会观察并运行给定的 <em>predicate</em> 函数，直到其返回 <code>true</code>。 一旦 predicate 返回了 true，给定的 <em>effect</em> 函数就会执行并且自动执行器函数将会被清理掉。</p><p>如果你没有传入 <code>effect</code> 函数，<code>when</code> 函数返回一个 <code>Promise</code> 类型的 disposer，并允许你手动取消</p><p><code>when</code> 对于以响应式的方式将值清理或取消掉十分有用。 例如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; when, makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span> &#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123; <span class="hljs-attr">dispose</span>: <span class="hljs-literal">false</span> &#125;)        <span class="hljs-title function_">when</span>(            <span class="hljs-comment">// Once...</span>            <span class="hljs-function">() =&gt;</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isVisible</span>,            <span class="hljs-comment">// ... then.</span>            <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispose</span>()        )    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">isVisible</span>() &#123;        <span class="hljs-comment">// 表示此项目是否可见.</span>    &#125;    <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 清理一些资源.</span>    &#125;&#125;</code></pre></div><p>一旦 <code>isVisible</code> 变成 <code>false</code>，<code>dispose</code> 方法将会被调用， 并对 <code>MyResource</code> 做一些清理操作</p><h3 id="await-when"><a href="#await-when" class="headerlink" title="await when(...)"></a><code>await when(...)</code></h3><p>如果你没有提供 <code>effect</code> 函数，<code>when</code> 将会返回一个 <code>Promise</code>。这样会跟 <code>async / await</code> 很好地结合在一起，让你可以等待可观察对象中的变化。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">await</span> <span class="hljs-title function_">when</span>(<span class="hljs-function">() =&gt;</span> that.<span class="hljs-property">isVisible</span>)    <span class="hljs-comment">// etc...</span>&#125;</code></pre></div><p>如果要提前取消 <code>when</code>，可以对它返回的 Promise 调用 <code>.cancel()</code> 函数。</p><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><p>这里是一些 reactive context 需要遵守的规则：</p><ol><li>默认情况下，如果可观察对象发生了改变，受其影响的 reactions 会立即（同步）运行。然而，它们直到当前最外层的 (trans)action 执行结束后才会运行。</li><li>autorun 只会跟踪给定函数在同步执行过程中所读取的可观察对象，不会跟踪异步发生的变化。</li><li>autorun 不会跟踪被其调用的 action 所读取的可观察对象，因为 action 始终<em>不会被追踪</em>。</li></ol><h3 id="Always-dispose-of-reactions"><a href="#Always-dispose-of-reactions" class="headerlink" title="Always dispose of reactions"></a>Always dispose of reactions</h3><p>传递给 <code>autorun</code>，<code>reaction</code> 和 <code>when</code> 的函数只有在它们观察的所有对象都被 GC 之后才会被 GC。原则上，它们一直等待可观察对象发生新的变化。 为了阻止 reactions 永远地等待下去，它们总是会返回一个 disposer 函数，该函数可以用来停止执行并且取消订阅所使用的任何可观察对象</p><div class="code-wrapper"><pre><code class="hljs arcade">const counter = observable(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-comment">// 初始化一个 autorun 并且打印 0.</span>const disposer = autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(counter.<span class="hljs-built_in">count</span>)&#125;)<span class="hljs-comment">// 打印: 1</span>counter.<span class="hljs-built_in">count</span>++<span class="hljs-comment">// 停止 autorun.</span>disposer()<span class="hljs-comment">// 不会打印消息.</span>counter.<span class="hljs-built_in">count</span>++</code></pre></div><p>我们强烈建议你，一旦不再需要这些方法中的副作用时，请务必调用它们所返回的 disposer 函数。 否则可能导致内存泄漏。</p><p><code>reaction</code> 和 <code>autorun</code> 中 effect 函数的第二个参数 <code>reaction</code> 也可以被用来提前把 reaction 清理掉（通过调用 <code>reaction.dispose()</code>）。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vat</span> &#123;    value = <span class="hljs-number">1.2</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;&#125;<span class="hljs-keyword">const</span> vat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vat</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderLine</span> &#123;    price = <span class="hljs-number">10</span>    amount = <span class="hljs-number">1</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)        <span class="hljs-comment">// 这个 autorun 将会和本 OrderLine 实例一起进行 GC,</span>        <span class="hljs-comment">// 因为它只使用了来自 `this` 的可观察对象.</span>        <span class="hljs-comment">// 所以不一定非要在删除 OrderLine 实例后立刻把它清理掉。</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disposer1</span> = <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">doSomethingWith</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">amount</span>)        &#125;)        <span class="hljs-comment">// 这个 autorun 将不会和本 OrderLine 实例一起进行 GC,</span>        <span class="hljs-comment">// 因为 vat 保存了对这个 autorun 的引用用于通知改变,</span>        <span class="hljs-comment">// 这样反过来又会把 &#x27;this&#x27; 保存在作用域中。</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disposer2</span> = <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">doSomethingWith</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">amount</span> * vat.<span class="hljs-property">value</span>)        &#125;)    &#125;    <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 所以, 为了避免内存问题, 当不再需要 reactions 之后</span>        <span class="hljs-comment">// 务必要调用 disposers.</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">disposer1</span>()        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">disposer2</span>()    &#125;&#125;</code></pre></div><h2 id="谨慎地使用-reactions！"><a href="#谨慎地使用-reactions！" class="headerlink" title="谨慎地使用 reactions！"></a>谨慎地使用 reactions！</h2><p>就像上面已经说过的那样，你不会经常创建 reactions。 很有可能你的应用程序不会直接使用这些 API 中的任何一个，而只会通过比如使用 mobx-react 绑定中的 <code>observer</code> 这样间接的方式创建出 reaction。</p><p>在你创建 reaction 之前，最好检查一下它是否符合下面几条原则：</p><ol><li><strong>只有在引起副作用的一方与副作用之间没有直接关系的情况下才使用 reaction</strong>： 如果一个副作用会为了响应很小的一组 events 或 actions 而执行，那么直接从那些特定的 action 中触发这个副作用通常会更容易理解。例如，如果按下表单提交按钮会导致一个 POST 网络请求的发送，那么为了响应 <code>onclick</code> 事件，直接触发这个副作用就会比通过 reaction 间接触发更容易理解。相比之下，如果你对表单状态的一切修改最后都会被自动存储到 localStorage，那么使用一个 reaction 可能就会很有帮助，这样你就不用在每个独立的 <code>onChange</code> 事件中触发这个副作用了。</li><li><strong>reactions 不应该更新其他可观察对象</strong>：这个 reaction 是否会修改其他可观察对象？如果答案是肯定的，那么你一般应该把你想要更新的可观察对象注解为 <a href="https://zh.mobx.js.org/computeds.html"><code>computed</code></a> 值。例如，如果一个待办事项的集合 <code>todos</code> 发生了变化，那么请不要使用 reaction 来计算剩余待办 <code>remainingTodos</code> 的数量，而要把 <code>remainingTodos</code> 注解为计算值。这将使得代码更容易理解和调试。reaction 不应该计算生成新的数据，而只应该触发副作用。</li><li><strong>reactions 应该是独立的</strong>：你的代码是否依赖其他必须首先运行的 reaction？如果发生这种情况，你可能违反了第一条规则， 你可以选择将你需要创建的新 reaction 合并到它所依赖 reaction 中。MobX 并不能保证 reaction 的执行顺序。</li></ol><p>有些实践并不符合上述原则。这就是为什么它们是<em>原则</em>，而不是<em>法则</em>。 但是，例外情况很少见，只有在万不得已的情况下才违反它们。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>mobx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jest常见问题解析</title>
    <link href="/2022/09/19/jest%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/19/jest%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h4 id="jest-‘beforeEach’-is-not-defined-eslint-no-undef"><a href="#jest-‘beforeEach’-is-not-defined-eslint-no-undef" class="headerlink" title="##jest ‘beforeEach’ is not defined .eslint no-undef"></a>##jest ‘beforeEach’ is not defined .eslint no-undef</h4><p><img src="https://img1.imgtp.com/2022/09/19/mkE2sSaP.png" alt="QQ截图20220919211238.png"></p><p>需要在.eslintrc文件加上这一段</p><div class="code-wrapper"><pre><code class="hljs prolog">&#123;  <span class="hljs-string">&quot;overrides&quot;</span>: [    &#123;      <span class="hljs-string">&quot;files&quot;</span>: [        <span class="hljs-string">&quot;**/*.spec.js&quot;</span>,        <span class="hljs-string">&quot;**/*.spec.jsx&quot;</span>      ],      <span class="hljs-string">&quot;env&quot;</span>: &#123;        <span class="hljs-string">&quot;jest&quot;</span>: true      &#125;    &#125;  ]&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>单元测试</category>
      
      <category>jest</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第六章链表</title>
    <link href="/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AD%E7%AB%A0%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AD%E7%AB%A0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="Util-js"><a href="#Util-js" class="headerlink" title="Util.js"></a>Util.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;</code></pre></div><h2 id="linked-list-models-js"><a href="#linked-list-models-js" class="headerlink" title="linked-list-models.js"></a>linked-list-models.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义每个节点的信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">undefined</span>;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element, next, prev</span>) &#123;    <span class="hljs-variable language_">super</span>(element, next);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = prev;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePair</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`[<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.key&#125;</span>,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.value&#125;</span>]`</span>;  &#125;&#125;</code></pre></div><h2 id="普通链表"><a href="#普通链表" class="headerlink" title="普通链表"></a>普通链表</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defaultEquals &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Node</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">equalFn = defaultEquals</span>) &#123;    <span class="hljs-comment">// 用来存储链表中的元素数量</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-comment">//自定义 用来比较是否相等 如果没有定义则使用默认的比较方法</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">equalFn</span> = equalFn;  &#125;  <span class="hljs-comment">//向链表尾部添加一个新元素</span>  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);    <span class="hljs-comment">// 先判断链表为空的情况</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">undefined</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-comment">// 循环找到最后一个节点</span>      <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span> != <span class="hljs-literal">null</span>) &#123;        current = current.<span class="hljs-property">next</span>;      &#125;      current.<span class="hljs-property">next</span> = node;    &#125;    <span class="hljs-comment">// 数值加一</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;  &#125;  <span class="hljs-comment">// 向链表的特定位置插入一个新元素</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">element, position</span>) &#123;    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">const</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;        node.<span class="hljs-property">next</span> = current;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(position - <span class="hljs-number">1</span>);        <span class="hljs-keyword">const</span> current = previous.<span class="hljs-property">next</span>;        previous.<span class="hljs-property">next</span> = node;        node.<span class="hljs-property">next</span> = current;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 返回链表中特定位置的元素。如果链表中不存在这样的元素，则返回 undefined</span>  <span class="hljs-title function_">getElementAt</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index &amp;&amp; current != <span class="hljs-literal">null</span>; i++) &#123;      current = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> current;  &#125;  <span class="hljs-comment">// 从链表中移除一个元素</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">const</span> currentIndex = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">indexOf</span>(element);    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeAt</span>(currentIndex);  &#125;  <span class="hljs-comment">// 返回元素在链表中的索引。如果链表中没有该元素则返回-1</span>  <span class="hljs-title function_">indexOf</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &amp;&amp; current != <span class="hljs-literal">null</span>; i++) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">equalFn</span>(element, current.<span class="hljs-property">element</span>)) &#123;        <span class="hljs-keyword">return</span> i;      &#125;      current = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  &#125;  <span class="hljs-comment">// 从链表的特定位置移除一个元素</span>  <span class="hljs-title function_">removeAt</span>(<span class="hljs-params">position</span>) &#123;    <span class="hljs-comment">// 边界判断</span>    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> || position &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">let</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-comment">// 当是第一个值时</span>    <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = current.<span class="hljs-property">next</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// for循环拿到curent</span>      <span class="hljs-comment">// for (let i = 0; i &lt; position; i++) &#123;</span>      <span class="hljs-comment">//   /**</span>      <span class="hljs-comment">//    * 获得之前的值，当到达目标值的时候，current.next就指向下一个值了，previous指向前一个之</span>      <span class="hljs-comment">//    */</span>      <span class="hljs-comment">//   previous = current;</span>      <span class="hljs-comment">//   current = current.next;</span>      <span class="hljs-comment">// &#125;</span>      <span class="hljs-comment">// 重构</span>      previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(position - <span class="hljs-number">1</span>);      current = previous.<span class="hljs-property">next</span>;      previous.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;    <span class="hljs-keyword">return</span> current.<span class="hljs-property">element</span>;  &#125;  <span class="hljs-comment">// 如果链表中不包含任何元素，返回 true，如果链表长度大于 0则返回 false</span>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 返回链表包含的元素个数，与数组的 length 属性类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>;  &#125;  <span class="hljs-comment">// 返回表示整个链表的字符串。由于列表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值</span>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;    <span class="hljs-keyword">let</span> objString = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.head.element&#125;</span>`</span>;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &amp;&amp; current != <span class="hljs-literal">null</span>; i++) &#123;      objString += <span class="hljs-string">`,<span class="hljs-subst">$&#123;current.element&#125;</span>`</span>;      current = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> objString;  &#125;&#125;</code></pre></div><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">DoublyNode</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; defaultEquals &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./LinkedList.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">equalsFn = defaultEquals</span>) &#123;    <span class="hljs-variable language_">super</span>(equalsFn);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">element, index</span>) &#123;    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyNode</span>(element);      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (thid.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = node;        &#125; <span class="hljs-keyword">else</span> &#123;          node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;          current.<span class="hljs-property">prev</span> = node;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;        &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;        current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;        current.<span class="hljs-property">next</span> = node;        node.<span class="hljs-property">prev</span> = current;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = node;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index - <span class="hljs-number">1</span>);        current = previous.<span class="hljs-property">next</span>;        previous.<span class="hljs-property">next</span> = node;        node.<span class="hljs-property">prev</span> = previous;        node.<span class="hljs-property">next</span> = current;        current.<span class="hljs-property">prev</span> = node;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> falses;  &#125;  <span class="hljs-title function_">removeAt</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = current.<span class="hljs-property">next</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">1</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">undefined</span>;        &#125; <span class="hljs-keyword">else</span> &#123;          current.<span class="hljs-property">prev</span> = <span class="hljs-literal">undefined</span>;        &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>)) &#123;        current = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index);        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = current.<span class="hljs-property">prev</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">undefined</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        current = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index);        current.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;        current.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = current.<span class="hljs-property">prev</span>;        current.<span class="hljs-property">next</span> = <span class="hljs-literal">undefined</span>;        current.<span class="hljs-property">prev</span> = <span class="hljs-literal">undefined</span>;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;      <span class="hljs-keyword">return</span> current.<span class="hljs-property">element</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;&#125;</code></pre></div><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defaultEquals &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./LinkedList.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularLinkedList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">equalsFn = defaultEquals</span>) &#123;    <span class="hljs-variable language_">super</span>(equalsFn);  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">element, index</span>) &#123;    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;          node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;          current = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>());          current.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index - <span class="hljs-number">1</span>);        current = previous.<span class="hljs-property">next</span>;        previous.<span class="hljs-property">next</span> = node;        node.<span class="hljs-property">next</span> = currents;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-title function_">removeAt</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>()) &#123;      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">1</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">const</span> removed = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;          current = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>());          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;          current.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;          current = removed;        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index - <span class="hljs-number">1</span>);        current = previous.<span class="hljs-property">next</span>;        previous.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;      <span class="hljs-keyword">return</span> current.<span class="hljs-property">element</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;&#125;</code></pre></div><h2 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare, defaultEquals &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./LinkedList.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortLinkedList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">equalsFn = defaultEquals, compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">super</span>(equalsFn);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compareFn</span> = compareFn;  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">element, index = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>().<span class="hljs-title function_">insert</span>(element, index);    &#125;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getIndexNextSortedElement</span>(element);    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>().<span class="hljs-title function_">insert</span>(element, position);  &#125;  <span class="hljs-title function_">getIndexNextSortedElement</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>(); i++) &#123;      <span class="hljs-keyword">const</span> comp = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(element, current.<span class="hljs-property">element</span>);      <span class="hljs-keyword">if</span> (comp === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;        <span class="hljs-keyword">return</span> i;      &#125;      current = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> i;  &#125;&#125;</code></pre></div><h2 id="通过链表创建栈"><a href="#通过链表创建栈" class="headerlink" title="通过链表创建栈"></a>通过链表创建栈</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">DoublyLinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./DoublyLinkedList&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackLinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyLinkedList</span>();  &#125;  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">push</span>(element);  &#125;  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">removeAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">size</span>() - <span class="hljs-number">1</span>);  &#125;  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">getElementAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">size</span>() - <span class="hljs-number">1</span>);  &#125;  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">isEmpty</span>();  &#125;  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">size</span>();  &#125;  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">clear</span>();  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">toString</span>();  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第五章 队列与双端队列</title>
    <link href="/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="队列和双端队列"><a href="#队列和双端队列" class="headerlink" title="##队列和双端队列"></a>##队列和双端队列</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像上一章的 Stack</span><span class="hljs-comment">类那样。但是，为了写出一个在获取元素时更高效的数据结构，我们将使用一个对象来存储我们</span><span class="hljs-comment">的元素（行&#123;3&#125;）。你会发现 Queue 类和 Stack 类非常类似，只是添加和移除元素的原则不同</span><span class="hljs-comment">也可以声明一个 count 属性来帮助我们控制队列的大小（行&#123;1&#125;）。此外，由于我们将要从队</span><span class="hljs-comment">列前端移除元素，同样需要一个变量来帮助我们追踪第一个元素。因此，声明一个 lowestCount</span><span class="hljs-comment">变量（行&#123;2&#125;）</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">// 向队列尾部添加一个（或多个）新的项</span>  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">...elements</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>] = elements[i];      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;    &#125;  &#125;  <span class="hljs-comment">// 移除队列的第一项（即排在队列最前面的项）并返回被移除的元素</span>  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>++;    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">// 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做</span>  <span class="hljs-comment">// 任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。该方</span>  <span class="hljs-comment">// 法在其他语言中也可以叫作 front 方法</span>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];  &#125;  <span class="hljs-comment">// 如果队列中不包含任何元素，返回 true，否则返回 false</span>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 返回队列包含的元素个数，与数组的 length 属性类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>;  &#125;  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> str;    &#125;    str = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>; i++) &#123;      str += <span class="hljs-string">`,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.items[i]&#125;</span>`</span>;    &#125;    <span class="hljs-keyword">return</span> str;  &#125;&#125;<span class="hljs-comment">// const queue = new Queue();</span><span class="hljs-comment">// console.log(queue.isEmpty()); // 输出 true</span><span class="hljs-comment">// queue.enqueue(&quot;John&quot;);</span><span class="hljs-comment">// queue.enqueue(&quot;Jack&quot;);</span><span class="hljs-comment">// console.log(queue.toString()); // John,Jack</span><span class="hljs-comment">// queue.enqueue(&quot;Camila&quot;);</span><span class="hljs-comment">// console.log(queue.toString()); // John, Jack, Camila</span><span class="hljs-comment">// console.log(queue.size()); // 输出 3</span><span class="hljs-comment">// console.log(queue.isEmpty()); // 输出 false</span><span class="hljs-comment">// queue.dequeue(); // 移除 John</span><span class="hljs-comment">// queue.dequeue(); // 移除 Jack</span><span class="hljs-comment">// console.log(queue.toString()); // Camila</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Queue</span>;</code></pre></div><h4 id="双端队列数据结构"><a href="#双端队列数据结构" class="headerlink" title="双端队列数据结构"></a>双端队列数据结构</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Deque</span> &#123;  <span class="hljs-comment">// 双端队列，遵循先进先出和后进先出</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> === <span class="hljs-number">0</span>;  &#125;  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> str;    &#125;    str = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>; i++) &#123;      str += <span class="hljs-string">`,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.items[i]&#125;</span>`</span>;    &#125;    <span class="hljs-keyword">return</span> str;  &#125;  <span class="hljs-comment">// 该方法在双端队列前端添加新的元素</span>  <span class="hljs-title function_">addFront</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addBack</span>(element);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>--;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>] = element;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i - <span class="hljs-number">1</span>];      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-number">0</span>] = element;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;    &#125;  &#125;  <span class="hljs-comment">// 该方法在双端队列后端添加新的元素（实现方法和 Queue 类中的enqueue 方法相同）</span>  <span class="hljs-title function_">addBack</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>] = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;  &#125;  <span class="hljs-comment">// 该方法会从双端队列前端移除第一个元素（实现方法和 Queue 类中的dequeue 方法相同）</span>  <span class="hljs-title function_">removeFront</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>++;    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">//该方法会从双端队列后端移除第一个元素（实现方法和 Stack 类中的pop 方法一样）。</span>  <span class="hljs-title function_">removeBack</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">// 该方法返回双端队列前端的第一个元素（实现方法和 Queue 类中的 peek方法一样）。</span>  <span class="hljs-title function_">peekFront</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];  &#125;  <span class="hljs-comment">// 该方法返回双端队列后端的第一个元素（实现方法和 Stack 类中的 peek方法一样）</span>  <span class="hljs-title function_">peekBack</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];  &#125;&#125;<span class="hljs-comment">// const deque = new Deque();</span><span class="hljs-comment">// console.log(deque.isEmpty()); // 输出 true</span><span class="hljs-comment">// deque.addBack(&quot;John&quot;);</span><span class="hljs-comment">// deque.addBack(&quot;Jack&quot;);</span><span class="hljs-comment">// console.log(deque.toString()); // John, Jack</span><span class="hljs-comment">// deque.addBack(&quot;Camila&quot;);</span><span class="hljs-comment">// console.log(deque.toString()); // John, Jack, Camila</span><span class="hljs-comment">// console.log(deque.size()); // 输出 3</span><span class="hljs-comment">// console.log(deque.isEmpty()); // 输出 false</span><span class="hljs-comment">// deque.removeFront(); // 移除 John</span><span class="hljs-comment">// console.log(deque.toString()); // Jack, Camila</span><span class="hljs-comment">// deque.removeBack(); // Camila 决定离开</span><span class="hljs-comment">// console.log(deque.toString()); // Jack</span><span class="hljs-comment">// deque.addFront(&quot;John&quot;); // John 回来询问一些信息</span><span class="hljs-comment">// console.log(deque.toString()); // John, Jack</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Deque</span>;</code></pre></div><h4 id="使用队列和双端队列来解决问题"><a href="#使用队列和双端队列来解决问题" class="headerlink" title="使用队列和双端队列来解决问题"></a>使用队列和双端队列来解决问题</h4><h5 id="循环队列——击鼓传花游戏"><a href="#循环队列——击鼓传花游戏" class="headerlink" title="循环队列——击鼓传花游戏"></a>循环队列——击鼓传花游戏</h5><p>这其中的一种叫作循环队列。循环队列的一个例子就是击鼓传花游戏（hot  potato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）。</p><p>实现一个模拟的击鼓传花游戏，要用到本章开头实现的 Queue 类（行{1}）。我们会得到一 份名单，把里面的名字全都加入队列（行{2}）。给定一个数字，然后迭代队列。从队列开头移 除一项，再将其添加到队列末尾（行{3}），模拟击鼓传花（如果你把花传给了旁边的人，你被 淘汰的威胁就立刻解除了）。一旦达到给定的传递次数，拿着花的那个人就被淘汰了（从队列中 移除——行{4}）。最后只剩下一个人的时候，这个人就是胜者（行{5}）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Queue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Queue.js&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">hotPotato</span>(<span class="hljs-params">elementsList, num</span>) &#123;  <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();  <span class="hljs-keyword">const</span> elimitatedList = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elementsList.<span class="hljs-property">length</span>; i++) &#123;    queue.<span class="hljs-title function_">enqueue</span>(elementsList[i]);  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue.<span class="hljs-title function_">toString</span>(), <span class="hljs-string">&quot;----&quot;</span>);  <span class="hljs-keyword">while</span> (queue.<span class="hljs-title function_">size</span>() &gt; <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;      queue.<span class="hljs-title function_">enqueue</span>(queue.<span class="hljs-title function_">dequeue</span>());    &#125;    elimitatedList.<span class="hljs-title function_">push</span>(queue.<span class="hljs-title function_">dequeue</span>());  &#125;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">winner</span>: queue.<span class="hljs-title function_">dequeue</span>(),    <span class="hljs-attr">eliminated</span>: elimitatedList,  &#125;;&#125;<span class="hljs-keyword">const</span> names = [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Camila&quot;</span>, <span class="hljs-string">&quot;Ingrid&quot;</span>, <span class="hljs-string">&quot;Carl&quot;</span>];<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">hotPotato</span>(names, <span class="hljs-number">7</span>);result.<span class="hljs-property">eliminated</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。`</span>);&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`胜利者： <span class="hljs-subst">$&#123;result.winner&#125;</span>`</span>);</code></pre></div><p>以上算法的输出如下。</p><p> Camila 在击鼓传花游戏中被淘汰。</p><p> Jack 在击鼓传花游戏中被淘汰。</p><p> Carl 在击鼓传花游戏中被淘汰。</p><p> Ingrid 在击鼓传花游戏中被淘汰。 </p><p> 胜利者：John</p><h5 id="回文检查器"><a href="#回文检查器" class="headerlink" title="回文检查器"></a>回文检查器</h5><p>下面是维基百科对回文的解释。 回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。 有不同的算法可以检查一个词组或字符串是否为回文。最简单的方式是将字符串反向排列并 检查它和原字符串是否相同。如果两者相同，那么它就是一个回文。我们也可以用栈来完成，但 是利用数据结构来解决这个问题的最简单方法是使用双端队列</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Deque</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Deque.js&quot;</span>;<span class="hljs-comment">// 回文字符串检测</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-params">aString</span>) &#123;  <span class="hljs-keyword">if</span> (aString == <span class="hljs-literal">null</span> || (aString != <span class="hljs-literal">null</span> &amp;&amp; aString.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 判断是否相等，不相等就返回</span>  <span class="hljs-keyword">let</span> isEqual = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 获得第一个和最后一个字符</span>  <span class="hljs-keyword">let</span> firstChar, lastChar;  <span class="hljs-keyword">const</span> deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deque</span>();  <span class="hljs-comment">// 先将字符串转成小写然后再去掉空格重新拼接</span>  aString = aString.<span class="hljs-title function_">toLocaleLowerCase</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(aString);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; aString.<span class="hljs-property">length</span>; i++) &#123;    deque.<span class="hljs-title function_">addBack</span>(aString.<span class="hljs-title function_">charAt</span>(i));  &#125;  <span class="hljs-comment">// while循环拿到第一个和最后一个进行比较，只有在isEqual为true才继续比奥,只有一个的时候跳出</span>  <span class="hljs-keyword">while</span> (deque.<span class="hljs-title function_">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; isEqual) &#123;    firstChar = deque.<span class="hljs-title function_">removeFront</span>();    lastChar = deque.<span class="hljs-title function_">removeBack</span>();    <span class="hljs-keyword">if</span> (lastChar !== firstChar) &#123;      isEqual = <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> isEqual;&#125;<span class="hljs-comment">// 全是true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;a&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;aa&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;kayak&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;kayak&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;level&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;level&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(  <span class="hljs-string">&quot;Was it a car or a cat I saw&quot;</span>,  <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;Was it a car or a cat I saw&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Step on no pets&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;Step on no pets&quot;</span>));</code></pre></div><p>在我们开始解释算法逻辑之前，需要检查传入的字符串参数是否合法（行{1}）。如果不合 法，我们返回 false。 对于这个算法，我们将使用在本章实现的 Deque 类（行{2}）。由于可能接收到同时包含大 小写字母的字符串，我们会将所有字母转化为小写，同时移除所有的空格（行{3}）。如果你愿意， 也可以移除所有的特殊字符，例如!、?、-、(和)等。为了保证算法简洁，我们会跳过这部分。 然后，我们会对字符串中的所有字符执行 enqueue 操作（行{4}）。如果所有元素都在双端 队列中（如果只有一个字符的话，那它肯定是回文）并且首尾字符相同的话（行{5}），我们将 从前端移除一个元素（行{6}），再从后端移除一个元素（行{7}）。要使字符串为回文，移除的 两个字符必须相同。如果字符不同的话，这个字符串就不是一个回文（行{8}）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jest学习笔记</title>
    <link href="/2022/09/16/jest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/16/jest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="Jest安装"><a href="#Jest安装" class="headerlink" title="##Jest安装"></a>##Jest安装</h4><div class="code-wrapper"><pre><code class="hljs q">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> jest</code></pre></div><h4 id="常见的匹配器"><a href="#常见的匹配器" class="headerlink" title="常见的匹配器"></a>常见的匹配器</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;two plus two is four&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">4</span>);&#125;);</code></pre></div><p><code>toBe</code>使用 <code>Object.is</code>来进行精准匹配的测试。 如果您想要检查对象的值，请使用 <code>toEqual</code> 代替：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;对象赋值&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>&#125;;  data[<span class="hljs-string">&#x27;two&#x27;</span>] = <span class="hljs-number">2</span>;  <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toEqual</span>(&#123;<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">two</span>: <span class="hljs-number">2</span>&#125;);&#125;);</code></pre></div><p><code>toEqual</code> 递归检查对象或数组的每个字段</p><h5 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h5><p>代码中的<code>undefined</code>, <code>null</code>, and <code>false</code>有不同含义，若你在测试时不想区分他们，可以用真值判断。 Jest提供helpers供你使用。</p><ul><li><code>toBeNull</code> 只匹配 <code>null</code></li><li><code>toBeUndefined</code> 只匹配 <code>undefined</code></li><li><code>toBeDefined</code> 与 <code>toBeUndefined</code> 相反</li><li><code>toBeTruthy</code> 匹配任何 <code>if</code> 语句为真</li><li><code>toBeFalsy</code> 匹配任何 <code>if</code> 语句为假</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span>;  <span class="hljs-title function_">expect</span>(n).<span class="hljs-title function_">toBeNull</span>();  <span class="hljs-title function_">expect</span>(n).<span class="hljs-title function_">toBeDefined</span>();  <span class="hljs-title function_">expect</span>(n).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeUndefined</span>();  <span class="hljs-title function_">expect</span>(n).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeTruthy</span>();  <span class="hljs-title function_">expect</span>(n).<span class="hljs-title function_">toBeFalsy</span>();&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;zero&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> z = <span class="hljs-number">0</span>;  <span class="hljs-title function_">expect</span>(z).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeNull</span>();  <span class="hljs-title function_">expect</span>(z).<span class="hljs-title function_">toBeDefined</span>();  <span class="hljs-title function_">expect</span>(z).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeUndefined</span>();  <span class="hljs-title function_">expect</span>(z).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeTruthy</span>();  <span class="hljs-title function_">expect</span>(z).<span class="hljs-title function_">toBeFalsy</span>();&#125;);</code></pre></div><h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h5><p>大多数的比较数字有等价的匹配器</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;two plus two&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> value = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeGreaterThan</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//大于</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeGreaterThanOrEqual</span>(<span class="hljs-number">3.5</span>);<span class="hljs-comment">//大于等于</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeLessThan</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//小于</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeLessThanOrEqual</span>(<span class="hljs-number">4.5</span>);<span class="hljs-comment">//小于等于</span>  <span class="hljs-comment">// toBe and toEqual are equivalent for numbers</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">4</span>);  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toEqual</span>(<span class="hljs-number">4</span>);&#125;);</code></pre></div><p>对于比较浮点数相等，使用 <code>toBeCloseTo</code> 而不是 <code>toEqual</code>，因为你不希望测试取决于一个小小的舍入误差。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;两个浮点数字相加&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> value = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;  <span class="hljs-comment">//expect(value).toBe(0.3);           这句会报错，因为浮点数有舍入误差</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeCloseTo</span>(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// 这句可以运行</span>&#125;);&#125;);</code></pre></div><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>您可以检查对具有 <code>toMatch</code> 正则表达式的字符串︰</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;there is no I in team&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(<span class="hljs-string">&#x27;team&#x27;</span>).<span class="hljs-property">not</span>.<span class="hljs-title function_">toMatch</span>(<span class="hljs-regexp">/I/</span>);&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;but there is a &quot;stop&quot; in Christoph&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(<span class="hljs-string">&#x27;Christoph&#x27;</span>).<span class="hljs-title function_">toMatch</span>(<span class="hljs-regexp">/stop/</span>);&#125;);</code></pre></div><h5 id="数组和可迭代对象"><a href="#数组和可迭代对象" class="headerlink" title="数组和可迭代对象"></a>数组和可迭代对象</h5><p> <code>toContain</code>来检查一个数组或可迭代对象是否包含某个特定项</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> shoppingList = [  <span class="hljs-string">&#x27;diapers&#x27;</span>,  <span class="hljs-string">&#x27;kleenex&#x27;</span>,  <span class="hljs-string">&#x27;trash bags&#x27;</span>,  <span class="hljs-string">&#x27;paper towels&#x27;</span>,  <span class="hljs-string">&#x27;milk&#x27;</span>,];<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;shoppingList数组中包含milk&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(shoppingList).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">&#x27;milk&#x27;</span>);  <span class="hljs-title function_">expect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(shoppingList)).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">&#x27;milk&#x27;</span>);&#125;);</code></pre></div><h5 id="thorw"><a href="#thorw" class="headerlink" title="thorw"></a>thorw</h5><p>你想测试某函数在调用时是否抛出了错误，你需要使用 <code>toThrow</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compileAndroidCode</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;you are using the wrong JDK&#x27;</span>);&#125;<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;compiling android goes as expected&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compileAndroidCode</span>()).<span class="hljs-title function_">toThrow</span>();  <span class="hljs-title function_">expect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compileAndroidCode</span>()).<span class="hljs-title function_">toThrow</span>(<span class="hljs-title class_">Error</span>);  <span class="hljs-comment">// 你可以自己定义确切的错误消息内容或者使用正则表达式</span>  <span class="hljs-title function_">expect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compileAndroidCode</span>()).<span class="hljs-title function_">toThrow</span>(<span class="hljs-string">&#x27;you are using the wrong JDK&#x27;</span>);  <span class="hljs-title function_">expect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compileAndroidCode</span>()).<span class="hljs-title function_">toThrow</span>(<span class="hljs-regexp">/JDK/</span>);&#125;);</code></pre></div><h4 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h4><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>为你的测试返回一个Promise，则Jest会等待Promise的resove状态 如果 Promise 的状态变为 rejected, 测试将会失败</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the data is peanut butter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;peanut butter&#x27;</span>);  &#125;);&#125;);</code></pre></div><h5 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the data is peanut butter&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();  <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;peanut butter&#x27;</span>);&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the fetch fails with an error&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  expect.<span class="hljs-title function_">assertions</span>(<span class="hljs-number">1</span>);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-title function_">expect</span>(e).<span class="hljs-title function_">toMatch</span>(<span class="hljs-string">&#x27;error&#x27;</span>);  &#125;&#125;);</code></pre></div><p>你也可以将 <code>async</code> and <code>await</code>和 <code>.resolves</code> or <code>.rejects</code>一起使用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the data is peanut butter&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">fetchData</span>()).<span class="hljs-property">resolves</span>.<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;peanut butter&#x27;</span>);&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the fetch fails with an error&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">fetchData</span>()).<span class="hljs-property">rejects</span>.<span class="hljs-title function_">toMatch</span>(<span class="hljs-string">&#x27;error&#x27;</span>);&#125;);</code></pre></div><p>如果期望Promise被Reject，则需要使用 <code>.catch</code> 方法。 请确保添加 <code>expect.assertions</code> 来验证一定数量的断言被调用。 否则，一个fulfilled状态的Promise不会让测试用例失败。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the fetch fails with an error&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  expect.<span class="hljs-title function_">assertions</span>(<span class="hljs-number">1</span>);  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-title function_">expect</span>(e).<span class="hljs-title function_">toMatch</span>(<span class="hljs-string">&#x27;error&#x27;</span>));&#125;);</code></pre></div><h5 id="测试回调函数"><a href="#测试回调函数" class="headerlink" title="测试回调函数"></a>测试回调函数</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the data is peanut butter&#x27;</span>, <span class="hljs-function"><span class="hljs-params">done</span> =&gt;</span> &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">error, data</span>) &#123;    <span class="hljs-keyword">if</span> (error) &#123;      <span class="hljs-title function_">done</span>(error);      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;peanut butter&#x27;</span>);      <span class="hljs-title function_">done</span>();    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">done</span>(error);    &#125;  &#125;  <span class="hljs-title function_">fetchData</span>(callback);&#125;);</code></pre></div><p>测试回调函数时，需要使用done方法，不能直接传入一个函数，否则没办法测试，需要使用上上面的格式</p><h5 id="resolves-rejects"><a href="#resolves-rejects" class="headerlink" title=".resolves / .rejects"></a><code>.resolves</code> / <code>.rejects</code></h5><p>您还可以使用 <code>.resolves</code> 匹配器在您期望的声明，Jest 会等待这一 Promise 来解决。 如果 Promise 被拒绝，则测试将自动失败。</p><div class="code-wrapper"><pre><code class="hljs lisp">test(&#x27;the data is peanut butter&#x27;, () =&gt; &#123;  return expect(<span class="hljs-name">fetchData</span>()).resolves.toBe(&#x27;peanut butter&#x27;)<span class="hljs-comment">;</span>&#125;)<span class="hljs-comment">;</span></code></pre></div><p>必须要使用return，在 <code>fetchData</code> 返回的这个 promise 变更为 resolved 状态、then() 有机会执行之前，测试就已经被视为已经完成了。</p><p>如果你希望Promise返回rejected，你需要使用 <code>.rejects</code> 匹配器。 它和 <code>.resolves</code> 匹配器是一样的使用方式。 如果 Promise 被拒绝，则测试将自动失败。</p><div class="code-wrapper"><pre><code class="hljs lisp">test(&#x27;the fetch fails with an error&#x27;, () =&gt; &#123;  return expect(<span class="hljs-name">fetchData</span>()).rejects.toMatch(&#x27;error&#x27;)<span class="hljs-comment">;</span>&#125;)<span class="hljs-comment">;</span></code></pre></div><h4 id="Jest的钩子函数"><a href="#Jest的钩子函数" class="headerlink" title="Jest的钩子函数"></a>Jest的钩子函数</h4><p>jest有4个钩子函数</p><ul><li>beforeAll()钩子函数会在所有的测试用例之前执行  只会执行一次</li><li>beforeEach()钩子函数 会在每个测试用例执行之前执行一次，每个测试用例执行前都会执行一次</li><li>afterEach() 钩子函数会在每个测试用里执行完之后执行执行一次</li><li>alfterAll() 钩子函数会在所有用力执行完后执行</li></ul><h4 id="生成jest配置文件jest-config-js"><a href="#生成jest配置文件jest-config-js" class="headerlink" title="生成jest配置文件jest.config.js"></a>生成jest配置文件jest.config.js</h4><div class="code-wrapper"><pre><code class="hljs ada">npx jest <span class="hljs-comment">--init</span></code></pre></div><h4 id="mock函数"><a href="#mock函数" class="headerlink" title="mock函数"></a>mock函数</h4><p>Mock 函数允许你测试代码之间的连接——实现方式包括：擦除函数的实际实现、捕获对函数的调用 ( 以及在这些调用中传递的参数) 、在使用 <code>new</code> 实例化时捕获构造函数的实例、允许测试时配置返回值。</p><p>有两种方法可以模拟函数：要么在测试代码中创建一个 mock 函数，要么编写一个<a href="https://jestjs.io/zh-Hans/docs/manual-mocks"><code>手动 mock</code></a>来覆盖模块依赖。</p><h5 id="使用-mock-函数"><a href="#使用-mock-函数" class="headerlink" title="使用 mock 函数"></a>使用 mock 函数<a href="https://jestjs.io/zh-Hans/docs/mock-functions#%E4%BD%BF%E7%94%A8-mock-%E5%87%BD%E6%95%B0"></a></h5><p>假设我们要测试函数 <code>forEach</code> 的内部实现，这个函数为传入的数组中的每个元素调用一次回调函数。</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">forEach</span>(items, callback) &#123;  <span class="hljs-keyword">for</span> (let <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">index</span> &lt; items.length; <span class="hljs-keyword">index</span>++) &#123;    callback(items[<span class="hljs-keyword">index</span>]);  &#125;&#125;</code></pre></div><p>为了测试此函数，我们可以使用一个 mock 函数，然后检查 mock 函数的状态来确保回调函数如期调用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mockCallback = jest.<span class="hljs-title function_">fn</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-number">42</span> + x);<span class="hljs-title function_">forEach</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], mockCallback);<span class="hljs-comment">// 此 mock 函数被调用了两次</span><span class="hljs-title function_">expect</span>(mockCallback.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 第一次调用函数时的第一个参数是 0</span><span class="hljs-title function_">expect</span>(mockCallback.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 第二次调用函数时的第一个参数是 1</span><span class="hljs-title function_">expect</span>(mockCallback.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// 第一次函数调用的返回值是 42</span><span class="hljs-title function_">expect</span>(mockCallback.<span class="hljs-property">mock</span>.<span class="hljs-property">results</span>[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">42</span>);</code></pre></div><h5 id="mock-属性"><a href="#mock-属性" class="headerlink" title=".mock 属性"></a><code>.mock</code> 属性</h5><p>所有的 mock 函数都有这个特殊的 <code>.mock</code>属性，它保存了关于此函数如何被调用、调用时的返回值的信息。 <code>.mock</code> 属性还追踪每次调用时 <code>this</code>的值，所以我们同样可以也检视（inspect） <code>this</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myMock1 = jest.<span class="hljs-title function_">fn</span>();<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myMock1</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMock1.<span class="hljs-property">mock</span>.<span class="hljs-property">instances</span>);<span class="hljs-comment">// &gt; [ &lt;a&gt; ]</span><span class="hljs-keyword">const</span> myMock2 = jest.<span class="hljs-title function_">fn</span>();<span class="hljs-keyword">const</span> b = &#123;&#125;;<span class="hljs-keyword">const</span> bound = myMock2.<span class="hljs-title function_">bind</span>(b);<span class="hljs-title function_">bound</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMock2.<span class="hljs-property">mock</span>.<span class="hljs-property">contexts</span>);<span class="hljs-comment">// &gt; [ &lt;b&gt; ]</span></code></pre></div><p>这些 mock 成员变量在测试中非常有用，用于说明这些 function 是如何被调用、实例化或返回的：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// The function was called exactly once</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// The first arg of the first call to the function was &#x27;first arg&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;first arg&#x27;</span>);<span class="hljs-comment">// The second arg of the first call to the function was &#x27;second arg&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;second arg&#x27;</span>);<span class="hljs-comment">// The return value of the first call to the function was &#x27;return value&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">results</span>[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;return value&#x27;</span>);<span class="hljs-comment">// The function was called with a certain `this` context: the `element` object.</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">contexts</span>[<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(element);<span class="hljs-comment">// This function was instantiated exactly twice</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">instances</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// The object returned by the first instantiation of this function</span><span class="hljs-comment">// had a `name` property whose value was set to &#x27;test&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">instances</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<span class="hljs-comment">// The first argument of the last call to the function was &#x27;test&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">lastCall</span>[<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;test&#x27;</span>);</code></pre></div><h5 id="Mock-的返回值"><a href="#Mock-的返回值" class="headerlink" title="Mock 的返回值"></a>Mock 的返回值<a href="https://jestjs.io/zh-Hans/docs/mock-functions#mock-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"></a></h5><p>Mock 函数也可以用于在测试期间将测试值注入代码︰</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myMock = jest.<span class="hljs-title function_">fn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myMock</span>());<span class="hljs-comment">// &gt; undefined</span>myMock.<span class="hljs-title function_">mockReturnValueOnce</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">mockReturnValueOnce</span>(<span class="hljs-string">&#x27;x&#x27;</span>).<span class="hljs-title function_">mockReturnValue</span>(<span class="hljs-literal">true</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myMock</span>(), <span class="hljs-title function_">myMock</span>(), <span class="hljs-title function_">myMock</span>(), <span class="hljs-title function_">myMock</span>());<span class="hljs-comment">// &gt; 10, &#x27;x&#x27;, true, true</span></code></pre></div><p>在函数连续传递风格（functional continuation-passing style）的代码中时，Mock 函数也非常有效。 以这种代码风格有助于避免复杂的中间操作，便于直观表现组件的真实意图，这有利于在它们被调用之前，将值直接注入到测试中。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filterTestFn = jest.<span class="hljs-title function_">fn</span>();<span class="hljs-comment">// Make the mock return `true` for the first call,</span><span class="hljs-comment">// and `false` for the second call</span>filterTestFn.<span class="hljs-title function_">mockReturnValueOnce</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">mockReturnValueOnce</span>(<span class="hljs-literal">false</span>);<span class="hljs-keyword">const</span> result = [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> <span class="hljs-title function_">filterTestFn</span>(num));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<span class="hljs-comment">// &gt; [11]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filterTestFn.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">// 11</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filterTestFn.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">// 12</span></code></pre></div><p>大多数现实世界例子中，实际是在依赖的组件上配一个模拟函数并配置它，但手法是相同的。 在这些情况下，尽量避免在非真正想要进行测试的任何函数内实现逻辑。</p><h5 id="模拟模块"><a href="#模拟模块" class="headerlink" title="模拟模块"></a>模拟模块<a href="https://jestjs.io/zh-Hans/docs/mock-functions#%E6%A8%A1%E6%8B%9F%E6%A8%A1%E5%9D%97"></a></h5><p>假定有个从 API 获取用户的类。 该类用 <a href="https://github.com/axios/axios">axios</a> 调用 API 然后返回 <code>data</code>，其中包含所有用户的属性：</p><p>users.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Users</span> &#123;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users.json&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.<span class="hljs-property">data</span>);  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Users</span>;</code></pre></div><p>现在，为测试该方法而不实际调用 API (使测试缓慢与脆弱)，我们可以用 <code>jest.mock(...)</code> 函数自动模拟 axios 模块。</p><p>一旦模拟模块，我们可为 <code>.get</code> 提供一个 <code>mockResolvedValue</code> ，它会返回假数据用于测试。 实际上，我们想说的是我们想让<code>axios.get(&#39;/users.json&#39;)</code> 有个伪造的响应结果。</p><p>users.test.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">Users</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users&#x27;</span>;jest.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;axios&#x27;</span>);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;should fetch users&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> users = [&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;];  <span class="hljs-keyword">const</span> resp = &#123;<span class="hljs-attr">data</span>: users&#125;;  axios.<span class="hljs-property">get</span>.<span class="hljs-title function_">mockResolvedValue</span>(resp);  <span class="hljs-comment">// or you could use the following depending on your use case:</span>  <span class="hljs-comment">// axios.get.mockImplementation(() =&gt; Promise.resolve(resp))</span>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Users</span>.<span class="hljs-title function_">all</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toEqual</span>(users));&#125;);</code></pre></div><h5 id="模拟-部分模块"><a href="#模拟-部分模块" class="headerlink" title="模拟 部分模块"></a>模拟 部分模块</h5><p>模块的子集可以被模拟，模块的其他部分可以维持当前实现：</p><p>foo-bar-baz.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">bar</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; <span class="hljs-string">&#x27;baz&#x27;</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//test.js</span><span class="hljs-keyword">import</span> defaultExport, &#123;bar, foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../foo-bar-baz&#x27;</span>;jest.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;../foo-bar-baz&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> originalModule = jest.requireActual(<span class="hljs-string">&#x27;../foo-bar-baz&#x27;</span>);  <span class="hljs-comment">//Mock the default export and named export &#x27;foo&#x27;</span>  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">__esModule</span>: <span class="hljs-literal">true</span>,    ...originalModule,    <span class="hljs-attr">default</span>: jest.<span class="hljs-title function_">fn</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;mocked baz&#x27;</span>),    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;mocked foo&#x27;</span>,  &#125;;&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;should do a partial mock&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> defaultExportResult = <span class="hljs-title function_">defaultExport</span>();  <span class="hljs-title function_">expect</span>(defaultExportResult).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;mocked baz&#x27;</span>);  <span class="hljs-title function_">expect</span>(defaultExport).<span class="hljs-title function_">toHaveBeenCalled</span>();  <span class="hljs-title function_">expect</span>(foo).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;mocked foo&#x27;</span>);  <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">bar</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);&#125;);</code></pre></div><h5 id="Mock-实现"><a href="#Mock-实现" class="headerlink" title="Mock 实现"></a>Mock 实现<a href="https://jestjs.io/zh-Hans/docs/mock-functions#mock-%E5%AE%9E%E7%8E%B0"></a></h5><p>还有，在某些情况下用Mock函数替换指定返回值是非常有用的。 可以用 <code>jest.fn</code> 或 <code>mockImplementationOnce</code>方法来实现Mock函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMockFn = jest.<span class="hljs-title function_">fn</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>));<span class="hljs-title function_">myMockFn</span>(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));<span class="hljs-comment">// &gt; true</span></code></pre></div><p>当你需要根据别的模块定义默认的Mock函数实现时，<code>mockImplementation</code> 方法是非常有用的。</p><p>foo.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// some implementation;</span>&#125;;</code></pre></div><p>test.js</p><div class="code-wrapper"><pre><code class="hljs js">jest.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;../foo&#x27;</span>); <span class="hljs-comment">// this happens automatically with automocking</span><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../foo&#x27;</span>);<span class="hljs-comment">// foo is a mock function</span>foo.<span class="hljs-title function_">mockImplementation</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-number">42</span>);<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// &gt; 42</span></code></pre></div><p>当你需要模拟某个函数调用返回不同结果时，请使用 <code>mockImplementationOnce</code> 方法︰</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMockFn = jest  .<span class="hljs-title function_">fn</span>()  .<span class="hljs-title function_">mockImplementationOnce</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))  .<span class="hljs-title function_">mockImplementationOnce</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>));<span class="hljs-title function_">myMockFn</span>(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));<span class="hljs-comment">// &gt; true</span><span class="hljs-title function_">myMockFn</span>(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));<span class="hljs-comment">// &gt; false</span></code></pre></div><p>当 <code>mockImplementationOne</code>定义的实现逐个调用完毕时， 如果定义了<code>jest.fn </code>，它将使用 <code>jest.fn </code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMockFn = jest  .<span class="hljs-title function_">fn</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;default&#x27;</span>)  .<span class="hljs-title function_">mockImplementationOnce</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;first call&#x27;</span>)  .<span class="hljs-title function_">mockImplementationOnce</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;second call&#x27;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myMockFn</span>(), <span class="hljs-title function_">myMockFn</span>(), <span class="hljs-title function_">myMockFn</span>(), <span class="hljs-title function_">myMockFn</span>());<span class="hljs-comment">// &gt; &#x27;first call&#x27;, &#x27;second call&#x27;, &#x27;default&#x27;, &#x27;default&#x27;</span></code></pre></div><p>大多数情况下，我们的函数调用都是链式的，如果你希望创建的函数支持链式调用（因为返回了this），可以使用<code>.mockReturnThis()</code> 函数来支持。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = &#123;  <span class="hljs-attr">myMethod</span>: jest.<span class="hljs-title function_">fn</span>().<span class="hljs-title function_">mockReturnThis</span>(),&#125;;<span class="hljs-comment">// is the same as</span><span class="hljs-keyword">const</span> otherObj = &#123;  <span class="hljs-attr">myMethod</span>: jest.<span class="hljs-title function_">fn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;  &#125;),&#125;;</code></pre></div><h5 id="自定义匹配器"><a href="#自定义匹配器" class="headerlink" title="自定义匹配器"></a>自定义匹配器<a href="https://jestjs.io/zh-Hans/docs/mock-functions#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%B9%E9%85%8D%E5%99%A8"></a></h5><p>最后，测试Mock函数需要写大量的断言，为了减少代码量，我们提供了一些自定义匹配器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// The mock function was called at least once</span><span class="hljs-title function_">expect</span>(mockFunc).<span class="hljs-title function_">toHaveBeenCalled</span>();<span class="hljs-comment">// The mock function was called at least once with the specified args</span><span class="hljs-title function_">expect</span>(mockFunc).<span class="hljs-title function_">toHaveBeenCalledWith</span>(arg1, arg2);<span class="hljs-comment">// The last call to the mock function was called with the specified args</span><span class="hljs-title function_">expect</span>(mockFunc).<span class="hljs-title function_">toHaveBeenLastCalledWith</span>(arg1, arg2);<span class="hljs-comment">// All calls and the name of the mock is written as a snapshot</span><span class="hljs-title function_">expect</span>(mockFunc).<span class="hljs-title function_">toMatchSnapshot</span>();</code></pre></div><p>这些匹配器是断言Mock函数的语法糖。 你可以根据自己的需要自行选择匹配器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// The mock function was called at least once</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">toBeGreaterThan</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// The mock function was called at least once with the specified args</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>).<span class="hljs-title function_">toContainEqual</span>([arg1, arg2]);<span class="hljs-comment">// The last call to the mock function was called with the specified args</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]).<span class="hljs-title function_">toEqual</span>([  arg1,  arg2,]);<span class="hljs-comment">// The first arg of the last call to the mock function was `42`</span><span class="hljs-comment">// (note that there is no sugar helper for this specific of an assertion)</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">// A snapshot will check that a mock was invoked the same number of times,</span><span class="hljs-comment">// in the same order, with the same arguments. 它还会在名称上断言。 它还会在名称上断言。</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>).<span class="hljs-title function_">toEqual</span>([[arg1, arg2]]);<span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-title function_">getMockName</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;a mock name&#x27;</span>);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>单元测试</category>
      
      <category>jest</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）读书笔记</title>
    <link href="/2022/09/14/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/14/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="第四章栈"><a href="#第四章栈" class="headerlink" title="##第四章栈"></a>##第四章栈</h4><p>使用数组来定义数据结构</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];  &#125;  <span class="hljs-comment">// 添加一个（或几个）新元素到栈顶,返回值是数组的长度</span>  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(element);  &#125;  <span class="hljs-comment">//移除栈顶的元素，同时返回被移除的元素</span>  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">pop</span>();  &#125;  <span class="hljs-comment">//返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</span>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];  &#125;  <span class="hljs-comment">// 如果栈里没有任何元素就返回 true，否则返回 false</span>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-comment">// 移除栈里的所有元素</span>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];  &#125;  <span class="hljs-comment">//返回栈里的元素个数。该方法和数组的 length 属性很类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;  &#125;&#125;</code></pre></div><p>使用对象来定义栈</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>] = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;  &#125;  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>;  &#125;  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>;  &#125;  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;    <span class="hljs-comment">// while(!this.isEmpty())&#123;</span>    <span class="hljs-comment">//   this.pop()</span>    <span class="hljs-comment">// &#125;</span>  &#125;  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>];  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;    <span class="hljs-keyword">let</span> str = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>; i++) &#123;      str = str + <span class="hljs-string">`,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.items[i]&#125;</span>`</span>;    &#125;    <span class="hljs-keyword">return</span> str;  &#125;&#125;</code></pre></div><p>保护数据结构内部元素</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(stack)); <span class="hljs-comment">// &#123;1&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(stack)); <span class="hljs-comment">// &#123;2&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-property">items</span>);</code></pre></div><p>外部可以直接拿到内部的数据，因为js中没有私有属性</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_count</span> = <span class="hljs-number">0</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span> = &#123;&#125;;  &#125; &#125;</code></pre></div><p>一部分开发者胡使用下划线作为私有属性的规范，但是这样依然可以被访问，没有实质性的作用</p><h5 id="用-ES2015-的限定作用域-Symbol-实现类"><a href="#用-ES2015-的限定作用域-Symbol-实现类" class="headerlink" title="用 ES2015 的限定作用域 Symbol 实现类"></a>用 ES2015 的限定作用域 Symbol 实现类</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> _items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;stackItem&quot;</span>);<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">//使用计算属性和symbol的形式</span>    <span class="hljs-variable language_">this</span>[_items] = &#123;&#125;;  &#125;&#125;</code></pre></div><p>虽然这种方式可以让上述方法没办法访问内部属性但是可以通过<code>Object.getOwnPropertySymbol(stack)</code>可以访问到以Symbol为key的属性</p><h5 id="用-ES2015-的-WeakMap-实现类"><a href="#用-ES2015-的-WeakMap-实现类" class="headerlink" title="用 ES2015 的 WeakMap 实现类"></a>用 ES2015 的 WeakMap 实现类</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakMapStack</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;    items.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>,[])  &#125;  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>)&#123;    items.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">push</span>(element)  &#125;  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">pop</span>()  &#125;  <span class="hljs-comment">//...</span>&#125;</code></pre></div><p>现在我们知道了，items 在 Stack 类里是真正的私有属性。采用这种方法，代码的可读性 不强，而且在扩展该类时无法继承私有属性。鱼和熊掌不可兼得！</p><h5 id="使用栈的实例"><a href="#使用栈的实例" class="headerlink" title="使用栈的实例"></a>使用栈的实例</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 将十进制转成二进制</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Stack</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Stack.js&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">decimalToBinary</span>(<span class="hljs-params">decNumber</span>) &#123;  decNumber = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Number</span>(decNumber));  <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();  <span class="hljs-keyword">let</span> dec = decNumber;  <span class="hljs-keyword">while</span> (dec &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(dec % <span class="hljs-number">2</span>));    stack.<span class="hljs-title function_">push</span>(dec % <span class="hljs-number">2</span>);    dec = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(dec / <span class="hljs-number">2</span>);  &#125;  <span class="hljs-keyword">let</span> binaryString = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">while</span> (!stack.<span class="hljs-title function_">isEmpty</span>()) &#123;    binaryString += stack.<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">toString</span>();  &#125;  <span class="hljs-keyword">return</span> binaryString;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 把十进制转换成基数为 2～36 的任意进制</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Stack</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Stack.js&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">baseConverter</span>(<span class="hljs-params">decNumber, base</span>) &#123;  <span class="hljs-keyword">let</span> dec = decNumber;  <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();  <span class="hljs-keyword">const</span> digits = <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">if</span> (!(base &gt;= <span class="hljs-number">2</span> &amp;&amp; base &lt;= <span class="hljs-number">36</span>)) &#123;    <span class="hljs-keyword">return</span> str;  &#125;  <span class="hljs-keyword">while</span> (dec &gt; <span class="hljs-number">0</span>) &#123;    arr.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(dec % base));    dec = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(dec / base);  &#125;  <span class="hljs-keyword">while</span> (!arr.<span class="hljs-title function_">isEmpty</span>()) &#123;    str += digits[arr.<span class="hljs-title function_">pop</span>()];  &#125;  <span class="hljs-keyword">return</span> str;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">baseConverter</span>(<span class="hljs-number">100345</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 11000011111111001</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">baseConverter</span>(<span class="hljs-number">100345</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// 303771</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">baseConverter</span>(<span class="hljs-number">100345</span>, <span class="hljs-number">16</span>)); <span class="hljs-comment">// 187F9</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">baseConverter</span>(<span class="hljs-number">100345</span>, <span class="hljs-number">35</span>)); <span class="hljs-comment">// 2BW0</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/09/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/09/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2011.40.38.png"></p><p><strong>什么是计算机系统</strong></p><p>计算机系统就是硬件+软件</p><p>硬件：就是计算机的实体，主机，外设等</p><p>软件：由各类功能特殊的程序组成</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2011.48.02.png"></p><p><strong>第一代计算机</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2011.51.30.png"></p><p><strong>第二代计算机</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2011.55.26.png"></p><p><strong>第三代计算机</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2011.57.57.png">****</p><p><strong>第四代计算机</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2012.00.34.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2012.29.04.png"></p><p>计算机硬件的基本组成分为早期冯诺依曼机的结构和现代计算机的结构</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2012.35.26.png"></p><p>早期冯诺依曼机是以运算器为中心的计算机结构</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2012.39.29.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2012.42.23.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2012.56.31.png"></p><p>输入设备</p><p>输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机，例如键盘，鼠标，扫描仪，摄像机等</p><p>输出设备</p><p>输出设备的任务是将计算机处理的结果以人们可以接受的形式或者其他系统所要求的信息形式输出，最常用的是显示器，打印机</p><p>存储器</p><p>存储器是计算机的存储部件，用来存储程序和数据</p><p>存储器分为主存储器(主存，内存储器)，辅助存储器(辅存，外存储器)，cpu可以直接访问的存储器是主存储器，辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器的信息必须调用至主存储器，cpu才可以访问到。</p><p>主存储器的工作方式是按存储单元的地址进行存取的，这种存取方式称之为按地址存取方式(相联存储器是按内容访问的)</p><p>主存储器中有存储体来存放二进制信息，地址寄存器(MAR)来存放地址，经过地址编码后找到对应的存储单元，数据寄存器(MDR),用来存放从存储体中读写的数据，时序控制逻辑用语产生存储器操作所需的各种时序信号。</p><p>主存储器中由若干个存储单元组成，每个存储单元都包涵若干个存储元件，存储单元可以存储一串二进制代码，这串代码称为存储字，这串代码的长度称之为存储字长，存储字长可以是1B或者它的偶数倍</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2013.04.48.png"></p><p>MAR用于寻址，其位数对应着储存单元的个数，MAR的长度与PC的长度相等。</p><p>MDR的位数和存储字长相等，一般为字节的二次幂的整数倍。</p><p>MAR和MDR虽然是位于存储器中，但是在现代cpu中却存在于cpu中，高速缓存也是位于cpu中。</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2015.10.36.png"></p><p>运算器的核心是算术逻辑单元ALU，运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器ACC，乘商寄存器MQ，操作数寄存器X，变址寄存器IX，基址寄存器BR等，前三个寄存器是必要的。</p><p>运算器中还有程序状态寄存器PSW，也称为标志寄存器，用于存放ALU运算得到的一些标志信息或者处理机的状态信息，如结果是否溢出，有无产生进位或者借位，结果是否为负等</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2015.38.50.png"></p><p>控制单元CU是核心</p><p>PC用来存放当前欲执行指令的地址，可以自动加1以形成下一条指令的地址，他和主存的MAR之间有一条直接通路</p><p>IR用来存放当前指令，其内容来自主存的MDR，指令中的操作码OP(IR)送至cpu，用于分析指令并发出各种微操作命令序列，而地址吗Ad(IR)M AR，用以取操作数</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2015.53.40.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2015.59.03.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2016.01.06.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2016.02.28.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2016.03.34.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2016.03.34.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2016.05.51.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2016.05.51.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2016.10.02.png"></p><p><strong>计算机性能指标</strong></p><p>机器字长</p><p>机器字长是指计算机进行一次整数运算即定点整数运算所能处理的二进制数据的位数，通常与CPU的寄存器，加法器有关，机器字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高，计算机的机器字长一般选定为字节的整数倍</p><p>主存容量/总容量</p><p>总容量=存储单元个数 * 存储字长bit=存储单元个数 * 存储字长/8B</p><p>MAR的位数反应存储单元的个数</p><p>MDR的位数反应存储字长</p><p>于是若MAR为32位，MDR为8位，于是总容量为2^32 * 8bit=4G</p><p>CPU主频</p><p>​    就是CPU的时钟频率，为cpu时钟周期的倒数</p><p>cpu时钟周期</p><p>​    为节拍脉冲/T周期，主频的倒数，他是cpu中最小的时间单位，执行指令的每一个动作至少需要一个时钟周期</p><p>CPI</p><p>​    执行一条指令需要的时钟周期数</p><p>CPU执行时间</p><p>​    CPU执行时间=CPU时钟周期数/主频=(指令条数 * CPI)/主频</p><p>​    CPU的性能(CPU的执行时间)主要取决于三个要素：主频，CPI，指令条数</p><p>​    主频，CPI，指令条数是相互制约的</p><p>MIPS</p><p>​    每秒执行多少百万条指令</p><p>​    MIPS=指令条数/(执行时间 * 10^6)=主频/（CPI * 10^6）</p><p>MFLOPS,GFLOPS,TFLOPS,PFLOPS,EFLOPS和ZFLOPS</p><p>MFLOPS，即每秒执行多少百万次浮点数运算。 MFLOPS=浮点操作次数/(执行时间 * 10^6)</p><p>GFLOPS，即每秒执行多少十亿次浮点数运算。 GFLOPS=浮点操作次数/(执行时间 * 10^9)</p><p>TFLOPS，即每秒执行多少万亿次浮点数运算。 TFLOPS=浮点操作次数/(执行时间 * 10^12)</p><p>PFLOPS， PFLOPS=浮点操作次数/(执行时间 * 10^15)</p><p>EFLOPS，EFLOPS=浮点操作次数/(执行时间 * 10^18)</p><p>ZFLOPS， ZFLOPS=浮点操作次数/(执行时间 * 10^21)</p><p>注意：在描述存储容量，文件大小等时，K，M，G，T通常用2的幂次来表示，如1Kb=2^10b，在描述速率。频率等时，k，M，G，T通常用10的幂次表示，如1kb/s=10^3b/s。通常前者用大写K，后者用小写k</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2016.43.45.png"></p><p>数据通路带宽</p><p>数据通路带宽是指数据总线一次所能并行传送信息的位数，这里说的数据通路宽度是指外部数据总线的宽度，他与CPU内部的数据总线宽度(内部寄存器的大小)有可能不同</p><p>注意：各个子系统通过数据总线连接形成的数据传送路径称之为数据通路</p><p>运算速度</p><p>​    吞吐量</p><p>​        指系统在单位时间内处理请求的数量，它取决于信息能多快的输入内存，cpu能多快的取指令，数据能多快的从内存取出或存入，以及所得结果能多快的从内存送给一台外部设备，几乎每步都关系到主存，因此系统吞吐量主要取决于主存的存取周期</p><p>​    响应时间</p><p>​        指从用户向计算机发送一个请求，到系统对该请求作出响应并获取所需结果的等待时间，包括CPU时间(运行一个程序所花的时间)与等待时间(用于磁盘访问，存储器访问，I/O操作，操作系统开销等时间)</p><p>基准程序</p><p>​    基准程序是专门用来进行性能评价的一组程序，能够很好的反应机器在运行实际负载是的性能，可以通过在不同机器上运行相同的基准程序来比较在不同机器1上的运行时间，从而评测性能，对于不同的应用场所，应该选择不同的基准程序。使用基准程序进行计算机性能评测也会存在缺陷，因为基准程序的性能可能与某一小段的短代码密切相关，而硬件系统设计人员或者编译器开发者会针对这些代码片段进行特殊的优化，使得执行这段代码的速度非常快，以至于不能得到准确的性能评测结果</p><h1 id="数据的表示与运算"><a href="#数据的表示与运算" class="headerlink" title="数据的表示与运算"></a>数据的表示与运算</h1><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2017.20.56.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2017.22.01.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2017.31.20.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2017.35.18.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2017.36.28.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2017.37.49.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2017.38.39.png"></p><h2 id="定点数的表示和计算"><a href="#定点数的表示和计算" class="headerlink" title="定点数的表示和计算"></a>定点数的表示和计算</h2><p>在计算机中，参与运算的机器数有两大类：无符号数和有符号数</p><p>无符号数：指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值，若机器字长为8位，则数的表示范围为0-2^8 -1,即0-255</p><p>有符号数：在机器中，数的正负号是无法识别的，有符号数用0表示正，用1表示负，从而将符号也数值化，并通常约定二进制数的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数</p><p>无符号整数中，最小值为全0，最大值为全1</p><p>无符号整数的加法：</p><p>无符号整数加法是从最低位开始，逐位相加，往更高位进位。如果超过最大位数，就会舍弃</p><p>无符号整数的减法：就是被减数不变。减数全部按位取反，末位加1，然后在从最低位开始，按位相加，往更高位进位</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2020.05.02.png"></p><p><strong>带符号位整数的表示和运算</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2020.07.46.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2020.09.44.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2020.11.12.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2020.12.14.png"></p><h3 id="补码的加法运算"><a href="#补码的加法运算" class="headerlink" title="补码的加法运算"></a><strong>补码的加法运算</strong></h3><p>从最低位开始，按位相加，符号位参与运算，并往更高位进位</p><h3 id="补码的减法运算"><a href="#补码的减法运算" class="headerlink" title="补码的减法运算"></a>补码的减法运算</h3><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2020.21.20.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2020.25.59.png"></p><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2021.52.08.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2021.53.34.png"></p><p>移码常用来表示浮点数的阶码，他只能表示整数</p><p>移码就是在真值X上加上一个常数(偏置值)，通常是取2^n,相当于X在数周上向正方向偏移了若干单位，移码的定义：</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2022.00.59.png"></p><p>移码的特点：</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2022.03.33.png"></p><h3 id="移码补码反码原码总结"><a href="#移码补码反码原码总结" class="headerlink" title="移码补码反码原码总结"></a>移码补码反码原码总结</h3><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2022.05.24.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-28%2023.16.27.png"></p><h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2010.11.10.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2010.12.14.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2010.15.18.png"></p><h3 id="定点小数的表示和运算"><a href="#定点小数的表示和运算" class="headerlink" title="定点小数的表示和运算"></a>定点小数的表示和运算</h3><p>定点小数只有补码反码原码的表示方式</p><p>定点小数是纯小数，约定小数点位置在符号位之后，有效数值部分最高位之前</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2010.20.55.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2010.26.51.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2010.28.06.png"></p><p>定点小数的补码反码原码的转换和定点整数相同</p><p>定点小数进行加减运算时，现将被减数和减数转成补码🉐️形式进行运算，和定点整数一样，减法要转成加法进行运算</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2012.07.01.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2012.08.53.png"></p><h2 id="算术逻辑单元ALU"><a href="#算术逻辑单元ALU" class="headerlink" title="算术逻辑单元ALU"></a>算术逻辑单元ALU</h2><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2012.14.58.png"></p><p>ALU的核心部件是加法器，加法器是由全加器再配以其他必要的逻辑电路组成，根据组成加法器个数是单个还是多个，加法器有并行和串行之分</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2012.17.50.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2015.58.44.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.00.22.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.03.05.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.05.16.png"></p><p>串行加法器具有器件少，成本低的优点，但是运算速度慢，多用于某些低速的专门运算器</p><h3 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h3><p>并行加法器的进位通常分为串行进位和并行进位</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.10.33.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.19.18.png"></p><p>低位运算产生的进位所需要的时间将可能影响直至最高位运算的时间，因此，并行加法器的最长运算时间主要是由于进位信号的传递时间决定的，位数越多延迟时间就越长，而全加器本身的求和和延迟为次要因素，所以加快进位产生和提高传递的速度是关键</p><h4 id="并行进位加法器"><a href="#并行进位加法器" class="headerlink" title="并行进位加法器"></a>并行进位加法器</h4><p>并行进位又称为先行进位，同时进位，特点是各级进位信号同时形成。</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.28.27.png"></p><p>采用并行进位的方案可以加快进位的产生和提高传递的速度，即将各级低位产生的本级G和P信号依次同时送到高位各全加器的输入端，使他们同时形成进位信号。</p><p>这种进位是快速的，与字长无关，但随着加法器位数的增加，Ci的逻辑表达式会变得越来越长，输入变量会越来越多，这会使得电路结构变得越来越复杂，所以完全采用并行进位是不现实的。</p><h3 id="补码加减运算电路"><a href="#补码加减运算电路" class="headerlink" title="补码加减运算电路"></a>补码加减运算电路</h3><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.44.24.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.46.02.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.47.10.png"></p><h2 id="算术逻辑单元的功能和结构"><a href="#算术逻辑单元的功能和结构" class="headerlink" title="算术逻辑单元的功能和结构"></a>算术逻辑单元的功能和结构</h2><h3 id="带标志加法器"><a href="#带标志加法器" class="headerlink" title="带标志加法器"></a>带标志加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.50.45.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.57.50.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2016.59.41.png"></p><p>无符号数加法器只能用于两个无符号数相加，不能进行带符号整数的加/减运算。为了能进行带符号整数的加/减运算，还需要在无符号数加法器的基础上增加相应的逻辑门电路，使得加法器不仅能计算和/差，还要能生成相应的标志信息。上图是同全加器实现的带标志加法器的实现电路。</p><p>为了实现加快加法运算的速度，实际电路一定会使用多极先行进位的方式</p><h3 id="溢出判别方法"><a href="#溢出判别方法" class="headerlink" title="溢出判别方法"></a>溢出判别方法</h3><p>仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为1（结果为负）;一个负数减去一个正数，结果的符号位却为0（结果为正）。</p><p>补码定点数加减运算溢出判断的方法有3种。</p><p>（1）采用一位符号位</p><p>由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2019.36.41.png"></p><h3 id="定点数的位移运算"><a href="#定点数的位移运算" class="headerlink" title="定点数的位移运算"></a>定点数的位移运算</h3><h4 id="算术位移"><a href="#算术位移" class="headerlink" title="算术位移"></a>算术位移</h4><p>算数位移的对象是有符号数，在位移过程中符号位保持不变</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2017.14.49.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2017.34.45.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2017.36.17.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2017.39.40.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2017.40.30.png"></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p>逻辑移位将操作数视为无符号数。</p><p>移位规则：左移，高位丢弃，低位补零，右移，低位丢弃，高位补零</p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2017.45.29.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2019.24.58.png"></p><h2 id="C语言中的强制类型转换"><a href="#C语言中的强制类型转换" class="headerlink" title="C语言中的强制类型转换"></a>C语言中的强制类型转换</h2><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2019.28.39.png"></p><h2 id="定点数乘法运算"><a href="#定点数乘法运算" class="headerlink" title="定点数乘法运算"></a>定点数乘法运算</h2><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2020.53.09.png"></p><p>定点数补码的乘法运算</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2021.02.56.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2021.15.05.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2021.24.41.png"></p><h2 id="定点数除法运算"><a href="#定点数除法运算" class="headerlink" title="定点数除法运算"></a>定点数除法运算</h2><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2021.39.33.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2021.43.51.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2021.45.30.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2021.46.20.png"></p><p>定点数补码除法运算</p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2022.29.19.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yangzeng-cell/blog-images/%E6%88%AA%E5%B1%8F2023-01-29%2022.31.26.png"></p><p>N是指数值位，不包括符号位</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2022/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3项目搭建</title>
    <link href="/2022/09/13/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/09/13/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="项目搭建规范"><a href="#项目搭建规范" class="headerlink" title="项目搭建规范"></a>项目搭建规范</h1><h2 id="一-代码规范"><a href="#一-代码规范" class="headerlink" title="一. 代码规范"></a>一. 代码规范</h2><h3 id="1-1-集成editorconfig配置"><a href="#1-1-集成editorconfig配置" class="headerlink" title="1.1. 集成editorconfig配置"></a>1.1. 集成editorconfig配置</h3><p>EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># http://editorconfig.org</span><span class="hljs-string">root</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span>[<span class="hljs-string">*</span>] <span class="hljs-comment"># 表示所有文件适用</span><span class="hljs-string">charset</span> <span class="hljs-string">=</span> <span class="hljs-string">utf-8</span> <span class="hljs-comment"># 设置文件字符集为 utf-8</span><span class="hljs-string">indent_style</span> <span class="hljs-string">=</span> <span class="hljs-string">space</span> <span class="hljs-comment"># 缩进风格（tab | space）</span><span class="hljs-string">indent_size</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 缩进大小</span><span class="hljs-string">end_of_line</span> <span class="hljs-string">=</span> <span class="hljs-string">lf</span> <span class="hljs-comment"># 控制换行类型(lf | cr | crlf)</span><span class="hljs-string">trim_trailing_whitespace</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 去除行首的任意空白字符</span><span class="hljs-string">insert_final_newline</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 始终在文件末尾插入一个新行</span>[<span class="hljs-string">*.md</span>] <span class="hljs-comment"># 表示仅 md 文件适用以下规则</span><span class="hljs-string">max_line_length</span> <span class="hljs-string">=</span> <span class="hljs-string">off</span><span class="hljs-string">trim_trailing_whitespace</span> <span class="hljs-string">=</span> <span class="hljs-literal">false</span></code></pre></div><p>VSCode需要安装一个插件：EditorConfig for VS Code</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2gh989yj30pj05ggmb.jpg" alt="image-20210722215138665"></p><h3 id="1-2-使用prettier工具"><a href="#1-2-使用prettier工具" class="headerlink" title="1.2. 使用prettier工具"></a>1.2. 使用prettier工具</h3><p>Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。</p><p>1.安装prettier</p><div class="code-wrapper"><pre><code class="hljs shell">npm install prettier -D</code></pre></div><p>2.配置.prettierrc文件：</p><ul><li>useTabs：使用tab缩进还是空格缩进，选择false；</li><li>tabWidth：tab是空格的情况下，是几个空格，选择2个；</li><li>printWidth：当行字符的长度，推荐80，也有人喜欢100或者120；</li><li>singleQuote：使用单引号还是双引号，选择true，使用单引号；</li><li>trailingComma：在多行输入的尾逗号是否添加，设置为 <code>none</code>；</li><li>semi：语句末尾是否要加分号，默认值true，选择false表示不加；</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;useTabs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;tabWidth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;printWidth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">80</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;singleQuote&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;trailingComma&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;none&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;semi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>3.创建.prettierignore忽略文件</p><div class="code-wrapper"><pre><code class="hljs gradle"><span class="hljs-regexp">/dist/</span>*.local.output.js<span class="hljs-regexp">/node_modules/</span>****<span class="hljs-comment">/*.svg</span><span class="hljs-comment">**/</span>*.sh<span class="hljs-regexp">/public/</span>*</code></pre></div><p>4.VSCode需要安装prettier的插件</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2acx21rj30ow057mxp.jpg" alt="image-20210722214543454"></p><p>5.测试prettier是否生效</p><ul><li>测试一：在代码中保存代码；</li><li>测试二：配置一次性修改的命令,批量修改；</li></ul><p>在package.json中配置一个scripts：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;prettier&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;prettier --write .&quot;</span></code></pre></div><h3 id="1-3-使用ESLint检测"><a href="#1-3-使用ESLint检测" class="headerlink" title="1.3. 使用ESLint检测"></a>1.3. 使用ESLint检测</h3><p>1.在前面创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。</p><p>2.VSCode需要安装ESLint插件：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2oq26odj30pw05faaq.jpg" alt="image-20210722215933360"></p><p>3.解决eslint和prettier冲突的问题：</p><p>安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装）</p><div class="code-wrapper"><pre><code class="hljs shell">npm i eslint-plugin-prettier eslint-config-prettier -D</code></pre></div><p>添加在eslintrc中添加prettier插件：</p><div class="code-wrapper"><pre><code class="hljs json">extends<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>  <span class="hljs-string">&quot;plugin:vue/vue3-essential&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-string">&quot;eslint:recommended&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-string">&quot;@vue/typescript/recommended&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-string">&quot;@vue/prettier&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-string">&quot;@vue/prettier/@typescript-eslint&quot;</span><span class="hljs-punctuation">,</span>  &#x27;plugin<span class="hljs-punctuation">:</span>prettier/recommended&#x27;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code></pre></div><h3 id="1-4-git-Husky和eslint"><a href="#1-4-git-Husky和eslint" class="headerlink" title="1.4. git Husky和eslint"></a>1.4. git Husky和eslint</h3><p>虽然我们已经要求项目使用eslint了，但是不能保证组员提交代码之前都将eslint中的问题解决掉了：</p><ul><li><p>也就是我们希望保证代码仓库中的代码都是符合eslint规范的；</p></li><li><p>那么我们需要在组员执行 <code>git commit </code> 命令的时候对其进行校验，如果不符合eslint规范，那么自动通过规范进行修复；</p></li></ul><p>那么如何做到这一点呢？可以通过Husky工具：</p><ul><li>husky是一个git hook工具，可以帮助我们触发git提交的各个阶段：pre-commit、commit-msg、pre-push</li></ul><p>如何使用husky呢？</p><p>这里我们可以使用自动配置命令：</p><div class="code-wrapper"><pre><code class="hljs shell">npx husky-init &amp;&amp; npm install</code></pre></div><p>这里会做三件事：</p><p>1.安装husky相关的依赖：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq0o5jxmj30bb04qwen.jpg" alt="image-20210723112648927"></p><p>2.在项目目录下创建 <code>.husky</code> 文件夹：</p><div class="code-wrapper"><pre><code class="hljs cmake">npx huksy <span class="hljs-keyword">install</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq16zo75j307703mt8m.jpg" alt="image-20210723112719634"></p><p>3.在package.json中添加一个脚本：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq26phpxj30dj06fgm3.jpg" alt="image-20210723112817691"></p><p>接下来，我们需要去完成一个操作：在进行commit时，执行lint脚本：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq3hn229j30nf04z74q.jpg" alt="image-20210723112932943"></p><p>这个时候我们执行git commit的时候会自动对代码进行lint校验。</p><h3 id="1-5-git-commit规范"><a href="#1-5-git-commit规范" class="headerlink" title="1.5. git commit规范"></a>1.5. git commit规范</h3><h4 id="1-5-1-代码提交风格"><a href="#1-5-1-代码提交风格" class="headerlink" title="1.5.1. 代码提交风格"></a>1.5.1. 代码提交风格</h4><p>通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw17gaqjj30to0cj3zp.jpg"></p><p>但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen</p><ul><li>Commitizen 是一个帮助我们编写规范 commit message 的工具；</li></ul><p>1.安装Commitizen</p><div class="code-wrapper"><pre><code class="hljs shell">npm install commitizen -D</code></pre></div><p>2.安装cz-conventional-changelog，并且初始化cz-conventional-changelog：</p><div class="code-wrapper"><pre><code class="hljs shell">npx commitizen init cz-conventional-changelog --save-dev --save-exact</code></pre></div><p>这个命令会帮助我们安装cz-conventional-changelog：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvz2odi4j30ek00zmx2.jpg" alt="image-20210723145249096"></p><p>并且在package.json中进行配置：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvzftay5j30iu04k74d.jpg"></p><p>这个时候我们提交代码需要使用 <code>npx cz</code>：</p><ul><li>第一步是选择type，本次更新的类型</li></ul><table><thead><tr><th>Type</th><th>作用</th></tr></thead><tbody><tr><td>feat</td><td>新增特性 (feature)</td></tr><tr><td>fix</td><td>修复 Bug(bug fix)</td></tr><tr><td>docs</td><td>修改文档 (documentation)</td></tr><tr><td>style</td><td>代码格式修改(white-space, formatting, missing semi colons, etc)</td></tr><tr><td>refactor</td><td>代码重构(refactor)</td></tr><tr><td>perf</td><td>改善性能(A code change that improves performance)</td></tr><tr><td>test</td><td>测试(when adding missing tests)</td></tr><tr><td>build</td><td>变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）</td></tr><tr><td>ci</td><td>更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等</td></tr><tr><td>chore</td><td>变更构建流程或辅助工具(比如更改测试环境)</td></tr><tr><td>revert</td><td>代码回退</td></tr></tbody></table><ul><li>第二步选择本次修改的范围（作用域）</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8ca15oj30r600wmx4.jpg" alt="image-20210723150147510"></p><ul><li>第三步选择提交的信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8mq3zlj60ni01hmx402.jpg" alt="image-20210723150204780"></p><ul><li>第四步提交详细的描述信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8y05bjj30kt01fjrb.jpg" alt="image-20210723150223287"></p><ul><li>第五步是否是一次重大的更改</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw9z5vbij30bm00q744.jpg" alt="image-20210723150322122"></p><ul><li>第六步是否影响某个open issue</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwar8xp1j30fq00ya9x.jpg" alt="image-20210723150407822"></p><p>我们也可以在scripts中构建一个命令来执行 cz：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwc4gtkxj30e207174t.jpg" alt="image-20210723150526211"></p><h4 id="1-5-2-代码提交验证"><a href="#1-5-2-代码提交验证" class="headerlink" title="1.5.2. 代码提交验证"></a>1.5.2. 代码提交验证</h4><p>如果我们按照cz来规范了提交风格，但是依然有同事通过 <code>git commit</code> 按照不规范的格式提交应该怎么办呢？</p><ul><li>我们可以通过commitlint来限制提交；</li></ul><p>1.安装 @commitlint/config-conventional 和 @commitlint/cli</p><div class="code-wrapper"><pre><code class="hljs shell">npm i @commitlint/config-conventional @commitlint/cli -D</code></pre></div><p>2.在根目录创建commitlint.config.js文件，配置commitlint</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>]&#125;</code></pre></div><p>3.使用husky生成commit-msg文件，验证提交信息：</p><div class="code-wrapper"><pre><code class="hljs shell">npx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot;</code></pre></div><h2 id="二-第三方库集成"><a href="#二-第三方库集成" class="headerlink" title="二. 第三方库集成"></a>二. 第三方库集成</h2><h3 id="2-1-vue-config-js配置"><a href="#2-1-vue-config-js配置" class="headerlink" title="2.1. vue.config.js配置"></a>2.1. vue.config.js配置</h3><p>vue.config.js有三种配置方式：</p><ul><li>方式一：直接通过CLI提供给我们的选项来配置：<ul><li>比如publicPath：配置应用程序部署的子目录（默认是 <code>/</code>，相当于部署在 <code>https://www.my-app.com/</code>）；</li><li>比如outputDir：修改输出的文件夹；</li></ul></li><li>方式二：通过configureWebpack修改webpack的配置：<ul><li>可以是一个对象，直接会被合并；</li><li>可以是一个函数，会接收一个config，可以通过config来修改配置；</li></ul></li><li>方式三：通过chainWebpack修改webpack的配置：<ul><li>是一个函数，会接收一个基于  <a href="https://github.com/mozilla-neutrino/webpack-chain">webpack-chain</a> 的config对象，可以对配置进行修改；</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">outputDir</span>: <span class="hljs-string">&#x27;./build&#x27;</span>,  <span class="hljs-comment">// configureWebpack: &#123;</span>  <span class="hljs-comment">//   resolve: &#123;</span>  <span class="hljs-comment">//     alias: &#123;</span>  <span class="hljs-comment">//       views: &#x27;@/views&#x27;</span>  <span class="hljs-comment">//     &#125;</span>  <span class="hljs-comment">//   &#125;</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-comment">// configureWebpack: (config) =&gt; &#123;</span>  <span class="hljs-comment">//   config.resolve.alias = &#123;</span>  <span class="hljs-comment">//     &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;),</span>  <span class="hljs-comment">//     views: &#x27;@/views&#x27;</span>  <span class="hljs-comment">//   &#125;</span>  <span class="hljs-comment">// &#125;,</span>  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    config.<span class="hljs-property">resolve</span>.<span class="hljs-property">alias</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;@&#x27;</span>, path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)).<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, <span class="hljs-string">&#x27;@/views&#x27;</span>)  &#125;&#125;</code></pre></div><h3 id="2-2-vue-router集成"><a href="#2-2-vue-router集成" class="headerlink" title="2.2. vue-router集成"></a>2.2. vue-router集成</h3><p>安装vue-router的最新版本：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install vue-router@next</code></pre></div><p>创建router对象：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RouteRecordRaw</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">RouteRecordRaw</span>[] = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/main&#x27;</span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/main&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/main/main.vue&#x27;</span>)  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/login/login.vue&#x27;</span>)  &#125;]<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;  routes,  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>()&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router</code></pre></div><p>安装router：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><p>在App.vue中配置跳转：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/main&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h3 id="2-3-vuex集成"><a href="#2-3-vuex集成" class="headerlink" title="2.3. vuex集成"></a>2.3. vuex集成</h3><p>安装vuex：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install vuex@next</code></pre></div><p>创建store对象：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;coderwhy&#x27;</span>    &#125;  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><p>安装store：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">use</span>(store).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><p>在App.vue中使用：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; $store.state.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div><h3 id="2-4-element-plus集成"><a href="#2-4-element-plus集成" class="headerlink" title="2.4. element-plus集成"></a>2.4. element-plus集成</h3><p>Element Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库：</p><ul><li>相信很多同学在Vue2中都使用过element-ui，而element-plus正是element-ui针对于vue3开发的一个UI组件库；</li><li>它的使用方式和很多其他的组件库是一样的，所以学会element-plus，其他类似于ant-design-vue、NaiveUI、VantUI都是差不多的；</li></ul><p>安装element-plus</p><div class="code-wrapper"><pre><code class="hljs shell">npm install element-plus</code></pre></div><h4 id="2-4-1-全局引入"><a href="#2-4-1-全局引入" class="headerlink" title="2.4.1. 全局引入"></a>2.4.1. 全局引入</h4><p>一种引入element-plus的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementPlus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/lib/theme-chalk/index.css&#x27;</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">use</span>(store).<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementPlus</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><h4 id="2-4-2-局部引入"><a href="#2-4-2-局部引入" class="headerlink" title="2.4.2. 局部引入"></a>2.4.2. 局部引入</h4><p>也就是在开发中用到某个组件对某个组件进行引入：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;h2&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h2&gt;    &lt;el-button&gt;默认按钮&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;    &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt;    &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt;    &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt;    &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;import &#123; ElButton &#125; from &#x27;element-plus&#x27;export default defineComponent(&#123;  name: &#x27;App&#x27;,  components: &#123;    ElButton  &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</code></pre></div><p>但是我们会发现是没有对应的样式的，引入样式有两种方式：</p><ul><li>全局引用样式（像之前做的那样）；</li><li>局部引用样式（通过babel的插件）；</li></ul><p>1.安装babel的插件：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install babel-plugin-import -D</code></pre></div><p>2.配置babel.config.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">plugins</span>: [    [      <span class="hljs-string">&#x27;import&#x27;</span>,      &#123;        <span class="hljs-attr">libraryName</span>: <span class="hljs-string">&#x27;element-plus&#x27;</span>,        <span class="hljs-attr">customStyleName</span>: <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;          <span class="hljs-keyword">return</span> <span class="hljs-string">`element-plus/lib/theme-chalk/<span class="hljs-subst">$&#123;name&#125;</span>.css`</span>        &#125;      &#125;    ]  ],  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>]&#125;</code></pre></div><p>但是这里依然有个弊端：</p><ul><li>这些组件我们在多个页面或者组件中使用的时候，都需要导入并且在components中进行注册；</li><li>所以我们可以将它们在全局注册一次；</li></ul><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;  <span class="hljs-title class_">ElButton</span>,  <span class="hljs-title class_">ElTable</span>,  <span class="hljs-title class_">ElAlert</span>,  <span class="hljs-title class_">ElAside</span>,  <span class="hljs-title class_">ElAutocomplete</span>,  <span class="hljs-title class_">ElAvatar</span>,  <span class="hljs-title class_">ElBacktop</span>,  <span class="hljs-title class_">ElBadge</span>,&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus/lib/components&#x27;</span><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<span class="hljs-keyword">const</span> components = [  <span class="hljs-title class_">ElButton</span>,  <span class="hljs-title class_">ElTable</span>,  <span class="hljs-title class_">ElAlert</span>,  <span class="hljs-title class_">ElAside</span>,  <span class="hljs-title class_">ElAutocomplete</span>,  <span class="hljs-title class_">ElAvatar</span>,  <span class="hljs-title class_">ElBacktop</span>,  <span class="hljs-title class_">ElBadge</span>]<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cpn <span class="hljs-keyword">of</span> components) &#123;  app.<span class="hljs-title function_">component</span>(cpn.<span class="hljs-property">name</span>, cpn)&#125;</code></pre></div><p>20211212 新版本按需自动导入elementplus</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// webpack.config.js</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AutoImport</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;unplugin-auto-import/webpack&#x27;</span>)<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Components</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;unplugin-vue-components/webpack&#x27;</span>)<span class="hljs-keyword">const</span> &#123; ElementPlusResolver &#125; = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span>)module.exports = &#123;  <span class="hljs-comment">// ...</span>  plugins: [    <span class="hljs-title function_ invoke__">AutoImport</span>(&#123;      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title function_ invoke__">ElementPlusResolver</span>()],    &#125;),    <span class="hljs-title function_ invoke__">Components</span>(&#123;      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title function_ invoke__">ElementPlusResolver</span>()],    &#125;),  ],&#125;</code></pre></div><h3 id="2-5-axios集成"><a href="#2-5-axios集成" class="headerlink" title="2.5. axios集成"></a>2.5. axios集成</h3><p>安装axios：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install axios</code></pre></div><p>封装axios：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> axios, &#123; <span class="hljs-title class_">AxiosInstance</span>, <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Result</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./types&#x27;</span><span class="hljs-keyword">import</span> &#123; useUserStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/@/store/modules/user&#x27;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HYRequest</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">AxiosInstance</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">options</span>: <span class="hljs-title class_">AxiosRequestConfig</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options: AxiosRequestConfig</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = axios.<span class="hljs-title function_">create</span>(options)    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">useUserStore</span>().<span class="hljs-property">getToken</span>        <span class="hljs-keyword">if</span> (token) &#123;          config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span>        &#125;        <span class="hljs-keyword">return</span> config      &#125;,      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> err      &#125;    )    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 拦截响应的数据</span>        <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>        &#125;        <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>      &#125;,      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> err      &#125;    )  &#125;  request&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>        .<span class="hljs-property">request</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-title class_">AxiosResponse</span>&lt;<span class="hljs-title class_">Result</span>&lt;T&gt;&gt;&gt;(config)        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-title function_">resolve</span>((res <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Promise</span>&lt;T&gt;)        &#125;)        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;          <span class="hljs-title function_">reject</span>(err)        &#125;)    &#125;)  &#125;  get&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span> &#125;)  &#125;  post&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span> &#125;)  &#125;  patch&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PATCH&#x27;</span> &#125;)  &#125;  <span class="hljs-keyword">delete</span>&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;DELETE&#x27;</span> &#125;)  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HYRequest</span></code></pre></div><h3 id="2-6-VSCode配置"><a href="#2-6-VSCode配置" class="headerlink" title="2.6. VSCode配置"></a>2.6. VSCode配置</h3><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;workbench.iconTheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vscode-great-icons&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">17</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;eslint.migration.2_x&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;[javascript]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dbaeumer.vscode-eslint&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;files.autoSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;afterDelay&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.tabSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;terminal.integrated.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">16</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.renderWhitespace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.quickSuggestions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;strings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;debug.console.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">15</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;window.zoomLevel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;emmet.includeLanguages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;javascript&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;javascriptreact&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;explorer.confirmDragAndDrop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;workbench.tree.indent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">16</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;javascript.updateImportsOnFileMove.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;always&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.wordWrap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;on&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;path-intellisense.mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;@&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/src&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;hediet.vscode-drawio.local-storage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eyIuZHJhd2lvLWNvbmZpZyI6IntcImxhbmd1YWdlXCI6XCJcIixcImN1c3RvbUZvbnRzXCI6W10sXCJsaWJyYXJpZXNcIjpcImdlbmVyYWw7YmFzaWM7YXJyb3dzMjtmbG93Y2hhcnQ7ZXI7c2l0ZW1hcDt1bWw7YnBtbjt3ZWJpY29uc1wiLFwiY3VzdG9tTGlicmFyaWVzXCI6W1wiTC5zY3JhdGNocGFkXCJdLFwicGx1Z2luc1wiOltdLFwicmVjZW50Q29sb3JzXCI6W1wiRkYwMDAwXCIsXCIwMENDNjZcIixcIm5vbmVcIixcIkNDRTVGRlwiLFwiNTI1MjUyXCIsXCJGRjMzMzNcIixcIjMzMzMzM1wiLFwiMzMwMDAwXCIsXCIwMENDQ0NcIixcIkZGNjZCM1wiLFwiRkZGRkZGMDBcIl0sXCJmb3JtYXRXaWR0aFwiOjI0MCxcImNyZWF0ZVRhcmdldFwiOmZhbHNlLFwicGFnZUZvcm1hdFwiOntcInhcIjowLFwieVwiOjAsXCJ3aWR0aFwiOjExNjksXCJoZWlnaHRcIjoxNjU0fSxcInNlYXJjaFwiOnRydWUsXCJzaG93U3RhcnRTY3JlZW5cIjp0cnVlLFwiZ3JpZENvbG9yXCI6XCIjZDBkMGQwXCIsXCJkYXJrR3JpZENvbG9yXCI6XCIjNmU2ZTZlXCIsXCJhdXRvc2F2ZVwiOnRydWUsXCJyZXNpemVJbWFnZXNcIjpudWxsLFwib3BlbkNvdW50ZXJcIjowLFwidmVyc2lvblwiOjE4LFwidW5pdFwiOjEsXCJpc1J1bGVyT25cIjpmYWxzZSxcInVpXCI6XCJcIn0ifQ==&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;hediet.vscode-drawio.theme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Kennedy&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.fontFamily&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Source Code Pro, &#x27;Courier New&#x27;, monospace&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.smoothScrolling&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esbenp.prettier-vscode&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;workbench.colorTheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Atom One Dark&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;vetur.completion.autoImport&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;security.workspace.trust.untrustedFiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;open&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;eslint.lintTask.enable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;eslint.alwaysShowStatus&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.codeActionsOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;source.fixAll.eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="三-接口文档"><a href="#三-接口文档" class="headerlink" title="三. 接口文档"></a>三. 接口文档</h2><p><a href="https://documenter.getpostman.com/view/12387168/TzsfmQvw">https://documenter.getpostman.com/view/12387168/TzsfmQvw</a></p><p>baseURL的值：</p><div class="code-wrapper"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">152.136</span>.<span class="hljs-number">185.210</span>:<span class="hljs-number">5000</span></code></pre></div><p>设置全局token的方法：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> res = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();pm.<span class="hljs-property">globals</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;token&quot;</span>, res.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>);</code></pre></div><p>接口文档v2版本：（有部分更新）</p><p><a href="https://documenter.getpostman.com/view/12387168/TzzDKb12">https://documenter.getpostman.com/view/12387168/TzzDKb12</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟列表的实现</title>
    <link href="/2022/09/11/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/11/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现一个时间格式化工具</title>
    <link href="/2022/09/11/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/09/11/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 如何封装一个时间格式化工具</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatTime</span>(<span class="hljs-params">timeStamp, fmtString</span>) &#123;  <span class="hljs-comment">// 1.先将时间戳转成Date的形式</span>  <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(timeStamp);  <span class="hljs-comment">// 2.建立正则表达式和值匹配的映射</span>  <span class="hljs-keyword">const</span> dateObject = &#123;    <span class="hljs-string">&quot;y+&quot;</span>: date.<span class="hljs-title function_">getFullYear</span>(),    <span class="hljs-string">&quot;M+&quot;</span>: date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>,    <span class="hljs-string">&quot;d+&quot;</span>: date.<span class="hljs-title function_">getDate</span>(),    <span class="hljs-string">&quot;h+&quot;</span>: date.<span class="hljs-title function_">getHours</span>(),    <span class="hljs-string">&quot;m+&quot;</span>: date.<span class="hljs-title function_">getMinutes</span>(),    <span class="hljs-string">&quot;s+&quot;</span>: date.<span class="hljs-title function_">getSeconds</span>(),  &#125;;  <span class="hljs-comment">// 遍历dateObject匹配</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> dateObject) &#123;    <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(key);    <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(fmtString)) &#123;      fmtString = fmtString.<span class="hljs-title function_">replace</span>(reg, (dateObject[key] + <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));    &#125;  &#125;  <span class="hljs-keyword">return</span> fmtString;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">formatTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>(), <span class="hljs-string">&quot;yyyy-MM-dd:hh:mm:ss&quot;</span>)); <span class="hljs-comment">//2022-09-11:17:05:48</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>electron 安装问题</title>
    <link href="/2022/09/11/electron-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/11/electron-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs crmsh">$ npm install electron --save-devnpm ERR! code <span class="hljs-number">1</span>npm ERR! path C:\Users\<span class="hljs-number">10152</span>\Desktop\study\代码碎屑\electron练习\my-electron-app\node_modules\electronnpm ERR! command failednpm ERR! command C:\WINDOWS\system32\cmd.exe /d /s /c <span class="hljs-keyword">node</span> <span class="hljs-title">install</span>.jsnpm ERR! RequestError: <span class="hljs-keyword">read</span> ECONNRESETnpm ERR!     at ClientRequest.<span class="hljs-tag">&lt;anonymous&gt;</span> (C:\Users\<span class="hljs-number">10152</span>\Desktop\study\代码碎屑\electron练习\my-electron-app\node_modules\got\source\request-as-event-emitter.js:<span class="hljs-number">178</span>:<span class="hljs-number">14</span>)npm ERR!     at Object.onceWrapper (<span class="hljs-keyword">node</span><span class="hljs-title">:events</span>:<span class="hljs-number">642</span>:<span class="hljs-number">26</span>)npm ERR!     at ClientRequest.emit (<span class="hljs-keyword">node</span><span class="hljs-title">:events</span>:<span class="hljs-number">539</span>:<span class="hljs-number">35</span>)npm ERR!     at ClientRequest.origin.emit (C:\Users\<span class="hljs-number">10152</span>\Desktop\study\代码碎屑\electron练习\my-electron-app\node_modules\@szmarczak\http-timer\source\index.js:<span class="hljs-number">37</span>:<span class="hljs-number">11</span>)npm ERR!     at TLSSocket.socketErrorListener (<span class="hljs-keyword">node</span><span class="hljs-title">:_http_client</span>:<span class="hljs-number">454</span>:<span class="hljs-number">9</span>)npm ERR!     at TLSSocket.emit (<span class="hljs-keyword">node</span><span class="hljs-title">:events</span>:<span class="hljs-number">527</span>:<span class="hljs-number">28</span>)npm ERR!     at emitErrorNT (<span class="hljs-keyword">node</span><span class="hljs-title">:internal</span>/streams/destroy:<span class="hljs-number">157</span>:<span class="hljs-number">8</span>)npm ERR!     at emitErrorCloseNT (<span class="hljs-keyword">node</span><span class="hljs-title">:internal</span>/streams/destroy:<span class="hljs-number">122</span>:<span class="hljs-number">3</span>)npm ERR!     at processTicksAndRejections (<span class="hljs-keyword">node</span><span class="hljs-title">:internal</span>/process/task_queues:<span class="hljs-number">83</span>:<span class="hljs-number">21</span>)npm ERR! A complete log of this run can be found <span class="hljs-keyword">in</span>:npm ERR!     D:\nodejs\node_cache\_logs\<span class="hljs-number">2022</span>-<span class="hljs-number">09</span>-<span class="hljs-number">10</span>T16_55_35_246Z-debug-<span class="hljs-number">0</span>.log</code></pre></div><p>eletron安装不成功可以设置下源</p><div class="code-wrapper"><pre><code class="hljs awk">npm config set ELECTRON_MIRROR https:<span class="hljs-regexp">//</span>npmmirror.com<span class="hljs-regexp">/mirrors/</span>electron/</code></pre></div><h4 id="electron-控制台中文乱码问题"><a href="#electron-控制台中文乱码问题" class="headerlink" title="electron 控制台中文乱码问题"></a>electron 控制台中文乱码问题</h4><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;   <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;</span><span class="hljs-keyword">Error</span>: <span class="hljs-keyword">no</span> <span class="hljs-keyword">test</span> specified\<span class="hljs-string">&quot; &amp;&amp; exit 1&quot;</span>,   <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;chcp 65001 &amp;&amp; electron .&quot;</span> &#125;,</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Electron</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Electron学习</title>
    <link href="/2022/09/10/Electron%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/10/Electron%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Electron</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>https了解</title>
    <link href="/2022/09/09/https%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/09/09/https%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http3了解</title>
    <link href="/2022/09/09/http3%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/09/09/http3%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node学习笔记</title>
    <link href="/2022/09/09/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/09/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-number">1.</span>node的输出<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">clear</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">trace</span>()<span class="hljs-number">2.</span>常见的全局对象特殊的全局对象，是各个模块都有的，但不是属于全局的__dirname<span class="hljs-comment">//获取当前文件所在的路径，不包括后面的文件名</span>__filename<span class="hljs-comment">//获取当前文件所在的路径名称包括文件名</span><span class="hljs-built_in">exports</span><span class="hljs-variable language_">module</span><span class="hljs-built_in">require</span>常见的全局对象process对象<span class="hljs-variable language_">console</span>对象定时器对象<span class="hljs-number">3.</span><span class="hljs-variable language_">global</span>和<span class="hljs-variable language_">window</span>的区别node中每一个文件都是一个独立的模块<span class="hljs-number">4.</span>模块化立即调用函数(<span class="hljs-variable constant_">IIFE</span>)是解决模块化的一种方式<span class="hljs-title class_">CommonJS</span>(<span class="hljs-variable constant_">CJS</span>)<span class="hljs-title class_">ESmodule</span>每个模块都有<span class="hljs-built_in">exports</span>,他会默认指向空对象,<span class="hljs-built_in">exports</span>指向的一个对象并在另外一个模块中被引用时，他们是指向同一个对象<span class="hljs-built_in">require</span>是对<span class="hljs-built_in">exports</span>的浅拷贝浅拷贝的本质就是引用赋值<span class="hljs-built_in">exports</span>中修改变量会使<span class="hljs-built_in">require</span>发生变化<span class="hljs-built_in">require</span>中的修改不会对<span class="hljs-built_in">exports</span>造成影响，因为<span class="hljs-built_in">require</span>是对<span class="hljs-built_in">exports</span>的拷贝<span class="hljs-number">5.</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>每一个模块都有一个<span class="hljs-variable language_">module</span>实例commomjs中没有<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>的概念，node中使用的是<span class="hljs-title class_">Moudle</span>类，每一个模块都是<span class="hljs-title class_">Modlue</span>的实例，也是<span class="hljs-variable language_">module</span>所以在<span class="hljs-title class_">Node</span>中真正导出的其实不是<span class="hljs-keyword">export</span>,而是<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>为什么<span class="hljs-built_in">exports</span>也可以导出因为<span class="hljs-variable language_">module</span>对象的<span class="hljs-built_in">exports</span>属性是<span class="hljs-keyword">export</span>对象的一个引用，也就是<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=<span class="hljs-built_in">exports</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>导出的值才是<span class="hljs-built_in">require</span>的值，默认<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>==<span class="hljs-keyword">export</span>,如果<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>指向另外一个值，则<span class="hljs-built_in">require</span>会引用这个值，而不是<span class="hljs-keyword">export</span>的值<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>的赋值是在顶层的<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=<span class="hljs-built_in">exports</span><span class="hljs-built_in">exports</span>=<span class="hljs-number">123</span><span class="hljs-comment">//module.exports在顶层引用的，如果后面再次修改exports的指向，则会无效</span><span class="hljs-number">6.</span><span class="hljs-built_in">require</span>()的查找规则<span class="hljs-number">1.</span>如果x是核心模块，直接会返回核心模块，<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;x&quot;</span>)<span class="hljs-comment">//会直接返回，停止查找</span><span class="hljs-number">2.</span>x是以./或者../或者/开头的会先将x当作一个文件先查找，如果有后缀名，则按后缀名格式查找，如果没有后缀名则<span class="hljs-number">1.</span>直接查找文件x<span class="hljs-number">2.</span>查找x.<span class="hljs-property">js</span><span class="hljs-number">3.</span>查找x.<span class="hljs-property">json</span><span class="hljs-number">4.</span>查找x.<span class="hljs-property">node</span>如果没有找到对应的文件，则会把他当成一个目录，查找里面的index文件<span class="hljs-number">1.</span>x/index.<span class="hljs-property">js</span><span class="hljs-number">2.</span>x/index.<span class="hljs-property">json</span><span class="hljs-number">3.</span>x/index.<span class="hljs-property">node</span>否则报错 not found<span class="hljs-number">3.</span>如果直接是一个<span class="hljs-title function_">X</span>(没有路径) 并且X不是一个核心模块则从最里面的node_module-&gt;最外面的node_module中去寻找<span class="hljs-number">7.</span><span class="hljs-built_in">require</span>的加载过程是同步的 <span class="hljs-number">8.</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>=&#123;&#125; <span class="hljs-built_in">exports</span>=<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>===<span class="hljs-keyword">export</span>=&#123;&#125; <span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>=<span class="hljs-built_in">exports</span><span class="hljs-number">9.</span>在源码中<span class="hljs-built_in">exports</span>=<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span><span class="hljs-number">10.</span>模块的加载过程模块在被第一次引入时，模块中的js代码会被运行一次模块被对此引入时，会被缓存，最终只会被加载一次如果有循环引入，他会按深度优先搜索遍历的方式进行加载<span class="hljs-number">11.</span><span class="hljs-variable constant_">ES</span> modules中<span class="hljs-keyword">export</span> &#123;&#125;<span class="hljs-comment">//不是一个对象，里面放置要到处的变量的列表</span><span class="hljs-keyword">import</span>默认必须放到顶部，<span class="hljs-keyword">import</span>是异步加载，<span class="hljs-keyword">import</span>加载模块不可以放到逻辑代码中<span class="hljs-title function_">import</span>().<span class="hljs-title function_">then</span>()<span class="hljs-comment">//进行动态加载</span><span class="hljs-number">12.</span>commonJS加载过程commonjs加载js文件的过程是运行时加载，并且是同步的，就是js引擎在执行代码的过程中加载模块同步意味着一个文件在没有加载结束之前，后面的代码都不加在commonjs通过<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>的导出一个对象，导出的是一个对象意味者可以将这个对象的引用在其他模块中赋值给其他变量，但是最终他们会指向同一个变量，那么一个变量修改了对象的属性，所有地方都会修改注意：<span class="hljs-built_in">require</span>进行解构的时候不会修改，因为解构会固定下当前的值<span class="hljs-number">13.</span><span class="hljs-variable constant_">ES</span> <span class="hljs-variable language_">module</span>的加载过程   <span class="hljs-variable constant_">ES</span> <span class="hljs-variable constant_">MODULE</span>加载js是编译的时候加载的，并且是异步的   编译时加载意味着<span class="hljs-keyword">import</span>不能和运行相关的内容放在一起使用   比如<span class="hljs-keyword">from</span>后面的路径要动态获取   比如不能将<span class="hljs-keyword">import</span>放到<span class="hljs-keyword">if</span>语句的代码块里面，所以es <span class="hljs-variable language_">module</span>时静态解析   异步意味着js引擎遇到<span class="hljs-keyword">import</span>时会获取到这个js文件，但是这个获取的过程是异步的，并不会阻塞进程的执行   <span class="hljs-keyword">type</span>-=<span class="hljs-variable language_">module</span>相当于script上的<span class="hljs-keyword">async</span>属性，如果后面还有js代码，他不会阻塞js代码的执行   <span class="hljs-variable constant_">ES</span> <span class="hljs-title class_">Module</span>通过<span class="hljs-keyword">export</span>导出的是变量本身的引用： <span class="hljs-keyword">export</span>在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（<span class="hljs-variable language_">module</span> environment record）； 模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的； 而在导入的地方，我们是可以实时的获取到绑定的最新值的；  所以，如果在导出的模块中修改了变化，那么导入的地方可以实时获取最新的变量；  注意：在导入的地方不可以修改变量，因为它只是被绑定到了这个变量上（其实是一个常量）   <span class="hljs-number">14.</span>在node中要使用es <span class="hljs-variable language_">module</span> 方式一：package.<span class="hljs-property">json</span>中配置<span class="hljs-attr">type</span>:<span class="hljs-variable language_">module</span> 方式二:使用以.<span class="hljs-property">mjs</span>结尾的文件 <span class="hljs-number">15.</span>内置模块path 从路径获取信息 <span class="hljs-title function_">dirname</span>()<span class="hljs-comment">//获取文件的父文件夹</span> <span class="hljs-title function_">basename</span>()<span class="hljs-comment">//获取文件名</span> <span class="hljs-title function_">extname</span>()<span class="hljs-comment">//获取文件扩展名</span> 路径的拼接 如果我们希望将多个路径进行拼接，但是不同的操作系统可能是使用不同的分隔符 这个时候我们可以使用path.<span class="hljs-property">join</span>函数 将文件和某个文件夹拼接 如果我们希望将某个文件和文件夹拼接，可以使用path.<span class="hljs-property">resolve</span> resolve函数会判断我们拼接的路径前面是否有/或者../或者./ 如果有表示是一个绝对路径，会返回对应的拼接路径 如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接 path.<span class="hljs-title function_">resolve</span>() 方法将路径或路径片段的序列解析为绝对路径。 如果没有传入 path 片段，则 path.<span class="hljs-title function_">resolve</span>() 将返回当前工作目录的绝对路径。  path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;/foo/bar&#x27;</span>, <span class="hljs-string">&#x27;./baz&#x27;</span>);            <span class="hljs-comment">// 返回: &#x27;/foo/bar/baz&#x27;</span>            path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;/foo/bar&#x27;</span>, <span class="hljs-string">&#x27;/tmp/file/&#x27;</span>);            <span class="hljs-comment">// 返回: &#x27;/tmp/file&#x27;</span>            path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;wwwroot&#x27;</span>, <span class="hljs-string">&#x27;static_files/png/&#x27;</span>, <span class="hljs-string">&#x27;../gif/image.gif&#x27;</span>);            <span class="hljs-comment">// 如果当前工作目录是 /home/myself/node，</span>            <span class="hljs-comment">// 则返回 &#x27;/home/myself/node/wwwroot/static_files/gif/image.gif&#x27;</span> <span class="hljs-number">16.</span>fs模块 fs操作文件的三种方式</code></pre></div><p><img src="https://img1.imgtp.com/2022/09/11/T30nJvRF.png" alt="QQ截图20220618120700.png"></p><p>17.文件描述符</p><p>​    在POSIX系统上，对于每个进程，内核都维护者一张当前打开的资源和文件的表格</p><p>​    每个打开的文件都会分配一个称为文件秒师傅的简单数字标识符</p><p>​    在系统层，所有系统操作都是使用这些文件描述符来标识和跟踪每一个特定文件</p><p>​    windows系统有不同的机制</p><p>​    fs.open()用于分配新的文件描述符，一旦被分配，则文件描述符可用于文件的读取数据，向文件写入数据或者请求关于文件的信息</p><p><img src="https://img1.imgtp.com/2022/09/11/TXLJdkIn.png" alt="QQ截图20220619093740.png"></p><p>18.文件的读写</p><p>​    </p><div class="code-wrapper"><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File(<span class="hljs-params">path</span>,<span class="hljs-params">options</span>?,<span class="hljs-params">callback</span>)</span>   <span class="hljs-comment">//读取文件的内容</span>fs.write<span class="hljs-constructor">File(<span class="hljs-params">file</span>,<span class="hljs-params">data</span>,<span class="hljs-params">options</span>?,<span class="hljs-params">callback</span>)</span> <span class="hljs-comment">//写入文件</span></code></pre></div><p><img src="https://img1.imgtp.com/2022/09/11/gbD9UytN.png" alt="QQ截图20220619094754.png"></p><div class="code-wrapper"><pre><code class="hljs dts">options中的属性<span class="hljs-symbol">flag:</span>写入的方式<span class="hljs-symbol">w:</span>打开文件写入，默认值w+:打开文件进行读写，如果不存在则会创建文件r+:打开文件进行读写，如果不存在就会抛出异常<span class="hljs-symbol">r:</span>打开文件读取，读取时的默认值<span class="hljs-symbol">a:</span>打开要写入的文件，将流放在文件的末尾，如果不存在则会创建文件a+:打开文件进行读写，将流放到文件末尾，如果不存在则创建<span class="hljs-symbol">encoding:</span>字符的编码现在基本上使用utf<span class="hljs-number">-8</span>如果不填encoding则会返回buffer</code></pre></div><p>19.文件夹的操作</p><p><img src="https://img1.imgtp.com/2022/09/11/ladw1Jt6.png" alt="QQ截图20220619093820.png"><br>20.events模块</p><p>​     Node中的核心API都是基于异步事件驱动的：</p><p>​     发出事件和监听事件都是通过EventEmitter类来完成，他们都是属于events对象</p><p>​      </p><div class="code-wrapper"><pre><code class="hljs mel">const <span class="hljs-keyword">emitter</span>=new EventEmitter()<span class="hljs-keyword">emitter</span>.on(eventName.listener)<span class="hljs-comment">//监听事件，也可以使用addListener</span><span class="hljs-keyword">emitter</span>.off(eventName.listener)<span class="hljs-comment">//移出事件监听，也可以使用removeLitener</span><span class="hljs-keyword">emitter</span>.<span class="hljs-keyword">emit</span>(eventName,...args?)<span class="hljs-comment">//发出事件，可以携带参数</span></code></pre></div><p><img src="https://img1.imgtp.com/2022/09/11/gbfKncoB.png" alt="QQ截图20220619135051.png"><br><img src="https://img1.imgtp.com/2022/09/11/z58jVfjS.png" alt="QQ截图20220619135226.png"></p><div class="code-wrapper"><pre><code class="hljs shij">emitter.once(eventName,listener)事件只监听一次emitter.prependListener()将监听事件添加到最前面emitter.prependOnceListener()将监听事件添加到最前面但只监听一次emitter.removeAllListeners(eventName?)移除所有事件</code></pre></div><p>21、npm包管理工具</p><p>​            npm run start=&gt;npm start</p><p>​            npm run test=&gt;npm test</p><p>​            npm run stop=&gt;npm stop</p><p>​            npm run restart=&gt;npm restart</p><p>22.npm config get cache //cmd中执行查看缓存所在目录</p><p>23.Buffer类</p><p>​    使用Buffer来存储二进制</p><p>​    buf=Buffer.from()//转换成buffer</p><p>​    中文会转换成unicode编码  3个unicode编码代表一个汉字 默认是utf8编码</p><p>​    <code>buf.toString([encoding[, start[, end]]])</code>//解码 encode默认是utf8</p><p>​    buffer的另外一种创建方式</p><p>​    <code>Buffer.alloc(size[, fill[, encoding]])</code> size表示创建的大小 默认是utf8</p><p>​    buffer可以将图片转换成二进制流进行传输，也可以把二进制转换成图片存储</p><p>24.读取文件返回的是一个二进制流</p><p><img src="https://img1.imgtp.com/2022/09/11/yyxGHUMi.png" alt="QQ截图20220623141058.png"><br>25.读取图片并且写入到另外一个文件</p><p><img src="https://img1.imgtp.com/2022/09/11/TduZGuBK.png" alt="QQ截图20220623141209.png"><br>26.sharp插件进行设置图片</p><p>27.Buffer的创建过程</p><p>​    事实上我们创建Buffer时，并不会频繁的向操作系统申请内存，它会默认先申请一个8 * 1024个字节大小的内存， 也就是8kb</p><p>28.Buffer的源码</p><p>29.进程和线程</p><p>​    进程:启动一个程序，既可以默认开启一个进程（也可以多进程）</p><p>​    线程：操作系统能够运行调度的最小单位</p><p>30.Node事件循环的阶段</p><p>​     一次完整的事件循环Tick分成很多个阶段</p><p>​    定时器(Timer):本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数</p><p>​    待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到 ECONNREFUSED</p><p>​    idle, prepare：仅系统内部使用</p><p>​    轮询（Poll）：检索新的 I/O 事件；执行与 I/O 相关的回调</p><p>​    检测：setImmediate() 回调函数在这里执行</p><p>​    关闭的回调函数：一些关闭的回调函数，如：socket.on(‘close’, …)</p><p>31.Node的微任务和宏任务</p><p>​    微任务队列</p><p>​    nettick queue:process.nextTick</p><p>​    other queue:Promise的then回调，queueMicrotask</p><p>​    宏任务队列</p><p>​    timer queue:setTimeout,setInterval    </p><p>​    poll queue :IO事件</p><p>​    check queue:setImmediate</p><p>​    close queue:close事件</p><p>32.Stream可以读取或者写入部分</p><p>​    4.中基本的流类型</p><p>​        writable:可以向其写人数据的流 fs.createWriteStream()</p><p>​        Readable:可以从中读取数据的流 fs.createReadStream()</p><p>​        Duplex：同时为Readable和wratable net.Socket</p><p>​        Transform:Duplex可以在写入和读取数据时修改或者转换数据的流  zlib.createDeflate()</p><p>33.Readable</p><p><img src="https://img1.imgtp.com/2022/09/11/QggeUwVk.png" alt="QQ截图20220624165628.png"><br>34.writable</p><p><img src="https://img1.imgtp.com/2022/09/11/14Ca9DGs.png" alt="QQ截图20220624183130.png"><br>35.pipe</p><p>从读取到输出到另外一个文件也可以这么写</p><p><img src="https://img1.imgtp.com/2022/09/11/14Ca9DGs.png" alt="QQ截图20220624183130.png"><br>36.http</p><p>安装nodemon来热更新自动启动</p><p>37.axios可以在浏览器用也可以在node中用，浏览器用的是xhr,node中使用的是http内置模块</p><p>38.文件上传</p><p>39.express</p><p>​        express核心是中间件</p><p>​        安装express</p><p>​        1.创建一个文件夹 </p><p>​        2.npx express-generator</p><p>​        3.npm install</p><p>​        4.DEBUG=express:* npm start</p><p>​        第二种安装方式</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<span class="hljs-built_in">npm</span> install express</code></pre></div><p>40.中间件</p><p>41.文件上传</p><p>​    使用multer  npm install multer</p><p>42.打印日志</p><p>​    使用morgan npm install morgan</p><p>43express路由</p><p>44.使用express部署静态资源，将express作为静态资源服务器</p><p>45.错误处理</p><p>46.调用express()到底创建的是什么</p><p>47.app.listen()启动服务器</p><p>​        如何可以结合原生来启动服务器</p><p>​        express-&gt;http.createServer.listen</p><p>48.app.use(中间件)内部发生了什么</p><p>49.用户发送了请求，中间件是如何被回调</p><p>50.next的为什么会执行下一个中间件</p><p>51.koa洋葱模型</p><p>​        koa的同步和异步都是符合洋葱模型的</p><p>​        express只有同步代码才会符合洋葱模型</p><p>52.koa和express的区别</p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用axios封装请求工具</title>
    <link href="/2022/09/09/%E4%BD%BF%E7%94%A8axios%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/09/09/%E4%BD%BF%E7%94%A8axios%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//request.js</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">AxiosInstance</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RequestInterceptors</span>, <span class="hljs-title class_">RequestConfig</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./type&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElLoading</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-plus&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_LOADING</span> = <span class="hljs-literal">true</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">axiosRequest</span> &#123;  <span class="hljs-attr">instance</span>: <span class="hljs-title class_">AxiosInstance</span>;  interceptors?: <span class="hljs-title class_">RequestInterceptors</span>;  <span class="hljs-attr">showLoading</span>: boolean;  loading?: any;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config: RequestConfig</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = axios.<span class="hljs-title function_">create</span>(config);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span> = config.<span class="hljs-property">showLoading</span> ?? <span class="hljs-variable constant_">DEFAULT_LOADING</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span> = config.<span class="hljs-property">interceptors</span>;    <span class="hljs-comment">// 将config中的拦截器传入</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestInterceptor</span>,      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestInterceptorCatch</span>,    );    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseInterceptor</span>,      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseInterceptorCatch</span>,    );    <span class="hljs-comment">// 设置通用的拦截器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span> = <span class="hljs-title class_">ElLoading</span>.<span class="hljs-title function_">service</span>(&#123;            <span class="hljs-attr">lock</span>: <span class="hljs-literal">true</span>,            <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;正在请求数据。。。。。&quot;</span>,            <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>,          &#125;);        &#125;        <span class="hljs-keyword">return</span> config;      &#125;,      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> err;      &#125;,    );    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span>?.<span class="hljs-title function_">close</span>();        <span class="hljs-keyword">const</span> data = res.<span class="hljs-property">data</span>;        <span class="hljs-keyword">if</span> (data.<span class="hljs-property">returnCode</span> == <span class="hljs-string">&quot;-1001&quot;</span>) &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求失败————————————————————————————&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">return</span> data;        &#125;      &#125;,      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span>?.<span class="hljs-title function_">close</span>();        <span class="hljs-keyword">if</span> (err.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;404&quot;</span>) &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;页面不存在&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> err;      &#125;,    );  &#125;  request&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestInterceptor</span>) &#123;        config = config.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">requestInterceptor</span>(config);      &#125;      <span class="hljs-keyword">if</span> (config.<span class="hljs-property">showLoading</span> === <span class="hljs-literal">false</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span> = config.<span class="hljs-property">showLoading</span>;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>        .<span class="hljs-property">request</span>&lt;any, T&gt;(config)        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseInterceptor</span>) &#123;            res = config.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">responseInterceptor</span>(res);          &#125;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span> = <span class="hljs-variable constant_">DEFAULT_LOADING</span>;          <span class="hljs-title function_">resolve</span>(res);        &#125;)        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span> = <span class="hljs-variable constant_">DEFAULT_LOADING</span>;          <span class="hljs-title function_">reject</span>(err);          <span class="hljs-keyword">return</span> err;        &#125;);    &#125;);  &#125;  get&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span> &#125;);  &#125;  post&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span> &#125;);  &#125;  <span class="hljs-keyword">delete</span>&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;DELETE&quot;</span> &#125;);  &#125;  patch&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;PATCH&quot;</span> &#125;);  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> axiosRequest;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//type.js</span><span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">export</span> interface <span class="hljs-title class_">RequestInterceptors</span>&lt;T = <span class="hljs-title class_">AxiosResponse</span>&gt; &#123;  requestInterceptor?: <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> <span class="hljs-title class_">AxiosRequestConfig</span>;  requestInterceptorCatch?: <span class="hljs-function">(<span class="hljs-params">error: any</span>) =&gt;</span> any;  responseInterceptor?: <span class="hljs-function">(<span class="hljs-params">res: T</span>) =&gt;</span> T;  responseInterceptorCatch?: <span class="hljs-function">(<span class="hljs-params">error: any</span>) =&gt;</span> any;&#125;<span class="hljs-keyword">export</span> interface <span class="hljs-title class_">RequestConfig</span>&lt;T = <span class="hljs-title class_">AxiosResponse</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosRequestConfig</span> &#123;  interceptors?: <span class="hljs-title class_">RequestInterceptors</span>&lt;T&gt;;  showLoading?: boolean;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//index.js</span><span class="hljs-keyword">import</span> axiosRequest <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./request&quot;</span>;<span class="hljs-keyword">import</span> localCache <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/cache&quot;</span>;<span class="hljs-keyword">const</span> httpRequest = <span class="hljs-keyword">new</span> <span class="hljs-title function_">axiosRequest</span>(&#123;  <span class="hljs-attr">baseURL</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_APP_BASE_URL</span>,  <span class="hljs-attr">timeout</span>: <span class="hljs-title class_">Number</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_TIME_OUT</span>),  <span class="hljs-attr">interceptors</span>: &#123;    <span class="hljs-attr">requestInterceptor</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> token = localCache.<span class="hljs-title function_">getCache</span>(<span class="hljs-string">&quot;token&quot;</span>);      <span class="hljs-keyword">if</span> (token) &#123;        config.<span class="hljs-property">headers</span> = &#123;&#125;;        config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span>;      &#125;      <span class="hljs-keyword">return</span> config;    &#125;,    <span class="hljs-attr">requestInterceptorCatch</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> error;    &#125;,    <span class="hljs-attr">responseInterceptor</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> res;    &#125;,    <span class="hljs-attr">responseInterceptorCatch</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> error;    &#125;,  &#125;,&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> httpRequest;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>axios</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gulp学习</title>
    <link href="/2022/09/08/gulp%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/08/gulp%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>glup</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>rollup学习</title>
    <link href="/2022/09/08/rollup%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/08/rollup%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>rollup</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vite3学习</title>
    <link href="/2022/09/08/vite3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/08/vite3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>vite</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack5学习</title>
    <link href="/2022/09/08/webpack5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/08/webpack5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//path.js</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> appDir = process.<span class="hljs-title function_">cwd</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Current directory: <span class="hljs-subst">$&#123;appDir&#125;</span>`</span>);<span class="hljs-keyword">const</span> <span class="hljs-title function_">resolveApp</span> = (<span class="hljs-params">relativePath</span>) =&gt; path.<span class="hljs-title function_">resolve</span>(appDir, relativePath);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = resolveApp;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//webpack.common.js</span><span class="hljs-keyword">const</span> resolveApp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./paths&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">DefinePlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">CopyWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;copy-webpack-plugin&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">ESLintPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;eslint-webpack-plugin&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<span class="hljs-keyword">const</span> productionConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.prod&#x27;</span>);<span class="hljs-keyword">const</span> developmentConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.dev&#x27;</span>);<span class="hljs-comment">/***</span><span class="hljs-comment"> * 这里有三种方法来进行代码分离，它可以减少打包文件大小，减少文件的加载时间</span><span class="hljs-comment"> *  它主要的目的是将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件；</span><span class="hljs-comment">    比如默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，</span><span class="hljs-comment">就会影响首页的加载速度</span><span class="hljs-comment">    代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能</span><span class="hljs-comment">      1.入口起点：使用entry配置手动分离代码；</span><span class="hljs-comment">      2.防止重复：使用Entry Dependencies或者SplitChunksPlugin去重和分离代码；</span><span class="hljs-comment">      3.动态导入：通过模块的内联函数调用来分离代码</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">commonConfig</span> = (<span class="hljs-params">env, args</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> devMode = args.<span class="hljs-property">mode</span> !== <span class="hljs-string">&#x27;production&#x27;</span>;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">entry</span>: [<span class="hljs-string">&#x27;./src/index.js&#x27;</span>],    <span class="hljs-comment">// 多入口文件 如果两个文件引用相同的代码会造成重复打包，增大单个bundle的大小，从而浪费带宽</span>    <span class="hljs-comment">// entry: &#123;</span>    <span class="hljs-comment">//   index: &#x27;./src/index.js&#x27;,</span>    <span class="hljs-comment">//   another: &#x27;./src/another-module.js&#x27;</span>    <span class="hljs-comment">// &#125;,</span>    <span class="hljs-comment">//将公共的包分离出来，减小bundle体积</span>    <span class="hljs-comment">// entry: &#123;</span>    <span class="hljs-comment">//   index: &#123;</span>    <span class="hljs-comment">//     import: &#x27;./src/index.js&#x27;,</span>    <span class="hljs-comment">//     dependOn: &#x27;shared&#x27;</span>    <span class="hljs-comment">//   &#125;,</span>    <span class="hljs-comment">//   another: &#123;</span>    <span class="hljs-comment">//     import: &#x27;./src/another-module.js&#x27;,</span>    <span class="hljs-comment">//     dependOn: &#x27;shared&#x27;</span>    <span class="hljs-comment">//   &#125;,</span>    <span class="hljs-comment">//   shared: &#x27;lodash&#x27;</span>    <span class="hljs-comment">// &#125;,</span>    <span class="hljs-attr">output</span>: &#123;      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;js/[name].bundle.js&#x27;</span>,      <span class="hljs-comment">// 为import().then异步加载使用</span>      <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;js/[name].[hash:6].chunk.js&#x27;</span>,      <span class="hljs-comment">// 必须是一个绝对路径</span>      <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolveApp</span>(<span class="hljs-string">&#x27;./dist&#x27;</span>),      <span class="hljs-comment">// 重新打包时清理dist文件夹</span>      <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>      <span class="hljs-comment">// 使用webpack-dev-middleware需要 目的是让文件在服务器中也可以使用,找到对应的文件,要在生产环境放到服务器中才加</span>      <span class="hljs-comment">// output中的path的作用是告知webpack之后的输出目录</span>      <span class="hljs-comment">// publicPath: &quot;/&quot;,</span>      <span class="hljs-comment">// Asset Modules 将这个模块下的文件输出到dist下的指定文件夹</span>      <span class="hljs-comment">// assetModuleFilename: &quot;img/[name].[hash:6][ext]&quot;</span>    &#125;,    <span class="hljs-comment">// /如果我们要在单个 HTML 页面上使用多个入口点，还需要 optimization.runtimeChunk: &#x27;single&#x27;</span>    <span class="hljs-comment">// optimization: &#123;</span>    <span class="hljs-comment">//   runtimeChunk: &#x27;single&#x27;</span>    <span class="hljs-comment">// &#125;,</span>    <span class="hljs-attr">optimization</span>: &#123;      <span class="hljs-comment">// optimization.chunkIds配置用于告知webpack模块的id采用什么算法生成</span>      <span class="hljs-comment">// natural: 使用自然数(不推荐),</span>      <span class="hljs-comment">// named: 使用包所在目录作为name(在开发环境推荐)</span>      <span class="hljs-comment">// deterministic: 生成id, 针对相同文件生成的id是不变</span>      <span class="hljs-comment">// chunkIds: devMode ? &#x27;deterministic&#x27; : &#x27;named&#x27;,</span>      <span class="hljs-comment">// 方式二使用splitChunkPlugin默认集成</span>      <span class="hljs-attr">splitChunks</span>: &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * async 默认 针对异步导入</span><span class="hljs-comment">         * initial 针对同步导入</span><span class="hljs-comment">         * all 针对同步和异步</span><span class="hljs-comment">         */</span>        <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,        <span class="hljs-comment">// 最小尺寸: 如果拆分出来一个, 那么拆分出来的这个包的大小最小为minSize</span>        <span class="hljs-attr">minSize</span>: <span class="hljs-number">20000</span>,        <span class="hljs-comment">// 将大于maxSize的包, 拆分成不小于minSize的包</span>        <span class="hljs-attr">maxSize</span>: <span class="hljs-number">20000</span>,        <span class="hljs-comment">// 表示至少被引入一次的包才会被分包，没有引用过的不会被打包</span>        <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span>,        <span class="hljs-comment">/**</span><span class="hljs-comment">         * cacheGroups：</span><span class="hljs-comment"> 用于对拆分的包就行分组，比如一个lodash在拆分之后，并不会立即打包，而是会等到有没有其他符合规则的包一起来打</span><span class="hljs-comment">包；</span><span class="hljs-comment"> test属性：匹配符合规则的包；</span><span class="hljs-comment"> name属性：拆分包的name属性；</span><span class="hljs-comment"> filename属性：拆分包的名称，可以自己使用placeholder属性</span><span class="hljs-comment">         */</span>        <span class="hljs-attr">cacheGroups</span>: &#123;          <span class="hljs-attr">vendor</span>: &#123;            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;js/[id]_venders.js&#x27;</span>,            <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span>          &#125;,          <span class="hljs-attr">default</span>: &#123;            <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;js/common_[id].js&#x27;</span>,            <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>          &#125;        &#125;      &#125;,      <span class="hljs-comment">/**optimization. runtimeChunk配置</span><span class="hljs-comment">       * 配置runtime相关的代码是否抽取到一个单独的chunk中：</span><span class="hljs-comment">       * runtime相关的代码指的是在运行环境中，对模块进行解析、加载、模块信息相关的代码；</span><span class="hljs-comment">       * 抽离出来后，有利于浏览器缓存的策略：</span><span class="hljs-comment">       * 比如我们修改了业务代码（main），那么runtime和component、bar的chunk是不需要重新加载的</span><span class="hljs-comment">       * 比如我们修改了component、bar的代码，那么main中的代码是不需要重新加载的</span><span class="hljs-comment">       *   true/multiple ：针对每个入口打包一个runtime文件；</span><span class="hljs-comment">             single 打包一个runtime文件</span><span class="hljs-comment">             object: name name属性决定runtimeChunk的名称；</span><span class="hljs-comment">       */</span>      <span class="hljs-attr">runtimeChunk</span>: &#123;        <span class="hljs-attr">name</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">entrypoint</span>) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-string">`other-<span class="hljs-subst">$&#123;entrypoint.name&#125;</span>`</span>;        &#125;      &#125;    &#125;,    <span class="hljs-attr">module</span>: &#123;      <span class="hljs-attr">rules</span>: [        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,          <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,          <span class="hljs-comment">// 本质上是依赖于typescript(typescript compiler)</span>          <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>        &#125;,        &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx$/i</span>, <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span> &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?js$/i</span>,          <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,          <span class="hljs-comment">// 将es6=》es5</span>          <span class="hljs-attr">use</span>: &#123;            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>          &#125;        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,          <span class="hljs-attr">use</span>: [            devMode ? <span class="hljs-string">&#x27;style-loader&#x27;</span> : <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,            &#123;              <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,              <span class="hljs-attr">options</span>: &#123;                <span class="hljs-comment">// 允许在使用css-loader之前加载多少个模块 postcss-loader</span>                <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>              &#125;            &#125;,            <span class="hljs-string">&#x27;postcss-loader&#x27;</span>          ]        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/i</span>,          <span class="hljs-attr">use</span>: [            devMode ? <span class="hljs-string">&#x27;style-loader&#x27;</span> : <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,            &#123;              <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,              <span class="hljs-attr">options</span>: &#123;                <span class="hljs-comment">// 0 =&gt; no loaders (default);</span>                <span class="hljs-comment">// 1 =&gt; postcss-loader;</span>                <span class="hljs-comment">// 2 =&gt; postcss-loader, less-loader</span>                <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">2</span>              &#125;            &#125;,            <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,            <span class="hljs-string">&#x27;less-loader&#x27;</span>          ]        &#125;,        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：</span><span class="hljs-comment">         * 1.asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现</span><span class="hljs-comment">         * 2.asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现</span><span class="hljs-comment">         * 3.asset/source 导出资源的源代码。之前通过使用 raw-loader 实现</span><span class="hljs-comment">         * 4.asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源</span><span class="hljs-comment">  体积限制实现</span><span class="hljs-comment">         */</span>        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpeg|svg|gif|jpg)$/</span>,          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset&#x27;</span>,          <span class="hljs-attr">generator</span>: &#123;            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;img/[name].[hash:6].[ext]&#x27;</span>          &#125;,          <span class="hljs-attr">parser</span>: &#123;            <span class="hljs-attr">dataUrlCondition</span>: &#123;              <span class="hljs-attr">maxSize</span>: <span class="hljs-number">100</span> * <span class="hljs-number">1024</span>            &#125;          &#125;        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(woff|woff2|eot|ttf|otf)$/i</span>,          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset/resource&#x27;</span>,          <span class="hljs-attr">generator</span>: &#123;            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;font/[name].[hash:6].[ext]&#x27;</span>          &#125;        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(csv|tsv)$/</span>,          <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;csv-loader&#x27;</span>]        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.xml$/</span>,          <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;xml-loader&#x27;</span>]        &#125;      ]    &#125;,    <span class="hljs-attr">resolve</span>: &#123;      <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.wasm&#x27;</span>, <span class="hljs-string">&#x27;.mjs&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>, <span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>],      <span class="hljs-attr">alias</span>: &#123;        <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">resolveApp</span>(<span class="hljs-string">&#x27;./src&#x27;</span>)      &#125;    &#125;,    <span class="hljs-attr">plugins</span>: [      <span class="hljs-keyword">new</span> <span class="hljs-title class_">ESLintPlugin</span>(),      <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;developement&#x27;</span>,        <span class="hljs-comment">// html模板</span>        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/asset/index.html&#x27;</span>      &#125;),      <span class="hljs-comment">// 定义全局常量</span>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefinePlugin</span>(&#123;        <span class="hljs-attr">BASE_URL</span>: <span class="hljs-string">&#x27;&quot;./&quot;&#x27;</span>      &#125;),      <span class="hljs-comment">// 复制文件到dist文件夹</span>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyWebpackPlugin</span>(&#123;        <span class="hljs-attr">patterns</span>: [          &#123;            <span class="hljs-attr">from</span>: <span class="hljs-string">&#x27;src/asset&#x27;</span>,            <span class="hljs-attr">globOptions</span>: &#123;              <span class="hljs-attr">ignore</span>: [<span class="hljs-string">&#x27;**/index.html&#x27;</span>, <span class="hljs-string">&#x27;**/.DS_Store&#x27;</span>]            &#125;          &#125;        ]      &#125;)    ]  &#125;;&#125;;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env, args</span>) =&gt;</span> &#123;  <span class="hljs-keyword">switch</span> (args.<span class="hljs-property">mode</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;development&#x27;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">commonConfig</span>(env, args), developmentConfig);    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;production&#x27;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">commonConfig</span>(env, args), productionConfig);    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;No matching configuration was fou)nd!&#x27;</span>);  &#125;&#125;;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//webpack.dev.js</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">HotModuleReplacementPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">entry</span>: [<span class="hljs-string">&#x27;webpack-hot-middleware/client?noInfo=false&amp;reload=true&#x27;</span>],  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,  <span class="hljs-comment">// 在开发环境中使用</span>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,  <span class="hljs-comment">// --watch 需要手动刷新页面不方便</span>  <span class="hljs-comment">// 开启本地服务器</span>  <span class="hljs-comment">// 官方其实有提到，建议 devServer.publicPath 与 output.publicPath相同</span>  <span class="hljs-attr">devServer</span>: &#123;    <span class="hljs-attr">static</span>: <span class="hljs-string">&#x27;./dist&#x27;</span>,    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  hot: &#x27;only&#x27;：表示热模块替换，编译失败后不会刷新整个页面</span><span class="hljs-comment">     */</span>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//开启gzip压缩</span>    <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;auto&#x27;</span>, <span class="hljs-comment">//修改本地服务器端口号, auto由服务器自动分配一个端口号</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * historyApiFallback是开发中一个非常常见的属性，它主要的作用是解决SPA页面在路由跳转之后，进行页面刷新</span><span class="hljs-comment">时，返回404的错误</span><span class="hljs-comment">    如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容</span><span class="hljs-comment">     */</span>    <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">//  设置主机地址</span>    <span class="hljs-comment">// host: &#x27;0.0.0.0&#x27;,</span>    <span class="hljs-comment">// 是否自动打开浏览器</span>    <span class="hljs-comment">// open: true,</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置开发代理</span><span class="hljs-comment">     */</span>    <span class="hljs-attr">proxy</span>: &#123;      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000/api&#x27;</span>,        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>      &#125;    &#125;  &#125;,  <span class="hljs-attr">plugins</span>: [    <span class="hljs-comment">// 使用webpack-hot-middleware替代webpack-dev-middleware开启热更新，因为webpack-dev-middleware不能够热更新</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HotModuleReplacementPlugin</span>()  ]&#125;;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//webpack.prod.js</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;css-minimizer-webpack-plugin&#x27;</span>);<span class="hljs-comment">// const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;);</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 生产环境中使用CDN，不需要下载包，排除这些库</span><span class="hljs-comment">   */</span>  <span class="hljs-attr">externals</span>: &#123;    <span class="hljs-comment">// window._</span>    <span class="hljs-attr">lodash</span>: <span class="hljs-string">&#x27;_&#x27;</span>,    <span class="hljs-comment">// window.dayjs</span>    <span class="hljs-attr">dayjs</span>: <span class="hljs-string">&#x27;dayjs&#x27;</span>  &#125;,  <span class="hljs-comment">// optimization: &#123;</span>  <span class="hljs-comment">//   //  生产环境中有tree shaking</span>  <span class="hljs-comment">//   minimize: false,</span>  <span class="hljs-comment">//   minimizer: [</span>  <span class="hljs-comment">//     // 对js代码进行压缩相关的操作，开发环境不需要压缩，减少打包时间</span>  <span class="hljs-comment">//     new TerserPlugin(&#123;</span>  <span class="hljs-comment">//       parallel: true,</span>  <span class="hljs-comment">//       extractComments: false,</span>  <span class="hljs-comment">//       terserOptions: &#123;</span>  <span class="hljs-comment">//         compress: &#123;</span>  <span class="hljs-comment">//           arguments: false,</span>  <span class="hljs-comment">//           dead_code: true</span>  <span class="hljs-comment">//         &#125;,</span>  <span class="hljs-comment">//         mangle: true,</span>  <span class="hljs-comment">//         toplevel: true,</span>  <span class="hljs-comment">//         keep_classnames: true,</span>  <span class="hljs-comment">//         keep_fnames: true</span>  <span class="hljs-comment">//       &#125;</span>  <span class="hljs-comment">//     &#125;)</span>  <span class="hljs-comment">//   ]</span>  <span class="hljs-comment">// &#125;,</span>  <span class="hljs-attr">plugins</span>: [    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 该插件将 CSS 提取到单独的文件中。它为每个包含 CSS 的 JS 文件创建一个 CSS 文件。它支持 CSS 和 SourceMaps 的按需加载。它建立在新的 webpack v5 功能之上，需要 webpack 5 才能工作。</span><span class="hljs-comment">     * 异步加载</span><span class="hljs-comment">无重复编译（性能）</span><span class="hljs-comment">更容易使用</span><span class="hljs-comment">特定于 CSS</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;css/[name].[contenthash:8].css&#x27;</span>,      <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;css/[name].[contenthash:8].css&#x27;</span>    &#125;),    <span class="hljs-comment">// 对css进行压缩 这样写可以只在production中使用</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>()  ]&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Hash、ContentHash、ChunkHash</span><span class="hljs-comment"> */</span><span class="hljs-comment">//  在我们给打包的文件进行命名的时候，会使用placeholder，placeholder中有几个属性比较相似：</span><span class="hljs-comment">// p hash、chunkhash、contenthash</span><span class="hljs-comment">// p hash本身是通过MD4的散列函数处理后，生成一个128位的hash值（32个十六进制）；</span><span class="hljs-comment">// n hash值的生成和整个项目有关系：</span><span class="hljs-comment">// p 比如我们现在有两个入口index.js和main.js；</span><span class="hljs-comment">// p 它们分别会输出到不同的bundle文件中，并且在文件名称中我们有使用hash；</span><span class="hljs-comment">// p 这个时候，如果修改了index.js文件中的内容，那么hash会发生变化；</span><span class="hljs-comment">// p 那就意味着两个文件的名称都会发生变化；</span><span class="hljs-comment">// n chunkhash可以有效的解决上面的问题，它会根据不同的入口进行借来解析来生成hash值：</span><span class="hljs-comment">// p 比如我们修改了index.js，那么main.js的chunkhash是不会发生改变的；</span><span class="hljs-comment">// n contenthash表示生成的文件hash名称，只和内容有关系：</span><span class="hljs-comment">// p 比如我们的index.js，引入了一个style.css，style.css有被抽取到一个独立的css文件中；</span><span class="hljs-comment">// p 这个css文件在命名时，如果我们使用的是chunkhash；</span><span class="hljs-comment">// p 那么当index.js文件的内容发生变化时，css文件的命名也会发生变化；</span><span class="hljs-comment">// p 这个时候我们可以使用contenthash</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//server.js</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-keyword">const</span> webpackDevMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-dev-middleware&#x27;</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config/webpack.common&#x27;</span>)(&#123;&#125;, &#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span> &#125;);<span class="hljs-keyword">const</span> compiler = <span class="hljs-title function_">webpack</span>(config);<span class="hljs-comment">// Tell express to use the webpack-dev-middleware and use the webpack.config.js</span><span class="hljs-comment">// configuration file as a base.</span>app.<span class="hljs-title function_">use</span>(  <span class="hljs-title function_">webpackDevMiddleware</span>(compiler, &#123;    <span class="hljs-attr">publicPath</span>: config.<span class="hljs-property">output</span>.<span class="hljs-property">publicPath</span>  &#125;));<span class="hljs-comment">// webpack-hot-middleware可以开启热更新</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-hot-middleware&#x27;</span>)(compiler));<span class="hljs-comment">// Serve the files on port 3000.</span>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">4000</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Example app listening on port 4000!\n&#x27;</span>);&#125;);</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">//package,son</span><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config ./config/webpack.common.js  --mode production --env production&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve --open  --config ./config/webpack.common.js  --mode development --env development&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config ./config/webpack.common.js --watch  --mode development --env development&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;serve&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node server.js&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;type-check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tsc --noEmit&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;type-check-watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tsc --noEmit --watch&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;prettier&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;prettier --write .&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>webpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用正则表达式</title>
    <link href="/2022/09/08/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/09/08/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建正则</span>   <span class="hljs-comment">// 1&gt; 匹配的规则pattern</span>   <span class="hljs-comment">// 2&gt; 匹配的修饰符flags</span>   <span class="hljs-keyword">const</span> re1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;ig&quot;</span>)   <span class="hljs-keyword">const</span> re2 = <span class="hljs-regexp">/abc/ig</span> <span class="hljs-comment">// 我是注释</span></code></pre></div><h4 id="正则表达式的使用方法"><a href="#正则表达式的使用方法" class="headerlink" title="正则表达式的使用方法"></a>正则表达式的使用方法</h4><p>JavaScript中的正则表达式被用于 RegExp 的 exec 和 test 方法</p><p>也包括 String 的 match、matchAll、replace、search 和 split 方法</p><p>exec : 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;fdabc123 faBC323 dfABC222 A2324aaBc&quot;</span>;<span class="hljs-keyword">const</span> re1 = <span class="hljs-regexp">/abc/gi</span>;<span class="hljs-comment">// console.log(re1.test(message));</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">exec</span>(message));<span class="hljs-comment">/**</span><span class="hljs-comment"> * [</span><span class="hljs-comment">  &#x27;aBC&#x27;,</span><span class="hljs-comment">  index: 10,</span><span class="hljs-comment">  input: &#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;,</span><span class="hljs-comment">  groups: undefined</span><span class="hljs-comment">]</span><span class="hljs-comment"> */</span></code></pre></div><p>test:一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;fdabc123 faBC323 dfABC222 A2324aaBc&quot;</span>;<span class="hljs-keyword">const</span> re1 = <span class="hljs-regexp">/abc/gi</span>; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">test</span>(message));</code></pre></div><p>match:一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// match方法</span><span class="hljs-keyword">const</span> res2 = message.<span class="hljs-title function_">match</span>(re1);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2);<span class="hljs-comment">//[ &#x27;abc&#x27;, &#x27;aBC&#x27;, &#x27;ABC&#x27;, &#x27;aBc&#x27; ]</span></code></pre></div><p>matchAll :一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// matchAll</span><span class="hljs-keyword">const</span> res = message.<span class="hljs-title function_">matchAll</span>(re1);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> iterator <span class="hljs-keyword">of</span> res) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator);&#125;[  <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;</span>,  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>][  <span class="hljs-string">&#x27;aBC&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">10</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;</span>,  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>][  <span class="hljs-string">&#x27;ABC&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">19</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;</span>,  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>][  <span class="hljs-string">&#x27;aBc&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">32</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;</span>,  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>]</code></pre></div><p>search :一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</p><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> result5 = message.<span class="hljs-keyword">search</span>(re1)console.<span class="hljs-built_in">log</span>(result5)</code></pre></div><p>replace:一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串</p><p>split:一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中 的 String 方法</p><h4 id="修饰符flag的使用"><a href="#修饰符flag的使用" class="headerlink" title="修饰符flag的使用"></a>修饰符flag的使用</h4><p>常见的修饰符</p><p>g:全局匹配</p><p>i:不区分大小写</p><p>m:多行匹配</p><h4 id="规则-–-字符类"><a href="#规则-–-字符类" class="headerlink" title="规则 – 字符类"></a>规则 – 字符类</h4><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\d</span>  平匹配数字<span class="hljs-number">0</span>-<span class="hljs-number">9</span><span class="hljs-string">\s</span>  空格符号，包括空格，制表符<span class="hljs-string">\t</span> , 换行符<span class="hljs-string">\n,和其他少数稀有字符，例如\v,\f,\r</span><span class="hljs-string">\w</span>  表示单字字符  字母、数字、下划线</code></pre></div><p>反向类</p><p>\D 表示非数字的其他字符包括数字</p><p>\W 表示非单字字符</p><p>\S 非空格字符</p><h4 id="规则-–-锚点"><a href="#规则-–-锚点" class="headerlink" title="规则 – 锚点"></a>规则 – 锚点</h4><p>符号 ^ 和符号 $ 在正则表达式中具有特殊的意义，它们被称为“锚点”</p><p>符号 ^ 匹配文本开头；</p><p>符号 $ 匹配文本末尾；</p><p>词边界（Word boundary）</p><p>​    词边界 \b 是一种检查，就像 ^ 和 $ 一样，它会检查字符串中的位置是否是词边界</p><p>​    词边界测试 \b 检查位置的一侧是否匹配 \w，而另一侧则不匹配 “\w”</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;My name! is WHY.&quot;</span>;<span class="hljs-comment">// 需求: name, name必须是一个单独的词</span><span class="hljs-comment">// 词边界</span><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\bname\b/i</span>.<span class="hljs-title function_">test</span>(message)) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;有name, name有边界&quot;</span>);&#125;<span class="hljs-comment">// 词边界的应用</span><span class="hljs-keyword">const</span> infos = <span class="hljs-string">&quot;now time is 11:56, 12:00 eat food, number is 123:456&quot;</span>;<span class="hljs-keyword">const</span> timeRe = <span class="hljs-regexp">/\b\d\d:\d\d\b/gi</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infos.<span class="hljs-title function_">match</span>(timeRe));<span class="hljs-comment">/**</span><span class="hljs-comment"> * 有name, name有边界</span><span class="hljs-comment">[ &#x27;11:56&#x27;, &#x27;12:00&#x27; ]</span><span class="hljs-comment"> */</span></code></pre></div><h4 id="规则-–-转义字符串"><a href="#规则-–-转义字符串" class="headerlink" title="规则 – 转义字符串"></a>规则 – 转义字符串</h4><p>转义字符要做常规字符来使用，需要使用对其进行转义，只要在它前面加个反斜杠</p><p>常见的需要转义的字符：</p><div class="code-wrapper"><pre><code class="hljs 1c">[] \  ^ $ . <span class="hljs-string">| ? * + ()</span></code></pre></div><h6 id="斜杠符号-‘-’-并不是一个特殊符号，但是在字面量正则表达式中也需要转义"><a href="#斜杠符号-‘-’-并不是一个特殊符号，但是在字面量正则表达式中也需要转义" class="headerlink" title="斜杠符号 ‘/’ 并不是一个特殊符号，但是在字面量正则表达式中也需要转义"></a>斜杠符号 ‘/’ 并不是一个特殊符号，但是在字面量正则表达式中也需要转义</h6><h4 id="集合（Sets）和范围（Ranges）"><a href="#集合（Sets）和范围（Ranges）" class="headerlink" title="集合（Sets）和范围（Ranges）"></a>集合（Sets）和范围（Ranges）</h4><h6 id="有时候我们只要选择多个匹配字符的其中之一就可以"><a href="#有时候我们只要选择多个匹配字符的其中之一就可以" class="headerlink" title="有时候我们只要选择多个匹配字符的其中之一就可以"></a>有时候我们只要选择多个匹配字符的其中之一就可以</h6><div class="code-wrapper"><pre><code class="hljs"> 有时候我们只要选择多个匹配字符的其中之一就可以</code></pre></div><p>集合  []  表示匹配中括号里面的任意一个字符</p><p>范围  </p><p>​    [0-9] 方括号也可以包含字符范围，例如匹配从a到z范围的字母[a-z],[0-5],</p><p>​    \d  ===[0-9]</p><p>​    \w ===[a-zA-Z0-9]</p><p>​    .    点表示匹配除换行符之外的所有字符</p><h5 id="排除范围：除了普通的范围匹配，还有类似-…-的“排除”范围匹配"><a href="#排除范围：除了普通的范围匹配，还有类似-…-的“排除”范围匹配" class="headerlink" title="排除范围：除了普通的范围匹配，还有类似 [^…] 的“排除”范围匹配"></a>排除范围：除了普通的范围匹配，还有类似 [^…] 的“排除”范围匹配</h5><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>数量  {n} 确切的数  ,{n,m} 表示多少范围匹配</p><p>缩写</p><p>​    +  表示一个或者多个 ==={1，}</p><p>​    ？表示零个或者一个 ==={0，1}</p><p>​    *  表示零个或者多个 ==={0，}</p><h4 id="贪婪（-Greedy）和惰性（-lazy）模式"><a href="#贪婪（-Greedy）和惰性（-lazy）模式" class="headerlink" title="贪婪（ Greedy）和惰性（ lazy）模式"></a>贪婪（ Greedy）和惰性（ lazy）模式</h4><p>默认是贪婪模式，</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.贪婪模式/惰性模式</span><span class="hljs-keyword">const</span> message =  <span class="hljs-string">&quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;</span>;<span class="hljs-comment">// 默认.+采用贪婪模式</span><span class="hljs-keyword">const</span> nameRe = <span class="hljs-regexp">/《.+》/gi</span>;<span class="hljs-keyword">const</span> result1 = message.<span class="hljs-title function_">match</span>(nameRe);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);<span class="hljs-comment">//[ &#x27;《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27; ]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message =  <span class="hljs-string">&quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;</span>;<span class="hljs-comment">// // 默认.+采用贪婪模式</span><span class="hljs-comment">// const nameRe = /《.+》/gi;</span><span class="hljs-comment">// const result1 = message.match(nameRe);</span><span class="hljs-comment">// console.log(result1);</span><span class="hljs-comment">// 使用惰性模式</span><span class="hljs-keyword">const</span> nameRe = <span class="hljs-regexp">/《.+?》/gi</span>;<span class="hljs-keyword">const</span> result1 = message.<span class="hljs-title function_">match</span>(nameRe);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);<span class="hljs-comment">//[ &#x27;《黄金时代》&#x27;, &#x27;《沉默的大多数》&#x27;, &#x27;《一只特立独行的猪》&#x27; ]</span></code></pre></div><p>默认情况下的匹配规则是查找到匹配的内容后，会继续向后查找，一直找到最后一个匹配的内容 , 这种匹配的方式，我们称之为贪婪模式（Greedy）</p><p>懒惰模式中的量词与贪婪模式中的是相反的。 </p><p>只要获取到对应的内容后，就不再继续向后匹配； </p><p>我们可以在量词后面再加一个问号 ‘?’ 来启用它； </p><p> 所以匹配模式变为 *? 或 +?，甚至将 ‘?’ 变为 ?</p><h4 id="捕获组（capturing-group）"><a href="#捕获组（capturing-group）" class="headerlink" title="捕获组（capturing group）"></a>捕获组（capturing group）</h4><p>模式的一部分可以用括号括起来 (…)，这称为“捕获组（capturing group）”</p><p>模式的一部分可以用括号括起来 (…)，这称为“捕获组（capturing group）”。</p><p> ◼ 这有两个作用： </p><p>​    它允许将匹配的一部分作为结果数组中的单独项；</p><p>​     它将括号视为一个整体； </p><p>​            方法 str.match(regexp)，如果 regexp 没有 g 标志，将查找第一个匹配并将它作为一个数组返回：</p><p>​                  在索引 0 处：完全匹配。</p><p>​                  在索引 1 处：第一个括号的内容。 </p><p>​                 在索引 2 处：第二个括号的内容。 </p><p>​                     …等等</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.捕获组</span><span class="hljs-keyword">const</span> message =  <span class="hljs-string">&quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;</span>;<span class="hljs-comment">// 使用惰性模式</span><span class="hljs-comment">//这是通过在开始括号之后立即放置 ?&lt;name&gt; 来完成的</span><span class="hljs-keyword">const</span> nameRe = <span class="hljs-regexp">/(?:《)(?&lt;why&gt;.+?)(?:》)/gi</span>;<span class="hljs-comment">//可以给捕获组起名字</span><span class="hljs-keyword">const</span> iterator = message.<span class="hljs-title function_">matchAll</span>(nameRe);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> iterator) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);&#125;<span class="hljs-comment">// 2.将捕获组作为整体</span><span class="hljs-keyword">const</span> info = <span class="hljs-string">&quot;dfabcabcfabcdfdabcabcabcljll;jk;j&quot;</span>;<span class="hljs-keyword">const</span> abcRe = <span class="hljs-regexp">/(abc)&#123;2,&#125;/gi</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-title function_">match</span>(abcRe));[  <span class="hljs-string">&#x27;《黄金时代》&#x27;</span>,  <span class="hljs-string">&#x27;黄金时代&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">10</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;</span>,  <span class="hljs-attr">groups</span>: [<span class="hljs-title class_">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-attr">why</span>: <span class="hljs-string">&#x27;黄金时代&#x27;</span> &#125;][  <span class="hljs-string">&#x27;《沉默的大多数》&#x27;</span>,  <span class="hljs-string">&#x27;沉默的大多数&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">17</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;</span>,  <span class="hljs-attr">groups</span>: [<span class="hljs-title class_">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-attr">why</span>: <span class="hljs-string">&#x27;沉默的大多数&#x27;</span> &#125;][  <span class="hljs-string">&#x27;《一只特立独行的猪》&#x27;</span>,  <span class="hljs-string">&#x27;一只特立独行的猪&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">26</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;</span>,  <span class="hljs-attr">groups</span>: [<span class="hljs-title class_">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-attr">why</span>: <span class="hljs-string">&#x27;一只特立独行的猪&#x27;</span> &#125;][ <span class="hljs-string">&#x27;abcabc&#x27;</span>, <span class="hljs-string">&#x27;abcabcabc&#x27;</span> ]</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.将捕获组作为整体</span><span class="hljs-keyword">const</span> info = <span class="hljs-string">&quot;dfabcabcfabcdfdabcabcabcljcbacballnbanba;jk;j&quot;</span>;<span class="hljs-keyword">const</span> abcRe = <span class="hljs-regexp">/(abc|cba|nba)&#123;2,&#125;/gi</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-title function_">match</span>(abcRe));<span class="hljs-comment">//[ &#x27;abcabc&#x27;, &#x27;abcabcabc&#x27;, &#x27;cbacba&#x27;, &#x27;nbanba&#x27; ]</span></code></pre></div><p>非捕获组：</p><p>  有时我们需要括号才能正确应用量词，但我们不希望它们的内容出现在结果中。</p><p> 可以通过在开头添加 ?: 来排除组。</p>]]></content>
    
    
    <categories>
      
      <category>正则表达式</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的git操作</title>
    <link href="/2022/09/08/%E5%B8%B8%E7%94%A8%E7%9A%84git%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/09/08/%E5%B8%B8%E7%94%A8%E7%9A%84git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="git基本使用"><a href="#git基本使用" class="headerlink" title="##git基本使用"></a>##git基本使用</h4><h5 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h5><div class="code-wrapper"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span></code></pre></div><h5 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h5><div class="code-wrapper"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/coderwhy/</span>hy-react-web-music.git</code></pre></div><h4 id="检测文件的状态"><a href="#检测文件的状态" class="headerlink" title="检测文件的状态"></a>检测文件的状态</h4><div class="code-wrapper"><pre><code class="hljs lua">git <span class="hljs-built_in">status</span>git <span class="hljs-built_in">status</span> -sgit <span class="hljs-built_in">status</span> <span class="hljs-comment">--short</span></code></pre></div><h4 id="将所有文件添加到暂存区"><a href="#将所有文件添加到暂存区" class="headerlink" title="将所有文件添加到暂存区"></a>将所有文件添加到暂存区</h4><div class="code-wrapper"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .</code></pre></div><h4 id="将暂存区的文件提交"><a href="#将暂存区的文件提交" class="headerlink" title="将暂存区的文件提交"></a>将暂存区的文件提交</h4><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;提交信息&quot;</span></code></pre></div><h4 id="add-commit-进行合并操作"><a href="#add-commit-进行合并操作" class="headerlink" title="add commit 进行合并操作"></a>add commit 进行合并操作</h4><div class="code-wrapper"><pre><code class="hljs livecodeserver">git commit -<span class="hljs-keyword">a</span> -m <span class="hljs-string">&quot;修改文件&quot;</span></code></pre></div><h4 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h4><div class="code-wrapper"><pre><code class="hljs awk">git commit --amend  <span class="hljs-regexp">//</span>将两个commit合并成一个提交</code></pre></div><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><div class="code-wrapper"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m <span class="hljs-string">&#x27;initial commit&#x27;</span>git <span class="hljs-keyword">add</span> forgotten_filegit <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span></code></pre></div><p>就是将再次commit的内容合并到之前的commit</p><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><div class="code-wrapper"><pre><code class="hljs jboss-cli">git loggit log <span class="hljs-params">--pretty=oneline</span>git log <span class="hljs-params">--oneline</span> <span class="hljs-params">--decorate</span> <span class="hljs-params">--graph</span> <span class="hljs-params">--all</span>   <span class="hljs-string">//</span>它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况</code></pre></div><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><div class="code-wrapper"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span>  <span class="hljs-comment">--hard HEAD^</span>git <span class="hljs-keyword">reset</span>  <span class="hljs-comment">--hard HEAD~1000</span>git <span class="hljs-keyword">reset</span>  <span class="hljs-comment">--hard 2d44982</span></code></pre></div><h4 id="管理远程仓库"><a href="#管理远程仓库" class="headerlink" title="管理远程仓库"></a>管理远程仓库</h4><div class="code-wrapper"><pre><code class="hljs <">git remote //查看远程仓库的命名git remote -v  //查看远程仓库地址git remote add &lt;shortname&gt; &lt;url&gt;  //添加远程仓库，让本地仓库和远程仓库建立连接git remote rename gitlab glab  //重命名远程仓库git remote remove gitlab  //移除远程仓库git remote show &lt;remote&gt;  //获取远程仓库信息例如git remote show origingit ls-remote &lt;remote&gt;  //显式地获得远程引用的完整列表</code></pre></div><h4 id="将代码push到远程仓库：将本地仓库的代码推送到远程仓库中"><a href="#将代码push到远程仓库：将本地仓库的代码推送到远程仓库中" class="headerlink" title="将代码push到远程仓库：将本地仓库的代码推送到远程仓库中"></a>将代码push到远程仓库：将本地仓库的代码推送到远程仓库中</h4><div class="code-wrapper"><pre><code class="hljs maxima">默认情况下是将当前分支（比如master）<span class="hljs-built_in">push</span>到<span class="hljs-built_in">origin</span>远程仓库的；git <span class="hljs-built_in">push</span>git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> mastergit <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> serverfix:awesomebranch  //远程分支和本地分支不同名时</code></pre></div><h4 id="从远程仓库fetch代码：从远程仓库获取最新的代码"><a href="#从远程仓库fetch代码：从远程仓库获取最新的代码" class="headerlink" title="从远程仓库fetch代码：从远程仓库获取最新的代码"></a>从远程仓库fetch代码：从远程仓库获取最新的代码</h4><div class="code-wrapper"><pre><code class="hljs sql">默认情况下是从origin中获取代码；git <span class="hljs-keyword">fetch</span>git <span class="hljs-keyword">fetch</span> origin获取到代码后默认并没有合并到本地仓库，我们需要通过<span class="hljs-keyword">merge</span>来合并；git <span class="hljs-keyword">merge</span></code></pre></div><h4 id="从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作"><a href="#从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作" class="headerlink" title="从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作"></a>从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作</h4><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">git</span> <span class="hljs-variable">pull</span> ===<span class="hljs-variable">git</span> <span class="hljs-variable">fetch</span> + <span class="hljs-variable">git</span> <span class="hljs-function"><span class="hljs-title">merge</span>(<span class="hljs-variable">rebase</span>)</span></code></pre></div><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><div class="code-wrapper"><pre><code class="hljs pgsql">$ git merge iss53Auto-merging <span class="hljs-keyword">index</span>.html<span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">index</span>.htmlAutomatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.</code></pre></div><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并 （unmerged）状态的文件：</p><div class="code-wrapper"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<span class="hljs-section">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><span class="hljs-section">=======</span>&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</code></pre></div><p>这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的 下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。 </p><p>冲突解决后，可以使用git status 来查看是否所有的冲突都解决了，然后再使用git commit进行提交</p><h4 id="Git标签（tag）-创建tag"><a href="#Git标签（tag）-创建tag" class="headerlink" title="Git标签（tag） - 创建tag"></a>Git标签（tag） - 创建tag</h4><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated），轻量标签很像一个不会改变的分支——它只是某个特定提交的引用，而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件 地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签</p><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span>  //轻量标签git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;附注标签&quot;</span>git show v1.<span class="hljs-number">4</span>  //可以看到标签信息和与之对应的提交信息 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息</code></pre></div><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a><strong>列出标签</strong></h4><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">（可带上可选的 -l</span> 选项 --list）git <span class="hljs-keyword">tag</span> <span class="hljs-title">-l</span> <span class="hljs-string">&quot;v1.8.5*&quot;</span>  //列出v1.<span class="hljs-number">8.5</span>开头的标签</code></pre></div><h4 id="push-tag"><a href="#push-tag" class="headerlink" title="push tag"></a>push tag</h4><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin <span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin --tags  <span class="hljs-comment">//推送所有标签</span>使用 git <span class="hljs-keyword">push</span> &lt;remote&gt; --tags 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。</code></pre></div><h4 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h4><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v1.<span class="hljs-number">1</span></code></pre></div><h4 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h4><div class="code-wrapper"><pre><code class="hljs awk">git push origin  --<span class="hljs-keyword">delete</span> v1.<span class="hljs-number">1</span>  <span class="hljs-regexp">//</span>第一种方式 git push &lt;remote&gt; :refs<span class="hljs-regexp">/tags/</span>&lt;tagname&gt;  <span class="hljs-regexp">//</span>第二种方式</code></pre></div><h4 id="切换到目标tag版本"><a href="#切换到目标tag版本" class="headerlink" title="切换到目标tag版本"></a>切换到目标tag版本</h4><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout <span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span>   <span class="hljs-comment">//虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用</span></code></pre></div><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p><div class="code-wrapper"><pre><code class="hljs armasm">$ git checkout -<span class="hljs-keyword">b</span> version2 <span class="hljs-built_in">v2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span></code></pre></div><p>如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍 微有些不同，这时就要当心了。</p><h4 id="Git创建分支"><a href="#Git创建分支" class="headerlink" title="Git创建分支"></a>Git创建分支</h4><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch testing</span></code></pre></div><h4 id="Git切换分支"><a href="#Git切换分支" class="headerlink" title="Git切换分支"></a>Git切换分支</h4><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git checkout testing</span></code></pre></div><h4 id="创建分支同时切换"><a href="#创建分支同时切换" class="headerlink" title="创建分支同时切换"></a>创建分支同时切换</h4><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b</span> testing</code></pre></div><h4 id="分支开发与合并"><a href="#分支开发与合并" class="headerlink" title="分支开发与合并"></a>分支开发与合并</h4><div class="code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-keyword">master</span><span class="hljs-title">git</span> merge hotfix</code></pre></div><h4 id="查看和删除分支"><a href="#查看和删除分支" class="headerlink" title="查看和删除分支"></a>查看和删除分支</h4><div class="code-wrapper"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span> 查看当前所有分支  带*就是head指针指向的分支，一般是当前分支git <span class="hljs-keyword">brabch </span>-v  查看最后一次提交git <span class="hljs-keyword">branch </span>--merged 查看所有合并到当前分支的分支git <span class="hljs-keyword">branch </span>--no-merged 查看所有没有合并到当前分支的分支  没有合并的分支不允许删除如果需要强制性删除 git <span class="hljs-keyword">branch </span>-D hotfixgit <span class="hljs-keyword">branch </span>--no-merged master  还没有合并到master的分支git <span class="hljs-keyword">branch </span>-d hotfix  删除hotfix分支</code></pre></div><h4 id="远程分支的管理"><a href="#远程分支的管理" class="headerlink" title="远程分支的管理"></a>远程分支的管理</h4><div class="code-wrapper"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> &lt;remote&gt; &lt;branch&gt;  推送远程分支git checkout -b serverfix <span class="hljs-built_in">origin</span>/serverfix  //创建分支并跟踪远程分支 下面是他的简写git checkout --<span class="hljs-built_in">track</span> &lt;remote&gt;/&lt;branch&gt; 跟踪远程分支git checkout -b <span class="hljs-built_in">sf</span> <span class="hljs-built_in">origin</span>/serverfix //创建和远程分支不一样的名字git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> &lt;branch&gt; 删除远程分支</code></pre></div><h4 id="Git-rebase用法"><a href="#Git-rebase用法" class="headerlink" title="Git rebase用法"></a>Git rebase用法</h4><div class="code-wrapper"><pre><code class="hljs crmsh">git checkout experimentgit rebase <span class="hljs-keyword">master</span><span class="hljs-title">git</span> checkout <span class="hljs-keyword">master</span><span class="hljs-title">git</span> merge experiment</code></pre></div><p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用</p><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行 应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。</p><p>假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p><div class="code-wrapper"><pre><code class="hljs crmsh">git rebase --onto <span class="hljs-keyword">master</span> <span class="hljs-title">server</span> client</code></pre></div><p>以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”</p><p>接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到server 分支，再对其执行变基命令的多个步骤</p><div class="code-wrapper"><pre><code class="hljs crmsh">git rebase <span class="hljs-keyword">master</span> <span class="hljs-title">server</span> 相当于git checkout servergit rebase <span class="hljs-literal">master</span></code></pre></div><h5 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h5><p>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基</p><h5 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a>用变基解决变基</h5><p> 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patchid”。 </p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的 </p><p>修改，并把它们应用到新分支上。</p><p>举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情 </p><p>境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会： </p><p>• 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7） </p><p>• 检查其中哪些提交不是合并操作的结果（C2，C3，C4） </p><p>• 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’） </p><p>• 把查到的这些提交应用在 teamone/master 上面</p><p>从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果。在一个被变基然后强制推送的分支上再次执行变基。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 git pull。 又或者你可以自己手动 完成这个过程，先 git fetch，再 git rebase teamone/master。 </p><p>如果你习惯使用 git pull ，同时又希望默认使用选项 –rebase，你可以执行这条语句 git config –global pull.rebase true 来更改 pull.rebase 的默认配置。</p><p>如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没 有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。 </p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull –rebase 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><div class="code-wrapper"><pre><code class="hljs ada">对于未进行提交到暂存区域的git checkout <span class="hljs-comment">-- &lt;file&gt;</span></code></pre></div><p>请务必记得 git checkout – <file> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p><h4 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a><strong>Git</strong> 别名</h4><p>为git 命令设置别名</p><div class="code-wrapper"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.co</span> checkoutgit <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.br</span> branchgit <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.ci</span> commitgit <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.st</span> status</code></pre></div><p>这意味着，当要输入 git commit 时，只需要输入 git ci。</p><div class="code-wrapper"><pre><code class="hljs csharp">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span>.unstage <span class="hljs-string">&#x27;reset HEAD --&#x27;</span></code></pre></div><p>这会使下面的两个命令等价：</p><div class="code-wrapper"><pre><code class="hljs pgsql">git unstage fileAgit <span class="hljs-keyword">reset</span> HEAD <span class="hljs-comment">-- fileA</span></code></pre></div><p>这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：</p><div class="code-wrapper"><pre><code class="hljs csharp">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span>.last <span class="hljs-string">&#x27;log -1 HEAD&#x27;</span></code></pre></div><p>使用自定义指令来查看最后一次提交信息</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> <span class="hljs-literal">last</span></code></pre></div><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：</p><div class="code-wrapper"><pre><code class="hljs csharp">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span>.visual <span class="hljs-string">&#x27;!gitk&#x27;</span></code></pre></div><h4 id="引用日志"><a href="#引用日志" class="headerlink" title="引用日志"></a>引用<strong>日志</strong></h4><p>当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用 所指向的历史。 </p><p>你可以使用 git reflog 来查看引用日志，引用日志只存在于本地仓库</p><div class="code-wrapper"><pre><code class="hljs angelscript">git <span class="hljs-built_in">ref</span>log</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript">$ git <span class="hljs-built_in">ref</span>log<span class="hljs-number">734713</span>b <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">0</span>&#125;: commit: fixed <span class="hljs-built_in">ref</span>s handling, added gc <span class="hljs-built_in">auto</span>, updatedd921970 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">1</span>&#125;: merge phedders/rdocs: Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span>strategy.<span class="hljs-number">1</span>c002dd <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">2</span>&#125;: commit: added some blame <span class="hljs-keyword">and</span> merge stuff<span class="hljs-number">1</span>c36188 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">3</span>&#125;: rebase -i (squash): updating HEAD<span class="hljs-number">95</span>df984 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">4</span>&#125;: commit: # This <span class="hljs-keyword">is</span> a combination of two commits.<span class="hljs-number">1</span>c36188 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">5</span>&#125;: rebase -i (squash): updating HEAD<span class="hljs-number">7e05</span>da5 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">6</span>&#125;: rebase -i (pick): updating HEAD</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript">git show <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">5</span>&#125;    <span class="hljs-comment">//如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @&#123;n&#125; 来 引用 reflog 中输出的提交记录。</span>git show <span class="hljs-symbol">master@</span>&#123;yesterday&#125;   <span class="hljs-comment">//查看你的 master 分支在昨天的时候指向了哪个提交，这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。</span></code></pre></div><h4 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先<strong>引用</strong></h4><div class="code-wrapper"><pre><code class="hljs awk">git show HEAD^   <span class="hljs-regexp">//</span> 可以查看上一次的提交  在window中不可用git show HEAD^^  <span class="hljs-regexp">//</span> win中可以使用git show <span class="hljs-string">&quot;HEAD^&quot;</span> <span class="hljs-regexp">//</span> win中要使用“”git show d921970^ <span class="hljs-regexp">//</span>某次提交的上一次提交</code></pre></div><p>另一种指明祖先提交的方法是 ~（波浪号）</p><div class="code-wrapper"><pre><code class="hljs dart">git <span class="hljs-keyword">show</span> HEAD~<span class="hljs-number">3</span>  也可以使用  git <span class="hljs-keyword">show</span> HEAD～～～</code></pre></div><h4 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区<strong>间</strong></h4><p>可以用来制定那些提交需要合并到master分支</p><h5 id="双点"><a href="#双点" class="headerlink" title="双点"></a>双点</h5><p>这种语法可以选出在一个分支中而不再另外一个分支的中的提交</p><p>例如：</p><p>​    你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">git</span></span> <span class="hljs-built_in">log</span> master..experiment</code></pre></div><p>​    如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">git</span></span> <span class="hljs-built_in">log</span> experiment..master</code></pre></div><p>​    另一个常用的场景是查看你即将推送到远端的内容‘</p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> origin/master..HEAD</code></pre></div><h4 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h4><div class="code-wrapper"><pre><code class="hljs awk">git stash/git stash pushgit stash list <span class="hljs-regexp">//</span>获取暂存列表git stash apply <span class="hljs-regexp">//</span>应用最新的暂存文件git stash apply stash@&#123;<span class="hljs-number">2</span>&#125;  <span class="hljs-regexp">//</span>应用指定的暂存文件git stash pop <span class="hljs-regexp">//</span>应用暂存并且删除git stash drop <span class="hljs-regexp">//</span>删除暂存</code></pre></div><h4 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重<strong>写历史</strong></h4><h5 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h5><div class="code-wrapper"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span></code></pre></div><h5 id="合并多次提交信息"><a href="#合并多次提交信息" class="headerlink" title="合并多次提交信息"></a>合并多次提交信息</h5><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i HEAD~<span class="hljs-number">3</span></code></pre></div><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><div class="code-wrapper"><pre><code class="hljs stylus">git branch <span class="hljs-attr">--set-upstream-to</span>=origin/master  <span class="hljs-comment">//设置上游分支就可以只写 git pull了</span>git merge <span class="hljs-attr">--allow-unrelated-histories</span>  <span class="hljs-comment">//强制合并</span>git push origin head:<span class="hljs-selector-tag">main</span>  head默认指向<span class="hljs-selector-tag">main</span>如果要push master默认要这么写git push origin master:<span class="hljs-selector-tag">main</span>  如果想写git push就要这么写配置git push 指向上游路径master，就是配置好的git branch <span class="hljs-attr">--set-upstream-to</span>=origin/master调用git push 就会push到master,但是这样每个分支都是push到mastergit config push<span class="hljs-selector-class">.default</span> upstream  <span class="hljs-selector-attr">[--global]</span><span class="hljs-comment">//加上global可以全局使用，否则就是当前项目使用</span>git config push<span class="hljs-selector-class">.default</span> current  <span class="hljs-comment">//这个会先去仓库找有没有和本地相同的分支，如果没有就在远程创建一个新的和本地相同的分支</span>push<span class="hljs-selector-class">.default</span> 默认是simple 就是push相同的分支</code></pre></div><h5 id="Fast-forward-merge-is-not-possible-To-merge-this-request-first-rebase-locally"><a href="#Fast-forward-merge-is-not-possible-To-merge-this-request-first-rebase-locally" class="headerlink" title="Fast-forward merge is not possible. To merge this request, first rebase locally"></a><a href="https://stackoverflow.com/questions/53066369/fast-forward-merge-is-not-possible-to-merge-this-request-first-rebase-locally">Fast-forward merge is not possible. To merge this request, first rebase locally</a></h5><p>解决办法</p><p><code>git checkout master</code> 先切换到主分支</p><p><code>git pull origin master</code> 然后再pull分支下来</p><p><code>git checkout newBranch</code> 切换到当前分支</p><p><code>git rebase origin/master -i</code>    再rebase</p><p><code>git rebase --continue</code></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是tailwindcss</title>
    <link href="/2022/09/08/%E4%BB%80%E4%B9%88%E6%98%AFtailwindcss/"/>
    <url>/2022/09/08/%E4%BB%80%E4%B9%88%E6%98%AFtailwindcss/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
      <category>tailwindcss</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>http2了解</title>
    <link href="/2022/09/08/http2%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/09/08/http2%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fetch笔记</title>
    <link href="/2022/09/08/fetch%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/fetch%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>fetch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ajax笔记</title>
    <link href="/2022/09/08/ajax%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/ajax%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="ajax的封装"><a href="#ajax的封装" class="headerlink" title="##ajax的封装"></a>##ajax的封装</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">&#123;</span><span class="hljs-params">  url,</span><span class="hljs-params">  method = <span class="hljs-string">&quot;get&quot;</span>,</span><span class="hljs-params">  data = &#123;&#125;,</span><span class="hljs-params">  headers = &#123;&#125;,</span><span class="hljs-params">  success,</span><span class="hljs-params">  failure,</span><span class="hljs-params">&#125; = &#123;&#125;</span>) &#123;  <span class="hljs-comment">// 1.创建对象</span>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();  <span class="hljs-comment">// 2.监听数据</span>  xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span> || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;      <span class="hljs-comment">// xhr.responseXML/xhr.responseText</span>      success &amp;&amp; <span class="hljs-title function_">success</span>(xhr.<span class="hljs-property">response</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      failure &amp;&amp; <span class="hljs-title function_">failure</span>(&#123; <span class="hljs-attr">status</span>: xhr.<span class="hljs-property">status</span>, <span class="hljs-attr">message</span>: xhr.<span class="hljs-property">statusText</span> &#125;);    &#125;  &#125;;  <span class="hljs-comment">// 现在返回的数据类型一般都是json,如果设置为空字符串则会使用text作为默认值</span>  <span class="hljs-comment">// 3.设置类型</span>  xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;  <span class="hljs-comment">// xhr.responseType=&quot;xml&quot;/blob/text/arraybuffer等</span>  <span class="hljs-comment">// 4.设置过期超时事件</span>  xhr.<span class="hljs-property">timeout</span> = timeout;  <span class="hljs-comment">// 5.open方法</span>  <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&quot;GET&quot;</span>) &#123;    <span class="hljs-keyword">const</span> queryString = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> data) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(data, key)) &#123;        <span class="hljs-keyword">const</span> item = data[key];        queryString.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;item&#125;</span>`</span>);      &#125;    &#125;    url = url + <span class="hljs-string">&quot;?&quot;</span> + queryString.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);    xhr.<span class="hljs-title function_">open</span>(method, url);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// post</span>    xhr.<span class="hljs-title function_">open</span>(method, url);    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);  &#125;  <span class="hljs-comment">// 6设置headers</span>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;      xhr.<span class="hljs-title function_">setRequestHeader</span>(key, headers[key]);    &#125;);  &#125;  <span class="hljs-keyword">if</span> (method.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&quot;POST&quot;</span>) &#123;    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&quot;GET&quot;</span>) &#123;    xhr.<span class="hljs-title function_">send</span>();  &#125;  <span class="hljs-comment">// return xhr可以用于调用abort()方法进行终止请求</span>  <span class="hljs-keyword">return</span> xhr;&#125;</code></pre></div><h4 id="ajax的promise的封装"><a href="#ajax的promise的封装" class="headerlink" title="ajax的promise的封装"></a>ajax的promise的封装</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">&#123; url, method = <span class="hljs-string">&quot;get&quot;</span>, data = &#123;&#125;, headers = &#123;&#125; &#125; = &#123;&#125;</span>) &#123;  <span class="hljs-comment">// 1.创建对象</span>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 2.监听数据</span>    xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span> || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;        <span class="hljs-comment">// xhr.responseXML/xhr.responseText</span>        <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">response</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-title function_">reject</span>(&#123; <span class="hljs-attr">status</span>: xhr.<span class="hljs-property">status</span>, <span class="hljs-attr">message</span>: xhr.<span class="hljs-property">statusText</span> &#125;);      &#125;    &#125;;    <span class="hljs-comment">// 现在返回的数据类型一般都是json,如果设置为空字符串则会使用text作为默认值</span>    <span class="hljs-comment">// 3.设置类型</span>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;    <span class="hljs-comment">// xhr.responseType=&quot;xml&quot;/blob/text/arraybuffer等</span>    <span class="hljs-comment">// 4.设置过期超时事件</span>    xhr.<span class="hljs-property">timeout</span> = timeout;    <span class="hljs-comment">// 5.open方法</span>    <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&quot;GET&quot;</span>) &#123;      <span class="hljs-keyword">const</span> queryString = [];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> data) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(data, key)) &#123;          <span class="hljs-keyword">const</span> item = data[key];          queryString.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;item&#125;</span>`</span>);        &#125;      &#125;      url = url + <span class="hljs-string">&quot;?&quot;</span> + queryString.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);      xhr.<span class="hljs-title function_">open</span>(method, url);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// post</span>      xhr.<span class="hljs-title function_">open</span>(method, url);      xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);    &#125;    <span class="hljs-comment">// 6设置headers</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;        xhr.<span class="hljs-title function_">setRequestHeader</span>(key, headers[key]);      &#125;);    &#125;    <span class="hljs-keyword">if</span> (method.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&quot;POST&quot;</span>) &#123;      xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&quot;GET&quot;</span>) &#123;      xhr.<span class="hljs-title function_">send</span>();    &#125;  &#125;);  <span class="hljs-comment">// return xhr可以用于调用abort()方法进行终止请求</span>  promise.<span class="hljs-property">xhr</span> = xhr;  <span class="hljs-keyword">return</span> promise;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react-router-v6笔记</title>
    <link href="/2022/09/08/react-router-v6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/react-router-v6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs qml"><span class="hljs-number">1.</span>前端路由的原理当<span class="hljs-built_in">url</span>发生变化的时候，引起页面不刷新来修改页面的内容的两个方法<span class="hljs-number">1.</span>通过修改<span class="hljs-built_in">url</span>中的hash的变化来修改页面的内容<span class="hljs-built_in">window</span>.onhashchange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">switch</span>(location.hash)&#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;#/a&quot;</span>:div.innerHTML=<span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">//url的hash也就是锚点。本质上就是修改了window.location的href</span><span class="hljs-comment">//可以通过直接赋值location.hash来改变href.但是页面不会刷新，</span><span class="hljs-comment">//但是hash会带有#</span><span class="hljs-number">2.</span>可以使用HTML5的history模式来修改<span class="hljs-built_in">url</span>,他有六种模式来改变URL的变化而不刷新页面history.replactState():替换原来的路径history.pushState():使用新的路径history.popState():路径的回退history.go():向前或者向后改变路径history.back():向后改变路径</code></pre></div><p><img src="https://img1.imgtp.com/2022/09/13/WPC9CvI7.png" alt="QQ截图20220607102052.png"></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">2.</span>react-router有两部分组成<span class="hljs-number">1.</span>react-router<span class="hljs-comment">//这是核心代码</span><span class="hljs-number">2.</span>react-router-dom<span class="hljs-comment">//这是用于浏览器的</span><span class="hljs-number">3.</span>react-router-native<span class="hljs-comment">//这个适用于原生应用</span>使用react-router需要使用npm install react-router-dom 他会自动安装react-router<span class="hljs-number">3.</span>react-router的组件使用&lt;<span class="hljs-title class_">BrowserRouter</span>&gt;是使用history模式<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;    <span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span>,      root    );<span class="hljs-comment">//这就是目前比较普遍的用法，也是官方比较推荐的用法，将他包裹在App组件</span>   <span class="hljs-number">3.1</span>&lt;<span class="hljs-title class_">HashRouter</span>&gt;是使用hash模式，官方不推荐使用   <span class="hljs-number">3.2</span>&lt;link&gt;组件是跳转的组件，它最终会被渲染成a元素   <span class="hljs-number">3.3</span>&lt;<span class="hljs-title class_">NavLink</span>&gt;是在<span class="hljs-title class_">Link</span>的基础上增加了一些样式   <span class="hljs-number">3.3</span><span class="hljs-number">.1</span> to属性是<span class="hljs-title class_">Link</span>和<span class="hljs-title class_">NavLink</span>组件中最重要的属性，用于设置跳转的路径   <span class="hljs-number">3.4</span>.<span class="hljs-property">Route</span>组件   <span class="hljs-number">3.4</span><span class="hljs-number">.1</span> <span class="hljs-title class_">Route</span>组件主要适用于路由路径的匹配   <span class="hljs-number">3.4</span><span class="hljs-number">.2</span> path属性:用于设置匹配到的路径   <span class="hljs-number">3.4</span><span class="hljs-number">.3</span> component属性：设置匹配到的路径后渲染的组件，   <span class="hljs-number">3.4</span><span class="hljs-number">.4</span>.<span class="hljs-property">exact</span>:精准匹配   上述的属性属于v5的版本   在v6版本中所有&lt;<span class="hljs-title class_">Route</span>&gt;组件将放在&lt;<span class="hljs-title class_">Routes</span>&gt;中，component改成element,</code></pre></div><p><img src="https://img1.imgtp.com/2022/09/13/TzYXcXQV.png" alt="QQ截图20220607144416.png"></p><p><img src="https://img1.imgtp.com/2022/09/13/XwuhkKsl.png" alt="QQ截图20220607215036.png"></p><p><img src="https://img1.imgtp.com/2022/09/13/djJ6Fots.png" alt="QQ截图20220607144950.png"></p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;NavLink&gt;的用法用于可以处于当前访问连接时修改连接的样式，处于active状态v5的写法可以添加如下属性activeStyle:活跃时的样式activeClassName：活跃时添加<span class="hljs-keyword">class</span><span class="hljs-symbol">exact</span>精确匹配也可以使用自定义<span class="hljs-symbol">class</span></code></pre></div><p><img src="https://img1.imgtp.com/2022/09/13/Ml03VBOs.png" alt="QQ截图20220607151506.png"></p><p>v6的写法，不需要activeStyle和activeClassName，可以在普通的style和className中传入一个函数，更加灵活方便</p><p><img src="https://img1.imgtp.com/2022/09/13/EfvZ4TfB.png" alt="QQ截图20220607151735.png"></p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Switch</span>的作用 <span class="hljs-built_in">V5</span> 在<span class="hljs-built_in">V6</span>没有该组件</code></pre></div><p>组件中获取路由参数，params中存在对饮的路由参数</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">params</span> = useParams()</code></pre></div><h4 id="Navigate导航"><a href="#Navigate导航" class="headerlink" title="Navigate导航"></a>Navigate导航</h4><p>Navigate用于路由的重定向</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;Route <span class="hljs-attribute">path</span>=<span class="hljs-string">&#x27;/home&#x27;</span> element=&#123;&lt;Navigate <span class="hljs-attribute">to</span>=<span class="hljs-string">&quot;/home/recommend&quot;</span>/&gt;&#125;/&gt;</code></pre></div><h4 id="Not-Found页面配置"><a href="#Not-Found页面配置" class="headerlink" title="Not Found页面配置"></a>Not Found页面配置</h4><div class="code-wrapper"><pre><code class="hljs awk">&lt;Route path=<span class="hljs-string">&#x27;*&#x27;</span> element=&#123;&lt;NotFound<span class="hljs-regexp">/&gt;&#125;/</span>&gt;</code></pre></div><h3 id="Search-Params"><a href="#Search-Params" class="headerlink" title="Search Params"></a>Search Params</h3><p><img src="https://img1.imgtp.com/2022/09/13/TdiJP94D.png" alt="QQ截图20220607203231.png"></p><h3 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h3><div class="code-wrapper"><pre><code class="hljs reasonml">import &#123; useNavigate &#125; from <span class="hljs-string">&quot;react-router-dom&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-constructor">SignupForm()</span> &#123;  <span class="hljs-keyword">let</span> navigate = use<span class="hljs-constructor">Navigate()</span>;  async <span class="hljs-keyword">function</span> handle<span class="hljs-constructor">Submit(<span class="hljs-params">event</span>)</span> &#123;    event.prevent<span class="hljs-constructor">Default()</span>;    await submit<span class="hljs-constructor">Form(<span class="hljs-params">event</span>.<span class="hljs-params">target</span>)</span>;    navigate(<span class="hljs-string">&quot;../success&quot;</span>, &#123; replace: <span class="hljs-literal">true</span> &#125;);  &#125;  return &lt;form onSubmit=&#123;handleSubmit&#125;&gt;&#123;<span class="hljs-comment">/* ... */</span>&#125;&lt;/form&gt;;&#125;使用useNavigate可以实现手动进行路由跳转，<span class="hljs-keyword">let</span> navigate = use<span class="hljs-constructor">Navigate()</span>;他会返回一个函数，参数有两个，一个是<span class="hljs-keyword">to</span>, 另一个optional second &#123; replace, state &#125; arg，或者使用历史调用栈类似于go<span class="hljs-number">(-1)</span>调用navigate<span class="hljs-number">(-1)</span></code></pre></div><h3 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation"></a>useLocation</h3><div class="code-wrapper"><pre><code class="hljs crmsh">let <span class="hljs-keyword">location</span> <span class="hljs-title">= useLocation</span>();//获取location</code></pre></div><p><img src="https://img1.imgtp.com/2022/09/13/LD2qs0Cd.png" alt="QQ截图20220607212846.png"></p><h3 id="withRouter-component"><a href="#withRouter-component" class="headerlink" title="withRouter(component)"></a>withRouter(component)</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;  useLocation,  useNavigate,  useParams,  useSearchParams&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">withRouter</span>(<span class="hljs-params">Component</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentWithRouterProp</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();    <span class="hljs-keyword">const</span> navigate = <span class="hljs-title function_">useNavigate</span>();    <span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useParams</span>();    <span class="hljs-keyword">const</span> [searchParams] = <span class="hljs-title function_">useSearchParams</span>()    <span class="hljs-keyword">const</span> query = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(searchParams)    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span></span></span><span class="hljs-tag"><span class="language-xml">        &#123;<span class="hljs-attr">...props</span>&#125;</span></span><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">router</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">location</span>, <span class="hljs-attr">navigate</span>, <span class="hljs-attr">params</span>,<span class="hljs-attr">query</span> &#125;&#125;</span></span><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span>    );  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentWithRouterProp</span>;&#125;<span class="hljs-comment">//在v6中没有这个高阶组件，因为v6都是使用到的是函数式组件，所以不需要，如果想用可以这样封装，在v5中的主要目的是为了手动调用路由可以获取到history,组件可以通过this.props.history,push()来手动进行路由跳转，v6可以使用到useNavigate()</span></code></pre></div><h4 id="路由的配置文件"><a href="#路由的配置文件" class="headerlink" title="路由的配置文件"></a>路由的配置文件</h4><p>通过像vue-router来将路由定义在单独的文件中</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//router.js</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Home&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeRecommend</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/HomeRecommend&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeRanking</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/HomeRanking&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeSongMenu</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/HomeSongMenu&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Category</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/Category&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Order</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/Order&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">NotFound</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/NotFound&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Detail&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/User&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Navigate</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../pages/About&quot;</span>))<span class="hljs-keyword">const</span> <span class="hljs-title class_">Login</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../pages/Login&quot;</span>))<span class="hljs-keyword">const</span> routes = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span>/&gt;</span></span>,    <span class="hljs-attr">children</span>: [      &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/recommend&quot;</span>/&gt;</span></span>      &#125;,      &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home/recommend&quot;</span>,        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HomeRecommend</span>/&gt;</span></span>      &#125;,      &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home/ranking&quot;</span>,        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HomeRanking</span>/&gt;</span></span>      &#125;,      &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home/songmenu&quot;</span>,        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HomeSongMenu</span>/&gt;</span></span>      &#125;    ]  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/category&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Category</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/order&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Order</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/detail/:id&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Detail</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">User</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;*&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NotFound</span>/&gt;</span></span>  &#125;]<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> routes</code></pre></div><div class="code-wrapper"><pre><code class="hljs reasonml">&#123;use<span class="hljs-constructor">Routes(<span class="hljs-params">routes</span>)</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redux笔记</title>
    <link href="/2022/09/08/Redux%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/Redux%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="##纯函数"></a>##纯函数</h4><p> 确定的输入，一定会产生确定的输出；</p><p>函数在执行过程中，不能产生副作用</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>一个store文件夹由4个文件组成</p><p>actionCreator.js</p><p>这个文件是用来编写action,action是一个普通的JavaScript对象，用来描述这次更新的type和content</p><p>强制使用action的好处是可以清晰的知道数据到底发生了什么样的变化，所有的数据变化都是可跟追、可预测的；</p><p>当然，目前我们的action是固定的对象</p><p>真实应用中，我们会通过函数来定义，返回一个action</p><p>Redux要求我们通过action来更新数据,通过dispatch action来更新数据</p><div class="code-wrapper"><pre><code class="hljs coffeescript">//actionCreator.jsconst &#123; ADD_NUMBER, CHANGE_NAME &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./constants&quot;</span>)const changeNameAction = <span class="hljs-function"><span class="hljs-params">(name)</span> =&gt;</span> (&#123;  type: CHANGE_NAME,  name&#125;)const addNumberAction = <span class="hljs-function"><span class="hljs-params">(num)</span> =&gt;</span> (&#123;  type: ADD_NUMBER,  num&#125;)module.<span class="hljs-built_in">exports</span> = &#123;  changeNameAction,  addNumberAction&#125;</code></pre></div><p>constants.js 用来定义type常量</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ADD_NUMBER</span> = <span class="hljs-string">&quot;add_number&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHANGE_NAME</span> = <span class="hljs-string">&quot;change_name&quot;</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-variable constant_">ADD_NUMBER</span>,  <span class="hljs-variable constant_">CHANGE_NAME</span>&#125;</code></pre></div><p>reducer.js</p><p>reducer是将state和action联系起来的桥梁，reducer是纯函数，reducer做的事情是将传入的state和action结合起来生成新的state</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-variable constant_">ADD_NUMBER</span>, <span class="hljs-variable constant_">CHANGE_NAME</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./constants&quot;</span>)<span class="hljs-comment">// 初始化的数据</span><span class="hljs-keyword">const</span> initialState = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state = initialState, action</span>) &#123;  <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-attr">CHANGE_NAME</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">name</span>: action.<span class="hljs-property">name</span> &#125;    <span class="hljs-keyword">case</span> <span class="hljs-attr">ADD_NUMBER</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + action.<span class="hljs-property">num</span> &#125;    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">return</span> state  &#125;&#125;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = reducer</code></pre></div><p>index.js</p><p>创建store实例</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; createStore &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;redux&quot;</span>)<span class="hljs-keyword">const</span> reducer =  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./reducer.js&quot;</span>)<span class="hljs-comment">// 创建的store</span><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = store</code></pre></div><p>使用store中的数据</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./store&quot;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>())</code></pre></div><p>修改store中的数据</p><div class="code-wrapper"><pre><code class="hljs js">store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeNameAction</span>(<span class="hljs-string">&quot;kobe&quot;</span>))</code></pre></div><p>订阅store中的数据</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./store&quot;</span>)<span class="hljs-keyword">const</span> unsubscribe = store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;订阅数据的变化:&quot;</span>, store.<span class="hljs-title function_">getState</span>())&#125;)<span class="hljs-comment">// 修改store中的数据: 必须action</span>store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;change_name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span> &#125;)store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;change_name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lilei&quot;</span> &#125;)<span class="hljs-title function_">unsubscribe</span>()</code></pre></div><h4 id="redux-三大核心-store-action-reducer"><a href="#redux-三大核心-store-action-reducer" class="headerlink" title="redux 三大核心 store action reducer"></a>redux 三大核心 store action reducer</h4><h4 id="redux-的三大原则"><a href="#redux-的三大原则" class="headerlink" title="redux 的三大原则"></a>redux 的三大原则</h4><ul><li>单一数据源<ol><li> 整个应用程序的state被存储在一颗object tree中，并且这个object tree只存储在一个 store 中</li><li>Redux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护</li><li>单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改</li></ol></li><li>State是只读的<ol><li>​    唯一修改State的方法一定是触发action，不要试图在其他地方通过任何的方式来修改State</li><li>​    这样就确保了View或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改state</li><li>这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race condition（竟态）的问题</li></ol></li><li>使用纯函数来执行修改<ol><li>​    通过reducer将 旧state和 actions联系在一起，并且返回一个新的State</li><li>​    随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state tree的一部分</li><li>   但是所有的reducer都应该是纯函数，不能产生任何的副作用</li></ol></li></ul><img src="https://img1.imgtp.com/2022/09/13/UQYkeCuR.png" alt="QQ截图20220913015123.png" style="zoom:200%;" /><p><img src="https://img1.imgtp.com/2022/09/13/6ShJ2AyZ.png" alt="QQ截图20220913015145.png"></p><h4 id="react和redux结合使用"><a href="#react和redux结合使用" class="headerlink" title="react和redux结合使用"></a>react和redux结合使用</h4><p>react-redux的使用</p><div class="code-wrapper"><pre><code class="hljs html">//index.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import App from &#x27;./App&#x27;;import &#123; Provider &#125; from &quot;react-redux&quot;import store from &quot;./store&quot;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render(  // <span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>  // <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//在组件中使用</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span><span class="hljs-comment">// import store from &quot;../store&quot;</span><span class="hljs-keyword">import</span> &#123; addNumberAction, subNumberAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store/counter&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;  <span class="hljs-title function_">calcNumber</span>(<span class="hljs-params">num, isAdd</span>) &#123;    <span class="hljs-keyword">if</span> (isAdd) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">addNumber</span>(num)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">subNumber</span>(num)    &#125;  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> &#123; counter, banners, recommends, userInfo &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;user&#x27;</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>nickname: &#123;userInfo.nickname&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>About Page: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.calcNumber(6, true)&#125;&gt;+6<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.calcNumber(88, true)&#125;&gt;+88<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.calcNumber(6, false)&#125;&gt;-6<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.calcNumber(88, false)&#125;&gt;-88<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;banner&#x27;</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>轮播图数据:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">            &#123;</span><span class="language-xml">              banners.map((item, index) =&gt; &#123;</span><span class="language-xml">                return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml">              &#125;)</span><span class="language-xml">            &#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;recommend&#x27;</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>推荐数据:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">            &#123;</span><span class="language-xml">              recommends.map((item, index) =&gt; &#123;</span><span class="language-xml">                return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml">              &#125;)</span><span class="language-xml">            &#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; (&#123;  <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span>.<span class="hljs-property">counter</span>,  <span class="hljs-attr">banners</span>: state.<span class="hljs-property">home</span>.<span class="hljs-property">banners</span>,  <span class="hljs-attr">recommends</span>: state.<span class="hljs-property">home</span>.<span class="hljs-property">recommends</span>,  <span class="hljs-attr">userInfo</span>: state.<span class="hljs-property">user</span>.<span class="hljs-property">userInfo</span>&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch</span>) =&gt; (&#123;  <span class="hljs-title function_">addNumber</span>(<span class="hljs-params">num</span>) &#123;    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addNumberAction</span>(num))  &#125;,  <span class="hljs-title function_">subNumber</span>(<span class="hljs-params">num</span>) &#123;    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">subNumberAction</span>(num))  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="hljs-title class_">About</span>)</code></pre></div><p>没有使用react-redux的写法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store&quot;</span><span class="hljs-keyword">import</span> &#123; addNumberAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store/counter&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>()    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;      <span class="hljs-attr">counter</span>: store.<span class="hljs-title function_">getState</span>().<span class="hljs-property">counter</span>.<span class="hljs-property">counter</span>,      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,      <span class="hljs-attr">friends</span>: [        &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>&#125;,        &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">112</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>&#125;,        &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">113</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;james&quot;</span>&#125;,      ]    &#125;  &#125;  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;    store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">const</span> state = store.<span class="hljs-title function_">getState</span>().<span class="hljs-property">counter</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> &#125;)    &#125;)  &#125;  <span class="hljs-title function_">addNumber</span>(<span class="hljs-params">num</span>) &#123;    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addNumberAction</span>(num))  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> &#123; counter &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home Counter: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.addNumber(1)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.addNumber(5)&#125;&gt;+5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.addNumber(8)&#125;&gt;+8<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span></code></pre></div><h4 id="我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码"><a href="#我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码" class="headerlink" title="我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码"></a>我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码</h4><p>使用redux-thunk来发布异步请求</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-thunk&quot;</span><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reducer&quot;</span><span class="hljs-comment">// 正常情况下 store.dispatch(object)</span><span class="hljs-comment">// 想要派发函数 store.dispatch(function)</span><span class="hljs-comment">// redux-devtools</span><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;<span class="hljs-attr">trace</span>: <span class="hljs-literal">true</span>&#125;) || compose;<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, <span class="hljs-title function_">composeEnhancers</span>(<span class="hljs-title function_">applyMiddleware</span>(thunk)))<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><p>定义一个返回函数的action</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchHomeMultidataAction</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-comment">// 如果是一个普通的action, 那么我们这里需要返回action对象</span>  <span class="hljs-comment">// 问题: 对象中是不能直接拿到从服务器请求的异步数据的</span>  <span class="hljs-comment">// return &#123;&#125;</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch, getState</span>) &#123;    <span class="hljs-comment">// 异步操作: 网络请求</span>    <span class="hljs-comment">// console.log(&quot;foo function execution-----&quot;, getState().counter)</span>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> banners = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">banner</span>.<span class="hljs-property">list</span>      <span class="hljs-keyword">const</span> recommends = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">recommend</span>.<span class="hljs-property">list</span>      <span class="hljs-comment">// dispatch(&#123; type: actionTypes.CHANGE_BANNERS, banners &#125;)</span>      <span class="hljs-comment">// dispatch(&#123; type: actionTypes.CHANGE_RECOMMENDS, recommends &#125;)</span>      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeBannersAction</span>(banners))      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeRecommendsAction</span>(recommends))    &#125;)  &#125;  <span class="hljs-comment">// 如果返回的是一个函数, 那么redux是不支持的</span>  <span class="hljs-comment">// return foo</span>&#125;</code></pre></div><h4 id="定义applyMiddleware中间件"><a href="#定义applyMiddleware中间件" class="headerlink" title="定义applyMiddleware中间件"></a>定义applyMiddleware中间件</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMiddleware</span>(<span class="hljs-params">store, ...fns</span>) &#123;  fns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;    <span class="hljs-title function_">fn</span>(store)  &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> applyMiddleware</code></pre></div><h4 id="定义log中间件"><a href="#定义log中间件" class="headerlink" title="定义log中间件"></a>定义log中间件</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">store</span>) &#123;  <span class="hljs-keyword">const</span> next = store.<span class="hljs-property">dispatch</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">logAndDispatch</span>(<span class="hljs-params">action</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;当前派发的action:&quot;</span>, action)    <span class="hljs-comment">// 真正派发的代码: 使用之前的dispatch进行派发</span>    <span class="hljs-title function_">next</span>(action)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;派发之后的结果:&quot;</span>, store.<span class="hljs-title function_">getState</span>())  &#125;  <span class="hljs-comment">// monkey patch: 猴补丁 =&gt; 篡改现有的代码, 对整体的执行逻辑进行修改</span>  store.<span class="hljs-property">dispatch</span> = logAndDispatch&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> log</code></pre></div><h4 id="定义thunk中间件"><a href="#定义thunk中间件" class="headerlink" title="定义thunk中间件"></a>定义thunk中间件</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">thunk</span>(<span class="hljs-params">store</span>) &#123;  <span class="hljs-keyword">const</span> next = store.<span class="hljs-property">dispatch</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchThunk</span>(<span class="hljs-params">action</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&quot;function&quot;</span>) &#123;      <span class="hljs-title function_">action</span>(store.<span class="hljs-property">dispatch</span>, store.<span class="hljs-property">getState</span>)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-title function_">next</span>(action)    &#125;  &#125;  store.<span class="hljs-property">dispatch</span> = dispatchThunk&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> thunk</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore, compose, combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span><span class="hljs-keyword">import</span> &#123; log, thunk, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./middleware&quot;</span><span class="hljs-comment">// import thunk from &quot;redux-thunk&quot;</span><span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./counter&quot;</span><span class="hljs-keyword">import</span> homeReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./home&quot;</span><span class="hljs-keyword">import</span> userReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./user&quot;</span><span class="hljs-comment">// 正常情况下 store.dispatch(object)</span><span class="hljs-comment">// 想要派发函数 store.dispatch(function)</span><span class="hljs-comment">// 将两个reducer合并在一起</span><span class="hljs-keyword">const</span> reducer = <span class="hljs-title function_">combineReducers</span>(&#123;  <span class="hljs-attr">counter</span>: counterReducer,  <span class="hljs-attr">home</span>: homeReducer,  <span class="hljs-attr">user</span>: userReducer&#125;)<span class="hljs-comment">// combineReducers实现原理(了解)</span><span class="hljs-comment">// function reducer(state = &#123;&#125;, action) &#123;</span><span class="hljs-comment">//   // 返回一个对象, store的state</span><span class="hljs-comment">//   return &#123;</span><span class="hljs-comment">//     counter: counterReducer(state.counter, action),</span><span class="hljs-comment">//     home: homeReducer(state.home, action),</span><span class="hljs-comment">//     user: userReducer(state.user, action)</span><span class="hljs-comment">//   &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// redux-devtools</span><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;<span class="hljs-attr">trace</span>: <span class="hljs-literal">true</span>&#125;) || compose;<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer)<span class="hljs-title function_">applyMiddleware</span>(store, log, thunk)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><h4 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h4><p>redux给我们提供了一个combineReducers函数可以方便的让我们对多个reducer进行合并</p><p>事实上，它也是将我们传入的reducers合并到一个对象中，最终返回一个combination的函数（相当于我们之前的reducer函 数了）； </p><p> 在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state；</p><p> 新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新</p><h4 id="Redux-Toolkit的用法"><a href="#Redux-Toolkit的用法" class="headerlink" title="Redux Toolkit的用法"></a>Redux Toolkit的用法</h4><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @reduxjs/toolkit react-redux</code></pre></div><p>Redux Toolkit 是官方推荐的编写 Redux 逻辑的方法。</p><p>redux toolkit API </p><ul><li>configureStore:包装createStore以提供简化的配置选项和良好的默认值。它可以自动组合你的 slice reducer，添加你提供 的任何 Redux 中间件，redux-thunk默认包含，并启用 Redux DevTools Extension</li><li>createSlice:接受reducer函数的对象、切片名称和初始状态值，并自动生成切片reducer，并带有相应的actions</li><li>createAsyncThunk:接受一个动作类型字符串和一个返回promise的函数，并生成一个pending/fulfilled/rejected基于该promise分派动作类型的 thunk</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//store.index.js</span><span class="hljs-keyword">import</span> &#123; configureStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span><span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./features/counter&quot;</span><span class="hljs-keyword">import</span> homeReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./features/home&quot;</span><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">configureStore</span>(&#123;  <span class="hljs-attr">reducer</span>: &#123;    <span class="hljs-attr">counter</span>: counterReducer,    <span class="hljs-attr">home</span>: homeReducer  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">///features/counter.js</span><span class="hljs-keyword">import</span> &#123; createSlice &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span><span class="hljs-keyword">const</span> counterSlice = <span class="hljs-title function_">createSlice</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;counter&quot;</span>,<span class="hljs-comment">//用户标记slice的名词,在之后的redux-devtool中会显示对应的名词；</span>  <span class="hljs-comment">//初始化值</span>  <span class="hljs-attr">initialState</span>: &#123;    <span class="hljs-attr">counter</span>: <span class="hljs-number">888</span>  &#125;,  <span class="hljs-comment">//相当于之前的reducer函数</span>  <span class="hljs-attr">reducers</span>: &#123;    <span class="hljs-title function_">addNumber</span>(<span class="hljs-params">state, &#123; payload &#125;</span>) &#123;      state.<span class="hljs-property">counter</span> = state.<span class="hljs-property">counter</span> + payload    &#125;,    <span class="hljs-title function_">subNumber</span>(<span class="hljs-params">state, &#123; payload &#125;</span>) &#123;      state.<span class="hljs-property">counter</span> = state.<span class="hljs-property">counter</span> - payload    &#125;  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; addNumber, subNumber &#125; = counterSlice.<span class="hljs-property">actions</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> counterSlice.<span class="hljs-property">reducer</span></code></pre></div><p>//在组件中使用</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../hoc&quot;</span><span class="hljs-keyword">import</span> &#123; addNumber &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/features/counter&quot;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> &#123; counter &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>About Counter: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; (&#123;  <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span>.<span class="hljs-property">counter</span>&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch</span>) =&gt; (&#123;  <span class="hljs-title function_">addNumber</span>(<span class="hljs-params">num</span>) &#123;    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addNumber</span>(num))  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="hljs-title class_">About</span>)</code></pre></div><h4 id="Redux-Toolkit的异步操作"><a href="#Redux-Toolkit的异步操作" class="headerlink" title="Redux Toolkit的异步操作"></a>Redux Toolkit的异步操作</h4><p>Redux Toolkit默认已经给我们继承了Thunk相关的功能：createAsyncThunk</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createSlice, createAsyncThunk &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@reduxjs/toolkit&#x27;</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fetchHomeMultidataAction = <span class="hljs-title function_">createAsyncThunk</span>(  <span class="hljs-string">&quot;fetch/homemultidata&quot;</span>,   <span class="hljs-keyword">async</span> (extraInfo, &#123; dispatch, getState &#125;) =&gt; &#123;    <span class="hljs-comment">// console.log(extraInfo, dispatch, getState)</span>    <span class="hljs-comment">// 1.发送网络请求, 获取数据</span>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)    <span class="hljs-comment">// 2.取出数据, 并且在此处直接dispatch操作(可以不做)</span>    <span class="hljs-keyword">const</span> banners = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">banner</span>.<span class="hljs-property">list</span>    <span class="hljs-keyword">const</span> recommends = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">recommend</span>.<span class="hljs-property">list</span>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeBanners</span>(banners))    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeRecommends</span>(recommends))    <span class="hljs-comment">// 3.返回结果, 那么action状态会变成fulfilled状态</span>    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>&#125;)<span class="hljs-keyword">const</span> homeSlice = <span class="hljs-title function_">createSlice</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>,  <span class="hljs-attr">initialState</span>: &#123;    <span class="hljs-attr">banners</span>: [],    <span class="hljs-attr">recommends</span>: []  &#125;,  <span class="hljs-attr">reducers</span>: &#123;    <span class="hljs-title function_">changeBanners</span>(<span class="hljs-params">state, &#123; payload &#125;</span>) &#123;      state.<span class="hljs-property">banners</span> = payload    &#125;,    <span class="hljs-title function_">changeRecommends</span>(<span class="hljs-params">state, &#123; payload &#125;</span>) &#123;      state.<span class="hljs-property">recommends</span> = payload    &#125;  &#125;,  <span class="hljs-comment">// extraReducers: &#123;</span>  <span class="hljs-comment">//   [fetchHomeMultidataAction.pending](state, action) &#123;</span>  <span class="hljs-comment">//     console.log(&quot;fetchHomeMultidataAction pending&quot;)</span>  <span class="hljs-comment">//   &#125;,</span>  <span class="hljs-comment">//   [fetchHomeMultidataAction.fulfilled](state, &#123; payload &#125;) &#123;</span>  <span class="hljs-comment">//     state.banners = payload.data.banner.list</span>  <span class="hljs-comment">//     state.recommends = payload.data.recommend.list</span>  <span class="hljs-comment">//   &#125;,</span>  <span class="hljs-comment">//   [fetchHomeMultidataAction.rejected](state, action) &#123;</span>  <span class="hljs-comment">//     console.log(&quot;fetchHomeMultidataAction rejected&quot;)</span>  <span class="hljs-comment">//   &#125;</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-attr">extraReducers</span>: <span class="hljs-function">(<span class="hljs-params">builder</span>) =&gt;</span> &#123;    <span class="hljs-comment">// builder.addCase(fetchHomeMultidataAction.pending, (state, action) =&gt; &#123;</span>    <span class="hljs-comment">//   console.log(&quot;fetchHomeMultidataAction pending&quot;)</span>    <span class="hljs-comment">// &#125;).addCase(fetchHomeMultidataAction.fulfilled, (state, &#123; payload &#125;) =&gt; &#123;</span>    <span class="hljs-comment">//   state.banners = payload.data.banner.list</span>    <span class="hljs-comment">//   state.recommends = payload.data.recommend.list</span>    <span class="hljs-comment">// &#125;)</span>  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; changeBanners, changeRecommends &#125; = homeSlice.<span class="hljs-property">actions</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> homeSlice.<span class="hljs-property">reducer</span></code></pre></div><h4 id="Redux-Toolkit的数据不可变性"><a href="#Redux-Toolkit的数据不可变性" class="headerlink" title="Redux Toolkit的数据不可变性"></a>Redux Toolkit的数据不可变性</h4><p>我们经常会进行浅拷贝来完成某些操作，但是浅拷贝事实上也是存在问题的</p><p>比如过大的对象，进行浅拷贝也会造成性能的浪费</p><p>比如浅拷贝后的对象，在深层改变时，依然会对之前的对象产生影响</p><p>事实上Redux Toolkit底层使用了immerjs的一个库来保证数据的不可变性</p><p>为了节约内存，又出现了一个新的算法：Persistent Data Structure（持久化数据结构或一致性 数据结构）；</p><p>​    用一种数据结构来保存数据；</p><p>​    当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会 对内存造成浪费；</p><h4 id="自定义connect函数"><a href="#自定义connect函数" class="headerlink" title="自定义connect函数"></a>自定义connect函数</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//connect.js</span><span class="hljs-comment">// connect的参数:</span><span class="hljs-comment">// 参数一: 函数</span><span class="hljs-comment">// 参数二: 函数</span><span class="hljs-comment">// 返回值: 函数 =&gt; 高阶组件</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">StoreContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./StoreContext&quot;</span>;<span class="hljs-comment">// import store from &quot;../store&quot;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">mapStateToProps, mapDispatchToProps, store</span>) &#123;  <span class="hljs-comment">// 高阶组件: 函数</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">WrapperComponent</span>) &#123;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props, context</span>) &#123;        <span class="hljs-variable language_">super</span>(props)                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-title function_">mapStateToProps</span>(context.<span class="hljs-title function_">getState</span>())      &#125;      <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">unsubscribe</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// this.forceUpdate()</span>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-title function_">getState</span>()))        &#125;)      &#125;      <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unsubscribe</span>()      &#125;      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> stateObj = <span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-title function_">getState</span>())        <span class="hljs-keyword">const</span> dispatchObj = <span class="hljs-title function_">mapDispatchToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">dispatch</span>)        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrapperComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; &#123;<span class="hljs-attr">...stateObj</span>&#125; &#123;<span class="hljs-attr">...dispatchObj</span>&#125;/&gt;</span></span>      &#125;    &#125;    <span class="hljs-title class_">NewComponent</span>.<span class="hljs-property">contextType</span> = <span class="hljs-title class_">StoreContext</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NewComponent</span>  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//StoreContext.js</span><span class="hljs-keyword">import</span> &#123; createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">StoreContext</span> = <span class="hljs-title function_">createContext</span>()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象的原型继承</title>
    <link href="/2022/09/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    <url>/2022/09/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h4 id="直接将父类的原型赋值给子类"><a href="#直接将父类的原型赋值给子类" class="headerlink" title="直接将父类的原型赋值给子类"></a>直接将父类的原型赋值给子类</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义Person构造函数(类)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, height, address</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">running</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);&#125;;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eating</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);&#125;;<span class="hljs-comment">// 定义学生类</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, height, address, sno, score</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;&#125;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;&#125;;<span class="hljs-keyword">const</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-title function_">getName</span>());<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;777&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>, <span class="hljs-string">&quot;999&quot;</span>, <span class="hljs-string">&quot;101010&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">getName</span>());</code></pre></div><p>这种方式会使父类和子类共用原型链上的方法，子类也会修改父类原型链的方法，修改或者添加子类原型链上的方法，父类也会受到影响，父类原型链上也会有这个方法</p><h4 id="通过父类实例实现继承"><a href="#通过父类实例实现继承" class="headerlink" title="通过父类实例实现继承"></a>通过父类实例实现继承</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义Person构造函数(类)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, height, address</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">running</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);&#125;;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eating</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);&#125;;<span class="hljs-comment">// 定义学生类</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">sno, score</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;&#125;<span class="hljs-comment">// Student.prototype指向Person实例</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = p1;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;&#125;;<span class="hljs-keyword">const</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;555&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-title function_">getName</span>());<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;777&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>, <span class="hljs-string">&quot;999&quot;</span>, <span class="hljs-string">&quot;101010&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">getName</span>());</code></pre></div><p>原型链继承虽然可以解决子类会修改父类的原型链上的方法的问题，但是子类无法查看父类的参数，也，也没办法修改父类的参数，打印看不到父类的参数，不可以给父类传参</p><h4 id="借用构造函数的继承"><a href="#借用构造函数的继承" class="headerlink" title="借用构造函数的继承"></a>借用构造函数的继承</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, height, address</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">running</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);&#125;;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eating</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);&#125;;<span class="hljs-comment">// 定义学生类</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, height, address, sno, score</span>) &#123;  <span class="hljs-comment">// 借用父类的构造函数</span>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, height, address);  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;&#125;<span class="hljs-comment">// Student.prototype指向Person实例</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = p1;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;&#125;;<span class="hljs-keyword">const</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-title function_">getName</span>());<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-title function_">eating</span>());<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;777&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>, <span class="hljs-string">&quot;999&quot;</span>, <span class="hljs-string">&quot;101010&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">eating</span>());</code></pre></div><p>这种方式会调用两次父类的构造函数</p><p>一次在创建子类原型的时候</p><p>另一次在子类构造函数内部(也就是每次创建子类实例的时候)；</p><h4 id="组合寄生式继承"><a href="#组合寄生式继承" class="headerlink" title="组合寄生式继承"></a>组合寄生式继承</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">o</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();&#125;<span class="hljs-comment">// 创建寄生函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">Subtype, Supertype</span>) &#123;  <span class="hljs-comment">// 方式一</span>  <span class="hljs-comment">// const obj=Object.create(Supertype.prototype)</span>  <span class="hljs-comment">// Subtype.prototype=obj</span>  <span class="hljs-comment">// 方式二</span>  <span class="hljs-title class_">Subtype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">createObject</span>(<span class="hljs-title class_">Supertype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Subtype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">value</span>: <span class="hljs-title class_">Subtype</span>,  &#125;);  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-title class_">Subtype</span>, <span class="hljs-title class_">Supertype</span>);  <span class="hljs-comment">// Subtype.__proto__=Supertype</span>&#125;<span class="hljs-comment">// 寄生组合式继承</span><span class="hljs-comment">// 原型链/借用/原型式(对象之间)/寄生式函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, height</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">running</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);&#125;;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eating</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);&#125;;<span class="hljs-comment">//类方法</span><span class="hljs-title class_">Person</span>.<span class="hljs-property">sleep</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;static sleep&quot;</span>);&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, height, sno, score</span>) &#123;  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, height);  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;&#125;<span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>);<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">studying</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;studying&quot;</span>);&#125;;<span class="hljs-comment">// 创建实例对象</span><span class="hljs-keyword">var</span> stu1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>, <span class="hljs-number">111</span>, <span class="hljs-number">100</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu1);stu1.<span class="hljs-title function_">studying</span>();<span class="hljs-title class_">Student</span>.<span class="hljs-title function_">sleep</span>();</code></pre></div><h4 id="ES6中的继承"><a href="#ES6中的继承" class="headerlink" title="ES6中的继承"></a>ES6中的继承</h4><p>es6中增加了extends关键字来实现继承</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;   &#125;   <span class="hljs-title function_">running</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);   &#125;   <span class="hljs-title function_">eating</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);   &#125;   <span class="hljs-keyword">static</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;static animal sleep&quot;</span>);   &#125; &#125; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age, sno, score</span>) &#123;     <span class="hljs-comment">// super可用来调用父类的构造函数、实例方法，静态方法</span>     <span class="hljs-variable language_">super</span>(name, age);     <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;     <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;   &#125;   <span class="hljs-title function_">studying</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;studying~&quot;</span>);   &#125; &#125; <span class="hljs-keyword">const</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>); <span class="hljs-comment">// 类方法也可以实现继承</span> <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">sleep</span>();</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>call函数的实现</title>
    <link href="/2022/09/07/call%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/07/call%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">MyCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, ...args</span>) &#123;  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;  thisArg = thisArg != <span class="hljs-literal">null</span> ? <span class="hljs-title class_">Object</span>(thisArg) : globalThis; <span class="hljs-comment">//Object(thisArg)如果是基本类型将会将换成包装类，globalThis分别对应window/node的环境</span>  args = args || [];  thisArg.<span class="hljs-property">fn</span> = fn;  <span class="hljs-keyword">const</span> result = thisArg.<span class="hljs-title function_">fn</span>(...args);  <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span>;  <span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo函数被执行&quot;</span>, <span class="hljs-variable language_">this</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum函数被执行&quot;</span>, <span class="hljs-variable language_">this</span>, num1, num2);  <span class="hljs-keyword">return</span> num1 + num2;&#125;foo.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>);<span class="hljs-keyword">var</span> result = sum.<span class="hljs-title function_">call</span>(&#123;&#125;, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<span class="hljs-comment">// console.log(&quot;系统调用的结果:&quot;, result)</span><span class="hljs-comment">// 自己实现的函数的hycall方法</span><span class="hljs-comment">// 默认进行隐式绑定</span><span class="hljs-comment">// foo.hycall(&#123;name: &quot;why&quot;&#125;)</span>foo.<span class="hljs-title class_">MyCall</span>(<span class="hljs-literal">undefined</span>);<span class="hljs-keyword">var</span> result = sum.<span class="hljs-title class_">MyCall</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hycall的调用:&quot;</span>, result);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Apply函数的实现</title>
    <link href="/2022/09/07/Apply%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/07/Apply%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, args</span>) &#123;  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;  thisArg = thisArg != <span class="hljs-literal">null</span> ? <span class="hljs-title class_">Object</span>(thisArg) : globalThis;  <span class="hljs-keyword">if</span> (!(args <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;args is no array&quot;</span>);  &#125;  args = args || [];  thisArg.<span class="hljs-property">fn</span> = fn;  <span class="hljs-keyword">const</span> result = thisArg.<span class="hljs-title function_">fn</span>(...args);  <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span>;  <span class="hljs-keyword">return</span> result;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>节流函数的实现</title>
    <link href="/2022/09/07/%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/07/%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="节流函数的基本实现"><a href="#节流函数的基本实现" class="headerlink" title="节流函数的基本实现"></a>节流函数的基本实现</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params">fn, interval</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            <span class="hljs-title function_">fn</span>();</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">      &#125;, <span class="hljs-number">1000</span>);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="this和参数绑定"><a href="#this和参数绑定" class="headerlink" title="this和参数绑定"></a>this和参数绑定</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params">fn, interval</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">      &#125;, <span class="hljs-number">1000</span>);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="对立即执行进行控制"><a href="#对立即执行进行控制" class="headerlink" title="对立即执行进行控制"></a>对立即执行进行控制</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params">fn, interval, leading = <span class="hljs-literal">true</span></span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-comment">// 对立即执行进行控制</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (!leading &amp;&amp; startTime === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(</span><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">1000</span>,</span><span class="language-javascript">        <span class="hljs-literal">false</span></span><span class="language-javascript">      );</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>尾部执行控制</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="language-javascript">        fn,</span></span><span class="hljs-params"><span class="language-javascript">        interval,</span></span><span class="hljs-params"><span class="language-javascript">        &#123; leading = <span class="hljs-literal">true</span>, trailing = <span class="hljs-literal">false</span> &#125; = &#123;&#125;</span></span><span class="hljs-params"><span class="language-javascript">      </span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-comment">// 对立即执行进行控制</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (!leading &amp;&amp; startTime === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">            <span class="hljs-keyword">return</span>;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-comment">// 针对waitTime还有余数的时候</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (trailing &amp;&amp; !timer) &#123;</span><span class="language-javascript">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">              fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">              timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">              startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">            &#125;, waitTime);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(</span><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">1000</span>,</span><span class="language-javascript">        &#123; <span class="hljs-attr">trailing</span>: <span class="hljs-literal">true</span> &#125;</span><span class="language-javascript">      );</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="取消函数"><a href="#取消函数" class="headerlink" title="取消函数"></a>取消函数</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="language-javascript">        fn,</span></span><span class="hljs-params"><span class="language-javascript">        interval,</span></span><span class="hljs-params"><span class="language-javascript">        &#123; leading = <span class="hljs-literal">true</span>, trailing = <span class="hljs-literal">false</span> &#125; = &#123;&#125;</span></span><span class="hljs-params"><span class="language-javascript">      </span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-comment">// 对立即执行进行控制</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (!leading &amp;&amp; startTime === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">            <span class="hljs-keyword">return</span>;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-comment">// 针对waitTime还有余数的时候</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (trailing &amp;&amp; !timer) &#123;</span><span class="language-javascript">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">              fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">              timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">              startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">            &#125;, waitTime);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消函数</span></span><span class="language-javascript">        _throttle.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">          startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _throttle;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(</span><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">1000</span>,</span><span class="language-javascript">        &#123; <span class="hljs-attr">trailing</span>: <span class="hljs-literal">true</span> &#125;</span><span class="language-javascript">      );</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="language-javascript">        fn,</span></span><span class="hljs-params"><span class="language-javascript">        interval,</span></span><span class="hljs-params"><span class="language-javascript">        &#123; leading = <span class="hljs-literal">true</span>, trailing = <span class="hljs-literal">false</span> &#125; = &#123;&#125;</span></span><span class="hljs-params"><span class="language-javascript">      </span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">try</span> &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">              <span class="hljs-keyword">try</span> &#123;</span><span class="language-javascript">              &#125; <span class="hljs-keyword">catch</span> (error) &#123;&#125;</span><span class="language-javascript">            &#125;);</span><span class="language-javascript">            <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">            <span class="hljs-comment">// 对立即执行进行控制</span></span><span class="language-javascript">            <span class="hljs-keyword">if</span> (!leading &amp;&amp; startTime === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">              startTime = nowTime;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">            <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">            <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">              <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">              <span class="hljs-keyword">const</span> res = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">              <span class="hljs-title function_">resolve</span>(res);</span><span class="language-javascript">              startTime = nowTime;</span><span class="language-javascript">              timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">              <span class="hljs-keyword">return</span>;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">            <span class="hljs-comment">// 针对waitTime还有余数的时候</span></span><span class="language-javascript">            <span class="hljs-keyword">if</span> (trailing &amp;&amp; !timer) &#123;</span><span class="language-javascript">              timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">                fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">                timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">                startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">              &#125;, waitTime);</span><span class="language-javascript">            &#125;</span><span class="language-javascript">          &#125; <span class="hljs-keyword">catch</span> (error) &#123;</span><span class="language-javascript">            <span class="hljs-title function_">reject</span>(error);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消函数</span></span><span class="language-javascript">        _throttle.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">          startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _throttle;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(</span><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">1000</span>,</span><span class="language-javascript">        &#123; <span class="hljs-attr">trailing</span>: <span class="hljs-literal">true</span> &#125;</span><span class="language-javascript">      );</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>防抖函数的实现</title>
    <link href="/2022/09/07/%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/07/%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="节流函数的基本实现"><a href="#节流函数的基本实现" class="headerlink" title="节流函数的基本实现"></a>节流函数的基本实现</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params">fn, delay</span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 记录上一次的timer</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 返回需要执行的函数</span></span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript"></span><span class="language-javascript">          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">            <span class="hljs-title function_">fn</span>();</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span><span class="language-javascript">          &#125;, delay);</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">mydebounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;----------&quot;</span>);</span><span class="language-javascript">      &#125;, <span class="hljs-number">1000</span>);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="this的绑定和参数传递"><a href="#this的绑定和参数传递" class="headerlink" title="this的绑定和参数传递"></a>this的绑定和参数传递</h4><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params">fn, delay</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 记录上一次的timer</span></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 返回需要执行的函数</span></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span></span><span class="language-javascript"><span class="language-xml">            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span></span><span class="language-javascript"><span class="language-xml">          &#125;, delay);</span></span><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">mydebounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;----------&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">      &#125;, <span class="hljs-number">1000</span>);</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h4 id="取消功能的实现"><a href="#取消功能的实现" class="headerlink" title="取消功能的实现"></a>取消功能的实现</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params">fn, delay</span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 记录上一次的timer</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 返回需要执行的函数</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript"></span><span class="language-javascript">          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span><span class="language-javascript">          &#125;, delay);</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消功能</span></span><span class="language-javascript">        _debounce.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _debounce;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> buttonEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> debounce = <span class="hljs-title function_">mydebounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;----------&quot;</span>);</span><span class="language-javascript">      &#125;, <span class="hljs-number">3000</span>);</span><span class="language-javascript"></span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = debounce;</span><span class="language-javascript"></span><span class="language-javascript">      buttonEl.<span class="hljs-property">onclick</span> = debounce.<span class="hljs-property">cancel</span>;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="实现立即执行功能"><a href="#实现立即执行功能" class="headerlink" title="实现立即执行功能"></a>实现立即执行功能</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params">fn, delay, immediate = <span class="hljs-literal">false</span></span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 记录上一次的timer</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 记录是否需要第一次是否执行和immediate配合</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> isInvoke = <span class="hljs-literal">false</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 返回需要执行的函数</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          <span class="hljs-comment">// 当immediate为true时</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (immediate &amp;&amp; !isInvoke) &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            isInvoke = <span class="hljs-literal">true</span>;</span><span class="language-javascript">            <span class="hljs-keyword">return</span>;</span><span class="language-javascript">          &#125;</span><span class="language-javascript"></span><span class="language-javascript">          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span><span class="language-javascript">            isInvoke = <span class="hljs-literal">false</span>; <span class="hljs-comment">//重置</span></span><span class="language-javascript">          &#125;, delay);</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消功能</span></span><span class="language-javascript">        _debounce.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _debounce;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> buttonEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> debounce = <span class="hljs-title function_">mydebounce</span>(</span><span class="language-javascript">        <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;----------&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">3000</span>,</span><span class="language-javascript">        <span class="hljs-literal">true</span></span><span class="language-javascript">      );</span><span class="language-javascript"></span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = debounce;</span><span class="language-javascript"></span><span class="language-javascript">      buttonEl.<span class="hljs-property">onclick</span> = debounce.<span class="hljs-property">cancel</span>;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="获取返回值的实现"><a href="#获取返回值的实现" class="headerlink" title="获取返回值的实现"></a>获取返回值的实现</h4><p>获取返回值的方式有两种</p><p>传入回调函数</p><p>通过promise.then来获取</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="language-javascript">        fn,</span></span><span class="hljs-params"><span class="language-javascript">        delay,</span></span><span class="hljs-params"><span class="language-javascript">        immediate = <span class="hljs-literal">false</span>,</span></span><span class="hljs-params"><span class="language-javascript">        resultCallback = () =&gt; &#123;&#125;</span></span><span class="hljs-params"><span class="language-javascript">      </span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 记录上一次的timer</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 记录是否需要第一次是否执行和immediate配合</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> isInvoke = <span class="hljs-literal">false</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 返回需要执行的函数</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">            <span class="hljs-keyword">try</span> &#123;</span><span class="language-javascript">              <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span><span class="language-javascript">              <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">              <span class="hljs-comment">// 当immediate为true时</span></span><span class="language-javascript">              <span class="hljs-keyword">if</span> (immediate &amp;&amp; !isInvoke) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">const</span> result = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">                <span class="hljs-title function_">resultCallback</span>(result);</span><span class="language-javascript">                <span class="hljs-title function_">resolve</span>(result);</span><span class="language-javascript">                isInvoke = <span class="hljs-literal">true</span>;</span><span class="language-javascript">                <span class="hljs-keyword">return</span>;</span><span class="language-javascript">              &#125;</span><span class="language-javascript"></span><span class="language-javascript">              timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">                <span class="hljs-keyword">const</span> result = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">                <span class="hljs-title function_">resultCallback</span>(result);</span><span class="language-javascript">                <span class="hljs-title function_">resolve</span>(result);</span><span class="language-javascript">                timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span><span class="language-javascript">                isInvoke = <span class="hljs-literal">false</span>; <span class="hljs-comment">//重置</span></span><span class="language-javascript">              &#125;, delay);</span><span class="language-javascript">            &#125; <span class="hljs-keyword">catch</span> (error) &#123;</span><span class="language-javascript">              <span class="hljs-title function_">reject</span>(error);</span><span class="language-javascript">            &#125;</span><span class="language-javascript">          &#125;);</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消功能</span></span><span class="language-javascript">        _debounce.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">          isInvoke = <span class="hljs-literal">false</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _debounce;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> buttonEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> debounce = <span class="hljs-title function_">mydebounce</span>(</span><span class="language-javascript">        <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;----------&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">3000</span>,</span><span class="language-javascript">        <span class="hljs-literal">true</span></span><span class="language-javascript">      );</span><span class="language-javascript"></span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = debounce;</span><span class="language-javascript"></span><span class="language-javascript">      buttonEl.<span class="hljs-property">onclick</span> = debounce.<span class="hljs-property">cancel</span>;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>节流防抖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义事件总线</title>
    <link href="/2022/09/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <url>/2022/09/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-btn&quot;</span>&gt;</span>nav button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 类EventBus -&gt; 事件总线对象</span></span><span class="language-javascript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">HYEventBus</span> &#123;</span><span class="language-javascript">      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span> = &#123;&#125;</span><span class="language-javascript">      &#125;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-title function_">on</span>(<span class="hljs-params">eventName, eventFn</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]</span><span class="language-javascript">        <span class="hljs-keyword">if</span> (!eventFns) &#123;</span><span class="language-javascript">          eventFns = []</span><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName] = eventFns</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        eventFns.<span class="hljs-title function_">push</span>(eventFn)</span><span class="language-javascript">      &#125;</span><span class="language-javascript">      </span><span class="language-javascript">      <span class="hljs-title function_">off</span>(<span class="hljs-params">eventName, eventFn</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]</span><span class="language-javascript">        <span class="hljs-keyword">if</span> (!eventFns) <span class="hljs-keyword">return</span></span><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; eventFns.<span class="hljs-property">length</span>; i++) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> fn = eventFns[i]</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (fn === eventFn) &#123;</span><span class="language-javascript">            eventFns.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>)</span><span class="language-javascript">            <span class="hljs-keyword">break</span></span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-comment">// 如果eventFns已经清空了</span></span><span class="language-javascript">        <span class="hljs-keyword">if</span> (eventFns.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]</span><span class="language-javascript">        &#125;</span><span class="language-javascript">      &#125;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-title function_">emit</span>(<span class="hljs-params">eventName, ...args</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]</span><span class="language-javascript">        <span class="hljs-keyword">if</span> (!eventFns) <span class="hljs-keyword">return</span></span><span class="language-javascript">        eventFns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-title function_">fn</span>(...args)</span><span class="language-javascript">        &#125;)</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 使用过程</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HYEventBus</span>()</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// aside.vue组件中监听事件</span></span><span class="language-javascript">    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;navclick&quot;</span>, <span class="hljs-function">(<span class="hljs-params">name, age, height</span>) =&gt;</span> &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;navclick listener 01&quot;</span>, name, age, height)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">click</span> =  (<span class="hljs-params"></span>) =&gt; &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;navclick listener 02&quot;</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;navclick&quot;</span>, click)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">      eventBus.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;navclick&quot;</span>, click)</span><span class="language-javascript">    &#125;, <span class="hljs-number">5000</span>);</span><span class="language-javascript"></span><span class="language-javascript">    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;asideclick&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;asideclick listener&quot;</span>)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// nav.vue</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> navBtnEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.nav-btn&quot;</span>)</span><span class="language-javascript">    navBtnEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;自己监听到&quot;</span>)</span><span class="language-javascript">      eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;navclick&quot;</span>, <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>响应式原理的实现</title>
    <link href="/2022/09/05/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/05/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是响应式"><a href="#什么是响应式" class="headerlink" title="什么是响应式"></a>什么是响应式</h4><p>响应式就是当对象中的属性发生更改的时候，依赖该属性的函数也会重新执行</p><h4 id="封装一个响应式的函数"><a href="#封装一个响应式的函数" class="headerlink" title="封装一个响应式的函数"></a>封装一个响应式的函数</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个容器来收集依赖</span><span class="hljs-keyword">const</span> reactiveFns = [];<span class="hljs-comment">// 定义一个收集依赖的函数</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">watchFn</span> = (<span class="hljs-params">fn</span>) =&gt; &#123;  reactiveFns.<span class="hljs-title function_">push</span>(fn);&#125;;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = obj.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;普通的其他函数&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这个函数不需要有任何响应式&quot;</span>);&#125;obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;<span class="hljs-comment">// 当数据变化的时候，执行对应的函数</span>reactiveFns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;  <span class="hljs-title function_">fn</span>();&#125;);</code></pre></div><h4 id="依赖收集类的封装"><a href="#依赖收集类的封装" class="headerlink" title="依赖收集类的封装"></a>依赖收集类的封装</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = [];  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn);  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-title function_">fn</span>();    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  depend.<span class="hljs-title function_">addDepend</span>(fn);&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = obj.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;depend.<span class="hljs-title function_">notify</span>();</code></pre></div><h4 id="自动监听对象的变化"><a href="#自动监听对象的变化" class="headerlink" title="自动监听对象的变化"></a>自动监听对象的变化</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = [];  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn);  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-title function_">fn</span>();    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  depend.<span class="hljs-title function_">addDepend</span>(fn);&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);  &#125;,  <span class="hljs-comment">// receiver就是objProxy</span>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);  &#125;,&#125;);<span class="hljs-comment">// 使用对象代理的方式去操作对象，不要直接操作对象</span><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = objProxy.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;depend.<span class="hljs-title function_">notify</span>();</code></pre></div><h4 id="依赖收集的管理"><a href="#依赖收集的管理" class="headerlink" title="依赖收集的管理"></a>依赖收集的管理</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = [];  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn);  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (fn) &#123;        <span class="hljs-title function_">fn</span>();      &#125;    &#125;);  &#125;&#125;<span class="hljs-comment">// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集</span><span class="hljs-keyword">let</span> activeReactiveFn = <span class="hljs-literal">null</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  activeReactiveFn = fn;  <span class="hljs-comment">// 先执行一次触发get进行依赖收集</span>  <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 将置为null</span>  activeReactiveFn = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">//使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-comment">// 根据target对象获取map的过程</span>  <span class="hljs-keyword">let</span> map = targetMap.<span class="hljs-title function_">get</span>(target); <span class="hljs-comment">//获取对应的对象的映射</span>  <span class="hljs-keyword">if</span> (!map) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    targetMap.<span class="hljs-title function_">set</span>(target, map);  &#125;  <span class="hljs-keyword">let</span> depend = map.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!depend) &#123;    depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();    map.<span class="hljs-title function_">set</span>(key, depend);  &#125;  <span class="hljs-keyword">return</span> depend;&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;  <span class="hljs-comment">// receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver === objProxy)<span class="hljs-comment">//true</span>    <span class="hljs-comment">// 在get中获取对应的depend</span>    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);    <span class="hljs-comment">// 给depend添加响应函数</span>    depend.<span class="hljs-title function_">addDepend</span>(activeReactiveFn);    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);  &#125;,  <span class="hljs-comment">// receiver就是objProxy</span>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);    depend.<span class="hljs-title function_">notify</span>();  &#125;,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = objProxy.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age 发生变化是需要执行的----1&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age 发生变化是需要执行的----2&quot;</span>);&#125;);objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;james&quot;</span>;objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;curry&quot;</span>;objProxy.<span class="hljs-property">age</span> = <span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> info = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>,&#125;;<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">address</span>, <span class="hljs-string">&quot;监听address变化+++++++++1&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">address</span>, <span class="hljs-string">&quot;监听address变化+++++++++2&quot;</span>);&#125;);</code></pre></div><h4 id="重构Depend"><a href="#重构Depend" class="headerlink" title="重构Depend"></a>重构Depend</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集</span><span class="hljs-keyword">let</span> activeReactiveFn = <span class="hljs-literal">null</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Depend优化:</span><span class="hljs-comment">   *  1&gt; depend方法</span><span class="hljs-comment">   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (activeReactiveFn) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(activeReactiveFn);    &#125;  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (fn) &#123;        <span class="hljs-title function_">fn</span>();      &#125;    &#125;);  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  activeReactiveFn = fn;  <span class="hljs-comment">// 先执行一次触发get进行依赖收集</span>  <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 将置为null</span>  activeReactiveFn = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">//使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-comment">// 根据target对象获取map的过程</span>  <span class="hljs-keyword">let</span> map = targetMap.<span class="hljs-title function_">get</span>(target); <span class="hljs-comment">//获取对应的对象的映射</span>  <span class="hljs-keyword">if</span> (!map) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    targetMap.<span class="hljs-title function_">set</span>(target, map);  &#125;  <span class="hljs-keyword">let</span> depend = map.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!depend) &#123;    depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();    map.<span class="hljs-title function_">set</span>(key, depend);  &#125;  <span class="hljs-keyword">return</span> depend;&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;  <span class="hljs-comment">// receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;    <span class="hljs-comment">// 在get中获取对应的depend</span>    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);    <span class="hljs-comment">// 给depend添加响应函数</span>    depend.<span class="hljs-title function_">depend</span>();    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);  &#125;,  <span class="hljs-comment">// receiver就是objProxy</span>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);    depend.<span class="hljs-title function_">notify</span>();  &#125;,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = objProxy.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age 发生变化是需要执行的----1&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age 发生变化是需要执行的----2&quot;</span>);&#125;);objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;james&quot;</span>;objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;curry&quot;</span>;objProxy.<span class="hljs-property">age</span> = <span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> info = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>,&#125;;<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">address</span>, <span class="hljs-string">&quot;监听address变化+++++++++1&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">address</span>, <span class="hljs-string">&quot;监听address变化+++++++++2&quot;</span>);&#125;);</code></pre></div><h4 id="vue3对象的响应式操作"><a href="#vue3对象的响应式操作" class="headerlink" title="vue3对象的响应式操作"></a>vue3对象的响应式操作</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集</span><span class="hljs-keyword">let</span> activeReactiveFn = <span class="hljs-literal">null</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Depend优化:</span><span class="hljs-comment">   *  1&gt; depend方法</span><span class="hljs-comment">   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (activeReactiveFn) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(activeReactiveFn);    &#125;  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (fn) &#123;        <span class="hljs-title function_">fn</span>();      &#125;    &#125;);  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  activeReactiveFn = fn;  <span class="hljs-comment">// 先执行一次触发get进行依赖收集</span>  <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 将置为null</span>  activeReactiveFn = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">//使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-comment">// 根据target对象获取map的过程</span>  <span class="hljs-keyword">let</span> map = targetMap.<span class="hljs-title function_">get</span>(target); <span class="hljs-comment">//获取对应的对象的映射</span>  <span class="hljs-keyword">if</span> (!map) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    targetMap.<span class="hljs-title function_">set</span>(target, map);  &#125;  <span class="hljs-keyword">let</span> depend = map.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!depend) &#123;    depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();    map.<span class="hljs-title function_">set</span>(key, depend);  &#125;  <span class="hljs-keyword">return</span> depend;&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;    <span class="hljs-comment">// receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作</span>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;      <span class="hljs-comment">// 在get中获取对应的depend</span>      <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);      <span class="hljs-comment">// 给depend添加响应函数</span>      depend.<span class="hljs-title function_">depend</span>();      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);    &#125;,    <span class="hljs-comment">// receiver就是objProxy</span>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;      <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);      <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);      depend.<span class="hljs-title function_">notify</span>();    &#125;,  &#125;);&#125;<span class="hljs-keyword">const</span> objProxy = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;);<span class="hljs-keyword">const</span> infoProxy = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>,  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoProxy.<span class="hljs-property">address</span>);&#125;);infoProxy.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;北京市&quot;</span>;<span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">name</span>);&#125;);foo.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;bar&quot;</span>;</code></pre></div><h4 id="vue2对象的响应式操作"><a href="#vue2对象的响应式操作" class="headerlink" title="vue2对象的响应式操作"></a>vue2对象的响应式操作</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集</span><span class="hljs-keyword">let</span> activeReactiveFn = <span class="hljs-literal">null</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Depend优化:</span><span class="hljs-comment">   *  1&gt; depend方法</span><span class="hljs-comment">   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (activeReactiveFn) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(activeReactiveFn);    &#125;  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (fn) &#123;        <span class="hljs-title function_">fn</span>();      &#125;    &#125;);  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  activeReactiveFn = fn;  <span class="hljs-comment">// 先执行一次触发get进行依赖收集</span>  <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 将置为null</span>  activeReactiveFn = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">//使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-comment">// 根据target对象获取map的过程</span>  <span class="hljs-keyword">let</span> map = targetMap.<span class="hljs-title function_">get</span>(target); <span class="hljs-comment">//获取对应的对象的映射</span>  <span class="hljs-keyword">if</span> (!map) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    targetMap.<span class="hljs-title function_">set</span>(target, map);  &#125;  <span class="hljs-keyword">let</span> depend = map.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!depend) &#123;    depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();    map.<span class="hljs-title function_">set</span>(key, depend);  &#125;  <span class="hljs-keyword">return</span> depend;&#125;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> value = obj[key];    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(obj, key);        depend.<span class="hljs-title function_">depend</span>();        <span class="hljs-keyword">return</span> value;      &#125;,      <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;        value = newValue;        <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(obj, key);        depend.<span class="hljs-title function_">notify</span>();      &#125;,    &#125;);  &#125;);  <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">const</span> infoProxy = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>,  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoProxy.<span class="hljs-property">address</span>);&#125;);infoProxy.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;北京市&quot;</span>;<span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">name</span>);&#125;);foo.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;bar&quot;</span>;foo.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;hhh&quot;</span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>搜集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组转换成树形解构</title>
    <link href="/2022/09/05/%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A0%91%E5%BD%A2%E8%A7%A3%E6%9E%84/"/>
    <url>/2022/09/05/%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A0%91%E5%BD%A2%E8%A7%A3%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现自动柯里化函数</title>
    <link href="/2022/09/05/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    <url>/2022/09/05/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝的实现方式</title>
    <link href="/2022/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否是对象</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">const</span> valueType = <span class="hljs-keyword">typeof</span> value;  <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> &amp;&amp; (valueType === <span class="hljs-string">&quot;object&quot;</span> || valueType === <span class="hljs-string">&quot;function&quot;</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">originValue</span>) &#123;   <span class="hljs-comment">// 数据类型是symbol</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(originValue.<span class="hljs-property">description</span>);  &#125;  <span class="hljs-comment">// 原始数据类型直接返回</span>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(originValue)) &#123;    <span class="hljs-keyword">return</span> originValue;  &#125;  <span class="hljs-comment">// 判断是否是function</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">return</span> originValue;  &#125;  <span class="hljs-comment">// 判断是否是set类型</span>  <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;    <span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> originValue) &#123;      newSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepClone</span>(item));    &#125;    <span class="hljs-keyword">return</span> newSet;  &#125;  <span class="hljs-comment">// 判断是否是Map类型</span>  <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;    <span class="hljs-keyword">const</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> originValue) &#123;      newMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">deepClone</span>(value));    &#125;  &#125;  <span class="hljs-comment">// 判断是否是Array</span>  <span class="hljs-keyword">const</span> newOBj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(originValue) ? [] : &#123;&#125;;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> originValue) &#123;    newOBj[key] = <span class="hljs-title function_">deepClone</span>(originValue[key]);  &#125;  <span class="hljs-comment">// 单独遍历Symbol</span>  <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(originValue);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> symbolKey <span class="hljs-keyword">of</span> symbolKeys) &#123;    newOBj[<span class="hljs-title class_">Symbol</span>(symbolKey.<span class="hljs-property">description</span>)] = <span class="hljs-title function_">deepClone</span>(originValue[symbolKey]);  &#125;  <span class="hljs-keyword">return</span> newOBj;&#125;</code></pre></div><h4 id="当拷贝的对象中出现循环引用时"><a href="#当拷贝的对象中出现循环引用时" class="headerlink" title="当拷贝的对象中出现循环引用时"></a>当拷贝的对象中出现循环引用时</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否是对象</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">const</span> valueType = <span class="hljs-keyword">typeof</span> value;  <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> &amp;&amp; (valueType === <span class="hljs-string">&quot;object&quot;</span> || valueType === <span class="hljs-string">&quot;function&quot;</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">originValue, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;  <span class="hljs-comment">// 数据类型是symbol</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(originValue.<span class="hljs-property">description</span>);  &#125;  <span class="hljs-comment">// 原始数据类型直接返回</span>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(originValue)) &#123;    <span class="hljs-keyword">return</span> originValue;  &#125;  <span class="hljs-comment">// 判断是否是function</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">return</span> originValue;  &#125;  <span class="hljs-comment">// 判断是否是set类型</span>  <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;    <span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> originValue) &#123;      newSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepClone</span>(item));    &#125;    <span class="hljs-keyword">return</span> newSet;  &#125;  <span class="hljs-comment">// 判断是否是Map类型</span>  <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;    <span class="hljs-keyword">const</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> originValue) &#123;      newMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">deepClone</span>(value));    &#125;  &#125;  <span class="hljs-comment">// 如果有循环引用的对象，return</span>  <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(originValue)) &#123;    <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(originValue);  &#125;  <span class="hljs-comment">// 判断是否是Array</span>  <span class="hljs-keyword">const</span> newOBj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(originValue) ? [] : &#123;&#125;;  map.<span class="hljs-title function_">set</span>(originValue, newOBj);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> originValue) &#123;    newOBj[key] = <span class="hljs-title function_">deepClone</span>(originValue[key], map);  &#125;  <span class="hljs-comment">// 以symbol作为key</span>  <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(originValue);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> symbolKey <span class="hljs-keyword">of</span> symbolKeys) &#123;    newOBj[<span class="hljs-title class_">Symbol</span>(symbolKey.<span class="hljs-property">description</span>)] = <span class="hljs-title function_">deepClone</span>(      originValue[symbolKey],      map    );  &#125;  <span class="hljs-keyword">return</span> newOBj;&#125;<span class="hljs-comment">// const info = &#123;</span><span class="hljs-comment">//   name: &quot;why&quot;,</span><span class="hljs-comment">//   age: 18,</span><span class="hljs-comment">//   friend: &#123;</span><span class="hljs-comment">//     name: &quot;kobe&quot;,</span><span class="hljs-comment">//     address: &#123;</span><span class="hljs-comment">//       name: &quot;洛杉矶&quot;,</span><span class="hljs-comment">//       detail: &quot;斯坦普斯中心&quot;,</span><span class="hljs-comment">//     &#125;,</span><span class="hljs-comment">//   &#125;,</span><span class="hljs-comment">//   // self: info</span><span class="hljs-comment">// &#125;;</span><span class="hljs-comment">// info.self = info;</span><span class="hljs-comment">// let newObj = deepClone(info);</span><span class="hljs-comment">// console.log(newObj);</span><span class="hljs-comment">// console.log(newObj.self === newObj);</span><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;cba&quot;</span>, <span class="hljs-string">&quot;nba&quot;</span>]);<span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;s1&quot;</span>);<span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;s2&quot;</span>);<span class="hljs-keyword">const</span> info1 = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,  <span class="hljs-attr">friend</span>: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,    <span class="hljs-attr">address</span>: &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;洛杉矶&quot;</span>,      <span class="hljs-attr">detail</span>: <span class="hljs-string">&quot;斯坦普斯中心&quot;</span>,    &#125;,  &#125;,  <span class="hljs-comment">// 1.特殊类型: Set</span>  <span class="hljs-attr">set</span>: set,  <span class="hljs-comment">// 2.特性类型: function</span>  <span class="hljs-attr">running</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);  &#125;,  <span class="hljs-comment">// 3.值的特殊类型: Symbol</span>  <span class="hljs-attr">symbolKey</span>: <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;abc&quot;</span>),  <span class="hljs-comment">// 4.key是symbol时</span>  [s1]: <span class="hljs-string">&quot;aaaa&quot;</span>,  [s2]: <span class="hljs-string">&quot;bbbb&quot;</span>,&#125;;info1.<span class="hljs-property">self</span> = info1;<span class="hljs-keyword">const</span> newObj1 = <span class="hljs-title function_">deepClone</span>(info1);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj1);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise的实现</title>
    <link href="/2022/09/05/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/05/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve被调用&quot;</span>);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject被调用&quot;</span>);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;padding&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);  <span class="hljs-title function_">reject</span>(<span class="hljs-number">222</span>);&#125;);</code></pre></div><h4 id="then方法的结构设计"><a href="#then方法的结构设计" class="headerlink" title="then方法的结构设计"></a>then方法的结构设计</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilled</span> = onFulfilled;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejected</span> = onRejected;  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;padding&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);  <span class="hljs-title function_">reject</span>(<span class="hljs-number">222</span>);&#125;);<span class="hljs-comment">// 此时不可以进行链式调用，否则会报错</span>promise.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-number">1111</span>;  &#125;,  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;);</code></pre></div><h4 id="then方法的结构设计-优化"><a href="#then方法的结构设计-优化" class="headerlink" title="then方法的结构设计-优化"></a>then方法的结构设计-优化</h4><h5 id="解决then在状态确定之后调用的问题"><a href="#解决then在状态确定之后调用的问题" class="headerlink" title="解决then在状态确定之后调用的问题"></a>解决then在状态确定之后调用的问题</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">//当调用then的时候，状态已经确定</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;      <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;      <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);    &#125;    <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(onFulfilled);      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(onRejected);    &#125;  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;padding&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);  <span class="hljs-title function_">reject</span>(<span class="hljs-number">222</span>);&#125;);<span class="hljs-comment">// 调用then方法多次调用</span>promise.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res);  &#125;,  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;);promise.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res2:&quot;</span>, res);  &#125;,  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err2:&quot;</span>, err);  &#125;);<span class="hljs-comment">// const promise = new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//   resolve(&quot;aaaaa&quot;)</span><span class="hljs-comment">// &#125;)</span><span class="hljs-comment">// 在确定Promise状态之后, 再次调用then</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  promise.<span class="hljs-title function_">then</span>(    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res3:&quot;</span>, res);    &#125;,    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err3:&quot;</span>, err);    &#125;  );&#125;, <span class="hljs-number">1000</span>);</code></pre></div><h4 id="then方法的结构设计-优化二"><a href="#then方法的结构设计-优化二" class="headerlink" title="then方法的结构设计-优化二"></a>then方法的结构设计-优化二</h4><h5 id="解决then方法链式调用"><a href="#解决then方法链式调用" class="headerlink" title="解决then方法链式调用"></a>解决then方法链式调用</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-comment">// try &#123;</span>        <span class="hljs-comment">//   const value = onFulfilled(this.value);</span>        <span class="hljs-comment">//   resolve(value);</span>        <span class="hljs-comment">// &#125; catch (error) &#123;</span>        <span class="hljs-comment">//   reject(error);</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-comment">// try &#123;</span>        <span class="hljs-comment">//   const reason = onRejected(this.reason);</span>        <span class="hljs-comment">//   resolve(reason);</span>        <span class="hljs-comment">// &#125; catch (error) &#123;</span>        <span class="hljs-comment">//   reject(error);</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// try &#123;</span>          <span class="hljs-comment">//   const value = onFulfilled(this.value);</span>          <span class="hljs-comment">//   resolve(value);</span>          <span class="hljs-comment">// &#125; catch (error) &#123;</span>          <span class="hljs-comment">//   reject(error);</span>          <span class="hljs-comment">// &#125;</span>          <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);        &#125;);        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// try &#123;</span>          <span class="hljs-comment">//   const reason = onRejected(this.reason);</span>          <span class="hljs-comment">//   resolve(reason);</span>          <span class="hljs-comment">// &#125; catch (error) &#123;</span>          <span class="hljs-comment">//   reject(error);</span>          <span class="hljs-comment">// &#125;</span>          <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);        &#125;);      &#125;    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;padding&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);  <span class="hljs-title function_">reject</span>(<span class="hljs-number">222</span>);&#125;);<span class="hljs-comment">// 调用then方法多次调用</span>promise  .<span class="hljs-title function_">then</span>(    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res);      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;aaaa&quot;</span>;      <span class="hljs-comment">// throw new Error(&quot;err message&quot;)</span>    &#125;,    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err1:&quot;</span>, err);      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bbbbb&quot;</span>;      <span class="hljs-comment">// throw new Error(&quot;err message&quot;)</span>    &#125;  )  .<span class="hljs-title function_">then</span>(    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res2:&quot;</span>, res);    &#125;,    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err2:&quot;</span>, err);    &#125;  );</code></pre></div><h4 id="catch的设计方法"><a href="#catch的设计方法" class="headerlink" title="catch的设计方法"></a>catch的设计方法</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    onRejected = onRejected || defaultOnRejected;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;状态pending&quot;</span>);  <span class="hljs-comment">// resolve(1111) // resolved/fulfilled</span>  <span class="hljs-title function_">reject</span>(<span class="hljs-number">2222</span>);&#125;);<span class="hljs-comment">// 调用then方法多次调用</span>promise  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;);</code></pre></div><h4 id="finally方法的设计"><a href="#finally方法的设计" class="headerlink" title="finally方法的设计"></a>finally方法的设计</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnFulfilled</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-keyword">return</span> value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onfinally</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;,      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;    );  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;状态pending&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1111</span>); <span class="hljs-comment">// resolved/fulfilled</span>  <span class="hljs-comment">// reject(2222);</span>&#125;);<span class="hljs-comment">// 调用then方法多次调用</span>promise  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;aaaaa&quot;</span>;  &#125;)  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res2:&quot;</span>, res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;)  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;finally&quot;</span>);  &#125;);</code></pre></div><h4 id="promise的类方法resolve-reject"><a href="#promise的类方法resolve-reject" class="headerlink" title="promise的类方法resolve/reject"></a>promise的类方法resolve/reject</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnFulfilled</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-keyword">return</span> value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onfinally</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;,      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;    );  &#125;  <span class="hljs-comment">// 就是将value转成fulfilled状态可以进行then调用</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);    &#125;);  &#125;  <span class="hljs-comment">// 将reason装成rejected状态</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason);    &#125;);  &#125;&#125;myPromise.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Hello World&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);&#125;);myPromise.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error Message&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);&#125;);</code></pre></div><h4 id="promise的类方法all-allSettled"><a href="#promise的类方法all-allSettled" class="headerlink" title="promise的类方法all/allSettled"></a>promise的类方法all/allSettled</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnFulfilled</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-keyword">return</span> value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onfinally</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;,      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;    );  &#125;  <span class="hljs-comment">// 就是将value转成fulfilled状态可以进行then调用</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);    &#125;);  &#125;  <span class="hljs-comment">// 将reason装成rejected状态</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason);    &#125;);  &#125;  <span class="hljs-comment">// all传入一个promise数组，如果promise item状态都是fulfulled，all才是fuldilled状态，否则只要出现了reject就会变成renject</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> values = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(res);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            <span class="hljs-title function_">reject</span>(err);          &#125;        );      &#125;);    &#125;);  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">allSettled</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> values = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(&#123;              <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>,              <span class="hljs-attr">value</span>: res,            &#125;);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>, <span class="hljs-attr">value</span>: err &#125;);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;        );      &#125;);    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1111</span>);  &#125;, <span class="hljs-number">1000</span>);&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2222</span>);  &#125;, <span class="hljs-number">2000</span>);&#125;);<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3333</span>);  &#125;, <span class="hljs-number">3000</span>);&#125;);myPromise  .<span class="hljs-title function_">all</span>([p1, p2, p3])  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);  &#125;);myPromise.<span class="hljs-title function_">allSettled</span>([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);&#125;);</code></pre></div><h4 id="promise类方法-any-race"><a href="#promise类方法-any-race" class="headerlink" title="promise类方法-any/race"></a>promise类方法-any/race</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnFulfilled</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-keyword">return</span> value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onfinally</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;,      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;    );  &#125;  <span class="hljs-comment">// 就是将value转成fulfilled状态可以进行then调用</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);    &#125;);  &#125;  <span class="hljs-comment">// 将reason装成rejected状态</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason);    &#125;);  &#125;  <span class="hljs-comment">// all传入一个promise数组，如果promise item状态都是fulfulled，all才是fuldilled状态，否则只要出现了reject就会变成renject</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> values = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(res);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            <span class="hljs-title function_">reject</span>(err);          &#125;        );      &#125;);    &#125;);  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">allSettled</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> values = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(&#123;              <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>,              <span class="hljs-attr">value</span>: res,            &#125;);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>, <span class="hljs-attr">value</span>: err &#125;);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;        );      &#125;);    &#125;);  &#125;  <span class="hljs-comment">// 相当于是竞赛，谁的状态先改变就用谁的</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promsies</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      promsies.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(resolve, reject);      &#125;);    &#125;);  &#125;  <span class="hljs-comment">//有一个状态时fulfilled状态就是执行resolve,等所有都变成rejected状态才会是reject  和all相反</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">any</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> reasons = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            <span class="hljs-title function_">resolve</span>(res);          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            reasons.<span class="hljs-title function_">push</span>(err);            <span class="hljs-keyword">if</span> (reasons.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(reasons));            &#125;          &#125;        );      &#125;);    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(<span class="hljs-number">1111</span>);  &#125;, <span class="hljs-number">3000</span>);&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2222</span>);  &#125;, <span class="hljs-number">2000</span>);&#125;);<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(<span class="hljs-number">3333</span>);  &#125;, <span class="hljs-number">3000</span>);&#125;);myPromise  .<span class="hljs-title function_">race</span>([p1, p2, p3])  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;);myPromise  .<span class="hljs-title function_">any</span>([p1, p2, p3])  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err.<span class="hljs-property">errors</span>);  &#125;);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>搜集</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现bind</title>
    <link href="/2022/09/05/%E5%AE%9E%E7%8E%B0bind/"/>
    <url>/2022/09/05/%E5%AE%9E%E7%8E%B0bind/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mybind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, ...args</span>) &#123;  <span class="hljs-comment">// 获得this的指向，就是实际的调用者</span>  <span class="hljs-keyword">let</span> fn = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 获取thisArg,如果是基本数据类型除了null,undefined都转成包装类型，否则指向全局</span>  thisArg = thisArg != <span class="hljs-literal">null</span> ? <span class="hljs-title class_">Object</span>(thisArg) : globalThis;  <span class="hljs-comment">// bind会返回一个新的函数</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">newFn</span>(<span class="hljs-params">...argArr</span>) &#123;    <span class="hljs-comment">// 向thisArg对象添加这个方法</span>    thisArg.<span class="hljs-property">fn</span> = fn;    <span class="hljs-comment">// 合并参数</span>    <span class="hljs-keyword">const</span> argTotals = [...args, ...argArr];    <span class="hljs-comment">// 执行函数</span>    <span class="hljs-keyword">const</span> result = thisArg.<span class="hljs-title function_">fn</span>(...argTotals);    <span class="hljs-comment">// 执行完成后删除方法</span>    <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span>;    <span class="hljs-keyword">return</span> result;  &#125;;&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo被执行&quot;</span>, <span class="hljs-variable language_">this</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2, num3, num4</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, num2, num3, num4);&#125;<span class="hljs-comment">// 系统的bind使用</span><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-title function_">bar</span>();<span class="hljs-keyword">var</span> newSum = sum.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>);<span class="hljs-title function_">newSum</span>();<span class="hljs-comment">// 使用自己定义的bind</span><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">mybind</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">bar</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<span class="hljs-keyword">var</span> newSum = sum.<span class="hljs-title function_">mybind</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">newSum</span>(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>);</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-React全家桶</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-React%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-React%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h1><h2 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React"></a>什么是React</h2><p>React是Facebook在2013年开源的JavaScript框架。</p><p>官⽅对它的解释是：⽤于构建⽤户界⾯的 JavaScript 库。</p><p>现今React和Vue是国内最为流⾏的两个框架，都是帮助我们来构建⽤户界⾯的JavaScript库</p><h2 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h2><p><strong>React的特点：</strong></p><p>声明式编程：</p><p>声明式编程是⽬前整个⼤前端开发的模式：Vue、React、Flutter、SwiftUI；</p><p>它允许我们只需要维护⾃⼰的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界⾯；</p><p>组件化开发：</p><p>组件化开发⻚⾯⽬前前端的流⾏趋势，我们会讲复杂的界⾯拆分成⼀个个⼩的组件；</p><p>如何合理的进⾏组件的划分和设计也是后⾯我会讲到的⼀个重点；</p><p>多平台适配：</p><p>2013年，React发布之初主要是开发Web⻚⾯；</p><p>2015年，Facebook推出了ReactNative，⽤于开发移动端跨平台；（虽然⽬前Flutter⾮常⽕爆，但是还是有很多公司在使⽤ReactNative）；</p><p>2017年，Facebook推出ReactVR，⽤于开发虚拟现实Web应⽤程序；（随着5G的普及，VR也会是⼀个⽕爆的应⽤场景）；</p><p><strong>React的优势</strong></p><p>React由Facebook来更新和维护，它是⼤量优秀程序员的思想结晶：</p><p>React的流⾏不仅仅局限于普通开发⼯程师对它的认可，⼤量流⾏的其他框架借鉴React的思想；</p><p>Vue.js框架设计之初，有很多的灵感来⾃Angular和React。</p><p>包括Vue3很多新的特性，也是借鉴和学习了React⽐如React Hooks是开创性的新功能（也是我们课程的重点）</p><p>Vue Function Based API学习了React Hooks的思想</p><p>Flutter的很多灵感都来⾃React，Flutter中的Widget – Element – RenderObject，对应的就是JSX – 虚 拟DOM – 真实DOM。</p><p>所以，可以说React是前端的先驱者，它会引领整个前端的潮流</p><h2 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX"></a>什么是JSX</h2><p>JSX是⼀种JavaScript的语法扩展（eXtension），也在很多地⽅称之为JavaScript XML，因为看起就是⼀段XML语法；</p><p>它⽤于描述我们的UI界⾯，并且其完全可以和JavaScript融合在⼀起使⽤；</p><p>它不同于Vue中的模块语法，你不需要专⻔学习模块语法中的⼀些指令（⽐如v-for、v-if、v-else、v-bind）</p><h2 id="JSX转换的本质是什么"><a href="#JSX转换的本质是什么" class="headerlink" title="JSX转换的本质是什么"></a>JSX转换的本质是什么</h2><p>实际上，jsx 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。</p><p>所有的jsx最终都会被转换成 React.createElement 的函数调⽤</p><h2 id="为什么React选择了JSX"><a href="#为什么React选择了JSX" class="headerlink" title="为什么React选择了JSX"></a>为什么React选择了JSX</h2><p>React认为渲染逻辑本质上与其他UI逻辑存在内在耦合</p><p>​    ⽐如UI需要绑定事件（button、a原⽣等等）；</p><p>​    ⽐如UI中需要展示数据状态，在某些状态发⽣改变时，⼜需要改变UI；</p><p>他们之间是密不可分，所以React没有将标记分离到不同的⽂件中，⽽是将它们组合到了⼀起，这个地⽅就是组件（Component）</p><h2 id="React为什么采⽤虚拟DOM"><a href="#React为什么采⽤虚拟DOM" class="headerlink" title="React为什么采⽤虚拟DOM"></a>React为什么采⽤虚拟DOM</h2><p>为什么要采⽤虚拟DOM，⽽不是直接修改真实的DOM呢</p><ul><li>很难跟踪状态发⽣的改变：原有的开发模式，我们很难跟踪到状态发⽣的改变，不⽅便针对我们应⽤程序进⾏调试；</li><li>操作真实DOM性能较低：传统的开发模式会进⾏频繁的DOM操作，⽽这⼀的做法性能⾮常的低；</li><li>虚拟DOM帮助我们从命令式编程转到了声明式编程的模式。</li><li>虚拟DOM有利于实现跨平台的能⼒，即⼀套代码可以打包出各个平台的应⽤</li></ul><h2 id="React事件函数绑定this有⼏种⽅式"><a href="#React事件函数绑定this有⼏种⽅式" class="headerlink" title="React事件函数绑定this有⼏种⽅式"></a>React事件函数绑定this有⼏种⽅式</h2><p><strong>⽅案⼀：bind给btnClick显示绑定this</strong></p><p>在传⼊函数时，我们可以主动绑定this：</p><div class="code-wrapper"><pre><code class="hljs jsx">&lt;button onClick=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">btnClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)&#125;&gt;点我⼀下(<span class="hljs-title class_">React</span>)&lt;/button&gt;</code></pre></div><p><strong>⽅案⼆：使⽤</strong> <strong>ES6 class fifields</strong> <strong>语法</strong></p><p>你会发现我这⾥将btnClick的定义变成了⼀种赋值语句</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<span class="hljs-variable language_">super</span>(props);<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊,李银河&quot;</span> &#125; &#125;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick&#125;</span>&gt;</span>点我⼀下(React)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick&#125;</span>&gt;</span>也点我⼀下(React)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;btnClick = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>); &#125;&#125;</code></pre></div><p><strong>⽅案三：事件监听时传⼊箭头函数（推荐）</strong></p><p>因为 onClick 中要求我们传⼊⼀个函数，那么我们可以直接定义⼀个箭头函数传⼊</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<span class="hljs-variable language_">super</span>(props);<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊,李银河&quot;</span> &#125; &#125;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.btnClick()&#125;&gt;点我⼀下(React)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.btnClick()&#125;&gt;也点我⼀下(React)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;<span class="hljs-title function_">btnClick</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>);   &#125;&#125;</code></pre></div><h2 id="说说事件的参数如何传递"><a href="#说说事件的参数如何传递" class="headerlink" title="说说事件的参数如何传递"></a><strong>说说事件的参数如何传递</strong></h2><p>在执⾏事件函数时，有可能我们需要获取⼀些参数信息：⽐如event对象、其他参数</p><p><strong>情况⼀：获取event对象。</strong></p><p>很多时候我们需要拿到event对象来做⼀些事情（⽐如阻⽌默认⾏为）假如我们⽤不到this，那么直接传⼊函数就可以获取到event对象</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick&#125;</span>&gt;</span>点我⼀下<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;<span class="hljs-title function_">btnClick</span>(<span class="hljs-params">e</span>) &#123;e.<span class="hljs-title function_">preventDefault</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); &#125;&#125;</code></pre></div><p><strong>情况⼆：获取更多参数。</strong> 有更多参数时，我们最好的⽅式就是传⼊⼀个箭头函数，主动执⾏的事件函数，并且传⼊相关的其他参数；</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<span class="hljs-variable language_">super</span>(props);<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">names</span>: [<span class="hljs-string">&quot;⾐服&quot;</span>, <span class="hljs-string">&quot;鞋⼦&quot;</span>, <span class="hljs-string">&quot;裤⼦&quot;</span>] &#125; &#125;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.aClick&#125;</span>&gt;</span>点我⼀下<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml"> &#123;this.state.names.map((item, index) =&gt; &#123;</span><span class="language-xml">return (</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.aClick(e, item, index)&#125;&gt;&#123;item&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml"> )</span><span class="language-xml"> &#125;)</span><span class="language-xml"> &#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;<span class="hljs-title function_">aClick</span>(<span class="hljs-params">e, item, index</span>) &#123;e.<span class="hljs-title function_">preventDefault</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, index);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); &#125;&#125;</code></pre></div><h2 id="React的事件和普通的HTML事件有什么不同"><a href="#React的事件和普通的HTML事件有什么不同" class="headerlink" title="React的事件和普通的HTML事件有什么不同"></a>React的事件和普通的HTML事件有什么不同</h2><p>区别：</p><ol><li>​    对于事件名称命名⽅式，原⽣事件为全⼩写，react 事件采⽤⼩驼峰；</li><li>​    对于事件函数处理语法，原⽣事件为字符串，react 事件为函数；</li><li>​    react 事件不能采⽤ return false 的⽅式来阻⽌浏览器的默认⾏为，⽽必须要地明确地调⽤ preventDefault() 来阻⽌默认⾏为。</li></ol><p>合成事件是 react 模拟原⽣ DOM 事件所有能⼒的⼀个事件对象，其优点如下：</p><ol><li>​    兼容所有浏览器，更好的跨平台；</li><li>​    将事件统⼀存放在⼀个数组，避免频繁的新增与删除（垃圾回收）。</li><li>​    ⽅便 react 统⼀管理和事务机制。</li></ol><p>​    事件的执⾏顺序为原⽣事件先执⾏，合成事件后执⾏，合成事件会冒泡绑定到 document 上，所以尽量避免原⽣事件与合成事件混         ⽤，如果原⽣事件阻⽌冒泡，可能会导致合成事件不执⾏，因为需要冒泡到document 上合成事件才会执⾏。</p><h2 id="什么是⾼级函数？什么是⾼阶HOC组件"><a href="#什么是⾼级函数？什么是⾼阶HOC组件" class="headerlink" title="什么是⾼级函数？什么是⾼阶HOC组件"></a>什么是⾼级函数？什么是⾼阶HOC组件</h2><p>⾼阶函数的维基百科定义：⾄少满⾜以下条件之⼀：</p><p>​    接受⼀个或多个函数作为输⼊；</p><p>​    输出⼀个函数；</p><p>JavaScript中⽐较常⻅的fifilter、map、reduce都是⾼阶函数</p><p>那么说明是⾼阶组件呢？</p><p>​    ⾼阶组件的英⽂是 <strong>Higher-Order Components</strong>，简称为 HOC ；</p><p>​    官⽅的定义：<strong>⾼阶组件是参数为组件，返回值为新组件的函数</strong>；</p><p>我们可以进⾏如下的解析：</p><p>​    ⾸先， ⾼阶组件 本身不是⼀个组件，⽽是⼀个函数；</p><p>​    其次，这个函数的参数是⼀个组件，返回值也是⼀个组件</p><p>⾼阶组件的调⽤过程类似于这样:</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">higherOrderComponent</span>(<span class="hljs-title class_">WrappedComponent</span>);</code></pre></div><p>⾼阶函数的编写过程类似于这样:</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">higherOrderComponent</span>(<span class="hljs-params">WrapperComponent</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrapperComponent</span>/&gt;</span></span> &#125; &#125;&#125;</code></pre></div><p>⾼阶组件并不是React API的⼀部分，它是基于React的组合特性⽽形成的设计模式；</p><p>⾼阶组件在⼀些React第三⽅库中⾮常常⻅：</p><p>​    ⽐如redux中的connect；</p><p>​    ⽐如react-router中的withRouter；</p><h2 id="说说⾼阶组件的应⽤场景"><a href="#说说⾼阶组件的应⽤场景" class="headerlink" title="说说⾼阶组件的应⽤场景"></a>说说⾼阶组件的应⽤场景</h2><p><strong>props的增强，不修改原有代码的情况下，添加新的props</strong></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> &#123; name, age &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Header &#123;name + age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span> &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aaa&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&#123;18&#125;</span> /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;&#125;</code></pre></div><p>可以通过⼀个⾼阶组件，让使⽤者在不破坏原有结构的情况下对某个组件增强props</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">enhanceProps</span>(<span class="hljs-params">WrapperCpn, otherProps</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrapperCpn</span> &#123;<span class="hljs-attr">...props</span>&#125; &#123;<span class="hljs-attr">...otherProps</span>&#125; /&gt;</span></span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhanceHeader</span> = <span class="hljs-title function_">enhanceProps</span>(<span class="hljs-title class_">Header</span>, &#123;<span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>&#125;)</code></pre></div><p>利⽤⾼阶组件来共享Context</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span>, createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title function_">createContext</span>(&#123; <span class="hljs-attr">nickname</span>: <span class="hljs-string">&quot;默认&quot;</span>, <span class="hljs-attr">level</span>: -<span class="hljs-number">1</span>&#125;)<span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params">props</span>) &#123; <span class="hljs-keyword">return</span> ( <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><span class="language-xml"> &#123;</span><span class="language-xml"> value =&gt; &#123;</span><span class="language-xml"> const &#123; nickname, level &#125; = value;</span><span class="language-xml"> return <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Header &#123;&quot;昵称:&quot; + nickname + &quot;等级&quot; + level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"> &#125;</span><span class="language-xml"> &#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span> )&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Footer</span>(<span class="hljs-params">props</span>) &#123; <span class="hljs-keyword">return</span> ( <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span><span class="language-xml"> &#123;</span><span class="language-xml"> value =&gt; &#123;</span><span class="language-xml"> const &#123; nickname, level &#125; = value;</span><span class="language-xml"> return <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Footer &#123;&quot;昵称:&quot; + nickname + &quot;等级&quot; + level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"> &#125;</span><span class="language-xml"> &#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Consumer</span>&gt;</span></span> )&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhanceHeader</span> = <span class="hljs-title function_">enhanceProps</span>(<span class="hljs-title class_">Header</span>, &#123; <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span> &#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123; <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> ( <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">nickname:</span> &quot;<span class="hljs-attr">why</span>&quot;, <span class="hljs-attr">level:</span> <span class="hljs-attr">90</span> &#125;&#125;&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;&#125;</code></pre></div><h2 id="React如何创建refs来获取对应的DOM呢"><a href="#React如何创建refs来获取对应的DOM呢" class="headerlink" title="React如何创建refs来获取对应的DOM呢"></a>React如何创建refs来获取对应的DOM呢</h2><p>如何创建refs来获取对应的DOM呢？⽬前有三种⽅式：</p><p>⽅式⼀：传⼊字符串</p><p>​    使⽤时通过 this.refs.传⼊的字符串 格式获取对应的元素；</p><p>⽅式⼆：传⼊⼀个对象</p><p>​    对象是通过 React.createRef() ⽅式创建出来的；</p><p>​    使⽤时获取到创建的对象其中有⼀个 current 属性就是对应的元素；</p><p>⽅式三：传⼊⼀个函数</p><p>​    该函数会在DOM被挂载时进⾏回调，这个函数会传⼊⼀个 元素对象，我们可以⾃⼰保存；</p><p>​    使⽤时，直接拿到之前保存的元素对象即可</p><h2 id="对-React-context-的理解"><a href="#对-React-context-的理解" class="headerlink" title="对 React context 的理解"></a>对 React context 的理解</h2><p>在React中，数据传递⼀般使⽤props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适⽤。单纯⼀对的⽗⼦组件传递并⽆问题，但要是组件之    间层层依赖深⼊，props就需要层层传递显然，这样做太繁琐了。</p><p>Context 提供了⼀种在组件之间共享此类值的⽅式，⽽不必显式地通过组件树的逐层传递 props。</p><p>可以把context当做是特定⼀个组件树内共享的store，⽤来做数据传递。简单说就是，当你不想在组件树中通过逐层传递props或者state的⽅式来传递数据时，可以使⽤Context来实现跨层级的组件数据传递。</p><p>JS的代码块在执⾏期间，会创建⼀个相应的作⽤域链，这个作⽤域链记录着运⾏时JS代码块执⾏期间所能访问的活动对象，包括变量和函数，JS程序通过作⽤域链访问到代码块内部或者外部的变量和函数</p><p>假如以JS的作⽤域链作为类⽐，React组件提供的Context对象其实就好⽐⼀个提供给⼦组件访问的作⽤域，⽽ Context对象的属性可以看成作⽤域上的活动对象。由于组件 的 Context 由其⽗节点链上所有组件通 过 getChildContext（）返回的Context对象组合⽽成，所以，组件通过Context是可以访问到其⽗组件链上所有节点组件提供的Context的属性</p><h2 id="类组件与函数组件有什么异同？"><a href="#类组件与函数组件有什么异同？" class="headerlink" title="类组件与函数组件有什么异同？"></a>类组件与函数组件有什么异同？</h2><p><strong>相同点：</strong> 组件是 React 可复⽤的最⼩代码⽚段，它们会返回要在⻚⾯中渲染的 React 元素。也正因为组件是 React 的最⼩编码单位，所以⽆论是函数组件还是类组件，在使⽤⽅式和最终呈现效果上都是完全⼀致的。</p><p>我们甚⾄可以将⼀个类组件改写成函数组件，或者把函数组件改写成⼀个类组件（虽然并不推荐这种重构⾏为）。从使⽤者的⻆度⽽⾔，很难从使⽤体验上区分两者，⽽且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全⼀致的。</p><p><strong>不同点：</strong></p><ul><li>它们在开发时的⼼智模型上却存在巨⼤的差异。类组件是基于⾯向对象编程的，它主打的是继承、⽣命周期等核⼼概念；⽽函数组件内核是函数式编程，主打的是 immutable、没有副作⽤、引⽤透明等特点。</li><li>之前，在使⽤场景上，如果存在需要使⽤⽣命周期的组件，那么主推类组件；设计模式上，如果需要使⽤继承，那么主推类组件。但现在由于 React Hooks 的推出，⽣命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官⽅更推崇“组合优于继承”的设计概念，所以类组件在这⽅⾯的优势也在淡出。</li><li>性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，⽽函数组件依靠React.memo 缓存渲染结果来提升性能。</li><li>从上⼿程度⽽⾔，类组件更容易上⼿，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的⽅案。</li><li>类组件在未来时间切⽚与并发模式中，由于⽣命周期带来的复杂度，并不易于优化。⽽函数组件本身轻量简单，且在 Hooks 的基础上提供了⽐原先更细粒度的逻辑组织与复⽤，更能适应 React 的未来发展。</li></ul><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h2><ol><li>Redux 是 JavaScript应⽤程序的可预测状态容器。</li><li>它可以帮助您编写⾏为⼀致、在不同环境（客户端、服务器和本机）中运⾏并且易于测试的应⽤程序。最重要的是，它提供了出⾊的开发⼈员体验，例如实时代码编辑与时间旅⾏调试器相结合。</li><li>可以将 Redux 与React或任何其他视图库⼀起使⽤。它很⼩（2kB，包括依赖项），但有⼀个庞⼤的插件⽣态系统可⽤</li></ol><h2 id="为什么需要redux"><a href="#为什么需要redux" class="headerlink" title="为什么需要redux"></a>为什么需要redux</h2><p>JavaScript开发的应⽤程序，已经变得越来越复杂了：</p><p>JavaScript需要管理的状态越来越多，越来越复杂；这些状态包括服务器返回的数据、缓存数据、⽤户操作产⽣的数据等等，也包括⼀些UI的状态，⽐如某些元素是否被选中，是否显示加载动效，当前分⻚；</p><p>管理不断变化的state是⾮常困难的：</p><p>状态之间相互会存在依赖，⼀个状态的变化会引起另⼀个状态的变化，View⻚⾯也有可能会引起状态的变化；</p><p>当应⽤程序复杂时，state在什么时候，因为什么原因⽽发⽣了变化，发⽣了怎么样的变化，会变得⾮常难以控制和追踪；</p><p>React是在视图层帮助我们解决了DOM的渲染过程，但是State依然是留给我们⾃⼰来管理：</p><p>⽆论是组件定义⾃⼰的state，还是组件之间的通信通过props进⾏传递；也包括通过Context进⾏数据之间的共享；</p><p>React主要负责帮助我们管理视图，state如何维护最终还是我们⾃⼰来决定</p><p>Redux就是⼀个帮助我们管理State的容器，提供了可预测的状态管理。</p><p>Redux除了和React⼀起使⽤之外，它也可以和其他界⾯库⼀起来使⽤（⽐如Vue），并且它⾮常⼩（包括依赖在内，只有2kb）</p><h2 id="redux的三⼤原则是什么"><a href="#redux的三⼤原则是什么" class="headerlink" title="redux的三⼤原则是什么"></a>redux的三⼤原则是什么</h2><p><strong>单⼀数据源</strong></p><p>整个应⽤程序的state被存储在⼀颗object tree中，并且这个object tree只存储在⼀个 store 中：</p><ul><li>Redux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护；</li><li>单⼀的数据源可以让整个应⽤程序的state变得⽅便维护、追踪、修改；</li></ul><p><strong>State是只读的</strong></p><p>唯⼀修改State的⽅法⼀定是触发action，不要试图在其他地⽅通过任何的⽅式来修改State：</p><ul><li>这样就确保了View或⽹络请求都不能直接修改state，它们只能通过action来描述⾃⼰想要如何修改state；</li><li>这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执⾏，所以不需要担⼼racecondition（竟态）的问题；</li></ul><p><strong>使⽤纯函数来执⾏修改</strong></p><p>通过reducer将 旧state 和 actions 联系在⼀起，并且返回⼀个新的State：</p><ul><li>随着应⽤程序的复杂度增加，我们可以将reducer拆分成多个⼩的reducers，分别操作不同state tree的⼀部分；</li><li>但是所有的reducer都应该是纯函数，不能产⽣任何的副作⽤；</li></ul><h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h1><h2 id="什么是React-Router"><a href="#什么是React-Router" class="headerlink" title="什么是React Router"></a>什么是React Router</h2><p>React Router是⼀个强⼤的路由库，建⽴在React的基础上，可以帮助向应⽤程序添加新的屏幕和流程。</p><p>这样可以使URL与⽹⻚上显示的数据保持同步。</p><p>它保持标准化的结构和⾏为，并⽤于开发单⻚Web应⽤程序。React Router有⼀个简单的API</p><h2 id="⻚⾯传递参数有⼏种⽅式"><a href="#⻚⾯传递参数有⼏种⽅式" class="headerlink" title="⻚⾯传递参数有⼏种⽅式"></a>⻚⾯传递参数有⼏种⽅式</h2><p>传递参数有三种⽅式：</p><ul><li>动态路由的⽅式；</li><li>search传递参数；</li><li>to传⼊对象；</li></ul><p>动态路由的⽅式</p><p>动态路由的概念指的是路由中的路径并不会固定：</p><ul><li>⽐如 /detail 的path对应⼀个组件Detail；</li><li>如果我们将path在Route匹配时写成 /detail/:id ，那么 /detail/abc 、 /detail/123 都可以匹配到该Route，并且进⾏显示；</li><li>这个匹配规则，我们就称之为动态路由；</li></ul><p>通常情况下，使⽤动态路由可以为路由传递参数。</p><div class="code-wrapper"><pre><code class="hljs jsx">&lt;div&gt; ...其他<span class="hljs-title class_">Link</span> &lt;<span class="hljs-title class_">NavLink</span> to=<span class="hljs-string">&quot;/detail/abc123&quot;</span>&gt;详情&lt;/<span class="hljs-title class_">NavLink</span>&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><span class="language-xml"> ... 其他Route</span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail/:id&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Detail&#125;/</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;NoMatch&#125;</span> /&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span>&lt;/div&gt;</code></pre></div><p>detail.js的代码如下：</p><p>我们可以直接通过match对象中获取id；</p><p>这⾥我们没有使⽤withRouter，原因是因为Detail本身就是通过路由进⾏的跳转；</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123; <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">match</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>); <span class="hljs-keyword">return</span> ( <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Detail: &#123;this.props.match.params.id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;&#125;</code></pre></div><p><strong>search传递参数</strong></p><p>NavLink写法：</p><p>我们在跳转的路径中添加了⼀些query参数；</p><div class="code-wrapper"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">NavLink</span> to=<span class="hljs-string">&quot;/detail2?name=why&amp;age=18&quot;</span>&gt;详情<span class="hljs-number">2</span>&lt;/<span class="hljs-title class_">NavLink</span>&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail2&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Detail2&#125;/</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span></code></pre></div><p>Detail2中如何获取呢？</p><p>Detail2中是需要在location中获取search的；</p><p>注意：这个search没有被解析，需要我们⾃⼰来解析；</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Detail2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123; <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>); <span class="hljs-comment">// ?name=why&amp;age=18</span> <span class="hljs-keyword">return</span> ( <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Detail2:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;&#125;</code></pre></div><p>to传⼊对象</p><p>to可以直接传⼊⼀个对象</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">NavLink</span> to=&#123;&#123; <span class="hljs-attr">pathname</span>: <span class="hljs-string">&quot;/detail2&quot;</span>,  <span class="hljs-attr">query</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>&#125;, <span class="hljs-attr">state</span>: &#123;<span class="hljs-attr">height</span>: <span class="hljs-number">1.98</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;洛杉矶&quot;</span>&#125;, <span class="hljs-attr">search</span>: <span class="hljs-string">&quot;?apikey=123&quot;</span> &#125;&#125;&gt; 详情<span class="hljs-number">2</span>&lt;/<span class="hljs-title class_">NavLink</span>&gt;</code></pre></div><p>获取参数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Detail2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123; <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">location</span>); <span class="hljs-keyword">return</span> ( <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Detail2:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> ) &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试,react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-小程序云开发</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/08-小程序云开发实战.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-小程序开发</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="说说你对⼩程序双线程模型架构的理解"><a href="#说说你对⼩程序双线程模型架构的理解" class="headerlink" title="说说你对⼩程序双线程模型架构的理解?"></a>说说你对⼩程序双线程模型架构的理解?</h1><p>⼩程序的宿主环境是：微信客户端</p><p>​    宿主环境可以执⾏⼩程序的各种⽂件</p><p>当⼩程序运⾏在 WebView 环境下时，会有什么问题呢？</p><p>​    JS 逻辑、DOM 树创建、CSS 解析、样式计算、Layout、Paint (Composite) 都发⽣在同⼀线程中</p><p>​    在 WebView 上执⾏过多的 JS 逻辑可能阻塞渲染，导致界⾯卡顿</p><p>⼩程序考虑到性能与安全的问题，采⽤了「双线程模型」的架构</p><p>​    WXML模块和WXSS样式运⾏于 渲染层，渲染层使⽤WebView线程渲染</p><p>​        当⼀个程序有多个⻚⾯时，会使⽤多个WebView的线程</p><p>​    JS脚本（app.js/home.js等）运⾏于 逻辑层，逻辑层使⽤ JsCore 运⾏ JS脚本</p><p>​        这两个线程都会经由微信客户端（Native）进⾏中转并交互</p><h1 id="什么是rpx？如何使⽤rpx进⾏屏幕适配？"><a href="#什么是rpx？如何使⽤rpx进⾏屏幕适配？" class="headerlink" title="什么是rpx？如何使⽤rpx进⾏屏幕适配？"></a>什么是rpx？如何使⽤rpx进⾏屏幕适配？</h1><p>什么是rpx：</p><p>​    rpx的全称是 responsive pixel ，可以根据屏幕宽度进⾏⾃适应。</p><p>使⽤rpx进⾏的屏幕适配：</p><p>开发微信⼩程序时设计师可以⽤ iPhone6 作为视觉稿的标准，规定屏幕宽为750rpx。 </p><ul><li>在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素。</li><li>即 1rpx = 0.5px = 1物理像素。</li><li>因此如果想定义⼀个100px宽度的view 则需要设置width为 200rp</li></ul><h1 id="wx-if和hidden属性有什么区别？开发中如何选择？"><a href="#wx-if和hidden属性有什么区别？开发中如何选择？" class="headerlink" title="wx:if和hidden属性有什么区别？开发中如何选择？"></a>wx:if和hidden属性有什么区别？开发中如何选择？</h1><p>wx:if和hidden的区别 :</p><p>wx:if 需要根据条件判断组件是否渲染，条件为true，对应的组件才会渲染出来；条件为false时，对应组件不仅不会渲染，也不会出现在虚拟DOM中。</p><p>hidden属性本质是通过添加hidden这个属性来控制组件的隐藏或显示，即使条件为true，对应组件也会渲染，只不过不会显示在⻚⾯中。</p><p>开发中选择:</p><p>如果操作很频繁 则使⽤hidden</p><p>如果不频繁 则使⽤ wx:if</p><h1 id="wx-for为什么需要绑定key？绑定key的⽅式有哪些？"><a href="#wx-for为什么需要绑定key？绑定key的⽅式有哪些？" class="headerlink" title="wx:for为什么需要绑定key？绑定key的⽅式有哪些？"></a>wx:for为什么需要绑定key？绑定key的⽅式有哪些？</h1><p>为什么要绑定key:</p><p>当我们希望处理同⼀层的VNode 进⾏插⼊、删除、新增节点时，可以更好的进⾏节点的复⽤，就需要key属性来判断。</p><p>绑定key的⽅式有哪些:</p><p>字符串: 表示 for循环array中item的某个属性(property) 该property是列表中的唯⼀的字符串或数字</p><p>保留关键字 *this 表示item本身 此时item本身是唯⼀的字符串或数字</p><h1 id="WXS的作⽤是什么？如何使⽤？"><a href="#WXS的作⽤是什么？如何使⽤？" class="headerlink" title="WXS的作⽤是什么？如何使⽤？"></a>WXS的作⽤是什么？如何使⽤？</h1><p>WXS作⽤:</p><p>⼩程序的⼀套脚本语⾔与 JavaScript 是不同的语⾔，有⾃⼰的语法，并不和 JavaScript ⼀致。</p><p>为了在wxml中调⽤函数来处理对应的数据</p><p>如何使⽤:</p><p>⽅式⼀：写在 wxs标签中</p><p>⽅式⼆：写在 .wxs结尾的⽂件中 以cjs的⽅式导出，以cjs的⽅式在wxml⽂件中引⼊使⽤</p><h1 id="⼩程序中的事件如何传递参数？"><a href="#⼩程序中的事件如何传递参数？" class="headerlink" title="⼩程序中的事件如何传递参数？"></a>⼩程序中的事件如何传递参数？</h1><p>⼩程序中事件常⽤传递参数的⽅式是通过 data- 属性来实现。</p><p>可以在逻辑代码中通过 el.currentTarget.dataset.属性名称 获取</p><h1 id="target和currentTarget的区别？"><a href="#target和currentTarget的区别？" class="headerlink" title="target和currentTarget的区别？"></a>target和currentTarget的区别？</h1><p>target：指触发事件的元素</p><p>currentTarget：指的是处理事件的元素，两者作⽤在同⼀个元素上⽆差别。</p><p>⼩程序中常⽤currentTarget</p><h1 id="⻚⾯和组件之间如何进⾏数据传递？"><a href="#⻚⾯和组件之间如何进⾏数据传递？" class="headerlink" title="⻚⾯和组件之间如何进⾏数据传递？"></a>⻚⾯和组件之间如何进⾏数据传递？</h1><p>⻚⾯传递给组件：</p><p>向组件传递数据可以通过 properties 属性，⽀持String、Number、Boolean、Object、Array、null等类型</p><p>向组件传递样式可以通过定义externalClasses属性来实现</p><p>组件传递给⻚⾯：</p><p>组件向外传递事件可以在组件内部通过this.triggerEvent将事件派发，⻚⾯可以通过bind绑定</p><h1 id="⼩程序中组件的插槽如何使⽤？如何给插槽传递默认值？"><a href="#⼩程序中组件的插槽如何使⽤？如何给插槽传递默认值？" class="headerlink" title="⼩程序中组件的插槽如何使⽤？如何给插槽传递默认值？"></a>⼩程序中组件的插槽如何使⽤？如何给插槽传递默认值？</h1><p><strong>⼩程序中使⽤插槽</strong> <strong>:</strong></p><p>在组件中想要使⽤插槽的地⽅通过 预留位置（也⽀持具名插槽）。</p><p>在组件外部可以在预留插槽中插⼊⽂字、图⽚或者是进度条</p><p><strong>给插槽传递默认值</strong> <strong>:</strong></p><p>⼩程序中不⽀持给插槽设置默认值，如果⾮要设置，可以通过兄弟选择器来实现 :</p><p>给需要传递的默认值元素上添加⼀个类，设置 display : none，默认不显示</p><p>之后在有预留插槽位置的元素设置伪类 :empty ，当⾥⾯没有内容时，再通过兄弟选择器找到默认值元素上的类，将display改为block。</p><h1 id="⻚⾯跳转过程中如何进⾏数据传递？"><a href="#⻚⾯跳转过程中如何进⾏数据传递？" class="headerlink" title="⻚⾯跳转过程中如何进⾏数据传递？"></a>⻚⾯跳转过程中如何进⾏数据传递？</h1><p><strong>⼩程序中实现⻚⾯跳转有两种⽅式</strong> <strong>:</strong></p><p>⽅式⼀ ：通过navigator组件，有利于SEO的优化。</p><p>⽅式⼆ : 通过wx的API进⾏⻚⾯跳转</p><p>wx.navigateTo() ：保留当前⻚⾯，跳转到应⽤内的某个⻚⾯</p><p>wx.navigateBack() ：关闭当前⻚⾯，返回上⼀⻚⾯或者多级⻚⾯</p><p><strong>⻚⾯跳转数据的传递</strong> <strong>:</strong></p><p>⽐如⾸⻚传递数据⾄详情⻚ (使⽤URL中的query字段)</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">url</span> : <span class="hljs-string">&quot;/pages/classify/index?name=wzl&amp;age=22&quot;</span></code></pre></div><p>⽐如详情⻚传递数据⾄⾸⻚(在详情⻚内部拿到⾸⻚实例，并修改数据) ：</p><div class="code-wrapper"><pre><code class="hljs awk">const pages = getCurrentPages() <span class="hljs-regexp">//</span>获取实例⽅法const prevPage = pages[pages.length - <span class="hljs-number">2</span>] <span class="hljs-regexp">//</span>具体实例prevPage.setData(&#123;info: <span class="hljs-string">&quot;my name is wzl&quot;</span>&#125;) <span class="hljs-regexp">//</span>修改数据</code></pre></div><h1 id="说说⼩程序的登录流程？"><a href="#说说⼩程序的登录流程？" class="headerlink" title="说说⼩程序的登录流程？"></a>说说⼩程序的登录流程？</h1><ol><li>通过wx.login()获取code。</li><li>将这个code发送给后端，后端会返回⼀个token，这个token将作为你身份的唯⼀标识。</li><li>将token通过wx.setStorageSync()保存在本地存储。</li><li>⽤户下次进⼊⻚⾯时，会先通过wx.getStorageSync() ⽅法判断token是否有值，如果有值，则可以请求其它数据，如果没有值，则进⾏登录操作。</li></ol><h1 id="⼩程序-WXSS-与CSS的区别？"><a href="#⼩程序-WXSS-与CSS的区别？" class="headerlink" title="⼩程序 WXSS 与CSS的区别？"></a>⼩程序 WXSS 与CSS的区别？</h1><p>WXSS (WeiXin Style Sheets)是⼀套样式语⾔，⽤于描述 WXML 的组件样式。</p><p>WXSS ⽤来决定 WXML 的组件应该怎么显示。</p><p>为了适应⼴⼤的前端开发者，WXSS 具有 CSS ⼤部分特性。同时为了更适合开发微信⼩程序，WXSS 对</p><p>CSS 进⾏了扩充以及修改。</p><p>与 CSS 相⽐，<strong>WXSS</strong> 扩展的特性有：</p><ul><li>尺⼨单位 rpx（responsive pixel）</li><li>样式导⼊， @import 语句</li></ul><h1 id="⼩程序⻚⾯的⽣命周期函数？"><a href="#⼩程序⻚⾯的⽣命周期函数？" class="headerlink" title="⼩程序⻚⾯的⽣命周期函数？"></a>⼩程序⻚⾯的⽣命周期函数？</h1><p>onLoad : ⻚⾯加载时触发。⼀个⻚⾯只会调⽤⼀次，可以在 onLoad 的参数中获取打开当前⻚⾯路径中的参数 onShow : ⻚⾯显示 / 切⼊前台时触发调⽤。 onReady : ⻚⾯初次渲染完成时触发,⼀个⻚⾯只会调⽤⼀次。 onHide : ⻚⾯隐藏 / 切⼊后台时触发，如 navigateTo 或底部 tab 切换到其他⻚⾯，⼩程序切⼊后台等 onUnload : ⻚⾯卸载时触发。如 redirectTo 或 navigateBack 到其他⻚⾯时.</p><h1 id="⼩程序有哪些传递数据的⽅法？"><a href="#⼩程序有哪些传递数据的⽅法？" class="headerlink" title="⼩程序有哪些传递数据的⽅法？"></a>⼩程序有哪些传递数据的⽅法？</h1><p>使⽤全局变量</p><ul><li>在 app.js 中的 this.globalData = { } 中放⼊要存储的数据。</li><li>在 组件.js 中， 头部 引⼊ const app = getApp(); 获取到全局变量app。</li><li>直接使⽤ app.globalData.key 来进⾏赋值和获取值。</li></ul><p>使⽤路由</p><ul><li>wx.navigateTo 和 wx.redirectTo 时，可以通过在 url 后 拼接变量。</li><li>然后在 ⽬标⻚⾯ 通过在 onLoad 周期中，通过参数来获取传递过来的值。</li></ul><p>使⽤本地缓存Storage</p><ul><li>⻚⾯和组件之间数据的传递</li><li>使⽤第三⽅的事件总线库</li><li>使⽤ Mobx来管理⼩程序跨⻚⾯传递数据。</li></ul><h1 id="微信⼩程序的优劣势"><a href="#微信⼩程序的优劣势" class="headerlink" title="微信⼩程序的优劣势"></a>微信⼩程序的优劣势</h1><ul><li>即⽤即⾛，不⽤安装，省流量，省安装时间，不占⽤桌⾯</li><li>依托微信流量，天⽣推⼴传播优势</li><li>开发成本⽐ App 低 <strong>缺点</strong></li><li>⽤户留存，即⽤即⾛是优势，也存在⼀些问题</li><li>⼊⼝相对传统 App 要深很多</li><li>限制较多,⻚⾯⼤⼩不能超过2M。不能打开超过10个层级的⻚⾯</li></ul><h1 id="bindtap和catchtap的区别是什么"><a href="#bindtap和catchtap的区别是什么" class="headerlink" title="bindtap和catchtap的区别是什么?"></a>bindtap和catchtap的区别是什么?</h1><p><strong>相同点</strong>：</p><p>​    都是⽤来监听⽤户的点击事件。</p><p><strong>不同点：</strong></p><p>​    主要是bindtap是不会阻⽌冒泡事件的，catchtap是阻值冒泡</p>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-Vue3全家桶实战</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-Vue3%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E6%88%98/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-Vue3%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue常⻅⾯试题"><a href="#Vue常⻅⾯试题" class="headerlink" title="Vue常⻅⾯试题"></a>Vue常⻅⾯试题</h1><h2 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h2><p>Vue (读⾳ /vjuː/，类似于 view) 是⼀套⽤于构建⽤户界⾯的渐进式 JavaScript框架</p><ul><li>全称是Vue.js或者Vuejs；</li><li>它基于标准 HTML、CSS 和 JavaScript 构建，并提供了⼀套声明式的、组件化的编程模型；</li><li>帮助你⾼效地开发⽤户界⾯，⽆论任务是简单还是复杂；</li></ul><h3 id="Vue-js-的特点"><a href="#Vue-js-的特点" class="headerlink" title="Vue.js 的特点"></a>Vue.js 的特点</h3><ul><li>易⽤： Vuejs是⼀个渐进式的框架，相⽐于其它框架，它更简单，易学，上⼿快。</li><li>灵活： （渐进式）不断繁荣的⽣态系统，可以在⼀个库和⼀套完整框架之间⾃如伸缩。</li><li>⾼效： 20kB min+gzip 运⾏⼤⼩；超快虚拟 DOM；最省⼼的优化。</li><li>双向绑定：开发效率⾼。</li><li>基于组件的代码共享</li><li>Web项⽬⼯程化，增加可读性、可维护性</li></ul><h3 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h3><p>MVC和MVVM都是⼀种软件的体系结构</p><ul><li>MVC是Model – View –Controller的简称，是在前期被使⽤⾮常框架的架构模式，⽐如iOS、前端；</li><li>MVVM是Model-View-ViewModel的简称，是⽬前⾮常流⾏的架构模式；</li></ul><p>通常情况下，我们也经常称Vue是⼀个MVVM的框架。</p><ul><li>Vue官⽅其实有说明，Vue虽然并没有完全遵守MVVM的模型，但是整个设计是受到它的启发的。</li></ul><h3 id="说说你对-SPA-单⻚⾯的理解，它的优缺点分别是什么"><a href="#说说你对-SPA-单⻚⾯的理解，它的优缺点分别是什么" class="headerlink" title="说说你对 SPA 单⻚⾯的理解，它的优缺点分别是什么"></a>说说你对 SPA 单⻚⾯的理解，它的优缺点分别是什么</h3><p>SPA（ single-page application ）仅在 Web ⻚⾯初始化时加载相应的 HTML、JavaScript 和 CSS。⼀旦⻚⾯加载完成，SPA 不会因为⽤户的操作⽽进⾏⻚⾯的重新加载或跳转；取⽽代之的是利⽤路由机制实现 HTML 内容的变换，UI 与⽤户的交互，避免⻚⾯的重新加载。</p><p><strong>优点：</strong></p><ul><li>⽤户体验好、快，内容的改变不需要重新加载整个⻚⾯，避免了不必要的跳转和重复渲染；</li><li>基于上⾯⼀点，SPA 相对对服务器压⼒⼩；</li><li>前后端职责分离，架构清晰，前端进⾏交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单⻚ Web 应⽤功能及显示效果，需要在加载⻚⾯的时候将 JavaScript、CSS 统⼀加载，部分⻚⾯按需加载；</li><li>前进后退路由管理：由于单⻚应⽤在⼀个⻚⾯中显示所有的内容，所以不能使⽤浏览器的前进后退功能，所有的⻚⾯切换需要⾃⼰建⽴堆栈管理；</li><li>SEO 难度较⼤：由于所有的内容都在⼀个⻚⾯中动态替换显示，所以在 SEO 上其有着天然的弱势</li></ul><h3 id="v-show-与-v-if-有什么区别"><a href="#v-show-与-v-if-有什么区别" class="headerlink" title="v-show 与 v-if 有什么区别"></a>v-show 与 v-if 有什么区别</h3><p><strong>⾸先，在⽤法上的区别：</strong></p><ul><li>v-show是不⽀持template；</li><li>v-show不可以和v-else⼀起使⽤；</li></ul><p><strong>其次，本质的区别：</strong></p><ul><li>v-show元素⽆论是否需要显示到浏览器上，它的DOM实际都是有存在的，只是通过CSS的display属性来进⾏切换；</li><li>v-if当条件为false时，其对应的原⽣压根不会被渲染到DOM中；</li></ul><p><strong>开发中如何进⾏选择呢？</strong></p><ul><li>如果我们的原⽣需要在显示和隐藏之间频繁的切换，那么使⽤v-show；</li><li>如果不会频繁的发⽣切换，那么使⽤v-if；</li></ul><h3 id="数组中的哪些⽅法会触发视图的更新"><a href="#数组中的哪些⽅法会触发视图的更新" class="headerlink" title="数组中的哪些⽅法会触发视图的更新"></a>数组中的哪些⽅法会触发视图的更新</h3><p>Vue 将被侦听的数组的变更⽅法进⾏了包裹，所以它们也将会触发视图更新，这些被包裹过的⽅法包括：</p><p>push()</p><p>pop()</p><p>shift()</p><p>unshift()</p><p>splice()</p><p>sort()</p><p>reverse()</p><p>上⾯的⽅法会直接修改原来的数组，所以它们会触发视图更新</p><p>其它数组的⽅法:</p><p>但是某些⽅法不会替换原来的数组，⽽是会⽣成新的数组，⽐如 fifilter()、concat() 和 slice()，使⽤这些⽅法将不会触发视图更新</p><h3 id="Vue中v-for的key-有什么作⽤"><a href="#Vue中v-for的key-有什么作⽤" class="headerlink" title="Vue中v-for的key 有什么作⽤"></a>Vue中v-for的key 有什么作⽤</h3><p>在使⽤v-for进⾏列表渲染时，我们通常会给元素或者组件绑定⼀个key属性。</p><p>这个key属性有什么作⽤呢？</p><ul><li>key属性主要⽤在Vue的虚拟DOM算法，在新旧nodes对⽐时辨识VNodes。</li><li>如果不使⽤key，Vue会使⽤⼀种最⼤限度减少动态元素并且尽可能的尝试就地修改/复⽤相同类型元素的算法</li><li>使⽤key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素。</li></ul><p>key 是 VNode 的唯⼀标记，通过这个 key， diffff 操作可以更准确、更快速的达到复⽤节点，更新视图的⽬的。复⽤节点就需要通过移动元素的位置来达到更新的⽬的。</p><h3 id="computed和method有什么区别"><a href="#computed和method有什么区别" class="headerlink" title="computed和method有什么区别"></a>computed和method有什么区别</h3><p>计算属性和⽅法：</p><ul><li>都可以通过this来访问</li><li>都可以对⼀些数据进⾏处理和计算</li><li>对于包含响应式数据计算的逻辑，应该使⽤计算属性，因为计算属性是有缓存。</li></ul><p>computed和method的区别</p><ul><li>computed底层会缓存, 性能更⾼</li><li>计算属性会基于它们的依赖关系进⾏缓存;</li><li>在数据不发⽣变化时，计算属性是不需要重新计算的</li><li>但是如果依赖的数据发⽣变化，在使⽤时，计算属性依然会重新进⾏计算</li></ul><h3 id="什么是双向绑定？v-model的本质是什么"><a href="#什么是双向绑定？v-model的本质是什么" class="headerlink" title="什么是双向绑定？v-model的本质是什么"></a>什么是双向绑定？v-model的本质是什么</h3><p>双向绑定:</p><ul><li>即当数据发⽣变化的时候，视图也就发⽣变化，当视图发⽣变化的时候，数据也会跟着同步变化</li><li>v-model 是语法糖，它负责监听⽤户在表单元素中的输⼊事件来更新数据</li></ul><p>表单元素使⽤v-model的本质：</p><ul><li>v-bind绑定value属性的值</li><li>v-on绑定input事件监听到函数,函数会获取最新的值赋值到绑定的属性中</li></ul><div class="code-wrapper"><pre><code class="hljs jsx">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> :value=<span class="hljs-string">&quot;message&quot;</span> @input=<span class="hljs-string">&quot;message = $event.target.value&quot;</span> /&gt;</code></pre></div><p>组件使⽤v-model的本质:</p><ul><li>将其 value attribute 绑定到⼀个名叫 modelValue 的 prop 上；</li><li>在其 input 事件被触发时，将新的值通过⾃定义的 update:modelValue 事件抛出(发出)；</li></ul><div class="code-wrapper"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">Counter</span> v-model=<span class="hljs-string">&quot;appCounter&quot;</span>/&gt;&lt;!-- 相当于--&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> <span class="hljs-attr">v-bind:modelValue</span>=<span class="hljs-string">&quot;appCounter&quot;</span> @<span class="hljs-attr">update:modelValue</span>=<span class="hljs-string">&quot;appCounter =</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="language-xml">$event&quot;</span>/&gt;</span></span></code></pre></div><h3 id="data选项为什么是⼀个函数⽽不是对象"><a href="#data选项为什么是⼀个函数⽽不是对象" class="headerlink" title="data选项为什么是⼀个函数⽽不是对象"></a>data选项为什么是⼀个函数⽽不是对象</h3><p>JavaScript中的对象是引⽤类型的数据，当多个实例引⽤同⼀个对象时，只要⼀个实例对这个对象进⾏操作，其他实例中的数据也会发⽣变化。</p><p>⽽在Vue中，我们更多的是想要复⽤组件，那就需要每个组件都有⾃⼰的数据，这样组件之间才不会相互⼲扰。</p><p>所以组件的数据不能写成对象的形式，⽽是要写成函数的形式。数据以函数返回值的形式定义。</p><p>这样当我们每次复⽤组件的时候，就会返回⼀个新的data，也就是说每个组件都有⾃⼰的私有数据空间，它们各⾃维护⾃⼰的数据，不会⼲扰其他组件的正常运⾏</p><h3 id="Vue-data-中某⼀个属性的值发⽣改变后，视图会⽴即同步执⾏重新渲染吗"><a href="#Vue-data-中某⼀个属性的值发⽣改变后，视图会⽴即同步执⾏重新渲染吗" class="headerlink" title="Vue data 中某⼀个属性的值发⽣改变后，视图会⽴即同步执⾏重新渲染吗"></a>Vue data 中某⼀个属性的值发⽣改变后，视图会⽴即同步执⾏重新渲染吗</h3><p>不会⽴即同步执⾏重新渲染。</p><p>Vue 实现响应式并不是数据发⽣变化之后 DOM ⽴即变化，⽽是按⼀定的策略进⾏ DOM 的更新。</p><p>Vue 在更新 DOM 时是异步执⾏的。只要侦听到数据变化， Vue 将开启⼀个队列，并缓冲在同⼀事件循环中发⽣的所有数据变更。</p><p>如果同⼀个watcher被多次触发，只会被推⼊到队列中⼀次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是⾮常重要的。</p><p>然后，在下⼀个的事件循环”tick”中，Vue 刷新队列并执⾏实际（已去重的）⼯作</p><h3 id="sass是什么？如何在vue中安装和使⽤"><a href="#sass是什么？如何在vue中安装和使⽤" class="headerlink" title="sass是什么？如何在vue中安装和使⽤"></a>sass是什么？如何在vue中安装和使⽤</h3><p>sass是⼀种CSS预处理器语⾔，除此之外，less、stylus也是常⻅的CSS预处理器语⾔。</p><p>sass安装和使⽤步骤如下：</p><ol><li><p>⽤npm安装加载程序（ sass-loader、 css-loader等加载程序)。</p></li><li><p>在 webpack.confifig.js中配置sass加载程序</p></li></ol><h3 id="在-Vue-js开发环境下调⽤API接⼝，如何避免跨域"><a href="#在-Vue-js开发环境下调⽤API接⼝，如何避免跨域" class="headerlink" title="在 Vue. js开发环境下调⽤API接⼝，如何避免跨域"></a>在 Vue. js开发环境下调⽤API接⼝，如何避免跨域</h3><p>1.在vue.confifig.js中的devServer选项中的proxy中配置反向代理</p><p>2.在vite.confifig.js中的server选项中的proxy中配置反向代理</p><p>3.直接后端开发⼈员配置cors</p><h3 id="v-if和v-for⼀起使⽤的弊端及解决办法"><a href="#v-if和v-for⼀起使⽤的弊端及解决办法" class="headerlink" title="v-if和v-for⼀起使⽤的弊端及解决办法"></a>v-if和v-for⼀起使⽤的弊端及解决办法</h3><p>Vue.js 中使⽤最多的两个指令就是 v-if 和 v-for ，因此开发者们可能会想要同时使⽤它们。虽然不建议这样做，但有时确实是必须的，于是我们想提供有关其⼯作⽅式的指南。</p><ul><li>2..x 版本中在⼀个元素上同时使⽤ v-if 和 v-for 时， v-for 会优先作⽤。</li><li>3.x 版本中 v-if 总是优先于 v-for ⽣效。</li></ul><p>由于语法上存在歧义，建议避免在同⼀元素上同时使⽤两者。</p><p>⽐起在模板层⾯管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可⻅元素，⽐如：</p><ol><li><p>在v-for的外层或内层包裹⼀个元素（template）来使⽤v-if</p></li><li><p>⽤computed处理筛选出列表</p></li></ol><h3 id="谈谈你对-keep-alive-的了解"><a href="#谈谈你对-keep-alive-的了解" class="headerlink" title="谈谈你对 keep-alive 的了解"></a>谈谈你对 keep-alive 的了解</h3><p>keep-alive 是 Vue 内置的⼀个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>⼀般结合路由和动态组件⼀起使⽤，⽤于缓存组件。</li><li>提供 include 和 exclude 属性，两者都⽀持字符串或正则表达式。</li></ul><p>​            include 表示只有名称匹配的组件会被缓存。</p><p>​            exclude 表示任何名称匹配的组件都不会被缓存。</p><p>​            其中 exclude 的优先级⽐ include ⾼。</p><ul><li>对应两个钩⼦函数 activated 和 deactivated 。</li></ul><p>​            当组件被激活时，触发钩⼦函数 activated。</p><p>​            当组件被移除时，触发钩⼦函数 deactivated。</p><h3 id="说说Vue插槽的作⽤和平时开发中的应⽤"><a href="#说说Vue插槽的作⽤和平时开发中的应⽤" class="headerlink" title="说说Vue插槽的作⽤和平时开发中的应⽤"></a>说说Vue插槽的作⽤和平时开发中的应⽤</h3><p>插槽的作⽤:</p><ul><li>⽀持在⽗组件⾃定义⼦组件中的个内容</li><li>让⼦组件更具有通⽤性，不必限定死某个内容</li></ul><p>插槽平时开发中的应⽤:</p><ul><li>在封装组件时，如果组件中的某个内容是动态的或不确定的，就可以使⽤插槽来代替了。</li><li>在使⽤第三⽅库时，往往会通过使⽤插槽类⾃定义第三⽅组件中的某些内容。</li></ul><h2 id="Component组件"><a href="#Component组件" class="headerlink" title="Component组件"></a>Component组件</h2><h3 id="⽗⼦组件的⽣命周期顺序"><a href="#⽗⼦组件的⽣命周期顺序" class="headerlink" title="⽗⼦组件的⽣命周期顺序"></a>⽗⼦组件的⽣命周期顺序</h3><p>加载渲染过程： ⽗beforeCreate -&gt; ⽗created -&gt; ⽗beforeMount -&gt; ⼦beforeCreate -&gt; ⼦created -&gt; ⼦beforeMount -&gt;⼦mounted -&gt; ⽗mounted</p><p>⼦组件更新过程：⽗beforeUpdate -&gt; ⼦beforeUpdate -&gt; ⼦updated -&gt; ⽗updated</p><p>⽗组件更新过程：⽗beforeUpdate -&gt; ⽗updated</p><p>销毁过程：⽗beforeDestroy -&gt; ⼦beforeDestroy -&gt; ⼦destroyed -&gt; ⽗destroyed</p><h3 id="组件通讯-传值-式有哪些"><a href="#组件通讯-传值-式有哪些" class="headerlink" title="组件通讯(传值)式有哪些"></a>组件通讯(传值)式有哪些</h3><ul><li>⽗传⼦：⼦组件通过props来接收⽗组件传递的属性 xxx 的值</li><li>⼦传⽗：⼦组件通过emit触发事件传递，⽗组件通过监听对应的事件来接收数据</li><li>Provide/Inject：⽗组件提供内容，⼦或孙组件可以注⼊⽗组件提供的内容。</li><li>组件实例：通过ref来拿到组件的实例，调⽤实例的属性或⽅法进⾏传值。</li><li>事件总线：可以⾃⼰编写EventBus插件来进⾏通讯，或世界使⽤第三⽅的事件总线库。</li><li>⽤Vuex/Pinia: 可以使⽤全局状态管理来进⾏全局共享数据</li></ul><h3 id="什么是⽣命周期函数？Vue组件的⽣命周期函数有哪些"><a href="#什么是⽣命周期函数？Vue组件的⽣命周期函数有哪些" class="headerlink" title="什么是⽣命周期函数？Vue组件的⽣命周期函数有哪些"></a>什么是⽣命周期函数？Vue组件的⽣命周期函数有哪些</h3><p><strong>⽣命周期函数：</strong></p><p>⽣命周期函数是⼀些钩⼦函数（回调函数），在某个时间会被Vue源码内部进⾏回调</p><p>通过对⽣命周期函数的回调，我们可以知道⽬前组件正在经历什么阶段</p><p>Vue3的⽣命周期函数:</p><p>beforeCreate :组件实例在创建之前</p><p>created: 组件被创建完成</p><p>​    可以发送⽹络请求</p><p>​    可以事件监听</p><p>​    this.$watch()</p><p>beforeMount : 组件template准备被挂载</p><p>mounted :组件template已经被挂载</p><p>​    可以获取DOM,可以使⽤DOM</p><p>beforeUpdate: 准备更新DOM</p><p>updated: 更新DOM,根据最新数据⽣成新的VNode,⽣成新的虚拟DOM,转换为真实的DOM</p><p>beforeUnmount: 卸载之前</p><p>unmounted: DOM 元素被卸载完成</p><p>​    回收操作(取消事件监听)</p><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><h3 id="什么是Composition-API-和-Options-API"><a href="#什么是Composition-API-和-Options-API" class="headerlink" title="什么是Composition API 和 Options API"></a>什么是Composition API 和 Options API</h3><p>Composition API:</p><ul><li>Composition API 是⼀组 API，允许我们使⽤导⼊的函数⽽不是声明选项来编写 Vue 组件。它是⼀个涵盖以下 API 的总称：Reactivity API、Lifecycle Hooks、Dependency Injection等等</li><li>使⽤Composition API编写组件时可以根据逻辑功能来组织代码。⽐如可以把⼀个功能所⽤到的API 放在⼀起，这样可以让代码⾼内聚和低耦合，进⽽提⾼了代码的逻辑的复⽤性。</li><li>在 Vue 3 中，它也主要与script setup语法⼀起使⽤</li></ul><p>Options API:</p><ul><li>在对应的属性中编写对应的功能模块, ⽐如data定义数据、methods中定义⽅法、computed中定义计算属性、watch中监听属性改变，也包括⽣命周期钩⼦</li><li>弊端: 当我们实现某⼀个功能时，这个功能对应的代码逻辑会被拆分到各个属性中,当组件变得复杂，导致对应属性的列表也会增⻓，这可能会导致组件难以阅读和理解</li></ul><h3 id="Composition-API和之Options-API有什么区别"><a href="#Composition-API和之Options-API有什么区别" class="headerlink" title="Composition API和之Options API有什么区别"></a>Composition API和之Options API有什么区别</h3><ul><li>在逻辑组织和逻辑复⽤⽅⾯，Composition API是优于Options API。</li><li>Composition API⼏乎是函数，会有更好的类型推断，对于TS的⽀持更友好。</li><li>Composition API对 tree-shaking 友好，代码也更容易压缩。</li><li>Composition API中⻅不到this的使⽤，减少了this指向不明的情况。</li><li>Composition API⽤起来稍微复杂⼀点，⽽Options API就⾮常简单、易于使⽤</li></ul><h3 id="说说Vue3中setup函数的作⽤"><a href="#说说Vue3中setup函数的作⽤" class="headerlink" title="说说Vue3中setup函数的作⽤"></a>说说Vue3中setup函数的作⽤</h3><p>在Vue3中， setup() 函数充当了组件编写Composition API 的⼊⼝点</p><p>setup函数参数主要有两个参数：</p><p>​    第⼀个参数：props , ⽗组件传递过来的属性会被放到props对象中</p><p>​    第⼆个参数：context, 它⾥⾯包含三个属性</p><p>​        attrs：所有的⾮prop的attribute；</p><p>​        slots：⽗组件传递过来的插槽；</p><p>​        emit：当我们组件内部需要发出事件时会⽤到emit（因为我们不能访问this，所以不可</p><p>以通过 this.$emit发出事件）</p><p>可以在setup中可以定义响应式数据、⽅法、计算属性、侦听器等等。</p><p>可以通过setup的返回值来替代data选项，让数据可以直接在template中使⽤。</p><h3 id="ref和reactive有什么区别？开发中如何选择"><a href="#ref和reactive有什么区别？开发中如何选择" class="headerlink" title="ref和reactive有什么区别？开发中如何选择"></a>ref和reactive有什么区别？开发中如何选择</h3><ul><li>ref和reactive都是响应式的API，都可以⽤来定义响应式的数据。</li><li>ref可以包裹任意数据类型，reactive只能包裹复杂数据类型，⽐如对象、数组。</li><li>ref返回⼀个ref对象，在script中取值需要通过value属性，但是在模板中使⽤会进⾏解包不需要调⽤value。</li><li>reactive包裹的是复杂数据类型，直接取⾥⾯的属性即可。</li><li>ref⼏乎可以应⽤在任何场景，⽽且包含reactive适合的场景</li><li>reactive的应⽤场景⽐较受限，第⼀：值⽐较固定，第⼆：值与值之间是有联系的。</li><li>开发中尽量选择ref</li></ul><h3 id="Composition-API常⻅的⼏个函数与⽤法"><a href="#Composition-API常⻅的⼏个函数与⽤法" class="headerlink" title="Composition API常⻅的⼏个函数与⽤法"></a>Composition API常⻅的⼏个函数与⽤法</h3><p>ref</p><p>​    包裹任意类型的值，将包裹的值加⼊响应式</p><p>reactive</p><p>​    包裹复杂类型的值，将包裹的值加⼊响应式</p><p>computed</p><p>​    把⼀些复杂逻辑⽤computed进⾏包裹，如同Options API中的计算属性⼀样</p><p>​    computed会⾃动收集相关依赖，当依赖发⽣变化时，会⾃动进⾏更新</p><p>⽣命周期</p><p>​    Vue3中想要在beforeCreate和created中做的事，直接在setup中做即可</p><p>​    Vue3的其他的⽣命周期函数都要在前⾯加⼀个on，然后需要在vue中主动引⼊watch</p><p>​    watch可以监听单个数据源，也可以监听多个数据源</p><p>​    watch是懒执⾏，第⼀次是不会执⾏的，除⾮你为其提供第三个参数中的immediate属性为</p><p>true</p><p>​    watch只有等到监听的数据源发⽣了变化后，才会执⾏第⼆个参数（回调）</p><p>​    watch可以获取监听数据源的前后变化的值</p><p>​    侦听多个数据源的时候，第⼀个参数是数组类型</p><p>watchEffect</p><p>​    watchEffffect会⾃动收集依赖，收集的依赖是第⼀个参数，也就是回调函数中有哪些东⻄是加⼊响应式的</p><p>​    如果这个值加⼊了响应式就会被收集起来，当被收集的值发⽣了变化，就会重新执⾏这个回调函数</p><p>​    watchEffffect第⼀次执⾏是在DOM挂载前执⾏的，所以如果你想在第⼀次执⾏时拿到DOM元 素</p><p>​    需要传⼊第⼆个参数，第⼆个参数是⼀个对象，让其flflush属性的值为post即可</p><p>toRefs</p><p>​    对reactive进⾏解构后就失去了响应式的效果，因为reactive返回的是⼀个Proxy对象</p><p>​    对Proxy对象进⾏解构，拿到的是纯净的值，所以没有了响应式的效果</p><p>​    如果想要对reactive进⾏解构，需要对其包裹⼀个toRefs</p><p>​    这么做相当于为reactive中的每⼀个值包裹了⼀个ref</p><h3 id="Vue3中的watch和watchEffffect有什么区别"><a href="#Vue3中的watch和watchEffffect有什么区别" class="headerlink" title="Vue3中的watch和watchEffffect有什么区别"></a>Vue3中的watch和watchEffffect有什么区别</h3><p>watch和watchEffect都⽤⽤来侦听响应式数据的变化，watch可以侦听指定的源，默认第⼀次不会执⾏，watchEffffect虽不能指定侦听的源，但是会⾃动收集依赖，并默认会先执⾏⼀次。</p><p>watch</p><ul><li>​    watch可以监听单个数据源，也可以监听多个数据源</li><li>​    watch是懒执⾏，第⼀次是不会执⾏的，除⾮你为其提供第三个参数中的immediate属性为true</li><li>​    watch只有等到监听的数据源发⽣了变化后，才会执⾏第⼆个参数（回调）</li><li>​    watch可以获取监听数据源的前后变化的值</li><li>​    侦听多个数据源的时候，第⼀个参数是数组类型</li></ul><p>watchEffect</p><ul><li>​    watchEffect会⾃动收集依赖，收集的依赖是第⼀个参数，也就是回调函数中有哪些东⻄是加⼊响应式的</li><li>​    如果这个值加⼊了响应式就会被收集起来，当被收集的值发⽣了变化，就会重新执⾏这个回调函数</li><li>​    watchEffect第⼀次执⾏是在DOM挂载前执⾏的，所以如果你想在第⼀次执⾏时拿到DOM元素</li><li>​    需要传⼊第⼆个参数，第⼆个参数是⼀个对象，让其flflush属性的值为post即可</li></ul><h3 id="说说Vue3中script-setup语法糖常⻅⽤法"><a href="#说说Vue3中script-setup语法糖常⻅⽤法" class="headerlink" title="说说Vue3中script setup语法糖常⻅⽤法"></a>说说Vue3中script setup语法糖常⻅⽤法</h3><p>script setup 是在单⽂件组件中使⽤ Composition API 的编译时语法糖，相⽐与之前的setup函数写法，它具有更多的优势：</p><ul><li>更少的样板内容，更简洁的代码。</li><li>能够使⽤纯 TypeScript 声明 props 和抛出事件。</li><li>更好的运⾏时性能 (其模板会被编译成与其同⼀作⽤域的渲染函数，没有任何的中间代理)。</li><li>更好的 IDE 类型推断性能 (减少语⾔服务器从代码中抽离类型的⼯作)。</li></ul><p><strong>script setup</strong></p><ul><li><p>当使⽤ script setup 的时候，任何在 script setup 声明的顶层绑定都能在模板中直接使⽤</p><p>​    声明的顶层绑定：包括变量，函数声明，以及 import 引⼊的内容</p></li><li><p>响应式数据需要通过ref、reactive来创建</p></li><li><p>在script setup中导⼊的组件可以直接使⽤</p></li></ul><p><strong>defifineProps</strong></p><p>在script setup语法糖中必须使⽤ defifineProps API来声明props，它具备完整的类型推断并且在<script setup> 中是直接可⽤的（不需要额外导⼊）。</p><p><strong>defifineEmits</strong></p><p>在script setup语法糖中必须使⽤ defifineEmits API来声明 emits，它具备完整的类型推断并且在<script setup> 中是直接可⽤的（不需要额外导⼊）。</p><p><strong>defifineExpose</strong></p><ul><li>获取组件的实例可以通过ref来获取，接着组件挂载完成后可通过value拿到组件实例。</li><li>当拿到组件实例后，默认是不可以访问这个实例中的⽅法和属性，因为默认没暴露任何⽅法和属性。</li><li>因此在Vue3组件中可以⽤defifineExpose API来暴露⽅法和属性给外部访问。</li><li>defifineExpose 也是不需要导⼊，直接使⽤即可</li></ul><h2 id="Vue-Rouer路由"><a href="#Vue-Rouer路由" class="headerlink" title="Vue Rouer路由"></a>Vue Rouer路由</h2><h3 id="vue-router路由的两种模式"><a href="#vue-router路由的两种模式" class="headerlink" title="vue-router路由的两种模式"></a>vue-router路由的两种模式</h3><p>vue-router中默认使⽤的是hash模式</p><ol><li><p>hash模式，带#。如：<a href="http://localhost:8080/#/page%E3%80%82%E6%94%B9%E5%8F%98hash%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E8%BA%AB%E4%B8%8D%E4%BC%9A%E6%9C%89%E4%BB%BB%E4%BD%95%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E4%BD%9C%E3%80%82">http://localhost:8080/#/page。改变hash，浏览器本身不会有任何请求服务器动作。</a></p></li><li><p>history模式，不带#， 如：&lt;<a href="http://localhost:8080/page">http://localhost:8080/page</a> ，路径没有#。基于HTML5的pushState、replaceState实现。</p></li></ol><table><thead><tr><th><strong>hash</strong></th><th><strong>history</strong></th></tr></thead><tbody><tr><td>有 # 号</td><td>没有 # 号</td></tr><tr><td>能够兼容到IE8</td><td>只能兼容到IE10</td></tr><tr><td>实际的url之前使⽤哈希字符，这部分url不会发送到服务器，不需要在服务器层⾯上进⾏任何处理</td><td>每访问⼀个⻚⾯都需要服务器进⾏路由匹配⽣成html ⽂件再发送响应给浏览器，消耗服务器⼤量资源</td></tr><tr><td>刷新不会存在 404 问题</td><td>浏览器直接访问嵌套路由时，会报 404 问题。</td></tr><tr><td>不需要服务器任何配置</td><td>需要在服务器配置⼀个回调路由</td></tr></tbody></table><h3 id="路由跳转时如何传递数据"><a href="#路由跳转时如何传递数据" class="headerlink" title="路由跳转时如何传递数据"></a>路由跳转时如何传递数据</h3><p>动态路由</p><p>path: /user/:id</p><p>获取动态路由的值的⽅式</p><p>​    在template中，直接通过 $route.params获取值</p><p>​    在created中，通过 this.$route.params获取值</p><p>​    在setup中，使⽤ vue-router库提供的⼀个hook useRoute</p><p>该Hook会返回⼀个Route对象，对象中保存着当前路由相关的值</p><p>query参数:</p><p>​    通过query的⽅式来传递参数</p><p>​    在界⾯中通过 $route.query 来获取参数</p><p>​    在created中，通过 this.$route.query获取值</p><p>​    在setup，使⽤ vue-router库提供的⼀个hook useRoute 来获取</p><h3 id="什么是路由守卫？路由守卫有什么作⽤"><a href="#什么是路由守卫？路由守卫有什么作⽤" class="headerlink" title="什么是路由守卫？路由守卫有什么作⽤"></a>什么是路由守卫？路由守卫有什么作⽤</h3><p><strong>什么是路由守卫</strong></p><p>vue-router 提供的路由(导航)守卫主要⽤来通过跳转或取消的⽅式守卫导航。有很多种⽅式植⼊路由导航中：全局的，单个路由独享的，或者组件级的。</p><p>全局导航钩⼦</p><p>​    router.beforeEach(to,from,next)</p><p>​    router.afterEach(to,from)</p><p>​    ….</p><p>组件内的钩⼦</p><p>​    beforeRouteEnter (to, from, next)</p><p>​    beforeRouteUpdate (to, from, next)</p><p>​    beforeRouteLeave (to, from, next)</p><p>​    。。。</p><p>单独路由独享组件</p><p>​    beforeEnter: (to, from, next)</p><p>​    afterEach(to,from)</p><p>​    ….</p><p><strong>路由守卫有什么作⽤</strong></p><p>可以在进⼊路由之前进⾏某些判断，⽐如，检查token是否存在来判断⽤户是否已经登录。</p><p>可以在路由守卫中进⾏⻚⾯的权限判断，⽐如，判断某个⽤户是否拥有该⻚⾯的权限。</p><p>也可以⽤来记录⻚⾯的某些信息，⽐如，记录⻚⾯的滚动信息等等。</p><h3 id="route和router的区别"><a href="#route和router的区别" class="headerlink" title="route和router的区别"></a>route和router的区别</h3><p>route是路由信息对象，在Vue3中通过 useRoute 来获取。</p><p>​    包括了path，params，hash，query，fullPath，matched，name等路由信息参数。</p><p>router是路由实例对象，在Vue3中通过 useRouter 来获取。</p><p>​    包括了路由跳转⽅法、钩⼦函数等，⽐如：push、go、back、addRouter、beforeEnter等</p><h2 id="Vuex和Pinia状态管理"><a href="#Vuex和Pinia状态管理" class="headerlink" title="Vuex和Pinia状态管理"></a>Vuex和Pinia状态管理</h2>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-前端工程化基础</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前端⼯程化-常⻅⾯试题"><a href="#前端⼯程化-常⻅⾯试题" class="headerlink" title="前端⼯程化-常⻅⾯试题"></a>前端⼯程化-常⻅⾯试题</h1><h2 id="Node基础"><a href="#Node基础" class="headerlink" title="Node基础"></a>Node基础</h2><h3 id="说说Node是什么？和浏览器有什么区别和关系？"><a href="#说说Node是什么？和浏览器有什么区别和关系？" class="headerlink" title="说说Node是什么？和浏览器有什么区别和关系？"></a>说说Node是什么？和浏览器有什么区别和关系？</h3><p>Node.js是⼀个基于V8 JavaScript引擎的JavaScript运⾏时环境</p><ul><li>V8可以嵌⼊到任何C ++应⽤程序中，⽆论是Chrome还是Node.js，事实上都是嵌⼊了V8引擎来执⾏JavaScript代码；</li><li>但是在Chrome浏览器中，还需要解析、渲染HTML、CSS等相关渲染引擎，另外还需要提供⽀持浏览器操作的API、浏览器⾃⼰的事件循环等</li><li>在Node.js中我们也需要进⾏⼀些额外的操作，⽐如⽂件系统读/写、⽹络IO、加密、压缩解压⽂件等操作</li></ul><p>在浏览器中，全局变量都是在window上的，⽐如有document、setInterval、setTimeout、alert、console等</p><ul><li>​    在浏览器中执⾏的JavaScript代码，如果我们在顶级范围内通过var定义的⼀个属性，默认会被添加到window对象上。</li></ul><p>在Node中，我们也有⼀个global属性，并且看起来它⾥⾯有很多其他对象</p><ul><li>在node中，我们通过var定义⼀个变量，它只是在当前模块中有⼀个变量，不会放到全局中</li></ul><h3 id="说说你对模块化开发的理解"><a href="#说说你对模块化开发的理解" class="headerlink" title="说说你对模块化开发的理解"></a>说说你对模块化开发的理解</h3><ul><li>模块化开发最终的⽬的是将程序划分成⼀个个⼩的结构(模块)</li><li>这个结构中编写属于⾃⼰的逻辑代码，有⾃⼰的作⽤域，定义变量名词时不会影响到其他的结构</li><li>可导出变量,函数,对象等给其他模块⽤，也可导⼊其他模块中的变量,函数,对象</li><li>按照这种结构划分开发程序的过程，就是模块化开发的过程</li><li>早期是没有模块化, 带来⼀些问题</li></ul><p>​    命名冲突 -&gt; ⽴即执⾏函数 -&gt; ⾃定义模块 -&gt; 没有规范</p><p>​    社区中模块化规范: CommonJS/AMD/CMD</p><p>​    ES6中推出模块化: ES Module</p><h3 id="什么是-yarn-和-npm？为什么要⽤-yarn-代替-npm-呢？"><a href="#什么是-yarn-和-npm？为什么要⽤-yarn-代替-npm-呢？" class="headerlink" title="什么是 yarn 和 npm？为什么要⽤ yarn 代替 npm 呢？"></a>什么是 yarn 和 npm？为什么要⽤ yarn 代替 npm 呢？</h3><p>npm 是与 Node.js ⾃带的默认包管理器，它有⼀个⼤型的公共库和私有库，存储在 npm registry的数据库中（官⽅默认中⼼库 <a href="http://registry.npmjs.org/%EF%BC%8C%E5%9B%BD%E5%86%85%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F">http://registry.npmjs.org/，国内淘宝镜像</a> <a href="http://registry.npm.taobao.org/%EF%BC%89%EF%BC%8C%E2%BD%A4%E6%88%B7%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87">http://registry.npm.taobao.org/），⽤户可以通过</a> npm 命令⾏访问该仓库。在 npm 的帮助下，⽤户可以轻松管理项⽬中的依赖项</p><p>yarn 也是⼀个包管理器，是由Facebook、Google、Exponent 和 Tilde 联合推出了⼀个新的 JS 包管理⼯具，它有如下的优点：</p><ul><li>速度快，⽀持并⾏安装。⽆论 npm 还是 Yarn 在执⾏包的安装时，都会执⾏⼀系列任务。npm 是按照队列执⾏每个 package，也就是说必须要等到当前 package 安装完成之后，才</li><li>能继续后⾯的安装。⽽ Yarn 是同步执⾏所有任务，提⾼了性能。离线模式，如果之前已经安装过⼀个软件包，⽤Yarn再次安装时之间从缓存中获取，就不⽤像npm那样再从⽹络下载了</li></ul><p>yarn 是为了弥补 早期npm 的⼀些缺陷⽽出现的，因为早期的npm存在很多的缺陷，⽐如安装依赖速度很慢、版本依赖混乱等等⼀系列的问题。虽然从npm5版本开始，进⾏了很多的升级和改进，但是依然很多⼈喜欢使⽤yarn。</p><h3 id="说出npm-install的安装过程"><a href="#说出npm-install的安装过程" class="headerlink" title="说出npm install的安装过程"></a>说出npm install的安装过程</h3><p>执⾏ npm install 会检测是有package-lock.json⽂件：</p><p>没有lock⽂件</p><ul><li>分析依赖关系，这是因为我们可能包会依赖其他的包，并且多个包之间会产⽣相同依赖的情况；</li><li>从registry仓库中下载压缩包（如果我们设置了镜像，那么会从镜像服务器下载压缩包）；获取到压缩包后会对压缩包进⾏缓存（从npm5开始有的）；将压缩包解压到项⽬的node_modules⽂件夹中（前⾯我们讲过，require的查找顺序会在该包下⾯查找）</li></ul><p>有lock⽂件</p><ul><li><p>检测lock中包的版本是否和package.json中⼀致（会按照semver版本规范检测）</p></li><li><p>不⼀致，那么会重新构建依赖关系，直接会⾛顶层的流程</p></li><li><p>⼀致的情况下，会去优先查找缓存</p><p>没有找到，会从registry仓库下载，直接⾛顶层流程</p><p>查找到，会获取缓存中的压缩⽂件，并且将压缩⽂件解压到node_modules⽂件夹中</p></li></ul><h3 id="什么是pnpm？为什么说pnpm⾼性能？"><a href="#什么是pnpm？为什么说pnpm⾼性能？" class="headerlink" title="什么是pnpm？为什么说pnpm⾼性能？"></a>什么是pnpm？为什么说pnpm⾼性能？</h3><ul><li><p>pnpm是⼀个快速、节省磁盘空间的软件包管理器，特点是：快速、⾼效，并⽀持monorepo等等。</p></li><li><p>当使⽤ npm 或 Yarn 时，如果你有 100 个项⽬，并且所有项⽬都有⼀个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本。为了解决上⾯的问题，就出现了pnpm，使⽤pnpm安装的依赖包将被存放在⼀个统⼀的位置。</p><p>​    当安装软件包时， 其包含的所有⽂件都会硬链接到此位置，⽽不会占⽤额外的硬盘空间</p></li></ul><p>​            pinia是软连接和硬链接相结合，⽅便在项⽬之间共享相同版本的依赖包</p><h2 id="webpack基础"><a href="#webpack基础" class="headerlink" title="webpack基础"></a>webpack基础</h2><h3 id="什么是webpack，说说你对webpack的理解"><a href="#什么是webpack，说说你对webpack的理解" class="headerlink" title="什么是webpack，说说你对webpack的理解"></a>什么是webpack，说说你对webpack的理解</h3><p>webpack是⼀个静态的模块化打包⼯具，它将根据模块的依赖关系进⾏静态分析，然后将这些模块按照指定的规则⽣成对应的静态资源</p><p>对webpack的理解</p><ul><li>打包⼯具：webpack可以将帮助我们进⾏模块打包，所以它是⼀个打包⼯具。</li><li>⽣成静态资源：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）</li><li>⽀持模块化：webpack默认⽀持各种模块化开发，ES Module、CommonJS、AMD等</li></ul><h3 id="有哪些常⻅的Loader？你⽤过哪些Loader"><a href="#有哪些常⻅的Loader？你⽤过哪些Loader" class="headerlink" title="有哪些常⻅的Loader？你⽤过哪些Loader"></a>有哪些常⻅的Loader？你⽤过哪些Loader</h3><ul><li>file-loader ：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件 (处理图⽚和字体)</li><li>url-loader ：与 fifile-loader 类似，区别是⽤户可以设置⼀个阈值，⼤于阈值会交给 fifile-loader 处理，⼩于阈值时返回⽂件 base64 形式编码 (处理图⽚和字体)</li><li>sass-loader ：将SCSS/SASS代码转换成CSS</li><li>less-loader ：将Less码转换成CSS</li><li>css-loader ：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性</li><li>style-loader ：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS</li><li>postcss-loader ：扩展 CSS 语法，使⽤下⼀代 CSS，可以配合 autoprefifixer 插件⾃动补⻬ CSS3 前 缀</li></ul><h3 id="有哪些常⻅的Plugin？你⽤过哪些Plugin？"><a href="#有哪些常⻅的Plugin？你⽤过哪些Plugin？" class="headerlink" title="有哪些常⻅的Plugin？你⽤过哪些Plugin？"></a>有哪些常⻅的Plugin？你⽤过哪些Plugin？</h3><ul><li>define-plugin ：定义环境变量 (Webpack4 之后指定 mode 会⾃动配置)</li><li>html-webpack-plugin ：简化 HTML ⽂件创建 (依赖于 html-loader)</li><li>clean-webpack-plugin : ⽬录清理</li><li>webpack-bundle-analyzer : 可视化 Webpack 输出⽂件的体积 (业务组件、依赖第三⽅模块)</li></ul><h3 id="说⼀说Loader和Plugin的区别？"><a href="#说⼀说Loader和Plugin的区别？" class="headerlink" title="说⼀说Loader和Plugin的区别？"></a>说⼀说Loader和Plugin的区别？</h3><ul><li>Loader 本质就是⼀个函数，在该函数中对接收到的内容进⾏转换，返回转换后的结果。 因为Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进⾏转译的预处理⼯作。</li><li>Plugin 就是插件，基于事件流框架 Tapable ，插件可以扩展 Webpack 的功能，在 Webpack运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li><li>Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每⼀项都是⼀个 Object，内部包含了 test(类型⽂件)、loader、options (参数)等属性。</li><li>Plugin 在 plugins 中单独配置，类型为数组，每⼀项是⼀个 Plugin 的实例，参数都通过构造函数传⼊。</li></ul><h3 id="source-map是什么？"><a href="#source-map是什么？" class="headerlink" title="source map是什么？"></a>source map是什么？</h3><p>source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p><p>map⽂件只要不打开开发者⼯具，浏览器是不会加载的。</p><p>线上环境⼀般有三种处理⽅案：</p><ul><li>hidden-source-map ：借助第三⽅错误监控平台 Sentry 使⽤</li><li>nosources-source-map ：只会显示具体⾏数以及查看源代码的错误栈。安全性⽐ sourcemap⾼</li><li>sourcemap ：通过 nginx 设置将 .map ⽂件只对⽩名单开放(公司内⽹)</li></ul><p>注意：避免在⽣产中使⽤ inline- 和 eval- ，因为它们会增加 bundle 体积⼤⼩，并降低整体性能。</p><h3 id="什么是babel？babel在开发中是什么作⽤？"><a href="#什么是babel？babel在开发中是什么作⽤？" class="headerlink" title="什么是babel？babel在开发中是什么作⽤？"></a>什么是babel？babel在开发中是什么作⽤？</h3><ul><li>Babel是⼀个JavaScript的编译⼯具，常⽤于编译JavaScript代码。</li><li>⽐如：可以将ECMAScript 2015+代码转换为向后兼容版本的JavaScript (即ES6以上的代码转成ES5代码)，但Babel在进⾏代码转换时是需要依赖对应的插件来转换。</li></ul><h3 id="vue-loader是什么-？使⽤它的⽤途有哪些？"><a href="#vue-loader是什么-？使⽤它的⽤途有哪些？" class="headerlink" title="vue-loader是什么 ？使⽤它的⽤途有哪些？"></a>vue-loader是什么 ？使⽤它的⽤途有哪些？</h3><p>Vue Loader 是⼀个 webpack 的 loader，它允许你以⼀种名为单⽂件组件 (SFC)的格式撰写 Vue组件。</p><p>Vue Loader 还提供了很多酷炫的特性：</p><ul><li>允许为 Vue 组件的每个部分使⽤其它的 webpack loader，例如在 <style> 的部分使⽤</li><li>Sass 和在 <template> 的部分使⽤ Pug；</li><li>允许在⼀个 .vue ⽂件中使⽤⾃定义块，并对其运⽤⾃定义的 loader 链；</li><li>使⽤ webpack loader 将 <style> 和 <template> 中引⽤的资源当作模块依赖来处理；</li><li>为每个组件模拟出 scoped CSS；</li><li>在开发过程中使⽤热重载来保持状态。</li></ul><p>简⽽⾔之，webpack 和 Vue Loader 的结合为你提供了⼀个现代、灵活且极其强⼤的前端⼯作流，来帮助撰写 Vue.js 应⽤。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="集中式版本控制和分布式版本控制有什么区别？"><a href="#集中式版本控制和分布式版本控制有什么区别？" class="headerlink" title="集中式版本控制和分布式版本控制有什么区别？"></a>集中式版本控制和分布式版本控制有什么区别？</h3><p>集中式版本控制(简称 CVCS） ⽐如 CVS和SVN</p><ul><li>主要特点是单⼀的集中管理的服务器，保存所有⽂件的修订版本</li><li>协同开发⼈员通过客户端连接到这台服务器，取出最新的⽂件或者提交更新</li><li>集中式版本控制也有⼀个核⼼的问题：中央服务 器不能出现故障</li></ul><p>分布式版本控制系统 (简 称 DVCS) ⽐如git</p><ul><li>客户端并不只提取最新版本的⽂件快照， ⽽是把代码仓库完整地镜像下 来，包括完整的历史记录</li><li>这么⼀来，任何⼀处协同⼯作⽤的服务器发⽣故障，事后都可以⽤任何⼀个镜像出来的本地仓库恢复</li><li>因为每⼀次的克隆操作，实际上都是⼀次对代码仓库的完整备份</li></ul><p>Git和SVN的区别</p><table><thead><tr><th>Git</th><th>SVN</th></tr></thead><tbody><tr><td>Git是⼀个分布式的版本控制⼯具</td><td>SVN 是集中版本控制⼯具</td></tr><tr><td>它属于第3代版本控制⼯具</td><td>它属于第2代版本控制⼯具</td></tr><tr><td>客户端可以在其本地系统上克隆整个存储库</td><td>版本历史记录存储在服务器端存储库中</td></tr><tr><td>.即使离线也可以提交</td><td>只允许在线提交</td></tr><tr><td>Push/pull 操作更快</td><td>Push/pull 操作较慢</td></tr><tr><td>⼯程可以⽤ commit ⾃动共享</td><td>没有任何东⻄⾃动共享</td></tr></tbody></table><h3 id="⼯作中常⻅的Git命令有哪些"><a href="#⼯作中常⻅的Git命令有哪些" class="headerlink" title="⼯作中常⻅的Git命令有哪些"></a>⼯作中常⻅的Git命令有哪些</h3><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建版本库:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> &lt;url&gt; <span class="hljs-comment">#克隆远程版本库</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init <span class="hljs-comment">#初始化本地版本库</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash">修改和提交:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status <span class="hljs-comment">#查看状态</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add &lt;file&gt; <span class="hljs-comment">#跟踪指定的⽂件</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add . <span class="hljs-comment">#将⽂件添加到暂存区中</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-comment">#将暂存区的⽂件进⾏提交更新</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash">查看提交历史:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> <span class="hljs-comment">#查看提交的历史</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">log</span> -p &lt;file&gt; <span class="hljs-comment">#查看指定⽂件的提交历史</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash">对分⽀和标签的操作: <span class="hljs-comment">#分⽀:</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch <span class="hljs-comment">#查看本地所有分⽀</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout &lt;branch&gt; <span class="hljs-comment">#切换到指定的分⽀</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch &lt;new-branch&gt; <span class="hljs-comment">#创建新的分⽀</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d &lt;branch&gt; <span class="hljs-comment">#删除本地分⽀</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash">标签:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git tag &lt;newtag&gt; <span class="hljs-comment">#基于最新提交创建标签</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git tag <span class="hljs-comment">#查看所有的本地标签</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git tag -d &lt;tagname&gt; <span class="hljs-comment">#删除指定的标签</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push --tags <span class="hljs-comment">#上传所有标签到远程仓库</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash">分⽀合并:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge &lt;branch&gt; <span class="hljs-comment">#合并指定分⽀到当前分⽀</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git rebase &lt;branch&gt; <span class="hljs-comment">#衍合指定分⽀到当前分⽀</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash">远程操作:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote add &lt;remote&gt; &lt;url&gt; <span class="hljs-comment">#关联远程仓库</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote -v <span class="hljs-comment">#查看所关联的远程版本库信息</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt; <span class="hljs-comment">#从指定的远程仓库中获取代码、信息</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git pull &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment">#获取远程仓库的代码并且合并</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;branch&gt; <span class="hljs-comment">#上传本地库的代码⾄远程仓库并且合并</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash">远程分⽀的操作: <span class="hljs-comment">#分享⼀个分⽀，并且将其推送到有写⼊权限的仓库上:</span></span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push &lt;remote&gt; &lt;branch&gt;</span><span class="hljs-meta prompt_">#</span><span class="language-bash">跟踪远程分⽀: <span class="hljs-comment">#克隆⼀个仓库时，默认会创建⼀个跟踪origin/master的分⽀</span></span><span class="hljs-meta prompt_">#</span><span class="language-bash">⾃⼰设置跟踪其他分⽀:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout --track &lt;remote&gt;/&lt;branch&gt;</span><span class="hljs-meta prompt_">#</span><span class="language-bash">删除远程分⽀:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;branch&gt;</span><span class="hljs-meta prompt_">#</span><span class="language-bash">获取别⼈更新的远程分⽀信息:</span><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt; &lt;branch&gt;</span></code></pre></div><h3 id="Git分⽀管理（Git-Flow）"><a href="#Git分⽀管理（Git-Flow）" class="headerlink" title="Git分⽀管理（Git Flow）"></a>Git分⽀管理（Git Flow）</h3><p>Production分⽀</p><p>也就是我们经常使⽤的Master分⽀，这个分⽀包含最近发布到⽣产环境的代码，最近发布的Release， 这个分⽀只能从其他分⽀合并，不能在这个分⽀直接修改</p><p>Develop分⽀</p><p>这个分⽀是我们的主开发分⽀，包含所有要发布到下⼀个Release的代码，这个主要合并于其他分⽀，⽐如Feature分⽀</p><p>Feature分⽀</p><p>这个分⽀主要是⽤来开发⼀个新的功能，⼀旦开发完成，我们合并回Develop分⽀，并进⼊下⼀个Release</p><p>Release分⽀</p><p>当你需要发布⼀个新Release的时候，我们基于Develop分⽀创建⼀个Release分⽀，完成Release后，我们合并到Master和Develop分⽀</p><p>Hotfifix分⽀</p><p>当我们在Production发现新的Bug时候，我们需要创建⼀个Hotfifix, 完成Hotfifix后，我们合并回Master和Develop分⽀，所以Hotfifix的改动会进⼊下⼀个Release</p>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-框架实战</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="什么是jQuery-jQuery有哪些优缺点？"><a href="#什么是jQuery-jQuery有哪些优缺点？" class="headerlink" title="什么是jQuery? jQuery有哪些优缺点？"></a>什么是jQuery? jQuery有哪些优缺点？</h2><p>什么是jQuery：</p><ul><li>jQuery 是⼀个快速、⼩型且功能丰富的 JavaScript 库。</li><li>使HTML⽂档遍历、操作、事件处理、动画和 Ajax 之类的事情变得更加简单</li><li>具有易于使⽤的 API，可在多种浏览器中使⽤</li><li>jQuery 结合多功能性和可扩展性，改变了数百万⼈编写 JavaScript 的⽅式</li></ul><p>jQuery优点缺点：</p><p>易于学习：相对于其它的前端框架，jQuery 更易于学习，它⽀持 JavaScript 的编码⻛格</p><p>少写多做（Write less, do more）</p><p>​    Query提供了丰富的功能(DOM操作、过滤器、事件、动画、Ajax等)。</p><p>​    可以编写更少可读的代码来提⾼开发⼈员的⼯作效率。</p><p>优秀的 API ⽂档：jQuery 提供了优秀的在线 API ⽂档。</p><p>跨浏览器⽀持：提供出⾊的跨浏览器⽀持 (IE9+)，⽆需编写额外代码。</p><p>jQuery缺点</p><p>jQuery代码库⼀直在增⻓（⾃ jQuery 1.5 起超过 200KB）</p><p>不⽀持组件化开发</p><p>jQuery 更适合DOM操作，当涉及到开发复杂的项⽬时，jQuery能⼒有限。</p><h2 id="什么是库-library-，什么是框架-framework-？"><a href="#什么是库-library-，什么是框架-framework-？" class="headerlink" title="什么是库(library)，什么是框架(framework)？"></a>什么是库(library)，什么是框架(framework)？</h2><p>随着JavaScript的普及，以及越来越多⼈使⽤JavaScript来构建⽹站和应⽤程序</p><ul><li>JavaScript社区认识到代码中存在⾮常多相同的逻辑是可复⽤的。</li><li>因此社区就开始对这些相同的逻辑的代码封装到⼀个JavaScript⽂件中。</li><li>这个封装好的JavaScript⽂件就可称为JavaScript库或JavaScript框架</li></ul><p>库(library)</p><ul><li>JavaScript库是⼀个预先编写好并实现了⼀些特定功能的代码⽚段的集合。</li><li>⼀个库中会包含许多的函数、变量等，可根据需求引⼊到项⽬中使⽤。</li><li>⼀些常⻅的库有jQuery、Day.js、Lodash和React等</li></ul><p>框架（framework）</p><ul><li>JavaScript框架是⼀个完整的⼯具集，可帮助塑造和组织您的⽹站或应⽤程序。</li><li>提供⼀个结构来构建整个应⽤程序，开发⼈员可以在结构的规则内更安全、更⾼效地⼯作。</li><li>⼀些更常⻅的框架有：Bootstrap、Angular、Vue、Next.js等。</li></ul><h2 id="什么是CDN-CDN有什么作⽤？"><a href="#什么是CDN-CDN有什么作⽤？" class="headerlink" title="什么是CDN? CDN有什么作⽤？"></a>什么是CDN? CDN有什么作⽤？</h2><p>什么是CDN：</p><p>CDN称之为内容分发⽹络（Content Delivery Network或Content Distribution Network，缩写：CDN）</p><ul><li>CDN它是⼀组分布在不同地理位置的服务器相互连接形成的⽹络系统。</li><li>通过这个⽹络系统，将Web内容存放在距离⽤户最近的服务器。</li><li>可以更快、更可靠地将Web内容(⽂件、图⽚、⾳乐、视频等)发送给⽤户</li></ul><p>CDN有什么作⽤：</p><ul><li>CDN会将资源缓存到遍布全球的⽹站，⽤户请求获取资源时，可就近获取CDN上缓存的资源。</li><li>这样CDN不但可以提⾼资源的访问速度，还可以分担源站的压⼒。</li></ul><h3 id="jQuery对象-与-DOM-Element的区别"><a href="#jQuery对象-与-DOM-Element的区别" class="headerlink" title="jQuery对象 与 DOM Element的区别"></a>jQuery对象 与 DOM Element的区别</h3><p>获取的⽅式不同</p><p>​    DOM Element 是通过原⽣⽅式获取，例如：document.querySelector()</p><p>​    jQuery对象是通过调⽤jQuery函数获取，例如：jQuery(‘ ‘)</p><p>jQuery对象是⼀个类数组对象，该对象中会包含所选中的DOM Element的集合。</p><p>jQuery对象的原型上扩展⾮常多实⽤的⽅法，DOM Element 则是W3C规范中定义的属性和⽅法</p><h3 id="jQuery库中的-是什么"><a href="#jQuery库中的-是什么" class="headerlink" title="jQuery库中的$是什么?"></a>jQuery库中的$是什么?</h3><p>$是jQuery()函数的别称。该函数⽤于将任何对象包裹成jQuery对象，接着你就被允许调⽤定义在jQuery对象上的多个不同⽅法。</p><p>⽐如：可以将⼀个选择器字符串传⼊$()函数，它会返回⼀个包含所有匹配的DOM元素数组的jQuery对象。</p><h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="什么是Bootstrap"><a href="#什么是Bootstrap" class="headerlink" title="什么是Bootstrap?"></a>什么是Bootstrap?</h2><p>Bootstrap 读⾳ /ˈbu:tstræp/ ，是⼀个⾮常受欢迎的前端框架，官⽅⽹站将其描述为。</p><p>最流⾏的 HTML、CSS 和 JS 框架，⽤于在 Web 上开发响应式、移动优先的项⽬。</p><p>​    响应式⻚⾯：⻚⾯布局会随着屏幕尺⼨的变化⽽⾃动调整布局，作⽤是适配各个屏幕</p><p>Bootstrap是功能强⼤、可扩展，且功能丰富的前端⼯具包</p><p>Bootstrap底层是使⽤Sass构建，⽀持定制（Sass、Color、CSS variable ….）。</p><p>Bootstrap中的⽹格系统、组件以及强⼤的JavaScript 插件可以让我们快速搭建响应式⽹站。</p><h2 id="说说Bootstrap的⽹格系统（Grid-System）？"><a href="#说说Bootstrap的⽹格系统（Grid-System）？" class="headerlink" title="说说Bootstrap的⽹格系统（Grid System）？"></a>说说Bootstrap的⽹格系统（Grid System）？</h2><p>Bootstrap⽹格系统是⽤于构建移动设备优先的强⼤布局系统，可⽀持12列⽹格、5 个断点和数⼗个预定义类</p><p>提供了⼀种简单⽽强⼤的⽅法来创建各种形状和⼤⼩的响应式布局。</p><p>底层使⽤了强⼤的flflexbox来构建弹性布局，并⽀持12列的⽹格布局。</p><p>⽹格系统是使⽤container、row和col类来布局，并且布局是⽀持响应的。</p><h2 id="使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？"><a href="#使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？" class="headerlink" title="使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？"></a>使⽤Bootstrap时，要声明的⽂档类型是什么？以及为什么要这样声明？</h2><p>使⽤Bootstrap时，需要使⽤ HTML5 ⽂档类型（Doctype）。</p><p>因为Bootstrap 使⽤了⼀些 HTML5 元素和 CSS 属性，如果在 Bootstrap 创建的⽹⻚开头不使⽤HTML5 的⽂档类型（Doctype），可能会⾯临⼀些浏览器显示不⼀致的问题，甚⾄可能⾯临⼀些特定情境下的不⼀致，以致于代码不能通过 W3C 标准的验证。</p><h2 id="对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么？"><a href="#对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么？" class="headerlink" title="对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么？"></a>对于各类尺⼨的设备，Bootstrap设置的class前缀分别是什么？</h2><p>超⼩设备⼿机（&lt;576px）：.col-</p><p>超⼩设备⼿机横屏（&gt;=576px）：.col-sm-</p><p>⼩型设备平板（&gt;=768px）：.col-md-</p><p>中型设备台式电脑（&gt;=992px）：.col-lg-</p><p>⼤型设备台式电脑（&gt;=1200px）：.col-xl-</p>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-JS高级</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E9%AB%98%E7%BA%A7/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h1><h2 id="this的绑定规则有⼏种"><a href="#this的绑定规则有⼏种" class="headerlink" title="this的绑定规则有⼏种"></a>this的绑定规则有⼏种</h2><p>默认绑定：⽴函数调⽤，函数没有被绑定到某个对象上进⾏调⽤</p><p>隐式绑定：通过某个对象发起的函数调⽤，在调⽤对象内部有⼀个对函数的引⽤。</p><p>显式绑定：明确this指向的对象，第⼀个参数相同并要求传⼊⼀个对象</p><p>​    apply/call</p><p>​    bind</p><p>new绑定：</p><p>​    创建⼀个全新对象</p><p>​    新对象被执⾏prototype链接</p><p>​    新对象绑定到函数调⽤的this</p><p>​    如果函数没有返回其他对象，表达式会返回这个对象</p><h2 id="this的⾯试题解析"><a href="#this的⾯试题解析" class="headerlink" title="this的⾯试题解析"></a>this的⾯试题解析</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;window&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); &#125;;<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo2</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo3</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); &#125;; &#125;;<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo4</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); &#125;; &#125;;&#125;<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;person1&quot;</span>);<span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;person2&quot;</span>);<span class="hljs-comment">// person1.foo1() // person1 隐式调⽤</span><span class="hljs-comment">// person1.foo1.call(person2) // person2 显示调⽤ this指向person2所在的对象</span><span class="hljs-comment">// person1.foo2(); // person1 箭头函数 向上层作⽤查找 上层作⽤域中的this为person1指向的对象</span><span class="hljs-comment">// person1.foo2.call(person2); // person1 箭头函数 显示绑定没⽤</span><span class="hljs-comment">// person1.foo3()() // window 相当于将返回的函数赋值给⼀个变量 指向该变量 是ᇿ⽴函数调⽤</span><span class="hljs-comment">// person1.foo3.call(person2)() // window 默认调⽤</span><span class="hljs-comment">// person1.foo3().call(person2) // person2 将函数的this显示绑定到person2所在的对象</span><span class="hljs-comment">// person1.foo4()() // person1 箭头函数 向上层作⽤域中查找this foo4中的this隐式绑定为person1</span><span class="hljs-comment">// person1.foo4.call(person2)() // person2 箭头函数 向上层作⽤域中查找this foo4中 的this显示绑定为person2</span><span class="hljs-comment">// person1.foo4().call(person2) // person1 箭头函数显示绑定没⽤ 和person1.foo4()()xiang&#x27;ton</span></code></pre></div><h1 id="作⽤域"><a href="#作⽤域" class="headerlink" title="作⽤域"></a>作⽤域</h1><h2 id="什么是变量提升、函数提升"><a href="#什么是变量提升、函数提升" class="headerlink" title="什么是变量提升、函数提升"></a>什么是变量提升、函数提升</h2><p>变量提升：</p><p>简单说就是在js代码执⾏前引擎会先进⾏预编译，预编译期间会将变量声明与函数声明提升⾄其对应作⽤域的最顶端，函数内声明的变量只会提升⾄该函数作⽤域最顶层。当函数内部定义的⼀个变量与外部相同时，那么函数体内的这个变量就会被上升到最顶端。</p><p>举个例⼦，如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 会将var a 的声明提升⾄最顶端</span></code></pre></div><p>函数提升：</p><p>函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升。</p><p>函数提升的优先级⼤于变量提升的优先级，即函数提升在变量提升之上</p><h2 id="说说你对GO-AO-VO的理解"><a href="#说说你对GO-AO-VO的理解" class="headerlink" title="说说你对GO/AO/VO的理解"></a>说说你对GO/AO/VO的理解</h2><p>GO</p><p>Global Object JS代码在执⾏前会现在堆内存中创建⼀个全局对象(GO)</p><p>⽤于存放⼀些定义好的变量⽅法等包含Date Array String Number setTimeout等</p><p>同时有⼀个window属性指向⾃⼰</p><p>同时在语法分析转成AST的过程中也会将⼀些变量 函数 存放在GO中 只是变量的初始值为undefifined</p><p>AO</p><p>函数在执⾏前会先在堆内存中创建⼀个AO(Activation Object)对象 ⾥⾯存放这arguments 对应函数的形参 以及在函数中定义的变量 初始值为undefifined</p><p>VO</p><p>Variable Object 在执⾏函数时 会在执⾏上下⽂栈(ECS)中进⼊⼀个函数执⾏上下⽂(FEC)其中有三个核⼼ 核⼼之⼀是VO 指向的是该函数在内存中解析时创建的AO ⽽在全局执⾏上下⽂中指向的是GO</p><h2 id="说说你对作⽤域和作⽤域链的理解"><a href="#说说你对作⽤域和作⽤域链的理解" class="headerlink" title="说说你对作⽤域和作⽤域链的理解"></a>说说你对作⽤域和作⽤域链的理解</h2><p>作⽤域</p><p>在ES5中，全局是⼀个作⽤域，函数也会产⽣作⽤域。在ES6中，代码块、let、const等都会有属于⾃⼰的作⽤域。</p><p>作⽤域链</p><p>当进⼊到⼀个执⾏上下⽂时，执⾏上下⽂会关联⼀个作⽤域链。通常作⽤域链在解析时就被确定，作⽤域链与函数的定义位置有关，与它的调⽤位置⽆关</p><h2 id="你是如何理解闭包的-闭包到底是什么"><a href="#你是如何理解闭包的-闭包到底是什么" class="headerlink" title="你是如何理解闭包的,闭包到底是什么"></a>你是如何理解闭包的,闭包到底是什么</h2><p><strong>什么是闭包？</strong></p><p>⼀个普通的函数function，如果它可以访问外层作⽤域的⾃由变量，那么这个函数和周围环境就是⼀个闭包。从狭义的⻆度来说：JavaScript中⼀个函数，如果访问了外层作⽤域的变量，那么它是⼀个闭包</p><p><strong>应⽤场景</strong></p><p>防抖 、节流 、⽴即执⾏函数 、组合函数等等</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="常⽤的数组操作⽅法有哪些"><a href="#常⽤的数组操作⽅法有哪些" class="headerlink" title="常⽤的数组操作⽅法有哪些"></a>常⽤的数组操作⽅法有哪些</h2><p>Array.shift()</p><p>删除并返回第⼀个元素 作⽤：从数组中删除第⼀个元素（即下标为0的元素），并返回该元素。 注意：1）删除元素之后，数组的⻓度-1。</p><p>Array.pop()</p><p>删除并返回最后⼀个元素 作⽤：从数组中删除最后⼀个元素（即下标为length-1的元素），并返回该元素。 注意：1）删除元素之后，数组的⻓度-1。</p><p>Array.push(param1[,param2,…paramN])</p><p>尾部添加元素 作⽤：在数组的尾部添加⼀个元素，并返回新数组的⻓度。 注意：1）它是直接修改该数组，⽽不是重新创建⼀个数组。</p><p>Array.unshift(newElement1[,newElement2,…newElementN])</p><p>头部添加元素 作⽤：在数组的头部添加⼀个或多个元素，并返回新数组的⻓度。 注意：1）它是直接修改该数组，⽽不是重新创建⼀个数组。</p><p>Array.join([separator])</p><p>转换成字符串 作⽤：把数组的所有元素放⼊到⼀个字符串中。 注意：1）参数separator表示字符串中元素的分隔符，可以为空，默认为半⻆逗号。</p><p>Array.reverse()</p><p>反转数组 作⽤：把数组的所有元素顺序反转。 注意：1）该⽅法会直接修改数组，⽽不会创建新的数组。</p><h2 id="数组如何进⾏降维（扁平化）"><a href="#数组如何进⾏降维（扁平化）" class="headerlink" title="数组如何进⾏降维（扁平化）"></a>数组如何进⾏降维（扁平化）</h2><p>利⽤Array.some⽅法判断数组中是否还存在数组，es6展开运算符连接数组</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;arr = [].<span class="hljs-title function_">concat</span>(...arr);&#125;</code></pre></div><p>使⽤数组的concat⽅法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<span class="hljs-keyword">let</span> result = []result = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arr)</code></pre></div><p>使⽤数组的concat⽅法和扩展运算符</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<span class="hljs-keyword">var</span> result = []result = [].<span class="hljs-title function_">concat</span>(...arr)</code></pre></div><p>es6中的flflat函数也可以实现数组的扁平化</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,[<span class="hljs-string">&#x27;中&#x27;</span>,<span class="hljs-string">&#x27;⽂&#x27;</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">11</span>,<span class="hljs-number">21</span>,<span class="hljs-number">31</span>]]]],<span class="hljs-number">3</span>];<span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">flat</span>( <span class="hljs-title class_">Infinity</span> )</code></pre></div><h2 id="数组去重，能⽤⼏种⽅法实现"><a href="#数组去重，能⽤⼏种⽅法实现" class="headerlink" title="数组去重，能⽤⼏种⽅法实现"></a>数组去重，能⽤⼏种⽅法实现</h2><p>利⽤ES6 Set去重（ES6中最常⽤）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span> (arr) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr))&#125;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unique</span>(arr))<span class="hljs-comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span></code></pre></div><p>利⽤for嵌套for，然后splice去重（ES5中最常⽤）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>; i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=i+<span class="hljs-number">1</span>; j&lt;arr.<span class="hljs-property">length</span>; j++)&#123;<span class="hljs-keyword">if</span>(arr[i]==arr[j])&#123; <span class="hljs-comment">//第⼀个等同于第⼆个，splice⽅法删除第⼆个</span>arr.<span class="hljs-title function_">splice</span>(j,<span class="hljs-number">1</span>);j--; &#125; &#125; &#125;<span class="hljs-keyword">return</span> arr; &#125;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unique</span>(arr))<span class="hljs-comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //NaN和&#123;&#125;没</span>有去重，两个<span class="hljs-literal">null</span>直接消失了</code></pre></div><p>利⽤indexOf去重</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;type error!&#x27;</span>)<span class="hljs-keyword">return</span> &#125;<span class="hljs-keyword">var</span> array = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (array .<span class="hljs-title function_">indexOf</span>(arr[i]) === -<span class="hljs-number">1</span>) &#123;array .<span class="hljs-title function_">push</span>(arr[i]) &#125; &#125;<span class="hljs-keyword">return</span> array; &#125;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unique</span>(arr))<span class="hljs-comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;,&#123;…&#125;] </span><span class="hljs-comment">//NaN、&#123;&#125;没有去重</span></code></pre></div><p>利⽤sort去重</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;type error!&#x27;</span>)<span class="hljs-keyword">return</span>; &#125;arr = arr.<span class="hljs-title function_">sort</span>()<span class="hljs-keyword">var</span> arrry= [arr[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (arr[i] !== arr[i-<span class="hljs-number">1</span>]) &#123;arrry.<span class="hljs-title function_">push</span>(arr[i]); &#125; &#125;<span class="hljs-keyword">return</span> arrry; &#125;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unique</span>(arr))<span class="hljs-comment">// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;,undefined] // NaN、&#123;&#125;没有去重</span></code></pre></div><p>利⽤includes</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;type error!&#x27;</span>)<span class="hljs-keyword">return</span> &#125;<span class="hljs-keyword">var</span> array =[];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span>( !array.<span class="hljs-title function_">includes</span>( arr[i]) ) &#123;<span class="hljs-comment">//includes 检测数组是否有某个值</span>array.<span class="hljs-title function_">push</span>(arr[i]); &#125; &#125;<span class="hljs-keyword">return</span> array&#125;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unique</span>(arr))<span class="hljs-comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span><span class="hljs-comment">// &#123;&#125; 没有去重</span></code></pre></div><p>利⽤filter</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>) &#123;<span class="hljs-comment">//当前元素，在原始数组中的第⼀个索引==当前索引值，否则返回当前元素</span><span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item, <span class="hljs-number">0</span>) === index; &#125;);&#125;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unique</span>(arr))<span class="hljs-comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></code></pre></div><p>利⽤递归去重</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev,cur</span>) =&gt;</span> prev.<span class="hljs-title function_">includes</span>(cur) ? prev : [...prev,cur],[]);&#125;<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-string">&#x27;true&#x27;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>, <span class="hljs-literal">undefined</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>,<span class="hljs-string">&#x27;NaN&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unique</span>(arr));<span class="hljs-comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></code></pre></div><h2 id="数组中的forEach和map的区别"><a href="#数组中的forEach和map的区别" class="headerlink" title="数组中的forEach和map的区别"></a>数组中的forEach和map的区别</h2><p>forEach() 和 map() 两个⽅法都是ECMA5中Array引进的新⽅法，都是⽤来遍历数组中的每⼀项。</p><p>它们之间的区别：</p><ol><li>map速度⽐forEach快</li><li>map会返回⼀个新数组，不对原数组产⽣影响,foreach不会产⽣新数组，forEach返回undefifined</li><li>map因为返回数组所以可以链式操作，forEach不能</li><li>map⾥可以⽤return（return的是什么，相当于把数组中的这⼀项变为什么（并不影响原来的数组，只是相当于把原数组克隆⼀份，把克隆的这⼀份的数组中的对应项改变了） 。</li><li>forEach⾥⽤return不起作⽤，forEach不能⽤break，会直接报错</li></ol><h2 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h2><p>在JavaScript中遍历数组通常是使⽤for…i循环，在ES5具有遍历数组功能的还有forEach、map、fifilter、some、every、reduce、reduceRight等。for…in和for…of是两种增强型循环，for…in是ES5标准，在ES6中新增了for…of的循环⽅式</p><p><strong>for…in</strong> ：遍历以任意顺序迭代⼀个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性。</p><p><strong>for…of</strong>：遍历在可迭代对象，包括 Array ， Map ， Set ， String ， TypedArray ，arguments 对象等等</p><p>它们的区别：</p><ol><li>for…in可以遍历对象和数组，for…of不能遍历对象</li><li>for…in 循环不仅遍历对象的键名，还会遍历⼿动添加的其它键，甚⾄包括原型链上的键</li><li>for…in遍历的索引为字符串类型</li><li>for..of适⽤遍历数/数组对象/字符串/map/set等拥有<strong>迭代器对象</strong>的集合，但是不能遍历对象</li><li>for…of与forEach()不同的是，它可以正确响应break、continue和return语句具有迭代器对象才可以使⽤for…of</li></ol><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="说出apply、call、bind函数的⽤法和区别"><a href="#说出apply、call、bind函数的⽤法和区别" class="headerlink" title="说出apply、call、bind函数的⽤法和区别"></a>说出apply、call、bind函数的⽤法和区别</h2><p><strong>⽤法：</strong></p><p>apply</p><p>第⼀个参数: 绑定this</p><p>第⼆个参数: 传⼊额外的实参, 以数组的形式</p><p>call</p><p>第⼀个参数: 绑定this</p><p>参数列表: 后续的参数以多参数的形式传递, 会作为实参bind(不希望obj对象身上有函数)</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(obj)<span class="hljs-title function_">bar</span>() <span class="hljs-comment">// this -&gt; obj</span></code></pre></div><p><strong>区别：</strong></p><p>call、apply和bind都可以改变函数的this指向</p><p>call、apply和bind第⼀个参数的是this要指向的对象</p><p>call、apply和bind都可以后续为函数传参，apply是将参数并成⼀个数组，call和bind是将参数依次列出</p><p>call、apply都是直接调⽤，bind⽣成的this指向改变函数需要⼿动调⽤</p><h2 id="什么是纯函数？如何编写纯函数？"><a href="#什么是纯函数？如何编写纯函数？" class="headerlink" title="什么是纯函数？如何编写纯函数？"></a>什么是纯函数？如何编写纯函数？</h2><p>纯函数：纯函数⼀般具有以下的特点：</p><p>确定的输⼊⼀定会有确定的输出（外部环境的任何变化不会影响函数内部的操作产⽣的结果）</p><p>纯函数的执⾏不会产⽣副作⽤。（函数内部的操作也不会对函数外部产⽣任何影响）</p><p>纯函数在react和redux中应⽤⽐较多。</p><p>编写纯函数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//⼀般的数学⽅法可以写成纯函数,例如相加</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<span class="hljs-keyword">var</span> result = args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">perValue, item</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> preValue + item &#125;, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> result&#125;</code></pre></div><h2 id="什么是函数柯⾥化？柯⾥化有什么作⽤"><a href="#什么是函数柯⾥化？柯⾥化有什么作⽤" class="headerlink" title="什么是函数柯⾥化？柯⾥化有什么作⽤"></a>什么是函数柯⾥化？柯⾥化有什么作⽤</h2><p>函数的柯⾥化：</p><p>将传⼊多个参数的函数转变成传⼊单个参数并且返回⼀个函数⽤于接收剩余的参数的函数。</p><p>每⼀层函数都接收⼀个参数并对参数进⾏处理。</p><p>柯⾥化的作⽤：</p><p>单⼀职责：每⼀个函数只⽤处理传⼊的单个参数，每个函数的职责单⼀⽽且确定</p><p>参数复⽤：可以拿到每⼀层函数执⾏的返回值作为⼀个新的函数，复⽤已经传⼊过的参数。</p><p>组合函数以及组合函数的作⽤？</p><p>组合函数：</p><p>组合函数是将多个函数组合到⼀起，进⾏依次调⽤的函数使⽤模式。</p><p>组合函数的作⽤：</p><p>减少重复代码的编写，提⾼代码的复⽤性，便于开发。</p><p>可以对任意个函数进⾏组合，返回新的具有多个被组合函数功能的新函数</p><h2 id="组合函数以及组合函数的作⽤"><a href="#组合函数以及组合函数的作⽤" class="headerlink" title="组合函数以及组合函数的作⽤"></a>组合函数以及组合函数的作⽤</h2><p>组合函数：</p><p>组合函数是将多个函数组合到⼀起，进⾏依次调⽤的函数使⽤模式。</p><p>组合函数的作⽤：</p><p>减少重复代码的编写，提⾼代码的复⽤性，便于开发。</p><p>可以对任意个函数进⾏组合，返回新的具有多个被组合函数功能的新函数</p><h2 id="说说你对严格模式的理解"><a href="#说说你对严格模式的理解" class="headerlink" title="说说你对严格模式的理解"></a>说说你对严格模式的理解</h2><p>严格模式是⼀种JavaScript的限制模式，因为种种历史原因，JavaScript语⾔在⾮严格模式下是⽐较松散的。在JavaScript不断优化和加⼊新特性的过程中，为了兼容早期的JavaScript，⼀些错误和不规范的写法也被保留了下来。这些错误也不会被抛出。在开启了严格模式后，js引擎会以⼀种更严格的规范执⾏JavaScript代码，⼀些不规范的写法和错误也会直接抛出。</p><p>开启严格模式的⽅法：</p><p>对⽂件开启：在⽂件的开头写上”use strict”</p><p>对函数开启：在函数的开头写上”use strict”</p><p>严格模式下的语法限制：</p><ol><li>不允许意外创建全局变量（不写var、let、const这种声明变量的关键字）</li><li>会对静默失败的赋值操作抛出异常</li><li>试图删除不可删除的属性</li><li>不允许函数参数有相同的名称</li><li>不允许只有0开头的⼋进制语法</li><li>不允许使⽤with</li><li>⽆法获取eval中定义的变量</li><li>this绑定不会默认转成对象</li></ol><h1 id="浏览器和v8引擎"><a href="#浏览器和v8引擎" class="headerlink" title="浏览器和v8引擎"></a>浏览器和v8引擎</h1><h2 id="浏览器内核是什么？有哪些常⻅的浏览器内核"><a href="#浏览器内核是什么？有哪些常⻅的浏览器内核" class="headerlink" title="浏览器内核是什么？有哪些常⻅的浏览器内核"></a>浏览器内核是什么？有哪些常⻅的浏览器内核</h2><p>浏览器内核⼜称浏览器渲染引擎，是浏览器的最核⼼部分。负责解析⽹⻚语法并渲染⽹⻚。</p><p>常⻅的浏览器内核有：</p><p>trident（三叉戟）—- IE浏览器、360安全浏览器、UC浏览器、搜狗⾼速浏览器、百度浏览器</p><p>gecko（壁⻁） —- Mozilla、Firefox</p><p>pestro -&gt; Blink —- Opera</p><p>Webkit —- Safari、360极速浏览器、搜狗⾼速浏览器、移动端浏览器</p><p>Webkit -&gt; Blink —-Chrome、Edge</p><h2 id="说出浏览器输⼊⼀个URL到⻚⾯显示的过程"><a href="#说出浏览器输⼊⼀个URL到⻚⾯显示的过程" class="headerlink" title="说出浏览器输⼊⼀个URL到⻚⾯显示的过程?"></a>说出浏览器输⼊⼀个URL到⻚⾯显示的过程?</h2><p>URL 输⼊</p><p>​    检查输⼊的内容是否是⼀个合法的 URL 链接</p><p>​    判断输⼊的 URL 是否完整, 如果不完整，浏览器可能会对域进⾏猜测，补全前缀或者后缀</p><p>​    使⽤⽤户设置的默认搜索引擎来进⾏搜索</p><p>DNS 解析</p><p>​    浏览器不能直接通过域名找到对应的服务器 IP 地址</p><p>​    所以需要进⾏ DNS 解析，查找到对应的 IP 地址进⾏访问。</p><p>建⽴ TCP 连接</p><p>​    发送 HTTP / HTTPS 请求（建⽴ TLS 连接）</p><p>​    向服务器 发起 TCP 连接请求</p><p>​    当这个请求到达服务端后，通过 TCP 三次握⼿，建⽴ TCP 的连接。</p><p>​        1.客户端发送 SYN 包到服务器，并进⼊ SYN_SEND 状态，等待服务器确认</p><p>​        2.服务器收到 SYN 包，必须确认客户的 SYN，同时⾃⼰也发送⼀个 SYN 包，此时服务器进⼊ SYN_RECV 状态。客户端收到服务器的             SYN包，向服务器发送确认包，此包发送完毕，客户端和服务器进⼊ ESTABLISHED 状态，完成三次握⼿。</p><p>服务器响应请求</p><p>当浏览器到 web 服务器的连接建⽴后，浏览器会发送⼀个初始的 HTTP GET 请求，请求⽬标通常是⼀个 HTML ⽂件。服务器收到请求后，将发回⼀个 HTTP 响应报⽂，内容包括相关响应头和 HTML 正⽂。</p><p>浏览器解析渲染⻚⾯</p><p>处理 HTML 标记并构建 DOM 树。</p><p>处理 CSS 标记并构建 CSSOM 树。</p><p>将 DOM 与 CSSOM 合并成⼀个渲染树根据渲染树来布局，以计算每个节点的⼏何信息。将各个节点绘制到屏幕上。</p><p>HTTP 请求结束，断开 TCP 连接.</p><h2 id="说说你对-JS-引擎的理解"><a href="#说说你对-JS-引擎的理解" class="headerlink" title="说说你对 JS 引擎的理解"></a>说说你对 JS 引擎的理解</h2><p>JavaSript 是⼀⻔解释型语⾔</p><p>JS 引擎是 JavaScript 语⾔的运⾏解释器</p><p>​    浏览器内核中有两种引擎，其中⼀种就是 JS 引擎</p><p>​    排版引擎</p><p>​        负责 HTML 和 CSS 解析和排版</p><p>​    JS 引擎</p><p>​        负责解析和运⾏ JavaScript 语句</p><p>常⻅ JS 引擎有</p><ol><li>​        SpiderMonkey -&gt; 第⼀款 JavaScript 引擎，Brendan Eich 开发</li><li>​        Chakra -&gt; 微软开发</li><li>​        WebKit -&gt; JavaScriptCore -&gt; APPLE 开发</li><li>​        Chrome -&gt; V8 -&gt; GOOGLE 开发</li><li>​        ⼩程序 -&gt; JSCore -&gt; 腾讯开发</li></ol><h2 id="说说V8引擎的内存管理"><a href="#说说V8引擎的内存管理" class="headerlink" title="说说V8引擎的内存管理"></a>说说V8引擎的内存管理</h2><p>JavaScript的内存管理是⾃动的</p><p>关于原始数据类型 直接在栈内存中分配</p><p>关于复杂数据类型 在堆内存中分配</p><h2 id="说说V8引擎的垃圾回收器"><a href="#说说V8引擎的垃圾回收器" class="headerlink" title="说说V8引擎的垃圾回收器"></a>说说V8引擎的垃圾回收器</h2><p>因为内存⼤⼩是有限的 所以在内存不需要的时候 需要进⾏释放 ⽤于腾出空间</p><p>GC对于内存管理有着对应的算法</p><p>常⻅的算法</p><p>​    引⽤计数(Reference Count)</p><p>​        当⼀个对象有引⽤指向它时 对应的引⽤计数+1</p><p>​        当没有对象指向它时 则为0 此时进⾏回收</p><p>​        但是有⼀个严重的问题 - 会产⽣循环引⽤</p><p>标记清除(Mark-Sweep)</p><p>​        核⼼思路: 可达性</p><p>​        有⼀个根对象 从该对象出发 开始引⽤到所⽤到的对象 对于根对象没有引⽤到的对象 认为是不可⽤的对象</p><p>​        对于不可⽤的对象 则进⾏回收</p><p>​        该算法有效的解决了循环引⽤的问题</p><p>​        ⽬前V8引擎采⽤的就是该算法</p><p>V8引擎为了优化 在采⽤标记清除的过程中也引⽤了其他的算法</p><p>​        标记整理</p><p>​            和标记清除相似 不同的是回收时 会将保留下来的存储对象整合到连续的内存空间 避免</p><p>​            内存碎⽚化</p><p>​        分代收集(Generational Collection)</p><p>​            将内存中的对象分为两组 新的空间 旧的空间</p><p>​            对于⻓期存活的对象 会将该对象从新空间移到旧空间中 同时GC检查次数减少</p><p>​            将新空间分为from和to 对象的GC查找之后从from移动到to空间中 然后to变为fromfrom变为to 循环⼏次 对于依然存在的对象 移            动到旧空间中</p><p>​        增量收集(Increment Collection)</p><p>​            如果存在许多对象 则GC试图⼀次性遍历所有的对象 可能会对性能造成⼀定的影响</p><p>​            所以引擎试图将垃圾收集⼯作分成⼏部分 然后这⼏部分逐⼀处理 这样会造成微⼩的延迟⽽不是很⼤的延迟</p><p>​        闲时收集(IdIe-time Collection)</p><p>​            GC只会在CPU空闲的时候运⾏ 减少可能对代码执⾏造成的影响</p><h2 id="v8引擎执⾏代码的⼤致流程"><a href="#v8引擎执⾏代码的⼤致流程" class="headerlink" title="v8引擎执⾏代码的⼤致流程"></a>v8引擎执⾏代码的⼤致流程</h2><p>Parse模块：将JavaScript代码转成AST Tree</p><p>Ignition :解释器 将ASTTree 转换为字节码(byte Code)同时收集TurboFan 优化需要的信息</p><p>TurboFan :编译器 将字节码编译为CPU可以直接执⾏的机器码(machine code).如果某⼀个函数呗被多次调⽤ 则会被标记为热点函数 会经过TurBoFan转换的优化的机器码让CPU执⾏ 提⾼代码性能如果后续执⾏代码过程中 改函数调⽤时的参数类型发⽣了改变 则会逆向的转成字节码 让CPU执⾏</p><p>v8引擎执⾏流程:</p><p>⾸先会编译JavaScript 编译过程分为三步</p><p>1 词法分析(scanner)</p><p>​    会将对应的每⼀⾏的代码的字节流分解成有意义的代码块 代码块被称为词法单元(token 进⾏记号化)</p><p>2 语法分析(parser)</p><p>​    将对应的tokens分析成⼀个元素逐级嵌套的树 这个树称之为 抽象语法树(Abstract SyntaxTree AST)这⾥也有对应的 pre-parser</p><p>3 将AST 通过Ignition解释器转换成对应的字节码(ByteCode) 交给CPU执⾏ 同时收集信息</p><p>​    将可优化的信息 通过TurBoFan编译器 编译成更好使⽤的机器码交给CPU执⾏.如果后续代码的参数类型发⽣改变 则会逆优化(Deoptimization)为字节码</p><h2 id="说说线程和进程的区别以及关系"><a href="#说说线程和进程的区别以及关系" class="headerlink" title="说说线程和进程的区别以及关系"></a>说说线程和进程的区别以及关系</h2><p><strong>进程</strong></p><p>​    是 cpu 分配资源的最⼩单位；（是能拥有资源和ᇿ⽴运⾏的最⼩单位）</p><p>​    计算机已经运⾏的程序，是操作系统管理程序的⼀种⽅式 (<strong>官⽅说法</strong>)</p><p>​    可以认为启动⼀个应⽤程序，就会默认启动⼀个进程（也可能是多个进程）(个⼈解释)</p><p>​    也可以说进程是线程的容器</p><p><strong>线程</strong></p><p>​    是 cpu 调度的最⼩单位；（线程是建⽴在进程的基础上的⼀次程序运⾏单位，⼀个进程中可以有多个线程）</p><p>​    操作系统能够运⾏运算调度的最⼩单位，通常情况下它被包含在进程中 (官⽅说法)</p><p>​    每⼀个进程中，都会启动⾄少⼀个线程⽤来执⾏程序中的代码，这个线程被称之为主线程</p><p><strong>操作系统的⼯作⽅式</strong></p><p>​    如何做到同时让多个进程同时⼯作?</p><p>​        因为 CPU 的运算速度⾮常快, 可以快速的在多个进程之间迅速的切换</p><p>​        当进程中的线程获取到世间⽚时, 就可以快速执⾏我们编写的代码</p><p>​        由于 CPU 执⾏速度过于变态, 对于⽤户来说是感受不到这种快速切换的 </p><h2 id="JavaScript为什么是单线程？"><a href="#JavaScript为什么是单线程？" class="headerlink" title="JavaScript为什么是单线程？"></a>JavaScript为什么是单线程？</h2><p>这主要和js的⽤途有关，js是作为浏览器的脚本语⾔，主要是实现⽤户与浏览器的交互，以及操作dom</p><p>这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><p>⽐如js被设计了多线程，如果有⼀个线程要修改⼀个dom元素，另⼀个线程要删除这个dom元素，此时浏览器就会⼀脸茫然，不知所措。</p><p>所以，为了避免复杂性，从⼀诞⽣，JavaScript就是单线程，这已经成了这⻔语⾔的核⼼特征，将来也不会改变</p><h2 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的?"></a>浏览器是多进程的?</h2><p>在浏览器中，每打开⼀个tab⻚⾯，其实就是新开了⼀个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。</p><p>因此浏览器是⼀个多进程的。为了利⽤多核CPU的计算能⼒，HTML5提出Web Worker标准，允许</p><p>JavaScript脚本创建多个线程，但是⼦线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质</p><h2 id="什么是重排重绘，如何减少重排重绘"><a href="#什么是重排重绘，如何减少重排重绘" class="headerlink" title="什么是重排重绘，如何减少重排重绘"></a>什么是重排重绘，如何减少重排重绘</h2><p>重排(Reflflow)</p><p>元素的位置发⽣变动时发⽣重排，也叫回流。此时在关键渲染路径中的 Layout 阶段，计算每⼀个元素在设备视⼝内的确切位置和⼤⼩。当⼀个元素位置发⽣变化时，其⽗元素及其后边的元素位置都可能发⽣变化，代价极⾼</p><p>重绘(Repaint)</p><p>元素的样式发⽣变动，但是位置没有改变。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这⼀步通常称为绘制或栅格化</p><p>另外，重排必定会造成重绘。以下是避免过多重排重绘的⽅法：</p><ol><li><p>使⽤ DocumentFragment 进⾏ DOM 操作，不过现在原⽣操作很少也基本上⽤不到</p></li><li><p>CSS 样式尽量批量修改</p></li><li><p>避免使⽤ table 布局</p></li><li><p>为元素提前设置好⾼宽，不因多次渲染改变位置</p></li></ol><h1 id="⾯向对象"><a href="#⾯向对象" class="headerlink" title="⾯向对象"></a>⾯向对象</h1><h2 id="什么是原型、原型链？"><a href="#什么是原型、原型链？" class="headerlink" title="什么是原型、原型链？"></a>什么是原型、原型链？</h2><p><strong>原型：</strong></p><p>在JavaScript中，每⼀个对象都会有⼀个属性[[prototype]]，这个属性就是对象的原型，这个属性的值也是⼀个对象，是原对象的原型对象。访问对象中属性时，会先在对象⾃身进⾏查找，如果没有找到，那么会去对象的原型对象上查找。</p><p><strong>原型链：</strong></p><p>每个对象都有⾃⼰的原型对象，原型对象也有⾃⼰的原型对象。在访问对象的属性时，会沿着对象⾃身=&gt;⾃身的原型对象=&gt;原型对象的原型对象……这样的链条⼀路查找上去，这条链式结构就叫做原型链。原型链的尽头是Object的原型对象的[[prototype]]属性，值为null。</p><h2 id="如何通过原型链实现继承？"><a href="#如何通过原型链实现继承？" class="headerlink" title="如何通过原型链实现继承？"></a>如何通过原型链实现继承？</h2><p>原型链继承：重写⼦类的显式原型对象，让⼦类的显式原型对象的隐式原型指向⽗类的显式原型对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">o</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()  &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">Subtype, Supertype</span>) &#123;<span class="hljs-title class_">Subtype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">createObject</span>(<span class="hljs-title class_">Supertype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Subtype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Subtype</span>   &#125;)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>) &#125;<span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>)</code></pre></div><h2 id="继承的各个⽅案以及优缺点？"><a href="#继承的各个⽅案以及优缺点？" class="headerlink" title="继承的各个⽅案以及优缺点？"></a>继承的各个⽅案以及优缺点？</h2><p>⽅案⼀：直接将⽗类的prototype赋值给⼦类的prototype，⽗类和⼦类共享原型对象</p><p>缺点：在⼦类原型对象上添加⽅法和属性会影响到⽗类</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Pesrson</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre></div><p>⽅案⼆：通过new操作符创建⼀个新的对象，将这个对象作为⼦类的原型对象(显式原型)</p><p>缺点：</p><p>⼦类的实例对象继承过来的属性是在原型上的，⽆法打印</p><p>没有完美的实现属性的继承（⼦类的实对象可以从⽗类继承属性，也可以拥有⾃⼰的属性）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = p</code></pre></div><p>⽅案三：通过new操作符创建⼀个新的对象，将这个对象作为⼦类的原型对象(显式原型)，并且在⼦类的内部通过借⽤构造函数的⽅法实现属性的继承</p><p>缺点：⽗类构造函数会被调⽤两次，并且⼦类的实例对象总是有两份相同的属性，⼀份在⾃身，⼀份在其原型对象上</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">arg1, arg2</span>) &#123;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, arg1, arg2)&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = p</code></pre></div><p>⽅案四：让⼦类的原型对象(显式原型)的原型对象(隐式原型)指向⽗类的原型对象(显式原型)</p><p>缺点：存在兼容性问题, <strong>proto</strong> 属性只有部分游览器⽀持</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre></div><p>⽅案五：寄⽣组合式继承(ES5中实现继承的最终⽅案)</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">o</span>) &#123; <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125; F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">Subtype, Supertype</span>) &#123; <span class="hljs-title class_">Subtype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">createObject</span>(<span class="hljs-title class_">Supertype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Subtype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123; <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">Subtype</span> &#125;)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>)</code></pre></div><h2 id="说说你对⾯向对象多态的理解"><a href="#说说你对⾯向对象多态的理解" class="headerlink" title="说说你对⾯向对象多态的理解"></a>说说你对⾯向对象多态的理解</h2><p>当对不同的数据类型执⾏同⼀个操作时, 如果表现出来的⾏为(形态)不⼀样, 那么就是多态的体现</p><p>继承也是多态的前提</p><h1 id="ES6-13"><a href="#ES6-13" class="headerlink" title="ES6-13"></a>ES6-13</h1><h2 id="说说let、const和var的区别？"><a href="#说说let、const和var的区别？" class="headerlink" title="说说let、const和var的区别？"></a>说说let、const和var的区别？</h2><p>作⽤域提升</p><p>​    var声明的变量是会进⾏作⽤域提升</p><p>​    let、const没有进⾏作⽤域提升，但是会在解析阶段被创建出来</p><p>​    let,const具有暂时性死区</p><p>块级作⽤域</p><p>​    var不存在块级作⽤域</p><p>​    let和const存在块级作⽤域</p><p>重复声明</p><p>​    var允许重复声明变量</p><p>​    let和const在同⼀作⽤域不允许重复声明变量</p><p>修改声明的变量</p><p>​    let,var 可以修改声明的变量</p><p>​    const它表示保存的数据⼀旦被赋值，就不能被修改,但是如果赋值的是引⽤类型，那么可以通过引⽤找到对应的对象，修改对象的内容</p><h2 id="说说ES6-ES13新增了哪些知识点"><a href="#说说ES6-ES13新增了哪些知识点" class="headerlink" title="说说ES6~ES13新增了哪些知识点"></a>说说ES6~ES13新增了哪些知识点</h2><p>ES6 :</p><p>​    使⽤class⽤来定义类</p><p>​        constructor构造器</p><p>​        extends实现继承</p><p>​        super关键字代表继承的⽗类</p><p>​    对象字⾯量的增强</p><p>​        属性的简写</p><p>​        ⽅法的简写</p><p>​        计算属性名</p><p>​    解构</p><p>​    let/const的使⽤</p><p>​        不能重复声明变量</p><p>​        不存在作⽤域提升</p><p>​        存在暂时性死区</p><p>​        不添加window</p><p>​        存在块级作⽤域</p><p>字符串模板</p><p>​    在模板字符串中，我们可以通过 ${expression} 来嵌⼊动态的内容</p><p>​    标签模板字符串</p><p>函数的默认参数</p><p>函数的剩余参数</p><p>箭头函数</p><p>​    没有显式原型prototype</p><p>​    不绑定this、arguments、super参数</p><p>展开语法</p><p>​    在函数调⽤时使⽤；</p><p>​    在数组构造时使⽤；</p><p>​    展开运算符其实是⼀种浅拷⻉</p><p>​    在构建对象字⾯量时，也可以使⽤展开运算符，这个是在ES2018（ES9）中添加的新特性；</p><p>规范了⼆进制和⼋进制的写法</p><p>新增Symbol</p><p>Set、WeakSet、Map、WeakMap</p><p>ES7 :</p><p>​    Array Includes</p><p>​        通过includes来判断⼀个数组中是否包含⼀个指定的元素，根据情况，包含返回 true，否则返回false。</p><p>​    指数exponentiation运算符</p><p>​    **对数字来计算乘⽅。</p><p>ES8 :</p><p>​    Object values</p><p>​        通过Object.values 来获取所有的value值</p><p>​    Object entries</p><p>​        通过 Object.entries 可以获取到⼀个数组，数组中会存放可枚举属性的键值对数组</p><p>​    String Padding</p><p>​        padStart 和 padEnd ⽅法，分别对字符串的⾸尾进⾏填充的。</p><p>​    Trailing Commas</p><p>​        允许在函数定义和调⽤时多加⼀个逗号：</p><p>​    Object.getOwnPropertyDescriptors</p><p>ES9 :</p><p>​    构建对象字⾯量时，可以使⽤展开运算符</p><p>ES10 :</p><p>​    flat</p><p>​        flat() ⽅法会按照⼀个可指定的深度递归遍历数组，并将所有元素与遍历到的⼦数组中的元素合并为⼀个新数组返回。</p><p>​    flatMap</p><p>​        flatMap是先进⾏map操作，再做flat的操作</p><p>​    flatMap中的flat相当于深度为1</p><p>​    Object fromEntries</p><p>​        Object.formEntries将entries转换成⼀个对象</p><p>​    trimStart trimEnd</p><p>​        去除字符串前⾯或者后⾯的空格</p><p>ES11 :</p><p>​    BigInt</p><p>​        BigInt，⽤于表示⼤的整数(超过最⼤安全整数)</p><p>​        BitInt的表示⽅法是在数值的后⾯加上n</p><p>​    空值合并操作符</p><p>​        ??当前⾯的值为null或者undefifined是,显式??后⾯的值</p><p>​    Optional Chaining</p><p>​        可选链?.</p><p>​        当?.前⾯的值为空时返回undefifined</p><p>Global ThisJavaScript环境的全局对象</p><p>for..in标准化</p><p>for…in遍历对象时遍历的是key</p><h2 id="说说Set、WeakSet、Map、WeakMap的特点"><a href="#说说Set、WeakSet、Map、WeakMap的特点" class="headerlink" title="说说Set、WeakSet、Map、WeakMap的特点"></a>说说Set、WeakSet、Map、WeakMap的特点</h2><p><strong>Set:</strong></p><p>⽤来存储数据,类似于数组,</p><p>与数组的区别是元素不能重复,</p><p>可以使⽤forEach⽅法和使⽤for…of…遍历</p><p>常⻅属性和⽅法</p><p>​    size：返回Set中元素的个数</p><p>​    add(value)：添加某个元素，返回Set对象本身</p><p>​    delete(value)：从set中删除和这个值相等的元素，返回boolean类型</p><p>​    has(value)：判断set中是否存在某个元素，返回boolean类型</p><p>​    clear()：清空set中所有的元素</p><p>​    forEach(callback, [, thisArg])：通过forEach遍历set</p><p><strong>WeakSet:</strong></p><p>只能存储对象类型,不能存放基本数据类型,</p><p>对对象的引⽤是⼀个弱引⽤,如果没有其他对对象的引⽤,那么相应对象会被GC进⾏清除,</p><p>不能遍历</p><p>常⻅的⽅法</p><p>​    add(value)：添加某个元素，返回WeakSet对象本身</p><p>​    delete(value)：从WeakSet中删除和这个值相等的元素，返回boolean类型</p><p>​    has(value)：判断WeakSet中是否存在某个元素，返回boolean类型</p><p><strong>Map:</strong></p><p>⽤于存储映射关系,存储的为键值对,</p><p>每个键值对为⼀个数组,</p><p>与对象的区别是存储的key可以为⼀个对象</p><p>可以使⽤forEach⽅法和使⽤for…of…遍历</p><p>常⻅属性和⽅法</p><p>​    size：返回Set中元素的个数</p><p>​    set(key, value)：在Map中添加key、value，并且返回整个Map对象</p><p>​    get(key)：根据key获取Map中的value</p><p>​    has(key)：判断是否包括某⼀个key，返回Boolean类型</p><p>​    delete(key)：根据key删除⼀个键值对，返回Boolean类型</p><p>​    clear()：清空所有的元素</p><p>​    forEach(callback, [, thisArg])：通过forEach遍历Map</p><p>**WeakMap:**存储的key只能为对象,不允许是其他类型</p><p>对对象的引⽤是⼀个弱引⽤,如果没有其他对对象的引⽤,那么相应对象会被GC进⾏清除,</p><p>不能进⾏遍历</p><p>常⻅的⽅法</p><p>​    set(key, value)：在Map中添加key、value，并且返回整个Map对象</p><p>​    get(key)：根据key获取Map中的value</p><p>​    has(key)：判断是否包括某⼀个key，返回Boolean类型</p><p>​    delete(key)：根据key删除⼀个键值对，返回Boolean类型</p>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-JS基础</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="02-JS基础常⻅⾯试题"><a href="#02-JS基础常⻅⾯试题" class="headerlink" title="02-JS基础常⻅⾯试题"></a>02-JS基础常⻅⾯试题</h1><h2 id="说出-JavaScript-中的常⻅数据类型"><a href="#说出-JavaScript-中的常⻅数据类型" class="headerlink" title="说出 JavaScript 中的常⻅数据类型"></a>说出 JavaScript 中的常⻅数据类型</h2><p>Number -&gt; 代表数据类型是数值</p><p>整数</p><p>浮点</p><p>数组</p><p>String -&gt; 代表字符串类型 -&gt; 通常是⼀段⽂本</p><p>boolean -&gt; 布尔类型</p><p>true</p><p>false</p><p>NULL -&gt; 空值</p><p>undefifined -&gt; 变量未定义</p><p>Object -&gt; 对象类型</p><p>BigInt -&gt; ⼤整数类型</p><p>Symbol -&gt; 符号类型</p><h2 id="说出count-和-count的区别"><a href="#说出count-和-count的区别" class="headerlink" title="说出count++和++count的区别?"></a>说出count++和++count的区别?</h2><p>如果它们在计算之后的值不会被使⽤ 是没有区别的</p><p>如果需要⽴刻使⽤⾃增之后的值 就⽤前置型 反之后置型</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span> + ++count <span class="hljs-comment">// 不推荐这么写</span><span class="hljs-comment">//需要⽴刻使⽤的话</span>count++<span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span> +count <span class="hljs-comment">//++count</span><span class="hljs-comment">//不需要的话</span><span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span> + count <span class="hljs-comment">//count++</span>count++</code></pre></div><h2 id="说出-和-的区别"><a href="#说出-和-的区别" class="headerlink" title="说出==和===的区别?"></a>说出==和===的区别?</h2><ol><li>== (普通相等)</li></ol><p>在类型不相同的情况下, 会将运算元先转成Number的值, 再进⾏⽐较(隐式转换)</p><p>null⽐较特殊: null在进⾏⽐较的时候, 应该是会被当成⼀个对象和原⽣类型进⾏⽐较的</p><p> 2.=== (严格不等)</p><p>在类型不同的情况下,直接返回false</p><h2 id="逻辑与-amp-amp-和逻辑或-的本质和区别"><a href="#逻辑与-amp-amp-和逻辑或-的本质和区别" class="headerlink" title="逻辑与&amp;&amp;和逻辑或||的本质和区别"></a>逻辑与&amp;&amp;和逻辑或||的本质和区别</h2><p>逻辑与:也叫作短路与</p><p>从左往右,依次计算</p><p>当计算第⼀个运算元,先隐式转换为Boolean值进⾏⽐较</p><p>true ,继续下⼀个⽐较</p><p>false ,直接返回该运算元的初始值</p><p>如果找到最后也没有找到,就返回最后⼀个运算元</p><p>逻辑或:也叫做短路或</p><p>从左往右,依次计算</p><p>当计算第⼀个运算元,先隐式转换为Boolean值进⾏⽐较</p><p>true ,直接返回该运算元的初始值</p><p>false ,继续下⼀个⽐较</p><p>如果找到最后也没有找到,就返回最后⼀个运算元</p><h2 id="说说什么是函数回调？什么匿名函数"><a href="#说说什么是函数回调？什么匿名函数" class="headerlink" title="说说什么是函数回调？什么匿名函数"></a>说说什么是函数回调？什么匿名函数</h2><p>回调函数：</p><p>⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数</p><p>匿名函数：</p><p>如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，那么这个函数称之为匿名函数</p><h2 id="说出对DOM和document对象的理解"><a href="#说出对DOM和document对象的理解" class="headerlink" title="说出对DOM和document对象的理解"></a>说出对DOM和document对象的理解</h2><p>DOM:⽂档对象模型(Document Object Model)将⻚⾯所有的内容表示为可以修改的对象</p><p>浏览器将我们编写在HTML中的每⼀个元素(Element)都抽象成了⼀个个对象所有这些对象都可以通过JavaScript来对其进⾏访问，那么我们就可以通过JavaScript来操作</p><p>⻚⾯;</p><p>所以，我们将这个抽象过程称之为 ⽂档对象模型(Document Object Model)Document节点表示的整个载⼊的⽹⻚，它的实例是全局的document对象:</p><p>对DOM的所有操作都是从 document 对象开始的</p><p>它是DOM的⼊⼝点，可以从document开始去访问任何节点元素</p><h2 id="说说常⻅的节点（Node）属性"><a href="#说说常⻅的节点（Node）属性" class="headerlink" title="说说常⻅的节点（Node）属性"></a>说说常⻅的节点（Node）属性</h2><p>nodeType</p><p>获取节点的类型</p><p>⽐如 注释节点8 ⽂本节点3 元素节点1</p><p>tagName</p><p>获取元素的标签名词 仅适⽤于Element节点</p><p>nodeName</p><p>获取元素的标签名词 适⽤于任何Node节点</p><p>innerHTML,textContent</p><p>前者将元素中的HTML获取为字符串属性 后者仅仅获取⽂本内容</p><p>outerHTML</p><p>包含了完整的HTML</p><p>相当于innerHTML加上元素本身</p><p>nodeValue/data</p><p>获取⾮元素节点的⽂本内容</p><p>hidden</p><p>⽤于设置元素隐藏(全局属性)</p><h2 id="说说attribute和Property的区别和关系"><a href="#说说attribute和Property的区别和关系" class="headerlink" title="说说attribute和Property的区别和关系"></a>说说attribute和Property的区别和关系</h2><p>attribute</p><p>浏览器解析HTML元素时 会将对应的属性(attribute)放在对应的元素对象上</p><p>具体分为标准的属性和⾮标准的属性</p><p>标准属性: id class href type value等等</p><p>⾮标准属性(⾃定义) :abc age height</p><p>Property</p><p>对于标准的attribute 会在DOM对象上创建对应的property属性</p><p>⼤多数情况下 他们是相互作⽤的 改变其中⼀个 另⼀个也会随之改变</p><p>⼤多数情况 推荐获取attribute 使⽤property⽅式 因为它默认是有类型的</p><h2 id="说说事件冒泡和事件捕获的理解"><a href="#说说事件冒泡和事件捕获的理解" class="headerlink" title="说说事件冒泡和事件捕获的理解"></a>说说事件冒泡和事件捕获的理解</h2><p>事件冒泡:</p><p>从最内层的元素向外依次传递的顺序, 默认是事件冒泡</p><p>事件捕获:</p><p>从外层到内层依次传递的顺序 ,可以通过addEventListener(“click”,fn,true) 监听事件捕获</p><h2 id="说说你对事件委托的理解"><a href="#说说你对事件委托的理解" class="headerlink" title="说说你对事件委托的理解"></a>说说你对事件委托的理解</h2><p>利⽤事件的冒泡机制，以及事件对象中可以准确获知触发事件的元素机制(e.target)，将⼦元素事件委托给⽗元素处理的现象。</p><h2 id="说说load和DOMContentLoaded的区别"><a href="#说说load和DOMContentLoaded的区别" class="headerlink" title="说说load和DOMContentLoaded的区别"></a>说说load和DOMContentLoaded的区别</h2><p>load</p><p>浏览器加载完所有的HTML 还加载完所有的外部资源 样式 图⽚等</p><p>DOMContentLoaded</p><p>HTML⽂档所有资源都加载完成 并构建了DOM树 但是⼀些外部资源还没有加载完成 如图⽚的src</p><h2 id="说说JSON的相关⽤法和应⽤场景"><a href="#说说JSON的相关⽤法和应⽤场景" class="headerlink" title="说说JSON的相关⽤法和应⽤场景"></a>说说JSON的相关⽤法和应⽤场景</h2><p>三种⽤法</p><p>简单值: 数字 字符串 布尔类型</p><p>对象值 key value组成 必须添加双引号 value 可以是简单值 对象值 数组值</p><p>数组值 内容可以是对象值 简单值 数组值</p><p>应⽤场景</p><p>⽹络传输的JSON数据</p><p>项⽬的某些配置⽂件</p><p>⾮关系型数据库将JSON作为存储⽂件</p><h2 id="prefetch-与-preload-的区别是什么"><a href="#prefetch-与-preload-的区别是什么" class="headerlink" title="prefetch 与 preload 的区别是什么"></a>prefetch 与 preload 的区别是什么</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;style&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;main.js&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span> /&gt;</span></code></pre></div><p>preload 是⼀个声明式 fetch，可以强制浏览器在不阻塞 document 的 onload 事件的情况下请<strong>求资源</strong>。 preload 顾名思义就是⼀种预加载的⽅式，它通过声明向浏览器声明⼀个需要提前加载的资源，当资源真正被使⽤的时候⽴即执⾏，就⽆需等待⽹络的消耗</p><p>prefetch 告诉浏览器这个资源将来可能需要，但是什么时间加载这个资源是由浏览器来决定的。若能预测到⽤户的⾏为，⽐如懒加载，点击到其它⻚⾯等则相当于提前预加载了需要的资源</p><h2 id="preload和prefetch的应⽤场景"><a href="#preload和prefetch的应⽤场景" class="headerlink" title="preload和prefetch的应⽤场景"></a>preload和prefetch的应⽤场景</h2><p><strong>webpack优化之preload和prefetch：</strong></p><p>单⻚⾯应⽤由于⻚⾯过多，可能会导致代码体积过⼤，从⽽使得⾸⻚打开速度过慢。所以切分代码，优化⾸屏打开速度尤为重要。但是所有的技术⼿段都不是完美的。当我们切割代码后，⾸屏的js⽂件体积减少了好多。但是也有⼀个</p><p>突出的问题：</p><p>那就是当跳转其他⻚⾯的时候，需要下载相应⻚⾯的js⽂件，这就导致体验极其不好，每⼀次点击访问新⻚⾯都要等待js⽂件下载，然后再去请求接⼝获取数据。频繁出现loading动画的体验真的不好所以如果我们在进⼊⾸⻚后，在浏览器的空闲时间提前下好⽤户可能会点击⻚⾯的js⽂件，这样⾸屏的js⽂件⼤⼩得到了控制，⽽且再点击新⻚⾯的时候，相关的js⽂件已经下载好了，就不再会出现loading动画。</p><p><strong>动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间</strong></p><p>按引⼊情况加载，只需添加注释即可</p><p>代码分割注释：/<em>webpackChunkName: ‘mp-supports’</em>/</p><p>prefetch注释：/* webpackPrefetch: true */</p><p>更多的，可以查看 webpack 注释⿊魔法：<a href="https://webpack.js.org/api/module-methods/#magic-comments">https://webpack.js.org/api/module-methods/#magic-comments</a></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">default</span>: lodash &#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;lodash&quot; */</span> <span class="hljs-comment">/*</span><span class="hljs-comment">webpackPrefetch: true */</span> <span class="hljs-string">&#x27;lodash&#x27;</span>);<span class="hljs-comment">// Multiple possible targets</span><span class="hljs-title function_">import</span>(<span class="hljs-comment">/* webpackInclude: /\.json$/ */</span><span class="hljs-comment">/* webpackExclude: /\.noimport\.json$/ */</span><span class="hljs-comment">/* webpackChunkName: &quot;my-chunk-name&quot; */</span><span class="hljs-comment">/* webpackMode: &quot;lazy&quot; */</span><span class="hljs-comment">/* webpackPrefetch: true */</span><span class="hljs-comment">/* webpackPreload: true */</span><span class="hljs-string">`./locale/<span class="hljs-subst">$&#123;language&#125;</span>`</span>)</code></pre></div><h2 id="如何实现⻚⾯⽂本不可复制"><a href="#如何实现⻚⾯⽂本不可复制" class="headerlink" title="如何实现⻚⾯⽂本不可复制"></a><strong>如何实现⻚⾯⽂本不可复制</strong></h2><p>有 CSS 和 JS 两种⽅法，以下任选其⼀或结合使⽤</p><p>使⽤ CSS 如下：</p><div class="code-wrapper"><pre><code class="hljs css">user-select: none;</code></pre></div><p>或使⽤ JS 如下，监听 selectstart 事件，禁⽌选中。</p><p>当⽤户选中⼀⽚区域时，将触发 selectstart 事件，Selection API 将会选中⼀⽚区域。禁⽌选中区域即可实现⻚⾯⽂本不可复制。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">onselectstart</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;e.<span class="hljs-title function_">preventDefault</span>();&#125;;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">oncopy</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;e.<span class="hljs-title function_">preventDefault</span>();&#125;;</code></pre></div><h2 id="DOM-中-Element-与-Node-有何区别"><a href="#DOM-中-Element-与-Node-有何区别" class="headerlink" title="DOM 中 Element 与 Node 有何区别"></a><strong>DOM 中 Element 与 Node 有何区别</strong></h2><p>Element 继承于 Node，具有 Node 的⽅法，同时⼜拓展了很多⾃⼰的特有⽅法</p><h2 id="点击-a-标签下载⽂件如何做"><a href="#点击-a-标签下载⽂件如何做" class="headerlink" title="点击 a 标签下载⽂件如何做"></a>点击 a 标签下载⽂件如何做</h2><p>有两种⽅式:</p><p>a.download 当指定 a 标签的 download 属性时，点击该链接会直接保存为⽂件，⽂件名为</p><p>download 属性</p><p>通过对 a 标签指定的 URL 在服务器设置响应头 Content-Disposition: attachment;</p><p>filename=”filename.jpg” 可直接下载</p>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-html-css</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-html-css/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-html-css/</url>
    
    <content type="html"><![CDATA[<h1 id="01-HTML-CSS-常⻅⾯试题"><a href="#01-HTML-CSS-常⻅⾯试题" class="headerlink" title="01-HTML-CSS-常⻅⾯试题"></a>01-HTML-CSS-常⻅⾯试题</h1><h2 id="1-HTML-标签有哪些⾏内元素"><a href="#1-HTML-标签有哪些⾏内元素" class="headerlink" title="1.HTML 标签有哪些⾏内元素"></a><strong>1.HTML</strong> <strong>标签有哪些⾏内元素</strong></h2><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-tag">img</span>picture<span class="hljs-selector-tag">span</span><span class="hljs-selector-tag">input</span><span class="hljs-selector-tag">textarea</span>selectlabe</code></pre></div><h2 id="2-说说你对元素语义化的理解"><a href="#2-说说你对元素语义化的理解" class="headerlink" title="2.说说你对元素语义化的理解"></a><strong>2.说说你对元素语义化的理解</strong></h2><p>元素语义化就是⽤正确的元素做正确的事情。虽然在理论上，所以的html元素都可以通过css样式实现</p><p>相同的事情，但是这么做会使事情复杂化，所以我们需要元素语义化来降低复杂度。</p><p>元素语义化在我们实际的开发中有很多好处，⽐如：</p><p>提⾼代码的阅读性和可维护性;</p><p>减少coder之间的沟通成本;</p><p>能让语⾳合成⼯具正确识别⽹⻚元素的⽤途，以便做出正确的反应</p><p>有利于SEO(Search Engine Optimization)</p><h2 id="3-HTML-中有哪些语义化标签"><a href="#3-HTML-中有哪些语义化标签" class="headerlink" title="3.HTML 中有哪些语义化标签"></a><strong>3.HTML</strong> <strong>中有哪些语义化标签</strong></h2><ul><li>header</li><li>footer</li><li>main</li><li>aside</li><li>article</li><li>section</li><li>address</li><li>summary/details</li><li>menu</li><li>h1/h2/h3/h4/h5/h6</li><li>img</li><li>p</li><li>strong/italic</li></ul><h2 id="4-什么是-URL-编码-URL-Encode"><a href="#4-什么是-URL-编码-URL-Encode" class="headerlink" title="4.什么是 URL 编码 (URL Encode)"></a><strong>4.什么是</strong> <strong>URL</strong> <strong>编码</strong> <strong>(URL Encode)</strong></h2><p>encodeURI ⽤来编码<strong>URI</strong>，其不会编码保留字符。</p><p>encodeURIComponent ⽤来编码 URI<strong>参数</strong>，除了字符：A-Z a-z 0-9 - _ . ! ~ * ‘ ( )，都将会转义</p><h2 id="5-说说你对SEO-的理解"><a href="#5-说说你对SEO-的理解" class="headerlink" title="5.说说你对SEO****的理解"></a><strong>5.说说你对</strong>SEO****的理解</h2><p>SEO就是搜索引擎优化(Search Engine Optimization)，SEO通过了解搜索引擎的运⾏规则来调整⽹站，</p><p>以提⾼⽹站的曝光度,以及⽹站的排名。</p><p>Google 搜索引擎的⼯作流程主要分为三个阶段：</p><p><strong>抓取</strong>：Google 会使⽤名为“抓取⼯具”的⾃动程序搜索⽹络，以查找新⽹⻚或更新后的⽹⻚。Google 会</p><p>将这些⽹⻚的地址（即⽹址）存储在⼀个⼤型列表中，以便⽇后查看。我们会通过许多不同的⽅法查找</p><p>⽹⻚，但主要⽅法是跟踪我们已知的⽹⻚中的链接。</p><p><strong>编⼊索引</strong>：Google 会访问它通过抓取得知的⽹⻚，并会尝试分析每个⽹⻚的主题。Google 会分析⽹⻚</p><p>中的内容、图⽚和视频⽂件，尝试了解⽹⻚的主题。这些信息存储在 Google 索引中，⽽ Google 索引</p><p>是⼀个存储在海量计算机中的巨⼤数据库。</p><p><strong>呈现搜索结果</strong>：当⽤户在 Google 上进⾏搜索时，Google 会尝试确定最优质的搜索结果。“最佳”结果取</p><p>决于许多因素，包括⽤户的位置、语⾔、设备（桌⾯设备或⼿机）以及先前⽤过的搜索查询。例如，在</p><p>⽤户搜索“⾃⾏⻋维修店”后，Google 向巴黎⽤户显示的答案与向⾹港⽤户显示的答案有所不同。⽀付费</p><p>⽤不能提⾼⽹⻚在 Google 搜索结果中的排名，⽹⻚排名是完全依靠算法完成的。</p><h2 id="6-’-’-与-‘-’-选择器有什么不同"><a href="#6-’-’-与-‘-’-选择器有什么不同" class="headerlink" title="6.’+’ 与 ‘~’ 选择器有什么不同"></a><strong>6.’+’</strong> <strong>与</strong> <strong>‘~’</strong> <strong>选择器有什么不同</strong></h2><p>~ 是匹配元素之后的选择器</p><p>+ 是匹配相邻元素选择器</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是div下⾯的p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是div下⾯的p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css"><span class="hljs-selector-tag">div</span>+<span class="hljs-selector-tag">p</span> &#123;</span><span class="language-css"><span class="hljs-attribute">color</span>: red;</span><span class="language-css"> &#125;</span><span class="language-css"><span class="hljs-comment">/* 第⼀个p标签变红⾊了 */</span></span><span class="language-css"><span class="hljs-selector-tag">div</span>~<span class="hljs-selector-tag">p</span>&#123;</span><span class="language-css"><span class="hljs-attribute">color</span>:red;</span><span class="language-css"> &#125;</span><span class="language-css"><span class="hljs-comment">/* div后⾯的p标签都变成红⾊了 */</span></span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h2 id="7-说明text-align-居中的条件"><a href="#7-说明text-align-居中的条件" class="headerlink" title="7.说明text-align****居中的条件"></a><strong>7.说明</strong>text-align****居中的条件</h2><ul><li>text-align : 直接翻译过来设置⽂本的⽔平对⻬⽅式 (是继承属性)(是继承属性)</li><li>text-align 并不控制块元素⾃⼰的对⻬，只控制它的⾏内内容的对⻬</li><li>MDN解释: 定义⾏内内容（例如⽂字）如何相对它的块⽗元素对⻬(可以设置图⽚居中)</li><li>W3C官⽅⽂档解释: 设置⾏内(inline-level)元素(没有填满⽗元素)在快级⽗元素的对⻬⽅式</li></ul><h2 id="8-line-height为什么可以让⽂字垂直居中？"><a href="#8-line-height为什么可以让⽂字垂直居中？" class="headerlink" title="8. line-height为什么可以让⽂字垂直居中？"></a><strong>8. line-height</strong>为什么可以让⽂字垂直居中？</h2><p>line-height :两⾏⽂字基线( baseline )之间的间距 基线( baseline`):与⼩写字⺟x最底部对⻬的线</p><p>⼀⾏⽂本 等于 line-height</p><p>⾏⾼ - ⽂本⾼度 = ⾏距</p><p>属性值:</p><p>normal :取决于⽤户端。桌⾯浏览器（包括Firefox）使⽤默认值，约为1.2，这取决于元素的</p><p>font-family</p><p>&lt;数字&gt; :该属性的应⽤值是这个⽆单位数字&lt;数字&gt;乘以该元素的字体⼤⼩ 这是设置line</p><p>height的推荐⽅法，不会在继承时产⽣不确定的结果</p><p>&lt;⻓度&gt; :指定&lt;⻓度&gt;⽤于计算 line box 的⾼度 以 em 为单位的值可能会产⽣不确定的结果</p><p>&lt;百分⽐&gt; :与元素⾃身的字体⼤⼩有关。计算值是给定的百分⽐值乘以元素计算出的字体⼤</p><p>⼩。百分⽐值可能会带来不确定的结果</p><p>height :元素的整体⾼度 line-height :元素中每⼀⾏⽂字所占据的⾼度</p><p>假设div中只有⼀⾏⽂字，如何让这⾏⽂字在div内部垂直居中 让 line-height 等同于 height</p><h2 id="9-说说盒⼦模型包含哪些内容？"><a href="#9-说说盒⼦模型包含哪些内容？" class="headerlink" title="**9.**说说盒⼦模型包含哪些内容？"></a>**9.**说说盒⼦模型包含哪些内容？</h2><ul><li><p>内容</p><p>​         通过宽度和⾼度设置</p></li><li><p>内边距</p><p>​        通过padding设置</p></li><li><p>padding: </p><p>​        padding-top padding-right padding-bottom padding-left;</p></li><li><p>边框</p><p>​        通过border设置</p><p>​        border: border-width border-style border-color</p><ul><li><p>外边距</p><p> 通过margin设置</p><p>margin: margin-top margin-right margin-bottom margin-left</p></li></ul></li></ul><h2 id="10-说说你对margin-的传递和折叠的理解"><a href="#10-说说你对margin-的传递和折叠的理解" class="headerlink" title="*10.说说你对margin***的传递和折叠的理解"></a>*<em>10.<strong>说说你对</strong></em><em>margin</em>***的传递和折叠的理解</h2><ul><li>margin的传递⼀般是⽗⼦块元素之间,有margin-top传递,margin-bottom传递.<ul><li>margin-top传递: 当块级元素的顶部线和⽗元素的顶部线重叠，那么这个块级元素的margin-top值会传递给⽗元素</li><li>margin-bottom传递:当块级元素的底部线和⽗元素的底部线重叠，那么这个块级元素的margin</li></ul></li><li>bottom值会传递给⽗元素</li><li>折叠: 指的是 垂直⽅向上相邻的2个margin（margin-top、margin-bottom）有可能会合并为1个margin.</li><li>它有两个兄弟块级元素之间的上下margin的折叠,也有⽗⼦块元素之间的margin折叠</li></ul><h2 id="11-CSS-隐藏⻚⾯中某个元素的⼏种⽅法"><a href="#11-CSS-隐藏⻚⾯中某个元素的⼏种⽅法" class="headerlink" title="11.CSS 隐藏⻚⾯中某个元素的⼏种⽅法"></a><strong>11.CSS</strong> <strong>隐藏⻚⾯中某个元素的⼏种⽅法</strong></h2><p>display: none</p><p>​    通过 CSS 操控 display，移出⽂档流</p><p>opacity: 0</p><p>​    透明度为 0，仍在⽂档流中，当作⽤于其上的事件(如点击)仍有效</p><p>visibility: hidden</p><p>​    透明度为 0，仍在⽂档流中，<strong>但作⽤于其上的事件</strong>**(<strong><strong>如点击</strong></strong>)**<strong>⽆效</strong>，这也是</p><p>visibility:hidden 与 opacity: 0 的区别</p><p>​    content-visibility</p><p>​    移出⽂档流，但是再次显示时消耗性能低</p><p>​    绝对定位于当前⻚⾯的不可⻅位置    </p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">top</span>: -<span class="hljs-number">9000px</span>;<span class="hljs-attribute">left</span>: -<span class="hljs-number">9000px</span>;</code></pre></div><h2 id="12-box-sizing有什么作⽤？content-box和-border-box的区别"><a href="#12-box-sizing有什么作⽤？content-box和-border-box的区别" class="headerlink" title="12.box-sizing有什么作⽤？content-box和****border-box的区别"></a><strong>12.box-sizing</strong>有什么作⽤？<strong><strong>content-box</strong></strong>和****border-box的区别</h2><p>box-sizing⽤来设置盒⼦模型中宽⾼的计算⽅式：</p><p>​    content-box: padding、border都布置在width、height外边</p><p>​    border-box: padding、border都布置在width、height⾥边</p><h2 id="13-为什么会发⽣样式抖动"><a href="#13-为什么会发⽣样式抖动" class="headerlink" title="**13.**为什么会发⽣样式抖动"></a>**13.**为什么会发⽣样式抖动</h2><p>因为没有指定元素具体⾼度和宽度,⽐如数据还没有加载进来时元素⾼度是 100px(假设这⾥是100px)</p><p>数据加载进来后,因为有了数据,然后元素被撑⼤,所有出现了抖动</p><h2 id="14-说说浮动常⻅的规则？"><a href="#14-说说浮动常⻅的规则？" class="headerlink" title="**14.**说说浮动常⻅的规则？"></a>**14.**说说浮动常⻅的规则？</h2><ul><li><p>元素⼀旦浮动后, 脱离标准流</p><p>​    朝着向左或向右⽅向移动，直到⾃⼰的边界紧贴着包含块（⼀般是⽗元素）或者其他浮动元素的边界为⽌</p></li><li><p>定位元素会层叠在浮动元素上⾯</p><p>​    如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界</p></li><li><p>浮动元素之间不能层叠</p><p>​    如果⼀个元素浮动，另⼀个浮动元素已经在那个位置了，后浮动的元素将紧贴着前⼀个浮动元素（左浮找左浮，右浮找右浮）</p><p>​    如果⽔平⽅向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充⾜的空间为⽌</p></li><li><p>浮动元素不能与⾏内级内容层叠，⾏内级内容将会被浮动元素推出</p><p>​    ⽐如⾏内级元素、inline-block元素、块级元素的⽂字内容</p><p>​    ⾏内级元素、inline-block元素浮动后，其顶部将与所在⾏的顶部对⻬</p></li></ul><h2 id="15-为什么需要清除浮动？清除浮动有⼏种⽅法？"><a href="#15-为什么需要清除浮动？清除浮动有⼏种⽅法？" class="headerlink" title="**15.**为什么需要清除浮动？清除浮动有⼏种⽅法？"></a>**15.**为什么需要清除浮动？清除浮动有⼏种⽅法？</h2><p><strong>为什么需要清除浮动：</strong></p><p>1）由于浮动元素脱离了标准流，变成了浮动元素，不再向⽗元素汇报⾼度。所以⽗元素在计算⾼度时</p><p>并没有将浮动元素的⾼度计算进来，因此就造成了⾼度塌陷的问题 。解决⾼度塌陷的问题就叫做清除浮动（3分）</p><p>2）清除浮动的⽬的：是为了让⽗元素在计算⾼度的时候把浮动⼦元素的⾼度计算进去</p><p><strong>清除浮动有⼏种⽅法：</strong></p><p>给⽗元素设置固定⾼度，扩展性不好，不推荐</p><p>在⽗元素的最后增加⼀个空的块级⼦元素，并设置让他clear:both , 但是增加了⽆意义的空标签，</p><p>违反了结构与样式分离的原则</p><p>给⽗元素添加⼀个伪元素(推荐)</p><div class="code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clear_fix</span><span class="hljs-selector-pseudo">::after</span> &#123;<span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-attribute">display</span>: block;<span class="hljs-attribute">clear</span>:both;<span class="hljs-attribute">visibility</span>: hidden; <span class="hljs-comment">/* 浏览器兼容性 */</span><span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 浏览器兼容性 */</span>&#125;<span class="hljs-selector-class">.clear_fix</span> &#123; *zoom: <span class="hljs-number">1</span>; <span class="hljs-comment">/* IE6/7兼容性 */</span>&#125;</code></pre></div><p>overflflow:auto触发BFC来清除浮动（前提⾼度为auto）</p><h2 id="16-伪类与伪元素有什么区别"><a href="#16-伪类与伪元素有什么区别" class="headerlink" title="16.伪类与伪元素有什么区别?"></a><strong>16.<strong>伪类与伪元素有什么区别</strong></strong>?</h2><p>伪类使⽤单冒号，⽽伪元素使⽤双冒号。如 :hover 是伪类， ::before 是伪元素</p><p>伪元素会在⽂档流⽣成⼀个新的元素，并且可以使⽤ content 属性设置内容</p><h2 id="17-结构伪类-nth-child-n-和nth-of-type-n-的区别？"><a href="#17-结构伪类-nth-child-n-和nth-of-type-n-的区别？" class="headerlink" title="*17.结构伪类*nth-child(n)和nth-of-type(n)****的区别？"></a>*<em>17.<strong>结构伪类</strong></em>*nth-child(n)<strong><strong>和</strong></strong>nth-of-type(n)****的区别？</h2><p>:nth-child</p><p>是结构伪类选择器，选中⽗元素的第⼏个⼦元素 , 计数时与元素的类型⽆关。</p><p>:nth-of-type</p><p>是结构伪类选择器和nth-child类似，但是计数时只计算同种类型的元素。</p>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react18 学习笔记</title>
    <link href="/2022/08/30/react18-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/30/react18-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="React开发依赖"><a href="#React开发依赖" class="headerlink" title="React开发依赖"></a>React开发依赖</h4><p>react开发必须依赖三个库：</p><ul><li><p>react   包含react所有必须的核心代码</p></li><li><p>react-dom react渲染在不同平台所需要的核心代码</p></li><li><p>babel  将jsx转换成React代码的工具</p><p>react 包含react web和react-native所拥有的核心代码</p><p>react-dom针对web和native完成的事情不同</p><p>​    web端react-dom会将jsx最终渲染成真实的DOM，显示在浏览器</p><p>​    native端 react-dom会将jsx最终渲染成原生的控件</p><p>babel是将jsx代码转成react.createElement</p></li></ul><h4 id="React组件化开发"><a href="#React组件化开发" class="headerlink" title="React组件化开发"></a>React组件化开发</h4><p>​    react中数据依赖来自两方面</p><p>​        参与界面更新的数据   当数据变量时，需要更新组件渲染的内容</p><p>​        不参与界面更新的数据  当数据变量时，不需要更新将组建渲染的内容，参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中，我们可以通过在构造函数中 this.state = {定义的数据}</p><p> 当我们的数据发生变化时，我们可以调用 this.setState 来更新数据，并且通知React进行update操作；在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面</p><ul><li><p>根据组件的定义方式，可以分为：函数组件(Functional Component )和类组件(Class Component)；</p></li><li><p>根据组件内部是否有状态需要维护，可以分成：无状态组件(Stateless Component )和有状态组件(Stateful Component)；</p></li><li><p>根据组件的不同职责，可以分成：展示型组件(Presentational Component)和容器型组件(Container Component)；</p></li><li><p>函数组件、无状态组件、展示型组件主要关注UI的展示；</p></li><li><p>类组件、有状态组件、容器型组件主要关注数据逻辑</p></li></ul><h4 id="JSX的条件渲染"><a href="#JSX的条件渲染" class="headerlink" title="JSX的条件渲染"></a>JSX的条件渲染</h4><p>​    在react中，所有条件判断都和普通的js代码一致，而vue中会使用v-if/v-show等来控制，react中没有这样封装好的指令</p><p>​    react常见的条件渲染方式</p><ul><li><p>条件判断语句</p></li><li><p>三元运算符</p></li><li><p>与运算符&amp;&amp;</p></li><li><p>display来控制</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;    <span class="hljs-comment">// 1.定义App根组件</span>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">super</span>()        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;          <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,          <span class="hljs-attr">isReady</span>: <span class="hljs-literal">false</span>,          <span class="hljs-attr">friend</span>: <span class="hljs-literal">undefined</span>        &#125;      &#125;      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> &#123; isReady, friend &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>        <span class="hljs-comment">// 1.条件判断方式一: 使用if进行条件判断</span>        <span class="hljs-keyword">let</span> showElement = <span class="hljs-literal">null</span>        <span class="hljs-keyword">if</span> (isReady) &#123;          showElement = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>准备开始比赛吧<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>        &#125; <span class="hljs-keyword">else</span> &#123;          showElement = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>请提前做好准备!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>        &#125;        <span class="hljs-keyword">return</span> (          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">            &#123;/* 1.方式一: 根据条件给变量赋值不同的内容 */&#125;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;showElement&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">            &#123;/* 2.方式二: 三元运算符 */&#125;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; isReady ? <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>开始战斗!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>赶紧准备<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span> &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">            &#123;/* 3.方式三: &amp;&amp;逻辑与运算 */&#125;</span><span class="language-xml">            &#123;/* 场景: 当某一个值, 有可能为undefined时, 使用&amp;&amp;进行条件判断 */&#125;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; friend &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;friend.name + &quot; &quot; + friend.desc&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>        )      &#125;    &#125;    <span class="hljs-comment">// 2.创建root并且渲染App组件</span>    <span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>))    root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>)  &lt;/script&gt;</code></pre></div></li></ul><p>1.react中，方法中this的默认是指向undefined的，</p><p>  2.vscode创建用户代码片段<br>3.<br> <div class="code-wrapper"><pre><code class="hljs js">jsx写注释&#123;<span class="hljs-comment">/* */</span>&#125; <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        &#123;/*这是一段注释*/&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;</code></pre></div></p><p>​    4.</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">//这三个值无法在jsx中渲染出来</span>   test1:<span class="hljs-literal">undefined</span>   test2:<span class="hljs-literal">null</span>   text3:<span class="hljs-literal">false</span></code></pre></div><p>5.在jsx中对象类型不可以作为子元素,进行直接展示</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.state.obj&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>6.jsx嵌入表达式<br>    运算表达式<br>    三元运算符<br>    执行一个函数</p><p>7.jsx中的class用className<br>8.jsx中style的写法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&quot;<span class="hljs-attr">red</span>&quot;,<span class="hljs-attr">fontSzie:</span>&quot;<span class="hljs-attr">24px</span>&quot;&#125;&#125;&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div><p>9.react的事件绑定<br>    react的事件绑定方法中this默认是undefined<br>    this的绑定的三种方式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;    <span class="hljs-comment">// class fields</span>    name = <span class="hljs-string">&quot;App&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-comment">//类组件继承一定要加super()并且必须写在最上面</span>      <span class="hljs-variable language_">super</span>()      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,        <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span>      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">btn1Click</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">btn1Click</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">btn1Click</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn1Click&quot;</span>, <span class="hljs-variable language_">this</span>);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span> &#125;)    &#125;    btn2Click = <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn2Click&quot;</span>, <span class="hljs-variable language_">this</span>)      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">1000</span> &#125;)    &#125;    <span class="hljs-title function_">btn3Click</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn3Click&quot;</span>, <span class="hljs-variable language_">this</span>);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">9999</span> &#125;)    &#125;    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">const</span> &#123; message &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>      <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          &#123;/* 1.this绑定方式一: bind绑定 */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btn1Click&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          </span><span class="language-xml">          &#123;/* 2.this绑定方式二: ES6 class fields */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btn2Click&#125;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml">          &#123;/* 3.this绑定方式三: 直接传入一个箭头函数(重要) */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> console.log(&quot;btn3Click&quot;)&#125;&gt;按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.btn3Click()&#125;&gt;按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前计数: &#123;this.state.counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>      )    &#125;  &#125;  <span class="hljs-comment">// 2.创建root并且渲染App组件</span>  <span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>))  root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>)</code></pre></div><p> 10.react事件的传参</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(e)</span>=&gt;</span>&#123;         this.click3(e,item,name)       &#125;&#125;&gt;点击3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><p>​        可以用来传递event<br>​<br> 在执行事件函数时，有可能我们需要获取一些参数信息：比如event对象、其他参数<br> 情况一：获取event对象<br> 很多时候我们需要拿到event对象来做一些事情（比如阻止默认行为）<br> 假如我们用不到this，那么直接传入函数就可以获取到event对象；<br> 情况二：获取更多参数<br> 有更多参数时，我们最好的方式就是传入一个箭头函数，主动执行的事件函数，并且传入相关的其他参数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">const</span> &#123; message &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>      <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          &#123;/* 1.event参数的传递 */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick.bind(this)&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event)</span> =&gt;</span> this.btnClick(event)&#125;&gt;按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          </span><span class="language-xml">          &#123;/* 2.额外的参数传递 */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick.bind(this,</span> &quot;<span class="hljs-attr">kobe</span>&quot;, <span class="hljs-attr">30</span>)&#125;&gt;</span>按钮3(不推荐)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event)</span> =&gt;</span> this.btnClick(event, &quot;why&quot;, 18)&#125;&gt;按钮4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>      )    &#125;</code></pre></div><p> 11.react的列表渲染使用最多的是使用map<br>     过滤filter<br>     截取slice<br> 12.React.createElement() jsx是他的语法糖</p><p>​    createElement需要传递三个参数</p><ul><li><p>type      当前ReactElement的类型，如果是标签元素，那么就使用字符串表示div,如果是组件元素就用组件的名称</p></li><li><p>config    所有jsx中的属性在config中都是对象的属性和值的形式存在，例如className作为class</p></li><li><p>children  存放在标签中的内容都是以children数组的形式存储</p><p><img src="https://img1.imgtp.com/2022/09/12/pgiZpbQL.png" alt="QQ截图20220912114717.png"></p></li></ul><p> 13.render() 将virtual Dom=&gt;Dom<br> 14.频繁的操作DOM，会产生回流和重绘<br> 15.React 组件名称首字母必须大写 html标签必须小写<br>     类组件需要继承自 React.Component<br>      类组件必须实现render函数<br> 16.函数式组件<br>      没有生命周期，也会被更新并挂载，但是没有生命周期函数；<br>      没有this(组件实例）；<br>     没有内部状态（state）<br> 17.render函数、函数式组件的返回类型<br>         组件，html元素<br>         数组、fragments<br>         Portals<br>         字符串或者数值类型<br>         Boolean，null<br> 18.react的生命周期</p><p>生命周期图谱</p><img src="https://img1.imgtp.com/2022/09/12/X4cHBQk6.png" alt="QQ截图20220912132938.png" style="zoom:200%;" /><img src="https://img1.imgtp.com/2022/09/12/ACO5RXp5.png" alt="QQ截图20220912133029.png" style="zoom:200%;" /><p> 常用的生命周期函数     </p><div class="code-wrapper"><pre><code class="hljs">    1.contructor()&#123;    &#125;     如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。     constructor中通常只做两件事情：     通过给 this.state 赋值对象来初始化内部的state；     为事件绑定实例（this）；    2.componentDidMount()      componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用          可以进行网络请求，添加订阅，DOM操作    3.componentDidUpdate(prevProps, prevState, snapshot)      会在更行后立即调用，首次渲染不会执行，可以使用setState方法，但是必须用于条件语句，当组件更新后，可以在此处对 DOM 进行操作，如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求    4.componentWillUnmount()      可以用于清楚timer,取消网络请求，取消订阅    5.不常用的生命周期      getDerivedStateFromProps：state 的值在任何时候都依赖于 props时使用；该方法返回一个对象来更新state；      getSnapshotBeforeUpdate：在React更新DOM之前回调的一个函数，可以获取DOM更新前的一些信息（比如说滚动位置）      shouldComponentUpdate：当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</code></pre></div><p>   19.组件通信<br>         1.父组件向子组件传递数据 传递参数是常量非string的时候要将其当作变量用{}</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Children2</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;里斯&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&#123;55&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children2</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs">     2.子组件向父组件传递数据，定义回调函数传递给子组件调用</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;import AddCounter from &#x27;./AddCounter&#x27;import SubCounter from &#x27;./SubCounter&#x27;export class App extends Component &#123;  constructor() &#123;    super()    this.state = &#123;      counter: 100    &#125;  &#125;  changeCounter(count) &#123;    this.setState(&#123; counter: this.state.counter + count &#125;)  &#125;  render() &#123;    const &#123; counter &#125; = this.state    return (      &lt;div&gt;        &lt;h2&gt;当前计数: &#123;counter&#125;&lt;/h2&gt;        &lt;AddCounter addClick=&#123;(count) =&gt; this.changeCounter(count)&#125;/&gt;        &lt;SubCounter subClick=&#123;(count) =&gt; this.changeCounter(count)&#125;/&gt;      &lt;/div&gt;    )  &#125;&#125;export default App</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;// import PropTypes from &quot;prop-types&quot;export class AddCounter extends Component &#123;  addCount(count) &#123;    this.props.addClick(count)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(1)&#125;&gt;+1&lt;/button&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(5)&#125;&gt;+5&lt;/button&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(10)&#125;&gt;+10&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;// AddCounter.propTypes = &#123;//   addClick: PropTypes.func// &#125;export default AddCounter</code></pre></div><div class="code-wrapper"><pre><code class="hljs">    3.跨组件通信Context，可以使用组件的组合来替代Context        </code></pre></div><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> React from <span class="hljs-string">&quot;react&quot;</span><span class="hljs-comment">// 1.创建一个Context并且设置默认值</span><span class="hljs-type">const</span> ThemeContext = React.<span class="hljs-built_in">createContext</span>(&#123; color: <span class="hljs-string">&quot;blue&quot;</span>, size: <span class="hljs-number">10</span> &#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ThemeContext</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-comment">// 1.创建一个Context</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UserContext</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//App.js//多个context传递数据的方式&lt;UserContext.Provider value=&#123;&#123;nickname: &quot;kobe&quot;, age: 30&#125;&#125;&gt;          &lt;ThemeContext.Provider value=&#123;&#123;color: &quot;red&quot;, size: &quot;30&quot;&#125;&#125;&gt;            &lt;Home &#123;...info&#125;/&gt;          &lt;/ThemeContext.Provider&gt; &lt;/UserContext.Provider&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//类组件的接受方式import React, &#123; Component &#125; from &#x27;react&#x27;import ThemeContext from &#x27;./context/theme-context&#x27;export class Profile extends Component &#123;  render() &#123;    console.log(this.context)    return (      &lt;div&gt;Profile&lt;/div&gt;    )  &#125;&#125;Profile.contextType = ThemeContextexport default Profile</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//函数式组件的接收方式import ThemeContext from &quot;./context/theme-context&quot;function HomeBanner() &#123;  return &lt;div&gt;    &#123;/* 函数式组件中使用Context共享的数据 */&#125;    &lt;ThemeContext.Consumer&gt;      &#123;        value =&gt; &#123;          return &lt;h2&gt; Banner theme:&#123;value.color&#125;&lt;/h2&gt;        &#125;      &#125;    &lt;/ThemeContext.Consumer&gt;  &lt;/div&gt;&#125;export default HomeBanner</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;import ThemeContext from &#x27;./context/theme-context&#x27;import UserContext from &#x27;./context/user-context&#x27;export class HomeInfo extends Component &#123;  //static contextType=ThemeContext 这种写法也可以  render() &#123;    // 4.第四步操作: 获取数据, 并且使用数据    console.log(this.context)    return (      &lt;div&gt;        &lt;h2&gt;HomeInfo: &#123;this.context.color&#125;&lt;/h2&gt;        &lt;UserContext.Consumer&gt;          &#123;            value =&gt; &#123;              return &lt;h2&gt;Info User: &#123;value.nickname&#125;&lt;/h2&gt;            &#125;          &#125;        &lt;/UserContext.Consumer&gt;      &lt;/div&gt;    )  &#125;&#125;// 3.第三步操作: 设置组件的contextType为某一个ContextHomeInfo.contextType = ThemeContextHomeInfo.displayName = &#x27;MyDisplayName&#x27;;//设置在devtool的显示名字export default HomeInfo</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//多个context的使用// Theme context，默认的 theme 是 “light” 值const ThemeContext = React.createContext(&#x27;light&#x27;);// 用户登录 contextconst UserContext = React.createContext(&#123;  name: &#x27;Guest&#x27;,&#125;);class App extends React.Component &#123;  render() &#123;    const &#123;signedInUser, theme&#125; = this.props;    // 提供初始 context 值的 App 组件    return (      &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;        &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt;          &lt;Layout /&gt;        &lt;/UserContext.Provider&gt;      &lt;/ThemeContext.Provider&gt;    );  &#125;&#125;function Layout() &#123;  return (    &lt;div&gt;      &lt;Sidebar /&gt;      &lt;Content /&gt;    &lt;/div&gt;  );&#125;// 一个组件可能会消费多个 contextfunction Content() &#123;  return (    &lt;ThemeContext.Consumer&gt;      &#123;theme =&gt; (        &lt;UserContext.Consumer&gt;          &#123;user =&gt; (            &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt;          )&#125;        &lt;/UserContext.Consumer&gt;      )&#125;    &lt;/ThemeContext.Consumer&gt;  );&#125;</code></pre></div><p>**什么时候使用Context.Consumer呢？</p><p>.当使用value的组件是一个函数式组件时；</p><p>.当组件中需要使用多个Context时；</p><p> 4.使用事件总线<br>   20.对props进行类型检查 propTypes</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;prop-types&quot;</span><span class="hljs-title class_">Children2</span>.<span class="hljs-property">propTypes</span> = &#123;          <span class="hljs-comment">// 必填属性</span>          <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,          <span class="hljs-attr">age</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,          <span class="hljs-attr">time</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">array</span>        &#125;;        <span class="hljs-comment">// 可以定义默认·值</span><span class="hljs-title class_">Children2</span>.<span class="hljs-property">defaultProps</span>=&#123;          <span class="hljs-attr">time</span>:[<span class="hljs-string">&quot;2022/5/11&quot;</span>,<span class="hljs-string">&quot;2022/5/6&quot;</span>]        &#125;</code></pre></div><p> 21.props为什么不写也是可以的   </p><div class="code-wrapper"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><span class="hljs-comment"><span class="hljs-function">      super()</span></span><span class="hljs-comment"><span class="hljs-function">      this.state=&#123;&#125;</span></span><span class="hljs-function">    &#125;</span><span class="hljs-function"> 因为<span class="hljs-title">react</span>内部会强制性给当前实例复制<span class="hljs-title">props</span></span><span class="hljs-function"> <span class="hljs-title">this</span>.<span class="hljs-title">instance</span>=<span class="hljs-title">element</span>.<span class="hljs-title">props</span></span></code></pre></div><p>22.组件插槽的实现</p><div class="code-wrapper"><pre><code class="hljs html"> //App.js<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        &#123;/* 1.使用children实现插槽 */&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">NavBar</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体文本<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">NavBar</span>&gt;</span>        &#123;/* 2.使用props实现插槽 */&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">NavBarTwo</span> </span><span class="hljs-tag">          <span class="hljs-attr">leftSlot</span>=<span class="hljs-string">&#123;btn&#125;</span></span><span class="hljs-tag">          <span class="hljs-attr">centerSlot</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">h2</span>&gt;</span>呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>&#125;          rightSlot=&#123;<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体2<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#125;        /&gt;      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//NavBar.jsexport class NavBar extends Component &#123;  render() &#123;    const &#123; children &#125; = this.props    console.log(children)    return (      &lt;div className=&#x27;nav-bar&#x27;&gt;        &lt;div className=&quot;left&quot;&gt;&#123;children[0]&#125;&lt;/div&gt;        &lt;div className=&quot;center&quot;&gt;&#123;children[1]&#125;&lt;/div&gt;        &lt;div className=&quot;right&quot;&gt;&#123;children[2]&#125;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//NavBarTwo.jsimport React, &#123; Component &#125; from &#x27;react&#x27;export class NavBarTwo extends Component &#123;  render() &#123;    const &#123; leftSlot, centerSlot, rightSlot &#125; = this.props    return (      &lt;div className=&#x27;nav-bar&#x27;&gt;        &lt;div className=&quot;left&quot;&gt;&#123;leftSlot&#125;&lt;/div&gt;        &lt;div className=&quot;center&quot;&gt;&#123;centerSlot&#125;&lt;/div&gt;        &lt;div className=&quot;right&quot;&gt;&#123;rightSlot&#125;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre></div><p>通过children实现的方案虽然可行，但是有一个弊端：通过索引值获取传入的元素很容易出错，不能精准的获取传入的原生</p><p>23.setState<br>   setState是异步更新，可以显著提升性能<br>   如果每一次调用setState都进行一次更新，那么意味着render函数需要频繁的调用<br>   最好的办法是获取多个更新，之后进行批量更新<br>   如果同步更新了state,但是还没执行render函数，那么state和props不能保持同步<br>   state和props不能保持一致性，会在开发中产生很多问题</p><p>   为了拿到异步更新后的数据</p><p>​    setState的三种写法</p><p>​    </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 1.setState更多用法</span>   <span class="hljs-comment">// 1.基本使用</span>   <span class="hljs-comment">// this.setState(&#123;</span>   <span class="hljs-comment">//   message: &quot;你好啊, 李银河&quot;</span>   <span class="hljs-comment">// &#125;)</span>   <span class="hljs-comment">// 2.setState可以传入一个回调函数,回调 函数中接收的 state 和 props 都保证为最新。回调函数 的返回值会与 state 进行浅合并。</span>   <span class="hljs-comment">// 好处一: 可以在回调函数中编写新的state的逻辑</span>   <span class="hljs-comment">// 好处二: 当前的回调函数会将之前的state和props传递进来</span>   <span class="hljs-comment">// this.setState((state, props) =&gt; &#123;</span>   <span class="hljs-comment">//   // 1.编写一些对新的state处理逻辑</span>   <span class="hljs-comment">//   // 2.可以获取之前的state和props值</span>   <span class="hljs-comment">//   console.log(this.state.message, this.props)</span>    <span class="hljs-comment">//获得最新的state和props</span><span class="hljs-comment">//   console.log(state, props)</span>   <span class="hljs-comment">//   return &#123;</span>   <span class="hljs-comment">//     message: &quot;你好啊, 李银河&quot;</span>   <span class="hljs-comment">//   &#125;</span>   <span class="hljs-comment">// &#125;)</span>   <span class="hljs-comment">// 3.setState在React的事件处理中是一个异步调用</span>   <span class="hljs-comment">// 如果希望在数据更新之后(数据合并), 获取到对应的结果执行一些逻辑代码</span>   <span class="hljs-comment">// 那么可以在setState中传入第二个参数: callback</span>   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊, 李银河&quot;</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;++++++:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>)   &#125;)   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;------:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>) &#125;</code></pre></div><h5 id="setState都是异步的吗"><a href="#setState都是异步的吗" class="headerlink" title="setState都是异步的吗"></a>setState都是异步的吗</h5><p>在React18以前，在组件的生命周期或者React合成事件中，setState是异步的，在setTimeout以及原生事件中是同步的，react18以后所有都是异步的，如果需要同步操作需要使用flushSync()</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 在react18之前, setTimeout中setState操作, 是同步操作</span>    <span class="hljs-comment">// 在react18之后, setTimeout中setState异步操作(批处理)</span>    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊, 李银河&quot;</span> &#125;)    &#125;)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>)  &#125;, <span class="hljs-number">0</span>);</code></pre></div><p> 24.组件创建的时候会被调用一次<br> 25.render函数，组件更新时调用render函数会让所有子组件都会进行一次更新。使用shouldComponentUpdate这个生命周期函数可以控制state和props发生变化时是否重新调用render函数         </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps,nextState</span>)&#123;    <span class="hljs-comment">//next...是最新的数据</span>       <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">num</span>!==nextState.<span class="hljs-property">num</span>)&#123;         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>     &#125;</code></pre></div><p>​    在开发中每个组件都写shouldComponentUpdate比较麻烦，可以在使用PureComponent</p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span></span></code></pre></div><p> 26.PureComponent不能用于函数式组件，需要用memo</p><p>​     PureComponent就是对组件进行优化，避免频繁的调用render函数进行渲染，这个方法中调用!shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)，进行浅层比较</p><p> 27.state中的属性的不可变性<br> 28.react不建议直接在操作dom，可以使用ref<br>     使用ref的三种方式</p><div class="code-wrapper"><pre><code class="hljs react">import React,&#123;createRef&#125; from &quot;react&quot;;class RefDemo extends React.Component&#123;  constructor(props)&#123;    super(props)    this.state=&#123;&#125;    this.titleRef=createRef()    // 第三种使用函数    this.textInput = null;  &#125;  componentDidMount()&#123;     &#125;  componentWillUnmount()&#123;      &#125;  changeRef1()&#123;    // 方式一已经被淘汰了    this.refs.refTitle.innerHTML=&quot;hello ref&quot;  &#125;  changeRef2()&#123;    // 官方推荐以这种方式     this.titleRef.current.innerHTML=&quot;hello big&quot;    console.log(this.titleRef.current)  &#125;  focusTextInput()&#123;    this.textInput.focus()    console.log(this.textInput)  &#125;  render()&#123;    return (      &lt;div&gt;        &lt;h1 ref=&quot;refTitle&quot;&gt;hello react&lt;/h1&gt;        &lt;button onClick=&#123;()=&gt;this.changeRef1()&#125;&gt;按钮1&lt;/button&gt;        &lt;h1 ref=&#123;this.titleRef&#125;&gt;hello world&lt;/h1&gt;        &lt;button onClick=&#123;()=&gt;this.changeRef2()&#125;&gt;按钮2&lt;/button&gt;        &lt;button onClick=&#123;()=&gt;this.focusTextInput()&#125;&gt;focus&lt;/button&gt;        &lt;div&gt;&lt;input ref=&#123;element=&gt;this.textInput=element&#125; type=&quot;text&quot; /&gt;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;export default RefDemo</code></pre></div><p>函数式组件中没有ref属性，要使用const textInput = useRef(null);<br>可以通过ref访问子组件的方法和属性和vue一样</p><h4 id="key的注意事项"><a href="#key的注意事项" class="headerlink" title="key的注意事项"></a>key的注意事项</h4><p>key必须唯一</p><p>key不能够使用随机数（因为随机数在下一次render时会重新生成一个数字）</p><p>使用index作为key,对性能没有优化</p><p>26.受控组件</p><p>​    受控组件就是通过setState来控制值，state成为唯一的数据源</p><p>​    </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">inputChange</span>(<span class="hljs-params">event</span>) &#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inputChange:&quot;</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">username</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span> &#125;) &#125; <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">const</span> &#123; username &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>   <span class="hljs-keyword">return</span> (     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">       &#123;/* 受控组件 */&#125;</span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;username&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.inputChange(e)&#125;/&gt;</span><span class="language-xml"></span><span class="language-xml">       &#123;/* 非受控组件 */&#125;</span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>username: &#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>   ) &#125;</code></pre></div><p>当type为text/textarea/select的时候绑定的是value,需要使用事件onChange</p><p>当type为checkbox/radio的时候，绑定的是checked，使用onChange事件</p><div class="code-wrapper"><pre><code class="hljs lua">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;始终是非受控组件</code></pre></div><p>使用form进行表单提交</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlavorForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-variable language_">super</span>(props);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;coconut&#x27;</span>&#125;;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);  &#125;  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);  &#125;  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你喜欢的风味是: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);    event.<span class="hljs-title function_">preventDefault</span>();  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><span class="language-xml">          选择你喜欢的风味:</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;grapefruit&quot;</span>&gt;</span>葡萄柚<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lime&quot;</span>&gt;</span>酸橙<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;coconut&quot;</span>&gt;</span>椰子<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mango&quot;</span>&gt;</span>芒果<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>    );  &#125;&#125;</code></pre></div><p>当针对多个输入的时候</p><p>可以给每个input绑定唯一的name,然后利用计算属性名来进行赋值操作</p><div class="code-wrapper"><pre><code class="hljs react">handleSubmitClick(event) &#123;    // 1.阻止默认的行为    event.preventDefault()    // 2.获取到所有的表单数据, 对数据进行组件    console.log(&quot;获取所有的输入内容&quot;)    console.log(this.state.username, this.state.password)    // 3.以网络请求的方式, 将数据传递给服务器(ajax/fetch/axios)  &#125;  // handleUsernameChange(event) &#123;  //   this.setState(&#123; username: event.target.value &#125;)  // &#125;  // handlePasswordChange(event) &#123;  //   this.setState(&#123; password: event.target.value &#125;)  // &#125;  handleInputChange(event) &#123;    this.setState(&#123;      [event.target.name]: event.target.value    &#125;)  &#125;  render() &#123;    const &#123; username, password &#125; = this.state    return (      &lt;div&gt;        &lt;form onSubmit=&#123;e =&gt; this.handleSubmitClick(e)&#125;&gt;          &#123;/* 1.用户名和密码 */&#125;          &lt;label htmlFor=&quot;username&quot;&gt;            用户:             &lt;input               id=&#x27;username&#x27;               type=&quot;text&quot;               name=&#x27;username&#x27;               value=&#123;username&#125;               onChange=&#123;e =&gt; this.handleInputChange(e)&#125;            /&gt;          &lt;/label&gt;          &lt;label htmlFor=&quot;password&quot;&gt;            密码:             &lt;input               id=&#x27;password&#x27;               type=&quot;password&quot;               name=&#x27;password&#x27;               value=&#123;password&#125;               onChange=&#123;e =&gt; this.handleInputChange(e)&#125;            /&gt;          &lt;/label&gt;          &lt;button type=&#x27;submit&#x27;&gt;注册&lt;/button&gt;        &lt;/form&gt;      &lt;/div&gt;    )  &#125;</code></pre></div><p>27.非受控组件</p><p>非受控组件就是将表单数据交给DOM节点来处理，</p><div class="code-wrapper"><pre><code class="hljs react">class NameForm extends React.Component &#123;  constructor(props) &#123;    super(props);    this.handleSubmit = this.handleSubmit.bind(this);    this.input = React.createRef();  &#125;  handleSubmit(event) &#123;    alert(&#x27;A name was submitted: &#x27; + this.input.current.value);    event.preventDefault();  &#125;  render() &#123;、  //defaultValue是默认值    return (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;label&gt;          Name:          &lt;input  defaultValue=&quot;Bob&quot; type=&quot;text&quot; ref=&#123;this.input&#125; /&gt;        &lt;/label&gt;        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vim">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt; 和 &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt; 支持 defaultChecked，<span class="hljs-symbol">&lt;select&gt;</span> 和 <span class="hljs-symbol">&lt;textarea&gt;</span> 支持 defaultValue。</code></pre></div><p>28.高阶组件</p><p>高阶组件是一个函数，高阶组件的参数是一个组件，返回值也是一个组件。高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。HOC 是纯函数，没有副作用，高阶组件适用于抽取公共的逻辑</p><div class="code-wrapper"><pre><code class="hljs react">import &#123; PureComponent &#125; from &#x27;react&#x27;//props增强// 定义组件: 给一些需要特殊数据的组件, 注入propsfunction enhancedUserInfo(OriginComponent) &#123;  class NewComponent extends PureComponent &#123;    constructor(props) &#123;      super(props)      this.state = &#123;        userInfo: &#123;          name: &quot;coderwhy&quot;,          level: 99        &#125;      &#125;    &#125;    render() &#123;      return &lt;OriginComponent &#123;...this.props&#125; &#123;...this.state.userInfo&#125;/&gt;    &#125;  &#125;  return NewComponent&#125;export default enhancedUserInfo</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//我们也可以利用高阶函数来劫持生命周期，在生命周期中完成自己的逻辑</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">logRenderTime</span>(<span class="hljs-params">OriginComponent</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">PureComponent</span> &#123;    <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">beginTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()      <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">endTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()      <span class="hljs-keyword">const</span> interval = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endTime</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">beginTime</span>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前<span class="hljs-subst">$&#123;OriginComponent.name&#125;</span>页面花费了<span class="hljs-subst">$&#123;interval&#125;</span>ms渲染完成!`</span>)    &#125;    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">OriginComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125;/&gt;</span></span>    &#125;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> logRenderTime</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//渲染鉴权，可以判断用户有没有登录，如果没有登录则渲染其他组件function loginAuth(OriginComponent) &#123;  return props =&gt; &#123;    // 从localStorage中获取token    const token = localStorage.getItem(&quot;token&quot;)    if (token) &#123;      return &lt;OriginComponent &#123;...props&#125;/&gt;    &#125; else &#123;      return &lt;h2&gt;请先登录, 再进行跳转到对应的页面中&lt;/h2&gt;    &#125;  &#125;&#125;export default loginAuth</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">import ThemeContext from &quot;../context/theme_context&quot;//和context结合function withTheme(OriginComponment) &#123;  return (props) =&gt; &#123;    return (      &lt;ThemeContext.Consumer&gt;        &#123;          value =&gt; &#123;            return &lt;OriginComponment &#123;...value&#125; &#123;...props&#125;/&gt;          &#125;        &#125;      &lt;/ThemeContext.Consumer&gt;    )  &#125;&#125;export default withTheme</code></pre></div><p>不要在 render 方法中使用 HOC</p><p>HOC也有自己的一些缺陷：</p><p> HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难； HOC可以劫持props，在不遵守约定的情况下也可能造成冲突；</p><p>Hooks的出现，是开创性的，它解决了很多React之前的存在的问题</p><p>比如this指向问题、比如hoc的嵌套复杂度问题等等</p><p>29.ref的转发，获取函数式组件内部的ref 可以使用forwardRef高阶函数<br>30.Portals的使用，用于将渲染元素独立于父组件，渲染到其他元素之上。使用React.createPortal(child,container)<br>31.fragment的使用，相当于vue的template在实际的dom中不渲染，带key的时候不能使用短语法<br>    还可以使用短语发    </p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Columns</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;&gt;        &lt;td&gt;<span class="hljs-type">Hello</span>&lt;/td&gt;        &lt;td&gt;<span class="hljs-type">World</span>&lt;/td&gt;      &lt;/&gt;    );  &#125;&#125;</code></pre></div><p> 32.StrictMode 开启react的严格模式，只有开发环境下起作用</p><p>​    StrictMode是用来突显应用程序中的潜在问题的工具</p><p>​    它为其后代元素触发额外的检查和警告</p><div class="code-wrapper"><pre><code class="hljs"> 可以识别不安全的生命周期 使用过时的ref的API 检测意外的副作用。</code></pre></div><p>​            组件的constructor会调用两次</p><p>​            生产环境终不悔调用两次</p><p>​    j检测使用废弃的findDOMNode方法</p><div class="code-wrapper"><pre><code class="hljs"> 检测过时的context api </code></pre></div><p>​            早期的Context是通过static属性声明Context对象属性，通过getChildContext返回Context对象等方式来使用Context的</p><p> 33.react中的css<br>     1.内联样式</p><p>​            style 接受一个采用小驼峰命名属性的 JavaScript 对象，，而不是 CSS 字符串</p><p>​            并且可以引用state中的状态来设置相关的样式</p><p>​            .内联样式, 样式之间不会有冲突</p><p>​             可以动态获取当前state中的状态</p><p>​             写法上都需要使用驼峰标识</p><p>​            某些样式没有提示</p><p>​            大量的样式, 代码混乱</p><p>​            某些样式无法编写(比如伪类/伪元素</p><div class="code-wrapper"><pre><code class="hljs"> 2.css modules     不是react特有的决绝方案，所有类似webpack配置环境都可以使用，在react中已经配置，在其他项目中使用需要在webpack.config.js中module:true      要创建xxx.moudle.css文件      不能使用连接符创建类名(.home-title)，js不支持，需要使用&#123;引入名字style.className&#125;来编写      不方便更改样式.不方便动态修改某些样式，依然需要使用内联样式  3.css in js      常用的 css in js库          styled-components              在多人协作中，css必定会出现命名冲突，与vue的scoped解决方案不同，react用styled-                    components的给类名加了随机字符的方式实现了css的私有化，它也是全局的          styled-components其实是一个组件，可以传入props          emotion          glamorous</code></pre></div><p>​        styled-components的本质是通过函数的调用，最终创建出一个组件，这个组件会自动添加上一个不重复的class</p><p>​        styled-components会给该class添加相关的样式，它支持css预处理器一样嵌套，支持直接子代选择器或者后代选择器，并且编写样式，可以通过&amp;符号获取当前元素，直接伪类选择器，伪元素等</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span><span class="hljs-keyword">import</span> &#123;  primaryColor,  largeSize&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./style/variables&quot;</span><span class="hljs-comment">// 1.基本使用</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">AppWrapper</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`</span><span class="hljs-string">  .footer &#123;</span><span class="hljs-string">    border: 1px solid orange;</span><span class="hljs-string">  &#125;</span><span class="hljs-string">// const obj = &#123;</span><span class="hljs-string">//   name: (props) =&gt; props.name || &quot;why&quot;</span><span class="hljs-string">// &#125;</span><span class="hljs-string">// 2.子元素单独抽取到一个样式组件</span><span class="hljs-string">// 3.可以接受外部传入的props</span><span class="hljs-string">// 4.可以通过attrs给标签模板字符串中提供的属性</span><span class="hljs-string">// 5.从一个单独的文件中引入变量</span><span class="hljs-string">export const SectionWrapper = styled.div.attrs(props =&gt; (&#123;</span><span class="hljs-string">  tColor: props.color || &quot;blue&quot;</span><span class="hljs-string">&#125;))`</span>  <span class="hljs-attr">border</span>: 1px solid red;  .<span class="hljs-property">title</span> &#123;    font-<span class="hljs-attr">size</span>: $&#123;<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> props.<span class="hljs-property">size</span>&#125;px;    <span class="hljs-attr">color</span>: $&#123;<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> props.<span class="hljs-property">tColor</span>&#125;;    &amp;:hover &#123;      background-<span class="hljs-attr">color</span>: purple;    &#125;  &#125;  .<span class="hljs-property">content</span> &#123;    font-<span class="hljs-attr">size</span>: $&#123;largeSize&#125;px;    <span class="hljs-attr">color</span>: $&#123;primaryColor&#125;;  &#125;<span class="hljs-string">`</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-title class_">HYButton</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`</span><span class="hljs-string">  border: 1px solid red;</span><span class="hljs-string">  border-radius: 5px;</span><span class="hljs-string">`</span><span class="hljs-comment">// css样式的继承</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HYButtonWrapper</span> = <span class="hljs-title function_">styled</span>(<span class="hljs-title class_">HYButton</span>)<span class="hljs-string">`</span><span class="hljs-string">  background-color: #0f0;</span><span class="hljs-string">  color: #fff;</span><span class="hljs-string">`</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeWrapper</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`</span><span class="hljs-string">  .top &#123;</span><span class="hljs-string">    .banner &#123;</span><span class="hljs-string">      color: red;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">  &#125;</span><span class="hljs-string">  .bottom &#123;</span><span class="hljs-string">    .header &#123;</span><span class="hljs-string">      color: <span class="hljs-subst">$&#123;props =&gt; props.theme.color&#125;</span>;</span><span class="hljs-string">      font-size: <span class="hljs-subst">$&#123;props =&gt; props.theme.size&#125;</span>;</span><span class="hljs-string">    &#125;</span><span class="hljs-string"></span><span class="hljs-string">    .product-list &#123;</span><span class="hljs-string">      .item &#123;</span><span class="hljs-string">        color: blue;</span><span class="hljs-string">      &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">  &#125;</span><span class="hljs-string">`</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs"> 4.普通的csc会相互层叠，都会合并到全局的css中去，遭成影响到其他模块 5.less的编写方式  需要配置webpack   需要使用craco  目前针对creat-react-app 5 的配置 npm i @craco/craco@alpha</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>   <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco start&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco build&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco test&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;eject&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts eject&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></div><p>​    </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//craco.config.js</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">CracoLessPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;craco-less&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">plugins</span>: [    &#123;      <span class="hljs-attr">plugin</span>: <span class="hljs-title class_">CracoLessPlugin</span>,      <span class="hljs-attr">options</span>: &#123;        <span class="hljs-attr">lessLoaderOptions</span>: &#123;          <span class="hljs-attr">lessOptions</span>: &#123;            <span class="hljs-attr">modifyVars</span>: &#123; <span class="hljs-string">&#x27;@primary-color&#x27;</span>: <span class="hljs-string">&#x27;#1DA57A&#x27;</span> &#125;,            <span class="hljs-attr">javascriptEnabled</span>: <span class="hljs-literal">true</span>,          &#125;,        &#125;,      &#125;,    &#125;,  ],&#125;;</code></pre></div><h4 id="React中添加class"><a href="#React中添加class" class="headerlink" title="React中添加class"></a>React中添加class</h4><p>可以借助第三方库classnames</p><p> 34.axios中，axios({})这样是使用他默认创建的实例，如果要自己创建一个实例要使用axios.create({})</p><h4 id="react-transition-group"><a href="#react-transition-group" class="headerlink" title="react-transition-group"></a>react-transition-group</h4><p>  这个库可以帮助我们方便的实现组件的 入场 和 离场 动画，使用时需要进行额外的安装</p><div class="code-wrapper"><pre><code class="hljs sql">npm install react<span class="hljs-operator">-</span>transition<span class="hljs-operator">-</span><span class="hljs-keyword">group</span> <span class="hljs-comment">--save</span>yarn <span class="hljs-keyword">add</span> react<span class="hljs-operator">-</span>transition<span class="hljs-operator">-</span><span class="hljs-keyword">group</span></code></pre></div><p>react-transition-group主要包括四个组件</p><p>Tansition</p><p>​        该组件是一个和平台无关的组件（不一定要结合CSS）</p><p>​        在前端开发中，我们一般是结合CSS来完成样式，所以比较常用的是CSSTransition</p><p>CSSTransition</p><p>​        在前端开发中，通常使用CSSTransition来完成过渡动画</p><p>​        CSSTransition是基于Transition组件构建的</p><p>​        CSSTransition执行过程中，有三个状态：appear、enter、exit；</p><p>​        它们有三种状态，需要定义对应的CSS样式：</p><p>​        第一类，开始状态：对于的类是-appear、-enter、exit； </p><p>​        第二类：执行动画：对应的类是-appear-active、-enter-active、-exit-active； </p><p>​        第三类：执行结束：对应的类是-appear-done、-enter-done、-exit-done；</p><p>​        CSSTransition常用属性</p><p>​        in</p><p>​        classNames</p><p>​        timeout</p><p>​        appear</p><p>​        unmountOnExit</p><h6 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数:"></a>钩子函数:</h6><p>​                onEnter</p><p>​                onEntering</p><p>​                onEntered</p><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; createRef, PureComponent &#125; from &#x27;react&#x27;import &#123; CSSTransition &#125; from &quot;react-transition-group&quot;import &quot;./style.css&quot;export class App extends PureComponent &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      isShow: true    &#125;    this.sectionRef = createRef()  &#125;  render() &#123;    const &#123; isShow &#125; = this.state    return (      &lt;div&gt;        &lt;button onClick=&#123;e =&gt; this.setState(&#123;isShow: !isShow&#125;)&#125;&gt;切换&lt;/button&gt;        &#123;/* &#123; isShow &amp;&amp; &lt;h2&gt;哈哈哈&lt;/h2&gt; &#125; */&#125;        &lt;CSSTransition           nodeRef=&#123;this.sectionRef&#125;          in=&#123;isShow&#125;           unmountOnExit=&#123;true&#125;           classNames=&quot;why&quot;           timeout=&#123;2000&#125;          appear          onEnter=&#123;e =&gt; console.log(&quot;开始进入动画&quot;)&#125;          onEntering=&#123;e =&gt; console.log(&quot;执行进入动画&quot;)&#125;          onEntered=&#123;e =&gt; console.log(&quot;执行进入结束&quot;)&#125;          onExit=&#123;e =&gt; console.log(&quot;开始离开动画&quot;)&#125;          onExiting=&#123;e =&gt; console.log(&quot;执行离开动画&quot;)&#125;          onExited=&#123;e =&gt; console.log(&quot;执行离开结束&quot;)&#125;        &gt;          &lt;div className=&#x27;section&#x27; ref=&#123;this.sectionRef&#125;&gt;            &lt;h2&gt;哈哈哈&lt;/h2&gt;            &lt;p&gt;我是内容, 哈哈哈&lt;/p&gt;          &lt;/div&gt;        &lt;/CSSTransition&gt;      &lt;/div&gt;    )  &#125;&#125;export default App</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.why-appear</span>, <span class="hljs-selector-class">.why-enter</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.why-appear-active</span>, <span class="hljs-selector-class">.why-enter-active</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">2s</span> ease;&#125;<span class="hljs-comment">/* 离开动画 */</span><span class="hljs-selector-class">.why-exit</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.why-exit-active</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">2s</span> ease;&#125;</code></pre></div><p>SwitchTransition</p><p>​        两个组件显示和切换时，使用该组件</p><p>​        SwitchTransition中主要有一个属性：mode，有两个值</p><p>​            in-out：表示新组件先进入，旧组件再移除；</p><p>​            out-in：表示就组件先移除，新组建再进入</p><p>​        SwitchTransition组件里面要有CSSTransition或者Transition组件，不能直接包裹你想要切换的组件</p><p>​        SwitchTransition里面的CSSTransition或Transition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是 key属性</p><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; PureComponent &#125; from &#x27;react&#x27;import &#123; SwitchTransition, CSSTransition &#125; from &#x27;react-transition-group&#x27;import &quot;./style.css&quot;export class App extends PureComponent &#123;  constructor() &#123;    super()     this.state = &#123;      isLogin: true    &#125;  &#125;  render() &#123;    const &#123; isLogin &#125; = this.state    return (      &lt;div&gt;        &lt;SwitchTransition mode=&#x27;out-in&#x27;&gt;          &lt;CSSTransition            key=&#123;isLogin ? &quot;exit&quot;: &quot;login&quot;&#125;            classNames=&quot;login&quot;            timeout=&#123;1000&#125;          &gt;            &lt;button onClick=&#123;e =&gt; this.setState(&#123; isLogin: !isLogin &#125;)&#125;&gt;              &#123; isLogin ? &quot;退出&quot;: &quot;登录&quot; &#125;            &lt;/button&gt;          &lt;/CSSTransition&gt;        &lt;/SwitchTransition&gt;      &lt;/div&gt;    )  &#125;&#125;export default App</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.login-enter</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.login-enter-active</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;&#125;<span class="hljs-selector-class">.login-exit</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.login-exit-active</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100px</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;&#125;</code></pre></div><p>TransitionGroup</p><p>​        将多个组件包裹在其中，一般用于列表中的元素的动画</p><p>​        ◼ 当我们有一组动画时，需要将这些CSSTransition放入到一个TransitionGroup中来完成动画：</p><div class="code-wrapper"><pre><code class="hljs react">&lt;TransitionGroup component=&quot;ul&quot;&gt;         &#123;           books.map((item, index) =&gt; &#123;             return (               &lt;CSSTransition key=&#123;item.id&#125; classNames=&quot;book&quot; timeout=&#123;1000&#125;&gt;                 &lt;li&gt;                   &lt;span&gt;&#123;item.name&#125;-&#123;item.price&#125;&lt;/span&gt;                   &lt;button onClick=&#123;e =&gt; this.removeBook(index)&#125;&gt;删除&lt;/button&gt;                 &lt;/li&gt;               &lt;/CSSTransition&gt;             )           &#125;)         &#125;       &lt;/TransitionGroup&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.book-enter</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">150px</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.book-enter-active</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;&#125;<span class="hljs-selector-class">.book-exit</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.book-exit-active</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">150px</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;&#125;</code></pre></div><p>36.react纯函数<br> 37.node中对ES6模块化的支持 在13.2.0以后对es6的支持，需要在package.json中添加属性”type”:”module”,导入文件时要跟上.js后缀名<br> 38.redux<br>     redux主要是负责状态管理<br>     store:createStore(reducer,..)<br>     state:通过store.getState()来获取当前state<br>     react的组成<br>         action:是用来更新数据，所有的数据变化，必须通过dispatch来派发action来更新，action可以是一个对象，也可以是一个函数，函数必须返回一个对象<br>         reducer：是将state和action连接起来，reducer是一个纯函数，reducer是将传入的reducer和action整和成为一个新的state<br>         dispatch:用来派发action<br>     redux的三大原则<br>         1.单一数据源<br>         2.state是只读的<br>         3.使用纯函数来执行修改<br> 39.单向数据流<br> 40.react动画中<TransitionGroup>中需要再用<cssTransition>包裹,否则会报错<br> 41.react-router<br>     默认是模糊匹配<br> 42.react-hook<br>     import React from “react”//这个是在函数式组件和类组件都要写，因为jsx是React.createElement()的语法糖，会在内部调用<br>     useState()<br>     Hook的使用规则：<br>         只能在函数最外层调用Hook,不要在循环，条件判断或者子函数中调用<br>         只能在React的函数组件中调用Hook,不要再其他js函数中使用</p><div class="code-wrapper"><pre><code class="hljs">  const [count, setCount] = useState(() =&gt; 10);//useState可以传入一个函数</code></pre></div><p>  console.log(“CounterHook渲染”);</p><p>  function handleBtnClick() {<br>    // setCount(count + 10);</p><p>​    setCount((prevCount) =&gt; prevCount + 10);//preCount是上一个count<br>​<br>​    如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。<br>​    与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的     setState 结合展开运算符来达到合并更新对象的效果。<br>​    setState(prevState =&gt; {<br>​      // 也可以使用 Object.assign<br>​      return {…prevState, …updatedValues};<br>​    });<br>​    useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><p> 43.useEffect()<br>     useEffect(() =&gt; {<br>    console.log(“订阅一些事件”);</p><p>​    return () =&gt; {<br>​      console.log(“取消订阅事件”)<br>​    }<br>  }, []);//通过返回一个函数来执行类似componmentwillumnount来清除副作用，[]这个可以作为优化，只有在组件切换时才执行，[]只会执行一次，相当于是componentDiMount,componentWillUnmount<br>  44.useEffect第二个参数<br>   useEffect(() =&gt; {<br>​    console.log(“修改DOM”, count);<br>  }, [count]);//useEffect可以让某个属性发生改变时才执行，这个属性必须在useEffect的回调函数中有使用到<br>  如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。</p><p>使用多个useEffect可以分开使用，执行的时候会挨个执行</p><h4 id="45-useContext的使用"><a href="#45-useContext的使用" class="headerlink" title="45.useContext的使用"></a>45.useContext的使用</h4><p>​    useContext可以让多个Context传递给函数式组件的时候减少consumer的嵌套</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));root.<span class="hljs-title function_">render</span>(  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;name:</span> &quot;<span class="hljs-attr">why</span>&quot;, <span class="hljs-attr">level:</span> <span class="hljs-attr">99</span>&#125;&#125;&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">TokenContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">coderwhy</span>&#x27;&#125;&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">TokenContext.Provider</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserContext</span>, <span class="hljs-title class_">ThemeContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./context&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 使用Context</span>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>)  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>)  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>User: &#123;user.name&#125;-&#123;user.level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span> <span class="hljs-attr">theme.color</span>, <span class="hljs-attr">fontSize:</span> <span class="hljs-attr">theme.size</span>&#125;&#125;&gt;</span>Theme<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div><h4 id="46-useCallback的使用"><a href="#46-useCallback的使用" class="headerlink" title="46.useCallback的使用"></a>46.useCallback的使用</h4><p>useReducer不是redux的替代品，useReducer仅仅是useState的一种替代方案。在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分，或者这次修改的state需要依赖之前的state时，也可以使用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;  <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span> &#125;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> - <span class="hljs-number">1</span> &#125;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add_number&quot;</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + action.<span class="hljs-property">num</span> &#125;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sub_number&quot;</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> - action.<span class="hljs-property">num</span> &#125;    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">return</span> state  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">const [state, dispatch] = useReducer(reducer, &#123; counter: 0, friends: [], user: &#123;&#125; &#125;)     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;increment&quot;&#125;)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;decrement&quot;&#125;)&#125;&gt;-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;add_number&quot;, num: 5&#125;)&#125;&gt;+5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;sub_number&quot;, num: 5&#125;)&#125;&gt;-5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;add_number&quot;, num: 100&#125;)&#125;&gt;+100<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><h4 id="47-useMemo的使用"><a href="#47-useMemo的使用" class="headerlink" title="47.useMemo的使用"></a>47.useMemo的使用</h4><p>在进行大量的计算的时候，使用useMemo可以避免重复的渲染</p><p>可以对子组件传递相同内容的对象的时候避免重新渲染</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123; useMemo, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HelloWorld被渲染~&quot;</span>)  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>&#125;)<span class="hljs-keyword">function</span> <span class="hljs-title function_">calcNumTotal</span>(<span class="hljs-params">num</span>) &#123;  <span class="hljs-comment">// console.log(&quot;calcNumTotal的计算过程被调用~&quot;)</span>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;    total += i  &#125;  <span class="hljs-keyword">return</span> total&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-comment">// const result = calcNumTotal(50)</span>  <span class="hljs-comment">// 1.不依赖任何的值, 进行计算</span>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title function_">calcNumTotal</span>(<span class="hljs-number">50</span>)  &#125;, [])  <span class="hljs-comment">// 2.依赖count</span>  <span class="hljs-comment">// const result = useMemo(() =&gt; &#123;</span>  <span class="hljs-comment">//   return calcNumTotal(count*2)</span>  <span class="hljs-comment">// &#125;, [count])</span>  <span class="hljs-comment">// 3.useMemo和useCallback的对比</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;&#125;  <span class="hljs-comment">// const increment = useCallback(fn, [])</span>  <span class="hljs-comment">// const increment2 = useMemo(() =&gt; fn, [])</span>  <span class="hljs-comment">// 4.使用useMemo对子组件渲染进行优化</span>  <span class="hljs-comment">// const info = &#123; name: &quot;why&quot;, age: 18 &#125;</span>  <span class="hljs-keyword">const</span> info = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;), [])  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计算结果: &#123;result&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计数器: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setCount(count+1)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">result</span>=<span class="hljs-string">&#123;result&#125;</span> <span class="hljs-attr">info</span>=<span class="hljs-string">&#123;info&#125;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div><p>48.useCallback是针对回调函数进行优化，useMemo是对返回值进行优化。userCallback可以用于传递给被pureComponent或者memo包裹的子组件的函数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useState, useCallback, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-comment">// useCallback性能优化的点:</span><span class="hljs-comment">// 1.当需要将一个函数传递给子组件时, 最好使用useCallback进行优化, 将优化之后的函数, 传递给子组件</span><span class="hljs-comment">//如果没有使用usecallback，函数式组件在发生更新的时候，所有代码都会重新执行，传递给子组件的函数会重新生成，如果使用usecallback,会根据第二个参数数组中的值，是否生成新的函数，使子组件是否重新渲染</span><span class="hljs-comment">// props中的属性发生改变时, 组件本身就会被重新渲染，</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HYHome</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-keyword">const</span> &#123; increment &#125; = props  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HYHome被渲染&quot;</span>)  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>increment+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">      &#123;/* 100个子组件 */&#125;</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;hello&quot;</span>)  <span class="hljs-comment">// 闭包陷阱: useCallback  解决闭包陷阱方式一，但是会生成新的函数</span>  <span class="hljs-comment">// const increment = useCallback(function foo() &#123;</span>  <span class="hljs-comment">//   console.log(&quot;increment&quot;)</span>  <span class="hljs-comment">//   setCount(count+1)</span>  <span class="hljs-comment">// &#125;, [count])</span>  <span class="hljs-comment">// 进一步的优化: 当count发生改变时, 也使用同一个函数(了解)</span>  <span class="hljs-comment">// 做法一: 将count依赖移除掉, 缺点: 闭包陷阱,因为此时的foo和原来的foo不是同一个foo,而原来的foo依然使用之前的count</span>  <span class="hljs-comment">// const increment = useCallback(function foo() &#123;</span>  <span class="hljs-comment">//   console.log(&quot;increment&quot;)</span>  <span class="hljs-comment">//   setCount(count+1)</span>  <span class="hljs-comment">// &#125;, [])</span>  <span class="hljs-comment">// 做法二: useRef, 在组件多次渲染时, 返回的是同一个值</span>  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>()  countRef.<span class="hljs-property">current</span> = count  <span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;increment&quot;</span>)    <span class="hljs-title function_">setCount</span>(countRef.<span class="hljs-property">current</span> + <span class="hljs-number">1</span>)  &#125;, [])  <span class="hljs-comment">// 普通的函数</span>  <span class="hljs-comment">// const increment = () =&gt; &#123;</span>  <span class="hljs-comment">//   setCount(count+1)</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计数: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HYHome</span> <span class="hljs-attr">increment</span>=<span class="hljs-string">&#123;increment&#125;/</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>message:&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setMessage(Math.random())&#125;&gt;修改message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-comment">// function foo(name) &#123;</span><span class="hljs-comment">//   function bar() &#123;</span><span class="hljs-comment">//     console.log(name)</span><span class="hljs-comment">//   &#125;</span><span class="hljs-comment">//   return bar</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// const bar1 = foo(&quot;why&quot;)</span><span class="hljs-comment">// bar1() // why</span><span class="hljs-comment">// bar1() // why</span><span class="hljs-comment">// const bar2 = foo(&quot;kobe&quot;)</span><span class="hljs-comment">// bar2() // kobe</span><span class="hljs-comment">// bar1() // why</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div><p>useCallback会返回一个函数的memoized(记忆的)，在依赖不变的情况下，多次定义的时候，返回的值是相同的。通常使用useCallback的目的是不希望子组件进行多次渲染，并不是为了函数继续缓存</p><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>useRef返回一个ref对象，返回的ref对象再组件的整个生命周期保持不变，会指向同一个对象</p><p>useRef的两种用法：</p><p>​    用法一：引入DOM(或者组件，但是需要class组件)元素</p><p>​    用法二： 保存一个数据，这个对象在整个生命周期可以保持不变</p><p>49.Refs的转发<br>      就是父组件想获取到子组件的ref,在高阶组件中转发refs<br>      可以使用React.forwardRef()<br>      const ref=useRef(initialValue)//初始化值后不会发生改变    </p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RefHookDemo02</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);  <span class="hljs-keyword">const</span> numRef = <span class="hljs-title function_">useRef</span>(count);  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;    numRef.<span class="hljs-property">current</span> = count;  &#125;, [count])  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      &#123;/* <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>numRef中的值: &#123;numRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count中的值: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> */&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count上一次的值: &#123;numRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count这一次的值: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setCount(count + 10)&#125;&gt;+10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-comment">//useEffect和useRef结合使用可以修改numRef.current</span></code></pre></div><p>50.useImperativeHandle要和React.forwardRef()一起使用</p><p>通过forwardRef可以将ref转发到子组件，获取到子组件内部的ref,子组件拿到父组件创建的ref绑定到某个元素上，forwordRef会将子组件的DOM暴露给父组件，父组件拿到DOM之后可以任意操作，可以使用useImperativeHandle暴露固定的操作</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useRef, forwardRef, useImperativeHandle &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>()  <span class="hljs-comment">// 子组件对父组件传入的ref进行处理</span>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-title function_">focus</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;focus&quot;</span>)        inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()      &#125;,      <span class="hljs-title function_">setValue</span>(<span class="hljs-params">value</span>) &#123;        inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span> = value      &#125;    &#125;  &#125;)  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;/</span>&gt;</span></span>&#125;))<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> titleRef = <span class="hljs-title function_">useRef</span>()  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>()  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDOM</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// console.log(inputRef.current)</span>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()    <span class="hljs-comment">// inputRef.current.value = &quot;&quot;</span>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">setValue</span>(<span class="hljs-string">&quot;哈哈哈&quot;</span>)  &#125;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;titleRef&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;/</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleDOM&#125;</span>&gt;</span>DOM操作<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div><p>51.自定义hook：就是将react的hook封装成函数<br>52.fiber的原理<br>53.不要在条件表达式中使用hook<br>54.使用normailze.css对项目进行初始化<br>    使用@craco/craco修改react 配置<br>        修改webpack的alias<br>    使用react-config-router进行路由配置<br>    使用styled-compoments进行写css样式<br>        background:url(${reuire()})//需要使用require来引入图片<br>        搜索框使用antDesign<br>        数据都是用redux来管理<br>        用redux-thunk进行异步请求<br>        配置redux-devtool<br>        将各个模块的redux分开写再各个文件中，然后进行合并，使用combineReducers<br>        store使用Provider进行传递<br>        所有组件用memo()包裹管理<br>        使用redux的hook:useDispatch()<br>                       useSelector(state=&gt;({}),shallowEqual)<br>                       shallowEqual//进行浅层比较,做优化<br>        Immutablejs可以解决使用拷贝来决绝数据可变性的问题，带来的性能问题        </p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> im=immutable<span class="hljs-keyword">const</span> info=&#123;&#125;<span class="hljs-keyword">const</span> imfoIM=im(info)imfoIm.<span class="hljs-keyword">set</span>()imfoIM.<span class="hljs-keyword">get</span>()imfoIm.list()imfoim.fromJS()<span class="hljs-comment">//深层次转换</span></code></pre></div><p>​        2.只能再react函数中调用成immutable类型<br>​            state.getIn([“a”,”b”])//相当于a.b<br>​            styled-components的传参<br>​            使用useCallback对需要传给子组件的函数进行包裹，可以有缓存，并提高性能<br>​<br>​            使用 redux-immutable中的commineReducer来优化combineReducer,提高性能</p><p>55 Hook的本质就是javascript函数，他要遵循两条规则<br>    1.只在最顶层使用hook<br>        不要再循环，条件或者嵌套函数中调用hook,确保总是再你的react函数的最顶层去调用他们<br>        遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确<br>    2.只能再react函数中调用Hook<br>      不要在普通的javascript中调用hook,可以在reat函数组件中调用hook,也可以在在定义hook中调用其他hook<br>56.自定义HOOK一定要以use开头<br>57.在两个组件中使用相同的 Hook 会共享 state 吗？不会。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。<br>58.自定义 Hook 如何获取独立的 state？每次调用 Hook，它都会获取独立的 state<br>    由于我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect<br>59.惰性初始化state</p><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, <span class="hljs-built_in">set</span>State] = useState(() =&gt; &#123;  <span class="hljs-keyword">const</span> initialState = someExpensiveComputation(props);  return initialState;&#125;);</code></pre></div><h4 id="60-useEffect是在每一轮渲染结束后执行"><a href="#60-useEffect是在每一轮渲染结束后执行" class="headerlink" title="60.useEffect是在每一轮渲染结束后执行"></a>60.useEffect是在每一轮渲染结束后执行</h4><p>61.组件卸载时需要清除effect创建的订阅，定时器等，useEffect函数需要返回一个清理函数</p><div class="code-wrapper"><pre><code class="hljs abnf">useEffect(() <span class="hljs-operator">=</span>&gt; &#123;  const subscription <span class="hljs-operator">=</span> props.source.subscribe()<span class="hljs-comment">;</span>  return () <span class="hljs-operator">=</span>&gt; &#123;    // 清除订阅    subscription.unsubscribe()<span class="hljs-comment">;</span>  &#125;<span class="hljs-comment">;</span>&#125;)<span class="hljs-comment">;</span></code></pre></div><p>为防止内存泄漏，清除函数会在组件卸载之前执行。另外，如果组件多次渲染，则会在子啊个effect之前，上一个effect就会被清除</p><h6 id="62-effect的执行时机"><a href="#62-effect的执行时机" class="headerlink" title="62.effect的执行时机"></a>62.effect的执行时机</h6><p>与componentDidMount,cimponentDidUpadate不同的是，在浏览器完成布局与绘制之后，</p><p>传给useEffect的函数会延迟调用，这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理情况，因此不应在函数值执行阻塞浏览器更新的操作</p><h6 id="63-useContext"><a href="#63-useContext" class="headerlink" title="63.useContext"></a>63.useContext</h6><div class="code-wrapper"><pre><code class="hljs reasonml">const MyContext= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>create<span class="hljs-constructor">Context(<span class="hljs-params">value</span>)</span>const value = use<span class="hljs-constructor">Context(MyContext)</span>;</code></pre></div><p>myContext是React.createContext的返回值，并返回该context的当前值，当前的value值由</p><p>他的上层组件距离当前组件最近的&lt;MyContext.Provider&gt;的value prop决定的</p><p>当Provider中的value发生更新的时候，useContext就会出发重新渲染，即使组件时使用React.emo包裹，或者使用shouldComponentUpdat生命周期，该组件都会重新渲染</p><p>只要MyConetext里面的值发生改变，使用了useContext的组件都会重新渲染，如果重新渲染开销大，可以使用memoization来优化</p><p>useContext(MyContext)===&gt;class中的static contextType=MyContext或者&lt;MyContext.Consumer&gt;</p><p><code>useContext(MyContext)</code> 只是让你能够<em>读取</em> context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件<em>提供</em> context。</p><h6 id="64-useReducer"><a href="#64-useReducer" class="headerlink" title="64.useReducer"></a>64.<code>useReducer</code></h6><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init);useState的替代方案在某些场合会比useState更加适用，例如 <span class="hljs-keyword">state</span> 逻辑较复杂且包含多个子值，或者下一个 <span class="hljs-keyword">state</span> 依赖于之前的 <span class="hljs-keyword">state</span> 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。</code></pre></div><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> initialState = &#123;count: <span class="hljs-number">0</span>&#125;;function reducer(<span class="hljs-keyword">state</span>, action) &#123;  switch (action.type) &#123;    case &#x27;increment&#x27;:      return &#123;count: <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span>&#125;;    case &#x27;decrement&#x27;:      return &#123;count: <span class="hljs-keyword">state</span>.count - <span class="hljs-number">1</span>&#125;;    <span class="hljs-keyword">default</span>:      throw new Error();  &#125;&#125;function Counter() &#123;  <span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialState);  return (    <span class="hljs-variable">&lt;&gt;</span>      Count: &#123;<span class="hljs-keyword">state</span>.count&#125;      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;    &lt;/&gt;  );&#125;</code></pre></div><h4 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h4><p>useReducer的第三个参数传入一个函数，这样初始state将设置为传入函数的返回值</p><p>可以通过外部来传入</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">initialCount</span>) &#123;  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: initialCount&#125;;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">init</span>(action.<span class="hljs-property">payload</span>);    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) &#123;  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialCount, init);  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><span class="language-xml">      Count: &#123;state.count&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;</span><span class="language-xml">        Reset</span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span>  );&#125;</code></pre></div><p>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）</p><p>如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><p>useReducer不可以作为redux的替代方案，不可以进行数据共享</p><p>65.使用memo包裹函数，可以进行性能优化，会对props进行浅层比较，如果props没有发生更新，则不会重新渲染</p><p>66.没有优化以前。父组件发生改变子组件也会重新渲染</p><p>67.useCallback</p><p>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p><img src="https://img1.imgtp.com/2022/09/12/JXSSiW1v.png" alt="QQ截图20220620112711.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/7N1MVzzM.png" alt="QQ截图20220620112901.png"></p><p>68.useMeno</p><p>​    <code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><p>useCallback是返回<a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数。useMeno是返回一个memoized值</p><p>useMemo只会在依赖项发生改变时才会重新计算执行，返回新的值，避免每次渲染时都进行高开销的计算</p><p>记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值</p><p><img src="https://img1.imgtp.com/2022/09/12/YMPGqZBu.png" alt="QQ截图20220620131653.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/9Z0ICdSV.png" alt="QQ截图20220620131701.png"></p><p>69.useRef</p><p>useRef返回一个ref对象，返回的ref对象在组件的整个生命周期保持不变</p><p>最常用的ref是两种用法</p><p>​    1.引入DOM(或者是class组件)元素，不可以用在函数组件中</p><p>​    2.保存一个数据，这个对象在整个生命周期中可以保持不变</p><p><img src="https://img1.imgtp.com/2022/09/12/dwdJVSSg.png" alt="QQ截图20220620143141.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/emUNGaLF.png" alt="QQ截图20220620143158.png"></p><p>70.<code>useImperativeHandle</code></p><p>useImperativeHandle要和forwardRef结合使用，使用useImperativeHandle可以使父元素不可以对子组件中的ref进行随意操作</p><p><img src="https://img1.imgtp.com/2022/09/12/Ey8AqNSp.png" alt="QQ截图20220620143648.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/crDRrvA5.png" alt="QQ截图20220620143735.png"></p><p>71.useLayoutEffect</p><p>​    和useEffect的区别是</p><p>​    useEffect会在渲染的内容更新到DOM之后再执行，而不会阻塞DOM的更新</p><p>​    useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新</p><p>​    <img src="https://img1.imgtp.com/2022/09/12/Zgl2puzy.png" alt="QQ截图20220620144244.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/a6VmoNdR.png" alt="QQ截图20220620144253.png"></p><p>72.redux-thunk</p><p>​     使用中间件目的是再dispatch的action和reducer之间扩展自己的代码，例如日志记录，调用异步接口，添加代码调试功能等等</p><p>​    可以使用redux-thunk发送异步请求</p><p>​    1.通常情况下。dispatch(action),actionn余姚是一个javascript对象</p><p>​    2.redux-thunk可以让dispatch(action函数)，action可以是一个函数</p><p>​    3.这个函数被调用的时候，会返回一个函数并给这个函数传一个patch,getState函数</p><p>​                dispatch函数用于再次派发action</p><p>​                getState函数获取到之前的状态</p><p><img src="C:\Users\10152\Desktop\study\memo\React\QQ截图20220620161818.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/DaBjyVoU.png" alt="QQ截图20220620162945.png"></p><h6 id="73-redux-devtools"><a href="#73-redux-devtools" class="headerlink" title="73.redux-devtools"></a>73.redux-devtools</h6><p>是用来对redux中的状态进行跟踪调试</p><p><img src="https://img1.imgtp.com/2022/09/12/QsLGVWW4.png" alt="QQ截图20220620163435.png"></p><h5 id="74-combineReducers"><a href="#74-combineReducers" class="headerlink" title="74.combineReducers"></a>74.combineReducers</h5><p>redux中提供了一个函数combineReducers来合并多个reducer</p><p>combinerReducer的实现</p><p>​    它会将reducer合并，并且返回一个combation函数相当于是新的reducer</p><p>​    在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state；</p><p>   新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新；</p><p><img src="https://img1.imgtp.com/2022/09/12/lfwbA1yr.png" alt="QQ截图20220620163958.png"></p><h5 id="75-useSelector"><a href="#75-useSelector" class="headerlink" title="75.useSelector()"></a>75.useSelector()</h5><div class="code-wrapper"><pre><code class="hljs pf">import React <span class="hljs-keyword">from</span> &#x27;react&#x27;import &#123; shallowEqual, useSelector &#125; <span class="hljs-keyword">from</span> &#x27;react-redux&#x27;export <span class="hljs-keyword">const</span> CounterComponent = () =&gt; &#123;  <span class="hljs-keyword">const</span> counter = useSelector((<span class="hljs-keyword">state</span>) =&gt; <span class="hljs-keyword">state</span>.counter,shallowEqual)  return <span class="hljs-variable">&lt;div&gt;</span>&#123;counter&#125;&lt;/div&gt;&#125;//在hook中使用redux,使用useSlectore来获取<span class="hljs-keyword">state</span></code></pre></div><h5 id="76-useDispatch"><a href="#76-useDispatch" class="headerlink" title="76.useDispatch()"></a>76.<code>useDispatch()</code></h5><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> dispatch = useDispatch()<span class="hljs-comment">//派发action</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs smali">export<span class="hljs-built_in"> const </span>Todos = () =&gt; &#123; <span class="hljs-built_in"> const </span>dispatch = useDispatch()  useEffect(() =&gt; &#123;    dispatch(fetchTodos())    // Safe to<span class="hljs-built_in"> add </span>dispatch to the dependencies<span class="hljs-built_in"> array</span><span class="hljs-built_in"></span>  &#125;, [dispatch])&#125;</code></pre></div><h5 id="77-useStore"><a href="#77-useStore" class="headerlink" title="77.useStore()"></a>77.<code>useStore()</code></h5><p>替代createStore()</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pinia笔记</title>
    <link href="/2022/08/23/pinia%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/23/pinia%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="Pinia和Vuex的区别"><a href="#Pinia和Vuex的区别" class="headerlink" title="Pinia和Vuex的区别"></a>Pinia和Vuex的区别</h4><p>Pinia主要是来替代Vuex的，pinia有更加简单的api，提供了composition api,和typesctript一起使用有更加可靠的类型推断支持</p><p>和vuex相比，pinia有很多优势</p><p>例如mutation不再存在</p><p>更好的typescript支持，vuex之前对ts的支持很不友好</p><p>不再有modules的嵌套解构，你可以灵活的使用每一个store，他们是通过扁平化的方式来进行相互使用</p><p>不再有命名空间的概念，不需要记住他们的复杂关系</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><div class="code-wrapper"><pre><code class="hljs mipsasm">yarn <span class="hljs-keyword">add </span>pinia<span class="hljs-comment"># or with npm</span>npm <span class="hljs-keyword">install </span>pinia</code></pre></div><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在vue3+vite中的使用</p><p>stores/index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> pinia</code></pre></div><p>main.js</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-keyword">import</span> pinia <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./stores&#x27;</span>createApp(App).use(pinia).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><h4 id="认识Store"><a href="#认识Store" class="headerlink" title="认识Store"></a>认识Store</h4><h5 id="什么是store"><a href="#什么是store" class="headerlink" title="什么是store"></a>什么是store</h5><p>一个store是一个实体，他会持有为绑定到组件树的状态和业务逻辑，换句话说，<strong>它托管全局状态</strong>。它有点像一个始终存在并且每个人都可以读取和写入的组件。你可以定义任意个store来管理你的状态。</p><h5 id="store有三个核心概念"><a href="#store有三个核心概念" class="headerlink" title="store有三个核心概念"></a>store有三个核心概念</h5><p>state，actions，getters，对应者数组的data，computed，methods</p><p>一旦store被实例化，你就可以直接在store上访问state，getters，actions中的任意属性</p><h4 id="定义Store"><a href="#定义Store" class="headerlink" title="定义Store"></a>定义Store</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><span class="hljs-keyword">const</span> useUser = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&quot;user&quot;</span>, &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <span class="hljs-attr">level</span>: <span class="hljs-number">100</span>  &#125;)&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useUser<span class="hljs-comment">//使用defineStore来定义store</span></code></pre></div><p>与Vue的Option API 类型类似的写法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Eduardo&#x27;</span> &#125;),  <span class="hljs-attr">getters</span>: &#123;    <span class="hljs-attr">doubleCount</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>,  &#125;,  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++    &#125;,  &#125;,&#125;)</code></pre></div><p>还有一种和setup函数类似的方法。我们可以传入一个定义响应式属性和方法的函数，并返回一个包含我们想要公开的属性和方法的对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//state</span>  <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Eduardo&#x27;</span>)  <span class="hljs-keyword">const</span> doubleCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>)<span class="hljs-comment">//getters</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;    count.<span class="hljs-property">value</span>++  &#125;<span class="hljs-comment">//actions</span>  <span class="hljs-keyword">return</span> &#123; count, name, doubleCount, increment &#125;&#125;)</code></pre></div><p>在组件中的使用</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;  <span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>  <span class="hljs-keyword">import</span> &#123; storeToRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>  <span class="hljs-keyword">import</span> useCounter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/counter&#x27;</span>;  <span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounter</span>()<span class="hljs-comment">//如果需要解构state并保持响应性，可以使用toRefs/storeToRefs</span><span class="hljs-comment">// const &#123; count &#125; = toRefs(counterStore)</span>  <span class="hljs-keyword">const</span> &#123; count &#125; = <span class="hljs-title function_">storeToRefs</span>(counterStore)  <span class="hljs-keyword">function</span> <span class="hljs-title function_">incrementCount</span>(<span class="hljs-params"></span>) &#123;    counterStore.<span class="hljs-property">count</span>++  &#125;&lt;/script&gt;</code></pre></div><h4 id="state的使用"><a href="#state的使用" class="headerlink" title="state的使用"></a><code>state</code>的使用</h4><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> store = useStore()store.<span class="hljs-keyword">count</span>++</code></pre></div><p>重置state</p><div class="code-wrapper"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> store = useStore()store.$reset()</code></pre></div><div class="code-wrapper"><pre><code class="hljs pf"> // <span class="hljs-number">1</span>.一个个修改状态     <span class="hljs-keyword">user</span>Store.name = <span class="hljs-string">&quot;kobe&quot;</span>     <span class="hljs-keyword">user</span>Store.age = <span class="hljs-number">20</span>     <span class="hljs-keyword">user</span>Store.level = <span class="hljs-number">200</span>    // <span class="hljs-number">2</span>.一次性修改多个状态     <span class="hljs-keyword">user</span>Store.<span class="hljs-variable">$patch</span>(&#123;       name: <span class="hljs-string">&quot;james&quot;</span>,       age: <span class="hljs-number">35</span>     &#125;)  //<span class="hljs-variable">$patch</span>还可以传入一个函数  cartStore.<span class="hljs-variable">$patch</span>((<span class="hljs-keyword">state</span>) =&gt; &#123;  <span class="hljs-keyword">state</span>.items.push(&#123; name: &#x27;shoes&#x27;, quantity: <span class="hljs-number">1</span> &#125;)  <span class="hljs-keyword">state</span>.hasChanged = true&#125;)</code></pre></div><p>替换state</p><p>你不能替换整个state,可以整合它</p><div class="code-wrapper"><pre><code class="hljs reasonml">store.<span class="hljs-constructor">$patch(&#123; <span class="hljs-params">count</span>: 24 &#125;)</span></code></pre></div><h4 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">getters</span>: &#123;    <span class="hljs-comment">// 1.基本使用</span>    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-comment">// 2.一个getter引入另外一个getter</span>    <span class="hljs-title function_">doubleCountAddOne</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-comment">// this是store实例</span>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">doubleCount</span> + <span class="hljs-number">1</span>    &#125;,    <span class="hljs-comment">// 3.getters也支持返回一个函数</span>    <span class="hljs-title function_">getFriendById</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; state.<span class="hljs-property">friends</span>.<span class="hljs-property">length</span>; i++) &#123;          <span class="hljs-keyword">const</span> friend = state.<span class="hljs-property">friends</span>[i]          <span class="hljs-keyword">if</span> (friend.<span class="hljs-property">id</span> === id) &#123;            <span class="hljs-keyword">return</span> friend          &#125;        &#125;      &#125;    &#125;,    <span class="hljs-comment">// 4.getters中用到别的store中的数据</span>    <span class="hljs-title function_">showMessage</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-comment">// 1.获取user信息</span>      <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUser</span>()      <span class="hljs-comment">// 2.获取自己的信息</span>      <span class="hljs-comment">// 3.拼接信息</span>      <span class="hljs-keyword">return</span> <span class="hljs-string">`name:<span class="hljs-subst">$&#123;userStore.name&#125;</span>-count:<span class="hljs-subst">$&#123;state.count&#125;</span>`</span>    &#125;  &#125;,</code></pre></div><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>actions相当于是methods</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,  &#125;),  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-comment">// since we rely on `this`, we cannot use an arrow function</span>      <span class="hljs-comment">//这里依赖this,所以不能使用箭头函数</span>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++    &#125;,    <span class="hljs-title function_">randomizeCounter</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">100</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>())    &#125;,  &#125;,&#125;)</code></pre></div><p>在actions中可以定义异步函数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mande &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mande&#x27;</span><span class="hljs-keyword">const</span> api = <span class="hljs-title function_">mande</span>(<span class="hljs-string">&#x27;/api/users&#x27;</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUsers = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;users&#x27;</span>, &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-attr">userData</span>: <span class="hljs-literal">null</span>,    <span class="hljs-comment">// ...</span>  &#125;),  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-keyword">async</span> <span class="hljs-title function_">registerUser</span>(<span class="hljs-params">login, password</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">userData</span> = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">post</span>(&#123; login, password &#125;)        <span class="hljs-title function_">showTooltip</span>(<span class="hljs-string">`Welcome back <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.userData.name&#125;</span>!`</span>)      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-title function_">showTooltip</span>(error)        <span class="hljs-comment">// let the form component display the error</span>        <span class="hljs-keyword">return</span> error      &#125;    &#125;,  &#125;,&#125;)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex4.0</title>
    <link href="/2022/08/23/vuex4-0/"/>
    <url>/2022/08/23/vuex4-0/</url>
    
    <content type="html"><![CDATA[<h4 id="Vuex-是什么"><a href="#Vuex-是什么" class="headerlink" title="Vuex 是什么"></a>Vuex 是什么</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式 + 库</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p><img src="https://vuex.vuejs.org/vuex.png"></p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install vuex@next --save</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//store/index.js</span><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">CHANGE_INFO</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mutation_types&#x27;</span><span class="hljs-keyword">import</span> homeModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/home&#x27;</span><span class="hljs-keyword">import</span> counterModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/counter&#x27;</span><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-comment">// 模拟数据</span>    <span class="hljs-comment">// counter: 100,</span>    <span class="hljs-attr">rootCounter</span>: <span class="hljs-number">100</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;coderwhy&quot;</span>,    <span class="hljs-attr">level</span>: <span class="hljs-number">100</span>,    <span class="hljs-attr">avatarURL</span>: <span class="hljs-string">&quot;http://xxxxxx&quot;</span>,    <span class="hljs-attr">friends</span>: [      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">112</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;,      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">113</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;james&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;    ],    <span class="hljs-comment">// 服务器数据</span>    <span class="hljs-comment">// banners: [],</span>    <span class="hljs-comment">// recommends: []</span>  &#125;),  <span class="hljs-attr">getters</span>: &#123;    <span class="hljs-comment">// 1.基本使用</span>    <span class="hljs-title function_">doubleCounter</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">counter</span> * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-title function_">totalAge</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">friends</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">preValue, item</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> preValue + item.<span class="hljs-property">age</span>      &#125;, <span class="hljs-number">0</span>)    &#125;,    <span class="hljs-comment">// 2.在该getters属性中, 获取其他的getters</span>    <span class="hljs-title function_">message</span>(<span class="hljs-params">state, getters</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">`name:<span class="hljs-subst">$&#123;state.name&#125;</span> level:<span class="hljs-subst">$&#123;state.level&#125;</span> friendTotalAge:<span class="hljs-subst">$&#123;getters.totalAge&#125;</span>`</span>    &#125;,    <span class="hljs-comment">// 3.getters是可以返回一个函数的, 调用这个函数可以传入参数(了解)</span>    <span class="hljs-title function_">getFriendById</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) &#123;        <span class="hljs-keyword">const</span> friend = state.<span class="hljs-property">friends</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === id)        <span class="hljs-keyword">return</span> friend      &#125;    &#125;  &#125;,  <span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;      state.<span class="hljs-property">counter</span>++    &#125;,    <span class="hljs-title function_">changeName</span>(<span class="hljs-params">state, payload</span>) &#123;      state.<span class="hljs-property">name</span> = payload    &#125;,    <span class="hljs-title function_">incrementLevel</span>(<span class="hljs-params">state</span>) &#123;      state.<span class="hljs-property">level</span>++    &#125;,     <span class="hljs-comment">//使用计算属性，将常量作为参数名</span>    [<span class="hljs-variable constant_">CHANGE_INFO</span>](state, newInfo) &#123;      state.<span class="hljs-property">level</span> = newInfo.<span class="hljs-property">level</span>      state.<span class="hljs-property">name</span> = newInfo.<span class="hljs-property">name</span>      <span class="hljs-comment">// 重要的原则: 不要在mutation方法中执行异步操作</span>      <span class="hljs-comment">// fetch(&quot;xxxx&quot;).then(res =&gt; &#123;</span>      <span class="hljs-comment">//   res.json().then(res =&gt; &#123;</span>      <span class="hljs-comment">//     state.name = res.name</span>      <span class="hljs-comment">//   &#125;)</span>      <span class="hljs-comment">// &#125;)</span>    &#125;,    <span class="hljs-comment">// changeBanners(state, banners) &#123;</span>    <span class="hljs-comment">//   state.banners = banners</span>    <span class="hljs-comment">// &#125;,</span>    <span class="hljs-comment">// changeRecommends(state, recommends) &#123;</span>    <span class="hljs-comment">//   state.recommends = recommends</span>    <span class="hljs-comment">// &#125;</span>  &#125;,  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-title function_">incrementAction</span>(<span class="hljs-params">context</span>) &#123;      <span class="hljs-comment">// console.log(context.commit) // 用于提交mutation</span>      <span class="hljs-comment">// console.log(context.getters) // getters</span>      <span class="hljs-comment">// console.log(context.state) // state</span>      context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;increment&quot;</span>)    &#125;,    <span class="hljs-title function_">changeNameAction</span>(<span class="hljs-params">context, payload</span>) &#123;      context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;changeName&quot;</span>, payload)    &#125;,    <span class="hljs-comment">// fetchHomeMultidataAction(context) &#123;</span>    <span class="hljs-comment">//   // 1.返回Promise, 给Promise设置then</span>    <span class="hljs-comment">//   // fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;</span>    <span class="hljs-comment">//   //   res.json().then(data =&gt; &#123;</span>    <span class="hljs-comment">//   //     console.log(data)</span>    <span class="hljs-comment">//   //   &#125;)</span>    <span class="hljs-comment">//   // &#125;)</span>          <span class="hljs-comment">//   // 2.Promise链式调用</span>    <span class="hljs-comment">//   // fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;</span>    <span class="hljs-comment">//   //   return res.json()</span>    <span class="hljs-comment">//   // &#125;).then(data =&gt; &#123;</span>    <span class="hljs-comment">//   //   console.log(data)</span>    <span class="hljs-comment">//   // &#125;)</span>    <span class="hljs-comment">//   return new Promise(async (resolve, reject) =&gt; &#123;</span>    <span class="hljs-comment">//     // 3.await/async</span>    <span class="hljs-comment">//     const res = await fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;)</span>    <span class="hljs-comment">//     const data = await res.json()</span>            <span class="hljs-comment">//     // 修改state数据</span>    <span class="hljs-comment">//     context.commit(&quot;changeBanners&quot;, data.data.banner.list)</span>    <span class="hljs-comment">//     context.commit(&quot;changeRecommends&quot;, data.data.recommend.list)</span>    <span class="hljs-comment">//     resolve(&quot;aaaaa&quot;)</span>    <span class="hljs-comment">//   &#125;)</span>    <span class="hljs-comment">// &#125;</span>  &#125;,  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">home</span>: homeModule,    <span class="hljs-attr">counter</span>: counterModule  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-comment">//main.js</span><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>createApp(App).use(store).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>state中主要是管理全局的状态，所有状态都存储在state中</p><div class="code-wrapper"><pre><code class="hljs pf">//<span class="hljs-keyword">state</span>要放到computed中去使用export <span class="hljs-keyword">default</span> &#123;   computed: &#123;     storeCounter() &#123;       return this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.counter     &#125;   &#125; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//在setup中使用state 需要使用useStore</span>&lt;script setup&gt;  <span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>  <span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()  <span class="hljs-comment">// 如果对store.state进行解构或者赋值给另外一个变量，会变成非响应式的，要使用toRefs</span>  <span class="hljs-keyword">const</span> &#123; counter &#125; = <span class="hljs-title function_">toRefs</span>(store.<span class="hljs-property">state</span>)    <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// store.state.counter++</span>    store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;increment&quot;</span>)  &#125;&lt;/script&gt;</code></pre></div><h5 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a><code>mapState</code> 辅助函数</h5><p><code>mapState</code> 辅助函数帮助我们生成计算属性</p><div class="code-wrapper"><pre><code class="hljs pf">/ 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; <span class="hljs-keyword">from</span> &#x27;vuex&#x27;export <span class="hljs-keyword">default</span> &#123;  // ...  computed: mapState(&#123;    // 箭头函数可使代码更简练    count: <span class="hljs-keyword">state</span> =&gt; <span class="hljs-keyword">state</span>.count,    // 传字符串参数 &#x27;count&#x27; 等同于 `<span class="hljs-keyword">state</span> =&gt; <span class="hljs-keyword">state</span>.count`    countAlias: &#x27;count&#x27;,    // 为了能够使用 `this` 获取局部状态，必须使用常规函数    countPlusLocalState (<span class="hljs-keyword">state</span>) &#123;      return <span class="hljs-keyword">state</span>.count + this.localCount    &#125;  &#125;)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">computed: mapState([  <span class="hljs-regexp">//</span> 映射 this.count 为 store.state.count  <span class="hljs-string">&#x27;count&#x27;</span>])<span class="hljs-regexp">//</span>还可以传递数组</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">computed: &#123;  localComputed () &#123; <span class="hljs-regexp">/* ... */</span> &#125;,  <span class="hljs-regexp">//</span> 使用对象展开运算符将此对象混入到外部对象中  ...mapState(&#123;    <span class="hljs-regexp">//</span> ...  &#125;)&#125;</code></pre></div><p>//使用展开运算符和其他computed合并</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;     <span class="hljs-title function_">fullname</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xxx&quot;</span>     &#125;,     <span class="hljs-comment">// name() &#123;</span>     <span class="hljs-comment">//   return this.$store.state.name</span>     <span class="hljs-comment">// &#125;,</span>     ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;level&quot;</span>, <span class="hljs-string">&quot;avatarURL&quot;</span>]),     ...<span class="hljs-title function_">mapState</span>(&#123;       <span class="hljs-attr">sName</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">name</span>,       <span class="hljs-attr">sLevel</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">level</span>     &#125;)   &#125; &#125;</code></pre></div><h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><p>getter类似于vue的computed</p><p>Getter 接受 state 作为其第一个参数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-attr">state</span>: &#123;    <span class="hljs-attr">todos</span>: [      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;    ]  &#125;,  <span class="hljs-attr">getters</span>: &#123;    doneTodos (state) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">todos</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">done</span>)    &#125;  &#125;&#125;)</code></pre></div><h5 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h5><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p><div class="code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">store</span>.getters.doneTodos // -&gt;</span> [&#123; id: <span class="hljs-number">1</span>, <span class="hljs-keyword">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, done: <span class="hljs-literal">true</span> &#125;]</code></pre></div><p>Getter 也可以接受其他 getter 作为第二个参数：</p><div class="code-wrapper"><pre><code class="hljs stylus">getters: &#123;  <span class="hljs-comment">// ...</span>  doneTodosCount (state, getters) &#123;    return getters<span class="hljs-selector-class">.doneTodos</span><span class="hljs-selector-class">.length</span>  &#125;&#125;store<span class="hljs-selector-class">.getters</span><span class="hljs-selector-class">.doneTodosCount</span> <span class="hljs-comment">// -&gt; 1</span></code></pre></div><p>我们可以很容易地在任何组件中使用它：</p><div class="code-wrapper"><pre><code class="hljs kotlin">computed: &#123;  doneTodosCount () &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.getters.doneTodosCount  &#125;&#125;</code></pre></div><p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p><h5 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h5><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><div class="code-wrapper"><pre><code class="hljs pf">getters: &#123;  // ...  getTodoById: (<span class="hljs-keyword">state</span>) =&gt; (id) =&gt; &#123;    return <span class="hljs-keyword">state</span>.todos.find(todo =&gt; todo.id === id)  &#125;&#125;store.getters.getTodoById(<span class="hljs-number">2</span>) // -&gt; &#123; id: <span class="hljs-number">2</span>, text: &#x27;...&#x27;, done: false &#125;</code></pre></div><p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果</p><h5 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a><code>mapGetters</code> 辅助函数</h5><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">computed</span>: &#123;  <span class="hljs-comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>    ...<span class="hljs-title function_">mapGetters</span>([      <span class="hljs-string">&#x27;doneTodosCount&#x27;</span>,      <span class="hljs-string">&#x27;anotherGetter&#x27;</span>,      <span class="hljs-comment">// ...</span>    ])  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">...mapGetters(&#123;  <span class="hljs-regexp">//</span> 把 `this.doneCount` 映射为 `this.<span class="hljs-variable">$store</span>.getters.doneTodosCount`  doneCount: <span class="hljs-string">&#x27;doneTodosCount&#x27;</span>&#125;)<span class="hljs-regexp">//</span>还可以取别名</code></pre></div><h5 id="在setup中使用"><a href="#在setup中使用" class="headerlink" title="在setup中使用"></a>在setup中使用</h5><div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;  <span class="hljs-keyword">import</span> &#123; computed, toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;  <span class="hljs-keyword">import</span> &#123; mapGetters, useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()  <span class="hljs-comment">// 1.使用mapGetters</span>  <span class="hljs-comment">// const &#123; message: messageFn &#125; = mapGetters([&quot;message&quot;])</span>  <span class="hljs-comment">// const message = computed(messageFn.bind(&#123; $store: store &#125;))</span>  <span class="hljs-comment">// 2.直接解构, 并且包裹成ref</span>  <span class="hljs-comment">// const &#123; message &#125; = toRefs(store.getters)</span>  <span class="hljs-comment">// 3.针对某一个getters属性使用computed</span>  <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">message</span>)  <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeAge</span>(<span class="hljs-params"></span>) &#123;    store.<span class="hljs-property">state</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>  &#125;&lt;/script&gt;</code></pre></div><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p><p>mutation的使用</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">CHANGE_INFO</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store/mutation_types&quot;</span> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;   <span class="hljs-attr">computed</span>: &#123;   &#125;,   <span class="hljs-attr">methods</span>: &#123;     <span class="hljs-title function_">changeName</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-comment">// this.$store.state.name = &quot;李银河&quot;</span>       <span class="hljs-comment">//传参方式</span>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;changeName&quot;</span>, <span class="hljs-string">&quot;王小波&quot;</span>)     &#125;,     <span class="hljs-title function_">incrementLevel</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;incrementLevel&quot;</span>)     &#125;,     <span class="hljs-title function_">changeInfo</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">//这是定义常量的方式</span>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-variable constant_">CHANGE_INFO</span>, &#123;         <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;王二&quot;</span>,         <span class="hljs-attr">level</span>: <span class="hljs-number">200</span>       &#125;)     &#125;   &#125; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pf">//在mutation中commit<span class="hljs-keyword">const</span> store = createStore(&#123;  <span class="hljs-keyword">state</span>: () =&gt; (&#123;    name: <span class="hljs-string">&quot;张三&quot;</span>,  &#125;),  mutations: &#123;    updateMut(<span class="hljs-keyword">state</span>, playload) &#123;      <span class="hljs-keyword">state</span>.name = playload;    &#125;,    updateMut2(<span class="hljs-keyword">state</span>, playload) &#123;      store.commit(<span class="hljs-string">&quot;updateMut&quot;</span>, playload);    &#125;,  &#125;,&#125;);</code></pre></div><h5 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h5><div class="code-wrapper"><pre><code class="hljs pf">mutations: &#123;  someMutation (<span class="hljs-keyword">state</span>) &#123;    api.callAsyncMethod(() =&gt; &#123;      <span class="hljs-keyword">state</span>.count++    &#125;)  &#125;&#125;</code></pre></div><p>我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><h5 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h5><div class="code-wrapper"><pre><code class="hljs awk">methods: &#123;      btnClick() &#123;        console.log(<span class="hljs-string">&quot;btnClick&quot;</span>)      &#125;,      <span class="hljs-regexp">//</span> ...mapMutations([<span class="hljs-string">&quot;changeName&quot;</span>, <span class="hljs-string">&quot;incrementLevel&quot;</span>, CHANGE_INFO])  使用常量，在template中要使用正确的函数名    &#125;</code></pre></div><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">store.<span class="hljs-built_in">dispatch</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//在action中也可以分发action</span>actions: &#123;  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">actionA</span> (<span class="hljs-params">&#123; commit &#125;</span>)</span> &#123;    commit(<span class="hljs-string">&#x27;gotData&#x27;</span>, <span class="hljs-keyword">await</span> getData())  &#125;,  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">actionB</span> (<span class="hljs-params">&#123; dispatch, commit &#125;</span>)</span> &#123;    <span class="hljs-keyword">await</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>) <span class="hljs-comment">// 等待 actionA 完成</span>    commit(<span class="hljs-string">&#x27;gotOtherData&#x27;</span>, <span class="hljs-keyword">await</span> getOtherData())  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在组件中使用methods: &#123;     <span class="hljs-regexp">//</span> counterBtnClick() &#123;     <span class="hljs-regexp">//</span>   this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&quot;incrementAction&quot;</span>)     <span class="hljs-regexp">//</span> &#125;,     <span class="hljs-regexp">//</span> nameBtnClick() &#123;     <span class="hljs-regexp">//</span>   this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&quot;changeNameAction&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>)     <span class="hljs-regexp">//</span> &#125;     <span class="hljs-regexp">//</span> ...mapActions([<span class="hljs-string">&quot;incrementAction&quot;</span>, <span class="hljs-string">&quot;changeNameAction&quot;</span>])   &#125;</code></pre></div><h4 id="Modules的使用"><a href="#Modules的使用" class="headerlink" title="Modules的使用"></a>Modules的使用</h4><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">actions</span>: &#123; ... &#125;,  <span class="hljs-attr">getters</span>: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> moduleB = &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">actions</span>: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">a</span>: moduleA,    <span class="hljs-attr">b</span>: moduleB  &#125;&#125;)store.<span class="hljs-property">state</span>.<span class="hljs-property">a</span> <span class="hljs-comment">// -&gt; moduleA 的状态</span>store.<span class="hljs-property">state</span>.<span class="hljs-property">b</span> <span class="hljs-comment">// -&gt; moduleB 的状态</span></code></pre></div><p>当没有添加namaspaced默认情况下使用module的值</p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 1.使用state时, 是需要state.moduleName.xxx --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Counter模块的counter: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.state.counter.count</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 2.使用getters时, 是直接getters.xxx --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Counter模块的doubleCounter: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.getters.doubleCount</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementCount&quot;</span>&gt;</span>count模块+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 告诉Vuex发起网络请求</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 派发事件时, 默认也是不需要跟模块名称</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 提交mutation时, 默认也是不需要跟模块名称</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">incrementCount</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&quot;incrementCountAction&quot;</span>)</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">actions</span>: &#123;    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;      <span class="hljs-keyword">if</span> ((state.<span class="hljs-property">count</span> + rootState.<span class="hljs-property">count</span>) % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)      &#125;    &#125;  &#125;&#125;</code></pre></div><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">getters</span>: &#123;    sumWithRootCount (state, getters, rootState) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> + rootState.<span class="hljs-property">count</span>    &#125;  &#125;&#125;</code></pre></div><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>默认情况下，模块内部的 action 和 mutation 仍然是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一个 action 或 mutation 作出响应。Getter 同样也默认注册在全局命名空间，但是目前这并非出于功能上的目的（仅仅是维持现状来避免非兼容性变更）。必须注意，不要在不同的、无命名空间的模块中定义两个相同的 getter 从而导致错误。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">account</span>: &#123;      <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,      <span class="hljs-comment">// 模块内容（module assets）</span>      <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;), <span class="hljs-comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>      <span class="hljs-attr">getters</span>: &#123;        isAdmin () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span>      &#125;,      <span class="hljs-attr">actions</span>: &#123;        login () &#123; ... &#125; <span class="hljs-comment">// -&gt; dispatch(&#x27;account/login&#x27;)</span>      &#125;,      <span class="hljs-attr">mutations</span>: &#123;        login () &#123; ... &#125; <span class="hljs-comment">// -&gt; commit(&#x27;account/login&#x27;)</span>      &#125;,      <span class="hljs-comment">// 嵌套模块</span>      <span class="hljs-attr">modules</span>: &#123;        <span class="hljs-comment">// 继承父模块的命名空间</span>        <span class="hljs-attr">myPage</span>: &#123;          <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),          <span class="hljs-attr">getters</span>: &#123;            profile () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/profile&#x27;]</span>          &#125;        &#125;,        <span class="hljs-comment">// 进一步嵌套命名空间</span>        <span class="hljs-attr">posts</span>: &#123;          <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,          <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),          <span class="hljs-attr">getters</span>: &#123;            popular () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/posts/popular&#x27;]</span>          &#125;        &#125;      &#125;    &#125;  &#125;&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml">//在组件中的写法</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 1.使用state时, 是需要state.moduleName.xxx --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Counter模块的counter: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.state.counter.count</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 2.使用getters时, 是直接getters.xxx --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Counter模块的doubleCounter: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.getters</span>[&quot;counter/doubleCount&quot;] &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementCount&quot;</span>&gt;</span>count模块+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 告诉Vuex发起网络请求</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 派发事件时, 默认也是不需要跟模块名称</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 提交mutation时, 默认也是不需要跟模块名称</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">incrementCount</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&quot;counter/incrementCountAction&quot;</span>)<span class="hljs-comment">//有命名空间的写法</span></span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p><h5 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h5><p>如果你希望使用全局 state 和 getter，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">modules</span>: &#123;  <span class="hljs-attr">foo</span>: &#123;    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">getters</span>: &#123;      <span class="hljs-comment">// 在这个模块的 getter 中，`getters` 被局部化了</span>      <span class="hljs-comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span>      someGetter (state, getters, rootState, rootGetters) &#123;        getters.<span class="hljs-property">someOtherGetter</span> <span class="hljs-comment">// -&gt; &#x27;foo/someOtherGetter&#x27;</span>        rootGetters.<span class="hljs-property">someOtherGetter</span> <span class="hljs-comment">// -&gt; &#x27;someOtherGetter&#x27;</span>        rootGetters[<span class="hljs-string">&#x27;bar/someOtherGetter&#x27;</span>] <span class="hljs-comment">// -&gt; &#x27;bar/someOtherGetter&#x27;</span>      &#125;,      <span class="hljs-attr">someOtherGetter</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; ... &#125;    &#125;,    <span class="hljs-attr">actions</span>: &#123;      <span class="hljs-comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span>      <span class="hljs-comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span>      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;        getters.<span class="hljs-property">someGetter</span> <span class="hljs-comment">// -&gt; &#x27;foo/someGetter&#x27;</span>        rootGetters.<span class="hljs-property">someGetter</span> <span class="hljs-comment">// -&gt; &#x27;someGetter&#x27;</span>        rootGetters[<span class="hljs-string">&#x27;bar/someGetter&#x27;</span>] <span class="hljs-comment">// -&gt; &#x27;bar/someGetter&#x27;</span>        <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someOtherAction&#x27;</span>        <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someOtherAction&#x27;</span>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;someMutation&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someMutation&#x27;</span>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;someMutation&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someMutation&#x27;</span>      &#125;,      someOtherAction (ctx, payload) &#123; ... &#125;    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router笔记</title>
    <link href="/2022/08/20/vue-router%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/20/vue-router%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址"><a href="#路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址" class="headerlink" title="路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址"></a>路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址</h4><h4 id="url的hash"><a href="#url的hash" class="headerlink" title="url的hash"></a>url的hash</h4><p>url的hash也就是锚点(#),本质上就是改变window.location的href的属性</p><p>我们可以通过赋值location.hash来改变href,但是不刷新页面</p><p>hash的优势就是兼容性好，在IE中可以运行，但是就是有个缺陷，#，显得不像是一个真实的路径</p><div class="code-wrapper"><pre><code class="hljs js">&lt;body&gt;    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/home&quot;</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/about&quot;</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#app&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;hashchange&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">switch</span> (location.<span class="hljs-property">hash</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;#/home&quot;</span>:</span></span><span class="language-javascript"><span class="language-xml">            app.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;home&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;#/about&quot;</span>:</span></span><span class="language-javascript"><span class="language-xml">            app.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;about&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">default</span>:</span></span><span class="language-javascript"><span class="language-xml">            app.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;app&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">        &#125;</span></span><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>  &lt;/body&gt;</code></pre></div><h4 id="html5-history-api"><a href="#html5-history-api" class="headerlink" title="html5 history api"></a>html5 history api</h4><p>history是html5新增的api 他有六种模式改变url而不刷新页面</p><p>replaceState  替换原来的路径</p><p>pushState  使用新的路径</p><p>popState 路径回退</p><p>go 向前或者向后改变路径</p><p>forward 向前改变路径</p><p>back 向后改变路径</p><div class="code-wrapper"><pre><code class="hljs js">&lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> show = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&quot;show&quot;</span>)[<span class="hljs-number">0</span>];</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> elea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;a&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elea);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;popstate&quot;</span>, historyChange);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;go&quot;</span>, historyChange);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> elea) &#123;</span></span><span class="language-javascript"><span class="language-xml">        item.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">          e.<span class="hljs-title function_">preventDefault</span>();</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">const</span> href = item.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;href&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(href);</span></span><span class="language-javascript"><span class="language-xml">          history.<span class="hljs-title function_">pushState</span>(&#123;&#125;, <span class="hljs-string">&quot;&quot;</span>, href);</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">historyChange</span>();</span></span><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">historyChange</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">switch</span> (location.<span class="hljs-property">pathname</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/about&quot;</span>:</span></span><span class="language-javascript"><span class="language-xml">            show.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;about&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/home&quot;</span>:</span></span><span class="language-javascript"><span class="language-xml">            show.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;home&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">default</span>:</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">        &#125;</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;</code></pre></div><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> vue-router</code></pre></div><h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><p>router/index.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;  createRouter,  createWebHashHistory,  createWebHistory,&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<span class="hljs-comment">// import Home from &#x27;../Views/Home.vue&#x27;</span><span class="hljs-comment">// import About from &#x27;../Views/About.vue&#x27;</span><span class="hljs-comment">// 路由的懒加载 ，可以进行分包，减少报的大小，进行按需加载   webpackChunkName设置包的名字</span><span class="hljs-comment">// const Home = () =&gt; import(/* webpackChunkName: &#x27;home&#x27; */&quot;../Views/Home.vue&quot;)</span><span class="hljs-comment">// const About = () =&gt; import(/* webpackChunkName: &#x27;about&#x27; */&quot;../Views/About.vue&quot;)</span><span class="hljs-comment">// 创建一个路由: 映射关系</span><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;  <span class="hljs-comment">// 指定采用的模式: hash</span>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),  <span class="hljs-comment">// history: createWebHistory(),</span>  <span class="hljs-comment">// 映射关系</span>  <span class="hljs-attr">routes</span>: [    &#123;<span class="hljs-comment">//设置默认路径并进行重定向</span>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,      <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/home&quot;</span>,    &#125;,    &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>,<span class="hljs-comment">//路由记录独一无二的名称</span>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/Home.vue&quot;</span>),<span class="hljs-comment">//组件懒加载</span>      <span class="hljs-attr">meta</span>: &#123;<span class="hljs-comment">//这是路由元信息，不在url中携带的信息</span>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,      &#125;,       <span class="hljs-comment">//子路由</span>      <span class="hljs-attr">children</span>: [        &#123;          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,          <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/home/recommend&quot;</span>,        &#125;,        &#123;          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;recommend&quot;</span>, <span class="hljs-comment">// /home/recommend</span>          <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/HomeRecommend.vue&quot;</span>),        &#125;,        &#123;          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;ranking&quot;</span>, <span class="hljs-comment">// /home/ranking</span>          <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/HomeRanking.vue&quot;</span>),        &#125;,      ],    &#125;,    &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;about&quot;</span>,      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/About.vue&quot;</span>),    &#125;,    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:id&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/User.vue&quot;</span>),    &#125;,    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/order&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/Order.vue&quot;</span>),    &#125;,    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/Login.vue&quot;</span>),    &#125;,    &#123;      <span class="hljs-comment">// abc/cba/nba  配置404页面</span>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/:pathMatch(.*)*&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/NotFound.vue&quot;</span>),    &#125;,  ],&#125;);<span class="hljs-comment">// 1.动态管理路由</span><span class="hljs-keyword">let</span> isAdmin = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (isAdmin) &#123;  <span class="hljs-comment">// 一级路由</span>  router.<span class="hljs-title function_">addRoute</span>(&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/admin&quot;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/Admin.vue&quot;</span>),  &#125;);  <span class="hljs-comment">// 添加vip页面 &quot;home&quot;必须唯一</span>  router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&quot;home&quot;</span>, &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;vip&quot;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/HomeVip.vue&quot;</span>),  &#125;);&#125;<span class="hljs-comment">// 获取router中所有的映射路由对象</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(router.<span class="hljs-title function_">getRoutes</span>());<span class="hljs-comment">// 2.路由导航守卫</span><span class="hljs-comment">// 进行任何的路由跳转之前, 传入的beforeEach中的函数都会被回调</span><span class="hljs-comment">// 需求: 进入到订单(order)页面时, 判断用户是否登录(isLogin -&gt; localStorage保存token)</span><span class="hljs-comment">// 情况一: 用户没有登录, 那么跳转到登录页面, 进行登录的操作</span><span class="hljs-comment">// 情况二: 用户已经登录, 那么直接进入到订单页面</span>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// 1.进入到任何别的页面时, 都跳转到login页面</span>  <span class="hljs-comment">// if (to.path !== &quot;/login&quot;) &#123;</span>  <span class="hljs-comment">//   return &quot;/login&quot;</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-comment">// 2.进入到订单页面时, 判断用户是否登录</span>  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">&quot;/order&quot;</span> &amp;&amp; !token) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/login&quot;</span>;  &#125;&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;</code></pre></div><p>//main.js</p><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-comment">// 5. 创建并挂载根实例</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">app</span> = Vue.createApp(<span class="hljs-keyword">App</span>)<span class="hljs-comment">//确保 _use_ 路由实例使</span><span class="hljs-comment">//整个应用支持路由。注册插件</span><span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(router)<span class="hljs-keyword">app</span>.mount(&#x27;#<span class="hljs-keyword">app</span>&#x27;)</code></pre></div><p>在组建中使用</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span>//home.vue<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home-nav&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/recommend&quot;</span>&gt;</span>推荐<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/ranking&quot;</span>&gt;</span>排行<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;logoutClick&quot;</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 占位组件 --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></code></pre></div><h2 id="lt-router-link-gt-Props"><a href="#lt-router-link-gt-Props" class="headerlink" title="&lt;router-link&gt; Props"></a><code>&lt;router-link&gt;</code> Props</h2><p>表示目标路由的链接。当被点击后，内部会立刻把 <code>to</code> 的值传到 <code>router.push()</code>，所以这个值可以是一个 <code>string</code> 或者是<a href="https://router.vuejs.org/zh/api/#routelocationraw">描述目标位置的对象</a>。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 字符串 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-comment">&lt;!-- 渲染结果 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#x27;/home&#x27;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-comment">&lt;!-- 同上 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/home&#x27; &#125;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-comment">&lt;!-- 命名的路由 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: &#x27;123&#x27; &#125;&#125;&quot;</span>&gt;</span>User<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-comment">&lt;!-- 带查询参数，下面的结果为 `/register?plan=private` --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125;&#125;&quot;</span>&gt;</span>  Register<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></code></pre></div><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>设置 <code>replace</code> 属性的话，当点击时，会调用 <code>router.replace()</code>，而不是 <code>router.push()</code>，所以导航后不会留下历史记录。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/abc&quot;</span> <span class="hljs-attr">replace</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></code></pre></div><h5 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h5><p>链接激活时，应用于渲染的 <code>&lt;a&gt;</code> 的 class</p><p><strong>默认值</strong>：<code>&quot;router-link-active&quot;</code></p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;router-link <span class="hljs-attribute">to</span>=<span class="hljs-string">&quot;/about&quot;</span> replace <span class="hljs-attribute">active-class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;关于&lt;/router-link&gt;</code></pre></div><p>可以修改默认的class或者添加新的class</p><h5 id="exact-active-class"><a href="#exact-active-class" class="headerlink" title="exact-active-class"></a>exact-active-class</h5><p>链接精准激活时，应用于渲染的 <code>&lt;a&gt;</code> 的 class</p><p><strong>默认值</strong>：<code>&quot;router-link-exact-active&quot;</code></p><h4 id="带参数的动态路由匹配"><a href="#带参数的动态路由匹配" class="headerlink" title="带参数的动态路由匹配"></a>带参数的动态路由匹配</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User&lt;/div&gt;&#x27;</span>,&#125;<span class="hljs-comment">// 这些都会传递给 `createRouter`</span><span class="hljs-keyword">const</span> routes = [  <span class="hljs-comment">// 动态字段以冒号开始</span>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> &#125;,]</code></pre></div><p>参数可以被当前路由的params获取</p><div class="code-wrapper"><pre><code class="hljs crmsh">const <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;</span><span class="hljs-title">  template</span>: &#x27;<span class="hljs-tag">&lt;div&gt;</span><span class="hljs-keyword">User</span> <span class="hljs-title">&#123;&#123; $route</span>.<span class="hljs-keyword">params</span>.id &#125;&#125;<span class="hljs-tag">&lt;/div&gt;</span>&#x27;,&#125;</code></pre></div><h5 id="监听响应路由参数的变化"><a href="#监听响应路由参数的变化" class="headerlink" title="监听响应路由参数的变化"></a>监听响应路由参数的变化</h5><p>使用带有参数的路由时需要注意的是，当用户从 <code>/users/johnny</code> 导航到 <code>/users/jolyne</code> 时，<strong>相同的组件实例将被重复使用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会被调用</strong>。</p><p>要对同一个组件中参数的变化做出响应的话，你可以简单地 watch <code>$route</code> 对象上的任意属性，在这个场景中，就是 <code>$route.params</code> ：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;...&#x27;</span>,  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.$watch(      <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>,      <span class="hljs-function">(<span class="hljs-params">toParams, previousParams</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 对路由变化做出响应...</span>      &#125;    )  &#125;,&#125;</code></pre></div><p>或者，使用 <code>beforeRouteUpdate</code> <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>，它也可以取消导航：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> User = &#123;  template: <span class="hljs-string">&#x27;...&#x27;</span>,  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>)</span> &#123;    <span class="hljs-comment">// 对路由变化做出响应...</span>    <span class="hljs-keyword">this</span>.userData = <span class="hljs-keyword">await</span> fetchUser(to.<span class="hljs-keyword">params</span>.id)  &#125;,&#125;</code></pre></div><h5 id="捕获所有路由或-404-Not-found-路由"><a href="#捕获所有路由或-404-Not-found-路由" class="headerlink" title="捕获所有路由或 404 Not found 路由"></a><strong>捕获所有路由或 404 Not found 路由</strong></h5><p>常规参数只匹配 url 片段之间的字符，用 <code>/</code> 分隔。如果我们想匹配<strong>任意路径</strong>，我们可以使用自定义的 <em>路径参数</em> 正则表达式，在 <em>路径参数</em> 后面的括号中加入 正则表达式 :</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  <span class="hljs-comment">// 将匹配所有内容并将其放在 `$route.params.pathMatch` 下</span>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:pathMatch(.*)*&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;NotFound&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFound</span> &#125;,  <span class="hljs-comment">// 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下</span>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user-:afterUser(.*)&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserGeneric</span> &#125;,]</code></pre></div><p>在这个特定的场景中，我们在括号之间使用了<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%9C%A8%E5%8F%82%E6%95%B0%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99">自定义正则表达式</a>，并将<code>pathMatch</code> 参数标记为<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0">可选可重复</a>。这样做是为了让我们在需要的时候，可以通过将 <code>path</code> 拆分成一个数组，直接导航到路由：</p><div class="code-wrapper"><pre><code class="hljs stylus">this.<span class="hljs-variable">$router</span><span class="hljs-selector-class">.push</span>(&#123;  name: <span class="hljs-string">&#x27;NotFound&#x27;</span>,  <span class="hljs-comment">// 保留当前路径并删除第一个字符，以避免目标 URL 以 `//` 开头。</span>  params: &#123; pathMatch: this.<span class="hljs-variable">$route</span><span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.substring</span>(<span class="hljs-number">1</span>)<span class="hljs-selector-class">.split</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &#125;,  <span class="hljs-comment">// 保留现有的查询和 hash 值，如果有的话</span>  query: this.<span class="hljs-variable">$route</span><span class="hljs-selector-class">.query</span>,  hash: this.<span class="hljs-variable">$route</span><span class="hljs-selector-class">.hash</span>,&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>NotFound: 您当前的路径</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$route.params.pathMatch</span> &#125;&#125;</span><span class="language-xml">不正确, 请输入正确的路径!<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></code></pre></div><p>这里还有另外一种写法：  注意：我在/:pathMatch(.*)后面又加了一个 *；</p><p>这时候$route.params.pathMatch将是数组</p><h4 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h4><p><strong>在 Vue 实例中，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用<code>this.$router.push</code></strong></p><p>想要导航到不同的 URL，可以使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，内部会调用这个方法，所以点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 相当于调用 <code>router.push(...)</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 字符串路径</span>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/users/eduardo&#x27;</span>)<span class="hljs-comment">// 带有路径的对象</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/eduardo&#x27;</span> &#125;)<span class="hljs-comment">// 命名的路由，并加上参数，让路由建立 url</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;eduardo&#x27;</span> &#125; &#125;)<span class="hljs-comment">// 带查询参数，结果是 /register?plan=private</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125; &#125;)<span class="hljs-comment">// 带 hash，结果是 /about#team</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#team&#x27;</span> &#125;)</code></pre></div><p><strong>注意</strong>：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> username = <span class="hljs-string">&#x27;eduardo&#x27;</span><span class="hljs-comment">// 我们可以手动建立 url，但我们必须自己处理编码</span>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">`/user/<span class="hljs-subst">$&#123;username&#125;</span>`</span>) <span class="hljs-comment">// -&gt; /user/eduardo</span><span class="hljs-comment">// 同样</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;username&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/eduardo</span><span class="hljs-comment">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; username &#125; &#125;) <span class="hljs-comment">// -&gt; /user/eduardo</span><span class="hljs-comment">// `params` 不能与 `path` 一起使用</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; username &#125; &#125;) <span class="hljs-comment">// -&gt; /user</span></code></pre></div><p>当指定 <code>params</code> 时，可提供 <code>string</code> 或 <code>number</code> 参数（或者对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params">可重复的参数</a>可提供一个数组）。<strong>任何其他类型（如 <code>undefined</code>、<code>false</code> 等）都将被自动字符串化</strong>。对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params">可选参数</a>，你可以提供一个空字符串（<code>&quot;&quot;</code>）来跳过它。</p><p>由于属性 <code>to</code> 与 <code>router.push</code> 接受的对象种类相同，所以两者的规则完全相同。</p><p><code>router.push</code> 和所有其他导航方法都会返回一个 <em>Promise</em>，让我们可以等到导航完成后才知道是成功还是失败。我们将在 <a href="https://router.vuejs.org/zh/guide/advanced/navigation-failures.html">Navigation Handling</a> 中详细介绍。</p><h5 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace"></a>router.replace</h5><p>它在导航时不会向 history 添加新记录</p><div class="code-wrapper"><pre><code class="hljs php">router.<span class="hljs-title function_ invoke__">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;)<span class="hljs-comment">// 相当于</span>router.<span class="hljs-title function_ invoke__">replace</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span> &#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs gcode"><span class="hljs-comment">// 向前移动一条记录，与 router.forward() 相同</span>router.go<span class="hljs-comment">(1)</span><span class="hljs-comment">// 返回一条记录，与 router.back() 相同</span>router.go<span class="hljs-comment">(-1)</span><span class="hljs-comment">// 前进 3 条记录</span>router.go<span class="hljs-comment">(3)</span><span class="hljs-comment">// 如果没有那么多记录，静默失败</span>router.go<span class="hljs-comment">(-100)</span>router.go<span class="hljs-comment">(100)</span></code></pre></div><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>用于相同的path之间的切换组件，想同时 (同级) 展示多个视图</p><p>你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code></p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view left-sidebar&quot; <span class="hljs-type">name</span>=&quot;LeftSidebar&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;&lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view main-content&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;&lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view right-sidebar&quot; <span class="hljs-type">name</span>=&quot;RightSidebar&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dts">const <span class="hljs-attr">router</span> <span class="hljs-operator">=</span> createRouter(<span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">  history:</span> createWebHashHistory(),<span class="hljs-symbol">  routes:</span> [    <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      path:</span> <span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-symbol">      components:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        default:</span> Home,        <span class="hljs-comment">// LeftSidebar: LeftSidebar 的缩写</span>        LeftSidebar,        <span class="hljs-comment">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span>        RightSidebar,      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span>,  ],<span class="hljs-punctuation">&#125;</span>)</code></pre></div><h4 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h4><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123; ... &#125;)router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-comment">// 返回 false 以取消导航</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;)</code></pre></div><h5 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span>,    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;      <span class="hljs-comment">// reject the navigation</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;,  &#125;,]</code></pre></div><h5 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h5><div class="code-wrapper"><pre><code class="hljs awk">const UserDetails = &#123;  template: `...`,  beforeRouteEnter(to, from) &#123;    <span class="hljs-regexp">//</span> 在渲染该组件的对应路由被验证前调用    <span class="hljs-regexp">//</span> 不能获取组件实例 `this` ！    <span class="hljs-regexp">//</span> 因为当守卫执行时，组件实例还没被创建！  &#125;,  beforeRouteUpdate(to, from) &#123;    <span class="hljs-regexp">//</span> 在当前路由改变，但是该组件被复用时调用    <span class="hljs-regexp">//</span> 举例来说，对于一个带有动态参数的路径 `<span class="hljs-regexp">/users/</span>:id`，在 `<span class="hljs-regexp">/users/</span><span class="hljs-number">1</span>` 和 `<span class="hljs-regexp">/users/</span><span class="hljs-number">2</span>` 之间跳转的时候，    <span class="hljs-regexp">//</span> 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    <span class="hljs-regexp">//</span> 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`  &#125;,  beforeRouteLeave(to, from) &#123;    <span class="hljs-regexp">//</span> 在导航离开渲染该组件的对应路由时调用    <span class="hljs-regexp">//</span> 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`  &#125;,&#125;</code></pre></div><h3 id="使用组合-API"><a href="#使用组合-API" class="headerlink" title="使用组合 API#"></a>使用组合 API<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88-api">#</a></h3><p>如果你正在使用<a href="https://v3.vuejs.org/guide/composition-api-setup.html#setup">组合 API 和 <code>setup</code> 函数</a>来编写组件，你可以通过 <code>onBeforeRouteUpdate</code> 和 <code>onBeforeRouteLeave</code> 分别添加 update 和 leave 守卫</p><h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程#"></a>完整的导航解析流程<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">#</a></h2><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h4 id="Vue-Router-和-组合式-API"><a href="#Vue-Router-和-组合式-API" class="headerlink" title="Vue Router 和 组合式 API"></a>Vue Router 和 组合式 API</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter, useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()    <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()    <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushWithQuery</span>(<span class="hljs-params">query</span>) &#123;      router.<span class="hljs-title function_">push</span>(&#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;search&#x27;</span>,        <span class="hljs-attr">query</span>: &#123;          ...route.<span class="hljs-property">query</span>,        &#125;,      &#125;)    &#125;  &#125;,&#125;</code></pre></div><p>//useRouter=&gt;$router  useRoute=&gt;$route</p><h5 id="useLink"><a href="#useLink" class="headerlink" title="useLink"></a><code>useLink</code></h5><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>动态路由主要通过两个函数实现。<code>router.addRoute()</code> 和 <code>router.removeRoute()</code>。它们<strong>只</strong>注册一个新的路由，也就是说，如果新增加的路由与当前位置相匹配，就需要你用 <code>router.push()</code> 或 <code>router.replace()</code> 来<strong>手动导航</strong>，才能显示该新路由</p><h5 id="添加嵌套路由"><a href="#添加嵌套路由" class="headerlink" title="添加嵌套路由"></a>添加嵌套路由</h5><p>要将嵌套路由添加到现有的路由中，可以将路由的 <em>name</em> 作为第一个参数传递给 <code>router.addRoute()</code>，这将有效地添加路由，就像通过 <code>children</code> 添加的一样：</p><div class="code-wrapper"><pre><code class="hljs reasonml">router.add<span class="hljs-constructor">Route(&#123; <span class="hljs-params">name</span>: &#x27;<span class="hljs-params">admin</span>&#x27;, <span class="hljs-params">path</span>: &#x27;<span class="hljs-operator">/</span><span class="hljs-params">admin</span>&#x27;, <span class="hljs-params">component</span>: Admin &#125;)</span>router.add<span class="hljs-constructor">Route(&#x27;<span class="hljs-params">admin</span>&#x27;, &#123; <span class="hljs-params">path</span>: &#x27;<span class="hljs-params">settings</span>&#x27;, <span class="hljs-params">component</span>: AdminSettings &#125;</span></code></pre></div><p>这等效于：</p><div class="code-wrapper"><pre><code class="hljs php">router.<span class="hljs-title function_ invoke__">addRoute</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>,  <span class="hljs-attr">component</span>: Admin,  <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;settings&#x27;</span>, <span class="hljs-attr">component</span>: AdminSettings &#125;],&#125;)</code></pre></div><p>Vue Router 提供了两个功能来查看现有的路由：</p><ul><li><a href="https://router.vuejs.org/zh/api/#hasroute"><code>router.hasRoute()</code></a>：检查路由是否存在。</li><li><a href="https://router.vuejs.org/zh/api/#getroutes"><code>router.getRoutes()</code></a>：获取一个包含所有路由记录的数组</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue3笔记(二)</title>
    <link href="/2022/08/18/Vue3%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <url>/2022/08/18/Vue3%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="64-异步组件"><a href="#64-异步组件" class="headerlink" title="64.异步组件"></a>64.异步组件</h4><p>vue2中的异步组件是使用import().then()来实现的</p><p>vue3中提供了函数defineAsyncComponent来实现异步组件，这这样可以对组件进行分包处理，不会打包到一个文件中，而是单独打到一个包中</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//方法一 因为这种方式也会返回一个promise</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncCategory</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;./views/Category.vue&quot;</span>))</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//方法二</span><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...从服务器获取组件</span>    <span class="hljs-title function_">resolve</span>(<span class="hljs-comment">/* 获取到的组件 */</span>)  &#125;)&#125;)<span class="hljs-comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></code></pre></div><p><code>defineAsyncComponent</code> 方法接收一个返回 Promise 的加载函数。这个 Promise 的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。你也可以调用 <code>reject(reason)</code> 表明加载失败。</p><p>全局注册方式</p><div class="code-wrapper"><pre><code class="hljs js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyComponent&#x27;</span>, <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span>  <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>)))</code></pre></div><p>defineAsyncComponent的高级选项</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;  <span class="hljs-comment">// 加载函数</span>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>),  <span class="hljs-comment">// 加载异步组件时使用的组件</span>  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>,  <span class="hljs-comment">// 展示加载组件前的延迟时间，默认为 200ms</span>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-comment">// 加载失败后展示的组件</span>  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,  <span class="hljs-comment">// 如果提供了一个 timeout 时间限制，并超时了</span>  <span class="hljs-comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>&#125;)</code></pre></div><h4 id="65-组件中的v-model"><a href="#65-组件中的v-model" class="headerlink" title="65.组件中的v-model"></a>65.组件中的v-model</h4><p>可以对组件进行双向数据绑定</p><ol><li>将内部原生 <code>input</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li><li>输入新的值时在 <code>input</code> 元素上触发 <code>update:modelValue</code> 事件</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//App.js</span>&lt;<span class="hljs-title class_">CustomInput</span>  :modelValue=<span class="hljs-string">&quot;searchText&quot;</span>  @<span class="hljs-attr">update</span>:modelValue=<span class="hljs-string">&quot;newValue =&gt; searchText = newValue&quot;</span>/&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">CustomInput</span>.<span class="hljs-property">vue</span> --&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>]</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">CustomInput</span> v-model=<span class="hljs-string">&quot;searchText&quot;</span> /&gt;<span class="hljs-comment">//这是上面的简写 v-model就可以使用了</span></code></pre></div><p>方式二。使用computed来实现v-model</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">CustomInput</span>.<span class="hljs-property">vue</span> --&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">value</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">modelValue</span></span></span><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, value)</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span> /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><p>v-model的参数是可以修改的</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">MyComponent</span> v-<span class="hljs-attr">model</span>:title=<span class="hljs-string">&quot;bookTitle&quot;</span> /&gt;  <span class="hljs-comment">//在组件中修改props的值还有emits的值为title和update:title</span></code></pre></div><h6 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 <code>v-model</code> 绑定</h6><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">UserName</span>  v-<span class="hljs-attr">model</span>:first-name=<span class="hljs-string">&quot;first&quot;</span>  v-<span class="hljs-attr">model</span>:last-name=<span class="hljs-string">&quot;last&quot;</span>/&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">firstName</span>: <span class="hljs-title class_">String</span>,    <span class="hljs-attr">lastName</span>: <span class="hljs-title class_">String</span>  &#125;,  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:firstName&#x27;</span>, <span class="hljs-string">&#x27;update:lastName&#x27;</span>]&#125;&lt;/script&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;firstName&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;lastName&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><h6 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 <code>v-model</code> 修饰符</h6><p>我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">MyComponent</span> v-model.<span class="hljs-property">capitalize</span>=<span class="hljs-string">&quot;myText&quot;</span> /&gt;</code></pre></div><p>组件的 <code>v-model</code> 上所添加的修饰符，可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的组件中，我们声明了 <code>modelModifiers</code> 这个 prop，它的默认值是一个空对象</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">modelValue</span>: <span class="hljs-title class_">String</span>,    <span class="hljs-attr">modelModifiers</span>: &#123;      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;)    &#125;  &#125;,  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>],  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">modelModifiers</span>) <span class="hljs-comment">// &#123; capitalize: true &#125;</span>  &#125;&#125;&lt;/script&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定上被使用了。</p><p>有了 <code>modelModifiers</code> 这个 prop，我们就可以在原生事件侦听函数中检查它的值，然后决定触发的自定义事件中要向父组件传递什么值。在下面的代码里，我们就是在每次 <code>&lt;input&gt;</code> 元素触发 <code>input</code> 事件时将值的首字母大写：</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">modelValue</span>: <span class="hljs-title class_">String</span>,    <span class="hljs-attr">modelModifiers</span>: &#123;      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;)    &#125;  &#125;,  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>],  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">emitValue</span>(<span class="hljs-params">e</span>) &#123;      <span class="hljs-keyword">let</span> value = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">modelModifiers</span>.<span class="hljs-property">capitalize</span>) &#123;        value = value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)      &#125;      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, value)    &#125;  &#125;&#125;&lt;/script&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;emitValue&quot;</span> /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><p>对于又有参数又有修饰符的 <code>v-model</code> 绑定，生成的 prop 名将是 <code>arg + &quot;Modifiers&quot;</code>。举例来说：</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">MyComponent</span> v-<span class="hljs-attr">model</span>:title.<span class="hljs-property">capitalize</span>=<span class="hljs-string">&quot;myText&quot;</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;titleModifiers&#x27;</span>],  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:title&#x27;</span>],  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">titleModifiers</span>) <span class="hljs-comment">// &#123; capitalize: true &#125;</span>  &#125;&#125;</code></pre></div><h4 id="66-mixins"><a href="#66-mixins" class="headerlink" title="66.mixins"></a>66.mixins</h4><p>局部混入的写法</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">mixin</span> = &#123;  created() &#123;    console.log(<span class="hljs-number">1</span>)  &#125;&#125;createApp(&#123;  created() &#123;    console.log(<span class="hljs-number">2</span>)  &#125;,  mixins: [<span class="hljs-keyword">mixin</span>]&#125;)<span class="hljs-comment">// =&gt; 1</span><span class="hljs-comment">// =&gt; 2</span></code></pre></div><p>Mixin 钩子的调用顺序与提供它们的选项顺序相同，且会在组件自身的钩子前被调用</p><p>在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，<a href="https://cn.vuejs.org/guide/reusability/composables.html">Composition API</a> 是现在更推荐的方式。</p><p>app.mixin()全局的混入 但是vue3不推荐使用</p><h4 id="67-setup-函数"><a href="#67-setup-函数" class="headerlink" title="67.setup()函数"></a>67.setup()函数</h4><p>setup函数有两个参数：props,context,在setup函数里面不能使用this</p><p>context参数包含3个属性：</p><p>attrs：所有非props的attribute</p><p>slots:父组件传递过来的插槽</p><p>emit</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;    <span class="hljs-comment">// 透传 Attributes（非响应式的对象，等价于 $attrs）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-property">attrs</span>)    <span class="hljs-comment">// 插槽（非响应式的对象，等价于 $slots）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-property">slots</span>)    <span class="hljs-comment">// 触发事件（函数，等价于 $emit）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-property">emit</span>)    <span class="hljs-comment">// 暴露公共属性（函数）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-property">expose</span>)  &#125;&#125;</code></pre></div><p>context是非响应性的，可以进行解构</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; attrs, slots, emit, expose &#125;</span>) &#123;    ...  &#125;&#125;</code></pre></div><p><code>attrs</code> 和 <code>slots</code> 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 <code>attrs.x</code> 或 <code>slots.x</code> 的形式使用其中的属性。此外还需注意，和 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 的属性都<strong>不是</strong>响应式的。如果你想要基于 <code>attrs</code> 或 <code>slots</code> 的改变来执行副作用，那么你应该在 <code>onBeforeUpdate</code> 生命周期钩子中编写相关逻辑。</p><p>setup可以有返回值，可以在template中使用</p><p><code>setup</code> 函数的第一个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的，并且会在传入新的 props 时同步更新。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>  &#125;,  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">title</span>)  &#125;&#125;</code></pre></div><p>如果解构props会使数据失去响应性，如果需要结构请使用toRef()/toRefs()</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; toRefs, toRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-comment">// 将 `props` 转为一个其中全是 ref 的对象，然后解构</span>    <span class="hljs-keyword">const</span> &#123; title &#125; = <span class="hljs-title function_">toRefs</span>(props)    <span class="hljs-comment">// `title` 是一个追踪着 `props.title` 的 ref</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title.<span class="hljs-property">value</span>)    <span class="hljs-comment">// 或者，将 `props` 的单个属性转为一个 ref</span>    <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">toRef</span>(props, <span class="hljs-string">&#x27;title&#x27;</span>)  &#125;&#125;</code></pre></div><p>请注意在模板中访问从 <code>setup</code> 返回的 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref">ref</a> 时，它会<a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#deep-reactivity">自动浅层解包</a>，因此你无须再在模板中为它写 <code>.value</code>。当通过 <code>this</code> 访问时也会同样如此解包。</p><p><strong>TIP</strong></p><p><strong><code>setup()</code> 自身并不含对组件实例的访问权，即在 <code>setup()</code> 中访问 <code>this</code> 会是 <code>undefined</code>。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</strong></p><h5 id="暴露公共属性"><a href="#暴露公共属性" class="headerlink" title="暴露公共属性"></a>暴露公共属性</h5><p><code>expose</code> 函数用于显式地限制该组件暴露出的属性，当父组件通过<a href="https://cn.vuejs.org/guide/essentials/template-refs.html#ref-on-component">模板引用</a>访问该组件的实例时，将仅能访问 <code>expose</code> 函数暴露出的内容：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; expose &#125;</span>) &#123;    <span class="hljs-comment">// 让组件实例处于 “关闭状态”</span>    <span class="hljs-comment">// 即不向父组件暴露任何东西</span>    <span class="hljs-title function_">expose</span>()    <span class="hljs-keyword">const</span> publicCount = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)    <span class="hljs-keyword">const</span> privateCount = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)    <span class="hljs-comment">// 有选择地暴露局部状态</span>    <span class="hljs-title function_">expose</span>(&#123; <span class="hljs-attr">count</span>: publicCount &#125;)  &#125;&#125;</code></pre></div><h5 id="与渲染函数一起使用"><a href="#与渲染函数一起使用" class="headerlink" title="与渲染函数一起使用#"></a>与渲染函数一起使用<a href="https://cn.vuejs.org/api/composition-api-setup.html#usage-with-render-functions">#</a></h5><p><code>setup</code> 也可以返回一个<a href="https://cn.vuejs.org/guide/extras/render-function.html">渲染函数</a>，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; h, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, count.<span class="hljs-property">value</span>)  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; h, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; expose &#125;</span>) &#123;    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)    <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; ++count.<span class="hljs-property">value</span>    <span class="hljs-title function_">expose</span>(&#123;      increment    &#125;)    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, count.<span class="hljs-property">value</span>)  &#125;&#125;</code></pre></div><h4 id="68-reactive-api"><a href="#68-reactive-api" class="headerlink" title="68. reactive api"></a>68. reactive api</h4><p>reactive可以将对象变成响应式对象  ，返回一个对象的响应式代理</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">account</span> = <span class="hljs-title function_ invoke__">reactive</span>(&#123;      <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;coderwhy&quot;</span>,      <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;1234567&quot;</span>    &#125;)</code></pre></div><p>reactive转换是深层的，他会影响所有的嵌套属性，reactive也会深层的解包所有ref属性，同时保持响应性</p><p>值得注意的是，当访问到某个响应式数组或 <code>Map</code> 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包。意思是</p><p>若要避免深层响应式转换，只想保留对这个对象顶层次访问的响应性，请使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive">shallowReactive()</a> 作替代</p><p>返回的对象以及其中嵌套的对象都会通过 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">ES Proxy</a> 包裹，因此<strong>不等于</strong>源对象，建议只使用响应式代理，避免使用原始对象。</p><p>ref 的解包：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; count &#125;)<span class="hljs-comment">// ref 会被解包</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span> === count.<span class="hljs-property">value</span>) <span class="hljs-comment">// true</span><span class="hljs-comment">// 会更新 `obj.count`</span>count.<span class="hljs-property">value</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span>) <span class="hljs-comment">// 2</span><span class="hljs-comment">// 也会更新 `count` ref</span>obj.<span class="hljs-property">count</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span>) <span class="hljs-comment">// 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 3</span></code></pre></div><p>注意当访问到某个响应式数组或 <code>Map</code> 这样的原生集合类型中的 ref 元素时，<strong>不会</strong>执行 ref 的解包：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> books = <span class="hljs-title function_">reactive</span>([<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Vue 3 Guide&#x27;</span>)])<span class="hljs-comment">// 这里需要 .value</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(books[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>)<span class="hljs-keyword">const</span> map = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;count&#x27;</span>, <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)]]))<span class="hljs-comment">// 这里需要 .value</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;count&#x27;</span>).<span class="hljs-property">value</span>)</code></pre></div><p>将一个 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref">ref</a> 赋值给为一个 <code>reactive</code> 属性时，该 ref 会被自动解包：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;&#125;)obj.<span class="hljs-property">count</span> = count<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span> === count.<span class="hljs-property">value</span>) <span class="hljs-comment">// true</span></code></pre></div><h4 id="69-ref-api"><a href="#69-ref-api" class="headerlink" title="69.ref api"></a>69.ref api</h4><p>ref 可以定义任何数据类型</p><p>ref会返回一个可变的响应式对象，该对象作为一个响应式的引用维护它内部的值,</p><div class="code-wrapper"><pre><code class="hljs pgsql">const <span class="hljs-keyword">info</span> = <span class="hljs-keyword">ref</span>(&#123;&#125;)console.log(<span class="hljs-keyword">info</span>.<span class="hljs-keyword">value</span>)</code></pre></div><p>在模板中使用ref的值，vue会自动帮助我们进行解包不需要使用.value,但是在setup函数内部，还是一个ref引用，必须使用.value的方式。在模板中的解包是浅层的解包</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">// 2.定义从网络中获取的数据也是使用ref</span>      <span class="hljs-comment">// const musics = reactive([])</span>      const musics = <span class="hljs-built_in">ref</span>(<span class="hljs-selector-attr">[]</span>)      <span class="hljs-built_in">onMounted</span>(() =&gt; &#123;        const serverMusics = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;海阔天空&quot;</span>, <span class="hljs-string">&quot;小苹果&quot;</span>, <span class="hljs-string">&quot;野狼&quot;</span>]</span>        musics<span class="hljs-selector-class">.value</span> = serverMusics      &#125;)</code></pre></div><h4 id="70-readonly"><a href="#70-readonly" class="headerlink" title="70.readonly()"></a>70.readonly()</h4><p>传入一个对象，无论是响应式还是普通对象，还是ref对象，会返回一个对象的只读代理</p><p>可以用于给子组件传递数据的时候，不允许修改父组件传递的值，，readonly他会劫持proxy中的set方法，不允许修改</p><p>只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 <code>reactive()</code> 相同，但解包得到的值是只读的。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> original = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">readonly</span>(original)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 用来做响应性追踪</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy.<span class="hljs-property">count</span>)&#125;)<span class="hljs-comment">// 更改源属性会触发其依赖的侦听器</span>original.<span class="hljs-property">count</span>++<span class="hljs-comment">// 更改该只读副本将会失败，并会得到一个警告</span>copy.<span class="hljs-property">count</span>++ <span class="hljs-comment">// warning!</span></code></pre></div><p>其实本质上就是readonly返回的对象的setter方法被劫持了而已</p><h4 id="71-reactive判断的api"><a href="#71-reactive判断的api" class="headerlink" title="71.reactive判断的api"></a>71.reactive判断的api</h4><h5 id="isProxy"><a href="#isProxy" class="headerlink" title="isProxy"></a>isProxy</h5><p>​    检查对象是否是由reactive或者readonly创建的proxy</p><h5 id="isReactive"><a href="#isReactive" class="headerlink" title="isReactive"></a>isReactive</h5><p>检查一个对象是否是由 <a href="https://cn.vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a> 或 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 创建的代理</p><p>如果该代理是readonly创建的，但是包裹了由reactive创建的另外一个代理，他也会返回true</p><h5 id="isReadonly"><a href="#isReadonly" class="headerlink" title="isReadonly"></a>isReadonly</h5><p>检查一个对象是否是由 <a href="https://cn.vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a> 或 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a> 创建的代理。</p><h5 id="toRow"><a href="#toRow" class="headerlink" title="toRow"></a>toRow</h5><p> 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。</p><h5 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a>shallowReactive</h5><p>创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。</p><h5 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a>shallowReadonly</h5><p>创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）</p><h4 id="72-toRefs"><a href="#72-toRefs" class="headerlink" title="72 toRefs"></a>72 toRefs</h4><p>如果使用es6的解构语法对reactive返回的对象进行解构，解构后获得的变量不是响应式的，可以使用toRefs将解构后的值变成响应式的</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> info = <span class="hljs-title function_">reactive</span>(&#123;         <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,         <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,         <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>       &#125;)       <span class="hljs-comment">// reactive被解构后会变成普通的值, 失去响应式</span>       <span class="hljs-keyword">const</span> &#123; name, age &#125; = <span class="hljs-title function_">toRefs</span>(info)</code></pre></div><p><code>toRefs</code> 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#toref"><code>toRef</code></a>。</p><h4 id="73-toRef"><a href="#73-toRef" class="headerlink" title="73.toRef"></a>73.toRef</h4><p>将一个reactive对象的属性变成响应式的</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>&#125;)<span class="hljs-keyword">const</span> fooRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// 更改该 ref 会更新源属性</span>fooRef.<span class="hljs-property">value</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">foo</span>) <span class="hljs-comment">// 2</span><span class="hljs-comment">// 更改源属性也会更新该 ref</span>state.<span class="hljs-property">foo</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooRef.<span class="hljs-property">value</span>) <span class="hljs-comment">// 3</span></code></pre></div><p>请注意，这不同于：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fooRef = <span class="hljs-title function_">ref</span>(state.<span class="hljs-property">foo</span>)</code></pre></div><p>上面这个 ref <strong>不会</strong>和 <code>state.foo</code> 保持同步，因为这个 <code>ref()</code> 接收到的是一个纯数值。</p><h4 id="74-ref其他api"><a href="#74-ref其他api" class="headerlink" title="74. ref其他api"></a>74. ref其他api</h4><h5 id="unref"><a href="#unref" class="headerlink" title="unref"></a>unref</h5><p>如果我们想要获取一个ref引用中的value，那么也可以通过unref方法：  如果参数是一个 ref，则返回内部值，否则返回参数本身；  这是 val = isRef(val) ? val.value : val 的语法糖函数</p><h5 id="isRef"><a href="#isRef" class="headerlink" title="isRef"></a>isRef</h5><p>判断值是否是一个ref对象。</p><h5 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h5><p>创建一个浅层的ref对象</p><h5 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef"></a>triggerRef</h5><p>手动触发和 shallowRef 相关联的副作用：</p><h4 id="75-computed"><a href="#75-computed" class="headerlink" title="75.computed()"></a>75.computed()</h4><p>接受一个 getter 函数，返回一个只读的响应式 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref">ref</a> 对象。该 ref 通过 <code>.value</code> 暴露 getter 函数的返回值。它也可以接受一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 ref 对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> plusOne = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(plusOne.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span>plusOne.<span class="hljs-property">value</span>++ <span class="hljs-comment">// 错误</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> plusOne = <span class="hljs-title function_">computed</span>(&#123;  <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>,  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;    count.<span class="hljs-property">value</span> = val - <span class="hljs-number">1</span>  &#125;&#125;)plusOne.<span class="hljs-property">value</span> = <span class="hljs-number">1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 0</span></code></pre></div><h4 id="76-在setup中获取组件实例"><a href="#76-在setup中获取组件实例" class="headerlink" title="76.在setup中获取组件实例"></a>76.在setup中获取组件实例</h4><div class="code-wrapper"><pre><code class="hljs js">&lt;show-info ref=<span class="hljs-string">&quot;showInfoRef&quot;</span>&gt;&lt;/show-info&gt;<span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">const</span> showInfoRef=<span class="hljs-title function_">ref</span>()<span class="hljs-keyword">return</span> &#123;showInfoRef&#125;&#125;</code></pre></div><h4 id="77-在setup中使用生命周期钩子函数"><a href="#77-在setup中使用生命周期钩子函数" class="headerlink" title="77.在setup中使用生命周期钩子函数"></a>77.在setup中使用生命周期钩子函数</h4><p>onBeforeMount</p><p>onMounted</p><p>onBeforeUpdate</p><p>onUpdated</p><p>onBeforeUnmounted</p><p>onUnounted</p><p>onActivited</p><p>onDeactivited</p><h4 id="78-provide"><a href="#78-provide" class="headerlink" title="78.provide"></a>78.provide</h4><ul><li><p>与注册生命周期钩子的 API 类似，<code>provide()</code> 必须在组件的 <code>setup()</code> 阶段同步调用。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;<span class="hljs-keyword">import</span> &#123; ref, provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> &#123; fooSymbol &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span><span class="hljs-comment">// 提供静态值</span><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-comment">// 提供响应式的值</span><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;count&#x27;</span>, count)<span class="hljs-comment">// 提供时将 Symbol 作为 key</span><span class="hljs-title function_">provide</span>(fooSymbol, count)&lt;/script&gt;</code></pre></div></li></ul><h4 id="79-inject"><a href="#79-inject" class="headerlink" title="79.inject()"></a>79.inject()</h4><p>第一个参数是注入的 key。Vue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，那么离得更近的组件将会“覆盖”链上更远的组件所提供的值。如果没有能通过 key 匹配到值，<code>inject()</code> 将返回 <code>undefined</code>，除非提供了一个默认值。</p><p>第二个参数是可选的，即在没有匹配到 key 时使用的默认值。它也可以是一个工厂函数，用来返回某些创建起来比较复杂的值。如果默认值本身就是一个函数，那么你必须将 <code>false</code> 作为第三个参数传入，表明这个函数就是默认值，而不是一个工厂函数。</p><p>与注册生命周期钩子的 API 类似，<code>inject()</code> 必须在组件的 <code>setup()</code> 阶段同步调用。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;<span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> &#123; fooSymbol &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span><span class="hljs-comment">// 注入值的默认方式</span><span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// 注入响应式的值</span><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;count&#x27;</span>)<span class="hljs-comment">// 通过 Symbol 类型的 key 注入</span><span class="hljs-keyword">const</span> foo2 = <span class="hljs-title function_">inject</span>(fooSymbol)<span class="hljs-comment">// 注入一个值，若为空则使用提供的默认值</span><span class="hljs-keyword">const</span> bar = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;default value&#x27;</span>)<span class="hljs-comment">// 注入一个值，若为空则使用提供的工厂函数</span><span class="hljs-keyword">const</span> baz = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())<span class="hljs-comment">// 注入时为了表明提供的默认值是个函数，需要传入第三个参数</span><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;function&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-literal">false</span>)&lt;/script&gt;</code></pre></div><h4 id="80-watch"><a href="#80-watch" class="headerlink" title="80.watch()"></a>80.watch()</h4><p>watch的api和option API中的watch类似</p><p>watch需要监听特定的数据源，并且执行其回调函数，默认情况下，他是惰性的，在初始化情况下不执行，只有在数据变化时才执行</p><p><code>watch()</code> 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。</p><p>第一个参数是侦听器的<strong>源</strong>。这个来源可以是以下几种：</p><ul><li>一个函数，返回一个值</li><li>一个 ref</li><li>一个响应式对象</li><li>…或是由以上类型的值组成的数组</li></ul><p>第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。</p><p>当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。</p><p>第三个可选的参数是一个对象，支持以下这些选项：</p><ul><li><p>**<code>immediate</code>**：在侦听器创建时立即触发回调。第一次调用时旧值是 <code>undefined</code>。</p></li><li><p>**<code>deep</code>**：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考<a href="https://cn.vuejs.org/guide/essentials/watchers.html#deep-watchers">深层侦听器</a>一节。</p></li><li><p>**<code>flush</code>**：调整回调函数的刷新时机。参考<a href="https://cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing">回调的刷新时机</a>一节。</p></li><li><p>**<code>onTrack / onTrigger</code>**：调试侦听器的依赖,参考<a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#watcher-debugging">调试侦听器</a>一节。</p></li></ul><p>与 <a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a> 相比，<code>watch()</code> 使我们可以：</p><ul><li>懒执行副作用；</li><li>更加明确是应该由哪个状态触发侦听器重新执行；</li><li>可以访问所侦听状态的前一个值和当前值。</li></ul><p>侦听一个 getter 函数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">watch</span>(  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">count</span>,  <span class="hljs-function">(<span class="hljs-params">count, prevCount</span>) =&gt;</span> &#123;    <span class="hljs-comment">/* ... */</span>  &#125;)</code></pre></div><p>侦听一个 ref：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-title function_">watch</span>(count, <span class="hljs-function">(<span class="hljs-params">count, prevCount</span>) =&gt;</span> &#123;  <span class="hljs-comment">/* ... */</span>&#125;)</code></pre></div><p>当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>([fooRef, barRef], <span class="hljs-function">(<span class="hljs-params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;  <span class="hljs-comment">/* ... */</span>&#125;)</code></pre></div><p>当使用 getter 函数作为源时，回调只在此函数的返回值变化时才会触发。如果你想让回调在深层级变更时也能触发，你需要使用 <code>&#123; deep: true &#125;</code> 强制侦听器进入深层级模式。在深层级模式时，如果回调函数由于深层级的变更而被触发，那么新值和旧值将是同一个对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">watch</span>(  <span class="hljs-function">() =&gt;</span> state,  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;    <span class="hljs-comment">// newValue === oldValue</span>  &#125;,  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span><span class="hljs-comment">//在创建的时候执行一次 &#125;</span>)</code></pre></div><p>当直接侦听一个响应式对象时，侦听器会自动启用深层模式：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">watch</span>(state, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">/* 深层级变更状态所触发的回调 */</span>&#125;)</code></pre></div><p><code>watch()</code> 和 <a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a> 享有相同的刷新时机和调试选项：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(source, callback, &#123;  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span>,  <span class="hljs-title function_">onTrack</span>(<span class="hljs-params">e</span>) &#123;    <span class="hljs-keyword">debugger</span>  &#125;&#125;)</code></pre></div><h4 id="81-watchEffect"><a href="#81-watchEffect" class="headerlink" title="81.watchEffect()"></a>81.watchEffect()</h4><p>立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p><ul><li><p>第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。</p><p>第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。</p><p>返回值是一个用来停止该副作用的函数。</p></li><li><p><strong>示例</strong></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>))<span class="hljs-comment">// -&gt; 输出 0</span>count.<span class="hljs-property">value</span>++<span class="hljs-comment">// -&gt; 输出 1</span></code></pre></div><p>副作用清除：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-keyword">async</span> (onCleanup) =&gt; &#123;  <span class="hljs-keyword">const</span> &#123; response, cancel &#125; = <span class="hljs-title function_">doAsyncWork</span>(id.<span class="hljs-property">value</span>)  <span class="hljs-comment">// `cancel` 会在 `id` 更改时调用</span>  <span class="hljs-comment">// 以便取消之前</span>  <span class="hljs-comment">// 未完成的请求</span>  <span class="hljs-title function_">onCleanup</span>(cancel)  data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response&#125;)</code></pre></div><p>停止侦听器：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> stop = <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<span class="hljs-comment">// 当不再需要此侦听器时:</span><span class="hljs-title function_">stop</span>()</code></pre></div><p>选项：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, &#123;  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span>,  <span class="hljs-title function_">onTrack</span>(<span class="hljs-params">e</span>) &#123;    <span class="hljs-keyword">debugger</span>  &#125;,  <span class="hljs-title function_">onTrigger</span>(<span class="hljs-params">e</span>) &#123;    <span class="hljs-keyword">debugger</span>  &#125;&#125;)</code></pre></div></li></ul><h4 id="82-hooks的封装"><a href="#82-hooks的封装" class="headerlink" title="82.hooks的封装"></a>82.hooks的封装</h4><p>封装usetitle</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//useTitle.js</span><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<span class="hljs-comment">//这是闭包函数</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useTitle</span>(<span class="hljs-params">titleValue</span>) &#123;  <span class="hljs-comment">// document.title = title</span>  <span class="hljs-comment">// 定义ref的引入数据</span>  <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">ref</span>(titleValue)  <span class="hljs-comment">// 监听title的改变</span>  <span class="hljs-title function_">watch</span>(title, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = newValue  &#125;, &#123;    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>  &#125;)  <span class="hljs-comment">// 返回ref值</span>  <span class="hljs-keyword">return</span> &#123;    title  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-comment">//App.vue</span><span class="hljs-comment">// 2.修改标题</span>      <span class="hljs-keyword">const</span> &#123; title &#125; = <span class="hljs-title function_">useTitle</span>(<span class="hljs-string">&quot;首页&quot;</span>)      <span class="hljs-comment">// 3.监听按钮的点击  这样修改的是同一个值，不需要重复的调用usetitle(&quot;首页-流行&quot;)</span>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">popularClick</span>(<span class="hljs-params"></span>) &#123;        title.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;首页-流行&quot;</span>      &#125;      <span class="hljs-keyword">function</span> <span class="hljs-title function_">hotClick</span>(<span class="hljs-params"></span>) &#123;        title.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;首页-热门&quot;</span>      &#125;      <span class="hljs-keyword">function</span> <span class="hljs-title function_">songClick</span>(<span class="hljs-params"></span>) &#123;        title.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;首页-歌单&quot;</span>      &#125;</code></pre></div><h4 id="84-单文件组件-lt-script-setup-gt"><a href="#84-单文件组件-lt-script-setup-gt" class="headerlink" title="84.单文件组件 &lt;script setup&gt;"></a>84.单文件组件 <code>&lt;script setup&gt;</code></h4><script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。- 更少的样板内容，更简洁的代码。- 能够使用纯 TypeScript 声明 props 和自定义事件。- 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。- 更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。<div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello script setup&#x27;</span>)&lt;/script&gt;</code></pre></div>与普通的 `<script>` 只在组件被首次引入的时候执行一次不同，`<script setup>` 中的代码会在**每次组件实例被创建的时候执行**。响应式数据需要使用ref或者reactive来实现##### 顶层的绑定会被暴露给模板[#](https://cn.vuejs.org/api/sfc-script-setup.html#top-level-bindings-are-exposed-to-template)当使用 `<script setup>` 的时候，任何在 `<script setup>` 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用：<div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 变量</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> msg = <span class="hljs-string">&#x27;Hello!&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 函数</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;log&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div>import 导入的内容也会以同样的方式暴露。这意味着我们可以在模板表达式中直接使用导入的 helper 函数，而不需要通过 `methods` 选项来暴露它：<div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; capitalize &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./helpers&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">capitalize</span>(<span class="hljs-name">&#x27;hello&#x27;</span>) &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div>##### 组件的使用组件直接导入即可，不需要注册<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div>##### **`defineProps()`**，`defineEmits（）`用于在`<script setup>`中定义props和emits<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-comment">// 定义props</span></span><span class="language-javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: &#123;</span><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span><span class="language-javascript">    <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;默认值&quot;</span></span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">age</span>: &#123;</span><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,</span><span class="language-javascript">    <span class="hljs-attr">default</span>: <span class="hljs-number">0</span></span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;)</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-comment">// 绑定函数, 并且发出事件</span></span><span class="language-javascript"><span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;infoBtnClick&quot;</span>])</span><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showInfoBtnClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">  <span class="hljs-title function_">emits</span>(<span class="hljs-string">&quot;infoBtnClick&quot;</span>, <span class="hljs-string">&quot;showInfo内部发生了点击&quot;</span>)</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-comment">// 定义foo的函数</span></span><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo function&quot;</span>)</span><span class="language-javascript">&#125;</span><span class="language-javascript"><span class="hljs-title function_">defineExpose</span>(&#123;</span><span class="language-javascript">  foo</span><span class="language-javascript">&#125;)</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>##### `defineExpose`使用 `<script setup>` 的组件是**默认关闭**的——即通过模板引用或者 `$parent` 链获取到的组件的公开实例，**不会**暴露任何在 `<script setup>` 中声明的绑定。可以通过 `defineExpose` 编译器宏来显式指定在 `<script setup>` 组件中要暴露出去的属性：<div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> b = <span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>)</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineExpose</span>(</span></span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">  a,</span><span class="hljs-template-variable">  b</span><span class="hljs-template-variable">&#125;</span><span class="language-xml">)</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3笔记</title>
    <link href="/2022/08/16/Vue3%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2022/08/16/Vue3%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h4 id="1-vue手脚架代价脚本-两种方式"><a href="#1-vue手脚架代价脚本-两种方式" class="headerlink" title="1.vue手脚架代价脚本  两种方式"></a>1.vue手脚架代价脚本  两种方式</h4><div class="code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">vue</span> <span class="hljs-string">create</span>  项目名  构建工具是<span class="hljs-string">webpack</span><span class="hljs-string">npm</span> <span class="hljs-string">init</span> <span class="hljs-string">vue</span>@<span class="hljs-string">latest</span>  <span class="hljs-string">1</span>.安装一个本地工具：<span class="hljs-built_in">create-vue</span>  <span class="hljs-string">2</span>.使用<span class="hljs-built_in">create-vue创建一个vue项目</span>  构建工具是<span class="hljs-string">vite</span></code></pre></div><h4 id="2-attrs"><a href="#2-attrs" class="headerlink" title="2.$attrs"></a>2.$attrs</h4><h4 id="3-emits"><a href="#3-emits" class="headerlink" title="3.emits"></a>3.emits</h4><p>vue3中增加了$emit事件的声明</p><h4 id="4-reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的"><a href="#4-reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的" class="headerlink" title="4.reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的"></a>4.reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的</h4><h4 id="5-ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包"><a href="#5-ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包" class="headerlink" title="5.ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包"></a>5.ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包</h4><p>但是在深层次引用的时候，使用的时候是直接使用，在设置的时候需要用.value</p><h4 id="6-ref和reactive的使用场景"><a href="#6-ref和reactive的使用场景" class="headerlink" title="6.ref和reactive的使用场景"></a>6.ref和reactive的使用场景</h4><p>​        reactive可以应用于本地的数据，多个数据之间是有联系的，是聚合数据</p><p>​        其他场景可以运用ref,定义网络请求中的数据也是用ref</p><ol start="7"><li><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><code>readonly</code></h4></li></ol><p>​    不要违反单项数据流，把响应式的reactive或者ref传递给子组件，子组件可以修改数据，为了不要让子组件修改数据，可以将传入的响应式变成readonly</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> obj1=<span class="hljs-keyword">readonly</span>(obj)<span class="hljs-comment">//可以将这个obj1传递过去</span></code></pre></div><p>readonly会返回原始对象的只读代理，本质上是劫持proxy的set方法，不能进行设置新的值</p><h4 id="8-isProxy"><a href="#8-isProxy" class="headerlink" title="8.isProxy"></a>8.isProxy</h4><p>判断是否是由reactive或者readonly创建的proxy</p><h4 id="9-isReactive"><a href="#9-isReactive" class="headerlink" title="9.isReactive"></a>9.isReactive</h4><p> 检查对象是否是由reactive创建的响应式代理，如果该代理是由readonly创建的，但是包裹reactive,也是true</p><h4 id="10-isReadonly"><a href="#10-isReadonly" class="headerlink" title="10.isReadonly"></a>10.isReadonly</h4><p> 是否是readonly</p><h4 id="11-toRow"><a href="#11-toRow" class="headerlink" title="11.toRow"></a>11.toRow</h4><p>返回reactive或者readonly代理的原始对象</p><h4 id="12-shallowReactive"><a href="#12-shallowReactive" class="headerlink" title="12.shallowReactive"></a>12.shallowReactive</h4><p>  创建一个响应式代理，跟踪本身的property,但是不会执行嵌套对象的深层响应式代理</p><h4 id="13-shallowReadonly"><a href="#13-shallowReadonly" class="headerlink" title="13.shallowReadonly"></a>13.shallowReadonly</h4><p> 只读的浅层</p><h4 id="14-toRefs"><a href="#14-toRefs" class="headerlink" title="14.toRefs"></a>14.toRefs</h4><p> 将响应式对象转换成普通对象，里面的property转成ref,可以进行解构成ref响应式</p><div class="code-wrapper"><pre><code class="hljs reasonml">const &#123;a&#125;=<span class="hljs-keyword">to</span><span class="hljs-constructor">Refs(<span class="hljs-params">reactive</span>(&#123;<span class="hljs-params">a</span>:<span class="hljs-string">&quot;zjag&quot;</span>&#125;)</span>  <span class="hljs-comment">//可以用于reactive的解构</span></code></pre></div><p>reactive默认情况下解构的值没有响应式</p><h4 id="15-setup的生命周期"><a href="#15-setup的生命周期" class="headerlink" title="15.setup的生命周期"></a>15.setup的生命周期</h4><h4 id="16-Provide函数"><a href="#16-Provide函数" class="headerlink" title="16.Provide函数"></a>16.Provide函数</h4><h4 id="17-路由钩子函数"><a href="#17-路由钩子函数" class="headerlink" title="17.路由钩子函数"></a>17.路由钩子函数</h4><h4 id="18-beforeEach"><a href="#18-beforeEach" class="headerlink" title="18.beforeEach"></a>18.beforeEach</h4><p> 全局的前置守卫beforeEach是会在导航触发的时候被调用，他又两个参数to,from,又返回值，返回false则会取消当前导航，不返回或者返回undefined则使用默认导航，返回一个路由地址，可以是字符串，也可以是object，包括路由信息</p><h4 id="19-什么是MVVM，和MVC的区别"><a href="#19-什么是MVVM，和MVC的区别" class="headerlink" title="19.什么是MVVM，和MVC的区别"></a>19.什么是MVVM，和MVC的区别</h4><p>20.data必须是一个函数，并且返回一个对象，在vue2中，也可以传入一个对象，在vue3中必须使用函数</p><p>21.箭头函数不能定义method中的函数，因为箭头函数中·没有this,箭头函数的this是由上层作用域的this来决定的，所以不会指定到当前组件实例</p><p>22.在源码中this的指向</p><p>23.v-once 表示当前元素或者组件只会更新一次，就是初始化以后就不会再次渲染，包含的子组件也是渲染也是渲染一次，在特定多的场合使用可以提高性能</p><h4 id="24-v-text"><a href="#24-v-text" class="headerlink" title="24.v-text"></a>24.v-text</h4><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  //二者是等价的</span></code></pre></div><h4 id="25-v-html"><a href="#25-v-html" class="headerlink" title="25.v-html"></a>25.v-html</h4><p>可以将字符串转换成html</p><p>默认情况下，如果我们展示的内容本身是html 的，那么vue并不会对其进行特殊的解析。</p><p>如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> data() &#123;         <span class="hljs-keyword">return</span> &#123;          <span class="hljs-built_in"> count</span>: <span class="hljs-number">0</span>,           content: `<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; font-size: 30px;&quot;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>`,         &#125;;       &#125;,</code></pre></div><h4 id="26-v-pre"><a href="#26-v-pre" class="headerlink" title="26.v-pre"></a>26.v-pre</h4><p>用于跳过元素和他的子元素的编译过程，显示原始的Mustach标签，就是不会对其进行编译</p><img src="https://img1.imgtp.com/2022/08/16/6QxUMw0k.png" alt="QQ截图20220805010351.png" style="zoom:200%;" /><p><img src="https://img1.imgtp.com/2022/08/16/RQQz8CXr.png" alt="QQ截图20220805010445.png"></p><h4 id="27-v-cloak"><a href="#27-v-cloak" class="headerlink" title="27.v-cloak"></a>27.v-cloak</h4><p>这个指令保持在元素上直到关联的组件实例结束编译，需要和css结合使用</p><img src="https://img1.imgtp.com/2022/08/16/0K3EfAAB.png" alt="图片1.png" style="zoom:200%;" /><h4 id="28-v-memo"><a href="#28-v-memo" class="headerlink" title="28.v-memo"></a>28.v-memo</h4><p>适用于性能优化，只有对应的数组中属性的值发生变化时才会重新渲染</p><img src="https://img1.imgtp.com/2022/08/16/JpOvHIxe.png" alt="QQ截图20220805011104.png" style="zoom:200%;" /><h4 id="29-v-bind"><a href="#29-v-bind" class="headerlink" title="29.v-bind"></a>29.v-bind</h4><p> v-bind的简写</p><h4 id="30-class绑定的语法"><a href="#30-class绑定的语法" class="headerlink" title="30.class绑定的语法"></a>30.class绑定的语法</h4><p>动态绑定的class可以和普通的class一起使用</p><p>:class可以是字符串，属性，对象，数组，计算属性返回一个对象，或是使用方法的调用返回一个对象或者数组</p><h4 id="31-style绑定的语法"><a href="#31-style绑定的语法" class="headerlink" title="31.style绑定的语法"></a>31.style绑定的语法</h4><p><img src="https://img1.imgtp.com/2022/08/16/7GFaKEon.png" alt="QQ截图20220805023313.png"></p><h4 id="32-name-”value”-动态绑定属性"><a href="#32-name-”value”-动态绑定属性" class="headerlink" title="32.:[name]=”value”  动态绑定属性"></a>32.:[name]=”value”  动态绑定属性</h4><h4 id="33-如下"><a href="#33-如下" class="headerlink" title="33.如下"></a>33.如下</h4> <div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;obj&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> //绑定对象 可以将所有对象的属性遍历，绑定过去</code></pre></div><h4 id="34-v-on事件绑定-简写"><a href="#34-v-on事件绑定-简写" class="headerlink" title="34.v-on事件绑定  @简写"></a>34.v-on事件绑定  @简写</h4><h4 id="35-v-on事件的参数传递"><a href="#35-v-on事件的参数传递" class="headerlink" title="35.v-on事件的参数传递"></a>35.v-on事件的参数传递</h4><p><img src="https://img1.imgtp.com/2022/08/16/gFZd2jBM.png" alt="QQ截图20220806014535.png"></p><h4 id="36-v-on的修饰符"><a href="#36-v-on的修饰符" class="headerlink" title="36.v-on的修饰符"></a>36.v-on的修饰符</h4><p><strong>.stop - 调用 event.stopPropagation()。</strong></p><p><strong>.prevent - 调用 event.preventDefault()。</strong></p><p><strong>.capture - 添加事件侦听器时使用 capture 模式。</strong></p><p><strong>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</strong></p><p><strong>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</strong></p><p><strong>.once - 只触发一次回调。</strong></p><p><strong>.left - 只当点击鼠标左键时触发。</strong></p><p><strong>.right - 只当点击鼠标右键时触发。</strong></p><p><strong>.middle - 只当点击鼠标中键时触发。</strong></p><p><strong>.passive - { passive: true } 模式添加侦听器</strong></p><h4 id="37-v-if-v-else-v-else-if"><a href="#37-v-if-v-else-v-else-if" class="headerlink" title="37.v-if ,v-else, v-else-if"></a>37.v-if ,v-else, v-else-if</h4><p>v-if的渲染原理</p><p>v-if是惰性的，只有在条件判断为true的时候，才会重新渲染。当为false的时候不会渲染</p><h4 id="38-v-show"><a href="#38-v-show" class="headerlink" title="38.v-show"></a>38.v-show</h4><h4 id="39-template元素"><a href="#39-template元素" class="headerlink" title="39.template元素"></a>39.template元素</h4><p>template元素可以在页面中不做渲染，可以用于包裹元素，但是不会在页面中渲染</p><h4 id="40-v-for和v-show的区别"><a href="#40-v-for和v-show的区别" class="headerlink" title="40.v-for和v-show的区别"></a>40.v-for和v-show的区别</h4><p><strong>首先，在用法上的区别：</strong></p><p>v-show是不支持template；</p><p>v-show不可以和v-else一起使用；</p><p><strong>其次，本质的区别：</strong></p><p>v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有存在的，只是通过CSS的display属性来进行切换；</p><p>v-if当条件为false时，其对应的原生压根不会被渲染到DOM中；</p><p><strong>开发中如何进行选择呢？</strong></p><p>如果我们的原生需要在显示和隐藏之间频繁的切换，那么使用v-show；</p><p>如果不会频繁的发生切换，那么使用v-if；</p><h4 id="41-v-for"><a href="#41-v-for" class="headerlink" title="41.v-for"></a>41.v-for</h4><p><img src="https://img1.imgtp.com/2022/08/16/Rt9R3gK5.png" alt="QQ截图20220806191249.png"></p><h4 id="42-数组跟新检测"><a href="#42-数组跟新检测" class="headerlink" title="42.数组跟新检测"></a>42.数组跟新检测</h4><p>vue会对以下数组的方法进行包裹，所以通过这些方法变更数组可以触发页面的更新</p><p><strong>push()</strong></p><p><strong>pop()</strong></p><p><strong>shift()</strong></p><p><strong>unshift()</strong></p><p><strong>splice()</strong></p><p><strong>sort()</strong></p><p><strong>reverse()</strong></p><p>这些方法都会直接修改原来的数组，</p><p>对于一些纯函数的数组方法，他会返回一个新的数组，所以必须将这个新的数组赋值给原来的属性</p><h4 id="43-v-for中key的作用"><a href="#43-v-for中key的作用" class="headerlink" title="43.v-for中key的作用"></a>43.v-for中key的作用</h4><p>key属性主要适用于Diff算法中，在新旧node对比时辨识vnode,如果不使用key,vue会使用一种最大限度减少动态元素并且尽可能的尝试就地复用或者修改相同类型的元素的算法</p><p>而使用了key时，他会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素</p><h4 id="44-什么是vnode"><a href="#44-什么是vnode" class="headerlink" title="44.什么是vnode"></a>44.什么是vnode</h4><p>vnode 全称virual node 就是虚拟节点，组件和元素都会被抽象成一个个虚拟节点，vnode本质就是一个个对象</p><h4 id="45-diff算法"><a href="#45-diff算法" class="headerlink" title="45.diff算法"></a>45.diff算法</h4><p>针对有key的vnode进行diff操作时</p><p><strong>1.首先会对新旧节点进行遍历，从头部开始，遇到相同的节点则继续，直到遇到不用的节点则跳出</strong></p><p><strong>2.然后再从新旧vnode节点的尾部开始遍历，遇到相同的节点则继续，遇到不同的节点则会跳出</strong></p><p><strong>3.如果最后新的节点更多，那么就添加新的节点</strong></p><p><strong>4.如果旧的节点比较多，则会移除旧的节点</strong></p><p><strong>5.如果中间存在无序的节点，就通过key建立所用途最大限度的复用旧节点</strong></p><h4 id="46-computed"><a href="#46-computed" class="headerlink" title="46.computed"></a>46.computed</h4><p>​    computed有缓存，只有依赖的属性发生变化的时候才会重新执行</p><p>​    computed和method的区别</p><p>​            computed是计算属性，method是方法，每次都会调用，computed只有数据变化时才会调用</p><p>​    computed的get set写法</p><p><img src="https://img1.imgtp.com/2022/08/16/u2w0mqRW.png" alt="QQ截图20220806170911.png"></p><h4 id="47-watch"><a href="#47-watch" class="headerlink" title="47.watch"></a>47.watch</h4><p><img src="https://img1.imgtp.com/2022/08/16/c9HE9R2T.png" alt="QQ截图20220807012240.png"></p><h2 id="回调的触发时机"><a href="#回调的触发时机" class="headerlink" title="回调的触发时机#"></a>回调的触发时机<a href="https://cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing">#</a></h2><p>当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。</p><p>默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新<strong>之前</strong>被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。</p><p>如果想在侦听器回调中能访问被 Vue 更新<strong>之后</strong>的DOM，你需要指明 <code>flush: &#39;post&#39;</code> 选项：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">watch</span>: &#123;    <span class="hljs-attr">key</span>: &#123;      <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) &#123;&#125;,      <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span>    &#125;  &#125;&#125;</code></pre></div><h4 id="48-jsconfig-json主要是给vscode中给项目更好的提示，没有也没关系"><a href="#48-jsconfig-json主要是给vscode中给项目更好的提示，没有也没关系" class="headerlink" title="48.jsconfig.json主要是给vscode中给项目更好的提示，没有也没关系"></a>48.jsconfig.json主要是给vscode中给项目更好的提示，没有也没关系</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//vue.config.js</span><span class="hljs-keyword">const</span> &#123; defineConfig &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@vue/cli-service&#x27;</span>)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>(&#123;  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">configureWebpack</span>: &#123;    <span class="hljs-attr">resolve</span>: &#123;      <span class="hljs-comment">// 配置路径别名</span>      <span class="hljs-comment">// @是已经配置好的路径别名: 对应的是src路径</span>      <span class="hljs-attr">alias</span>: &#123;        <span class="hljs-string">&quot;utils&quot;</span>: <span class="hljs-string">&quot;@/utils&quot;</span>       &#125;    &#125;  &#125;&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">//jsconfig.json</span><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es5&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esnext&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//定义根目录</span>    <span class="hljs-attr">&quot;moduleResolution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>      <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-string">&quot;src/*&quot;</span>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">//webpack配置了别名，为了给项目中更好的提示，可以在这里配置，否则写的时候没有提示</span>      <span class="hljs-attr">&quot;utils/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-string">&quot;src/utils/*&quot;</span>      <span class="hljs-punctuation">]</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;lib&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>      <span class="hljs-string">&quot;esnext&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-string">&quot;dom&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-string">&quot;dom.iterable&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-string">&quot;scripthost&quot;</span>    <span class="hljs-punctuation">]</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h4 id="49-v-model"><a href="#49-v-model" class="headerlink" title="49.v-model"></a>49.v-model</h4><h4 id="50-使用手脚架开发"><a href="#50-使用手脚架开发" class="headerlink" title="50.使用手脚架开发"></a>50.使用手脚架开发</h4><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @vue<span class="hljs-regexp">/cli -g   /</span>/安装手脚架<span class="hljs-built_in">npm</span> update @vue<span class="hljs-regexp">/cli -g /</span>/更手脚架Vue create 项目的名称这种方式采用webpack作为构建工具现在官方已经不再作为推荐的手脚搭建工具了开始使用<span class="hljs-built_in">npm</span> init vue@latest 命令  使用vite作为构建工具</code></pre></div><img src="https://img1.imgtp.com/2022/08/15/2VVktFIN.png" alt="图片1.png" style="zoom:200%;" /><img src="https://img1.imgtp.com/2022/08/15/QcWf8mgQ.png" alt="图片2.png" style="zoom:200%;" /><img src="https://img1.imgtp.com/2022/08/15/hS9wL3j1.png" alt="图片3.png" style="zoom:200%;" /><img src="https://img1.imgtp.com/2022/08/15/0QrTy1qq.png" alt="图片4.png" style="zoom:200%;" /><p><img src="https://img1.imgtp.com/2022/08/16/v3jDRHw7.png" alt="QQ截图20220815210717.png"></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue/dist/vue.esm-bundler&quot;</span>;<span class="hljs-comment">// import App from &#x27;./App.vue&#x27;</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 当App是以对象的形式写的话就要使用 vue/dist/vue.esm-bundler</span><span class="hljs-comment"> * 这两种方式的不同，使用对象的方式，是因为如果引入的是vue,vue是runtime的代码，，不会编译template成</span><span class="hljs-comment"> * vnode,需要使用vue/dist/vue.esm-bundler</span><span class="hljs-comment"> * 里面包括compiler+runtime，可以将template-&gt;createVNode-&gt;Vnode-&gt;DOM,对象的写法是由</span><span class="hljs-comment"> * vue/dist/vue.esm-bundler的源码来完成的，.vue文件的写法是由vue-loader来完成template-&gt;vnode的过程</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = &#123;  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;&#125;;  &#125;,  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h1&gt;vue&lt;/h1&gt;`</span>,&#125;;<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>);</code></pre></div><h4 id="51-注册组件的方式"><a href="#51-注册组件的方式" class="headerlink" title="51.注册组件的方式"></a>51.注册组件的方式</h4><p>全局组件</p><p>局部组件</p><h4 id="52-父组件向子组件传递数据"><a href="#52-父组件向子组件传递数据" class="headerlink" title="52.父组件向子组件传递数据"></a>52.父组件向子组件传递数据</h4><p>父组件向子组件传递数据是通过props来完成的</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// 写法一</span>  <span class="hljs-comment">// props: [&quot;height&quot;, &quot;name&quot;, &quot;gender&quot;, &quot;width&quot;],</span>  <span class="hljs-comment">// 写法二</span>  <span class="hljs-comment">// props: &#123;</span>  <span class="hljs-comment">//   height: Object,</span>  <span class="hljs-comment">//   name: Number,</span>  <span class="hljs-comment">//   gender: String,</span>  <span class="hljs-comment">//   width: Number,</span>  <span class="hljs-comment">// &#125;,</span>  <span class="hljs-comment">// 第三种写法</span>  <span class="hljs-comment">// 当默认值是对象或者函数的时候，必须返回一个函数</span>  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">propsB</span>: &#123;      <span class="hljs-comment">// 当props是一个函数的时候，这个不是一个工厂函数，而是作为一个默认值</span>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>,      <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;default&quot;</span>;      &#125;,    &#125;,    <span class="hljs-attr">h</span>: [<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">String</span>], <span class="hljs-comment">//可以是多种类型</span>    <span class="hljs-attr">a</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//表示是必填值</span>    &#125;,    <span class="hljs-attr">height</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hhhh&quot;</span> &#125;),    &#125;,    <span class="hljs-attr">name</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,      <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;我是string&quot;</span>,    &#125;,    <span class="hljs-attr">gender</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,      <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];      &#125;,    &#125;,    <span class="hljs-attr">width</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,      <span class="hljs-attr">default</span>: <span class="hljs-number">88888</span>,    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre></div><h5 id="prop常见的两种用法"><a href="#prop常见的两种用法" class="headerlink" title="prop常见的两种用法"></a>prop常见的两种用法</h5><p>字符串数组，就是数组中的字符串就是attribute的名称，传递的数据类型时只能是字符串，不能是其他类型</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">show-info</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;why&quot;</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">:height</span>=<span class="hljs-string">&quot;1.88&quot;</span> </span><span class="hljs-tag">             <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;广州市&quot;</span> <span class="hljs-attr">abc</span>=<span class="hljs-string">&quot;cba&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span> /&gt;</span>//传递的数据类型不是string值，是其他类型或者是变量，必须用v-bind/:</code></pre></div><p>对象类型，对象类型我们可以指定attribute名称时，指定传递类型默认值，校验等</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">show-info</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">show-message</span>=<span class="hljs-string">&quot;哈哈哈哈&quot;</span>/&gt;</span></code></pre></div><h5 id="props允许的数据类型"><a href="#props允许的数据类型" class="headerlink" title="props允许的数据类型"></a>props允许的数据类型</h5><p><code>String,Number,Boolean,Array,Object,Date,Function,Symbol</code></p><h5 id="props的命名"><a href="#props的命名" class="headerlink" title="props的命名"></a>props的命名</h5><p>html中attribute名大小写不敏感，所以浏览器会把所有大写解释为小写，在模板中使用驼峰规则，的prop名要写成短横线</p><h4 id="53-非prop的attribute"><a href="#53-非prop的attribute" class="headerlink" title="53.非prop的attribute"></a>53.非prop的attribute</h4><p>当我们传递一个组件某个属性值，但是这个属性值没有对应的props和emits，就是非props的attribute，例如class,style,id等。</p><p>当组件有单个根节点时，非prop的attribute就会默认绑定到根节点上</p><p>如果不希望绑定到根节点，想要手动的绑定节点，可以在组件中设置</p><div class="code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-symbol">inheritAttr:</span><span class="hljs-literal">false</span></code></pre></div><p>就可以通过$attrs来访问所有的非props的attribute</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;$attr.class&quot;</span>&gt;</span>hhhhhhhh<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">    <span class="hljs-attr">inheritAttrs</span>:<span class="hljs-literal">false</span></span><span class="language-javascript">  &#125;</span></code></pre></div><p><strong>多个根节点的attribute</strong></p><p>如果是多个根节点的情况，多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个元素上</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attr&quot;</span>&gt;</span>hhhhhhhh<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>33333<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>4444<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p><em>注意</em>template模板中允许有多个根节点</p><h4 id="54-子组件向父组件从传递数据"><a href="#54-子组件向父组件从传递数据" class="headerlink" title="54.子组件向父组件从传递数据"></a>54.子组件向父组件从传递数据</h4><div class="code-wrapper"><pre><code class="hljs html">//子组件<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick(1)&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick(5)&quot;</span>&gt;</span>+5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick(10)&quot;</span>&gt;</span>+10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">    <span class="hljs-comment">// 1.emits数组语法</span></span><span class="language-javascript">    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&quot;add&quot;</span>],</span><span class="language-javascript">    <span class="hljs-comment">// 2.emmits对象语法</span></span><span class="language-javascript">    <span class="hljs-comment">// emits: &#123;</span></span><span class="language-javascript">    <span class="hljs-comment">//   add: function(count) &#123;</span></span><span class="language-javascript">    <span class="hljs-comment">//     if (count &lt;= 10) &#123;</span></span><span class="language-javascript">    <span class="hljs-comment">//       return true</span></span><span class="language-javascript">    <span class="hljs-comment">//     &#125;</span></span><span class="language-javascript">    <span class="hljs-comment">//     return false</span></span><span class="language-javascript">    <span class="hljs-comment">//   &#125;</span></span><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title function_">btnClick</span>(<span class="hljs-params">count</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btnClick:&quot;</span>, count)</span><span class="language-javascript">        <span class="hljs-comment">// 让子组件发出去一个自定义事件</span></span><span class="language-javascript">        <span class="hljs-comment">// 第一个参数自定义的事件名称</span></span><span class="language-javascript">        <span class="hljs-comment">// 第二个参数是传递的参数</span></span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-number">100</span>)</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//app,vue<span class="hljs-tag">&lt;<span class="hljs-name">add-counter</span> @<span class="hljs-attr">add</span>=<span class="hljs-string">&quot;addBtnClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">add-counter</span>&gt;</span></code></pre></div><h4 id="55-插槽slot"><a href="#55-插槽slot" class="headerlink" title="55.插槽slot"></a>55.插槽slot</h4><p>插槽的使用过程其实是抽取共性、预留不同</p><div class="code-wrapper"><pre><code class="hljs html">//show-message.vue//插槽的定义方式，使用<span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>标签进行占位，可以写入默认值，没有传递时就是用默认值<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是默认内容, 哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//插槽的使用<span class="hljs-tag">&lt;<span class="hljs-name">show-message</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>百度一下<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">show-message</span>&gt;</span></code></pre></div><h4 id="56-具名插槽的使用"><a href="#56-具名插槽的使用" class="headerlink" title="56.具名插槽的使用"></a>56.具名插槽的使用</h4><p>当需要插入不同的模块到不同的slot的时候，需要定义具体的名字。默认情况下不带名字时，会有默认的名字。</p><p>一个不带 name 的slot，会带有隐含的名字 default；</p><p>具名插槽使用的时候缩写：</p><p>跟 v-on 和 v-bind 一样，v-slot 也有缩写； </p><p> 即把参数之前的所有内容 (v-slot:) 替换为字符 #；</p><div class="code-wrapper"><pre><code class="hljs html">//nav-bar.vue<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-bar&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;other&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//App.vue<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">nav-bar</span>&gt;</span>  //简写    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">left</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#123; leftText &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">center</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>//完整写法    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:right</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">nav-bar</span>&gt;</span>  <span class="hljs-comment">&lt;!-- nav-bar只给一个插槽传入数据 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">nav-bar</span>&gt;</span>  //动态插槽名    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">position</span>]&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">nav-bar</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot; position = &#x27;left&#x27; &quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot; position = &#x27;center&#x27; &quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot; position = &#x27;right&#x27; &quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">NavBar</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./NavBar.vue&#x27;</span></span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title class_">NavBar</span></span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;center&quot;</span>,</span><span class="language-javascript">        <span class="hljs-attr">leftText</span>: <span class="hljs-string">&quot;返回&quot;</span></span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h4 id="57-渲染作用域"><a href="#57-渲染作用域" class="headerlink" title="57.渲染作用域"></a>57.渲染作用域</h4><p>在vue模板中，父级模板的所有内容都是在父级作用域中编译完成的</p><p>子模版中所有内容都是在作用域中编译完成的，所以具名插槽的作用域是在父级，而作用域插槽的作用域是在子模版中</p><h4 id="58-作用域插槽"><a href="#58-作用域插槽" class="headerlink" title="58.作用域插槽"></a>58.作用域插槽</h4><p>作用域插槽可以通过插槽访问子组件的内容，而修改每个具体的样式</p><div class="code-wrapper"><pre><code class="hljs html">//tabControll.vue<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tab-control&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in titles&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tab-control-item&quot;</span></span><span class="hljs-tag">           <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: index === currentIndex &#125;&quot;</span></span><span class="hljs-tag">           @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;itemClick(index)&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">abc</span>=<span class="hljs-string">&quot;cba&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>//这是默认值        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//App.vue<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.tab-control --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- &lt;tab-control :titles=&quot;[&#x27;流行&#x27;, &#x27;最新&#x27;, &#x27;优选&#x27;]&quot;/&gt; --&gt;</span>    <span class="hljs-comment">&lt;!-- 2.展示内容 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; pageContents[currentIndex] &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.tab-control: button --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-control</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 2.tab-control: a元素(重要) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-control</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 3.独占默认插槽的简写(了解) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-control</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 4.如果只有一个默认插槽, 那么template可以省略 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span></span><span class="hljs-tag">                 <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-control</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h4 id="59-非父子组件之间的通信"><a href="#59-非父子组件之间的通信" class="headerlink" title="59.非父子组件之间的通信"></a>59.非父子组件之间的通信</h4><p>1.全局的事件总线</p><p>vue3中移除了$on,$off,$once方法，如果需要使用事件总线，可以使用第三方库，或者通过自己写的事件总线方法。事件总线不经可以用于非父子组件的通信，也可以用于任意组件的通信</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//event-bus.js  事件总线初始化</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HYEventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hy-event-store&#x27;</span><span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HYEventBus</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> eventBus</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//App.vue   在created声明周期中监听事件</span><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-comment">// fetch()</span>      <span class="hljs-comment">// 事件监听</span>      eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;whyEvent&quot;</span>, <span class="hljs-function">(<span class="hljs-params">name, age, height</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;whyEvent事件在app中监听&quot;</span>, name, age, height)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">`name:<span class="hljs-subst">$&#123;name&#125;</span>, age:<span class="hljs-subst">$&#123;age&#125;</span>, height:<span class="hljs-subst">$&#123;height&#125;</span>`</span>      &#125;)    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//在Category.vue中 created中监听，在unmounted中移出事件</span><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils/event-bus&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">whyEventHandler</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;whyEvent在category中监听&quot;</span>)    &#125;  &#125;,  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;whyEvent&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">whyEventHandler</span>)  &#125;,  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;category unmounted&quot;</span>)    eventBus.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;whyEvent&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">whyEventHandler</span>)  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//HomeBanner.vue  emit事件</span><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils/event-bus&#x27;</span> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;   <span class="hljs-attr">methods</span>: &#123;     <span class="hljs-title function_">bannerBtnClick</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bannerBtnClick&quot;</span>)       eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;whyEvent&quot;</span>, <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)     &#125;   &#125; &#125;</code></pre></div><p>2.Provide/inject</p><p>provide和inject可以用于跨组件的通信</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//App.vue</span><span class="hljs-comment">// provide一般都是写成函数 也可以写成对象，如果需要使用data中的属性，必须使用函数形式</span>   <span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-keyword">return</span> &#123;       <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,       <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,       <span class="hljs-comment">//默认不是响应式的，如果需要变成响应式的，要使用computed，computed的返回值是一个ref对象，需要使用.value来获取</span>       <span class="hljs-attr">message</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<span class="hljs-comment">//要写箭头函数，箭头函数的this是由上层作用域来决定的</span>     &#125;   &#125; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div class=&quot;banner&quot;&gt;    &lt;h2&gt;HomeBanner: &#123;&#123; name &#125;&#125; - &#123;&#123; age &#125;&#125; - &#123;&#123;message.value&#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    inject: [&quot;name&quot;, &quot;age&quot;, &quot;message&quot;]  &#125;&lt;/script&gt;</code></pre></div><h4 id="60-组件的生命周期"><a href="#60-组件的生命周期" class="headerlink" title="60.组件的生命周期"></a>60.组件的生命周期</h4><p><img src="https://img1.imgtp.com/2022/08/17/Lqxt3NMi.png" alt="lifecycle.16e4c08e.png"></p><p>父子组件的挂载过程</p><p>父组件beforeCreate -&gt;父组件created-&gt;父组件beforemount-&gt;子组件beforeCreate-&gt;子组件created-&gt; 子组件beforeMount-&gt;子组件mounted-&gt;父组件mounted</p><h4 id="61-refs的使用"><a href="#61-refs的使用" class="headerlink" title="61.$refs的使用"></a>61.$refs的使用</h4><p>通过$refs可以获取到子元素或者子组件</p><p>通过<code>this.$refs.refName</code>可以获取到子组件实例，子组件实例是一个Proxy代理，vue组件是一个对象类似于一个class，根据class创建一个组件实例，通过<code>this.$refs.refname.$el</code>可以获取到组件DOM元素。，<code>this.$parent</code>获取到父组件元素，<code>this.$root</code>获取到根组件元素，$ref还可以调用子组件的属性和方法在Vue3中已经移除了$children的属性</p><p>如果template中由多个根，拿到的是第一个node节点</p><p><img src="https://img1.imgtp.com/2022/08/17/RTih8iQq.png" alt="QQ截图20220817150027.png"></p><h4 id="62-动态组件"><a href="#62-动态组件" class="headerlink" title="62.动态组件"></a>62.动态组件</h4><p>is中的组件只能是局部已注册的组件和全局组件</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;why&quot;</span> </span><span class="hljs-tag">                 <span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;18&quot;</span></span><span class="hljs-tag">                 @<span class="hljs-attr">homeClick</span>=<span class="hljs-string">&quot;homeClick&quot;</span></span><span class="hljs-tag">                 <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentTab&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></code></pre></div><h4 id="63-组件缓存keep-alive"><a href="#63-组件缓存keep-alive" class="headerlink" title="63.组件缓存keep-alive"></a>63.组件缓存keep-alive</h4><p>如果组件频繁的切换会造成性能消耗增加，如果需要保存组件切换之前的状态，可以使用keep-alive，他通常和Component动态组件一起使用</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!-- include: 组件的名称来自于组件内部定义时name选项  --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;home,about&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentTab&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="include-exclude"><a href="#include-exclude" class="headerlink" title="include/exclude"></a>include/exclude</h5><p><code>&lt;KeepAlive&gt;</code> 默认会缓存内部的所有组件实例，但我们可以通过 <code>include</code> 和 <code>exclude</code> prop 来定制该行为。这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 以英文逗号分隔的字符串 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;a,b&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span><span class="hljs-comment">&lt;!-- 正则表达式 (需使用 `v-bind`) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;/a|b/&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span><span class="hljs-comment">&lt;!-- 数组 (需使用 `v-bind`) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span></code></pre></div><p>它会根据组件的 <a href="https://cn.vuejs.org/api/options-misc.html#name"><code>name</code></a> 选项进行匹配，所以组件如果想要条件性地被 <code>KeepAlive</code> 缓存，就必须显式声明一个 <code>name</code> 选项</p><p><em>TIP</em></p><p><em>在 3.2.34 或以上的版本中，使用 <code>&lt;script setup&gt;</code> 的单文件组件会自动根据文件名生成对应的 <code>name</code> 选项，无需再手动声明。</em></p><h5 id="最大缓存实例数-https-cn-vuejs-org-guide-built-ins-keep-alive-html-max-cached-instances"><a href="#最大缓存实例数-https-cn-vuejs-org-guide-built-ins-keep-alive-html-max-cached-instances" class="headerlink" title="最大缓存实例数[#](https://cn.vuejs.org/guide/built-ins/keep-alive.html#max-cached-instances"></a>最大缓存实例数[#](<a href="https://cn.vuejs.org/guide/built-ins/keep-alive.html#max-cached-instances">https://cn.vuejs.org/guide/built-ins/keep-alive.html#max-cached-instances</a></h5><p>我们可以通过传入 <code>max</code> prop 来限制可被缓存的最大组件实例数。<code>&lt;KeepAlive&gt;</code> 的行为在指定了 <code>max</code> 后类似一个 <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">LRU 缓存</a>：如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;activeComponent&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span></code></pre></div><p>缓存实例的生命周期</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">activated</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 在首次挂载、</span>    <span class="hljs-comment">// 以及每次从缓存中被重新插入的时候调用</span>  &#125;,  <span class="hljs-title function_">deactivated</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 在从 DOM 上移除、进入缓存</span>    <span class="hljs-comment">// 以及组件卸载时调用</span>  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现可过期的localstorage数据(仅供参考)</title>
    <link href="/2022/08/15/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84localstorage%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/08/15/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84localstorage%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>localstorage相对于cookie中的问题是不能设置过期时间</p><p>所以我们要自己对localStorage进行二次封装，使得localstorage在适当的时间失效</p><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-keyword">const</span> timeout = <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;key&quot;</span>);&#125;, timeout);</code></pre></div><p>这种方式需要编写多个定时器，维护成本高，不利于代码的复用</p><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><ol><li>用<strong>「localStorage」</strong>存一份{key(键): expire(过期时间)}的映射表</li><li>重写<strong>「localStorage API」</strong>, 对方法进行二次封装</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = &#123;  <span class="hljs-title function_">setExpireMap</span>(<span class="hljs-params">key, expire</span>) &#123;    <span class="hljs-keyword">const</span> expireMap = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;EXPIRE_MAP&quot;</span>) || &#123;&#125;;    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(      <span class="hljs-string">&quot;EXPIRE_MAP&quot;</span>,      <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;        ...expireMap,        [key]: expire,      &#125;)    );  &#125;,  <span class="hljs-title function_">setItem</span>(<span class="hljs-params">key, value, expire</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setExpireMap</span>(key, expire);    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, value);  &#125;,  <span class="hljs-title function_">getItem</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> expireMap = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;EXPIRE_MAP&quot;</span>))[key];    <span class="hljs-keyword">if</span> (expireMap &amp;&amp; expireMap &gt; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key);    &#125;    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key);    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;,&#125;;</code></pre></div><ul><li>对 <code>store</code> 操作时需要维护2份数据, 并且占用缓存空间</li><li>如果 <code>EXPIRE_MAP</code> 误删除将会导致所有过期时间失效</li><li>对操作过程缺少更灵活的控制(比如操作状态, 操作回调等)</li></ul><h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>惰性删除，只有在下一次取值的时候才删除</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lsc = (<span class="hljs-keyword">function</span> (<span class="hljs-params">self</span>) &#123;    <span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&#x27;one_more_lsc_&#x27;</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加一个键值对数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val 值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expires 过期时间，单位为秒</span><span class="hljs-comment">     */</span>    self.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">key, val, expires</span>) &#123;        key = prefix + key;        val = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<span class="hljs-string">&#x27;val&#x27;</span>: val, <span class="hljs-string">&#x27;expires&#x27;</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() + expires * <span class="hljs-number">1000</span>&#125;);        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, val);    &#125;;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 读取对应键的值数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">null|*</span>&#125; 对应键的值</span><span class="hljs-comment">     */</span>    self.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) &#123;        key = prefix + key;        <span class="hljs-keyword">var</span> val = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key);        <span class="hljs-keyword">if</span> (!val) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        val = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(val);        <span class="hljs-keyword">if</span> (val.<span class="hljs-property">expires</span> &lt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()) &#123;            <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">return</span> val.<span class="hljs-property">val</span>;    &#125;;    <span class="hljs-keyword">return</span> self;&#125;(lsc || &#123;&#125;));</code></pre></div><p>上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。</p><h4 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h4><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p><p>每隔一秒执行一次定时删除，操作如下：</p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复<strong>步骤1</strong>，直至重复500次。</li></ol><p>具体实现如下：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lsc = (<span class="hljs-keyword">function</span> (<span class="hljs-params">self</span>) &#123;    <span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&#x27;one_more_lsc_&#x27;</span>    <span class="hljs-keyword">var</span> list = [];    <span class="hljs-comment">//初始化list</span>    self.<span class="hljs-property">init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">var</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>);        <span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;^&#x27;</span> + prefix);        <span class="hljs-keyword">var</span> temp = [];        <span class="hljs-comment">//遍历所有localStorage中的所有key</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-comment">//找出可过期缓存的key</span>            <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(keys[i])) &#123;                temp.<span class="hljs-title function_">push</span>(keys[i]);            &#125;        &#125;        list = temp;    &#125;;    self.<span class="hljs-title function_">init</span>();    self.<span class="hljs-property">check</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">if</span> (!list || list.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">var</span> checkCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (checkCount &lt; <span class="hljs-number">500</span>) &#123;            <span class="hljs-keyword">var</span> expireCount = <span class="hljs-number">0</span>;            <span class="hljs-comment">//随机测试20个设置了过期时间的key</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;                <span class="hljs-keyword">if</span> (list.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">var</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * list.<span class="hljs-property">length</span>);                <span class="hljs-keyword">var</span> key = list[index];                <span class="hljs-keyword">var</span> val = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(list[index]);                <span class="hljs-comment">//从list中删除被惰性删除的key</span>                <span class="hljs-keyword">if</span> (!val) &#123;                    list.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);                    expireCount++;                    <span class="hljs-keyword">continue</span>;                &#125;                val = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(val);                <span class="hljs-comment">//删除所有发现的已过期的key</span>                <span class="hljs-keyword">if</span> (val.<span class="hljs-property">expires</span> &lt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()) &#123;                    list.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);                    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key);                    expireCount++;                &#125;            &#125;            <span class="hljs-comment">//若删除的key不超过5个则跳出循环</span>            <span class="hljs-keyword">if</span> (expireCount &lt;= <span class="hljs-number">5</span> || list.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            checkCount++;        &#125;    &#125;    <span class="hljs-comment">//每隔一秒执行一次定时删除</span>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setInterval</span>(self.<span class="hljs-property">check</span>, <span class="hljs-number">1000</span>);    <span class="hljs-keyword">return</span> self;&#125;(lsc || &#123;&#125;));</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>搜集</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端系统课笔记</title>
    <link href="/2022/08/14/%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/14/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs stata">1.margin-left的值如果是百分比时，相对于他的包含块的宽度的百分比，即他的父元素2.性能优化点：link ref=`dns-prefetch`dns预获取，在资源加载之前获取到真实的ip地址3.rgb R红 <span class="hljs-keyword">G</span>绿 B蓝  \#ff0000 十六进制表示法  rgb(0，0，0) 十进制表示4.image/vedio是行内可替换元素，不是行内块级元素5.<span class="hljs-keyword">line</span>-hight是继承属性6.#表示多个属性是以逗号分隔7.+表示多个属性是以空格分隔8.text-align 时将行内元素相对于父级块元素进行居中例如img 文本 <span class="hljs-keyword">input</span>等9.text-ident和width以em为单位的时候是相对于自身的，font-size可以从父元素继承，如果父元素设置了font-size则会继承下来并相对于自身10.普遍兄弟选择器只能选中下面的所有兄弟元素11.script标签放到html的头部时要加<span class="hljs-keyword">window</span>.onload12.伪类hover,link,visited,active的执行顺序 LVHA13.除了a标签，hover和active也可以用在其他元素上14.a元素没有设置伪类，默认所有伪类都是相同的设置15.::first-<span class="hljs-keyword">line</span>选中首行元素::first-letter选中首字母元素之间的间隙默认是换行符，去掉换行符可以::after&#123;content:url(<span class="hljs-string">&quot;./image/icon.svg&quot;</span>);<span class="hljs-comment">//可以这样来添加图片</span>color:green&#125;&lt;p&gt;这是上面代码的实现&lt;<span class="hljs-keyword">br</span> /&gt;  我们有一些 &lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;collection of words and punctuation&quot;</span>&gt;文字&lt;/span&gt; 有一些  &lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;small popups which also hide again&quot;</span>&gt;提示&lt;/span&gt;。&lt;<span class="hljs-keyword">br</span> /&gt;  把鼠标放上去&lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;not to be taken literally&quot;</span>&gt;看看&lt;/span&gt;。&lt;/p&gt;<span class="hljs-comment">//自定义属性</span>::after伪元素，attr()CSS表达式和一个自定义数据属性 data-<span class="hljs-keyword">descr</span> 创建一个纯CSS content: attr(data-<span class="hljs-keyword">descr</span>);   16.怎么画0.5px的线 17.常见的继承属性：font-size,font-weight,font-family,<span class="hljs-keyword">line</span>-height,color,text-align一般和文本有关的 1.  css的权重 important 10000 内联选择器 1000 id选择器 100 类选择器，属性选择器，伪类 10 元素选择器，伪元素 1 通配选择器  019.img，vedio,<span class="hljs-keyword">input</span>是行内替换元素  和其他行内元素在一行显示，可以设置宽高行内非替换元素不可以设置宽高20.伪元素是行内非替换元素，不可以设置宽高，必须转成行内块级元素和块级元素，在使用伪元素过程中必须加content21.不要在p元素里面放块元素22.行内元素不要放块级元素，只能放行内元素23.设置元素不可见的方式1.<span class="hljs-keyword">display</span>:none 不占据任何空间2.visibility:hidden占据空间不可见3.设置颜色透明度4.background:transparent可以是背景颜色透明5.opacity:1,可以设置透明度，但是会使子元素也会变透明，具有穿透性24.padding:10px 20px 30px 写三个值得时候，左边没有值，用右边的替代25.border-radius百分比圆角水平方向是width+border的百分比，圆角垂直方向是height+border的百分比border-radius:50%是个圆，超过百分之50%也是圆，超过50%，无效26.marginmargin的传递 左右margin不传递margin-top的传递 如果块级元素顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top就会传递给父元素margin-bottom如果块级元素的底部线和父元素的底部线出现重叠，且父元素高度为auto时，会传递解决：1.父元素设置border 2.父元素使用padding 3.触发bfc上下margin的折叠 兄弟块元素上下两个margin合并成一个margin，折叠后取较大的值。解决方法只设置一个父子之间折叠，也会出线相同的情况27.outline  外轮廓不占据空间，默认显示在border外面 outlone:none可以去除a元素，<span class="hljs-keyword">input</span>元素focus状态下的默认外轮廓28.box-shadow:offset-x offset-y blur(模糊度) 向外扩散的值 color ，多个阴影以逗号分隔，会叠加29.text-shadow:文字添加阴影27.行内非替换元素的注意事项1.不可以设置width和height2.设置margin-top.margin-bottom不生效，margi-left和margin-right生效3.设置padding-top,padding-bottom会不等高，且不占据空间，设置padding-right和padding-left生效4.设置border和padding给相同效果28.html5语义化标签&lt;header&gt;&lt;nav&gt;&lt;section&gt;&lt;artical&gt;&lt;aside&gt;&lt;footer&gt;29.vedio和audio时行内替换元素   在针对不同的播放格式写法   &lt;vedio src=<span class="hljs-string">&quot;&quot;</span>&gt;   &lt;source src=<span class="hljs-string">&quot;.../....mp4&quot;</span>&gt;&lt;/source&gt;   &lt;source src=<span class="hljs-string">&quot;.avi&quot;</span>&gt;&lt;/source&gt;   &lt;source src=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/source&gt;   &lt;p&gt;该浏览器不支持&lt;/p&gt;   &lt;/vedio&gt;30.data-*自定义属性，可以html和js中进行数据传递31.white-space:normal|nowrap|pre|.....32.text-overflow:clip|esclip text-overflow必须在overflow不是visible才生效33.css函数1.<span class="hljs-keyword">var</span> 定义CSS变量属性名要以--开头html&#123;--main-color:#fffff&#125;div&#123;color:<span class="hljs-keyword">var</span>(--main-color)&#125;2.calc 计算CSS值，3.blur  高斯模糊--毛玻璃效果  blur(radius)可以应用于图片或者元素，radius模糊半径可以和filter一起使用。filter:blur(5px)，会使所有子元素都有高斯模糊图片的高斯模糊也可以在图片上添加一个遮盖层，用定位元素父元素：position:relative.cover&#123;position:absolutetop:0left:0right:0bottom:0background:rgba(0,0,0,.5)<span class="hljs-comment">//透明效果</span>background-filter:blur(5px)<span class="hljs-comment">//高斯模糊</span>&#125;4.gradient 颜色渐变函数 是一种&lt;image&gt;css数据类型的子类型，用于图片颜色的过度转变  liner-gradient 线性渐变 background-image:linear-gradient(to right top ,red,blue)     34.background背景色对也border,padding有效   color前景色对border也是有效的，border没有设置颜色时，会使用color的值  35.浏览器前缀：-o-,-xv-,-ms-,-mso-,0moz-.-webkit-36.bfc 兄弟块元素margin折叠35.媒体查询36.css单位em rempxvw/vh%37.less定义变量 @mainColor:#ffff使用变量 @mainColor兼容css&amp;:hover &amp;::afterless的运算less的混合(Mixins)    .box2(@borderwidth:1px,@borderColor:red)&#123;    border:@borderwidth solid @borderColor    &#125;    .box-size&#123;    width:100px;    height:200px    &#125;.box&#123;<span class="hljs-comment">//混入方式,可以传参</span>.box2(2px,green)width:.box-size[width]<span class="hljs-comment">//混入和映射结合使用</span>&amp;:extend(.box-size) <span class="hljs-comment">//继承</span>&#125;less内置函数.box&#123;color:color(red)<span class="hljs-comment">//将转换成16进制</span>width:convert(100px,<span class="hljs-string">&quot;in&quot;</span>)单位准换，转成英寸<span class="hljs-built_in">floor</span>()向下取整<span class="hljs-built_in">ceil</span>()向上取整&#125;less的作用域：查找一个变量时，会在本地和混入先查找，然后再父级查找less的注释less的导入 import38.移动端适配   视口viewport   布局视口   视觉视口   理想视口   &lt;<span class="hljs-keyword">meta</span> name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=980px&quot;</span>&gt;<span class="hljs-comment">//修改布局视口的宽度，对pc端无效</span>   &lt;<span class="hljs-keyword">meta</span> name=<span class="hljs-string">&quot;viewport&quot;</span> content=&quot;device-width，initial-<span class="hljs-keyword">scal</span>=1.0,user-scalable=<span class="hljs-keyword">no</span>   minimun-<span class="hljs-keyword">scal</span>=1.0,maximun-scale=1.0   &gt;39.css的相对单位em,是相对于自身的font-size来进行定位的，如果自己已经定义了font-size的px，则用自身的font-size,否则就继承自父元素的font-sizerem是基于根元素的字体的大小vw是视窗宽度的1%vh是视窗高度的1%40.再pc端，布局视口和视觉视口是同一个，不用区分默认情况下，一个在PC端的网页在移动端会如何显示呢？ 第一，它会按照宽度为980px来布局一个页面的盒子和内容； 第二，为了显示可以完整的显示在页面中，对整个页面进行缩小我们相对于980px布局的这个视口，称之为布局视口（layout viewport）； 布局视口的默认宽度是980px；视觉视口（visual viewport） 如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用户的可见区域中； 那么显示在可见区域的这个视口，就是视觉视口（visual viewport）41.适配方案 – rem+动态html的font-size   使用该方案有两个问题    问题一：针对不同的屏幕，设置html不同的font-size；     问题二：将原来要设置的尺寸，转化成rem单位；    方案一：媒体查询     可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸；     缺点：    ✓ 1.我们需要针对不同的屏幕编写大量的媒体查询；    ✓ 2.如果动态改变尺寸，不会实时的进行更新；    ◼ 方案二：编写js代码     如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码；     方法：    ✓ 1.根据html的宽度计算出font-size的大小，并且设置到html上；    ✓ 2.监听页面的实时改变，并且重新设置font-size的大小到html上；        rem的单位换算方案一：手动换算方案二：less/scss函数◼ 方案四：VSCode插件 px to rem 的插件，在编写时自动转化◼ 方案四：VSCode插件 px to rem 的插件，在编写时自动转化三：postcss-pxtorem42。<span class="hljs-keyword">meta</span>标签的作用可以在head中定义元信息，例如 比如标题title、样式style、link外部资源等；     <span class="hljs-keyword">meta</span>用于定义那些不能使用其他定元相关（<span class="hljs-keyword">meta</span>-related）元素定义的任何元数据信息；    <span class="hljs-keyword">meta</span> 元素定义的元数据的类型包括以下几种：             如果设置了 charset 属性，<span class="hljs-keyword">meta</span> 元素是一个字符集声明，告诉文档使用哪种字符编码。             如果设置了 http-equiv 属性，<span class="hljs-keyword">meta</span> 元素则是编译指令。             如果设置了 name 属性，<span class="hljs-keyword">meta</span> 元素提供的是文档级别（document-level）的元数据，应用于整个页面。            例如：robots，author，<span class="hljs-keyword">Copyright</span>，description，keywords             43.link图标 &lt;link rel=<span class="hljs-string">&quot;icon&quot;</span> href=<span class="hljs-string">&quot;https:;;;;&quot;</span> /&gt; 也可以直接将该favicon.ico直接置于根目录下，不需要使用link来引入，因为大部分浏览器都可以识别   44.CSS样式的字符编码 开发中推荐在CSS的开头编写@charset指定编码：@import <span class="hljs-string">&quot;utf-8&quot;</span> 45.全局属性data-* data设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到；通常用于HTML和JavaScript数据之间的传递；46.<span class="hljs-string">&quot;&quot;</span>==null <span class="hljs-comment">//false</span>null和undefined不能转换成任何数据类型进行比较47.<span class="hljs-keyword">const</span> obj=&#123;[Symbol.toPrimitive]()&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span>&#125;&#125;48.转换成boolean的方式Boolean(a)!!a49.switch case 是严格匹配===，还要防止case穿透50.npxnpx 是 npm v5.2.0 引入的一条命令（ npx ），是一个 npm 包执行器。我们可以使用 npx 来执行各种命令。主要有以下特点：临时安装可执行依赖包，不用全局安装，不用担心长期的污染。可以执行依赖包中的命令，安装完成自动运行。自动加载 node_modules 中依赖包，不用指定 <span class="hljs-variable">$PATH</span> 。可以指定 node 版本、命令的版本，解决了不同项目使用不同npx 执行流程如下：到 node_modules/.bin 路径检查对应的命令是否存在，找到之后执行；没有找到，就去环境变量 <span class="hljs-variable">$PATH</span> 里面，检查对应命令是否存在，找到之后执行;还是没有找到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。51.函数默认的返回值是undefined52.递归53.斐波那契数列function fibonacci(<span class="hljs-keyword">n</span>)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">n</span>===1||<span class="hljs-keyword">n</span>===2) <span class="hljs-keyword">return</span> 1    <span class="hljs-keyword">return</span> fibonacci(<span class="hljs-keyword">n</span>-1)+fibonacci(<span class="hljs-keyword">n</span>-2)  &#125;54.立即执行函数1.会立即执行2.函数有独立的作用域，可以避免外界访问或者修改内部的变量，3.可以有参数和返回值4.匿名函数多种写法(function()&#123;&#125;)()            <span class="hljs-comment">// 匿名函数多种写法</span>            (function (fn) &#123;              console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;立即执行函数&quot;</span>);            &#125;)();            <span class="hljs-comment">// + - ！都可以，但是不要这样用</span>            +(function foo() &#123;              console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;立即执行函数&quot;</span>);            &#125;)();5.应用：。1.解决命名冲突的问题，防止全局变量的命名冲突2.<span class="hljs-keyword">const</span> btnRtm1 = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = 0; i &lt; btnRtm.length; i++) &#123;  <span class="hljs-keyword">var</span> btn = btnRtm[i];  (function (<span class="hljs-keyword">m</span>) &#123;    btn.onclick = function () &#123;      console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">m</span>);    &#125;;  &#125;)(i);&#125;<span class="hljs-comment">// 打印 4 4 4 4 .....</span><span class="hljs-comment">// 立即执行函数可以解决上述问题还有for循环中有异步代码例如setTimeout，也可以用let解决</span><span class="hljs-comment">// 因为在如下代码中，但执行onclick执行的时候，此时for循环已经执行完，i已经变成btnRtm.length 所以执行代码永远是4 4 4 ，而使用立即执行函数，会每次将i作为参数传入立即执行函数中，尽管i执行完之后已经变成4，但是m存储这0 1 2 3 </span><span class="hljs-keyword">const</span> btnRtm = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = 0; i &lt; btnRtm.length; i++) &#123;  <span class="hljs-keyword">var</span> btn = btnRtm[i];  (function (<span class="hljs-keyword">m</span>) &#123;    btn.onclick = function () &#123;      console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">m</span>);    &#125;;  &#125;)(i);&#125;<span class="hljs-comment">// 打印 1 2 3 4....</span><span class="hljs-keyword">const</span> btnRtm3 = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);<span class="hljs-keyword">for</span> (let i = 0; i &lt; btnRtm.length; i++) &#123;  <span class="hljs-keyword">var</span> btn = btnRtm[i];  btn.onclick = function () &#123;    console.<span class="hljs-built_in">log</span>(i);  &#125;;&#125;<span class="hljs-comment">// 打印1 2 3 4 .....</span>55.js代码规范56.Object的key是字符串57.Object可以使用delete来删除属性，Object.name/Object[<span class="hljs-string">&quot;name&quot;</span>]来获取，或者修改属性，obj[name]是计算属性，name是一个变量58.Object 遍历可以使用forin,或者Object.keys()   59.栈内存和堆内存原始数据类型是在栈内存引用类型实在堆内存60.包装类型，   当有包装类型的原始数据类型可以调用方法，是因为js引擎会将原始类型转换成包装类调用对应的方法   123..<span class="hljs-keyword">toString</span>(2)<span class="hljs-comment">//转换成二进制</span>   toFixed(2)保留两位小数。是四舍五入   parseInt===Number.parseInt     String类   length   str[0]   charAt(0)<span class="hljs-comment">//字符位置</span>   <span class="hljs-keyword">for</span>   <span class="hljs-keyword">for</span>...of   <span class="hljs-keyword">for</span>...<span class="hljs-keyword">in</span>   字符串是不可变的   例如：<span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;name&quot;</span>; str[0] = <span class="hljs-string">&quot;v&quot;</span>; console.<span class="hljs-built_in">log</span>(str);<span class="hljs-comment">//name</span>  <span class="hljs-keyword">var</span> str = str.toUpperCase();console.<span class="hljs-built_in">log</span>(str);<span class="hljs-comment">//这是新的字符串，不是原来的</span>str.indexOf(searchString,fromIndex)<span class="hljs-comment">//返回值是索引值</span>str.includes()str.startsWidth(<span class="hljs-string">&quot;1&quot;</span>)<span class="hljs-comment">//是否以1开头</span>str.endsWidth()str.<span class="hljs-keyword">replace</span>()str.slice()str.substring()str.<span class="hljs-built_in">substr</span>()字符串拼接+，cocat()<span class="hljs-built_in">trim</span>()<span class="hljs-keyword">split</span>()<span class="hljs-keyword">replace</span>()替换，是纯函数61.Arraysplice()<span class="hljs-comment">//添加，删除，替换</span>poppushshiftunshiftarr.length可以获得数组的长度，修改数组的长度，删除数组如果arr.length为6arr.length=2<span class="hljs-comment">//可以删除剩余的元素</span>arr.length=0可以删除所有元素arr.length=8<span class="hljs-comment">//可以扩容</span>arr.slice()arr.join()arr.concat()arr.indexOf()arr.find(arr.find(callback[, thisArg]) callback(element,index,array) <span class="hljs-comment">//会返回匹配到的元素，匹配到多个的时候会返回第一个   find 方法不会改变数组</span>arr.findIndex( )<span class="hljs-comment">//实现find</span>Array.prototype.myFind = function (callback, thisArg) &#123;  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;    <span class="hljs-keyword">if</span> (callback.call(thisArg, this[i], i, this)) &#123;      <span class="hljs-keyword">return</span> this[i];    &#125;  &#125;&#125;;<span class="hljs-comment">//实现forEach</span>Array.prototype.MyForEach = function (callback, thisArg) &#123;  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;    callback.apply(thisArg, [this[i], i, this]);  &#125;&#125;;includes()arr.<span class="hljs-keyword">sort</span>()<span class="hljs-comment">// 默认是降序</span>arr.<span class="hljs-keyword">sort</span>((item1, item2) =&gt; &#123;  <span class="hljs-keyword">return</span> item1.age - item2.age;&#125;);console.<span class="hljs-built_in">log</span>(arr);<span class="hljs-comment">// 升序</span>arr.<span class="hljs-keyword">sort</span>((item1, item2) =&gt; &#123;  <span class="hljs-keyword">return</span> item2.age - item1.age;&#125;);console.<span class="hljs-built_in">log</span>(arr);arr.<span class="hljs-built_in">reverse</span>()arr.filter()Array.prototype.myfilter = function (callback, thisArg) &#123;  let newArr = [];  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;    <span class="hljs-keyword">if</span> (callback.call(thisArg, this[i], i, this)) &#123;      newArr.push(this[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> newArr;&#125;;arr.map()arr.reduce()Date类型new <span class="hljs-built_in">Date</span>()Date.now()<span class="hljs-comment">//当前事件的时间戳</span>date.getTime()<span class="hljs-comment">//将时间转换成时间戳</span>date.valueOf()<span class="hljs-comment">//也是一样</span>+date<span class="hljs-comment">//也可以</span>将字符串转换成时间戳<span class="hljs-keyword">var</span> dateString = <span class="hljs-string">&quot;2020-5-15&quot;</span>;console.<span class="hljs-built_in">log</span>(new <span class="hljs-built_in">Date</span>(dateString).getTime());console.<span class="hljs-built_in">log</span>(Date.<span class="hljs-keyword">parse</span>(dateString));==================================================================================Dom62.所有节点都继承自EventTarget63.document对象-可以获得整个网页node节点<span class="hljs-keyword">var</span> html=document.documnetElement<span class="hljs-keyword">var</span> body=documnet.bodybody,html,body都是documnet的属性获取所有节点的导航 <span class="hljs-keyword">var</span> bodyEl=document.body获取所有子节点 bodyEl.childNodes  换行符也属于text节点，注释是comment节点获取下一个兄弟节点 bodyEl.nextSibling前兄第节点 preSibling</code></pre></div><p>打印body的子节点</p><p><img src="https://img1.imgtp.com/2022/08/14/ehewKeMN.png" alt="屏幕截图 2022-05-18 100006.png"></p><p><img src="https://img1.imgtp.com/2022/08/14/B3g8Atxi.png" alt="屏幕截图 2022-05-18 100042.png"></p><div class="code-wrapper"><pre><code class="hljs stata">64.获取子元素bodyEl.children65.获取第一个子节点  bodyEl.firstElementChild    bodyEl.children[0]  bodyEl.nextElementSibling66.Document和Element的关系   没有关系。document.body,body是他的属性，不是继承类，body:document.querySelectAll(<span class="hljs-string">&quot;body&quot;</span>) ,所以Documnet和Element不是继承的关系，ELment是body的值67.<span class="hljs-keyword">table</span>和<span class="hljs-keyword">form</span>之间的导航68.document.getElementById(<span class="hljs-string">&quot;&quot;</span>)   documnet.querySelector(<span class="hljs-string">&quot;&quot;</span>)   document.querySlectorAll(<span class="hljs-string">&quot;&quot;</span>)   document.getElementsByName(<span class="hljs-string">&quot;&quot;</span>)   document.getElementsByTagName(<span class="hljs-string">&quot;&quot;</span>)   document.getElementsByClassName(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//这3个是实时的</span>69.NodeList是类数组对象，但是可以用<span class="hljs-keyword">forEach</span>,可以用Array.from()转换成array70.节点类型判断通过childNodes获取的节点判断节点类型用nodeType属性 1.元素节点 3.文本 8，注释节点71.nodeName获取节点名称，tagName元素名72.data用于非元素节点获取数据 innerHTML 获取元素 textContent获取文本设置的时候，innerHTML和innerContent都可以设置文本，innerContent设置元素不会被解析为html元素，会当作普通文本innerHTML 将会删除所有该元素的后代并以给出的 htmlString 替代不是追加73.outerHTML会获取本身及其子元素74.常见全局属性 id style title <span class="hljs-keyword">class</span> hidden:相当于设置<span class="hljs-keyword">display</span>:none<span class="hljs-keyword">on</span>+事件75.attributehtml定义的是标准attribute自定义的属性是非标准attribute所有attribute都支持的方法element.hasAttribute(<span class="hljs-keyword">e</span>)element.getAttribure(<span class="hljs-keyword">e</span>)element.setAttribute(<span class="hljs-keyword">e</span>)element.removeAttribute(<span class="hljs-keyword">e</span>)element.attributes-&gt;like array这些对大小写不敏感，而且返回值都是string76.property对象中的属性称为property元素中的属性称为attribute标准的attribute中在对应的对象模型中都有对用的propertyproperty和attribute会相互影响使用点语法也可以获得元素的属性77.className和classListclassList是可迭代对象78.style在js中要使用驼峰多个样式可以使用style.cssText=<span class="hljs-string">&quot;&quot;</span>这个不用写驼峰，但是会覆盖，不推荐78.style的读取getComputedStyle()，ele.style只能读取内联样式，就是直接在元素上定义的样式，widow.getComputedStyle(ele,[pseudoElt])可以读取所有的css属性，包括外部样式，但是getComputedStyle是只读属性79.data-*80.<span class="hljs-keyword">var</span> el=document.createElement(<span class="hljs-string">&quot;element&quot;</span>)<span class="hljs-comment">//创建元素</span>el.className=<span class="hljs-string">&quot;&quot;</span>el.classList.add(<span class="hljs-string">&quot;&quot;</span>)boxel.<span class="hljs-keyword">append</span>(el)<span class="hljs-comment">//向父元素插入创建的元素，默认是插入最后</span>boxel.prepend(el)<span class="hljs-comment">//添加到父元素的里面的最前面</span>boxel.before(el)<span class="hljs-comment">//添加到元素的前面</span>boxel.after(el)<span class="hljs-comment">//添加到元素后面</span>boxel.replacewith(...node|string)<span class="hljs-comment">//替换元素</span>appendChild,insertbefore这些方法比较旧了81.el.remove()<span class="hljs-comment">//将自己移除</span>82.克隆<span class="hljs-keyword">var</span> newEl=el.cloneNode()<span class="hljs-comment">//默认是不会克隆子节点cloneNode(true)会克隆子节点</span>83.获取元素的宽高 ele.width ele.height84.clientWidth:元素content+padding(不包含滚动条)clientTop:border-top的宽度。clientLeftoffsetWidth:元素的完整宽度content+border+paddingoffsetLeft 距离父元素左边的距离 offsetTopscrollHeight 元素可滚动的高度scrollTop 滚动条滚动的距离85.<span class="hljs-keyword">window</span>的大小和滚动   <span class="hljs-keyword">window</span>.outerWidth<span class="hljs-comment">//</span>   <span class="hljs-keyword">window</span>.innerWidth<span class="hljs-comment">//窗口的宽度，不包括调试窗口和工具栏</span>   document.doeumnetElement.offsetWidth document.doeumnetElement.offsetHeight   <span class="hljs-keyword">window</span>.scrollX  获取x轴的滚动位置 <span class="hljs-keyword">window</span>.scrollY Y轴的滚动位置  也可以用别名pagexOffset  pageYOffset   设置滚动的位置 <span class="hljs-keyword">window</span>.scrollBy(x,y)<span class="hljs-comment">//在原来的位置基础上叠加滚动的位置</span>   <span class="hljs-keyword">window</span>.scrollTo(x,y)<span class="hljs-comment">//滚动到绝对的位置，到了位置不会变</span>   <span class="hljs-keyword">window</span>.onscroll<span class="hljs-comment">//监听滚动</span>   86.事件<span class="hljs-keyword">on</span>+eventele.addEventListener(<span class="hljs-string">&quot;event&quot;</span>,callback)87.事件流事件冒泡事件捕获捕获阶段-》目标阶段-》冒泡阶段88.event常见属性方法event.<span class="hljs-keyword">type</span>:事件类型event.target:目标元素event.currentTarget:绑定事件的元素event.offsetXevent.clientXevent.pageXevent.screenXtarget和currentTarget的区别target事件发生的对象，currentTarget是事件绑定的对象，如果如果绑定事件的元素和触发事件的元素相同时，target===currentTargetevent.preventDefault()event.propagetion()<span class="hljs-keyword">on</span>+event中普通函数中this指向绑定事件的元素。addEentListener()也是一样89.EventTarget类所有节点，元素都继承自eventtarget，<span class="hljs-keyword">window</span>也是eventTarget.removeEventListener(event,callbackName,)eventTarget.dispatchEvent()90.事件委托91.import * from 是否包含export defaultexport &#123;&#125;和export <span class="hljs-keyword">const</span> a ,export <span class="hljs-keyword">const</span> b有区别吗92.&lt;div id=<span class="hljs-string">&quot;box&quot;</span>&gt;&lt;/div&gt;box.click()<span class="hljs-comment">//如果是id，也可以这样写但是不推荐</span>92.常见的鼠标事件onclick <span class="hljs-comment">//只能接受event作为唯一的参数，且不用再调用的时候写</span>oncontextmenuonmousedownonmouseuponmousemove93.mouseover和mouseenter的区别mouseenter和mouseleave不支持冒泡进入子元素依然属于该元素只会触发子元素的mouseenter，父元素没反应mouseover和mouseout支持冒泡94.键盘事件onkeydownonkeypressonkeyupevent.code event.key95.onfocus和onblur96.oninput和onchange99.表单事件 onsubmit onreset100.onload和DOMContentLoaded101.onresize102.定时器setTimeout和setInterval是<span class="hljs-keyword">window</span>的方法103.ontransitioned监听动画的结束后调用104.<span class="hljs-keyword">tab</span>切换中切换.active的方法1.<span class="hljs-keyword">for</span>循环2.使用documnet.queryslector(<span class="hljs-string">&quot;.active&quot;</span>)修改3.使用在外面进行变量记录105.BOM浏览器对象模型106.node:<span class="hljs-keyword">global</span>==lobalThis<span class="hljs-keyword">window</span>:<span class="hljs-keyword">window</span>==globalThis放到<span class="hljs-keyword">window</span>的属性全局都可访问用<span class="hljs-keyword">var</span>申明的全局对象都放到<span class="hljs-keyword">window</span>对像中<span class="hljs-keyword">var</span> openWin=<span class="hljs-keyword">window</span>.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//打开网址</span><span class="hljs-keyword">window</span>.<span class="hljs-keyword">close</span>()<span class="hljs-comment">//只能关闭通过open()打开的新的窗口</span>107.<span class="hljs-keyword">window</span>常见事件<span class="hljs-keyword">window</span>.onfocus<span class="hljs-keyword">window</span>.onblur<span class="hljs-keyword">window</span>.onhashchange108.location对象属性，用于表示<span class="hljs-keyword">window</span>当前连接url信息location.href<span class="hljs-comment">//完整url</span><span class="hljs-comment">//url信息</span>location.hostnamelocation.hostloaction.protocollocation.portlocation.pathnamelocation.hashloacation.<span class="hljs-keyword">search</span><span class="hljs-comment">//location方法</span>loacation.assign()<span class="hljs-comment">//打开新的网页，是加入历史记录站，可以返回</span>location.<span class="hljs-keyword">replace</span>()<span class="hljs-comment">//替代当前url,不可以返回</span>loaction.reload()<span class="hljs-comment">//重新加载</span>109.URLSearchParams<span class="hljs-keyword">var</span> searchParams=new URLSearchParams(str)<span class="hljs-built_in">get</span>(&quot;name“)<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;zzzz&quot;</span>)has()<span class="hljs-keyword">set</span>()URLSearchParams可以使用<span class="hljs-keyword">for</span>...of中文使用encodeURLComponment和decodeURLComponment进行编解码<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] of searchParams) &#123;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] of searchParams.entries()) &#123;&#125;110.history<span class="hljs-comment">//属性</span>history,lengthhistory.state<span class="hljs-comment">//修改history</span>history.pushState(&#123;name:<span class="hljs-string">&quot;mike&quot;</span>,age:18&#125;)hsitory.back()history.forword()history.go(-2)replacestate()111.json<span class="hljs-keyword">var</span> item=JSON.stringfy(item)<span class="hljs-keyword">var</span> item=JSON.<span class="hljs-keyword">parse</span>(item)json的方法还可以实现深拷贝<span class="hljs-keyword">var</span> obj=JSON.<span class="hljs-keyword">parse</span>(JSON.strigfy(obj1))112.protobuf113.&amp;gt; &amp;lt;114.&lt;button onclick=<span class="hljs-string">&quot;add()&quot;</span>&gt;按钮&lt;/button&gt;<span class="hljs-comment">//再元素上事件的写法</span>115.<span class="hljs-comment">/* 设置图片水平方向和垂直方向上自动居中，随着浏览器大小的变化 */</span>.img_center&#123;  position: relative;  transform: <span class="hljs-keyword">translate</span>(-50%,-%50);  left: 50%;  top:50%;&#125;</code></pre></div><p>116.</p><p><img src="https://img1.imgtp.com/2022/08/14/lwe19xZA.png" alt="屏幕截图 2022-05-25 175414.png"></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">117.</span><span class="hljs-keyword">this</span>的指向<span class="hljs-number">1.</span><span class="hljs-keyword">this</span>的指向是由函数调用执行的时候决定的<span class="hljs-number">2.</span><span class="hljs-keyword">this</span>的绑定分为：默认绑定：独立函数调用<span class="hljs-keyword">this</span>是指向window,例如fn()隐式绑定：对象中<span class="hljs-keyword">this</span>的指向是指向调用的对象，例如obj.fn()显示绑定:通过call,apply,bind来进行显示绑定下，<span class="hljs-keyword">this</span>指向绑定的对象new的绑定：通过new创建的对象，<span class="hljs-keyword">this</span>会指向新创建的对象<span class="hljs-number">3.</span><span class="hljs-keyword">this</span>指向的优先级：new&gt;显示绑定&gt;隐式绑定&gt;默认绑定<span class="hljs-number">4.</span>箭头函数是没有<span class="hljs-keyword">this</span>,arguments，是由上层函数作用域来决定，一层一层作用域找注意：<span class="hljs-keyword">var</span> name=<span class="hljs-string">&quot;mike&quot;</span><span class="hljs-keyword">var</span> obj=&#123;foo()&#123;<span class="hljs-keyword">return</span> ()=&gt;&#123;console.log(<span class="hljs-keyword">this</span>.name)&#125;&#125;&#125;<span class="hljs-comment">//this会先去foo中去找，找不到就去全局作用域，对象中没有作用域</span>不可以使用显示绑定改变<span class="hljs-keyword">this</span>的指向<span class="hljs-number">5.</span>显示绑定中如果指向的是一个基本数据类型，如果有包装类型则转换成包装类<span class="hljs-number">6.</span>setTimeout中的<span class="hljs-keyword">this</span>默认指向window<span class="hljs-number">7.</span>forEach中<span class="hljs-keyword">this</span>默认指向window，可以通过第二个参数修改<span class="hljs-number">8.</span>事件绑定中<span class="hljs-keyword">this</span>指向绑定的元素<span class="hljs-number">9.</span>new不可以和apply和call一起使用<span class="hljs-number">10.</span>bind的优先级高于call/apply<span class="hljs-number">11.</span>new的优先级高于bind<span class="hljs-number">12.</span>间接函数引用：<span class="hljs-number">1.</span>(obj1.foo=obj2.foo)()这样直接调用，<span class="hljs-keyword">this</span>是默认绑定指向window<span class="hljs-number">2.</span>(b=person.sauName)()   <span class="hljs-comment">//window</span><span class="hljs-number">13.</span>foo.apply(<span class="hljs-literal">null</span>)/foo.apply(undefined)指向window<span class="hljs-number">14.</span>箭头函数可以替代<span class="hljs-keyword">var</span> _this=<span class="hljs-keyword">this</span>来替代，可以获得上层作用域<span class="hljs-number">118.</span> Array.prototype.slice 来将一个类似于数组的对象（array-like <span class="hljs-keyword">object</span>）转换成一个真正的数组，Aaary.prototye.slice.apply()/bind()<span class="hljs-number">119.</span>html解析过程中，遇到css文件会下载，但是不会阻止html的解析，但会阻塞render的渲染过程<span class="hljs-number">120.</span>回流和重绘<span class="hljs-number">121.</span>scriptdefer js的下载和执行不阻塞Dom tree的构建defer代码执行的时候Dom构建完成，defer会在DomContentLoad以后执行多个defer顺序执行defer推荐放在head中defer仅适用于外部脚本，对script的内容会忽略async 多个async不能保证顺序执行，不会组设Dom渲染。不能保证DOMContentLoaded之前或者之后执行行async用于独立脚本，没有外部依赖<span class="hljs-number">122.</span>函数的执行是在函数执行上下文中执行<span class="hljs-number">123.</span>函数的作用域链再函数创建时就确定了。每个执行上下文都有自己的作用域链</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/hbsvpJ1A.png" alt="屏幕截图 2022-05-29 114030.png"></p><p>当查找变量的时候，函数首先会在local中寻找，找不到再去上层作用作用域寻找，而这个函数的上层作用域是Window</p><p><img src="https://img1.imgtp.com/2022/08/14/YJJTxHz8.png" alt="屏幕截图 2022-05-29 120154.png"></p><p>124.垃圾回收器</p><p>​        1..引用计数</p><p>​                    当一个对象有一个引用指向它时，那么这个对象的引用就+1</p><p>​                    当一个对象的引用为0时，这个对象就可以销毁掉</p><p>​                    这个算法有一个回答的弊端就是会产生循环引用</p><p>​        2.标记清除</p><p>​        3.标记整理</p><p>​        4.分代收集</p><p>​        5.增量收集</p><p>​        6.闲时收集</p><div class="code-wrapper"><pre><code class="hljs 130">125.闭包1.狭义：函数引用外层函数的自由变量就是闭包。2.通过返回一个函数，外部可以通过这个函数访问这个函数所在作用域链的变量，闭包可以突破作用域链126.GUI的渲染和js的执行是在同一个线程，是互斥的127.foo.name,获取函数名foo.length//获取行参个数，不会把剩余参数和默认参数计算在内，arguments//类数组对象，可以通过下标获取值，有length属性，是可迭代对象，但是本身不可以使用数组的方法，可以通过Array.prototype.map.call(arguments)来使用argument转array1.for循环，将argument一个个放到数组中2.Array.from(argumsnets)3.[...arguments]4.var arr=Array.prototype.slice.call/apply(arguments)//会截取整段，并返回新的数组或者var arr=[].slice.call/apply(arguments)箭头函数没有argments,会去上层作用域去找arguments128.剩余参数   剩余参数必须放到最后129.剩余参数和argument的区别剩余参数是数组，可以使用所有数组方法，arguments是类数组剩余参数只包含没有对应形参的实参，arguments包含所有参数130.纯函数相同的输入产生相同的输出，不会产生副作用不依赖外部变量确定输出不能修改外部变量作用：只是单纯的实现自己的业务，不需要关注外部的数据变化131.函数柯里化就是把接受多个函数的函数变成返回接受单一参数的函数var foo=x=&gt;y=&gt;z=&gt;console.log(x+y+z)shiyo132.async默认会返回promiseasync的返回值会被promise包裹，相当于Promise.resolve()await 后面是一个promsie,则会返回Promise.resolve(res)的值如果不是promise，则用Promise.resolve(res)包裹await 使用trycatch捕获异常133.封装自动转化成柯里化函数134.组合函数组合函数的封装135.Function.prototype.name   Function.prototype.length Function.prototype.displayName136.with(obj)&#123;console.log(message)//扩展一个语句的作用域链，它首先会去obj里面去找，找不到再去上层作用域找，但是不推荐使用&#125;137.eval()138.严格模式开启严格模式的方式class和module会自动开启严格模式严格模式的限制1.无法意外创建全局变量2.引起静默模式失败3.不能用with4.this默认指向undefined,this不会装换成包装类139.Object.defineProperty(obj,prop.descriptor)属性描述符的分类1.数据属性描述符：configurable:表示这个属性是否可删除,默认值是false，使用delete不嫩删除，如果设置为false,则不可以配置了，后续其他属性描述符也不可以使用了。就是Configurable:false,后续不可以对这个属性使用Object.defineProperty配置。enumerable:是否可以枚举属性，false:forin,Object.keys()这些都不可以美剧，默认是truewritable:是否可以写入，默认是可以写入，设置为false是只读属性value:&quot;mike&quot;,设置属性值如果使用字面量创建对象，则所有属性描述符都是true,object.defineProperty()设置的属性的value的优先级会比字面量创建的属性设置的值高2.存取属性描述符getsetwiritable,value和get,set不可以同时使用140.Object.defineProperties()//同时设置多个属性描述符141.Object.getOwnPropertyDescriptor(obj, &quot;name1&quot;)//获取某个属性描述符142.Object.getOwnPropertyDescriptors(obj)//获取所有属性描述符143.Object.preventExtensions(obj);//不允许扩展属性144.object.seal(obj)//密封对象，不允许配置和删除属性，增加新的属性145.Object.freeze(obj)//不能修该现有属性，也不能增加新的属性146.原型和原型链__proto__是浏览器加，非标准的，要看各个浏览器如何实现，建议使用Object.getPrototypeOf(obj)来获取对象的原型__proto__隐式原型prototype显式原型所有的对象都有隐式原型，函数有隐式原型和显示原型当对象获取值的时候p1.address如果实例对象没没有这个属性则会到他的原型练上去寻找当对象属性赋值的时候，如果该属性不存在则会在当前对象中新建一个属性赋值，不会修改原型链上的属性的值p1.address=&quot;us&quot;//这样不会对原型链上的该属性进行修改如果要对原型的属性进行修改：Person.prototype.address=&quot;japan&quot;Person.prototype=&#123;message:&quot;章&quot;,info:&#123;&#125;,eating:function()&#123;&#125;,constructor:Person&#125;//修改Person的显示原型指向新的对象p1.__proto_===Object.prototypeconstructor应该是不可以枚举的，要用Object.deineProperty()来修改定义原型链：实例对象在查找某个属性的时候，他先去自己对象寻找，然后再去原型链里面去找，直到找到null为止147.面向对象的特性:封装，继承，多态148.使用new关键字创建对象的过程1.创建一个空对象2.让这个对象的[[prototype]]属性指向该构造函数的prototype对象3.让构造函数的中的this指向新创建的对象4.执行该构造函数5.如果构造函数没有返回一个非空对象，则返回新创建出来的对象149.原型链的继承1.Student.prototype=Person.prototype//这种继承虽然可以继承到Person的方法，但是添加student的方法的时候，会添加到Person原型上，对Person和Student都会有影响2.原型链继承student.prototype=new Person()//改善上面一种方法，不会对Person.prototype上的方法进行干扰但是，如果有和Person相同的属性的时候例如function Student(age,gender,name,weight)&#123;this.age=age;this.gender=gender;this.name=name;this.weight=weigth&#125;age,gender属性在pERson里面也有，这样会有代码重复的问题，但是可以获取到自己的age,gender如果不写，调用的时候是获取到Person的age和gender,多个实例共享相同的属性了3.借用构造函数继承  function Student(age,gender,name,weight)&#123;  Person.call(this,age,gender)  this.name=name;this.weight=weigth  &#125;  使用这个方法可以实现属性的继承  将2，3方法结合起来就是组合继承  student.prototype=new Person(age,gender)//继承父类的方法   function Student(age,gender,name,weight)&#123;  Person.call(this,age,gender)//这样没有调用父类的constructor  this.name=name;this.weight=weigth  &#125;  缺点：new student的时候构造函数会调两次，一次Person,一次student，拥有两份父类属性，父类的静态属性和静态方法也没有继承  4.寄生组合继承  function Student(age,gender,name,weight)&#123;  Person.call(this,age,gender)  this.name=name;this.weight=weigth  &#125;  inhert(Student,Person)  Object.assign(Student, Person);//继承静态属性和方法(或者称为类方法或者类属性)150.原型式继承函数// 使用这个方法来处理Object.create()的兼容性问题        function createObject(o) &#123;          function F() &#123;&#125;          F.prototype = o;          return new F();        &#125;        // 封装工具函数实现继承        function inhert(Subtype, Supertype) &#123;        //Subtype.prototype.__proto__=Supertype.prototype        //Object.setPrototypeOf(Subtype.prototype,Supertype.prototype)          // Subtype.prototype = createObject(Supertype.prototype);          Subtype.prototype = Object.create(Supertype.prototype);//Object.create()不会调用constructor          Object.defineProperty(Subtype, &quot;constructor&quot;, &#123;            configurable: false,            enumerable: false,            value: Subtype,            writable: true,          &#125;);        &#125;    //对象之间的继承  function object(o)&#123;  var obj=&#123;&#125;  obj.__proto__=o.prototype//Object,setPrototypeOf(obj,o.prototype)  return obj  &#125;151.Object是所有类的父类152.obj.hasOwnProperty()、//判断是否在自己身上&quot;name&quot; in obj//判断属性是否在obj的里面或者原型链上for in 遍历原型链可枚举属性和方法instanceOfPerson.protytype.isPrototypeOf(stu)//判断实例是否在莫格原型链上，判断对象之间的继承153.对象具备__proto__属性。函数有__proto__和prototype属性154.Person.run()//这个调用的是类方法，protoytype上面的方法是实例方法155.class定义类class会有默认的constructorclass是的构造函数、原型链的语法糖156.对象中访问器的写法var obj = &#123;  name: &quot;mike&quot;,&#125;;//对象访问器的写法一Object.defineProperty(obj, &quot;name&quot;, &#123;  configurable: true,  enumerable: true,  get() &#123;    return obj.name;  &#125;,  set(value) &#123;    obj.name = value;  &#125;,&#125;);//对象访问器的写法二var obj2 = &#123;  name: &quot;zhang&quot;,  get getName() &#123;    return this.name;  &#125;,  set setName(value) &#123;    this.name = value;  &#125;,&#125;;//三class Person &#123;  constructor(name) &#123;    this._name = name;  &#125;  get name() &#123;    return this._name;  &#125;  set name(value) &#123;    this._name = value;  &#125;&#125;157.类方法/static方法中的this指向类本身158.class的继承 extend159.面向对象的三大特性：封装，继承，多态多态的条件：1。必须实现继承  2.必须有父类引用指向子类对象  3.js中可以说到处是多态160.对象字面量增强：1.属性的增强var name=&quot;why&quot;var obj=&#123;name&#125;2.方法的增强var obj=&#123;eating()&#123;&#125;&#125;3.计算属性名obj=&#123;[name]:&#125;161.数组的解构和对象的解构const [name1,name2,name3]=arrconst &#123;age,name,color&#125;=objconst [name1,name2,...name3]=arr//将剩下的元素放入name3数组中const [name1,name2,name3=&quot;default&quot;]=arr//设置默认值//对象的解构是没有顺序的，根据Key来进行解构//对象解构的重命名  const &#123;age:age1,name:name1&#125;=obj//重命名为age1,name1 //对象解构默认值默认值 const &#123;age:age1=18,...other&#125;=obj1//可以使用剩余运算符和默认值162.手写apply,call,bind163.词法环境词法环境由环境记录和外部词法环境两部分组成一个执行上下文关联两个环境LexicalEnvironment和VariableEnvirmentLexicalEnvironment用于处理let和constVariableEnvirment用于处理var,function164.https://262.ecma-international.org/8.0/165.let和constlet/const不可以重复声明const声明的是引用类型则可以修改const指向的地址的内部的变量，但不可以修改const的指向let/const不会出现变量提升，必须先声明再使用，否则会出现暂时性死区let/const会提前创建出来，但是不可以被访问，只有赋值的时候才可以访问暂时性死区取决于代码执行的顺序，和定义的位置没有关系var定义的全局变量默认会添加到window上。而let/const不会再window添加任何属性var 会被添加到 object environment record而const /let会被添加到decaretive environment record166.块级作用域let/const/function/class声明是有块级作用域的，foo()//在这之前不可以访问&#123;function foo()&#123;&#125;&#125;foo()//这样可以访问浏览器做了特殊处理，可以让块级作用域里面的函数在块级作用域之后被访问167.立即执行函数会形成闭包，形成自己的作用域168.for(let i=0;i&lt;btnEls.length;i++)&#123;var btnEl=btnEls[i]btnEl.onclick=function()&#123;console.log(`点击了$&#123;i&#125;按钮`)&#125;&#125;//会形成4个词法环境，每个词法环境都会保存着自己的i，function引用外层的词法环境，所以执行完外层词法不会被销毁，当需要i的时候，会往上层寻找，因为当前词法环境中保存着i</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/frDfleO9.png" alt="QQ截图20220606172932.png"></p><p><img src="https://img1.imgtp.com/2022/08/14/3FHLdHM8.png" alt="QQ截图2022060617452911.png"></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">169.</span>模板字符串<span class="hljs-number">1.</span>普通模板字符串<span class="hljs-number">2.</span>标签模板字符串<span class="hljs-number">170</span>,函数默认值<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg1,arg2</span>)&#123;arg1=arg1?<span class="hljs-attr">arg1</span>:<span class="hljs-number">0</span>arg1=arg1||<span class="hljs-number">0</span>arg1=(arg===<span class="hljs-literal">null</span>)||(arg1===<span class="hljs-literal">undefined</span>)?<span class="hljs-number">0</span>:arg1<span class="hljs-comment">//es6</span>arg1=arg1??<span class="hljs-string">&quot;我是默认值&quot;</span>&#125;<span class="hljs-title function_">foo</span>(<span class="hljs-params">arg1,arg2=<span class="hljs-string">&quot;why&quot;</span></span>)&#123;&#125;<span class="hljs-comment">//默认参数最好放后面</span>剩余参数也是放在后面，如果两个都有的话，剩余参数放后面<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">&#123;name,age&#125;=&#123;name=<span class="hljs-string">&quot;why&quot;</span>,age=<span class="hljs-number">18</span>&#125;</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age)<span class="hljs-comment">//对传入的对象进行解构赋值，给默认值</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">&#123;name=<span class="hljs-string">&quot;why&quot;</span>,age=<span class="hljs-number">18</span>&#125;=&#123;&#125;</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age)<span class="hljs-comment">//对象参数的解构赋值，如果传入的参数</span>中没有该值name,age，则给name,age赋值&#125;默认参数不计算在argument内<span class="hljs-number">171.</span>箭头函数没有显示原型，不可以作为构造函数，不能通过<span class="hljs-keyword">new</span>创建<span class="hljs-number">172.</span>展开运算符<span class="hljs-keyword">var</span> obj=&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;why&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;<span class="hljs-title function_">foo</span>(...obj)<span class="hljs-comment">//这样来用是不可以的，因为函数参数必须是可迭代对象</span><span class="hljs-number">173.</span>浅拷贝：就是将对象里面的内容赋值到新的对象里面，如果对象里面还有对象，则只会复制对象的引用就是浅拷贝只会拷贝第一层对象浅拷贝的方法可以使用展开运算符和<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<span class="hljs-number">174.</span>ele.<span class="hljs-title function_">append</span>()和ele.<span class="hljs-title function_">appendChild</span>()的区别append参数可以是node/string appendChild只能是<span class="hljs-title class_">Node</span>,<span class="hljs-title function_">append</span>()没有返回值，appendChild会返回插入值本身，append可以追加多个字符串、node，而appendChild只能加一个节点<span class="hljs-number">175.</span>数值的表示<span class="hljs-number">176.</span><span class="hljs-title class_">Symbol</span><span class="hljs-keyword">const</span> s1=<span class="hljs-title class_">Symbol</span>()<span class="hljs-keyword">const</span> obj=&#123;[s1]:<span class="hljs-string">&quot;aaaa&quot;</span>&#125;<span class="hljs-comment">//对象中key可以是string/Symbol</span>由<span class="hljs-title class_">Symbol</span>()生成是独一无二的<span class="hljs-number">177.</span>set存储任何类型的唯一的值<span class="hljs-keyword">const</span> set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()set.<span class="hljs-title function_">add</span>(dd)set.<span class="hljs-title function_">has</span>(dd)set.<span class="hljs-property">size</span><span class="hljs-comment">//获取元素数量</span>set.<span class="hljs-title function_">delete</span>(value)<span class="hljs-comment">//删除元素</span><span class="hljs-title function_">clear</span>(set)<span class="hljs-comment">//清空</span>set.<span class="hljs-title function_">forEach</span>()<span class="hljs-comment">//可以用于数组的遍历</span>set.<span class="hljs-title function_">keys</span>()set.<span class="hljs-title function_">values</span>()<span class="hljs-comment">//keys()和values的返回值是相同的</span>set.<span class="hljs-title function_">entry</span>()<span class="hljs-comment">//返回值为[value,value]</span>forof数组去重<span class="hljs-keyword">const</span> newArr=<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr))/[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]<span class="hljs-title class_">Set</span>中<span class="hljs-title class_">NaN</span>===<span class="hljs-title class_">NaN</span><span class="hljs-number">178.</span><span class="hljs-title class_">WeakSet</span><span class="hljs-title class_">WeakSet</span>是弱引用，可以被垃圾回收器回收weakSet只能存储对象weakSet对对象都是弱引用的，所以不可以遍历<span class="hljs-title class_">WeakSet</span>中由<span class="hljs-title function_">has</span>(),<span class="hljs-title function_">add</span>(),<span class="hljs-title function_">delete</span>()它和 <span class="hljs-title class_">Set</span> 对象的区别有两点：    与<span class="hljs-title class_">Set</span>相比，<span class="hljs-title class_">WeakSet</span> 只能是对象的集合，而不能是任何类型的任意值。    <span class="hljs-title class_">WeakSet</span>持弱引用：集合中对象的引用为弱引用。 如果没有其他的对<span class="hljs-title class_">WeakSet</span>中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 <span class="hljs-title class_">WeakSet</span> 中没有存储当前对象的列表。 正因为这样，<span class="hljs-title class_">WeakSet</span> 是不可枚举的。</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/EzcYmE14.png" alt="QQ截图20220608150415.png"></p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-number">179.</span><span class="hljs-built_in">Map</span><span class="hljs-keyword">map</span>也是可迭代对象<span class="hljs-keyword">map</span>可以使用任何数据类型作为key,而<span class="hljs-built_in">Object</span>只可以使用string、symbol作为key<span class="hljs-keyword">const</span> <span class="hljs-keyword">map</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<span class="hljs-keyword">map</span>.set(info,<span class="hljs-string">&quot;999&quot;</span>)<span class="hljs-keyword">map</span>.<span class="hljs-keyword">delete</span>(info)<span class="hljs-keyword">map</span>.has(info)clear(<span class="hljs-keyword">map</span>)forEach<span class="hljs-keyword">map</span>.get(info)forof<span class="hljs-number">180.</span><span class="hljs-built_in">Map</span>和<span class="hljs-built_in">Object</span>的区别<span class="hljs-number">181.</span><span class="hljs-built_in">WeakMap</span>key只能是对象，对对象的引用是弱引用，如果没有其他引用引用该对象，他就会被GC回收weakMap的key是不可以枚举的，不可以遍历不能使用forof,forEach进行遍历<span class="hljs-keyword">delete</span>(key)get(key)has(key)set(key,value)weakMap可以解决<span class="hljs-built_in">Map</span>可能导致内存泄漏的问题，因为数组会一值引用每一个key,value参考：https:<span class="hljs-regexp">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap</span><span class="hljs-regexp">182.Array.prototype.includes(item)</span><span class="hljs-regexp">183.Math.pow()/**</span><span class="hljs-regexp">184.Object.values(obj)</span><span class="hljs-regexp">185.Object.keys(obj)</span><span class="hljs-regexp">186.Object。entries(obj)//</span>obj可以是对象，数组，字符串获取的数组和forin遍历的顺序是一致的，但是不会遍历原型链上的属性和方法<span class="hljs-number">187.</span><span class="hljs-built_in">String</span>.prototype.padStart(总长度,填充字符串)<span class="hljs-regexp">//字符串填充 会返回新的字符串</span><span class="hljs-regexp">例如隐藏只显示身份证的部分数字，其余部分填充*</span><span class="hljs-regexp">188.Object.getOwnPropertyDescriptors</span><span class="hljs-regexp">189.Array.prototype.flat(number)//</span>将多维数组扁平化<span class="hljs-number">190.</span><span class="hljs-built_in">Array</span>.prototype.flatMap(callback(currval,index,arr))<span class="hljs-regexp">//相当于先使用map再使用flat(1)进行扁平化</span><span class="hljs-regexp">191.数组扁平化的方法</span><span class="hljs-regexp">192.Object.fromEntries(entries)//</span>把entry转换成Obj将queryString转换成对象</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/cVkjgfjQ.png" alt="QQ截图20220608171027.png"></p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-number">193.</span>空值合并运算符 ??<span class="hljs-number">194.</span>str.trim()/trimStart()/trimRight()<span class="hljs-number">195.</span>可选链操作符  ?.可以替代<span class="hljs-keyword">if</span>(obj.friend&amp;&amp;obj.friend.running)&#123;obj.friend.running()&#125;obj?.friend?.running?.()<span class="hljs-number">196.</span>WeakRef//暂时不建议使用<span class="hljs-number">197.</span>逻辑赋值运算符message=message||&quot;默认值&quot;=&gt;message||=&quot;默认值&quot;message??=&quot;默认值&quot;obj&amp;&amp;obj.friend&amp;&amp;obj.friend.running()<span class="hljs-number">198.</span>const <span class="hljs-built_in">new</span>=str.replaceAll()//替换所有匹配到的字符串  原始字符串保持不变。<span class="hljs-number">199.</span>str.at(<span class="hljs-keyword">index</span>)<span class="hljs-number">200.</span><span class="hljs-keyword">Object</span>.hasOwn(obj,propKey)//可以替代obj.hasOwnProperty(prop),因为hasOwnProperty()可能会被使用者重写const <span class="hljs-keyword">info</span>=<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(<span class="hljs-keyword">null</span>)//这样创建的对下个原型指向<span class="hljs-keyword">null</span><span class="hljs-keyword">info</span>.name=&quot;why&quot;<span class="hljs-keyword">info</span>.hasOwnProperty(<span class="hljs-type">name</span>)//由于原型指向<span class="hljs-keyword">null</span>,所以获取不到hasOwnProperty方法需要使用<span class="hljs-keyword">Object</span>.hasOwn()替代<span class="hljs-number">201.</span><span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>()创建一个新对象，使用现有的对象来提提供新创建对象的__proto__<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(proto,[prppertiesObject])<span class="hljs-number">202.</span><span class="hljs-keyword">Class</span> Person&#123;height=<span class="hljs-number">1.88</span>//在这里写的时候，<span class="hljs-built_in">new</span>创建对象时也会被添加到新的对象里面，再<span class="hljs-keyword">class</span>内部可以通过this来访问constructor(<span class="hljs-type">name</span>,age)&#123;this.name=<span class="hljs-type">name</span>this.age=agethis.address=&quot;广州市&quot;&#125;static &#123;//静态代码块&#125;&#125;<span class="hljs-number">203.</span>proxy<span class="hljs-keyword">Object</span>.defineProperty()的缺点，不可以监听到对象属性的新增和删除操作，新增的属性也没办法监听，只能监听属性，不能监听整个对象</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/EQg1fUBC.png" alt="QQ截图20220609114316.png"></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Proxy</span>是监听整个对象，他有<span class="hljs-number">13</span>个捕获器，这些捕获器可以劫持对象的一些操作用proxy替代obj操作</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/aIkHlWXU.png" alt="QQ截图20220609115247.png"></p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">204.</span><span class="hljs-built_in">Reflect</span>的作用<span class="hljs-built_in">Reflect</span>是为了替代<span class="hljs-built_in">Object</span>中的一些方法</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/KQev7yPJ.png" alt="QQ截图20220609153635.png"></p><p><img src="https://img1.imgtp.com/2022/08/14/0fcGhnc0.png" alt="QQ截图20220609153658.png"></p><p><img src="https://img1.imgtp.com/2022/08/14/MDMfI710.png" alt="QQ截图20220609153711.png"></p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">205</span><span class="hljs-selector-class">.Reflect</span>.construct的作用Reflect<span class="hljs-selector-class">.construct</span>(target, argumentsList<span class="hljs-selector-attr">[, newTarget]</span>)</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/BXFFyjjm.png" alt="QQ截图20220609155310.png"></p><p>​    </p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-number">206</span><span class="hljs-selector-class">.new</span><span class="hljs-selector-class">.target</span>作用<span class="hljs-number">207</span><span class="hljs-selector-class">.promise</span>三种状态：pendingfulfilledrejected状态发生改变，就不可以更改<span class="hljs-built_in">resolve</span>(value)<span class="hljs-comment">//value会作为then方法中的回调函数的参数</span><span class="hljs-number">1</span>.普通值则作为参数直接传过去<span class="hljs-number">2</span>.如果传入的是promise,则由promise的中的·resolve参数决定<span class="hljs-number">3</span><span class="hljs-selector-class">.thenable</span>对象则会执行then方法并且由then方法中的reslove的参数决定<span class="hljs-built_in">then</span>()<span class="hljs-comment">//可以传两个参数，成功的回调和失败的回调</span><span class="hljs-built_in">catch</span>()<span class="hljs-comment">//失败的回调</span><span class="hljs-number">208</span><span class="hljs-selector-class">.Window</span><span class="hljs-selector-class">.getComputedStyle</span>(ele,prop?)和Element<span class="hljs-selector-class">.getBoundingClientRect</span>()的区别getComputedStyle是定义在window上的方法，getBoundingClientRect是Element的方法，getComputedStyle返回值是CSS属性值，而getBoundingClientRect返回的是具体的位置信息</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/OJQOJUb1.png" alt="QQ截图20220611104648.png"></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">209.</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">then</span>()<span class="hljs-comment">//返回值是一个promise,链式调用中，then会等待上一个then的返回值promise的状态来决定</span><span class="hljs-keyword">const</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>)&#125;)promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<span class="hljs-keyword">return</span> res&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)then的返回值<span class="hljs-number">1.</span>普通值则会直接包裹成promise返回<span class="hljs-number">2.</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span> 则有这个promise的状态来决定<span class="hljs-number">3.</span>有thenable方法的对象，则由thenable方法的状态来决定then抛出异常时，就处于reject状态，则会调用后面的<span class="hljs-keyword">catch</span>then <span class="hljs-keyword">return</span> 时处于fulfilledthen没有返回值则不会继续调用then<span class="hljs-number">210.</span><span class="hljs-title class_">Promsie</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">catch</span>()<span class="hljs-keyword">catch</span> 里面调用<span class="hljs-keyword">return</span>的时候默认状态是fuifilled,他的返回值是一个promise和then一样如果向继续链式调用<span class="hljs-keyword">catch</span>，需要抛出异常当promise中调用reject的时候，会调用最近<span class="hljs-keyword">catch</span>没有返回值时不会继续链式调用<span class="hljs-number">211.</span>中断函数的执行<span class="hljs-keyword">return</span><span class="hljs-keyword">throw</span>前两种会直接结束函数的执行<span class="hljs-keyword">yield</span></code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/ws0WolVm.png" alt="QQ截图20220612095542.png"></p><p>212.Promise.prototype.finally(callback)    </p><p>​        无论Promise对象变成fulfilled还是rejected状态，最终都会执行</p><p>​        finally方法的回调函数参数是不接受参数的</p><ol start="213"><li><p>Promise.resolve()相当于new Promsie()并且执行resolve方法。</p><p>就是希望将变量转换成Promise来使用</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&quot;why&quot;</span>)=<span class="hljs-function">=&gt;</span><span class="hljs-keyword">new</span> Promsise(<span class="hljs-function"><span class="hljs-params">(resolve)</span>=&gt;</span>resolve(<span class="hljs-string">&quot;why&quot;</span>))参数和resolve一样</code></pre></div></li><li><p>Promise.reject() reject方法类似于resolve方法，只是会将Promise对象的状态设置为reject状态</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-string">&quot;why&quot;</span>)=&gt;<span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">_</span>,<span class="hljs-params">reject</span>)</span>=&gt;reject(<span class="hljs-string">&quot;why&quot;</span>))<span class="hljs-comment">//_不传可以这样写</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promsie</span>.</span></span>reject无论传什么参数都是rejected</code></pre></div></li><li><p>Promsie.all([])</p><div class="code-wrapper"><pre><code class="hljs arcade">他的作用是将对各promise,放入到数组中执行，<span class="hljs-built_in">all</span>方法的最终状态是由数组中的所有promisek结果决定的，如果Promise所有状态都是fulfilled状态则Pramise.<span class="hljs-built_in">all</span>的状态为fulfilled，并且将所有数组中的promise的返回值做成一个数组返回如果数组中出现一个promise状态为rejected则<span class="hljs-built_in">all</span>的状态也会变成rejected,并将第一个reject的返回值作为参数Promsie.<span class="hljs-built_in">all</span>([p1,p2,p3]).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>res).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>err)</code></pre></div></li><li><p>Promise.allSettled([])</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promsie</span>.</span></span>all<span class="hljs-constructor">Settled([<span class="hljs-params">p1</span>,<span class="hljs-params">p2</span>,<span class="hljs-params">p3</span>])</span>.<span class="hljs-keyword">then</span>(res=&gt;res)<span class="hljs-comment">//状态都是fulfilled,会返回一个[&#123;stattus:fulfilled/rejected,value:&quot;&quot;&#125;]</span></code></pre></div></li><li><p>Promsie.race([])</p><div class="code-wrapper"><pre><code class="hljs cpp">rece的状态由[]中的promise那个先完成的状态来决定的</code></pre></div></li><li><p>Promise.any([])</p></li></ol><div class="code-wrapper"><pre><code class="hljs cpp">只要[]中的promise中的第一个变成fulfilled的状态来决定的，返回值也是这个promise返回值如果所有的promsie状态都是rejected则会变成any的状态会变成reject果所有的Promise都是reject的，那么会报一个AggregateError的错误。</code></pre></div><p>219.迭代器</p><p>220.async函数的执行</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">async</span>函数 没有<span class="hljs-keyword">await</span>的话则和普通的函数没有区别，都是会同步执行返回值如果是普通值则会被<span class="hljs-built_in">Promise</span>.resolve()包裹返回值是promsie时，会有promise的状态来决定返回值是thenable对象，则由thenable的状态来决定<span class="hljs-keyword">async</span>函数的执行函数的执行函数想返回reject状态，调用<span class="hljs-keyword">catch</span>,可以使用返回一个promsie 里面用reject(),thenable也是一样，或者使用<span class="hljs-built_in">Promise</span>.reject()还可以用<span class="hljs-keyword">throw</span> 来抛出异常<span class="hljs-keyword">async</span>的异常不会报错，而是会作为<span class="hljs-built_in">Promise</span>.reject来传递<span class="hljs-keyword">await</span>关键字 只能在<span class="hljs-keyword">async</span>里面使用<span class="hljs-keyword">await</span> 之后的代码相当于Promsie.<span class="hljs-keyword">then</span>(),<span class="hljs-keyword">await</span>要捕获错误需要使用<span class="hljs-keyword">try</span>...<span class="hljs-keyword">catch</span><span class="hljs-keyword">await</span> 后面跟的代码是<span class="hljs-built_in">Promise</span>.resolve包裹，会等待promise的返回值<span class="hljs-keyword">await</span>会阻塞代码的执行，等待promise返回值，<span class="hljs-keyword">await</span>之前都是同步的</code></pre></div><p>221.浏览器的事件循环</p><p>​        宏任务队列(marcotask queue)：</p><div class="code-wrapper"><pre><code class="hljs coffeescript">ajax,<span class="hljs-built_in">setTimeout</span>,<span class="hljs-built_in">setInterval</span>,DOM监听，UI Rendering等</code></pre></div><p>​        微任务队列(microtask queue)</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>的<span class="hljs-keyword">then</span>回调，Mutation Obderver API queueMicrotask <span class="hljs-keyword">async</span> <span class="hljs-keyword">await</span></code></pre></div><p>​    执行宏任务之前，会先检查微任务队列是否为空，如果不为空，先执行微任务</p><p>222.错误处理方案</p><p>​        throw 会中断后面代码的执行</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">throw</span> <span class="hljs-title class_">String</span>/<span class="hljs-built_in">number</span>/<span class="hljs-built_in">boolean</span>/<span class="hljs-title class_">Object</span></code></pre></div><p>​        异常的捕获</p><p>​        try..catch..finally</p><p>223.cookie存储是由浏览器自动做的，携带cookie也是由浏览器做的</p><p>224.Storage</p><p>​        localStorage在页面关闭并重新打开时不会被清除，sessionStroage会被清除</p><p>​        在页面内发生跳转不打开新页面时，sessionStorage和localStorage都会被保留</p><p>​        在页面外发生跳转打开新的页面时，sessionStorage不保存，localStorage会保存</p><p>​        sessionStorage只会在本次会话中存储，不会在新页面中获取</p><p>225.cache工具的封装</p><p>226.正则表达式</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> re1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">REgExp</span>(pattern,<span class="hljs-string">&quot;ig&quot;</span>)<span class="hljs-comment">//new 创建</span><span class="hljs-keyword">const</span> re2=<span class="hljs-regexp">/aaaa/ig</span> <span class="hljs-comment">//字面量写法</span>message.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/abc/ig</span>,<span class="hljs-string">&quot;cba&quot;</span>)message.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/\d+/ig</span>,<span class="hljs-string">&quot;cba&quot;</span>)message.<span class="hljs-title function_">test</span>(<span class="hljs-regexp">/^abc$/ig</span>)<span class="hljs-comment">//返回值是boolean值</span>message.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/abc/ig</span>)<span class="hljs-comment">//返回匹配到的值的数组结合</span>message.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/abc/ig</span>)<span class="hljs-comment">//必须加g,返回值是迭代器</span>message.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/abc/ig</span>)message.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/abc/i</span>)<span class="hljs-comment">//返回索引，没有则返回-1</span>常见修饰符g 匹配全部i 忽略大小写m 多行匹配规则\d digit 一个数字<span class="hljs-number">0</span>-<span class="hljs-number">9</span>\s space 一个空格字符，换行符,\t,\n\w word 一个拉丁字母或者数字，下划线.  匹配任意字符，除了换行符反向类\D 非数字 除\d以外字符 如字母\S 非空格 \W 非单字字符转义/\./ig 对.进行转义[,],\,^,$,.,|,?,*,+,(,),/  常见的需要进行转义<span class="hljs-keyword">const</span> jsfile=<span class="hljs-regexp">/\.jsx?$/</span>  ?表示前面的字符可选集合匹配到多个字符中的其中之一.用[]/[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]/,<span class="hljs-regexp">/[156]/</span><span class="hljs-keyword">const</span> phone=<span class="hljs-regexp">/^1[3-9]\d&#123;9&#125;$/</span> <span class="hljs-comment">//匹配电话号码</span>排除范围[^...]，不匹配括号里面的量词/a&#123;<span class="hljs-number">5</span>&#125;/ 匹配<span class="hljs-number">5</span>个a /a&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;/匹配<span class="hljs-number">3</span>-<span class="hljs-number">5</span>个a缩写+:一个或者多个,&#123;<span class="hljs-number">1</span>,&#125;?:<span class="hljs-number">0</span>或者<span class="hljs-number">1</span>个 &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;*:<span class="hljs-number">0</span>个或者多个 &#123;<span class="hljs-number">0</span>,&#125;<span class="hljs-keyword">const</span> tag=<span class="hljs-regexp">/&lt;\/?[a-z][a-z0-9]*\/?/ig</span>  匹配多个元素标签贪婪模式和惰性模式<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《.+?》/g</span> 惰性模式<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《.+》/g</span> 贪婪模式捕获组<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《(.+?)》/g</span>str.<span class="hljs-title function_">matchAll</span>(name)未学完<span class="hljs-number">227.</span>http 超文本传输协议  默认端口是<span class="hljs-number">80</span>端口，是应用层协议<span class="hljs-number">228.</span><span class="hljs-variable constant_">HTTP</span>组成一次请求包括request和response<span class="hljs-number">229.</span>http版本<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.0</span><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> 添加了持久化连接<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2.0</span><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">3.0</span><span class="hljs-number">230.</span><span class="hljs-variable constant_">HTTP</span>的请求方式<span class="hljs-variable constant_">GET</span><span class="hljs-variable constant_">HEAD</span><span class="hljs-comment">//和get相似,但是没有响应体，例如准备下载一个文件前，先获取文件的大小，再决定是否进行下载</span><span class="hljs-variable constant_">POST</span><span class="hljs-comment">//将实体提交到指定的资源</span><span class="hljs-variable constant_">PUT</span><span class="hljs-comment">//替换所有数据</span><span class="hljs-variable constant_">DELETE</span><span class="hljs-variable constant_">PATCH</span><span class="hljs-comment">//对部分数据进行修改</span><span class="hljs-variable constant_">CONNECT</span><span class="hljs-variable constant_">TRACE</span><span class="hljs-number">231.</span>request headercontent-type是请求携带的数据类型application/x-www-form-urlencoded 表示被编码成以&amp;分隔name=why&amp;age=<span class="hljs-number">18</span>application/json 表示是一种json类型text/plain 表示文本类型application/xmlmultipart/form-data <span class="hljs-comment">//表示文件上传 ，很多浏览器会自动设置</span>content-length 文件长度 不需要设置keep-alive http/<span class="hljs-number">1.1</span> 默认为<span class="hljs-literal">true</span>accept-<span class="hljs-attr">encoding</span>:告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip压缩对应.<span class="hljs-property">gz</span>文件，浏览器会自动解压，这个属性不用配，浏览器会配，在webpack中可以打包成gzip文件<span class="hljs-attr">accept</span>:告诉浏览器，客户端可以接受的文件的格式类型 默认是任何格式都接受user-<span class="hljs-attr">agent</span>:客户端相关的信息<span class="hljs-number">232.</span>http response status<span class="hljs-number">200</span> ok <span class="hljs-number">201</span> create post请求，创建新的资源<span class="hljs-number">301</span> 永久重定向<span class="hljs-number">400</span> bad request 客户端的错误，服务器无法或者不进行处理<span class="hljs-number">401</span> unauthorized 未授权 一般是没有登录的情况下 没有cookie,token或者过期<span class="hljs-number">403</span> forbidden 没有权限<span class="hljs-number">404</span> <span class="hljs-title class_">NOt</span> found 一般是接口不存在，url错误<span class="hljs-number">500</span> 服务器未知错误<span class="hljs-number">503</span> 暂时无法访问<span class="hljs-number">400</span>、<span class="hljs-number">403</span>都是浏览器返回的有些开发所有返回的status都是<span class="hljs-number">200</span>，在数据里面来自定义错误信息<span class="hljs-number">233.</span>xhr<span class="hljs-keyword">const</span> xhr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()xhr.<span class="hljs-property">onload</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//xhr.response   一般使用这个</span><span class="hljs-comment">//xhr.responseText</span><span class="hljs-comment">//xhr.responseXML</span>&#125;xhr.<span class="hljs-property">responseType</span>=<span class="hljs-string">&quot;json&quot;</span><span class="hljs-comment">//默认是text,一般是json</span>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>,url)<span class="hljs-comment">//第一个参数是请求类型，第二个参数是url，第三个参数是是否同步，默认是异步</span><span class="hljs-comment">//设置过期时间</span>xhr.<span class="hljs-property">timeout</span>=<span class="hljs-number">3000</span>xhr.<span class="hljs-property">ontimeout</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;xhr.<span class="hljs-title function_">abort</span>()<span class="hljs-comment">//取消请求</span><span class="hljs-comment">//发送网络请求</span>xhr.<span class="hljs-title function_">send</span>()<span class="hljs-number">234.</span>ajax的封装<span class="hljs-number">235.</span><span class="hljs-title class_">Fetch</span> 返回值是promise文件上传地址<span class="hljs-attr">http</span>:<span class="hljs-comment">//123.207.32.32:1888/02_param/upload</span><span class="hljs-number">236.</span>gitgit add .git commit -m <span class="hljs-string">&quot;提交描述&quot;</span>git pushgit pull origin master <span class="hljs-comment">//从远程的某个分支获取</span>git branch --set-upstream-to=origin/master  <span class="hljs-comment">//设置上游分支就可以只写 git pull了</span>git merge --allow-unrelated-histories  <span class="hljs-comment">//强制合并</span>git statusgit clone url<span class="hljs-comment">//克隆代码</span>push到远程仓库git pushgit push origin masterfetch代码git fetch git fetch origin master获取到代码后默认并没有合并，需要mergegit mergeget merge origin/master也可以使用git pull相当于git fetch+git <span class="hljs-title function_">merge</span>(rebase)链接远程仓库geit remote add origin ....git push origin master <span class="hljs-comment">//第一次图送会推送到main分支  第二次推送会被推送到master</span>git push origin <span class="hljs-attr">master</span>:maingit push origin <span class="hljs-attr">head</span>:main  head默认指向main如果要push master默认要这么写git push origin <span class="hljs-attr">master</span>:main  如果想写git push就要这么写配置git push 指向上游路径master，就是配置好的git branch --set-upstream-to=origin/master调用git push 就会push到master,但是这样每个分支都是push到mastergit config push.<span class="hljs-property">default</span> upstream  [--<span class="hljs-variable language_">global</span>]<span class="hljs-comment">//加上global可以全局使用，否则就是当前项目使用</span>git config push.<span class="hljs-property">default</span> current  <span class="hljs-comment">//这个会先去仓库找有没有和本地相同的分支，如果没有就在远程创建一个新的和本地相同的分支</span>push.<span class="hljs-property">default</span> 默认是simple 就是push相同的分支git tag 打标签git tag v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>git tag -a v1<span class="hljs-number">.0</span><span class="hljs-number">.1</span> -m <span class="hljs-string">&quot;注释&quot;</span>默认情况子git tag 不会push到服务器git push origin v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>  推送到远程git push origin --tags 把所有tag都推送上去git tag -d tagname  <span class="hljs-comment">//删除本地的tag</span>git oush origin&lt;在本地定义的远程的名字，默认是origin&gt; -d或者--<span class="hljs-keyword">delete</span> v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>git checkpout v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span> 跳转到目标tag, 回到tag版本代码 不能再当前tag修改代码，需要根据当前的tag,创建新的分支来修改git cat-file -p 00d2  <span class="hljs-comment">//查看.git/objects/00/d2..... 就可以看到文件的内容</span>git cat-file -t 00d2 <span class="hljs-comment">//查看文件内容</span><span class="hljs-comment">//blod 表示文件还没提交的文件</span><span class="hljs-comment">//commit 表示已经提交</span><span class="hljs-comment">//tag 表示是tag</span></code></pre></div><p>237.Git分支</p><p>创建新的分支其实创建一个新的可移动的指针</p><p>git branch 分支  创建分支</p><p>git checkout 分支 切换分支</p><p>git 怎么直到指向那个分支 也是使用HEAD的指针 </p><p>git checkout 分支  就是将head指针指向它</p><p>先使用 git branch 分支 创建分支 然后再使用 git checkout 分支 将切换分支指针指向该分支</p><p>git checkout -b <newbranchname>   //创建新的分支并且切换分支</p><p> 238.git flow </p><p>在项目开发过程中，首先会创建master主分支用于线上发布，可以打上tag作为版本，如果线上出现bug,则从master开辟分支，进行代码的修复，然后合并到master分支，和develop分支。develop分支用于开发，需要上线时会开辟release分支用于测试，并且修复测试遇到的bug,完成测试后就可以合并到master和develop,如果需要开发新的功能，则需要从develop开辟新分支进行开发</p><p>239.git的远程分支</p><p>git remote add origin url</p><p>git fetch origin main  //把main分支拉取</p><p>git branch –set-upstream-to=origin/main  //设置上游分支</p><p>=========================================================</p><p>get merge//默认合并upstream   合并必须要有共同的祖先</p><p>远程分支是也是一种分支结构：  以 remote/branch式命名的</p><p>240.跟踪远程分支</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支</p><p>如果你愿意的话可以设置其他的跟踪分支，可以通过运行 git checkout –track origin/分支名</p><p> 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支</p><div class="code-wrapper"><pre><code class="hljs vim">git checkout --track <span class="hljs-symbol">&lt;remote&gt;</span>/<span class="hljs-symbol">&lt;branch&gt;</span>  相当于git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/main  跟踪origin/main  并且创建和切换mian分支git checkout <span class="hljs-symbol">&lt;branch&gt;</span>  上面的简写他会先检查远程有没有这个分支，然后在跟踪这个分支，并且在本地创建这个分支，在切换到这个分支</code></pre></div><p>241.git checkout -b  develop</p><p>​        git push origin develop</p><p>如果需要创建一个分支，并且推送到远程，远程也会创建相同的分支</p><p>242.git branch -d  分支     删除本地分支</p><p>243.删除远程分支</p><div class="code-wrapper"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> &lt;branch&gt;</code></pre></div><p>244.查看git log</p><div class="code-wrapper"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--pretty=oneline</span></code></pre></div><p>245 git rebase</p><div class="code-wrapper"><pre><code class="hljs crmsh">git checkout featuregit rebase <span class="hljs-keyword">master</span><span class="hljs-title">git</span> checkout <span class="hljs-keyword">master</span><span class="hljs-title">git</span> merge  feature//永远不要在主分支上rebase</code></pre></div><p>246.git rebase的原理</p><p>247.rebase和merge的区别</p><p>merge会记录git的所有历史，那么分支的历史错综复杂，也会全部记录下来</p><p>rebase用于简化历史记录，将两个分支的历史简化，整个历史更加简洁</p>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
      <category>前端系统课笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue2和vue3的区别(vue2向vue3迁移)(一)</title>
    <link href="/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/"/>
    <url>/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<ol><li><h3 id="vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。"><a href="#vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。" class="headerlink" title="vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。"></a>vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。</h3></li><li><h3 id="vue3中使用Proxy来实现对数据劫持，vue2中使用Object-defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用-set和-delete方法。"><a href="#vue3中使用Proxy来实现对数据劫持，vue2中使用Object-defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用-set和-delete方法。" class="headerlink" title="vue3中使用Proxy来实现对数据劫持，vue2中使用Object.defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用$set和$delete方法。"></a>vue3中使用Proxy来实现对数据劫持，vue2中使用Object.defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用$set和$delete方法。</h3></li><li><h3 id="vue3删除了-set和-off-once-移除了filter-内敛模板等特性"><a href="#vue3删除了-set和-off-once-移除了filter-内敛模板等特性" class="headerlink" title="vue3删除了$set和$off,$once.移除了filter,内敛模板等特性"></a>vue3删除了$set和$off,$once.移除了filter,内敛模板等特性</h3></li><li><h3 id="在编译方面做了优化：生成Block-tree-Slot编译优化，diff算法优"><a href="#在编译方面做了优化：生成Block-tree-Slot编译优化，diff算法优" class="headerlink" title="在编译方面做了优化：生成Block tree,Slot编译优化，diff算法优"></a>在编译方面做了优化：生成Block tree,Slot编译优化，diff算法优</h3></li><li><h3 id="vue3中已经去掉了事件总线，可以使用mitt"><a href="#vue3中已经去掉了事件总线，可以使用mitt" class="headerlink" title="vue3中已经去掉了事件总线，可以使用mitt"></a>vue3中已经去掉了事件总线，可以使用mitt</h3></li><li><h3 id="vue3中增加了componsition-API"><a href="#vue3中增加了componsition-API" class="headerlink" title="vue3中增加了componsition API"></a>vue3中增加了componsition API</h3></li><li><h3 id="vue3中移除了-children"><a href="#vue3中移除了-children" class="headerlink" title="vue3中移除了$children"></a>vue3中移除了$children</h3></li><li><h3 id="vue3中的推荐的构建工具已经从vue-cli转成vite"><a href="#vue3中的推荐的构建工具已经从vue-cli转成vite" class="headerlink" title="vue3中的推荐的构建工具已经从vue cli转成vite"></a>vue3中的推荐的构建工具已经从vue cli转成vite</h3></li><li><h3 id="vue3中的推荐的状态管理工具已经从vuex转成pinia"><a href="#vue3中的推荐的状态管理工具已经从vuex转成pinia" class="headerlink" title="vue3中的推荐的状态管理工具已经从vuex转成pinia"></a>vue3中的推荐的状态管理工具已经从vuex转成pinia</h3></li><li><h3 id="IDE支持Vetur-gt-Volar"><a href="#IDE支持Vetur-gt-Volar" class="headerlink" title="IDE支持Vetur-&gt;Volar"></a>IDE支持Vetur-&gt;Volar</h3></li><li><h3 id="vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰"><a href="#vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰" class="headerlink" title="vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰"></a>vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰</h3></li><li><h3 id="添加了全新的全局api-createApp-来替代new-Vue-来创建vue实例"><a href="#添加了全新的全局api-createApp-来替代new-Vue-来创建vue实例" class="headerlink" title="添加了全新的全局api :createApp()来替代new Vue()来创建vue实例"></a>添加了全新的全局api :createApp()来替代new Vue()来创建vue实例</h3></li></ol><table><thead><tr><th>2.x Global API</th><th>3.x Instance API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config</td><td>app.config</td></tr><tr><td>Vue.config.productionTip</td><td>删除</td></tr><tr><td>Vue.config.ignoredElements</td><td>app.config.compilerOptions.isCustomElement</td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr><tr><td>Vue.extend</td><td>删除</td></tr></tbody></table><h3 id="13-全局-API-Treeshaking"><a href="#13-全局-API-Treeshaking" class="headerlink" title="13.全局 API Treeshaking"></a>13.全局 API Treeshaking</h3><div class="code-wrapper"><pre><code class="hljs vue">import Vue from &#x27;vue&#x27;Vue.nextTick(() =&gt; &#123;  // something DOM-related&#125;)</code></pre></div><p>在Vue2.X中Vue.nextTick()是一个暴露在单个Vue对象中的全局的api，事实上，实例方法$nextTick()只是一个包装器，为了方便Vue.nextTick()，回调函数的this会自动绑定到当前实例中，但是在vite和webpack中，Vue.nextTick不可以进行treeshaking,所以在Vue3中做了优化，让nextTick可以进行treeShaking,全局的模块只能作为ES模块构建的命名导出来进行访问，</p><div class="code-wrapper"><pre><code class="hljs vue">import &#123; nextTick &#125; from &#x27;vue&#x27;nextTick(() =&gt; &#123;  // something DOM-related&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs vue">import &#123; shallowMount &#125; from &#x27;@vue/test-utils&#x27;import &#123; MyComponent &#125; from &#x27;./MyComponent.vue&#x27;import &#123; nextTick &#125; from &#x27;vue&#x27;test(&#x27;an async feature&#x27;, async () =&gt; &#123;  const wrapper = shallowMount(MyComponent)  // execute some DOM-related tasks  await nextTick()  // run your assertions&#125;)</code></pre></div><p>如果在Vue3中使用Vue.nextTick()会导致臭名昭著的<code>undefined is not a function</code>错误</p><p>通过此更改，如果模块捆绑器支持 tree-shaking，则未在 Vue 应用程序中使用的全局 API 将从最终捆绑包中删除，从而获得最佳文件大小</p><h5 id="以下Vue2的全局QAPI会受到影响"><a href="#以下Vue2的全局QAPI会受到影响" class="headerlink" title="以下Vue2的全局QAPI会受到影响"></a>以下Vue2的全局QAPI会受到影响</h5><ul><li><code>Vue.nextTick</code></li><li><code>Vue.observable</code>（替换为<code>Vue.reactive</code>）</li><li><code>Vue.version</code></li><li><code>Vue.compile</code>（仅在完整版本中）</li><li><code>Vue.set</code>（仅在兼容版本中）//不要使用</li><li><code>Vue.delete</code>（仅在兼容版本中）//不要使用</li></ul><p>除了如上全局API之外，许多内部组件将不再作为默认导入的一部分，需要使用到时再导入，有利于treeShaking,</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;transition&gt;  &lt;div v-show=&quot;ok&quot;&gt;hello&lt;/div&gt;&lt;/transition&gt;</code></pre></div><p>会被编译成</p><div class="code-wrapper"><pre><code class="hljs vue">import &#123; h, Transition, withDirectives, vShow &#125; from &#x27;vue&#x27;export function render() &#123;  return h(Transition, [withDirectives(h(&#x27;div&#x27;, &#x27;hello&#x27;), [[vShow, this.ok]])])&#125;</code></pre></div><p>可以减少包的大小</p><p><strong>notice</strong></p><p><strong>上述内容仅适用于与支持 tree-shaking 的捆绑器一起使用的<a href="https://github.com/vuejs/core/tree/master/packages/vue#which-dist-file-to-use">ES 模块构建</a>- UMD 构建仍然包含所有功能并在 Vue 全局变量上公开所有内容（并且编译器将生成适当的输出以使用全局 API 而不是导入）。</strong></p><p>再插件中使用时</p><p>Vue2.x中使用全局api</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> plugin = &#123;  <span class="hljs-attr">install</span>: <span class="hljs-function"><span class="hljs-params">Vue</span> =&gt;</span> &#123;    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// ...</span>    &#125;)  &#125;&#125;</code></pre></div><p>Vue3.x使用全局API</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">const</span> plugin = &#123;  <span class="hljs-attr">install</span>: <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;    <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// ...</span>    &#125;)  &#125;&#125;</code></pre></div><p>在webpack中如果把上诉代码打包成一个buddle,他会把vue源码也会打包进去，如果要避免这样的发生可以使用externals排除</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-comment">/*...*/</span>  <span class="hljs-attr">externals</span>: &#123;    <span class="hljs-attr">vue</span>: <span class="hljs-string">&#x27;Vue&#x27;</span>  &#125;&#125;</code></pre></div><p>rollUp中的写法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// rollup.config.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">/*...*/</span>  <span class="hljs-attr">external</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>]&#125;</code></pre></div><h3 id="14-v-model"><a href="#14-v-model" class="headerlink" title="14.v-model"></a>14.v-model</h3><p>在组建中使用v-model</p><p>在vue2.x,<code>v-model</code>在组件上使用 a 相当于传递一个<code>value</code>prop 并发出一个<code>input</code>事件：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;</code></pre></div><p>如果想更改属性名和事件的时候，需要使用在组件中添加model选项，</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- ParentComponent.vue --&gt;&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">// ChildComponent.vue</span>export default <span class="hljs-punctuation">&#123;</span>  model<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    prop<span class="hljs-punctuation">:</span> &#x27;title&#x27;<span class="hljs-punctuation">,</span>    event<span class="hljs-punctuation">:</span> &#x27;change&#x27;  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  props<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-comment">// this allows using the `value` prop for a different purpose</span>    value<span class="hljs-punctuation">:</span> String<span class="hljs-punctuation">,</span>    <span class="hljs-comment">// use `title` as the prop which take the place of `value`</span>    title<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>      type<span class="hljs-punctuation">:</span> String<span class="hljs-punctuation">,</span>      default<span class="hljs-punctuation">:</span> &#x27;Default title&#x27;    <span class="hljs-punctuation">&#125;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>所以v-model实际上时这样的</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent :title=&quot;pageTitle&quot; @change=&quot;pageTitle = $event&quot; /&gt;</code></pre></div><h3 id="使用v-bind-sync"><a href="#使用v-bind-sync" class="headerlink" title="使用v-bind.sync#"></a>使用<code>v-bind.sync</code><a href="https://v3-migration.vuejs.org/breaking-changes/v-model.html#using-v-bind-sync">#</a></h3><p>在某些情况下，我们可能需要一个道具的“双向绑定”（有时除了现有<code>v-model</code>的不同道具之外）。为此，我们建议以<code>update:myPropName</code>. 例如，对于<code>ChildComponent</code>上一个带有<code>title</code>prop 的示例，我们可以通过以下方式传达分配新值的意图：</p><div class="code-wrapper"><pre><code class="hljs vue">this.$emit(&#x27;update:title&#x27;, newValue)</code></pre></div><p>然后，如果需要，父级可以侦听该事件并更新本地数据属性。例如：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</code></pre></div><p><code>.sync</code>为方便起见，我们使用修饰符对这种模式进行了简写：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt;</code></pre></div><p>在Vue3.x中 自定义组件的双向数据绑定时使用modelValue，@update:modelValue来替代</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent  :modelValue=&quot;pageTitle&quot;  @update:modelValue=&quot;pageTitle = $event&quot;/&gt;</code></pre></div><p>如果需要修改model的名称则直接修改</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent v-model:title=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</code></pre></div><p>也可以作为.sync的替代，可以在组件中双向数据绑定多个值</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">ChildComponent</span> v-<span class="hljs-attr">model</span>:title=<span class="hljs-string">&quot;pageTitle&quot;</span> v-<span class="hljs-attr">model</span>:content=<span class="hljs-string">&quot;pageContent&quot;</span> /&gt;&lt;!-- would be shorthand <span class="hljs-attr">for</span>: --&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span></span></span><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  @<span class="hljs-attr">update:title</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">:content</span>=<span class="hljs-string">&quot;pageContent&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  @<span class="hljs-attr">update:content</span>=<span class="hljs-string">&quot;pageContent = $event&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">/&gt;</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue2和vue3的区别(vue2向vue3迁移)(二)</title>
    <link href="/2022/08/12/Vue3%E5%92%8CVue%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%BA%8C)/"/>
    <url>/2022/08/12/Vue3%E5%92%8CVue%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="15-key属性"><a href="#15-key属性" class="headerlink" title="15.key属性"></a>15.key属性</h3><p>key主要适用于在Vue的虚拟DOM算法中，跟踪节点的，以便重用和修改现有的节点，以及何时修改或者重新排序。</p><p>在Vue2.x中，key也被推荐用于v-if,v-else,v-else-if</p><div class="code-wrapper"><pre><code class="hljs json">&lt;!-- Vue <span class="hljs-number">2.</span>x --&gt;&lt;div v-if=<span class="hljs-string">&quot;condition&quot;</span> key=<span class="hljs-string">&quot;yes&quot;</span>&gt;Yes&lt;/div&gt;&lt;div v-else key=<span class="hljs-string">&quot;no&quot;</span>&gt;No&lt;/div&gt;</code></pre></div><p>在vue3.x中不再要求这么使用，因为vue会自己给他添加一个unique key</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 3.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>如果你确实想添加key,必须保证key唯一</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 2.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- Vue 3.x (recommended solution: remove keys) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- Vue 3.x (alternate solution: make sure the keys are always unique) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p> <strong><code>&lt;template v-for&gt;</code></strong></p><div class="code-wrapper"><pre><code class="hljs gauss">vue2.x中 &lt;template&gt;标签不能拥有<span class="hljs-built_in">key</span>,只能在他的子元素中设置<span class="hljs-built_in">key</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 2.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;&#x27;heading-&#x27; + item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;&#x27;content-&#x27; + item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p>在vue3.x中，key应该被设置在template上</p><!-- Vue 3.x --><template v-for="item in list" :key="item.id">  <div>...</div>  <span>...</span></template><p>v-for也是一样</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 2.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item.isVisible&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-comment">&lt;!-- Vue 3.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item.isVisible&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h3 id="16-v-if-与-v-for-优先级"><a href="#16-v-if-与-v-for-优先级" class="headerlink" title="16.v-if 与 v-for 优先级"></a>16.v-if 与 v-for 优先级</h3><p>在vue2.x中，在相同的元素中v-for的优先级更高</p><p>Vue3.x中，v-if的优先级更高</p><h3 id="17-v-bind"><a href="#17-v-bind" class="headerlink" title="17.v-bind"></a>17.v-bind</h3><p>vue2.x中</p><div class="code-wrapper"><pre><code class="hljs htaccess">&lt;!-- template --&gt;&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;!-- result --&gt;&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;</code></pre></div><p>vue3.x中</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- template --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- result --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- template --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- result --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>对于绑定相同的属性，v2不会覆盖，而v3会被覆盖 v3中绑定有顺序要求</p><h3 id="18-v-on-native已经被移除"><a href="#18-v-on-native已经被移除" class="headerlink" title="18.v-on.native已经被移除"></a>18.v-on.native已经被移除</h3><h3 id="19-函数式组件"><a href="#19-函数式组件" class="headerlink" title="19.函数式组件"></a>19.函数式组件</h3><p>vue2.x中函数式组件主要用于性能优化，他的初始化速度要快于有状态组件，而且可以返回多个根节点，vue3.x中有状态组件的性能优化可以和无状态组件一样，而且还可以有多个跟节点</p><h3 id="20-异步组件"><a href="#20-异步组件" class="headerlink" title="20.异步组件"></a>20.异步组件</h3><p>vue2.x中异步组件的写法是</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncModal</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal.vue&#x27;</span>)</code></pre></div><p>或者可配置</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> asyncModal = &#123;  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal.vue&#x27;</span>),  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,  <span class="hljs-attr">error</span>: <span class="hljs-title class_">ErrorComponent</span>,  <span class="hljs-attr">loading</span>: <span class="hljs-title class_">LoadingComponent</span>&#125;</code></pre></div><p>vue3中添加了一个定义异步组件的方法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ErrorComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/ErrorComponent.vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">LoadingComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/LoadingComponent.vue&#x27;</span><span class="hljs-comment">// Async component without options</span><span class="hljs-keyword">const</span> asyncModal = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal.vue&#x27;</span>))<span class="hljs-comment">// Async component with options</span><span class="hljs-keyword">const</span> asyncModalWithOptions = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal.vue&#x27;</span>),  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>&#125;)</code></pre></div><p>而且vue2.x中的配置选项component变成了loader</p><p>vue3.x不再接受resolve，reject参数，而是返回一个promise</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 2.x version</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">oldAsyncComponent</span> = (<span class="hljs-params">resolve, reject</span>) =&gt; &#123;  <span class="hljs-comment">/* ... */</span>&#125;<span class="hljs-comment">// 3.x version</span><span class="hljs-keyword">const</span> asyncComponent = <span class="hljs-title function_">defineAsyncComponent</span>(  <span class="hljs-function">() =&gt;</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">/* ... */</span>    &#125;))</code></pre></div><h3 id="21-emits-Option"><a href="#21-emits-Option" class="headerlink" title="21.emits Option"></a>21.<code>emits</code> Option</h3><p>vue2.x中不需要声明emits的值</p><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;accepted&#x27;)&quot;</span>&gt;</span>OK<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;text&#x27;</span>]</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>vue3.x中需要定义emits</p><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;accepted&#x27;)&quot;</span>&gt;</span>OK<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;text&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;accepted&#x27;</span>]</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js">下面例子中&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;click&#x27;, $event)&quot;</span>&gt;</span>OK<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>: [] <span class="hljs-comment">// without declared event</span></span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>在父组件中监听click事件</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-button</span>&gt;</span></code></pre></div><p>click会被触发两次</p><h3 id="22-listener移除"><a href="#22-listener移除" class="headerlink" title="22.$listener移除"></a>22.$listener移除</h3><h3 id="23-attrs中包含class和style"><a href="#23-attrs中包含class和style" class="headerlink" title="23.$attrs中包含class和style"></a>23.$attrs中包含class和style</h3><p>vue2.x中，<code>class</code>和<code>style</code>属性在 Vue 2 虚拟 DOM 实现中得到一些特殊处理。因此，它们<em>不</em>包含在 中<code>$attrs</code>，而所有其他属性都包含在 中。</p><p>使用时会出现这样的副作用<code>inheritAttrs: false</code>：</p><p>这样$attr中的属性不再自动绑定到子组件的根元素上，而是由开发者来决定怎么绑定他们，但是class和style不属于$attr的一部分，任然会应用在根元素上</p><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> /&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span></span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;my-component id=<span class="hljs-string">&quot;my-id&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;my-class&quot;</span>&gt;&lt;/my-component&gt;</code></pre></div><p>真正渲染成的html</p><div class="code-wrapper"><pre><code class="hljs js">&lt;label <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;my-class&quot;</span>&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;my-id&quot;</span> /&gt;</span></span>&lt;/label&gt;</code></pre></div><p>在Vue3.x中则包含这些</p><h3 id="24-v-on不再支持数字的keycode"><a href="#24-v-on不再支持数字的keycode" class="headerlink" title="24.v-on不再支持数字的keycode"></a>24.v-on不再支持数字的keycode</h3><h3 id="25-不在支持-on-off-once"><a href="#25-不在支持-on-off-once" class="headerlink" title="25.不在支持$on,$off,$once"></a>25.不在支持$on,$off,$once</h3><p>vue2.x中支持事件总线</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// eventBus.js</span><span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> eventBus</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ChildComponent.vue</span><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// adding eventBus listener</span>    eventBus.$on(<span class="hljs-string">&#x27;custom-event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Custom event triggered!&#x27;</span>)    &#125;)  &#125;,  <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// removing eventBus listener</span>    eventBus.$off(<span class="hljs-string">&#x27;custom-event&#x27;</span>)  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ParentComponent.vue</span><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">callGlobalCustomEvent</span>(<span class="hljs-params"></span>) &#123;      eventBus.$emit(<span class="hljs-string">&#x27;custom-event&#x27;</span>) <span class="hljs-comment">// if ChildComponent is mounted, we will have a message in the console</span>    &#125;  &#125;&#125;</code></pre></div><p>vue3.x中事件总线可以使用第三方的库来实现，例如<a href="https://github.com/developit/mitt">mitt</a>或<a href="https://github.com/scottcorgan/tiny-emitter">tiny-emitter</a></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// eventBus.js</span><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;tiny-emitter/instance&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">$on</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> emitter.<span class="hljs-title function_">on</span>(...args),  <span class="hljs-attr">$once</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> emitter.<span class="hljs-title function_">once</span>(...args),  <span class="hljs-attr">$off</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> emitter.<span class="hljs-title function_">off</span>(...args),  <span class="hljs-attr">$emit</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> emitter.<span class="hljs-title function_">emit</span>(...args)&#125;</code></pre></div><h3 id="26-filters"><a href="#26-filters" class="headerlink" title="26.filters"></a>26.filters</h3><p>vue3.x移除了过滤器，可以使用methods和computed来替代</p><p>全局的过滤器可以使用如下方式来在vue3中定义</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$filters</span> = &#123;  <span class="hljs-title function_">currencyUSD</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;$&#x27;</span> + value  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Bank Account Balance<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; $filters.currencyUSD(accountBalance) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>&lt;/template&gt;</code></pre></div><h3 id="27-删除了inline-template"><a href="#27-删除了inline-template" class="headerlink" title="27.删除了inline-template"></a>27.删除了inline-template</h3><h3 id="28-删除了-children"><a href="#28-删除了-children" class="headerlink" title="28.删除了$children"></a>28.删除了$children</h3><p>vue2.x可以使用$children来访问直接子组件，vue3.x使用refs来替代就可以了</p><h3 id="29-自定义指令"><a href="#29-自定义指令" class="headerlink" title="29.自定义指令"></a>29.自定义指令</h3><p>指令的钩子函数已经重新命名，更好的和组件的生命周期配合，此外，<code>expression</code>字符串不再作为<code>binding</code>对象的一部分传递</p><p>vue2.x中的directive的可选项</p><p>bind  指令只绑定一次到元素中</p><p>inserted  元素只被插入父元素中一次</p><p>update  该hook表示当元素更新时，children还没有更新</p><p>componentUpdated  表示组件和子元素都更新完毕</p><p>unbind 表示解绑</p><p>vue2.x的自定义指令</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-highlight</span>=<span class="hljs-string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>Highlight this text bright yellow<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java">Vue.directive(<span class="hljs-string">&#x27;highlight&#x27;</span>, &#123;  bind(el, binding, vnode) &#123;    el.style.background = binding.value  &#125;&#125;)</code></pre></div><p>vue3.x中新增了created    这个声明周期是在元素的属性和事件被应用之前</p><p>bind -&gt;beforeMount</p><p>inserted -&gt;mounted</p><p>beforeUpdate 类似于组件的beforeUpdate</p><p>update被移除</p><p>componentUpdated → <strong>updated</strong></p><p><strong>beforeUnmount</strong>: new! Similar to component lifecycle hooks, this will be called right before an element is unmounted</p><p>unbind -&gt; <strong>unmounted</strong></p><div class="code-wrapper"><pre><code class="hljs html">const MyDirective = &#123;  created(el, binding, vnode, prevVnode) &#123;&#125;, // new  beforeMount() &#123;&#125;,  mounted() &#123;&#125;,  beforeUpdate() &#123;&#125;, // new  updated() &#123;&#125;,  beforeUnmount() &#123;&#125;, // new  unmounted() &#123;&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-highlight</span>=<span class="hljs-string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>Highlight this text bright yellow<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">const app = Vue.createApp(&#123;&#125;)app.directive(&#x27;highlight&#x27;, &#123;  beforeMount(el, binding, vnode) &#123;    el.style.background = binding.value  &#125;&#125;)</code></pre></div><h3 id="30-data-option"><a href="#30-data-option" class="headerlink" title="30.data option"></a>30.data option</h3><p>vue2.x中还可以使用对象作为data的值。vue3.x不可以使用对象作为data,必须使用function</p><h3 id="31-元素的挂载"><a href="#31-元素的挂载" class="headerlink" title="31.元素的挂载"></a>31.元素的挂载</h3><p>在vue2.x中当挂载的元素是一个templayte的时候，渲染的内容会替换掉需要挂载的元素，在vue3.x中，需要被渲染的内容会添加到元素的children中，替代元素的innerHTML</p><p>vue2.x中</p><div class="code-wrapper"><pre><code class="hljs html">new Vue(&#123;  el: &#x27;#app&#x27;,  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  `&#125;)// orconst app = new Vue(&#123;  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  `&#125;)app.$mount(&#x27;#app&#x27;)</code></pre></div><p>挂载到对应的元素上</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    Some app content  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>最终渲染的效果</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>Hello Vue!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>vue3.x中的效果</p><div class="code-wrapper"><pre><code class="hljs html">const app = Vue.createApp(&#123;  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  `&#125;)app.mount(&#x27;#app&#x27;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">data-v-app</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>Hello Vue!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h3 id="32-transition的变化"><a href="#32-transition的变化" class="headerlink" title="32.transition的变化"></a>32.transition的变化</h3><p>.v-enter已被替换成.v-enter-from</p><h3 id="33-vNode-生命周期事件"><a href="#33-vNode-生命周期事件" class="headerlink" title="33.vNode 生命周期事件"></a>33.vNode 生命周期事件</h3><p>在vue2.x中，可以使用事件来监听组件生命周期处于哪个阶段，这些事件的前缀是hook:,在 Vue 3 中，此前缀已更改为<code>vue:</code>. 此外，这些事件现在可用于 HTML 元素和组件</p><p>vue2.x </p><p>hook:后面跟的是生命周期函数的名称</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> @<span class="hljs-attr">hook:updated</span>=<span class="hljs-string">&quot;onUpdated&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p>vue3.x中</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> @<span class="hljs-attr">vue:updated</span>=<span class="hljs-string">&quot;onUpdated&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h3 id="34-数组的监听"><a href="#34-数组的监听" class="headerlink" title="34.数组的监听"></a>34.数组的监听</h3><p>vue3.x中，数组的监听需要加上deep</p><div class="code-wrapper"><pre><code class="hljs html">watch: &#123;  bookList: &#123;    handler(val, oldVal) &#123;      console.log(&#x27;book list changed&#x27;)    &#125;,    deep: true  &#125;,&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>daily</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript笔记</title>
    <link href="/2022/08/05/typescript%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/05/typescript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="1-在定义一个变量时，基本数据类型可以用类型推断，不用定义类型"><a href="#1-在定义一个变量时，基本数据类型可以用类型推断，不用定义类型" class="headerlink" title="1.在定义一个变量时，基本数据类型可以用类型推断，不用定义类型"></a>1.在定义一个变量时，基本数据类型可以用类型推断，不用定义类型</h4><div class="code-wrapper"><pre><code class="hljs abnf">let msg <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello there!&quot;</span><span class="hljs-comment">;</span></code></pre></div><h4 id="2-ts的常用的数据类型"><a href="#2-ts的常用的数据类型" class="headerlink" title="2.ts的常用的数据类型"></a>2.ts的常用的数据类型</h4><div class="code-wrapper"><pre><code class="hljs pgsql">string,number,<span class="hljs-type">boolean</span>,arrays,<span class="hljs-keyword">any</span>,<span class="hljs-keyword">function</span>,<span class="hljs-keyword">object</span>,<span class="hljs-keyword">union</span> <span class="hljs-keyword">type</span>,<span class="hljs-keyword">Type</span> Aliases,Interfaces，<span class="hljs-keyword">Type</span> Assertions，<span class="hljs-type">bigint</span>，symbol,<span class="hljs-keyword">Type</span> Assertions,.Literal <span class="hljs-keyword">Types</span>,Enums ,<span class="hljs-keyword">null</span>,undefined,<span class="hljs-keyword">any</span>,<span class="hljs-type">unknown</span>,<span class="hljs-type">void</span>,never ,Tuple</code></pre></div><h4 id="3-interface和type-aliases的区别"><a href="#3-interface和type-aliases的区别" class="headerlink" title="3.interface和type aliases的区别"></a>3.interface和type aliases的区别</h4><div class="code-wrapper"><pre><code class="hljs typescript">实现继承的方式不同<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bear</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-attr">honey</span>: <span class="hljs-built_in">boolean</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">Animal</span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">Bear</span> = <span class="hljs-title class_">Animal</span> &amp; &#123;   <span class="hljs-attr">honey</span>: <span class="hljs-built_in">boolean</span> &#125;添加新的字段<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Window</span> &#123;  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Window</span> &#123;  <span class="hljs-attr">ts</span>: <span class="hljs-title class_">TypeScriptAPI</span>&#125;类型别名不能够修改已经创建的字段<span class="hljs-keyword">type</span> <span class="hljs-title class_">Window</span> = &#123;  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">Window</span> = &#123;  <span class="hljs-attr">ts</span>: <span class="hljs-title class_">TypeScriptAPI</span>&#125; <span class="hljs-comment">// Error: Duplicate identifier &#x27;Window&#x27;.</span><span class="hljs-keyword">const</span> src = <span class="hljs-string">&#x27;const a = &quot;Hello World&quot;&#x27;</span>;<span class="hljs-variable language_">window</span>.<span class="hljs-property">ts</span>.<span class="hljs-title function_">transpileModule</span>(src, &#123;&#125;);接口只能声明对象，不能够重命名原语类型别名不能够声明合并，但是接口可以如果是定义非对象类型，通常推荐使用<span class="hljs-keyword">type</span>如果是定义对象类型，那么他们是有区别的：<span class="hljs-keyword">interface</span> 可以重复的对某个接口来定义属性和方法；而type定义的是别名，别名是不能重复的</code></pre></div><h4 id="4-Type-Assertions类型断言"><a href="#4-Type-Assertions类型断言" class="headerlink" title="4.Type Assertions类型断言"></a>4.Type Assertions类型断言</h4><div class="code-wrapper"><pre><code class="hljs nim"><span class="hljs-type">TypeScript</span> 只允许类型断言转换为更具体或更不具体的类型版本，而不可以转成没有关系的类型<span class="hljs-keyword">const</span> a = (<span class="hljs-type">expr</span> <span class="hljs-keyword">as</span> <span class="hljs-type">any</span>) <span class="hljs-keyword">as</span> T;  可以将两种不相关的类型进行转换时，要进行两次断言，先断雁城<span class="hljs-type">any</span>或者unknown</code></pre></div><h4 id="5-Literal-Types-文本类型"><a href="#5-Literal-Types-文本类型" class="headerlink" title="5.Literal Types 文本类型"></a>5.Literal Types 文本类型</h4><div class="code-wrapper"><pre><code class="hljs reasonml">const constantString = <span class="hljs-string">&quot;Hello World&quot;</span>;<span class="hljs-comment">//使用const定义的常量类型</span><span class="hljs-keyword">function</span> print<span class="hljs-constructor">Text(<span class="hljs-params">s</span>: <span class="hljs-params">string</span>, <span class="hljs-params">alignment</span>: <span class="hljs-string">&quot;left&quot;</span> | <span class="hljs-string">&quot;right&quot;</span> | <span class="hljs-string">&quot;center&quot;</span>)</span> &#123;  <span class="hljs-comment">// ...</span>&#125;您可以使用 <span class="hljs-keyword">as</span> const 将整个对象转换为类型文字：const req = &#123; url: <span class="hljs-string">&quot;https://example.com&quot;</span>, <span class="hljs-keyword">method</span>: <span class="hljs-string">&quot;GET&quot;</span> &#125; <span class="hljs-keyword">as</span> const;handle<span class="hljs-constructor">Request(<span class="hljs-params">req</span>.<span class="hljs-params">url</span>, <span class="hljs-params">req</span>.<span class="hljs-params">method</span>)</span>;</code></pre></div><h4 id="6-Enums-枚举"><a href="#6-Enums-枚举" class="headerlink" title="6.Enums 枚举"></a>6.Enums 枚举</h4><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// 定义枚举类型</span><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;  <span class="hljs-variable constant_">LEFT</span>,  <span class="hljs-variable constant_">RIGHT</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-attr">d1</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">LEFT</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">turnDirection</span>(<span class="hljs-params">direction: Direction</span>) &#123;  <span class="hljs-keyword">switch</span>(direction) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Direction</span>.<span class="hljs-property">LEFT</span>:      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;角色向左移动一个格子&quot;</span>)      <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Direction</span>.<span class="hljs-property">RIGHT</span>:      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;角色向右移动一个格子&quot;</span>)      <span class="hljs-keyword">break</span>  &#125;&#125;<span class="hljs-comment">// 监听键盘的点击</span><span class="hljs-title function_">turnDirection</span>(<span class="hljs-title class_">Direction</span>.<span class="hljs-property">LEFT</span>)<span class="hljs-keyword">export</span> &#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;  <span class="hljs-variable constant_">LEFT</span> = <span class="hljs-string">&quot;LEFT&quot;</span>,  <span class="hljs-variable constant_">RIGHT</span> = <span class="hljs-string">&quot;RIGHT&quot;</span>&#125;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Operation</span> &#123;  <span class="hljs-title class_">Read</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,<span class="hljs-comment">//位运算符</span>  <span class="hljs-title class_">Write</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,  foo = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-attr">d1</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">LEFT</span></code></pre></div><h4 id="7-ts的运行环境"><a href="#7-ts的运行环境" class="headerlink" title="7.ts的运行环境"></a>7.ts的运行环境</h4><div class="code-wrapper"><pre><code class="hljs crmsh">方式一：tsc math.ts   <span class="hljs-keyword">node</span> <span class="hljs-title">math</span>.js  这种方式会比较麻烦方式二：webpack中配置本地的运行环境  使用ts-loader方式三：使用ts-<span class="hljs-keyword">node</span><span class="hljs-title">npm</span> install ts-<span class="hljs-keyword">node</span> <span class="hljs-title">-g</span>npm install tslib @types/<span class="hljs-keyword">node</span> <span class="hljs-title">-g</span>ts-<span class="hljs-keyword">node</span> <span class="hljs-title">math</span>.ts</code></pre></div><h4 id="8-unkonwn类型和any类型的区别"><a href="#8-unkonwn类型和any类型的区别" class="headerlink" title="8.unkonwn类型和any类型的区别"></a>8.unkonwn类型和any类型的区别</h4><p>任何类型都可以是any类型,ts不会对any类型的变量进行类型检测，任何类型也是可以赋值给unknown,但是使用这个变量必须进行类型检查，否则就会报错</p><p><img src="https://img1.imgtp.com/2022/08/05/Lt1elC2b.png" alt="QQ截图20220715095600.png"></p><h4 id="9-Tuple类型-元组"><a href="#9-Tuple类型-元组" class="headerlink" title="9.Tuple类型(元组)"></a>9.Tuple类型(元组)</h4><p>元组类型就是不同类型的数组的集合</p><p><img src="https://img1.imgtp.com/2022/08/05/PyfvKidj.png" alt="QQ截图20220715101013.png"></p><h4 id="10-Never类型"><a href="#10-Never类型" class="headerlink" title="10.Never类型"></a>10.Never类型</h4><h5 id="Never类型指永不存在的类型。-例如，never-类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型"><a href="#Never类型指永不存在的类型。-例如，never-类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型" class="headerlink" title="Never类型指永不存在的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型"></a>Never类型指永不存在的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</h5><h4 id="11-函数参数"><a href="#11-函数参数" class="headerlink" title="11.函数参数"></a>11.函数参数</h4><p><img src="https://img1.imgtp.com/2022/08/05/8e9QZ1fu.png" alt="QQ截图20220715111132.png"></p><h4 id="12-匿名函数的参数类型"><a href="#12-匿名函数的参数类型" class="headerlink" title="12.匿名函数的参数类型"></a>12.匿名函数的参数类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/UiMI6HEs.png" alt="QQ截图20220715111344.png"></p><h4 id="13-函数参数的对象类型"><a href="#13-函数参数的对象类型" class="headerlink" title="13.函数参数的对象类型"></a>13.函数参数的对象类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/Itu8eHI1.png" alt="QQ截图20220715112229.png"></p><h4 id="14-函数参数对象可选参数"><a href="#14-函数参数对象可选参数" class="headerlink" title="14.函数参数对象可选参数"></a>14.函数参数对象可选参数</h4><p><img src="https://img1.imgtp.com/2022/08/05/4knXfTJ1.png" alt="QQ截图20220715112745.png"></p><h4 id="15-联合类型"><a href="#15-联合类型" class="headerlink" title="15.联合类型"></a>15.联合类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/xI0aQEuD.png" alt="QQ截图20220715114922.png"></p><h4 id="16-一个参数一个可选类型的时候-它其实类似于是这个参数是-类型-undefined-的联合类型"><a href="#16-一个参数一个可选类型的时候-它其实类似于是这个参数是-类型-undefined-的联合类型" class="headerlink" title="16.一个参数一个可选类型的时候, 它其实类似于是这个参数是 类型|undefined 的联合类型"></a>16.一个参数一个可选类型的时候, 它其实类似于是这个参数是 类型|undefined 的联合类型</h4><h4 id="17-非空类型断言"><a href="#17-非空类型断言" class="headerlink" title="17.非空类型断言!"></a>17.非空类型断言!</h4><p><img src="https://img1.imgtp.com/2022/08/05/T6LzBxdD.png" alt="QQ截图20220715142334.png"></p><h4 id="18-可选链操作"><a href="#18-可选链操作" class="headerlink" title="18.可选链操作"></a>18.可选链操作</h4><p><img src="https://img1.imgtp.com/2022/08/05/TaGoHMzn.png" alt="QQ截图20220715151237.png"></p><h4 id="19-运算符"><a href="#19-运算符" class="headerlink" title="19.!!运算符"></a>19.!!运算符</h4><p>可以将其他数据类型转换成boolean</p><h4 id="20-操作符-空值合并操作符"><a href="#20-操作符-空值合并操作符" class="headerlink" title="20.??操作符  空值合并操作符"></a>20.??操作符  空值合并操作符</h4><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> messgae1 = <span class="hljs-string">&quot;1111&quot;</span>;<span class="hljs-keyword">const</span> content = messgae1 ?? <span class="hljs-string">&quot;你好&quot;</span>;如果message1是<span class="hljs-literal">null</span>或者<span class="hljs-literal">undefined</span>,content就会使用后面的值，message是空字符串不生效</code></pre></div><h4 id="21-类型缩小-Type-Narrowing"><a href="#21-类型缩小-Type-Narrowing" class="headerlink" title="21.类型缩小  Type Narrowing"></a>21.类型缩小  Type Narrowing</h4><p>类型缩小就是将例如联合类型进行精确到具体的类型</p><p>常见的类型保护有</p><p>typeof</p><p>===，！==</p><p>instanceof</p><p>in</p><p>…..</p><p><img src="https://img1.imgtp.com/2022/08/05/xmoxhxl5.png" alt="QQ截图20220716003305.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/DnVQP9fW.png" alt="QQ截图20220716003335.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/ECM7n6A2.png" alt="QQ截图20220716003417"></p><p><img src="https://img1.imgtp.com/2022/08/05/eDTnB12m.png" alt="QQ截图20220716003433"></p><p><img src="https://img1.imgtp.com/2022/08/05/s38SLBN0.png" alt="QQ截图20220716003446"></p><h4 id="22-函数类型定义"><a href="#22-函数类型定义" class="headerlink" title="22.函数类型定义"></a>22.函数类型定义</h4><p><img src="https://img1.imgtp.com/2022/08/05/E4FrxA0i.png"></p><h4 id="23-参数的可选类型"><a href="#23-参数的可选类型" class="headerlink" title="23.参数的可选类型"></a>23.参数的可选类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/5GU46enS.png"></p><h4 id="24-参数的默认值"><a href="#24-参数的默认值" class="headerlink" title="24.参数的默认值"></a>24.参数的默认值</h4><p><img src="https://img1.imgtp.com/2022/08/05/0pGV9IBH.png"></p><h4 id="25-剩余参数"><a href="#25-剩余参数" class="headerlink" title="25.剩余参数"></a>25.剩余参数</h4><p><img src="https://img1.imgtp.com/2022/08/05/b2Gi65SO.png"></p><h4 id="26-指定this的绑定"><a href="#26-指定this的绑定" class="headerlink" title="26.指定this的绑定"></a>26.指定this的绑定</h4><p><img src="https://img1.imgtp.com/2022/08/05/PLXzyda7.png"></p><h4 id="27-函数的重载"><a href="#27-函数的重载" class="headerlink" title="27.函数的重载"></a>27.函数的重载</h4><p>通过联合类型的有两个缺点：</p><p> 1.需要进行很多类型逻辑判断</p><p> 2.返回值类型不能判定</p><p><img src="https://img1.imgtp.com/2022/08/05/Xl0sI2DM.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/obc6YOcv.png"></p><h4 id="27-类的定义"><a href="#27-类的定义" class="headerlink" title="27.类的定义"></a>27.类的定义</h4><p><img src="https://img1.imgtp.com/2022/08/05/GQd3h5pF.png"></p><h4 id="28-类的继承"><a href="#28-类的继承" class="headerlink" title="28.类的继承"></a>28.类的继承</h4><p><img src="https://img1.imgtp.com/2022/08/05/NwBuKZH2.png"></p><h4 id="29-类的多态"><a href="#29-类的多态" class="headerlink" title="29.类的多态"></a>29.类的多态</h4><p><img src="https://img1.imgtp.com/2022/08/05/95zR2UQ2.png"></p><h4 id="30-类的成员修饰符"><a href="#30-类的成员修饰符" class="headerlink" title="30.类的成员修饰符"></a>30.类的成员修饰符</h4><p>private 修饰的属性和方法只能在该类内部使用</p><p>protected修饰的属性和方法只能在类本身及其子类内部使用</p><p>public是默认的成员修饰符，可以在外部，类，子类使用</p><p><img src="https://img1.imgtp.com/2022/08/05/Pw02xjP0.png"></p><h4 id="31-readonly修饰符"><a href="#31-readonly修饰符" class="headerlink" title="31.readonly修饰符"></a>31.readonly修饰符</h4><p><img src="https://img1.imgtp.com/2022/08/05/KrYErakm.png"></p><h4 id="32-访问器setter-getter"><a href="#32-访问器setter-getter" class="headerlink" title="32.访问器setter/getter"></a>32.访问器setter/getter</h4><p><img src="https://img1.imgtp.com/2022/08/05/eVx6dPgv.png"></p><h4 id="33-类的静态成员"><a href="#33-类的静态成员" class="headerlink" title="33.类的静态成员"></a>33.类的静态成员</h4><p><img src="https://img1.imgtp.com/2022/08/05/ESG5cMLo.png"></p><h4 id="34-抽象类abstract"><a href="#34-抽象类abstract" class="headerlink" title="34.抽象类abstract"></a>34.抽象类abstract</h4><p>什么是 抽象方法? 在TypeScript中没有具体实现的方法(没有方法体)，就是抽象方法</p><p>抽象方法，必须存在于抽象类中</p><p>抽象类是使用abstract声明的类</p><p><img src="https://img1.imgtp.com/2022/08/05/XmcOILgK.png"></p><h4 id="35-类本身也可以作为另外一变量的类型"><a href="#35-类本身也可以作为另外一变量的类型" class="headerlink" title="35.类本身也可以作为另外一变量的类型"></a>35.类本身也可以作为另外一变量的类型</h4><h4 id="36-接口的声明"><a href="#36-接口的声明" class="headerlink" title="36.接口的声明"></a>36.接口的声明</h4><p> <img src="https://img1.imgtp.com/2022/08/05/3ANVJqpG.png"></p><h4 id="37-接口的索引类型"><a href="#37-接口的索引类型" class="headerlink" title="37.接口的索引类型"></a>37.接口的索引类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/1pM1SZre.png"></p><h4 id="38-函数类型"><a href="#38-函数类型" class="headerlink" title="38.函数类型"></a>38.函数类型</h4><p>interface也可以定义函数，建议使用类型别名列定义函数</p><p><img src="https://img1.imgtp.com/2022/08/05/xVRVoVov.png"></p><h4 id="39-接口的继承"><a href="#39-接口的继承" class="headerlink" title="39.接口的继承"></a>39.接口的继承</h4><p><img src="https://img1.imgtp.com/2022/08/05/VlVrCRbV.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/gvacaNKp.png"></p><h4 id="40-交叉类型"><a href="#40-交叉类型" class="headerlink" title="40.交叉类型"></a>40.交叉类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/kExwu85c.png"></p><h4 id="41-字面量赋值"><a href="#41-字面量赋值" class="headerlink" title="41.字面量赋值"></a>41.字面量赋值</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://img1.imgtp.com/2022/08/05/LVx7kzYn.png"></h4><p><img src="https://img1.imgtp.com/2022/08/05/UxFV3w0L.png" alt="QQ截图20220716171033.png"></p><h4 id="42-枚举类型"><a href="#42-枚举类型" class="headerlink" title="42.枚举类型"></a>42.枚举类型</h4><p>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型； </p><p>枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型</p><p><img src="https://img1.imgtp.com/2022/08/05/JUcGQCK2.png" alt="QQ截图20220716172406.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/i4HcVm8N.png" alt="QQ截图20220716172417.png"></p><h4 id="43-泛型"><a href="#43-泛型" class="headerlink" title="43.泛型"></a>43.泛型</h4><p><img src="https://img1.imgtp.com/2022/08/05/A6dtGWoy.png" alt="QQ截图20220717020140.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/A6dtGWoy.png" alt="QQ截图20220717020140.png"></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title class_">Foo</span>&lt;T,E&gt;(<span class="hljs-attr">a</span>:T,<span class="hljs-attr">b</span>:E)&#123;&#125;</code></pre></div><p>还可以传入多个类型</p><p>常见范型的缩写</p><p>T：是type的缩写。代表类型</p><p>K,V:是key和value的缩写</p><p>E：是element的缩写</p><p>O：是Object的缩写</p><h4 id="44-泛型接口的定义"><a href="#44-泛型接口的定义" class="headerlink" title="44.泛型接口的定义"></a>44.泛型接口的定义</h4><p><img src="https://img1.imgtp.com/2022/08/05/2ZbKkBg2.png" alt="QQ截图20220717020609.png"></p><h4 id="45-泛型作为类"><a href="#45-泛型作为类" class="headerlink" title="45.泛型作为类"></a>45.泛型作为类</h4><p><img src="https://img1.imgtp.com/2022/08/05/c0ucka5e.png" alt="QQ截图20220717092242.png"></p><h4 id="46-泛型约束"><a href="#46-泛型约束" class="headerlink" title="46.泛型约束"></a>46.泛型约束</h4><p><img src="https://img1.imgtp.com/2022/08/05/A9jQ0E9R.png" alt="QQ截图20220717092443.png"></p><p>在范型参数使用约束</p><p><strong>举个栗子：我们希望获取一个对象给定属性名的值</strong></p><p>我们需要确保我们不会获取 obj 上不存在的属性；</p><p>所以我们在两个类型之间建立一个约束；</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 传入的key类型, obj当中key的其中之一</span>interface <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: string  <span class="hljs-attr">age</span>: number&#125;type <span class="hljs-title class_">IKunKeys</span> = keyof <span class="hljs-title class_">IKun</span> <span class="hljs-comment">// &quot;name&quot;|&quot;age&quot;</span><span class="hljs-comment">//keyof 可以获取key的联合类型</span><span class="hljs-keyword">function</span> getObjectProperty&lt;O, K <span class="hljs-keyword">extends</span> keyof O&gt;(<span class="hljs-attr">obj</span>: O, <span class="hljs-attr">key</span>: K)&#123;  <span class="hljs-keyword">return</span> obj[key]&#125;<span class="hljs-keyword">const</span> info = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>&#125;</code></pre></div><h4 id="47-映射类型（Mapped-Types）"><a href="#47-映射类型（Mapped-Types）" class="headerlink" title="47.映射类型（Mapped Types）"></a>47.<strong>映射类型（Mapped Types）</strong></h4><p><strong>有的时候，一个类型需要基于另外一个类型，但是你又不想拷贝一份，这个时候可以考虑使用映射类型</strong>，而且可以改变属性的特性，例如可以改变属性的readonly，是否可选</p><p>大部分内置的工具都是通过映射类型来实现的；</p><p>大多数类型体操的题目也是通过映射类型完成的</p><p><strong>映射类型建立在索引签名的语法上：</strong></p><p>映射类型，就是使用了 PropertyKeys 联合类型的泛型；</p><p>其中 PropertyKeys 多是通过 keyof 创建，然后循环遍历键名创建一个类型</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// TypeScript提供了映射类型: 函数</span><span class="hljs-comment">// 映射类型不能使用interface定义</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapPerson</span>&lt;<span class="hljs-title class_">Type</span>&gt; = &#123;  <span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Type</span>]?: <span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Property</span>]<span class="hljs-comment">//readonly可以将属性转成只读属性 ？可以转成可选属性</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>  <span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">IPersonOptional</span> = <span class="hljs-title class_">MapPerson</span>&lt;<span class="hljs-title class_">IPerson</span>&gt;<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">IPersonOptional</span> = &#123;&#125;</code></pre></div><h4 id="48-映射修饰符（Mapping-Modifiers）"><a href="#48-映射修饰符（Mapping-Modifiers）" class="headerlink" title="48.映射修饰符（Mapping Modifiers）"></a>48.<strong>映射修饰符（Mapping Modifiers）</strong></h4><p><strong>在使用映射类型时，有两个额外的修饰符可能会用到：</strong></p><p>一个是 readonly，用于设置属性只读；</p><p> 一个是 ? ，用于设置属性可选；</p><p><strong>你可以通过前缀 - 或者 + 删除或者添加这些修饰符，如果没有写前缀，相当于使用了 + 前缀</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapPerson</span>&lt;<span class="hljs-title class_">Type</span>&gt; = &#123;  -<span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Type</span>]-?: <span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Property</span>]<span class="hljs-comment">//- 表示删除readonly和？+表示添加</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  age?: <span class="hljs-built_in">number</span>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>  address?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// </span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IPersonRequired</span> = <span class="hljs-title class_">MapPerson</span>&lt;<span class="hljs-title class_">IPerson</span>&gt;<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">IPersonRequired</span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>,  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>&#125;</code></pre></div><h4 id="49-内置工具和类型体操"><a href="#49-内置工具和类型体操" class="headerlink" title="49.内置工具和类型体操"></a>49.<strong>内置工具和类型体操</strong></h4><p><strong>类型系统其实在很多语言里面都是有的，比如Java、Swift、C++等等，但是相对来说TypeScript的类型非常灵活：</strong></p><p> 这是因为TypeScript的目的是为JavaScript添加一套类型校验系统，因为JavaScript本身的灵活性，也让TypeScript类型系统</p><p>不得不增加更附加的功能以适配JavaScript的灵活性；</p><p> 所以TypeScript是一种可以支持类型编程的类型系统； </p><p>◼ <strong>这种类型编程系统为TypeScript增加了很大的灵活度，同时也增加了它的难度：</strong></p><p> 如果你不仅仅在开发业务的时候为自己的JavaScript代码增加上类型约束，那么基本不需要太多的类型编程能力；</p><p> 但是如果你在开发一些框架、库，或者通用性的工具，为了考虑各种适配的情况，就需要使用类型编程； </p><p>◼ <strong>TypeScript本身为我们提供了类型工具，帮助我们辅助进行类型转换（前面有用过关于this的类型工具）。</strong></p><p>◼ <strong>很多开发者为了进一步增强自己的TypeScript编程能力，还会专门去做一些类型体操的题目：</strong></p><p> <a href="https://github.com/type-challenges/type-challenges">https://github.com/type-challenges/type-challenges</a></p><p> <a href="https://ghaiklor.github.io/type-challenges-solutions/en/">https://ghaiklor.github.io/type-challenges-solutions/en/</a></p><p>◼ <strong>我们课堂上会学习TypeScript的编程能力的语法，并且通过学习内置工具来练习一些类型体操的题目</strong></p><h4 id="49-namespace"><a href="#49-namespace" class="headerlink" title="49.namespace"></a>49.namespace</h4><p><strong>命名空间不再建议使用，使用模块替代</strong></p><p>namespace会形成独立的空间，里面的内容需要使用export，外部才可以使用，否则外部无法访问</p><p><img src="https://img1.imgtp.com/2022/08/05/qr2xvkmZ.png" alt="QQ截图20220717174941.png"><br><img src="https://img1.imgtp.com/2022/08/05/Eq2OIARP.png" alt="QQ截图20220717175005.png"><br>48.命名空间的拆分</p><p>可以将命名空间的内容拆分到多个文件中</p><h4 id="50-d-ts文件-类型声明文件"><a href="#50-d-ts文件-类型声明文件" class="headerlink" title="50..d.ts文件  类型声明文件"></a>50..d.ts文件  类型声明文件</h4><p>它仅仅用来做类型检测，告知typescript我们有哪 些类型,他和普通的ts文件的区别是，他只能做类型盛名，不可以写业务代码，而且不需要使用export导出，他是全局的</p><p>那么typescript会在哪里查找我们的类型声明呢？</p><p>内置类型声明；</p><p>外部定义类型声明；</p><p>自己定义类型声明；</p><p>类型声明文件主要适用于外部类库，例如引入的npm包没有做类型声明，则需要自己写类型声明文件</p><h4 id="51-内置类型声明"><a href="#51-内置类型声明" class="headerlink" title="51.内置类型声明"></a>51.内置类型声明</h4><p>内置类型声明是typescript自带的、帮助我们内置了JavaScript运行时的一些标准化API的声明文件。包括比如Math、Date等内置类型，也包括DOM API，比如Window、Document等； 内置类型声明通常在我们安装typescript的环境中会带有的；</p><p><a href="https://github.com/microsoft/TypeScript/tree/main/lib">https://github.com/microsoft/TypeScript/tree/main/lib</a></p><p><strong>TypeScript 使用模式命名这些声明文件lib.[something].d.ts</strong></p><p><strong>内置声明的环境</strong></p><p><strong>我们可以通过target和lib来决定哪些内置类型声明是可以使用的：</strong></p><p>例如，startsWith字符串方法只能从称为ECMAScript 6的 JavaScript 版本开始使用；</p><p><strong>我们可以通过target的编译选项来配置：TypeScript通过lib根据您的target设置更改默认包含的文件来帮助解决此问题。</strong></p><p><a href="https://www.typescriptlang.org/tsconfig#lib">https://www.typescriptlang.org/tsconfig#lib</a></p><h4 id="52-外部定义类型声明和自定义声明"><a href="#52-外部定义类型声明和自定义声明" class="headerlink" title="52.外部定义类型声明和自定义声明"></a>52.外部定义类型声明和自定义声明</h4><p>外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明</p><p>这些库通常有两种类型声明方式：</p><p> 方式一：在自己库中进行类型声明（编写.d.ts文件），比如axios</p><p>方式二：通过社区的一个公有库DefinitelyTyped存放类型声明文件</p><p>该库的GitHub地址：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">https://github.com/DefinitelyTyped/DefinitelyTyped/</a></p><p>该库查找声明安装方式的地址：<a href="https://www.typescriptlang.org/dt/search?search">https://www.typescriptlang.org/dt/search?search</a>=</p><p>比如我们安装react的类型声明： npm i @types/react –save-dev</p><p> 什么情况下需要自己来定义声明文件呢？</p><p>情况一：我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</p><p>情况二：我们给自己的代码中声明一些类型，方便在其他地方直接进行使用；</p><p>​                原则上所有类型声明都可以写在.d.ts文件上，一般建议在d.ts文件中定义全局的变量，函数，文件类型声明，或者类</p><p>例如在全局定义变量</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>TSDemo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js</span></span><span class="hljs-string"><span class="hljs-tag">  &quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">const</span> whyName = <span class="hljs-string">&quot;why&quot;</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> whyAge = <span class="hljs-number">18</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> whyHeight = <span class="hljs-number">1.88</span></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">bar</span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>在ts文件下访问的时候报错，找不到这个变量或者函数，需要在.d.ts文件中声明变量</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-comment">//第三方库使用js编写的文件，在ts中使用的时候需要自己声明这个库，例如如下这种声明方式</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;lodash&quot;</span> &#123;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">join</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-built_in">any</span>&#125;<span class="hljs-comment">// 为自己的 变量/函数/类 定义类型声明</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">whyName</span>: <span class="hljs-built_in">string</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">whyAge</span>: <span class="hljs-built_in">number</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">whyHeight</span>: <span class="hljs-built_in">number</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">bar: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span></span>)&#125;<span class="hljs-comment">// 作为一个第三方库为其他开发者提供类型声明文件 .d.ts =&gt; axios.d.ts</span><span class="hljs-comment">// 声明文件模块，引入某些模块的时候，ts不支持这些模块，所以需要声明</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.png&quot;</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.jpg&quot;</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.jpeg&quot;</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.svg&quot;</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.vue&quot;</span><span class="hljs-comment">//当使用cdn的方式引入一个包的时候</span><span class="hljs-comment">//一种方式 声明成模块(不合适)因为没有导入</span><span class="hljs-comment">// 另一种方式 声明命名空间</span><span class="hljs-comment">//例如声明jquery&#x27;</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">namespace</span> $ &#123;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">settings: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">any</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试问题记录</title>
    <link href="/2022/08/04/interview02/"/>
    <url>/2022/08/04/interview02/</url>
    
    <content type="html"><![CDATA[<h3 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h3><h3 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h3><h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别"></a>请描述一下 <code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别</h3><h3 id="WEB标准以及W3C标准是什么"><a href="#WEB标准以及W3C标准是什么" class="headerlink" title="WEB标准以及W3C标准是什么"></a>WEB标准以及W3C标准是什么</h3><h3 id="HTTP-request报文结构是怎样的"><a href="#HTTP-request报文结构是怎样的" class="headerlink" title="HTTP request报文结构是怎样的"></a>HTTP request报文结构是怎样的</h3><h3 id="HTTP-response报文结构是怎样的"><a href="#HTTP-response报文结构是怎样的" class="headerlink" title="HTTP response报文结构是怎样的"></a>HTTP response报文结构是怎样的</h3><h3 id="如何垂直居中一个浮动元素"><a href="#如何垂直居中一个浮动元素" class="headerlink" title="如何垂直居中一个浮动元素"></a>如何垂直居中一个浮动元素</h3><h3 id="css中可以让文字在垂直和水平方向上重叠的两个属性是什么"><a href="#css中可以让文字在垂直和水平方向上重叠的两个属性是什么" class="headerlink" title="css中可以让文字在垂直和水平方向上重叠的两个属性是什么"></a>css中可以让文字在垂直和水平方向上重叠的两个属性是什么</h3><p>面试总结</p><p>css动画</p><p>从左上角到右下角</p><p>jsonp如何实现跨域</p><p>tcp三次握手四次挥手</p><p>正则表达式</p><p>首屏加载优化</p><p>promise实现</p><p>promise.all实现</p><p>并发多条请求，等所有成功后在响应</p><p>自己做过哪些缓存</p><p>eventBus</p><p>如何实现跨域</p><p>设计模式</p><p>中英文切换：前端国际化</p><p>自己webpack搭建项目</p><p>哪些数据需要缓存</p><p>前端数据可视化</p><p>vue-cli搭建</p><p>vue3了解</p><p>数据请求接口拦截</p><p>有没有做过重构</p><p>v-for和v-show区别</p><p>v-for为什么不可以和v-if一起用</p><p>自定义命令v-**有没有用过，设置优先级</p><p>用过哪些缓存</p><p>$nexttrick使用场景</p><p>用过哪些钩子函数</p><p>visual Dom</p><p>vue中router实现原理</p><p>如何减少回流重绘</p><p>用过哪些设计模式，前端模块分层 ts中有进行模块的分层</p><p>v-model和sync区别</p><p>浏览器渲染线程是异步还是同步的</p><p>vue中加载外部js文件和vue中js的执行顺序</p><p>vue中如何进行跨多个组件传递信息</p><p>移动端安卓和ios的兼容性问题，pc端兼容性问题</p><p>页面嵌入到app中如何区分是是外部页面还是app页面</p><h5 id="http2-http3的区别"><a href="#http2-http3的区别" class="headerlink" title="http2/http3的区别"></a>http2/http3的区别</h5><h5 id="一百万条数据中查询一条数据"><a href="#一百万条数据中查询一条数据" class="headerlink" title="一百万条数据中查询一条数据"></a>一百万条数据中查询一条数据</h5><h5 id="如何根据电脑系统的亮度来调整background"><a href="#如何根据电脑系统的亮度来调整background" class="headerlink" title="如何根据电脑系统的亮度来调整background"></a>如何根据电脑系统的亮度来调整background</h5><h5 id="如果出现页面出现大面积空白解决方案"><a href="#如果出现页面出现大面积空白解决方案" class="headerlink" title="如果出现页面出现大面积空白解决方案"></a>如果出现页面出现大面积空白解决方案</h5><h5 id="scroll-behavior的值，及其作用"><a href="#scroll-behavior的值，及其作用" class="headerlink" title="scroll-behavior的值，及其作用"></a>scroll-behavior的值，及其作用</h5><h5 id="DOCTYPE的作用"><a href="#DOCTYPE的作用" class="headerlink" title="DOCTYPE的作用"></a>DOCTYPE的作用</h5><h5 id="JS如何上传多张png格式的图片"><a href="#JS如何上传多张png格式的图片" class="headerlink" title="JS如何上传多张png格式的图片"></a>JS如何上传多张png格式的图片</h5>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客网收集面试题答案</title>
    <link href="/2022/08/04/interview01/"/>
    <url>/2022/08/04/interview01/</url>
    
    <content type="html"><![CDATA[<h4 id="1-说一说cookie-sessionStorage-localStorage-区别？"><a href="#1-说一说cookie-sessionStorage-localStorage-区别？" class="headerlink" title="1.说一说cookie sessionStorage localStorage 区别？"></a>1.说一说cookie sessionStorage localStorage 区别？</h4><p><strong>我的回答：</strong>cookie的大小只有4k,cookie是在浏览器中存储的，分为两种，内存cookie和硬盘cookie,默认的cookie就是内存cookie,没有设置过期时间，默认情况下就是浏览器关闭，cookie就会被浏览器删除，硬盘cookie是有设置过期时间，在过期时间之前，浏览器关闭，cookie不会被删除。把过期时间设置为负数或者0，可以删除cookie。</p><p>sessionStorage和localStorage不会自动存储，需要手动的存储数据，存储的数据量会比cookie大。sessionStorage只会在本次会话中存储，不会在新的页面中被获取。localStorage在页面关闭并且重新打开时不会被清除，sessionStorage会被清除。在页面内发生跳转不打开新的页面的时候，sessionStorage和localstorage不会被删除，在页面中跳转打开新的页面的时候，sessionStorage不保存，localstorage会保存</p><p><strong>参考答案：</strong>得分点 数据存储位置，生命周期，存储大小，写入方式，数据共享，发送请求是否携带，应用场景。相同点Cookie,SessionStorage，LocalStorage都是存储在浏览器本地的，不同点，cookie默认是浏览器关闭时候会被删除，可以设置过期时间，在过期时间内浏览器关闭，cookie不会删除。cookie一般是由服务端写入的，SessionStorage和LocalStorage是在客户端写入的，cookie的生命周期是由服务端设置好的，而LocalStorage是永远存在的，如果没有手动删除。SessionStorage页面关闭会被清除。sessionStorage只会在本次会话中存储，不会在新的页面中被获取，页面内发生跳转不打开新的页面时候，sessionStorage不会被清除，cookie的存储大小为4k,sessionStorage和localStorage存储大小为5M。cookie，sessionStorage,localStorage数据共享都是遵循同源策略原则，SessionStorage还必须限制在同一个页面。前端向后端发送数据的时候，cookie会自动携带，而localStorage和sessionStorage中的数据必须手动添加。应用场景：cookie可以存储登录的验证信息SessionId和token,localStorage通常存储不易变动的数据来减轻服务器的压力，SessionStorage可以用来检测用户是否刷新进入页面，像音乐播放器恢复播放进度条的功能</p><h4 id="2-说一说JS数据类型有哪些-区别是什么？"><a href="#2-说一说JS数据类型有哪些-区别是什么？" class="headerlink" title="2.说一说JS数据类型有哪些,区别是什么？"></a>2.说一说JS数据类型有哪些,区别是什么？</h4><p>数据类型有Null,undefined,Boolean,Number.String,Symbol,Bigint,Object8种数据类型</p><p>基本数据类型有null,undefined,boolean,number,string,symbol,bigint,引用数据类型包括普通的object，数组，正则，Date对象，Math内置对象，Function对象，包括ES6新增的Map和Set对象</p><p>基本数据类型是存储在栈中，引用数据类型存储在堆中的，引用数据类型在栈中存储了指针，该指针指向存储数据所在的堆内存的起始地址。</p><p>Symbol是ES6中新增的基本数据类型，可以产生一个独一无二的值，作为Object的key。Symbol创建的值具有唯一性，Symbol(key)!==Symbol(key),要获取对象中用symbol作为key的属性，必须通过Object.getOwnPropertySymbols(obj)</p><p>Bigint也是ES6新增的基本数据类型，来代表超出最大或者最小Number可以表示的值，不可以和Number混用</p><p>判断基本数据类型可以使用typeof 来判断，但是typeof null ===object typeof function===’function’</p><p>无法判断其他引用数据类型，必须使用instanceof来判断</p><h4 id="3-说一说你对闭包的理解？"><a href="#3-说一说你对闭包的理解？" class="headerlink" title="3.说一说你对闭包的理解？"></a>3.说一说你对闭包的理解？</h4><p>闭包就是内部函数访问外部环境的自由变量，外部变量可以引用另一个函数的内部函数，通过这个内部函数的引用来访问他的上层作用域，如果这个外部变量依然引用着这个函数，所以不会被垃圾回收器回收，而导致内存泄露。闭包可以模仿块级作用域，能够实现函数柯里化，在构造函数中使用特权方法，Vue中数据响应式Observer使用了闭包</p><h4 id="4-说一说promise是什么与使用方法？"><a href="#4-说一说promise是什么与使用方法？" class="headerlink" title="4.说一说promise是什么与使用方法？"></a>4.说一说promise是什么与使用方法？</h4><p>Promise是异步微任务，new Promise是同步执行，new Promise().then()是异步的，promise解决了异步多层嵌套回调，造成回调地狱的问题，让代码的可读性增加，更加容易维护。</p><p>promise的使用：通过new Promise()创建一个实例，传入一个包含resolve,reject作为参数的函调函数，执行成功是使用resolve(),执行失败是使用reject,promsie有三种状态，padding ,rejected,fulfilled,当状态发生改变的时候，就不会再更改，所以fulfilled状态执行resolve，rejected状态执行reject,然后会调用实例方法then(),then是异步调用，有两个回调函数，第一个是成功的回调，另外一个是失败的回调，失败的回调也可以链式调用使用catch传入失败的回调，promise.finally()不管成功还是失败都会执行，promsie中的类方法，Promsie.resolve()转换成fulfilled状态，并将参数传给then,Promise.reject()转换从rejected状态，并将给定的失败的信息传递给catch,any()方法会传入一个promise数组，只要有一个promise为fulfilled状态，则any也是fulfilled,只有全部为rejected则为rejected,allSettled()状态只有fulfilled状态，race()谁先改变状态就是使用谁的状态,all()只有全部为fulfilled才是fulfilled，有一个为reject则为reject</p><h4 id="5-说一说跨域是什么？如何解决跨域问题？"><a href="#5-说一说跨域是什么？如何解决跨域问题？" class="headerlink" title="5.说一说跨域是什么？如何解决跨域问题？"></a>5.说一说跨域是什么？如何解决跨域问题？</h4><p>由于同源策略，当出现请求页面的地址和当前页面地址协议，域名，端口号有一个不一致就会出现跨域。</p><p>解决跨域的方法</p><p>使用jsonp进行请求数据，并且通过回调函数来携带返回的数据</p><p>cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。<br>res.setHeader(‘Access-Control-Allow-Origin’, ‘*’);<br>res.setHeader(“Access-Control-Allow-Methods”, “GET, PUT, OPTIONS, POST”);</p><p>node中间件、nginx反向代理：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制</p><p>JSONP：利用的原理是script标签可以跨域请求资源，将回调函数作为参数拼接在url中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成javascript。</p><p>postmessage：H5新增API，通过发送和接收API实现跨域通信。</p><p>webpack中配置devServer中的proxy实现跨域</p><h4 id="6-说一说BFC"><a href="#6-说一说BFC" class="headerlink" title="6.说一说BFC"></a>6.说一说BFC</h4><p>BFC就是块级格式化上下文。他会形成一块独立的区域，不会影响边界以外的元素</p><p>BFC产生的条件</p><ol><li>根元素</li><li>浮动元素（float:left/float:right）</li><li>绝对定位元素(position:absolute,fixed)</li><li>行内块元素 display:inline-block</li><li>表格单元格 display:table-cell 表格的单元格默认就是</li><li>匿名表格单元格元素</li><li>overflow计算值不是visible的块元素</li><li>display:flex/inline-flex的直接子元素</li><li>display:grid或者inline-grid的直接子元素</li><li>display:flow-root元素</li></ol><p>作用</p><p>​    解决同一个BFC相邻两个box的margin会折叠的问题</p><p>​    解决浮动高度塌陷的问题，可以实现清除浮动的效果。通常是overflow:hidden</p><p>​        解决高度塌陷要满足以下条件</p><p>​            浮动元素的父元素触发BFC，形成BFC</p><p>​            浮动元素的父元素的高度是auto</p><p>​    BFC的高度是auto的情况下，高度的计算</p><p>​            如果只有inline-level 是行高的顶部和底部的距离</p><p>​            如果是block-level,是由最顶层块的上边缘到最底层块的下边缘之间距离</p><p>​            如果有绝对定位元素，将忽略</p><p>​            如果有浮动元素，则会增加高度包含浮动元素的下边缘</p><h4 id="7-说一说Vuex是什么，每个属性是干嘛的，如何使用-？"><a href="#7-说一说Vuex是什么，每个属性是干嘛的，如何使用-？" class="headerlink" title="7.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？"></a>7.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？</h4><p>VueX是全局状态管理的工具。vuex的属性有state,getter,mutations,action,module，state属性用来存储公共管理的数据，mutations属性定义可以修改state中的数据，是同步修改的，所以不要在mutation中书写ajax代码，这样数据不可追踪，getters属性可以认为是定义store的计算属性。getter的返回值会根据他的依赖被缓存起来，且只有当他的依赖发生了改变才会被重新计算，action中进行异步操作，可以操作mutation来修改数据，mutation是修改数据的唯一方法。module可以将store分为多个模块，每个模块都有自己的mutation，state,getter,action,module。通过store.state可以获取state,可以用计算属性中的mapState,store.commit来提交mutation,可以使用mapMutation来映射多个mutation,store,dispatch来分发action,可以使用mapAction来映射多个action  ,获取getter可以使用store,getter,可以使用maGetter来映射多个getter</p><h4 id="8-说一说JavaScript有几种方法判断变量的类型？"><a href="#8-说一说JavaScript有几种方法判断变量的类型？" class="headerlink" title="8.说一说JavaScript有几种方法判断变量的类型？"></a>8.说一说JavaScript有几种方法判断变量的类型？</h4><p>typeof 可以用来判断基本数据类型  还可以判断Function ,其他引用数据类型都是返回Object,null也是返回object</p><p>constructor可以判断引用数据类型 就是判断instance.<strong>proto</strong>.constructor=Function</p><p>instanceOf也可以判断引用数据类型 单数不能判断基本数据类型，就是运用原型链，判断右边的原型是否在左边的原型链上</p><p>Object.prototype.toString.call也可以用来判断引用数据类型</p><h4 id="9-说一说样式优先级的规则是什么？"><a href="#9-说一说样式优先级的规则是什么？" class="headerlink" title="9.说一说样式优先级的规则是什么？"></a>9.说一说样式优先级的规则是什么？</h4><p>样式的优先级应该分为4大类</p><p>第一类 !important的优先级最高，无论是什么引用方式，什么选择器</p><p>第二类是引用方式  行内样式优先级高于嵌入样式和外部样式，如果嵌入样式和外部样式使用相同的选择器，则看他们谁后引入，被覆盖</p><p>第三类是选择器</p><p>id选择器&gt;类选择器，属性选择器，伪类选择器&gt;元素选择器，伪元素选择器&gt;通配符选择器</p><p>第四类是默认样式</p><p> important 10000<br> 内联选择器 1000<br> id选择器 100<br> 类选择器，属性选择器，伪类 10<br> 元素选择器，伪元素 1<br> 通配选择器  0</p><h4 id="10-说一说JS实现异步的方法？"><a href="#10-说一说JS实现异步的方法？" class="headerlink" title="10.说一说JS实现异步的方法？"></a>10.说一说JS实现异步的方法？</h4><p>得分点 回调函数、事件监听、setTimeout、Promise、生成器Generators/yield、async/await,</p><p>所有的异步代码都会在同步代码执行完后，从异步队列中取出依次执行。回调函数是最基本的异步函数，例如ajax请求，回调函数的有点是简单，容易理解和实现，缺点是不利于代码的阅读和理解，各个部分耦合度高，使得程序结构混乱，流程难以追踪(尤其是多个回调函数嵌套的情况，容易出现回调地狱)，而且每个任务只能指定一个回调函数，回调函数不能使用try..catch来捕获错误，不能直接·return  ,Promise包装了一个异步调用并且生成了一个promise实例，promise不经可以捕获错误，而且可以很好的解决回调地狱的问题，缺点是没办法取消promise,错误需要使用回调函数来捕获。generator函数是ES6提供的异步编程的解决方案，generator是一个状态机，封装了多个内部状态，可以暂停函数，yield可以暂停执行，next可以继续执行,每次返回都是yield的结果。优点是语义清晰，但是需要手动调用。async/await是基于Promises实现的，await会阻塞后面的代码的执行。如果多个异步代码没有依赖性却使用了await会降低性能</p><h4 id="11-说一说Vue2-0-双向绑定的原理与缺陷？"><a href="#11-说一说Vue2-0-双向绑定的原理与缺陷？" class="headerlink" title="11.说一说Vue2.0 双向绑定的原理与缺陷？"></a>11.说一说Vue2.0 双向绑定的原理与缺陷？</h4><p>Vue的响应式原理：采用数据劫持和发布者-订阅者模式相结合的方式，遍历对象中的属性使用Object.defineProperty劫持各个属性的getter和setter方法，在数据发生变化的时候，触发setter,进而调用对应的notify方法执行依赖该属性的函数，进而更新页面的DOM。读取该属性的时候会触发getter，使用Object.defineProperty不能够监听对象的新增属性和删除属性。不可以监听通过数组索引来修改数据，不能够修改length,而监听到变化</p><h4 id="12-说一说数组去重都有哪些方法？"><a href="#12-说一说数组去重都有哪些方法？" class="headerlink" title="12.说一说数组去重都有哪些方法？"></a>12.说一说数组去重都有哪些方法？</h4><p>方式一：使用new Set(arr)进行去重，然后再使用Array.from()或者扩展运算符转成数组</p><p>方式二:    使用filter+indexOf来去重</p><p>方式三:   使用双重for循环+splice来进行去重</p><p>方式四:   使用[]+indexOf来去重</p><p>方式五:   使用sort去重，先进行排序，然后再进行当前索引和下一个索引值进行比较，push进新的数组</p><p>方式六:   使用对象属性不能相同的特点去重，以数组每一个item作为object的key,通过for循环判断obj[arr[i]]是否存在，如果不存在则push,并且obj[arr[i]]=1,否则就是obj[arr[i]]++</p><p>方式七：使用includes来去重，可以区别Nan,可以判断新的数组中是否包含这个值，不包含就push</p><p>方式八：使用hasOwnProperty来去重</p><p>方式九：先进行排序，然后在进行递归，splices删除重复数据</p><p>方式十：使用Map数据结构来去重，通过has判断，如果为false就push，并且set值，</p><p>方式十一：使用reduce+includes来去重，判断pre中是否存在</p><h4 id="13-说一说null-和-undefined-的区别，如何让一个属性变为null"><a href="#13-说一说null-和-undefined-的区别，如何让一个属性变为null" class="headerlink" title="13.说一说null 和 undefined 的区别，如何让一个属性变为null"></a>13.说一说null 和 undefined 的区别，如何让一个属性变为null</h4><p><strong>得分点 操作的变量没有被赋值、全局对象的一个属性、函数没有return返回值、值 <code>null</code> 特指对象的值未设置 undefined == null、undefined !== null</strong> </p><p>一个变量定义了，但是没有进行初始化，那他的值就是undefined。函数没有指定return的值，默认就是undefined。对象中某个属性不存在就是undefined，函数定义了形参，但是没有定义默认参数，实参就是undefined,undefined可以通过typeof 来判断是否undefined,undefined==undefined,undefined===undefined。null就是对象的值未设置，一个对象没有设置指针地址就是null,null通过typeof判断类型是object,null==null,null===null,null==undefined,null!==undeined,undefined表示未设置值的默认状态，null表示手动设置为空对象，儿不是默认状态，在实际使用过程中，变量不需要手动的赋值undefined,如果需要手动的释放对象，可以赋值null,typeof会判断为object,是因为js数据类型在底层都是以二进制的形式表示的，二进制的前三位为0会被typeof判断为objet,而null的二进制全是0，当对象被赋值为0以后就会被垃圾回收器择机回收并且释放内存</p><h4 id="14-说一下浮动"><a href="#14-说一下浮动" class="headerlink" title="14.说一下浮动"></a>14.说一下浮动</h4><p>float属性可以指定一个元素向左或者向右浮动，浮动元素会脱离标准流</p><p>浮动规则一</p><p>​    元素一旦浮动后，脱离标准流</p><p>​            朝着向左或者向右方向移动，直到自己的边界紧贴者包含块(一般是父元素)或者其他浮动元素的边界为止</p><p>​            定位元素会层叠在浮动元素上面</p><p>浮动规则二</p><p>​    如果元素是向左或者向右浮动，浮动的元素的左右边界不能超过包含快的左右边界</p><p>浮动规则三</p><p>​    浮动元素之间不能够层叠，如果一个元素浮动，后面的元素会紧挨着前面的浮动元素排列，如果剩下的空间不够放下一个浮动元素则会向下移动，找到可以放下的空间</p><p>浮动规则四</p><p>​    浮动元素不能与行内级内容层叠，行内级内容会被推出去</p><p>浮动规则五</p><p>​    行内级元素，inline-block元素浮动后，其顶部将与所在行的顶部对齐</p><p>浮动的问题</p><p>​    由于浮动的元素脱离了标准流·，变成了脱标元素，所以不在向父元素汇报高度，父元素计算高度的时候不计算浮动元素的高度，所以会造成内容塌陷</p><p>解决高度塌陷的方法</p><p>​    方法一，给父元素设置固定高度。扩展性不好</p><p>​    方法二，给父元素最后添加一个空的块级元素，并且设置为clear:both。这样会增加无意义的空标签，维护麻烦，违反了结构与样式分离的原则</p><p>​    方式三，给父元素添加一个伪元素，::after,设置content:””,display:block，overflow:hidden,clear:both,visibility:hidden,height:0,   为了兼容IE6/7还要加上*zoom:1</p><h4 id="15-说一说es6中箭头函数？"><a href="#15-说一说es6中箭头函数？" class="headerlink" title="15.说一说es6中箭头函数？"></a>15.说一说es6中箭头函数？</h4><p>箭头函数中没有this,箭头函数中的this指向是由上层作用域的中非箭头函数this决定的，箭头函数中没有arguments,如果箭头函数中出现arguments，则由上层作用域非箭头函数的arguments决定，箭头函数中arguments可以使用rest参数替代，箭头函数不可以作为构造函数，没有super()和原型,箭头函数不可以使用call,apply,bind显示绑定来改变this的指向，箭头函数不可以作为generator函数。箭头函数不能作为事件绑定的回调函数，如果使用了this，该this不会指向触发事件的元素，而是指向window。箭头函数适用于需要引用上层作用域的this,可以替代var _this=this,或者没有使用到this的函数</p><h4 id="16-说一说call-apply-bind的作用和区别？"><a href="#16-说一说call-apply-bind的作用和区别？" class="headerlink" title="16.说一说call apply bind的作用和区别？"></a>16.说一说call apply bind的作用和区别？</h4><p>call,apply,bind可以显示进行this的绑定，call可以传多个参数，并且立即执行函数，apply第二个参数传的是函数，也是会立即执行，bind可以传多个参数，并且会返回新的函数，call,apply还可以用于函数的执行。call,apply可以用于对象的继承，将伪数组转成真数组，进行原型链方法的借调，等等，bind可以用于react中this的绑定</p><h4 id="17-说一说this指向（普通函数、箭头函数）？"><a href="#17-说一说this指向（普通函数、箭头函数）？" class="headerlink" title="17.说一说this指向（普通函数、箭头函数）？"></a>17.说一说this指向（普通函数、箭头函数）？</h4><p>默认绑定this是指向全局window，普通函数的调用</p><p>隐式绑定this是指向调用的对象，对象调用方法时</p><p>显示绑定this指向绑定的值</p><p>new绑定this指向新创建的对象</p><p>箭头函数中没有this,this是由上层作用域中非箭头函数决定的</p><p>在严格模式下，this默认是undefined</p><p>默认绑定的优先级最低</p><p>显示绑定的优先级高于隐式绑定</p><p>new绑定的优先级高于bind</p><p>new绑定优先级高于隐式绑定</p><p>bind的优先级高于call/apply</p><p>new不可以和call/apply一起使用</p><p>setTimeout中this默认指向window</p><p>事件绑定中this指向绑定的元素</p><h4 id="18-说一说CSS尺寸设置的单位"><a href="#18-说一说CSS尺寸设置的单位" class="headerlink" title="18.说一说CSS尺寸设置的单位"></a>18.说一说CSS尺寸设置的单位</h4><p>px是绝对长度单位，em,rem,vw/vh是相对长度单位</p><p>em是在font-size中默认使用相对于父元素的字体大小,如果自己定义了font-size,则根据自身的font-size进行定义，其他属性也是相对于自身的font-size,</p><h4 id="19-说一说HTML语义化？"><a href="#19-说一说HTML语义化？" class="headerlink" title="19.说一说HTML语义化？"></a>19.说一说HTML语义化？</h4><h4 id="20-说几个未知宽高元素水平垂直居中方法"><a href="#20-说几个未知宽高元素水平垂直居中方法" class="headerlink" title="20.说几个未知宽高元素水平垂直居中方法"></a>20.说几个未知宽高元素水平垂直居中方法</h4><h4 id="21-说一说JS变量提升？"><a href="#21-说一说JS变量提升？" class="headerlink" title="21.说一说JS变量提升？"></a>21.说一说JS变量提升？</h4><p>函数和var 声明的变量在代码编译阶段会提升到最前面，但此时var声明的变量还没有赋值，所以此时访问是undefined,而函数可以在函数定义之前被调用，因为函数是一等公民，函数声明的提升优先级会比变量提升高，let,const不会出现变量提升，let const在定义以前访问会出现暂时性死区</p><h4 id="22-说一说-HashRouter-和-HistoryRouter的区别和原理？"><a href="#22-说一说-HashRouter-和-HistoryRouter的区别和原理？" class="headerlink" title="22.说一说 HashRouter 和 HistoryRouter的区别和原理？"></a>22.说一说 HashRouter 和 HistoryRouter的区别和原理？</h4><p>HashRouter  和 HistoryRouter都是利用浏览器的两种特性来实现前端路由的，根据这两种特性，可以实现不需要刷新页面的去修改内容。HashRouter就是利用通过监听window.onhashchange根据location.hash的变化来修改Dom,url中hashRouter和historyRouter的不同是，hash会在url中有#这样的hash值，而history没有。historyRouter是根据h5新增的历史调用栈API来实现的，他有六种模式来改变url而不会重新刷新页面</p><p>history.replaceState():替换原来的路径</p><p>history.pushState() 使用新的路径</p><p>history.popState()  路径的回退</p><p>history.back() 向后改变路径</p><p>history.go() 跳转至那个路径</p><p>通过window.onpopState来监听浏览器的前进和后退，pushState和replaceState都是可以携带参数，hash可以兼容低版本的浏览器，如果想传递任意类型的数据到记录栈可以使用history,history需要后端配合，如果后端不配合，就会出现404，而hash不需要</p><h4 id="23-说一说map-和-forEach-的区别？"><a href="#23-说一说map-和-forEach-的区别？" class="headerlink" title="23.说一说map 和 forEach 的区别？"></a>23.说一说map 和 forEach 的区别？</h4><p>得分点 map创建新数组、map返回处理后的值、forEach()不修改原数组、forEach()方法返回undefined</p><p>map会返回新的数组，forEach不会修改原来的数组，map需要return foreach不需要return,foreach中return是无效的，map中this默认指向undefined,foreach中this默认指向window,forEach不能终端执行，只能够抛出异常来终止执行。forEach没有返回值新的数组所以不能够进行链式调用，map的处理数组比foreach快</p><h4 id="24-说一说事件循环Event-loop，宏任务与微任务？"><a href="#24-说一说事件循环Event-loop，宏任务与微任务？" class="headerlink" title="24.说一说事件循环Event loop，宏任务与微任务？"></a>24.说一说事件循环Event loop，宏任务与微任务？</h4><p>js代码执行过程中，同步代码先执行，要到定时器，就会先将定时器先挂起，继续向下执行，执行到异步代码，就会将异步代码进入事件队列，宏任务就会进入宏任务队列，微任务就是进入微任务事件队列，同步代码执行完后，就会从事件队列中取出异步代码，进入执行上下文调用栈，微任务先执行，执行完后在执行宏任务，等定时器到期之后也会加入到事件队列，就这样不断的循环往复执行，就是事件循环，事件循环包括浏览器的事件循环和Node的事件循环，浏览器的事件循环中宏任务包括定时器，ajax请求，window.postmessage,setImmediate,UI render,Dom监听，微任务包括promise的then回调，async/await,Mutation Obderver，queueMicrotask。Node的事件循环中微任务为process.nexttick,promise的then回调，queueMicrotask,宏任务队列包括，定时器，ID事件，setImmediate,close事件</p><h4 id="25-说一说Vue3-0-实现数据双向绑定的方法-？"><a href="#25-说一说Vue3-0-实现数据双向绑定的方法-？" class="headerlink" title="25.说一说Vue3.0 实现数据双向绑定的方法 ？"></a>25.说一说Vue3.0 实现数据双向绑定的方法 ？</h4><p>vue3中实现数据双向绑定采用new Proxy来替代Object.defineProperty实现，proxy可以监听整个对象，使用new proxy()将需要监听的对象作为参数传递，并且有13中拦截器，可以对对象以及函数进行监听，例如监听对象属性的getter,setter,delete操作,in操作，defineProperty操作等，可以解决object.defineproperty不可以监听对象属性的新增和删除操作，不可以监听数组通过索引赋值，和手动给length赋值等操作</p><h4 id="26-说一下Diff算法？"><a href="#26-说一下Diff算法？" class="headerlink" title="26.说一下Diff算法？"></a>26.说一下Diff算法？</h4><p>得分点 patch、patchVnode、updateChildren、vue优化时间复杂度为O(n) </p><p>diff算法中的比较过程，第一步：patch函数首先会对新旧节点进行比较，如果旧的节点存在且和新的节点类型不同，则会销毁旧的节点。如果旧节点存在，如果新旧节点类型相同时，然后对新的节点的类型进行判断，如果是文本节点，则直接替换成文本节点，如果是注释节点也是直接的插入。处理静态节点，处理fragment组件节点等，然后就是处理普通的Dom元素和组件节点等等，在处理普通元素的时候，他会先判断旧节点是否存在，不存在则直接挂在。否则调用patchElement函数。在执行patchElement的时候首先处理props的情况，先将新的节点的props全部挂载到el上，判断旧节点的props是否不需要在新的节点上，如果不需要，那么删除对应的属性。然后通过调用patchChildren来对比子元素，如果新的节点是一个字符串类型，则直接调用el.textContent=newChildren,如果新节点不是字符串类型，旧节点是字符串类型，那么直接遍历新的节点，挂载到el上，如果新旧节点都是数组，则会分为有key和没有key两种，有key则调用patchKeyedChildren方法，没有key则调用patchUnkeyedChildren方法。调用patchUnkeyedChildren方法时，会获取到长度最小的那个节点，for循环依次进行patch，patch完之后，剩下的节点，如果旧的长度大于新的，则移除这些节点，如果新的长度大于旧的长度则创建新的节点，如果有key则会调用patchKeyedChildren方法，首先节点会从头部开始比较，如果两个节点相同则会调用patch,并且i++,如果节点不同则会跳出循环，然后再从尾部进行比较，重复相同的步骤，并且e1–,e2–,如果i&gt;e1而且i&lt;e2,就是旧的节点遍历完了，依然有新的节点，则进行挂载，如果新的节点遍历完，旧的节点还有则移除旧的节点。对于剩下的未知的序列，就是无须的序列，首先会根据key建立map索引图， 遍历剩下的旧节点, 新旧对比, 移除不使用的旧节点，oldIndex = 0 是一个特殊值，表示新节点没有对应的旧节点。用于确定最长稳定子序列，建立新的vnode的key的位置在旧的vnode的映射，然后for遍历旧节点中还没有被对比的节点，如果该节点已经被patch过，则卸载掉，如果在旧的vnode中key存在，在获取相同的key在新vnode的位置，如果存在，则新节点在旧节点的映射中设置所以旧节点的索引位置，然后进行新旧节点的patch,如果在旧node中key不存在，试图定位一个相同类型的没有key的节点的位置，准备用这个替换成新的值，从新结点中找到类型相同，且在旧节点没有对应映射的节点，设置进去，如果在新的vnode中没有对应的映射，就是在新的vnode中不存在这个key了，就卸载掉</p><h4 id="27-说一说三栏布局的实现方案"><a href="#27-说一说三栏布局的实现方案" class="headerlink" title="27.说一说三栏布局的实现方案"></a>27.说一说三栏布局的实现方案</h4><p>圣杯布局，双飞翼布局</p><h4 id="28-说一下浏览器垃圾回收机制？"><a href="#28-说一下浏览器垃圾回收机制？" class="headerlink" title="28.说一下浏览器垃圾回收机制？"></a>28.说一下浏览器垃圾回收机制？</h4><h4 id="29-说一说-vue-的-keep-alive-？"><a href="#29-说一说-vue-的-keep-alive-？" class="headerlink" title="29.说一说 vue 的 keep-alive ？"></a>29.说一说 vue 的 keep-alive ？</h4><h4 id="30-CSRF攻击是什么？"><a href="#30-CSRF攻击是什么？" class="headerlink" title="30.CSRF攻击是什么？"></a>30.CSRF攻击是什么？</h4><h4 id="31-XSS攻击是什么？"><a href="#31-XSS攻击是什么？" class="headerlink" title="31.XSS攻击是什么？"></a>31.XSS攻击是什么？</h4><h4 id="32-说一说js继承的方法和优缺点？"><a href="#32-说一说js继承的方法和优缺点？" class="headerlink" title="32.说一说js继承的方法和优缺点？"></a>32.说一说js继承的方法和优缺点？</h4><h4 id="33-说一说defer和async区别？"><a href="#33-说一说defer和async区别？" class="headerlink" title="33.说一说defer和async区别？"></a>33.说一说defer和async区别？</h4><p>默认情况下浏览器下载完js代码会立即执行，如果js需要操作dom,则会阻塞页面的渲染，async属性可以使加载js文档和dom树的构建同时进行，当js加载完成，js代码执行，会阻塞html的渲染，defer会等到dom构建完成以后再加载js代码。</p><p>defer是js的下载和执行不阻塞DOM tree的构建，defer中的js代码执行的时候Dom构建完成，defer会在DomcontenLoad之后执行，多个设置defer的script会按顺序加载，defer仅适用于外部脚本，对script的内容会忽略。而async不能保证顺序执行，不会阻塞DOM渲染，不能保证DOMContentLoaded之前或者之后执行，async用于独立脚本执行，就是那些不需要依赖外部文件的脚本</p><p>加分项：阻塞的原因：由于js是可以操作dom的，如果在修改这些元素的时候同时渲染界面即js线程和ui线程同时运行，那么渲染线程前后获得的数据可能不一致，因此为了防止渲染出现不可以预测的效果，所以浏览器设置GUI渲染线程和js引擎为互斥的关系当浏览器执行js代码的时候渲染线程就会被保存在一个队列中，直到js程序执行完成才会接着执行。如果js执行事件过长，就会造成渲染界面过程不连贯，导致页面渲染加载阻塞的感觉</p><h4 id="34-说一下浏览器如何渲染页面的"><a href="#34-说一下浏览器如何渲染页面的" class="headerlink" title="34.说一下浏览器如何渲染页面的"></a>34.说一下浏览器如何渲染页面的</h4><p>浏览器首先会解析页面，把html构建成DOM树，css构建成cssom树，css的加载不会阻塞dom树的构建，然后将dom树和cssom树整合成render树，如果加载到script标签，会阻塞页面的渲染进程，所以需要把script放在底部，然后执行js代码，经过布局和绘制，最终渲染到屏幕上</p><h4 id="35-说一说vue-computed和watch的区别？"><a href="#35-说一说vue-computed和watch的区别？" class="headerlink" title="35.说一说vue computed和watch的区别？"></a>35.说一说vue computed和watch的区别？</h4><p>当需要依赖其他状态来产生新的状态的时候，可以使用computed,computed适用于计算比较多的场景。computed依赖于其他状态，computed是同步的，而且有缓存，如果依赖的状态没有发生变化，他不会重新计算，computed默认是调用getter方法，也可以修改数据调用setter方法，watch是作为侦听器，可以监听data，props,emit等属性的变化，也是有惰性的，watch在数据初始化的时候不会执行，只有在数据变化的时候才会执行，可以设置immediate:true来让watch立即执行一次，watch默认不能够监听对象的属性的变化，可以设置deep:true,对对象进行深度监听</p><h4 id="36-说一说-Vue-中-nextTick-作用与原理？"><a href="#36-说一说-Vue-中-nextTick-作用与原理？" class="headerlink" title="36.说一说 Vue 中 $nextTick 作用与原理？"></a>36.说一说 Vue 中 $nextTick 作用与原理？</h4><p>得分点 异步渲染、获取DOM、Promise </p><p>将回调延迟到下一次DOM更新循环之后执行，在修改数据之后立即执行它，然后等待DOM更新</p><p>ue更新DOM是异步执行的，在修改数据后，视图不会立刻更新，而是等待同一事件循环中所有数据变化之后，同意更新视图，所以修改完数据，立刻获得的是未修改的dom,nextTrick就可以在DOM更新之后执行回调函数，解决异步渲染不可以获取到更新之后的DOM的问题，nextTick会返回一个promise,所以可以使用async/await</p><p>应用场景：在钩子函数created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中</p><h4 id="37-说一说new会发生什么？"><a href="#37-说一说new会发生什么？" class="headerlink" title="37.说一说new会发生什么？"></a>37.说一说new会发生什么？</h4><ol><li>创建一个空对象</li><li>让这个空对象的[[prototype]]属性指向构造函数的prototype</li><li>让构造函数中的this指向新创建的对象</li><li>执行该构造函数</li><li>如果构造函数没有返回对象则返回新创建的对象</li></ol><h4 id="38-说一下token-能放在cookie中吗？"><a href="#38-说一下token-能放在cookie中吗？" class="headerlink" title="38.说一下token 能放在cookie中吗？"></a>38.说一下token 能放在cookie中吗？</h4><p>得分点 能、不设置cookie有效期、重新登录重写cookie覆盖原来的cookie </p><p>token一般用来判断用户是否登录，它内部包含的信息包括uid(用户唯一的身份标识)，time(当前的时间戳)，sign(签名，token的前几位是以哈希算法压缩成的一定长度地十六进制字符串)，token可以存放在cookie，token是否过期由后端决定，所以token存储在cookie中只要不设置cookie的过期时间就可以，如果token失效，只要返回固定状态表示token失效，需要重新登录，重新设置cookie中的token就可以了，</p><h4 id="39-说一下浏览器输入URL发生了什么？"><a href="#39-说一下浏览器输入URL发生了什么？" class="headerlink" title="39.说一下浏览器输入URL发生了什么？"></a>39.说一下浏览器输入URL发生了什么？</h4><h4 id="40-说一说组件通信的方式？"><a href="#40-说一说组件通信的方式？" class="headerlink" title="40.说一说组件通信的方式？"></a>40.说一说组件通信的方式？</h4><h4 id="41-说一说-v-if-和-v-show区别？"><a href="#41-说一说-v-if-和-v-show区别？" class="headerlink" title="41.说一说 v-if 和 v-show区别？"></a>41.说一说 v-if 和 v-show区别？</h4><p>v-if是条件渲染，是惰性的，只有在条件判断为true的时候才会渲染到页面中去，v-show相当于设置display来进行切换，所有v-if有更高的切换开销，v-show有更高的切换开销，如果需要频繁切换，需要使用v-show，v-else和template不可以用于v-show，v-show无论如何它的DOM实际上都是存在的，只是通过CSS来切换display属性，当v-if当条件为false时，其对应的元素不会渲染到DOM中</p><h4 id="42-React生命周期的各个阶段是什么？"><a href="#42-React生命周期的各个阶段是什么？" class="headerlink" title="42.React生命周期的各个阶段是什么？"></a>42.React生命周期的各个阶段是什么？</h4><h4 id="43-React组件间传值的方法有哪些？"><a href="#43-React组件间传值的方法有哪些？" class="headerlink" title="43.React组件间传值的方法有哪些？"></a>43.React组件间传值的方法有哪些？</h4><p>父组件向子组件传值是使用props进行传递，</p><p>子组件向父组件传值，可以使用回调函数，父组件向子组件传递回调函数，子组件执行回调函数并传递参数</p><p>子孙组件之间的传递可以使用createContext()</p><p>兄弟组件间的数据传递可以使用事件总线来传递</p><p>还可以使用redux进行全局状态管理</p><h4 id="44-说一说盒模型？"><a href="#44-说一说盒模型？" class="headerlink" title="44.说一说盒模型？"></a>44.说一说盒模型？</h4><p>盒模型分为IE的盒模型和W3C的盒模型，W3C的盒模型指的是content的宽高，IE的盒模型是将content,padding,margin包含在宽度和高度之内，可以使用css ,box-sizing:border-box来将W3C的盒模型转换成IE盒模型，默认是content-box</p><h4 id="45-说一说伪数组和数组的区别？"><a href="#45-说一说伪数组和数组的区别？" class="headerlink" title="45.说一说伪数组和数组的区别？"></a>45.说一说伪数组和数组的区别？</h4><p>得分点 类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历</p><p>数组的类型是Array,类数组的类型是object,类数组可以使用length查看长度，可以使用索引来获得值，但是不可以修改length,不能使用array的方法，可以使用forin进行遍历，类数组常用的场景：函数参数argumenrs,NodeList等，类数组转成数组方法，Array.from(arr),Array.prototype.slice.call(arr),索引不连续时会自动补位</p><h4 id="46-说一说如何实现可过期的localstorage数据？"><a href="#46-说一说如何实现可过期的localstorage数据？" class="headerlink" title="46.说一说如何实现可过期的localstorage数据？"></a>46.说一说如何实现可过期的localstorage数据？</h4><h4 id="47-说一说axios的拦截器原理及应用？"><a href="#47-说一说axios的拦截器原理及应用？" class="headerlink" title="47.说一说axios的拦截器原理及应用？"></a>47.说一说axios的拦截器原理及应用？</h4><h4 id="48-说一说创建ajax过程？"><a href="#48-说一说创建ajax过程？" class="headerlink" title="48.说一说创建ajax过程？"></a>48.说一说创建ajax过程？</h4><h4 id="49-说一下fetch-请求方式？"><a href="#49-说一下fetch-请求方式？" class="headerlink" title="49.说一下fetch 请求方式？"></a>49.说一下fetch 请求方式？</h4><h4 id="50-说一下有什么方法可以保持前后端实时通信？"><a href="#50-说一下有什么方法可以保持前后端实时通信？" class="headerlink" title="50.说一下有什么方法可以保持前后端实时通信？"></a>50.说一下有什么方法可以保持前后端实时通信？</h4><h4 id="51-说一下重绘、回流区别如何避免？"><a href="#51-说一下重绘、回流区别如何避免？" class="headerlink" title="51.说一下重绘、回流区别如何避免？"></a>51.说一下重绘、回流区别如何避免？</h4><p>对节点的大小，位置的修改重新计算被称为回流，例如DOM结构的改变(添加新的节点或者删除节点)</p><p>改变布局，例如修改了width,height,padding,font-size等值</p><p>窗口resize、(修改了窗口的尺寸)</p><p>调用getComputedStyle方法获取尺寸，位置信息等</p><p>修改背景色，字体颜色，边框颜色，边框样式等，</p><p>回流一定会引起重绘，重绘不一定会引起回流，所以应该减少回流</p><p>1.修改样式尽量一次性修改，例如通过cssText,classList,class来修改</p><p>2.避免频繁的操作DOM，可以是用document.documentFragment批量修改片段</p><p>3.避免使用getComputedStyle频繁获取计算值，如果需要，可以将计算值存储起来</p><p>4.修改DOM可以先设置diaplay:none，是他不存在render树，再进行修改，修改完成后再加入render树中</p><p>5.对某些元素使用position:absolute,fixed使其脱离标准流，这样开销会比较小</p><p>6.默认情况下，标准流中的内容都会被绘制在同一个图层上，利用一些属性创建一个新的合成图层，这些layer可以使用GPU加速绘制，因为这些图层都是单独渲染，减少了回流和重绘，例如3d transform,vedio,canvas,iframe,opacity动画转换，position:fixed,animation或者transition设置了opacity,transorm.分层确实可以提高性能，但是不要过度使用，她是以内存为代价的</p><h4 id="52-说一说-Vue-列表为什么加-key？"><a href="#52-说一说-Vue-列表为什么加-key？" class="headerlink" title="52.说一说 Vue 列表为什么加 key？"></a>52.说一说 Vue 列表为什么加 key？</h4><p>得分点 性能优化、diff算法节点比对、key不能是index</p><p>key属性主要时用在Vue的虚拟DOM算法，在新旧Vnode对比时辨识vnodes,如果不使用key,vue会使用一种最大限度减少动态元素并且尽可能减少的尝试就地修改/复用相同类型元素的算法，而使用key，他会基于key的变化重新排列元素顺序，并且移除或者销毁不需要的元素</p><p>相同的父元素的子元素的key必须唯一，如果有重复的可以会渲染错误</p><p>如果使用index作为key,没有优化效果，因为index会改变</p><p>它也可以用于强制替换元素或者组件而不是重复使用它时。当你遇到如下场景时它可能会很有用：</p><ul><li><p>完整地触发组件的生命周期钩子</p></li><li><p>触发过渡</p></li></ul><h4 id="53-说一说vue-router-实现懒加载的方法？"><a href="#53-说一说vue-router-实现懒加载的方法？" class="headerlink" title="53.说一说vue-router 实现懒加载的方法？"></a>53.说一说vue-router 实现懒加载的方法？</h4><div class="code-wrapper"><pre><code class="hljs livescript">vue实现懒加载的两种方法component：resolve=&gt;<span class="hljs-built_in">require</span>([<span class="hljs-string">&quot;./app.vue&quot;</span>],resolve)component:()i=&gt;<span class="hljs-keyword">import</span>(<span class="hljs-comment">/*webpackChunkName:app*/</span><span class="hljs-string">&quot;./app.vue&quot;</span>)webpackChunkName可以不写不要在路由中使用异步组件。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。webpack会进行代码分隔，进行独立打包，当使用道德时候才会加载，vue-router只会第一次加载时获取，以后都会使用缓存</code></pre></div><h4 id="55-ReactRouter基本用法是什么？"><a href="#55-ReactRouter基本用法是什么？" class="headerlink" title="55.ReactRouter基本用法是什么？"></a>55.ReactRouter基本用法是什么？</h4><h4 id="56-setState是同步还是异步的？"><a href="#56-setState是同步还是异步的？" class="headerlink" title="56.setState是同步还是异步的？"></a>56.setState是同步还是异步的？</h4><p>setState在组件生命周期或者react合成事件中，setState是异步的</p><p>在原生的dom事件中，setTimeout中，setState是同步的</p><p>setState设计为异步，可以显著提升性能，如果每次调用setState都进行更新，那么意味着render函数会被频繁的调用，页面会重新渲染，这样效率很低，最好的办法因该是活得多个更新，然后进行批量更新，</p><p>如果同步进行更新state,但是还没有执行render函数，那么state,props不能保持同步，state和props不一致，在开发中会产生很多问题</p><h4 id="57-React事件绑定原理"><a href="#57-React事件绑定原理" class="headerlink" title="57.React事件绑定原理"></a>57.React事件绑定原理</h4><p>得分点 非原生事件、SyntheticBaseEvent </p><p>React中的事件不是原生的事件，而是对原生的event进行封装的新类SyntheticBaseEvent，模拟处DOM事件的所有功能,通过event.nativeEvent可以获得原生事件，react将所有的事件都绑定在root根组件上，之前都是绑定在document上的，react中的事件和DOM事件不一样，和vue也不一样，react并不是将click事件绑定在该div的真实DOM上，而是在root处监听所有支持的事件，当事件发生并冒泡到root处时，react将事件内容封装并交给真正的处理函数运行，这样的方式不仅减少了内存的消耗，还能再组件挂载销毁时统一订阅和移除事件，另外冒泡到root上的事件也不是原生浏览器事件，而是React自己实现的合成事件(SyntheticBaseEvent),因此我们如果不想要事件冒泡的话，调用event.stopPropagation是无效的，应该调用event.preventDefault</p><h4 id="58-React中hooks的优缺点是什么？"><a href="#58-React中hooks的优缺点是什么？" class="headerlink" title="58.React中hooks的优缺点是什么？"></a>58.React中hooks的优缺点是什么？</h4><h4 id="59-说一说前端性能优化手段？"><a href="#59-说一说前端性能优化手段？" class="headerlink" title="59.说一说前端性能优化手段？"></a>59.说一说前端性能优化手段？</h4><h4 id="60-说一说性能优化有哪些性能指标，如何量化？"><a href="#60-说一说性能优化有哪些性能指标，如何量化？" class="headerlink" title="60.说一说性能优化有哪些性能指标，如何量化？"></a>60.说一说性能优化有哪些性能指标，如何量化？</h4><h4 id="61-说一说服务端渲染？"><a href="#61-说一说服务端渲染？" class="headerlink" title="61.说一说服务端渲染？"></a>61.说一说服务端渲染？</h4><h4 id="62-事件扩展符用过吗-…-，什么场景下？"><a href="#62-事件扩展符用过吗-…-，什么场景下？" class="headerlink" title="62.事件扩展符用过吗(…)，什么场景下？"></a>62.事件扩展符用过吗(…)，什么场景下？</h4><p>1.在数组调用时可以替代数组的apply方法</p><p>2.用于合并数组</p><p>3.与解构赋值相结合，生成新的数组</p><p>4.将字符串转成数组</p><p>5.任何iterator对象，都可以通过展开运算符转成数组</p><p>6.用于数组的浅拷贝</p><p>7.构造字面量对象可以使用展开语法</p><p>8.在 new 表达式中应用，使用 <code>new</code> 关键字来调用构造函数时，不能<strong>直接</strong>使用数组 + <code>apply</code> 的方式（<code>apply</code> 执行的是调用 <code>[[Call]]</code> , 而不是构造 <code>[[Construct]]</code>），可以使用展开语法替代</p><h4 id="63-说一说vue钩子函数？"><a href="#63-说一说vue钩子函数？" class="headerlink" title="63.说一说vue钩子函数？"></a>63.说一说vue钩子函数？</h4><p>组件从创建，挂载，更新，销毁的全过程就是vue的声明周期，包括beforeCreate,created,beforemount,mounted,beforeUpdate,updated,beforeumount,umouted,</p><p>beforeCreate钩子函数会在实例初始化之后，进行数据侦听和事件/侦听器的配置之前同步调用，</p><p>created钩子函数会在组件实例被创完成后被立即同步调用，此时$watch,computed,method,data等属性可以被调用，但是挂载阶段还没开始，所以$el属性还不可以使用，</p><p>beforeMount钩子函数被调用时，该钩子函数会在挂载前调用，render函数首次被调用，在服务器端渲染期间不会被调用</p><p>mounted钩子函数被调用时，在实例挂载完成后调用，这时候传给app.mount的元素已经被新创建的vm.$el替换，mounted不会保证所有子组件都被挂载完成。如果想执行在这个视图渲染完毕后执行代码，可以在mounted内部使用vm.$nextTick</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 仅在整个视图都被渲染之后才会运行的代码</span>  &#125;)&#125;</code></pre></div><p>该钩子函数不会再服务端渲染时调用</p><p>beforeUpdate钩子函数是在数据发生变化之后DOM更新之前调用，适合在DOM更新之前访问它，例如移除手动添加的事件监听器。<strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。</strong></p><p>updated钩子函数会在数据更新之后虚拟DOM重新渲染完毕之后被调用，此时DOM已经更新完毕可以进行DOM操作，但是不建议下该狗子中进行状态的改变，通常使用watch或者computed来进行状态监听，updated不能保证子组件已经挂载完成，如果想要在组件完全渲染以后操作可以使用vm.$nextTick.该钩子函数不能用于服务端。</p><p>activited钩子函数</p><p>该钩子会被keep-alive缓存的组件激活时调用，该钩子在服务器管渲染期间不被调用</p><p>deactivated钩子函数会在被keep-alive缓存的组件失活时调用，在服务端不可用</p><p>beforeMount钩子函数会在组件卸载之前调用，在这个时候1可以解除对事件的监听，<strong>该钩子在服务器端渲染期间不被调用。</strong></p><p>mounted钩子函数调用时，组件已经卸载完成，指令和监听器都卸载完成，<strong>该钩子在服务器端渲染期间不被调用。</strong></p><p>父子组件的声明周期</p><p>挂载阶段</p><p>父beforeCreate-&gt;父created-&gt;父beforMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p>更新阶段</p><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p>销毁阶段</p><p>父beforeDestory-&gt;子deforeDestory-&gt;子destoryed-&gt;父destoryed</p><h4 id="64-vue生命周期的源码实现"><a href="#64-vue生命周期的源码实现" class="headerlink" title="64.vue生命周期的源码实现"></a>64.vue生命周期的源码实现</h4><h4 id="65-nexttick源码"><a href="#65-nexttick源码" class="headerlink" title="65.nexttick源码"></a>65.nexttick源码</h4><h4 id="66-v8垃圾回收"><a href="#66-v8垃圾回收" class="headerlink" title="66.v8垃圾回收"></a>66.v8垃圾回收</h4><h4 id="68-计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？"><a href="#68-计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？" class="headerlink" title="68.计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？"></a>68.计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？</h4><h4 id="69-进程与线程的区别？（暂定）"><a href="#69-进程与线程的区别？（暂定）" class="headerlink" title="69.进程与线程的区别？（暂定）"></a>69.进程与线程的区别？（暂定）</h4><ol><li>一个线程属于一个进程，而一个进程可以有多个线程，但至少有一个线程，线程依赖进程的存在</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存</li><li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li><li>进程的切换开销远大于线程的切换开销</li><li>进程间的通信IPC，线程间可以直接写进数据段(如全局变量)来进行通信–需要进程同步和互斥手段的辅助，以保证数据的一致性</li><li>进程编程调试简单可靠性高，但是创建销毁开销大，线程正好相反，开销小，切换速度快，但是编程调试相对复杂</li><li>进程间不会相互影响，一个线程挂掉会导致整个进程挂掉</li><li>进程适合多核，多机分布，线程适用于多核</li></ol><p>进程：我们可以认为，启动一个应用程序，就会默认启动一个进程(也可能是多个进程)</p><p>线程：每一个进程中，都会启动至少一个线程用来执行程序中的代码，这就主线程，所以说进程是线程的容器</p><p>操作系统类似于一个大工厂，工厂中有很多车间，这个车间就是进程，每个车间有可能有一盒以上的工人在工厂，这个工人就是线程</p><p>js是单线程的，js线程有自己的容器进程，浏览器或者node</p><h4 id="70-基本数据类型之间的转换"><a href="#70-基本数据类型之间的转换" class="headerlink" title="70.基本数据类型之间的转换"></a>70.基本数据类型之间的转换</h4><p>1.console.log(null==undefined)//true<br>2.非空字符串通过Boolean()转成true,空字符串转成false，对于Number类型，非0数字都会转成true,0,NaN会转成false,对象都会被转成true,undefined会被转成false，if条件判断会自动转成boolean进行判断，使用!!也可以进行隐式转换<br>3.数值类型的转换，可以通过Number(),parseInt(),parseFloat()三个函数显示的进行转换，Number()可以用于任何数据类型，parseInt和parseFloat主要用于字符串，Number()进行类型转换时，<br>boolean值false会转成0，true会转成1，null会转成0，undefined会返回NaN,对于字符串的转换，如果字符串中只包含数字则会转换成十进制的数字，如果字符串中包含浮点数，则会转成浮点数，如果包含十六进制的字符串则会转成十进制的数字，如果是空字符串则会转成0，如果字符串中包含其字符，则会转成NaN。对象会先调用valueOf按照上述方式进行转换，如果是NaN则会再调用toString再进行上述的转换。<br>使用parseInt进行类型转换时，他会从第一个非空格的字符进行转换，如果第一个字符不是加减，数字字符，则会转成NaN,空字符串也会转成NaN,如果第一个字符时加减，数字则会一直到非数字字符位置，parseInt会进行截断字符，如果是浮点数字符串，则会遇到.就会截断<br>parseFloat只能解析十进制，会忽略第二个.他会忽略字符转以0开头的值<br>4.转成字符串，+””就可以变成字符串，也可以调用toString来转换，除了null和undefined都可以toString，使用String()也可以转成字符转，有toString则会调用这个方法，null则会装成”null”,undefined=&gt;’undefined’</p><h4 id="71-webpack-的-plugin-和-loader-的区别和原理"><a href="#71-webpack-的-plugin-和-loader-的区别和原理" class="headerlink" title="71.webpack 的 plugin 和 loader 的区别和原理"></a>71.webpack 的 plugin 和 loader 的区别和原理</h4><h4 id="72-静态资源一般采取什么缓存策略？"><a href="#72-静态资源一般采取什么缓存策略？" class="headerlink" title="72.静态资源一般采取什么缓存策略？"></a>72.静态资源一般采取什么缓存策略？</h4><p>强缓存和协商缓存</p><h4 id="73-移动端300ms的延迟问题，问什么会有这个问题"><a href="#73-移动端300ms的延迟问题，问什么会有这个问题" class="headerlink" title="73.移动端300ms的延迟问题，问什么会有这个问题"></a>73.移动端300ms的延迟问题，问什么会有这个问题</h4><h4 id="74-vue模版编译都有哪些阶段"><a href="#74-vue模版编译都有哪些阶段" class="headerlink" title="74.vue模版编译都有哪些阶段"></a>74.vue模版编译都有哪些阶段</h4><h4 id="75-vue虚拟dom怎么生成的"><a href="#75-vue虚拟dom怎么生成的" class="headerlink" title="75.vue虚拟dom怎么生成的"></a>75.vue虚拟dom怎么生成的</h4><h4 id="76-Vue2-3区别"><a href="#76-Vue2-3区别" class="headerlink" title="76.Vue2 3区别"></a>76.Vue2 3区别</h4><h4 id="77-手写防抖节流"><a href="#77-手写防抖节流" class="headerlink" title="77.手写防抖节流"></a>77.手写防抖节流</h4><h4 id="78-手写dom树转js对象"><a href="#78-手写dom树转js对象" class="headerlink" title="78.手写dom树转js对象"></a>78.手写dom树转js对象</h4><h4 id="79-给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端"><a href="#79-给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端" class="headerlink" title="79.给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端"></a>79.给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端</h4><h4 id="80-如果一个页面打开很慢，可能是哪些原因，怎么进行优化"><a href="#80-如果一个页面打开很慢，可能是哪些原因，怎么进行优化" class="headerlink" title="80.如果一个页面打开很慢，可能是哪些原因，怎么进行优化"></a>80.如果一个页面打开很慢，可能是哪些原因，怎么进行优化</h4><h4 id="81-TCP的三次握手，以及每次的作用"><a href="#81-TCP的三次握手，以及每次的作用" class="headerlink" title="81.TCP的三次握手，以及每次的作用"></a>81.TCP的三次握手，以及每次的作用</h4><h4 id="82-TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理"><a href="#82-TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理" class="headerlink" title="82.TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理"></a>82.TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理</h4><h4 id="83-Vue的响应式原理"><a href="#83-Vue的响应式原理" class="headerlink" title="83.Vue的响应式原理"></a>83.Vue的响应式原理</h4><h4 id="84-Vue中computed和data里的值的联系，computed的特点以及响应式变化"><a href="#84-Vue中computed和data里的值的联系，computed的特点以及响应式变化" class="headerlink" title="84.Vue中computed和data里的值的联系，computed的特点以及响应式变化"></a>84.Vue中computed和data里的值的联系，computed的特点以及响应式变化</h4><h4 id="85-Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy-和-defineProperty-的比较"><a href="#85-Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy-和-defineProperty-的比较" class="headerlink" title="85.Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy 和 defineProperty 的比较"></a>85.Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy 和 defineProperty 的比较</h4><p>详情请看vue3和vue2区别</p><p>vue2中重写数组中的方法，主要分为这几步</p><ol><li>获取到Array原型链上的方法，因为拦截后还需要调用原生的方法进行操作</li><li>使用object.defineproperty拦截数组的操作</li><li>再把array的实例原型指向修改后的实例原型</li></ol><p>proxy和defineproperty的区别</p><p>defineproperty的作用主要不是用来监听对象属性的变化，defineproperty不可以监听数组的变化，必须重写数组的方法，会对对象进行修改，不能够监听对象属性的修改和删除，不可以监听数组手动修改length和通过数组下标修改值，proxy代理，可以代理对象，不需要修改元素组，而且有十三中捕获器，还可以配合reflect来使用</p><h4 id="86-webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等"><a href="#86-webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等" class="headerlink" title="86.webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等"></a>86.webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等</h4><h4 id="87-window-onload和DOMContentLoaded的区别"><a href="#87-window-onload和DOMContentLoaded的区别" class="headerlink" title="87.window.onload和DOMContentLoaded的区别"></a>87.window.onload和DOMContentLoaded的区别</h4><h4 id="88-了解http2"><a href="#88-了解http2" class="headerlink" title="88.了解http2"></a>88.了解http2</h4><h4 id="89-网页布局的方式有哪些"><a href="#89-网页布局的方式有哪些" class="headerlink" title="89.网页布局的方式有哪些"></a>89.网页布局的方式有哪些</h4><h4 id="90-使用promise封装ajax"><a href="#90-使用promise封装ajax" class="headerlink" title="90.使用promise封装ajax"></a>90.使用promise封装ajax</h4><h4 id="91-写一个vue的自定义指令"><a href="#91-写一个vue的自定义指令" class="headerlink" title="91.写一个vue的自定义指令"></a>91.写一个vue的自定义指令</h4><h4 id="92-vuex的原理，数据存储在哪里"><a href="#92-vuex的原理，数据存储在哪里" class="headerlink" title="92.vuex的原理，数据存储在哪里"></a>92.vuex的原理，数据存储在哪里</h4><h4 id="93-说一下href和src的区别"><a href="#93-说一下href和src的区别" class="headerlink" title="93.说一下href和src的区别"></a>93.说一下href和src的区别</h4><h4 id="94-说一下你知道的webpack打包构建的优化"><a href="#94-说一下你知道的webpack打包构建的优化" class="headerlink" title="94.说一下你知道的webpack打包构建的优化"></a>94.说一下你知道的webpack打包构建的优化</h4><h4 id="95-说一下你了解的plugin和loader-以及如何去写一个plugin和loader"><a href="#95-说一下你了解的plugin和loader-以及如何去写一个plugin和loader" class="headerlink" title="95.说一下你了解的plugin和loader,以及如何去写一个plugin和loader"></a>95.说一下你了解的plugin和loader,以及如何去写一个plugin和loader</h4><h4 id="96-说一下transform的原理-先平移再旋转和先旋转再平移有什么区别"><a href="#96-说一下transform的原理-先平移再旋转和先旋转再平移有什么区别" class="headerlink" title="96.说一下transform的原理(先平移再旋转和先旋转再平移有什么区别)"></a>96.说一下transform的原理(先平移再旋转和先旋转再平移有什么区别)</h4><h4 id="97-函数和对象及其上下文存储在哪里"><a href="#97-函数和对象及其上下文存储在哪里" class="headerlink" title="97.函数和对象及其上下文存储在哪里"></a>97.函数和对象及其上下文存储在哪里</h4><h4 id="98-手写虚拟dom转换成真实的dom"><a href="#98-手写虚拟dom转换成真实的dom" class="headerlink" title="98.手写虚拟dom转换成真实的dom"></a>98.手写虚拟dom转换成真实的dom</h4><h4 id="99-为什么一个网站的资源会存储在多个域名中"><a href="#99-为什么一个网站的资源会存储在多个域名中" class="headerlink" title="99.为什么一个网站的资源会存储在多个域名中"></a>99.为什么一个网站的资源会存储在多个域名中</h4><h4 id="100-如何实现前端的权限控制"><a href="#100-如何实现前端的权限控制" class="headerlink" title="100.如何实现前端的权限控制"></a>100.如何实现前端的权限控制</h4><h4 id="101-说一下vue3相对于vue2的优化"><a href="#101-说一下vue3相对于vue2的优化" class="headerlink" title="101.说一下vue3相对于vue2的优化"></a>101.说一下vue3相对于vue2的优化</h4><h4 id="102-说一下vite相对于webpack的优化"><a href="#102-说一下vite相对于webpack的优化" class="headerlink" title="102.说一下vite相对于webpack的优化"></a>102.说一下vite相对于webpack的优化</h4><h4 id="103-实现vue中template生成虚拟dom"><a href="#103-实现vue中template生成虚拟dom" class="headerlink" title="103.实现vue中template生成虚拟dom"></a>103.实现vue中template生成虚拟dom</h4><h4 id="104-知道http499是什么"><a href="#104-知道http499是什么" class="headerlink" title="104.知道http499是什么"></a>104.知道http499是什么</h4><p>表示客户端主动关闭连接，即HTTP 499 Client Closed Request,HTTP 499 表示nginx使用非标准状态码。表明当nginx正在处理请求时，客户端关闭了连接</p><h4 id="105-说一说mata标签的作用"><a href="#105-说一说mata标签的作用" class="headerlink" title="105.说一说mata标签的作用"></a>105.说一说mata标签的作用</h4><p>meta元素用来定义元数据的，meta标签用于定义不能用其他元数据元素定义的元数据信息，header中定义元数据的标签有style,link,title等，不能用这些标签定义的数据，就写在meta中。</p><p>meta元素定义的元数据的类型包括以下几类</p><p>如果设置了charset meta元素就是一个字符集声明，告诉文档使用那种字符编码</p><p>如果设置了http-equiv属性，meta元素则是编译指令  主要是做兼容性处理，告诉IE浏览器去模仿那个浏览器的行为，IE模仿edge的行为，chrome使用1</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;IE=edge,chrome=1&quot;</span>&gt;</code></pre></div><p>如果设置了name属性，meta元素提供的是文档级别的元数据，应用于整个页面</p><h4 id="106-说一下css的优先级，important的缺点"><a href="#106-说一下css的优先级，important的缺点" class="headerlink" title="106.说一下css的优先级，important的缺点"></a>106.说一下css的优先级，important的缺点</h4><p>css的优先级是按照css的权重来叠加的，</p><p>！important  10000</p><p>内联样式 1000</p><p>id选择器 100</p><p>类选择器，属性选择权，伪类  10</p><p>元素选择器，伪元素 1</p><p>通配符 0</p><p>通过各项叠加来计算css的优先级</p><p>important的优先级最高，在全局和组件中要谨慎使用，在对一些继承属性使用important，在修改这个属性的时候需要再次添加important，可能会造成混乱</p><h4 id="107-说一下响应式布局"><a href="#107-说一下响应式布局" class="headerlink" title="107.说一下响应式布局"></a>107.说一下响应式布局</h4><h4 id="108-写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"><a href="#108-写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名" class="headerlink" title="108.写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"></a>108.写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名</h4><h4 id="109-说一下js的事件循环和node事件循环的区别"><a href="#109-说一下js的事件循环和node事件循环的区别" class="headerlink" title="109.说一下js的事件循环和node事件循环的区别"></a>109.说一下js的事件循环和node事件循环的区别</h4><p>js的事件循环是运行在浏览器环境中的，node事件循环是运行在node环境中的</p><p>浏览器的事件循环是一个我们编写的javascript代码和浏览器api调用(setTimeout/ajax/事件监听)的桥梁，桥梁之间他们用回调函数进行沟通</p><p>node事件循环是一个我们编写的javascript代码和系统调用(file syatem network)之间的桥梁，桥梁之间通过回调函数进行沟通</p><p>浏览器的事件循环：</p><p>​    首先会在函数执行调用栈中执行同步代码，如果执行到定时器会先将定时器挂起，继续向下执行执行到微任务代码，则先进入微任务队列，执行到宏任务，则进入宏任务队列，同步代码执行完成后，则会开始执行异步队列中的代码，先执行微任务队列，微任务队列之星完后在执行宏任务队列，等定时器执行完后，则进入宏任务队列执行，如此往复直到执行完成</p><p>宏任务队列：ajax，setTimeout ，setInterval，DOM监听，UIrendering等</p><p>微任务队列：Promise的then回调，Mutation observer api queueMicrotask() async/await等</p><p>node的事件循环是由libuv来实现的，libuv采用的就是非阻塞异步IO的调用方式</p><p>node事件循环分成很多个阶段</p><p>定时器(Timer):setTimeOut ，setIterval</p><p>待定回调（pending callback） 对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到 ECONNREFUSED</p><p>idle,prepare:进内部使用</p><p>轮询：检索新的I/O事件，执行与IO有关的回调</p><p>检测：setImmediate()回调函数在这里执行</p><p>关闭回调函数:一些关闭的回调函数，如socket.on(‘close’,)</p><p>node的事件的循环更加复杂，他也分为微任务和宏任务</p><p>宏任务：setTimeout,setInterval,IO事件，setImmediate,close事件</p><p>微任务：promise.then,async/awiat,process.nextTick,queueMicrotask</p><p>Node中的事件循环不只是 微任务队列和 宏任务队列：</p><p>​    微任务队列： </p><p>​        next tick queue：process.nextTick； </p><p>​        other queue：Promise的then回调、queueMicrotask；</p><p>​    宏任务队列： </p><p>​         timer queue：setTimeout、setInterval； </p><p>​        poll queue：IO事件；</p><p>​        check queue：setImmediate； ü close queue：close事件</p><p>执行宏任务的时候都必须先判断微任务队列是否有值</p><h4 id="110-实现一个柯里化函数（写代码）"><a href="#110-实现一个柯里化函数（写代码）" class="headerlink" title="110.实现一个柯里化函数（写代码）"></a>110.实现一个柯里化函数（写代码）</h4><h4 id="111-实现函数的链式调用（写代码，compose函数）"><a href="#111-实现函数的链式调用（写代码，compose函数）" class="headerlink" title="111.实现函数的链式调用（写代码，compose函数）"></a>111.实现函数的链式调用（写代码，compose函数）</h4><h4 id="112-如何配置less文件的loader"><a href="#112-如何配置less文件的loader" class="headerlink" title="112.如何配置less文件的loader"></a>112.如何配置less文件的loader</h4><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>:/\.<span class="hljs-keyword">less</span>$/,use:[style-loader,css-loader,postcss-loader,<span class="hljs-keyword">less</span>-loader]</code></pre></div><h4 id="113-webpack是如何做到一步步处理loader文件的"><a href="#113-webpack是如何做到一步步处理loader文件的" class="headerlink" title="113.webpack是如何做到一步步处理loader文件的"></a>113.webpack是如何做到一步步处理loader文件的</h4><h4 id="114-为什么webpack是自上而下执行的"><a href="#114-为什么webpack是自上而下执行的" class="headerlink" title="114.为什么webpack是自上而下执行的"></a>114.为什么webpack是自上而下执行的</h4><h4 id="115-实现防抖和节流函数（写代码）"><a href="#115-实现防抖和节流函数（写代码）" class="headerlink" title="115.实现防抖和节流函数（写代码）"></a>115.实现防抖和节流函数（写代码）</h4><h4 id="116-如何用css实现两栏布局"><a href="#116-如何用css实现两栏布局" class="headerlink" title="116.如何用css实现两栏布局"></a>116.如何用css实现两栏布局</h4><h4 id="117-说一下css的position定位"><a href="#117-说一下css的position定位" class="headerlink" title="117.说一下css的position定位"></a>117.说一下css的position定位</h4><p>运用position进行定位，常取得5个值是：    static relative absolute fixed  sticky</p><p>position的默认值就是static</p><p>使用其他属性值可以让position变成定位元素</p><p>relative:会按照标准文档流进行布局，可以通过left right top bottom 来进行定位，参照对象是元素原来的位置</p><p>fixed：元素会脱离标准流，可以通过left，right，top，bottom进行定位，参照对象是视口。例如画布滚动时，元素不动</p><p>absolute：元素会脱离文档流，可以通过left，right，top，bottom进行定位，参照对象是最近定位（position不为static的元素）的祖先元素，否则就会相对于视口进行定位</p><h4 id="118-说一下js的作用域"><a href="#118-说一下js的作用域" class="headerlink" title="118.说一下js的作用域"></a>118.说一下js的作用域</h4><p>js的作用域有全局作用域，函数作用域，eval作用域，块级作用域</p><p>全局作用域就是最顶层的作用域，所有变量都可以访问到，函数作用域就是每个函数内部的作用域，eval作用域就是eval函数内部的作用域，es6新增了块级作用域，块级作用域是函数作用域的子集</p><h4 id="119-说一下js的import和node的require的区别"><a href="#119-说一下js的import和node的require的区别" class="headerlink" title="119.说一下js的import和node的require的区别"></a>119.说一下js的import和node的require的区别</h4><h4 id="120-说一下你了解的js的数组的常用方法"><a href="#120-说一下你了解的js的数组的常用方法" class="headerlink" title="120.说一下你了解的js的数组的常用方法"></a>120.说一下你了解的js的数组的常用方法</h4><p>数组常用的方法有</p><p>Array.prototype.join()</p><p>Array.prototype.concat()</p><p>Array.prototype.slice()</p><p>Array.prototype.splice()</p><p>Array.prototype.push()</p><p>Array.prototype.shift()</p><p>Array.prototype.unshift()</p><p>Array.isArray()</p><p>Array.prototype.pop()</p><p>Array.prototype.map()</p><p>Array.prototype.forEach()</p><p>Array.prototype.reduce()</p><p>Array.prototype.sort()</p><p>Array.prototype.some()</p><p>Array.prototype.every()</p><p>Array.prototype.entry()</p><p>Array.prototype.find()</p><p>Array.prototype.findIndex()</p><p>Array.prototype.flat()/flatMap()</p><p>Array.prototype.indexOf()</p><p>Array.prototype.includes()</p><p>Array.from()</p><p>Array.of()</p><p>Array.prototype.toString()</p><p>Array.prototype.values()</p><h4 id="121-说一下GET和POST的区别"><a href="#121-说一下GET和POST的区别" class="headerlink" title="121.说一下GET和POST的区别"></a>121.说一下GET和POST的区别</h4><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置</li><li>GET请求参数会被完整保留在浏览器的历史记录里，而POST中的参数不会被保留</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制</li><li>GET参数通过URL传递，POST放在Request body中</li><li>GET请求只能进行 url 编码，而POST支持多种编码方式</li><li>GET产生的URL地址可以被收藏，而POST不可以</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li></ul><h4 id="123-说一下px，rem，em的区别和联系"><a href="#123-说一下px，rem，em的区别和联系" class="headerlink" title="123.说一下px，rem，em的区别和联系"></a>123.说一下px，rem，em的区别和联系</h4><p>px是绝对长度单位，rem，em是相对长度单位，em是相对于元素本身的font-size来进行定位的，如果本身没有font-size则会继承自父元素的font-size，rem是根据根元素的font-size</p><h4 id="124-说一下instanceof的原理"><a href="#124-说一下instanceof的原理" class="headerlink" title="124.说一下instanceof的原理"></a>124.说一下instanceof的原理</h4><p>通过判断instance的[[prototype]]是否和原型链上的原型是否匹配</p><h4 id="125-说一下this的指向有几种方式"><a href="#125-说一下this的指向有几种方式" class="headerlink" title="125.说一下this的指向有几种方式"></a>125.说一下this的指向有几种方式</h4><p>1.默认绑定  this默认是指向全局，浏览器中this指向window,node中this指向global  在由于兼容性考虑可以使用globalThis  在函数声明中，this就是默认绑定</p><p>2.隐式绑定  在对象中this是指向调用的变量</p><p>3.显示绑定   可以使用call ,apply ,bind来指定this的指向</p><p>4.new绑定   使用new创建的对象，构造函数中的this会指向新创建的对象</p><h4 id="126-说一下v-model的原理"><a href="#126-说一下v-model的原理" class="headerlink" title="126.说一下v-model的原理"></a>126.说一下v-model的原理</h4><p>v-model就是如下的语糖</p><p>对于input，textarea元素</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;input  :<span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;text&quot;</span>  @<span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;event =&gt; text = event.target.value&quot;</span>&gt;</code></pre></div><p>对于文本元素text，textarea会绑定value property监听input事件，checkbox和radio会绑定checked property 监听change事件，select属性会绑定value属性，监听change事件</p><h4 id="127-如何封装一个弹窗组件，需要考虑那些问题"><a href="#127-如何封装一个弹窗组件，需要考虑那些问题" class="headerlink" title="127.如何封装一个弹窗组件，需要考虑那些问题"></a>127.如何封装一个弹窗组件，需要考虑那些问题</h4><h4 id="128-说一下keep-alive的原理，以及如果超出缓存长度，如何处理"><a href="#128-说一下keep-alive的原理，以及如果超出缓存长度，如何处理" class="headerlink" title="128.说一下keep-alive的原理，以及如果超出缓存长度，如何处理"></a>128.说一下keep-alive的原理，以及如果超出缓存长度，如何处理</h4><h4 id="129-说一下你对jwt认证机制的理解，它的优缺点"><a href="#129-说一下你对jwt认证机制的理解，它的优缺点" class="headerlink" title="129.说一下你对jwt认证机制的理解，它的优缺点"></a>129.说一下你对jwt认证机制的理解，它的优缺点</h4><h4 id="130-说一下new创建实例的时候都做了什么"><a href="#130-说一下new创建实例的时候都做了什么" class="headerlink" title="130.说一下new创建实例的时候都做了什么"></a>130.说一下new创建实例的时候都做了什么</h4><p>new创建实例的过程</p><ol><li>创建一个空对象</li><li>新创建的对象的[[prototype]]指向构造函数的prototype</li><li>构造函数的this指向新创建的对象</li><li>执行构造函数</li><li>如果构造函数没有返回值，则返回新创建的对象</li></ol><h4 id="131-说一下你对闭包的理解"><a href="#131-说一下你对闭包的理解" class="headerlink" title="131.说一下你对闭包的理解"></a>131.说一下你对闭包的理解</h4><h4 id="132-说一下你对flex布局的理解，以及其中属性的默认值-未完待续"><a href="#132-说一下你对flex布局的理解，以及其中属性的默认值-未完待续" class="headerlink" title="132.说一下你对flex布局的理解，以及其中属性的默认值(未完待续)"></a>132.说一下你对flex布局的理解，以及其中属性的默认值(未完待续)</h4><p>flex是用于按行或者按列布局元素的一维布局方法，元素可以通过膨胀以填充额外的空间以适应更小的空间。flex布局可以解决原来布局的一些痛点，例如垂直居中块元素，例如使容器的所有子项等分可用宽度，而不用管具体的宽高，在多列布局中所有列都采用相同的高度，即使他们包含的内容量不同。</p><p>开启了flex布局的元素叫flex item</p><p>flex container 里面的直接子元素叫做flex item</p><p>当flex conteainer中的子元素变成flex item时，具备以下特点：</p><p>​    flex item的布局将受flex container属性的设置来来控制和布局</p><p>​    flex item不再严格区分块级元素和行内级元素</p><p>​    flex item 默认情况下是包裹内容的，但是可以设置宽度和高度</p><p>display：flex或者inline-flex可以变成 flex-container</p><p>flex container的css属性有</p><p>​    flex-flow</p><p>​    flex-direction</p><p>​    flex-wrap</p><p>​    flex-flow</p><p>​    justify-content</p><p>​    align-items</p><p>​    align-content</p><p>应用在flex items上的c s s属性</p><p>​    flex-grow</p><p>​    flex-basis</p><p>​    flex-shrink</p><p>​    order</p><p>​    align-self</p><p>​    flex</p><h4 id="133-说一下ES6的块级作用域（待补充）"><a href="#133-说一下ES6的块级作用域（待补充）" class="headerlink" title="133.说一下ES6的块级作用域（待补充）"></a>133.说一下ES6的块级作用域（待补充）</h4><p>let const function class声明都会形成块级作用域，块级作用域可以让变量必须先声明再访问，否则会出现暂时性死区。块级作用域不会出现变量提升。例如在setTimeOut中的通过递归获取dom节点，可以使用该特性来代替立即执行函数</p><h4 id="134-说一下async和await的原理，generator用来做什么"><a href="#134-说一下async和await的原理，generator用来做什么" class="headerlink" title="134.说一下async和await的原理，generator用来做什么"></a>134.说一下async和await的原理，generator用来做什么</h4><p>async和await就是generator和promise.then的语法糖</p><h4 id="135-如何用ES5实现ES6的class的static和private"><a href="#135-如何用ES5实现ES6的class的static和private" class="headerlink" title="135.如何用ES5实现ES6的class的static和private"></a>135.如何用ES5实现ES6的class的static和private</h4><p>static:ES5中是直接在构造函数中添加</p><p>private:默认使用_来替代，并且定义get set方法</p><h4 id="136-用promise封装实现readfile和writefile的同步请求（写代码）"><a href="#136-用promise封装实现readfile和writefile的同步请求（写代码）" class="headerlink" title="136.用promise封装实现readfile和writefile的同步请求（写代码）"></a>136.用promise封装实现readfile和writefile的同步请求（写代码）</h4><h4 id="137-手写ES6的模板字符串（写代码"><a href="#137-手写ES6的模板字符串（写代码" class="headerlink" title="137.手写ES6的模板字符串（写代码"></a>137.手写ES6的模板字符串（写代码</h4>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
