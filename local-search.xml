<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/12/11/hello-world/"/>
    <url>/2022/12/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>web性能权威指南</title>
    <link href="/2022/12/09/web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2022/12/09/web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="web性能权威指南"><a href="#web性能权威指南" class="headerlink" title="web性能权威指南"></a>web性能权威指南</h1><h2 id="网络技术概览"><a href="#网络技术概览" class="headerlink" title="网络技术概览"></a>网络技术概览</h2><p>网络通信决定性影响的两个方面：延迟与带宽</p><p>延迟：分组从信息源发送到目的地所需要的时间</p><p>带宽：逻辑或者物理通信路径最大的吞吐量</p><p><strong>延迟的构成</strong></p><p>传播延迟：消息从发送端到接收端所需要的时间，是信号传播距离和速度的函数</p><p>传输延迟：把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数</p><p>处理延迟：处理分组首部，检查位错误及确定分组目标</p><p>排队延迟：到来的分组排队等待处理的时间</p><p>以上加起来的时间就是客户端到服务器的总延迟时间。传播时间取决于距离和信号通过的媒介。另外传播速度一般不超过光速，而传输时延是由传输链路上的速率来决定的，与客户端和服务器的距离无关。假设有一个 10 MB 的文件，分别通过两个链路传输，一个1Mbit/s，另一个 100 Mbit/s。在 1 Mbit/s 的链路上，需要花10 s，而在 100 Mbit/s 的链路上，只需 0.1 s。</p><p>接着，分组到达路由器。路由器必须检测分组的首部，以确定出站路由，并且还可能对数据进行检查，这些都要花时间。由于这些检查通常由硬件完成，因此相应的延迟一般非常短，但再短也还是存在。最后，如果分组到达的速度超过了路由器的处理能力，那么分组就要在入站缓冲区排队。数据在缓冲区排队等待的时间，当然就是排队延迟。</p><p>每个分组在通过网络时都会遇到这样或那样的延迟。发送端与接收端的距离越远，传播时间就越长。一路上经过的路由器越多，每个分组的处理和传输延迟就越多。最后，网络流量越拥挤，分组在入站缓冲区中被延迟的可能性就越大。</p><h2 id="浏览器网络概述"><a href="#浏览器网络概述" class="headerlink" title="浏览器网络概述"></a>浏览器网络概述</h2><p>现代浏览器完全包括数百个组件的操作系统，包括进程管理，安全沙箱，分层的优化缓存，javascript虚拟机，图形渲染，GPU管道，存储系统，传感器，音频与视频，网络机制，等等。</p><p>显然，浏览器乃至运行在其中的应用的性能，取决于若干组件：解析、布局、HTML 与 CSS 的样式计算、JavaScript 执行速度、渲染管道，当然还有网络相关各层协议的配合。其中每个组件的角色都很重要，而网络组件通常是加倍重要，因为浏览器慢就慢在等待网络资源上，等待造成后续环节被阻塞！</p><p>运行在浏览器中的 Web 应用并不负责管理个别网络套接字的生命周期，这是好事。通过把这个任务委托给浏览器，可以自动化很多重要的性能优化任务，包括套接字重用、请求优先级排定、晚绑定、协议协商、施加连接数限制，等等。事实上，浏览器是有意把请求管理生命周期与套接字管理分开的</p><p>套接字是以池的形式进行管理的（图 14-2），即按照来源，每个池都有自己的连接限制和安全约束。挂起的请求是排好队的、有优先次序的，然后再适时把它们绑定到池中个别的套接字上。除非服务器有意关闭连接，否则同一个套接字可以自动用于多个请求</p><p><strong>来源</strong></p><p>由应用协议、域名和端口三个要件构成，比如 (http, <a href="http://www.example.com/">www.example.com</a>, 80) 与(https, <a href="http://www.example.com/">www.example.com</a>, 443) 就是两个不同的来源。</p><p><strong>套接字池</strong></p><p>属于同一个来源的一组套接字。实践中，所有主流浏览器的最大池规模都是 6 个套接字。</p><p>自动化的套接字池管理会自动重用 TCP 连接，从而有效保障性能，除此之外，这种架构设计还提供了其他优化的机会：</p><ul><li>浏览器可以按照优先次序发送排队的请求；</li><li>浏览器可以重用套接字以最小化延迟并提升吞吐量；</li><li>浏览器可以预测请求提前打开套接字；</li><li>浏览器可以优化何时关闭空闲套接字；</li><li>浏览器可以优化分配给所有套接字的带宽</li></ul><h3 id="网络安全与沙箱"><a href="#网络安全与沙箱" class="headerlink" title="网络安全与沙箱"></a>网络安全与沙箱</h3><p>将个别套接字的管理任务委托给浏览器还有另一个重要的用意：可以让浏览器运用沙箱机制，对不受信任的应用代码采取一致的安全与策略限制。比如，浏览器不允许直接访问原始网络套接字 API，因为这样给恶意应用向任意主机发起任意请求（端口扫描、连接邮件服务器或发送未知消息）提供可乘之机</p><p><strong>连接限制</strong></p><p>浏览器管理所有打开的套接字池并强制施加连接数限制，保护客户端和服务器的资源不会被耗尽</p><p><strong>请求格式化与响应处理</strong></p><p>浏览器格式化所有外发请求以保证格式一致和符合协议的语义，从而保护服务器。类似地，响应解码也会自动完成，以保护用户。</p><p><strong>TLS协商</strong></p><p>浏览器执行 TLS 握手和必要的证书检查。任何证书有问题（比如服务器正在使用自已签发的证书），用户都会收到通知。</p><p><strong>同源策略</strong></p><p>浏览器会限制应用只能向哪个来</p><h3 id="资源与客户端状态缓存"><a href="#资源与客户端状态缓存" class="headerlink" title="资源与客户端状态缓存"></a>资源与客户端状态缓存</h3><p>最好最快的请求是没有请求。在分派请求之前，浏览器会自动检查其资源缓存，执行必要的验证，然后在满足限制条件的情况下返回资源的本地副本。类似地，如果某本地资源不在缓存中，那么浏览器就会发送网络请求，将响应自动填充到缓存中，以备后续访问使用。</p><p>• 浏览器针对每个资源自动执行缓存指令。</p><p>• 浏览器会尽可能恢复失效资源的有效性。</p><p>• 浏览器会自动管理缓存大小及资源回收。</p><p>高效、最优地管理缓存很困难。所幸，浏览器会替我们照管这一切，我们要做的，只是确保服务器返回适当的缓存指令Cache-Control、ETag 和 Last-Modified。最后，浏览器还有一个经常被人忽视的重要功能，那就是提供会话认证和 cookie 管理。浏览器为每个来源维护着独立的 cookie 容器，为读写新 cookie、会话和认证数据提供必要的应用及服务器 API，还会为我们自动追加和处理 HTTP 首部，让一切都自动化。</p><h3 id="应用API与协议"><a href="#应用API与协议" class="headerlink" title="应用API与协议"></a>应用API与协议</h3><table><thead><tr><th></th><th>XmlHttpRequest</th><th>Server-Sent Event</th><th>WebSocket</th></tr></thead><tbody><tr><td>请求流</td><td>否</td><td>否</td><td>是</td></tr><tr><td>响应流</td><td>受限</td><td>否</td><td>是</td></tr><tr><td>分帧机制</td><td>HTTP</td><td>事件流</td><td>二进制分帧</td></tr><tr><td>二进制数据传输</td><td>是</td><td>否(base64)</td><td>是</td></tr><tr><td>压缩</td><td>是</td><td>是</td><td>受限</td></tr><tr><td>应用传输协议</td><td>HTTP</td><td>TCP</td><td>WebSocket</td></tr><tr><td>网络传输协议</td><td>TCP</td><td>TCP</td><td>TCP</td></tr></tbody></table><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>这就意味着浏览器会自动帮</p><p>我们完成所有底层的连接管理、协议协商、HTTP 请求格式化，以及更多工作：XHR不仅实现了浏览器的异步通信，还极大的简化的这个过程，XH R是浏览器提供的应用API.这就意味着浏览器会自动帮我们完成所有底层的连接管理、协议协商、HTTP 请求格式化，以及更多工作：</p><p>浏览器管理着连接建立、套接字池和连接终止；</p><p>浏览器决定最佳的 HTTP（S）传输协议（HTTP 1.0、1.x 和 2.0）； </p><p>浏览器处理 HTTP 缓存、重定向和内容类型协商；</p><p>浏览器保障安全、验证和隐私；</p><p>等等</p><h4 id="跨源资源共享（CORS）"><a href="#跨源资源共享（CORS）" class="headerlink" title="跨源资源共享（CORS）"></a>跨源资源共享（CORS）</h4><p>XHR 是一个浏览器层面的 API，向我们隐藏了大量底层处理，包括缓存、重定向、内容协商、认证，等等。这样做有两个目的。第一，XHR 的 API 因此非常简单，开发人员可以专注业务逻辑。其次，浏览器可以采用沙箱机制，对应用代码强制施加一套安全限制。</p><p>XHR 接口强制要求每个请求都严格具备 HTTP 语义：应用提供数据和 URL，浏览器格式化请求并管理每个连接的完整生命周期。类似地，虽然 XHR API 允许应用添加自定义的 HTTP 首部（通过 setRequestHeader() 方法），同时也有一些首部是应用代码不能设定的：</p><p>• Accept-Charset、Accept-Encoding、Access-Control-*</p><p>• Host、Upgrade、Connection、Referer、Origin</p><p>• Cookie、Sec-<em>、Proxy-</em> 以及很多其他首部</p><p>浏览器会拒绝对不安全首部的重写，以此保证应用不能假扮用户代理、用户或请求来源。事实上，保护来源（Origin）首部特别重要，因为这是对所有 XHR 请求应用“同源策略”的关键。</p><p>CORS 请求也使用相同的 XHR API，区别仅在于请求资源用的 URL 与当前脚本并不同源。</p><p>针对 CORS 请求的选择同意认证机制由底层处理：请求发出后，浏览器自动追加受保护的 Origin HTTP 首部，包含着发出请求的来源。相应地，远程服务器可以检查 Origin首部，决定是否接受该请求，如果接受就返回 Access-Control-Allow-Origin 响应首部：</p><div class="code-wrapper"><pre><code class="hljs awk">=&gt; 请求GET <span class="hljs-regexp">/resource.js HTTP/</span><span class="hljs-number">1.1</span>Host: thirdparty.comOrigin: http:<span class="hljs-regexp">//</span>example.com ➊<span class="hljs-regexp">//</span>Origin 首部由浏览器自动设置...&lt;= 响应HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OKAccess-Control-Allow-Origin: http:<span class="hljs-regexp">//</span>example.com ➋<span class="hljs-regexp">//</span> 选择同意首部由服务器设置</code></pre></div><p>假如它选择不同意接受这个请求，那么只要不在响应中包含 <em>Access-Control-Allow-Origin</em> 首部即可。这样，客户端的浏览器就会自动将发出的请求作废。</p><p>如果第三方服务器不支持 CORS，那么客户端请求同样会作废，因为客户端会验证响应中是否包含选择同意的首部。作为一个特例，CORS 还允许服务器返回一个通配值 (Access-Control-Allow-Origin: *)，表示它允许来自任何源的请求。</p><p><strong>因为 CORS 还会提前采取一系列安全措施，以确保服务器支持 CORS：</strong> </p><p>• CORS 请求会省略 cookie 和 HTTP 认证等用户凭据；</p><p>• 客户端被限制只能发送“简单的跨源请求”，包括只能使用特定的方法（GET、POST 和 HEAD），以及只能访问可以通过 XHR 发送并读取的 HTTP 首部。</p><p>要启用 cookie 和 HTTP 认证，客户端必须在发送请求时通过 XHR 对象发送额外的属性（withCredentials），而服务器也必须以适当的首部（<em>Access-Control-Allow**Credentials</em>）响应，表示它允许应用发送用户的隐私数据。</p><div class="code-wrapper"><pre><code class="hljs excel">=&gt; 预备请求OPTIONS /resource.js HTTP/<span class="hljs-number">1.1</span> ➊//验证许可的预备 OPTIONS 请求Ho<span class="hljs-symbol">st:</span> thirdparty.comOrig<span class="hljs-symbol">in:</span> ht<span class="hljs-symbol">tp:</span>//example.comAccess-Control-Request-Meth<span class="hljs-symbol">od:</span> POSTAccess-Control-Request-Heade<span class="hljs-symbol">rs:</span> My-Custom-Header...&lt;= 预备响应HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK ➋//第三方源的成功预备响应Access-Control-Allow-Orig<span class="hljs-symbol">in:</span> ht<span class="hljs-symbol">tp:</span>//example.comAccess-Control-Allow-Metho<span class="hljs-symbol">ds:</span> GET, POST, PUTAccess-Control-Allow-Heade<span class="hljs-symbol">rs:</span> My-Custom-Header...（正式的 HTTP 请求）➌//实际的 CORS 请求</code></pre></div><p>W3C 官方的 CORS 规范规定了何时何地必须使用预备请求：“简单的”请求可以跳过它，但很多条件下这个请求都是必需的，因此也会为验证许可而增加仅有一次往返的网络延迟。只要完成预备请求，客户端就会将结果缓存起来，后续请求就不必重复验证了</p><p><strong><u>CORS 得到了所有现代浏览器支持，参见：caniuse.com/cors。要全面了解CORS 的各种策略及实现，请参考 W3C 官方标准（<a href="http://www.w3.org/TR/cors/%EF%BC%89%E3%80%82">http://www.w3.org/TR/cors/）。</a></u></strong></p><h4 id="通过XHR下载数据"><a href="#通过XHR下载数据" class="headerlink" title="通过XHR下载数据"></a>通过XHR下载数据</h4><p>XHR 既可以传输文本数据，也可以传输二进制数据。事实上，浏览器可以自动为各种原生数据类型提供编码和解码服务，因此应用在直接将这些数据传给 XHR 时就已经编码 / 解码好了，反之亦然。浏览器可以自动解码的数据类型如下。</p><p>ArrayBuffer</p><p>固定长度的二进制数据缓冲区。</p><p>Blob</p><p>二进制大对象或不可变数据。</p><p>Document</p><p>解析后得到的 HTML 或 XML 文档。</p><p>JSON</p><p>表示简单数据结构的 JavaScript 对象。</p><p>Text</p><p>简单的文本字符串。</p><p>浏览器通过http的content-type信息，来推断出类型， 比 如 把application/json 响应解析为 JSON 对象），应用也可以在发起 XHR 请求时显式重写数据类型：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/images/photo.webp&#x27;</span>);xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;blob&#x27;</span>; ➊<span class="hljs-comment">//将返回数据类型设置为 Blob</span>xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123; <span class="hljs-keyword">var</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>); img.<span class="hljs-property">src</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>); ➋<span class="hljs-comment">//基于返回的对象创建唯一的对象 URI 并设置为图片的源</span> img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">src</span>); ➌<span class="hljs-comment">//图片加载完毕后立即释放对象</span> &#125; <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(img); &#125;&#125;;xhr.<span class="hljs-title function_">send</span>()</code></pre></div><p>注意，这里我们在以原生格式传输一张图片，没有使用 base64 编码，也没有使用数据 URI，而是在页面中添加了一个 <img> 元素。这样在 JavaScript 中处理接收到的二进制数据不会产生任何网络传输开销和编码开销！ XHR API 让我们得以通过脚本高效、动态地开发应用，无论操作什么数据类型都没问题，全部用 JavaScript搞定！</p><p><em><strong>这里的二进制大对象接口（Blob）属于 HTML5 的 File API，就像一个不透明的引用，可以指向任何数据块（二进制或文本）。这个对象本身没有太多功能，只能查询其大小、MIME 类型，或将它切分成更小的块。这个对象存在的真正目的，是作为各种 JavaScript API 之间的一种高效的互操作机制。</strong></em></p><h4 id="通过XHR上传数据"><a href="#通过XHR上传数据" class="headerlink" title="通过XHR上传数据"></a>通过XHR上传数据</h4><p>通过 XHR 上传任何类型的数据都很简单，而且高效。事实上，上传不同类型数据的代码都一样，只不过最后在调用 XHR 请求对象的 send() 方法时，要传入相应的数据对象。剩下的事就都由浏览器处理了：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>,<span class="hljs-string">&#x27;/upload&#x27;</span>);xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;text string&quot;</span>); ➊<span class="hljs-comment">//把简单的文本字符串上传到服务器</span><span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(); ➋<span class="hljs-comment">//通过 FormData API 动态创建表单数据</span>formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-number">123456</span>);formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;topic&#x27;</span>, <span class="hljs-string">&#x27;performance&#x27;</span>);<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>);xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;xhr.<span class="hljs-title function_">send</span>(formData); ➌<span class="hljs-comment">//向服务器上传 multipart/form-data 对象</span><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>);xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;;<span class="hljs-keyword">var</span> uInt8Array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); ➍<span class="hljs-comment">//创建无符号、8 字节整型的有类型数组（ArrayBuffer）</span>xhr.<span class="hljs-title function_">send</span>(uInt8Array.<span class="hljs-property">buffer</span>); ➎<span class="hljs-comment">//向服务器上传字节块</span></code></pre></div><p>XHR 对象的 send() 方法可以接受 DOMString、Document、FormData、Blob、File 及ArrayBuffer 对象，并自动完成相应的编码，设置适当的 HTTP 内容类型 (content-type)，然后再分派请求。需要发送二进制 Blob 或上传用户提交的文件？简单，取得对该对象的引用，传给 XHR</p><p>如果上传文件过大，还可以将文件分块上传</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> blob = ...; ➊<span class="hljs-comment">//任意数据（二进制或文本）的二进制对象</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BYTES_PER_CHUNK</span> = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; ➋<span class="hljs-comment">//将块大小设置为 1 MB</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SIZE</span> = blob.<span class="hljs-property">size</span>;<span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> end = <span class="hljs-variable constant_">BYTES_PER_CHUNK</span>;<span class="hljs-keyword">while</span>(start &lt; <span class="hljs-variable constant_">SIZE</span>) &#123; ➌<span class="hljs-comment">//以 1 MB 为步长迭代数据块</span> <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>); xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; ... &#125;; xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Range&#x27;</span>, start+<span class="hljs-string">&#x27;-&#x27;</span>+end+<span class="hljs-string">&#x27;/&#x27;</span>+<span class="hljs-variable constant_">SIZE</span>); ➍<span class="hljs-comment">//告诉服务器上传的数据范围（开始位置 - 结束位置 / 总大小）</span> xhr.<span class="hljs-title function_">send</span>(blob.<span class="hljs-title function_">slice</span>(start, end)); ➎<span class="hljs-comment">//通过 XHR 上传 1 MB 大小的数据片段</span> start = end; end = start + <span class="hljs-variable constant_">BYTES_PER_CHUNK</span>;&#125;</code></pre></div><p>XHR 不支持请求流，这意味着在调用 send() 时必须提供完整的文件。不过，前面的例子示范了一个简单的解决方案：切分文件，然后通过多个 XHR 请求分段上传。这种实现方案当然不能替代真正的请求流 API，但对某些应用来说却是一个可行的方案。</p><p><em><strong>切分大文件上传是个不错的技巧，适合连接不稳定或经常中断的场景。此时，假如某个块由于掉线而上传失败，应用可以随后只重新上传该块，而不必重新上传整个大文件。</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>web性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web性能权威指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http权威指南</title>
    <link href="/2022/12/09/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2022/12/09/http%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http权威指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS权威指南</title>
    <link href="/2022/11/30/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2022/11/30/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="置换元素和非置换元素"><a href="#置换元素和非置换元素" class="headerlink" title="置换元素和非置换元素"></a>置换元素和非置换元素</h2><p>置换元素是指用来置换元素内容的部分不由文档内容直接表示，在html中，最常见的置换元素是img，input</p><p>非置换元素即元素的内容由用户代理通常是浏览器在元素自身生成的框中显示，文本，段落，标题，单元格，列表等其他都是非置换元素</p><h2 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h2><p>块级元素是独占一行，行内元素不会独占一行，在html中，块级元素不能出现在行内元素中，但是css不会限制他们的显示方式，可以互相嵌套</p><h2 id="把CSS应用到HTML的方式"><a href="#把CSS应用到HTML的方式" class="headerlink" title="把CSS应用到HTML的方式"></a>把CSS应用到HTML的方式</h2><h3 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h3><div class="code-wrapper"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;basic.css&quot;</span>&gt;</code></pre></div><p>多个link，会自动合成一个link</p><h3 id="style元素"><a href="#style元素" class="headerlink" title="style元素"></a>style元素</h3><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;test/css&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><p>style中可以使用@import导入外部样式</p><h3 id="import指令"><a href="#import指令" class="headerlink" title="@import指令"></a>@import指令</h3><p>@import也可以引入外部样式，但是@import必须放在顶部，否则不起作用</p><p>可以使用多个@import</p><h3 id="HTTP链接"><a href="#HTTP链接" class="headerlink" title="HTTP链接"></a>HTTP链接</h3><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><h2 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h2><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">/* 这是一段注释 */</span></code></pre></div><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><p>主要是指html元素</p><h3 id="群组选择器"><a href="#群组选择器" class="headerlink" title="群组选择器"></a>群组选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>:red&#125;</code></pre></div><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.warning</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;</code></pre></div><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.wraning</span><span class="hljs-selector-class">.help</span>&#123;<span class="hljs-attribute">background</span>:red&#125;</code></pre></div><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id选择器使用不能超过一次，id选择器的优先级高于类选择器</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#lead</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;</code></pre></div><h3 id="简单属性描述符"><a href="#简单属性描述符" class="headerlink" title="简单属性描述符"></a>简单属性描述符</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span><span class="hljs-selector-attr">[class]</span>&#123;<span class="hljs-attribute">color</span>:silver&#125;;  在<span class="hljs-selector-tag">h1</span>标签中有class属性的都设置<span class="hljs-attribute">color</span>*<span class="hljs-selector-attr">[title]</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125; ;  所有有title属性的<span class="hljs-attribute">font-weight</span>都设置为bold<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span><span class="hljs-selector-attr">[href]</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;; <span class="hljs-selector-tag">a</span>标签中存在title和href属性的<span class="hljs-attribute">font-weight</span>都设置为bold</code></pre></div><h3 id="精准的属性描述符"><a href="#精准的属性描述符" class="headerlink" title="精准的属性描述符"></a>精准的属性描述符</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;http://google.com&quot;</span>]</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;http://google.com&quot;</span>]</span><span class="hljs-selector-attr">[title=<span class="hljs-string">&quot;google&quot;</span>]</span>&#123;<span class="hljs-attribute">font-weight</span>:bold&#125;</code></pre></div><h3 id="使用属性选择器匹配子串"><a href="#使用属性选择器匹配子串" class="headerlink" title="使用属性选择器匹配子串"></a>使用属性选择器匹配子串</h3><div class="code-wrapper"><pre><code class="hljs prolog">[foo|=<span class="hljs-string">&#x27;bar&#x27;</span>] 选择的元素有foo属性，且以bar和-开头，或者是bar本身 例如 foo=<span class="hljs-string">&quot;bar-gerr&quot;</span>[foo~=<span class="hljs-string">&quot;bar&quot;</span>] 选择的元素有foo属性，且其值包含bar这个词的一组词，就是匹配以空格分隔的一组词的一个  例如foo=<span class="hljs-string">&quot;bar li&quot;</span>[foo*=<span class="hljs-string">&quot;bar&quot;</span>] 选择的元素有foo属性，且其值包含子串bar 例如foo=“bary”[foo^=<span class="hljs-string">&quot;bar&quot;</span>] 选择的元素有foo属性，且其值是以bar开头  [foo$=<span class="hljs-string">&quot;bar&quot;</span>] 选在的元素有foo属性，且其值是以bar结尾</code></pre></div><h3 id="不区分大小写的标识符"><a href="#不区分大小写的标识符" class="headerlink" title="不区分大小写的标识符"></a>不区分大小写的标识符</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href$=<span class="hljs-string">&#x27;.PDF&#x27;</span> i]</span></code></pre></div><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.sidebar</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>&#123;<span class="hljs-attribute">color</span>:white&#125; //为所有符合条件的后代设置样式，无论层级多深</code></pre></div><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &gt; <span class="hljs-selector-tag">strong</span> &#123;<span class="hljs-attribute">color</span>:red&#125;  //只为子元素设置样式</code></pre></div><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-top</span>:<span class="hljs-number">0</span>;&#125;  //选择紧跟在<span class="hljs-selector-tag">h1</span>后面的<span class="hljs-selector-tag">p</span>元素，他们是同属于一个父元素</code></pre></div><h3 id="后继同胞选择器"><a href="#后继同胞选择器" class="headerlink" title="后继同胞选择器"></a>后继同胞选择器</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span> ~<span class="hljs-selector-tag">ol</span>&#123;<span class="hljs-attribute">font-style</span>:italic;&#125;  //选择<span class="hljs-selector-tag">h2</span>中同属于一个父元素的所有兄弟<span class="hljs-selector-tag">ol</span>，和相邻兄弟选择器不同的是，相邻兄弟选择器只能匹配一个</code></pre></div><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span><span class="hljs-selector-pseudo">:hover</span>&#123;<span class="hljs-attribute">color</span>:red;&#125;  <span class="hljs-comment">//鼠标悬停在未访问过的链接的时候</span><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span><span class="hljs-selector-pseudo">:hover</span>&#123;<span class="hljs-attribute">color</span>:maroon;&#125;  <span class="hljs-comment">//鼠标悬停在已访问过的链接的时候。</span></code></pre></div><p>这种伪类选择器的使用和伪类的顺序无关，但是不要使用互相排斥的伪类类如<code>a:link:visited</code></p><h4 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h4><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span>&#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid red&#125;  选择文档根元素，在<span class="hljs-selector-tag">html</span>中，根元素始终是<span class="hljs-selector-tag">html</span>元素，在xml中是不一样的<span class="hljs-selector-pseudo">:empty</span>伪类可以选择没有任何子代的元素，甚至连文本结点都没有包括空白文本，元素里面只有注释也是属于空元素*<span class="hljs-selector-pseudo">:empty</span>&#123;<span class="hljs-attribute">display</span>:none;&#125;可以匹配所有的空元素，但是这里有个陷阱，他可以匹配<span class="hljs-selector-tag">img</span>，<span class="hljs-selector-tag">input</span>，还有匹配没有内容的<span class="hljs-selector-tag">textarea</span><span class="hljs-selector-pseudo">:empty</span>是唯一考虑文本结点的css选择器</code></pre></div><p>选择唯一子代</p><div class="code-wrapper"><pre><code class="hljs typescript">a[href] <span class="hljs-attr">img</span>:only-child  <span class="hljs-comment">//有href属性的a标签中 有唯一的子后代元素img  文本不属于元素</span>在后代选择器中使用:only-child,列出的元素不一定是父子关系例如&lt;a href&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/&gt;</span></span>&lt;/a&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>都可以匹配到如果需要确保是父子关系的话必须使用&gt;a[href] &gt; <span class="hljs-attr">img</span>:only-child如果想匹配超链接中唯一的img，但是链接中还有其他内容，img不是a标签中的唯一子元素可以使用:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>a[href] <span class="hljs-attr">img</span>:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span> &#123;<span class="hljs-attr">border</span>:5px solid black;&#125;&lt;a href=<span class="hljs-string">&quot;#&quot;</span>&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/&gt;</span></span>&lt;/a&gt;only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>和last-child的区别是only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>会忽略其他子元素，只会匹配对应的元素，only-child只会匹配唯一的元素注意:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>指的是元素，不能用于其他例如：p.<span class="hljs-property">unique</span>:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span> &#123;<span class="hljs-attr">color</span>:red;&#125;&lt;div&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;unique&quot;</span>&gt;</span>this is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>this is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>&lt;/div&gt;这两个段落都不会被匹配，因为都是div的后代，不是唯一的类型，:only-<span class="hljs-keyword">of</span>-<span class="hljs-keyword">type</span>前面必须是元素类型</code></pre></div><p>选择第一个和最后一个子代</p><p>:first-child 选择一个元素的第一个子元素</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<span class="hljs-attribute">font-weight</span>:bold;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<span class="hljs-attribute">text-transform</span>:uppercase;&#125;</code></pre></div><p>人们对p:first-child最大的误解就是认为他是选择p标签下的第一个子元素，如果想选择一个元素的第一个em子元素，应该是em:first-child,和:first-child对应的还有:last-child</p><p>选择第一个或者最后一个的某个元素</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:first</span>-of-type<span class="hljs-selector-pseudo">:last-of-type</span><span class="hljs-selector-tag">table</span><span class="hljs-selector-pseudo">:only-of-type</span> &#123;<span class="hljs-attribute">background</span>:color&#125;  等价于 <span class="hljs-selector-tag">table</span><span class="hljs-selector-pseudo">:first</span>-of-type<span class="hljs-selector-pseudo">:last-of-type</span> &#123;<span class="hljs-attribute">background</span>:color&#125;</code></pre></div><p>选择每第n个元素</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-meta">:first-child等价于:nth-child(1)</span>:nth-child(an+b) n=0,1,2,3,4..  元素是从1开始算起的，没有第0个元素，例如3n，则0，3，6，9，0是匹配不到的<span class="hljs-meta">:nth-child(2n+1)等价于 :nth-child(odd)</span><span class="hljs-meta">:nth-child(2n)等价于 :nth-child(even)</span>tr:nth-child(n+9)等价于 tr:nth-child(8) ~tr:nth-last-child是从后面开始算起的<span class="hljs-meta">:nth-child(1):nth-last-child(1)等价于:only-child</span>注意：nth-child(an<span class="hljs-code">+b)和：nth-of-type(an+</span>b)的区别</code></pre></div><h3 id="超链接伪类"><a href="#超链接伪类" class="headerlink" title="超链接伪类"></a>超链接伪类</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:link</span> 指未访问过的地址<span class="hljs-selector-pseudo">:visited</span> 指已访问过的地址</code></pre></div><h3 id="用户操作伪类"><a href="#用户操作伪类" class="headerlink" title="用户操作伪类"></a>用户操作伪类</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:focus</span> 指当前获得输入焦点的元素，即可以接受键盘输入或者以某种方式激活<span class="hljs-selector-pseudo">:hover</span> 指鼠标放置在上面的元素，例如鼠标悬停在超链接上<span class="hljs-selector-pseudo">:active</span> 指用户输入激活的元素，例如用户单击超链接，按下鼠标的那段时间</code></pre></div><p>可以处于:active状态的元素有链接，菜单项目，以及可以设定taindex属性的元素，这些元素包括其他交互元素如表单控件，可编辑内容的元素，还可以获得焦点，这些伪类最常用于超链接</p><p>这些伪类的顺序不可以随意改变</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">link-visited-focus-hover-active</span></code></pre></div><p>动态伪类引起的问题</p><p>例如：如果把link，visited设置为相同的font-size，而hover和active的时候增大字体</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span>,<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">13px</span>;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>,<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">20px</span>;&#125;</code></pre></div><p>用户在鼠标悬停或者在触屏点击的时候字体增大可能会出现重排的情况</p><h3 id="UI状态伪类"><a href="#UI状态伪类" class="headerlink" title="UI状态伪类"></a>UI状态伪类</h3><table><thead><tr><th>伪类</th><th>说明</th></tr></thead><tbody><tr><td>:disabled</td><td>即指代禁用用户界面元素例如表单元素，即不接受输入元素</td></tr><tr><td>:checked</td><td>指代用户或者文档默认选中的radio/checkbox</td></tr><tr><td>:enabled</td><td>指代启用的用户界面元素例如表单元素，即接受输入的元素</td></tr><tr><td>:indeterminate</td><td>指代既未选中耶没有未选中的单选按钮或者复选框，这个状态只能由dom来设定，不能由用户设定</td></tr><tr><td>:default</td><td>指代默认选中的单选框或者复选框按钮</td></tr><tr><td>:valid</td><td>指代满足所有数据有效性语义的输入框</td></tr><tr><td>:invalid</td><td>指代不满足所有数据有效性语义的输入框</td></tr><tr><td>:in-range</td><td>指代输入的值在最小值和最大值之间的输入框</td></tr><tr><td>:out-of-range</td><td>指代输入的值小于控件允许的最小值或大于控件允许的最大值的输入框</td></tr><tr><td>:required</td><td>指代必须输入值的输入框</td></tr><tr><td>:optional</td><td>指代无需输入值的输入框</td></tr><tr><td>:read-write</td><td>指代可由用户编辑的输入框</td></tr><tr><td>:read-only</td><td>指代不能由用户编辑的输入框</td></tr></tbody></table><p>非ui元素也可以使用:focus</p><p>:default</p><p>这个伪类通常用于上下文菜单选项，button，选择列表，目录，如果有几个同名的redio，最开始选中的那个radio就会匹配，即使用户后来选中了其他radio，页面重新加载时，也会应用于默认的那个，select元素一开始选中多个option，也可以匹配:default,:default还可以匹配button，和菜单选项</p><div class="code-wrapper"><pre><code class="hljs pgsql">[<span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;checkbox&#x27;</span>]:<span class="hljs-keyword">default</span> + label &#123;font-size:italic;&#125;&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=&quot;checkbox&quot; id=&quot;chbx&quot; checked <span class="hljs-type">name</span>=&quot;foo&quot; <span class="hljs-keyword">value</span>=&quot;bar&quot;/&gt;&lt;label <span class="hljs-keyword">for</span>=&quot;chbx&quot;&gt;this <span class="hljs-keyword">is</span> checkbox&lt;/label&gt;</code></pre></div><p>:required</p><p>:required是匹配必填的表单控件，required属性在html5中指定，:optional匹配没有required属性的表单控件，或者required属性为false的元素</p><p>想要提交表单，:required要求元素必须有值，:optional的有值没有值都可以</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">input</span>:require &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:optional</span> &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;&#125;也可以这么写<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[required]</span> &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-attr">[required]</span>) &#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;&#125;&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;email&quot;</span> placeholder=<span class="hljs-string">&quot;&quot;</span> required&gt;&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;email&quot;</span> placeholder=<span class="hljs-string">&quot;&quot;</span> &gt;&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;email&quot;</span> required=<span class="hljs-string">&quot;false&quot;</span> &gt;除了表单输入框意外，其他元素既不能必选也不能可选</code></pre></div><p>:valid和:invalid只适用于可以检查数据有效性的元素，div是不可以的，input可能匹配其中一个，这取决于用户界面当前的状态</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;email&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span>&#123;  <span class="hljs-attribute">background-position</span>:<span class="hljs-number">100%</span> <span class="hljs-number">50%</span>;  <span class="hljs-attribute">background-repeat</span>:no-repeat;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;email&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span><span class="hljs-selector-pseudo">:valid</span>&#123;  <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">...</span>)&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;emial&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span><span class="hljs-selector-pseudo">:invalid</span>&#123;  <span class="hljs-attribute">background</span>&#125;</code></pre></div><p>:in-range/:out-of-range</p><p>适用于有范围要求的表单控件</p><div class="code-wrapper"><pre><code class="hljs lua">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;number&#x27;</span> <span class="hljs-built_in">min</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-built_in">max</span>=<span class="hljs-string">&#x27;100&#x27;</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;number&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span> &#123;  <span class="hljs-attribute">background-position</span>:<span class="hljs-number">50%</span> <span class="hljs-number">50%</span>;  <span class="hljs-attribute">background-repeat</span>:no-repeat;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;number&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span><span class="hljs-selector-pseudo">:valid</span>&#123;&#125;<span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;number&#x27;</span>]</span><span class="hljs-selector-pseudo">:focus</span><span class="hljs-selector-pseudo">:invalid</span>&#123;&#125;</code></pre></div><h3 id="target伪类"><a href="#target伪类" class="headerlink" title=":target伪类"></a>:target伪类</h3><p>URL中有个片段标识符，它指向的文档片段在css中称之为target，url片段标识符指向的目标元素可以使用:target伪类进行标识</p><p>例如</p><p><a href="http://www.w3.org/tr/css3/#target-pes">http://www.w3.org/tr/css3/#target-pes</a></p><p>target-pes这部分就是片段标识符，用#标识，对应着页面中🈶️id=“target-pes”的元素，这个元素就是片段标识符的target</p><p>利用:target,我们可以突出显示文档中的任何目标元素，或者为不同的target元素定义不同的样式，</p><div class="code-wrapper"><pre><code class="hljs css">*<span class="hljs-selector-pseudo">:target</span> &#123;<span class="hljs-attribute">border-left</span>:<span class="hljs-number">5px</span> solid gray;<span class="hljs-attribute">background</span>:yellow <span class="hljs-built_in">url</span>(<span class="hljs-string">target.png</span>) top right no-repeat&#125;</code></pre></div><p>:target定义的样式在以下情况不会应用：</p><p>1.页面的url中没有片段标识符</p><p>2.页面的url中有片段标识符，但是文档中没有与之匹配的元素</p><p>如果文档中有多个元素与之匹配，样式都会应用</p><h3 id="lang伪类"><a href="#lang伪类" class="headerlink" title=":lang伪类"></a>:lang伪类</h3><div class="code-wrapper"><pre><code class="hljs css">*<span class="hljs-selector-pseudo">:lang</span>(fr) &#123;<span class="hljs-attribute">font-style</span>:italic;&#125;*:[lang|=<span class="hljs-string">&#x27;fr&#x27;</span>] &#123;<span class="hljs-attribute">font-style</span>:italic;&#125;</code></pre></div><h3 id="not-否定伪类"><a href="#not-否定伪类" class="headerlink" title=":not()否定伪类"></a>:not()否定伪类</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.moreinfo</span>)&#123;<span class="hljs-attribute">font-style</span>:italic;&#125;<span class="hljs-selector-class">.link</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-tag">li</span>)<span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-tag">p</span>) &#123;<span class="hljs-attribute">font-style</span>:italic;&#125;</code></pre></div><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素和伪类的区别是伪类是：伪元素是：：</p><p>所有的伪元素选择器只能出现在选择器的最后，<code>p::first-line em</code> 这样是不允许的</p><p>::first-letter</p><p>用于修饰任何非行内元素的首字母，或者开头的标点符号或者首字母</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">color</span>:red;&#125;</code></pre></div><p>::first-letter常用于实现排版效果的首字母大写或者首字母下沉，你可以把每个p元素首字母的字号设置为其余内容的两倍大，不过最好应用于第一段文字的首字母上</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-of-type<span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">200%</span>;&#125;</code></pre></div><p>::first-line</p><p>用于修饰元素的首行文本，例如把首行文本字体变大</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">150%</span>;<span class="hljs-attribute">color</span>:purple;&#125;</code></pre></div><p><strong>对于::first-letter和::first-line的限制</strong></p><p>目前这两个伪元素只能用于块级元素上，不能用于行内元素，对于在::first-letter</p><table><thead><tr><th>::first-letter</th><th>::first-line</th></tr></thead><tbody><tr><td>所有字体属性</td><td>所有字体属性</td></tr><tr><td>所有背景属性</td><td>所有背景属性</td></tr><tr><td>所有文本修饰属性</td><td>所有外边距属性</td></tr><tr><td>所有行内排版属性</td><td>所有内边距属性</td></tr><tr><td>所有行内布局属性</td><td>所有边框属性</td></tr><tr><td>所有边框属性</td><td>所有文本装饰属性</td></tr><tr><td>box-shadow</td><td>所有行内排版属性</td></tr><tr><td>color</td><td>color</td></tr><tr><td>opacity</td><td>opacity</td></tr></tbody></table><p>::before和::after</p><h2 id="特指度"><a href="#特指度" class="headerlink" title="特指度"></a>特指度</h2><p>选择器的特指度是由选择器本身的组成来决定的，一个特指度值由四部分组成，0，0，0，0</p><p>选择器中的id属性值加0，1，0，0</p><p>选择器中的每个类属性，属性选择器，或者伪类加0010</p><p>选择器中的每个元素和伪元素加0001</p><p>连接符和通用选择器不加特指度</p><p>通用选择器的特指度为0000</p><p>连接符没有特指度</p><p>id选择器和选择id属性的属性选择器在特指度上是有区别的</p><p>例如</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &gt; <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">table</span> <span class="hljs-selector-tag">tr</span><span class="hljs-selector-attr">[id=<span class="hljs-string">&#x27;totals&#x27;</span>]</span> <span class="hljs-selector-tag">td</span> <span class="hljs-selector-tag">ul</span> &gt;<span class="hljs-selector-tag">li</span> &#123;colors:maroon;&#125; //<span class="hljs-number">0017</span><span class="hljs-selector-tag">li</span><span class="hljs-selector-id">#answer</span> &#123;<span class="hljs-attribute">color</span>:navy;&#125;  //<span class="hljs-number">0101</span></code></pre></div><p>行内样式的特指度为1000；</p><p>!important 会超多其他声明，但是不会改变特指度</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承指的是某些样式不仅会应用到所指的元素，还会应用到元素的后代</p><p>属性值不会向上传播，即元素的样式绝不会传给祖先元素</p><p>在html中，向上传播的规则又个例外，应用在body上的背景样式会传给html元素，htm是文档的根元素，用于定义渲染的画布，这种例外仅发生在body元素定义了背景而html元素没有定义背景的情况</p><p>border属性，盒模型的属性包括margin，padding，background，border不继承</p><p>零特指度战胜没有特指度</p><p>通用选择器会应用于所有元素，    而且特指度为零，所以他声明的color会覆盖继承的color，因为继承没有特指度，通用选择器可以匹配任何选择器，所有他会覆盖继承的值，所以不要滥用通用选择器</p><h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>css使用层叠机制把样式组合在一起，即结合继承和特指度的一些规则，css层叠的规则如下</p><p>找到匹配特定元素的所有规则</p><p>按显式权重排序应用到特定元素上的所有声明，以！important声明的规则比没有的高</p><p>按来源排序应用到特定元素上的所有声明，声明有三个来源，创作人员，读者，用户代理，创作者编写的样式优先级高于读者的样式，读者中！important声明的样式权重比其他样式高，包括创作者以！important编写的样式，创作者和读者编写的样式会覆盖用户代理编写的样式</p><p>按特指度排序的应用到特定元素上的所有声明，样式表或文档中靠后的声明权重较高，导入的样式声明会放在所有样式声明的最前面。</p><p><strong>按权重和来源排序</strong></p><p>如果两个规则应用在同一个元素上，有!important的会胜出</p><p>:如果都定义了!important,!important在行内样式的会胜出</p><p>如果显式权重相同，就要考虑来源，如果匹配元素的两个样式权重相同，而一个是创作者编写的样式，另外一个是读者编写的样式，最后创作者编写的样式会生效</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">em</span> &#123;<span class="hljs-attribute">color</span>:red&#125;  //创作者编写<span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">em</span> &#123;<span class="hljs-attribute">color</span>:red&#125;  //读者编写</code></pre></div><p>在声明的权重上，要考虑五个方面，下面按权重从高到低列出</p><p>1.读者提供的样式以!important声明</p><p>2.创作者编写的样式以!important声明</p><p>3.创作者编写的常规样式</p><p>4.读者提供的常规样式</p><p>5.用户代理提供的样式</p><p><strong>按特指度排序</strong></p><p>如果应用在一个元素上的声明有冲突，而且各个声明的显式权重和来源相同，那么因该按特指度排序，特指度最高的声明胜出。</p><p><strong>按前后顺序排序</strong></p><p>如果两个规则的显式权重，来源，和特指度都相同，那么在样式表靠后的规则会胜出</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>在css中，url和开始的括号之间不可以有空格</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background</span>:<span class="hljs-built_in">url</span>()&#125;  正确<span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background</span>:url ()&#125; 错误</code></pre></div><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><div class="code-wrapper"><pre><code class="hljs arduino">&lt;image&gt;的src可以有三种值urlimage-set  只有少量浏览器支持gradient 线性或径向渐变图像</code></pre></div><h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><p>css使用calc进行简单的数学计算</p><p>calc()会检查括号中各个值的类型，确保兼容，检查方式如下：</p><p>+和-两侧的值必须使用相同类型的值，或者是number，integer，结果为number，5+2.7是有效的5em+2.7是无效的，因为一边是长度单位，一边没有，5em+20px是有效的，因为都是长度单位</p><p>*计算的两个值中必须有一个是number，因此2.5rem * 2是有效的，2rem * 2.5rem是无效的，因为结果是5rem^2,这是面积单位不是长度单位</p><p>/计算的两个值右边必须是number，左边是integer时，值式number，否则单位和左边一样，30em/2.75是有效的，30/2.75em是无效的</p><p>任何情况下都不可以/0</p><h2 id="attr"><a href="#attr" class="headerlink" title="attr()"></a>attr()</h2><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>在css中的颜色表示</p><ul><li>具名颜色</li><li>RGB颜色 可以使用百分比或者整数表示 rbg(100%,100%,100%) rgb(255,255,255),百分比的取值范围是0-100%，整数的范围0-255，都不能超过这个值，否则就会被裁减</li><li>RGBA颜色。会比RGB的基础上增加一个alpha，即red-green-blue-alpha。范围是0-1</li><li>十六进制的RGB   h1{color:#FFFFFF}. 如果16进制中每两个数值相同，可以省略一个，css允许使用简短语法，h1{color:#FFF;},为什么可以这么写，因为浏览器会把每个数字复制成两个，#F00 会变成#FF0000，#6FA变成#66FFAA，像#808080不能这么写</li><li>十六进制的RGBA。#663399AA可以写成#639A<ul><li>HSL和HSLa颜色。CSS3新增的颜色表示方法，HSL是Hue 色相 ，Satuation 饱和度，Lightness明度的简称色相是角度值取值范围是0-360，饱和度0-100的百分数明度是0-100的百分数。色相分布在一个色相环上，随着角度的旋转得到的色谱上的不同的颜色，0代表红色，旋转到360又回回到红色，p.one {color:hsl(0,%,0%)}</li></ul></li></ul><p><strong>颜色关键字</strong></p><p>有两个特殊的关键字可以在任何时候允许使用颜色值的地方使用，transparent，currentColor</p><p>transparent表示完全透明的颜色，按照css color module的定义，他与rgba(0,0,0,0)相同，这个关键字不用于定义文本颜色，主要用于定义背景色的默认值，还可以定义只占空间而不可见边框的元素，定义渐变也常用</p><p>currentColor是指当前元素color属性计算得到的值：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.main</span> &#123;<span class="hljs-attribute">color</span>:gray;<span class="hljs-attribute">border-color</span><span class="hljs-selector-pseudo">:current</span>Color;&#125;</code></pre></div><h2 id="角度"><a href="#角度" class="headerlink" title="角度"></a>角度</h2><p>deg。度数，完整的圆周是360度；</p><p>grad。百分度，完整的圆周是400百分度；</p><p>rad。 弧度，完整的圆周是2π</p><p>turn  圈数 一个完整的圆周是一圈，这个单位在旋转动画中最有用，</p><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>&#123;<span class="hljs-attr">--base-color</span>:<span class="hljs-number">#639</span>;<span class="hljs-attr">--highlight-color</span>:<span class="hljs-number">#AEA</span>;&#125;<span class="hljs-selector-tag">h1</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--base-color);&#125;<span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--highlight-color);&#125;自定义标识符使用--作为开头，并使用<span class="hljs-selector-tag">var</span>进行调用，区分大小写，自定义属性还有范围<span class="hljs-selector-tag">html</span>&#123;<span class="hljs-attr">--base-color</span>:<span class="hljs-number">#639</span>;&#125;<span class="hljs-selector-tag">aside</span>&#123;<span class="hljs-attr">--base-color</span>:<span class="hljs-number">#F60</span>;&#125;<span class="hljs-selector-tag">aside</span>中的变量作用范围在<span class="hljs-selector-tag">aside</span>元素之下，<span class="hljs-selector-tag">html</span>则作用于<span class="hljs-selector-tag">html</span>元素之下</code></pre></div><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><h3 id="text-indent-文本缩进"><a href="#text-indent-文本缩进" class="headerlink" title="text-indent 文本缩进"></a>text-indent 文本缩进</h3><p>取值:length/percentage</p><p>初始值：0</p><p>适用于：块级元素</p><p>百分数：相对于所在块级元素的宽度</p><p>计算值：百分数如上，长度值得到绝对长度</p><p>继承性：是</p><p>动画性：是</p><p>text-indent可以把元素缩进到指定的长度，缩进的长度可以是负值，例如<code>text-indent:-9999px;</code>,常用语缩进段落的第一行</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">text-indent</span>:<span class="hljs-number">2em</span>;&#125;</code></pre></div><p>Text-indent可以用于任何块级元素，缩进将沿行内方向展开，text-indent不能用于行内元素，或者置换元素例如图像，如果图像在块级元素的第一行，他将随行中的其他文本一起后移。</p><p>如果想缩进行内元素的首行，可以通过内边距或者外边距来实现，</p><p>text-indent可以是负值，常用的用法是实现悬挂缩进，即首行相比元素的其他内容悬挂在一边</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">text-indent</span>:-<span class="hljs-number">4em</span>;&#125;</code></pre></div><p>在使用负值时，避免被浏览器放入边框吃掉，建议在外部加上padding或者magin</p><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><p>取值：start｜end｜left｜right｜center｜jutify｜match-parent｜start end</p><p>初始值：css3中是start，在css2.1中是由用户代理指定</p><p>适用于：块级元素</p><p>计算值：指定值，match-parent除外</p><p>继承性：是</p><p>动画性：否</p><p>在css2.1中，对从左到右书写的语言，text-align的默认值是left，从右至左的默认值是right，在css3中，对于纵向书写的语言，left和right对应着起边和终边。</p><p><strong>两端对齐。justify</strong></p><p>两端对齐的文本，一行的两端都要和父元素的边界对齐，单词和字母之间的空白会调整，从而保证每一行的长度一致，两端对齐的文本要经过拉升，正好正满父元素左右边界之间的空间，至于如何拉升，是由用户代理来决定的，css规定，letter-spcing设置了长度值，用户代理不因该在增加和减少字符之间的间距。</p><p><strong>和父元素保持一致</strong></p><p>match-parent ，浏览器不支持这个值，他的基本作用被inherit覆盖，</p><h3 id="text-align-last"><a href="#text-align-last" class="headerlink" title="text-align-last"></a>text-align-last</h3><p>对齐最后一行</p><p>取值 auto｜start｜end｜left｜right｜center｜justify</p><p>初始值 auto</p><p>适用于 块级元素</p><p>计算值 指定值</p><p>继承性 是</p><p>动画性 否</p><p>如果段落只有一行，就是第一行也是最后一行，test-align-last的优先级会高于text-align</p><h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><p>指的是行的基线之间的距离，和font-size无关，line-height是控制行距，是除字体高度之外在文本行上方的额外空间，也就是说，line-height的值和字体之间的高度差就是行距</p><p>取值  number｜length｜percentage ｜normal</p><p>初始值 normal</p><p>适用于 所有元素</p><p>百分数 相当于font-size</p><p>计算值 长度和百分数，得到绝对值，否则，是指定值</p><p>继承性 是</p><p>动画性 是</p><p>对于块级元素而言，line-height定义元素中文本行基线之间的最小距离，定义的是最小距离，而不是固定值，基线之间的距离可能比line-height的值大,line-height不影响置换元素的布局，但是依旧会应用到置换元素上。</p><p><strong>行的构成</strong></p><p>文本行的每个元素构成一个内容去，其高度由字体的高度居定，随内容区出现的是一个inline box行内框 ，如果不考虑其他因素，他的高度和内容区的高度相同，line-height是影响内容区高度的因素之一。</p><p>元素的行距等于font-size-line-height，行距可能是负数，行距分为两半，分别是内容区的上半部分和下半部分，算上行距，就得到元素的行内距。例如font-size是14px line-height是18px 二者差4px，那么这就会被分为内容区的上半部分和下半部分，</p><p>确定一行内容的全部行内框之后，行框也就确定了，行框恰好包围最高那个行内框的顶部和最低那个行内框的底部</p><p><strong>line-height的值</strong>*</p><p>默认是normal时，行之间的距离是由用户代理来确定，不同的用户代理可能不同，不过一般是font-size的1.2倍，因此行高一般会比font-size大</p><p><strong>line-height的继承</strong></p><p>块级元素之间继承的line-height有点复杂，从父元素继承line-height值时，根据父元素的font-size进行计算，而不是根据子元素计算，</p><p>例如</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">line-height</span>:<span class="hljs-number">1em</span>;&#125;//<span class="hljs-number">10px</span>;<span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">18px</span>;&#125;</code></pre></div><p>Line-height使用纯数字的时候<code>line-height:1;</code>，纯数字就会应用到当前元素及其子元素上，元素的line-heigh将根据自身的font-size*1来计算</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">div</span>&#123;line-height:<span class="hljs-number">1</span>.<span class="hljs-number">5</span>&#125;<span class="hljs-attribute">p</span>&#123;font-size:<span class="hljs-number">18</span>px&#125;  //继承得到的line-height=<span class="hljs-number">18</span>*<span class="hljs-number">1</span>.<span class="hljs-number">5</span>px</code></pre></div><p>如果把line-height：inherit，元素的line-height将变成父元素line-height的计算值。</p><h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><p>Vertical-align只能用于置换元素如img，input等和行内元素，vertical-align不是继承属性</p><p>取值  baseline sub super top text-top middle bottom text-bottom 具体数值。百分比</p><p>初始值 baseline</p><p>适用于 行内元素和单元格</p><p>百分数。相对于元素的line-height的值</p><p>计算值 百分数和长度值，得到绝对长度，否则是指定的值</p><p>继承性 否</p><p>动画性 具体数值，百分比</p><p>备注。用于单元格上时，只能取baseline，top ，middle，bottom</p><p><strong>baseline</strong></p><p>强制元素的基线和父元素的基线对齐，正常情况下，一行中所有文本元素的底端都是对齐的</p><p>如果目标元素没有基线，像表单，图像，表单输入框，或者其他置换元素，元素底端和父元素的基线对齐</p><p><strong>sub</strong></p><p>sub把元素放在下标处，即元素的基线，对于置换元素来说就是底边线，低于父元素的基线，规范没有定义下沉🉐️距离，因此在不同🉐️1用户代理可能不同，super的·作用和sub相反，让元素的基线或者置换元素的底边线高于父元素的基线，高出的距离由用户代理来决定。</p><p>sub和super不会改变元素的font-size</p><p><strong>bottom</strong></p><p>bottom把元素所在的行内框的底边和行框的底边对齐。</p><p><strong>top</strong></p><p>top和bottom相反</p><p><strong>middle</strong></p><p>middle通常用于image上，middle把行内元素所在方框的中线与父元素基线向上偏移0.5ex处的线对齐，(1ex相当于父元素的font-size)</p><p>多数用户代理把1ex视作是半个em，因此middle把行内元素所在方框的中线与父元素基线向上偏移1/4em</p><p><strong>百分数</strong></p><p>百分数的效果是把元素的基线或者置换元素的底边相对于父元素的基线抬升或者下沉指定的量，指定的百分数是相对于元素自身而非父元素的line- height计算，</p><p>提升或者下沉文本不会和其他行重叠，，纵向对齐元素可能会改变行高，行框是包含最高的那个行内框的顶端和最低那个行内框的底端，这包括verticle-aligh的高度</p><h3 id="word-sapcing-单词间距"><a href="#word-sapcing-单词间距" class="headerlink" title="word-sapcing 单词间距"></a>word-sapcing 单词间距</h3><p>取值   具体数值 normal</p><p>默认值 normal</p><p>适用于所有元素</p><p>计算值 normal的绝对长度为0 否则为指定的具体的长度</p><p>继承性 是</p><p>动画性 是</p><h3 id="letter-spacing-字符间距"><a href="#letter-spacing-字符间距" class="headerlink" title="letter-spacing 字符间距"></a>letter-spacing 字符间距</h3><p>取值 具体数值 normal</p><p>初始值 normal</p><p>适用于 所有元素</p><p>计算值 长度得到绝对长度，否则是normal</p><p>继承性 是</p><p>动画性 是</p><h3 id="对齐方式对间距的影响"><a href="#对齐方式对间距的影响" class="headerlink" title="对齐方式对间距的影响"></a>对齐方式对间距的影响</h3><p>word-spacing的宽度可能会受到text-align的影响，如果text-align为两端对齐，为了让文字沾满整行，可能会调整文字间的宽度，word-spacing可能被调整，letter-spacing如果是数值则没有影响，如果是noraml，可能会改变距离。word-spacing和letter-spacing继承的都是计算后的值，而不是换算系数。为了让字符之间的间距和font-size成比例，必须给元素自身设置letter-spacing</p><h3 id="text-transform-文本转换"><a href="#text-transform-文本转换" class="headerlink" title="text-transform 文本转换"></a>text-transform 文本转换</h3><p>取值 uppercase lowercase capitalize none</p><p>初始值 none</p><p>适用于 所有值</p><p>计算值 指定值</p><p>继承性 是</p><p>动画性 是</p><h3 id="text-decoration-文本装饰"><a href="#text-decoration-文本装饰" class="headerlink" title="text-decoration 文本装饰"></a>text-decoration 文本装饰</h3><p>取值 none ｜underline ｜overline ｜line-through ｜ blink</p><p>初始值 none</p><p>适用于 所有元素</p><p>计算值 指定值</p><p>继承性 否</p><p>动画性 否</p><p>在一个规则中可以有多个装饰结果，如果有让a标签既有上划线又有下划线</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<span class="hljs-attribute">text-decoration</span>:underline overline;&#125;</code></pre></div><p>如果是在同一个元素上使用多个text-decoration，注意特指度</p><p>text-decoration不能够被继承</p><p>text-decoration和vertical-align同时使用，还会发生奇怪的事情，例如</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">text-decoration</span>:overline;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12pt</span>;&#125;<span class="hljs-selector-tag">sup</span> &#123;<span class="hljs-attribute">vertical-align</span>:<span class="hljs-number">50%</span>;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12pt</span>;&#125;</code></pre></div><p>p元素上有上划线，sup元素是p的子元素，所以会出现sup元素被上划线穿过的情况</p><h3 id="text-rendering"><a href="#text-rendering" class="headerlink" title="text-rendering"></a>text-rendering</h3><p>svg属性，支持他的用户代理不会把它视为一个css属性</p><h3 id="text-shadow-文本阴影"><a href="#text-shadow-文本阴影" class="headerlink" title="text-shadow 文本阴影"></a>text-shadow 文本阴影</h3><p>取值 none ｜数值｜数值 数值 数值？</p><p>初始值 none</p><p>适用于 所有元素</p><p>继承性 否</p><p>动画性 是</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-built_in">text</span>-shadow：颜色 行横偏移距离 纵向偏移距离 可选 模糊半径</code></pre></div><p>大量的阴影或者模糊半径的文本阴影会损耗性能，尤其是在低损耗和CPU性能有限的情况下，例如移动设备</p><h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><p>他会影响用户代理对文档中的空格，换行符，制表符的处理方式</p><p>取值 noraml nowrap  pre pre-wrap pre-line</p><p>适用于 全部元素，块级元素</p><p>计算值 指定值</p><p>继承性 否</p><p>动画性 否</p><table><thead><tr><th>值</th><th>空白</th><th>换行符</th><th>自动换行</th></tr></thead><tbody><tr><td>pre-line</td><td>折叠</td><td>保留</td><td>允许</td></tr><tr><td>normal</td><td>折叠</td><td>忽略</td><td>允许</td></tr><tr><td>nowrap</td><td>折叠</td><td>保留</td><td>禁止</td></tr><tr><td>pre</td><td>保留</td><td>保留</td><td>禁止</td></tr><tr><td>pre-wrap</td><td>保留</td><td>保留</td><td>允许</td></tr></tbody></table><h2 id="视觉格式化基础"><a href="#视觉格式化基础" class="headerlink" title="视觉格式化基础"></a>视觉格式化基础</h2><h3 id="元素框基础"><a href="#元素框基础" class="headerlink" title="元素框基础"></a>元素框基础</h3>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
      <category>CSS权威指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS权威指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十四章 算法设计与技巧</title>
    <link href="/2022/11/25/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/11/25/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h1><p>了归并和排序算法。两者的共同点在于它们都是分而治之算法。分而治之是算法设计中的一种方法。它将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题</p><p>分而治之算法可以分成三个部分</p><p>(1) 分解原问题为多个子问题（原问题的多个小实例）。</p><p>(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子</p><p>问题。</p><p>(3) 组合这些子问题的解决方式，得到原问题的解。</p><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>二分搜索也可以用分而治之的方式来实现</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearchRecursive</span>(<span class="hljs-params"></span><span class="hljs-params">  array,</span><span class="hljs-params">  value,</span><span class="hljs-params">  low,</span><span class="hljs-params">  high,</span><span class="hljs-params">  compareFn = defaultCompare</span><span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (low &lt;= high) &#123;    <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((low + high) / <span class="hljs-number">2</span>);    <span class="hljs-keyword">const</span> element = array[mid];    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(element, value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, mid + <span class="hljs-number">1</span>, high, compareFn);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compareFn</span>(element, value) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, low, mid - <span class="hljs-number">1</span>, compareFn);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> mid;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">DOES_NOT_ESIST</span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch2</span>(<span class="hljs-params">array, value, compareFn = defaultCompare</span>) &#123;  <span class="hljs-keyword">const</span> sortedArray = <span class="hljs-title function_">quickSort</span>(array);  <span class="hljs-keyword">const</span> low = <span class="hljs-number">0</span>;  <span class="hljs-keyword">const</span> high = sortedArray.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">binarySearchRecursive</span>(array, value, low, high, compareFn);&#125;</code></pre></div><p>在上面的算法中，我们有两个函数：binarySearch 和 binarySearchRecursive。binarySearch 函数用来暴露给开发者进行二分搜索。binarySearchRecursive 是分而治之算法。我们将 low 参数以 0 传递，将 high 参数以 sortedArray.length - 1 传递，来在已排序的数组中进行搜索。在计算 mid 元素的索引值后，我们确定待搜索的值比 mid 大还是小。如果小（行{1}）或大（行{2}），就再次调用 binarySearchRecursive 函数，但是这次，我们在子数组中进行搜索，改变 low 或 high 参数（不同于我们在第 13 章中那样移动指针）。如果不大也不小，表示我们找到了这个值（行{3}）并且这就是一种基本情形。还有一种情况是 low比 high 要大，这表示算法没有找到这个值（行{4}）。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。</p><p>注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题</p><p>用动态规划解决问题时，要遵循三个重要步骤：</p><p>(1) 定义子问题；</p><p>(2) 实现要反复执行来解决子问题的部分；</p><p>(3) 识别并求解出基线条件。</p><p>能用动态规划解决的一些著名问题如下。</p><p>背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。</p><p>最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。</p><p>矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。</p><p>硬币找零：给出面额为 <em>d</em>1, …, <em>d**n</em>的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。</p><p>图的全源最短路径：对所有顶点对(<em>u</em>, <em>v</em>)，找出从顶点 <em>u</em> 到顶点 <em>v</em> 的最短路径。我们在第 9章已经学习过这个问题的 Floyd-Warshall 算法。</p><h2 id="最少硬币找零问题"><a href="#最少硬币找零问题" class="headerlink" title="最少硬币找零问题"></a>最少硬币找零问题</h2><p>最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 <em>d</em>1, …, <em>d**n</em>及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 <em>d</em>1, …, <em>d**n</em>及其数量，找到所需的最少的硬币个数。</p><p>例如，美国有以下面额（硬币）：<em>d</em>1 = 1，<em>d</em>2 = 5，<em>d</em>3 = 10，<em>d</em>4 = 25。</p><p>如果要找 36 美分的零钱，我们可以用 1 个 25 美分、1 个 10 美分和 1 个便士（1 美分）。</p><p>如何将这个解答转化成算法？</p><p>最少硬币找零的解决方案是找到 <em>n</em> 所需的最小硬币数。但要做到这一点，首先得找到对每个</p><p><em>x</em> &lt; <em>n</em> 的解。然后，我们可以基于更小的值的解来求解</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minCoinChange</span>(<span class="hljs-params">coins, amount</span>) &#123;  <span class="hljs-keyword">const</span> cache = [];  <span class="hljs-keyword">const</span> <span class="hljs-title function_">makeChange</span> = (<span class="hljs-params">value</span>) =&gt; &#123;    <span class="hljs-keyword">if</span> (!value) &#123;      <span class="hljs-keyword">return</span> [];    &#125;    <span class="hljs-keyword">if</span> (cahce[value]) &#123;      <span class="hljs-keyword">return</span> cache[value];    &#125;    <span class="hljs-keyword">let</span> min = [];    <span class="hljs-keyword">let</span> newMin;    <span class="hljs-keyword">let</span> newAmount;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">const</span> coin = coins[i];      newAmount = value - coin;      <span class="hljs-keyword">if</span> (newAmount &gt;= <span class="hljs-number">0</span>) &#123;        newMin = <span class="hljs-title function_">makeChange</span>(newAmount);      &#125;      <span class="hljs-keyword">if</span> (        newAmount &gt;= <span class="hljs-number">0</span> &amp;&amp;        (newMin.<span class="hljs-property">length</span> &lt; min.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> || !min.<span class="hljs-property">length</span>) &amp;&amp;        (newMin.<span class="hljs-property">length</span> || !newAmount)      ) &#123;        min = [coin].<span class="hljs-title function_">concat</span>(newMin);        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;new Min &quot;</span> + min + <span class="hljs-string">&quot; for &quot;</span> + amount);      &#125;    &#125;    <span class="hljs-keyword">return</span> (cahce[value] = min);  &#125;;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">makeChange</span>(amount);&#125;</code></pre></div><p>minCoinChange 参数接收 coins 参数，该参数代表问题中的面额。对美国的硬币系统而言，它是[1, 5, 10, 25]。我们可以随心所欲地传递任何面额。此外，为了更加高效且不重复计算值，我们使用了 cache（这个技巧称为记忆化）。接下来是 minCoinChange 函数中的 makeChange 方法，它也是一个递归函数，用来解决问题。makeChange 函数在行{13}被调用，amount 作为参数传入。由于 makeChange是一个内部函数，它也能访问到 cache 变量。</p><p>为了进一步帮助我们，我们基于 coins 参数（面额）解决问题。因此，对每个面额，我们都计算 newAmount的值，它的值会一直减小，直到能找零的最小钱数（别忘了本算法对所有的 x &lt; amount 都会计算 makeChange 结果）。若 newAmount 是合理的值（正值），</p><p>我们也会计算它的找零结果。最后，我们判断 newAmount 是否有效，minValue （最少硬币数）是否是最优解，与此同时 minValue 和 newAmount 是否是合理的值。若以上判断都成立，意味着有一个比之前更优的答案（——以 5 美分为例，可以给 5 便士或者 1 个 5 美分镍币，1 个 5 美分镍币是最优解）。最后，返回最终结果。</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 <em>W</em> 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过<em>W</em>，且总价值最大</p><p>下面是一个例子。</p><table><thead><tr><th>物品</th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>2</td><td>3</td><td>4</td></tr><tr><td>3</td><td>4</td><td>5</td></tr></tbody></table><p>考虑背包能够携带的重量只有 5。对于这个例子，我们可以说最佳解决方案是往背包里装入物品 1 和物品 2。这样，总重量为 5，总价值为 7</p><p>这个问题有两个版本。<strong>0-1</strong> 版本只能往背包里装完整的物品，而<strong>分数背包问题</strong>则允许装入分数物品。在这个例子里，我们将处理该问题的 0-1 版本。动态规划对分数版本无能为力，但本章稍后要学习的贪心算法可以解决它。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 0-1背包问题</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">knapSack</span>(<span class="hljs-params">capacity, weights, values, n</span>) &#123;  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">KS</span> = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;    <span class="hljs-comment">//&#123;1&#125;</span>    <span class="hljs-variable constant_">KS</span>[i] = [];  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> w = <span class="hljs-number">0</span>; w &lt;= capacity; w++) &#123;      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || w === <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//&#123;2&#125;</span>        <span class="hljs-variable constant_">KS</span>[i][w] = <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (weights[i - <span class="hljs-number">1</span>] &lt;= w) &#123;        <span class="hljs-comment">//&#123;3&#125;</span>        <span class="hljs-keyword">const</span> a = values[i - <span class="hljs-number">1</span>] + <span class="hljs-variable constant_">KS</span>[i - <span class="hljs-number">1</span>][w - weights[i - <span class="hljs-number">1</span>]];        <span class="hljs-keyword">const</span> b = <span class="hljs-variable constant_">KS</span>[i - <span class="hljs-number">1</span>][w];        <span class="hljs-variable constant_">KS</span>[i][w] = a &gt; b ? a : b; <span class="hljs-comment">// &#123;4&#125; max(a,b)</span>      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable constant_">KS</span>[i][w] = <span class="hljs-variable constant_">KS</span>[i - <span class="hljs-number">1</span>][w]; <span class="hljs-comment">// &#123;5&#125;</span>      &#125;    &#125;  &#125;  <span class="hljs-title function_">findValues</span>(n, capacity, <span class="hljs-variable constant_">KS</span>, weights, values); <span class="hljs-comment">// &#123;6&#125; 增加的代码</span>  <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">KS</span>[n][capacity]; <span class="hljs-comment">// &#123;7&#125;</span>&#125;</code></pre></div><p>我们可以用开头的例子来测试这个算法。</p><div class="code-wrapper"><pre><code class="hljs reasonml">const values = <span class="hljs-literal">[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</span>, weights = <span class="hljs-literal">[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span>, capacity = <span class="hljs-number">5</span>, n = values.length; console.log(knap<span class="hljs-constructor">Sack(<span class="hljs-params">capacity</span>, <span class="hljs-params">weights</span>, <span class="hljs-params">values</span>, <span class="hljs-params">n</span>)</span>); <span class="hljs-comment">// 输出 7</span></code></pre></div><p>请注意，这个算法只输出背包携带物品价值的最大值，而不列出实际的物品。我们可以增加下面的附加函数来找出构成解决方案的物品。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findValues</span>(<span class="hljs-params">n, capacity, KS, weights, values</span>) &#123;  <span class="hljs-keyword">let</span> i = n;  <span class="hljs-keyword">let</span> k = capacity;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;构成解的物品：&quot;</span>);  <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; k &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">KS</span>[i][k] !== <span class="hljs-variable constant_">KS</span>[i - <span class="hljs-number">1</span>][k]) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(        <span class="hljs-string">`物品 <span class="hljs-subst">$&#123;i&#125;</span> 可以是解的一部分 w,v: <span class="hljs-subst">$&#123;weights[i - <span class="hljs-number">1</span>]&#125;</span>, <span class="hljs-subst">$&#123;values[i - <span class="hljs-number">1</span>]&#125;</span>`</span>      );      i--;      k -= <span class="hljs-variable constant_">LS</span>[i][k];    &#125; <span class="hljs-keyword">else</span> &#123;      i--;    &#125;  &#125;&#125;</code></pre></div><p>我们可以在 knapSack 函数的行{7}之前调用这个函数（在行{6}声明）。执行完整的算法，会得到如下输出。</p><p><strong>构成解的物品：</strong></p><p><strong>物品</strong> <strong>2</strong> <strong>可以是解的一部分</strong> <strong>w,v: 3,4</strong> </p><p><strong>物品</strong> <strong>1</strong> <strong>可以是解的一部分</strong> <strong>w,v: 2,3</strong> </p><p><strong>总价值</strong><strong>: 7</strong> </p><p>背包问题也可以写成递归形式。你可以在本书的源代码包中找到它的递归版本</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>另一个经常被当作编程挑战问题的动态规划问题是最长公共子序列（LCS）：找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//最长公共子序列</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">lcs</span>(<span class="hljs-params">wordX, wordY</span>) &#123;  <span class="hljs-keyword">const</span> m = wordX.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> n = wordY.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> l = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;    l[i] = []; <span class="hljs-comment">// &#123;1&#125;</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; i &lt;= n; j++) &#123;      l[i][j] = <span class="hljs-number">0</span>; <span class="hljs-comment">// &#123;2&#125;</span>    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || j === <span class="hljs-number">0</span>) &#123;        l[i][i] = <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wordX[i - <span class="hljs-number">1</span>] === wordY[j - <span class="hljs-number">1</span>]) &#123;        l[i][j] = l[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>; <span class="hljs-comment">// &#123;3&#125;</span>      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> a = l[i - <span class="hljs-number">1</span>][j];        <span class="hljs-keyword">const</span> b = l[i][j - <span class="hljs-number">1</span>];        l[i][j] = a &gt; b ? a : b; <span class="hljs-comment">// &#123;4&#125; max(a,b)</span>      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> l[m][n]; <span class="hljs-comment">// &#123;5&#125;</span>&#125;</code></pre></div><p>如果比较背包问题和 LCS 算法，我们会发现两者非常相似。这项从顶部开始构建解决方案的技术被称为记忆化，而解决方案就在表格或矩阵的右下角。</p><p>像背包问题算法一样，这种方法只输出 LCS 的长度，而不包含 LCS 的实际结果。要提取这个信息，需要对算法稍作修改，声明一个新的 solution 矩阵</p><p>注意，代码中有一些注释，我们需要用以下代码替换这些注释。</p><p> 行{1}：solution[i] = [];</p><p> 行{2}：solution[i][j] = ‘0’;</p><p> 行{3}：solution[i][j] = ‘diagonal’;</p><p> 行{4}：solution[i][j]=(l[i][j] == l[i-1][j]) ? ‘top’ : ‘left’;</p><p> 行{5}：printSolution(solution, wordX, m, n)</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printSolution</span>(<span class="hljs-params">solution, wordX, m, n</span>) &#123;  <span class="hljs-keyword">let</span> a = m;  <span class="hljs-keyword">let</span> b = n;  <span class="hljs-keyword">let</span> x = solution[a][b];  <span class="hljs-keyword">let</span> answer = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">while</span> (x !== <span class="hljs-string">&quot;0&quot;</span>) &#123;    <span class="hljs-keyword">if</span> (solution[a][b] === <span class="hljs-string">&quot;diagonal&quot;</span>) &#123;      answer = wordX[a - <span class="hljs-number">1</span>] + answer;      a--;      b--;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (solution[a][b] === <span class="hljs-string">&quot;left&quot;</span>) &#123;      b--;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (solution[a][b] === <span class="hljs-string">&quot;top&quot;</span>) &#123;      a--;    &#125;    x = solution[a][b];  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;lcs: &quot;</span> + answer);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lcs2</span>(<span class="hljs-params">wordX, wordY</span>) &#123;  <span class="hljs-keyword">const</span> m = wordX.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> n = wordY.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> solution = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;    solution[i] = []; <span class="hljs-comment">// &#123;1&#125;</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; i &lt;= n; j++) &#123;      solution[i][j] = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">// &#123;2&#125;</span>    &#125;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || j === <span class="hljs-number">0</span>) &#123;        solution[i][i] = <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wordX[i - <span class="hljs-number">1</span>] === wordY[j - <span class="hljs-number">1</span>]) &#123;        solution[i][j] = <span class="hljs-string">&quot;diagonal&quot;</span>; <span class="hljs-comment">// &#123;3&#125;</span>      &#125; <span class="hljs-keyword">else</span> &#123;        solution[i][j] = solution[i][j] == solution[i - <span class="hljs-number">1</span>][j] ? <span class="hljs-string">&quot;top&quot;</span> : <span class="hljs-string">&quot;left&quot;</span>; <span class="hljs-comment">// &#123;4&#125; max(a,b)</span>      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">printSolution</span>(solution, wordX, m, n); <span class="hljs-comment">// &#123;5&#125;</span>&#125;</code></pre></div><p>LCS 问题也可以写成递归形式。你可以在本书的源代码包中找到它的递归版本</p><h2 id="矩阵链相乘"><a href="#矩阵链相乘" class="headerlink" title="矩阵链相乘"></a>矩阵链相乘</h2><p>矩阵链相乘是另一个可以用动态规划解决的著名问题。这个问题是要找出一组矩阵相乘的最佳方式（顺序）。</p><p>让我们试着更好地理解这个问题。<em>n</em> 行 <em>m</em> 列的矩阵 <strong>A</strong> 和 <em>m</em> 行 <em>p</em> 列的矩阵 <strong>B</strong> 相乘，结果是 <em>n</em> 行 <em>p</em> 列的矩阵 <strong>C</strong>。</p><p>考虑我们想做 <strong>A</strong><em><strong>B</strong></em><strong>C</strong>*<strong>D</strong> 的乘法。因为乘法满足结合律，所以我们可以让这些矩阵以任意顺序相乘。因此，考虑如下情况：</p><p> <strong>A</strong> 是一个 10 行 100 列的矩阵；</p><p> <strong>B</strong> 是一个 100 行 5 列的矩阵；</p><p> <strong>C</strong> 是一个 5 行 50 列的矩阵；</p><p> <strong>D</strong> 是一个 50 行 1 列的矩阵；</p><p> <strong>A</strong><em><strong>B</strong></em><strong>C</strong>*<strong>D</strong> 的结果是一个 10 行 1 列的矩阵。</p><p>在这个例子里，相乘的方式有五种。</p><p>(1) (<strong>A</strong>(<strong>B</strong>(<strong>CD</strong>)))：乘法运算的次数是 1750 次。</p><p>(2) ((<strong>AB</strong>)(<strong>CD</strong>))：乘法运算的次数是 5300 次。</p><p>(3) (((<strong>AB</strong>)<strong>C</strong>)<strong>D</strong>)：乘法运算的次数是 8000 次。</p><p>(4) ((<strong>A</strong>(<strong>BC</strong>))<strong>D</strong>)：乘法运算的次数是 75 500 次。</p><p>(5) (<strong>A</strong>((<strong>BC</strong>)<strong>D</strong>))：乘法运算的次数是 31 000 次。</p><p>相乘的顺序不一样，要进行的乘法运算总数也有很大差异。那么，要如何构建一个算法，求出最少的乘法运算次数？矩阵链相乘的算法如下。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//矩阵链相乘</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">matrixChainOrder</span>(<span class="hljs-params">p</span>) &#123;  <span class="hljs-keyword">const</span> n = p.<span class="hljs-property">length</span>;  <span class="hljs-keyword">const</span> m = [];  <span class="hljs-keyword">const</span> s = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    m[i] = [];    m[i][i] = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> l = <span class="hljs-number">2</span>; l &lt; n; l++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n - l + <span class="hljs-number">1</span>; i++) &#123;      <span class="hljs-keyword">const</span> j = i + l - <span class="hljs-number">1</span>;      m[i][j] = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt;= j - <span class="hljs-number">1</span>; k++) &#123;        <span class="hljs-keyword">const</span> q = m[i][k] + m[k + <span class="hljs-number">1</span>][j] + p[i - <span class="hljs-number">1</span>] * p[k] * p[j]; <span class="hljs-comment">//&#123;1&#125;</span>        <span class="hljs-keyword">if</span> (q &lt; m[i][j]) &#123;          m[i][j] = q; <span class="hljs-comment">//&#123;2&#125;</span>        &#125;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;</code></pre></div><p>整个算法中最重要的是行{1}，神奇之处全都在这一行。它计算了给定括号顺序的乘法运算次数，并将值保存在辅助矩阵 m 中。对开头的例子执行上面的算法，会得到结果 1750。正如我们前面提到的，这是最少的运算次数。看看下面的代码。</p><div class="code-wrapper"><pre><code class="hljs arcade">const p = [<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">5</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>]; <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(matrixChainOrder(p));</code></pre></div><p>然而，这个算法也不会给出最优解的括号顺序。为了得到这些信息，我们可以对代码做一些改动。</p><p>首先，需要通过以下代码声明并初始化一个辅助矩阵 s。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = []; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;  s[i] = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>; j &lt;= n; j++)&#123;  s[i][j] = <span class="hljs-number">0</span>;  &#125; &#125;</code></pre></div><p>然后，在 matrixChainOrder 函数的行{2}添加下面的代码。</p><div class="code-wrapper"><pre><code class="hljs js">s[i][j] = k;</code></pre></div><p>在行{3}，我们调用打印括号的函数，如下所示。</p><div class="code-wrapper"><pre><code class="hljs reasonml">print<span class="hljs-constructor">OptimalParenthesis(<span class="hljs-params">s</span>, 1, <span class="hljs-params">n</span>-1)</span>;</code></pre></div><p>最后，我们的 printOptimalParenthesis 函数如</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printOptimalParenthesis</span>(<span class="hljs-params">s, i, j</span>) &#123;  <span class="hljs-keyword">if</span> (i === j) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;(&quot;</span>);    <span class="hljs-title function_">printOptimalParenthesis</span>(s, i, s[i][j]);    <span class="hljs-title function_">printOptimalParenthesis</span>(s, s[i][j] + <span class="hljs-number">1</span>, j);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;)&quot;</span>);  &#125;&#125;</code></pre></div><p>执行修改后的算法，也能得到括号的最佳顺序(A<a href="A%5B2%5D(A%5B3%5DA%5B4%5D)">1</a>)，并可以转化为(A(B(CD)))。</p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。我们来看看如何用贪心算法解决动态规划话题中最少硬币找零问题和背包问题</p><p>我们在第 12 章介绍了一些其他的贪心算法，比如 Dijkstra 算法、Prim 算法和Kruskal 算法。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十三章 排序和搜索算法</title>
    <link href="/2022/11/23/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/23/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十二章 图</title>
    <link href="/2022/11/22/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%9B%BE/"/>
    <url>/2022/11/22/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十一章 二叉队和堆排序</title>
    <link href="/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E4%BA%8C%E5%8F%89%E9%98%9F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E4%BA%8C%E5%8F%89%E9%98%9F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉队和堆排序"><a href="#二叉队和堆排序" class="headerlink" title="二叉队和堆排序"></a>二叉队和堆排序</h1><h2 id="Util-js"><a href="#Util-js" class="headerlink" title="Util.js"></a>Util.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Swap</span>(<span class="hljs-params">array, a, b</span>) &#123;  <span class="hljs-keyword">const</span> temp = array[a];  array[a] = array[b];  array[b] = temp;&#125;<span class="hljs-comment">//es6写法  有一个公开的问题表示解构操作比正常的赋值操作性能更差</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">swap1</span> = (<span class="hljs-params">array, a, b</span>) =&gt;  ([array[a], array[b]] = [array[b], array[a]]);</code></pre></div><h2 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare, <span class="hljs-title class_">Swap</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinHeap</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compareFn</span> = compareFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span> = [];  &#125;  <span class="hljs-comment">//获取左侧节点的位置</span>  <span class="hljs-title function_">getLeftIndex</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-comment">//获取右侧结点的位置</span>  <span class="hljs-title function_">getRightIndex</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;  &#125;  <span class="hljs-comment">//获取父节点的位置</span>  <span class="hljs-title function_">getParentIndex</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 这个方法向堆中插入一个新的值。如果插入成功，它返回 true，否则返回 false</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">value</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-title function_">push</span>(value);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">siftUp</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">//表示我们将要将这个值和它的父节点进行交换，直到父节点小于这个插入的值。这个上移操作也被称为 up head、percolate up、bubble up、heapify up 或 cascade up</span>  <span class="hljs-title function_">siftUp</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-comment">//获取父节点的索引</span>    <span class="hljs-keyword">let</span> parent = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getParentIndex</span>(index);    <span class="hljs-comment">//小根堆做法</span>    <span class="hljs-keyword">while</span> (      index &gt; <span class="hljs-number">0</span> &amp;&amp;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[parent], <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[index]) ===        <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>    ) &#123;      <span class="hljs-title class_">Swap</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>, paren, index);      index = parent;      parent = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getParentIndex</span>(index);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 移除最小值(小根堆)或者最大值(大根堆)并且返回该值</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">extract</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">1</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-title function_">shift</span>();    &#125;    <span class="hljs-keyword">const</span> removedValue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-title function_">shift</span>();    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">siftDown</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> removedValue;  &#125;  <span class="hljs-title function_">siftDown</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">let</span> element = index;    <span class="hljs-keyword">const</span> left = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getLeftIndex</span>(index);    <span class="hljs-keyword">const</span> right = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getRightIndex</span>(index);    <span class="hljs-keyword">const</span> size = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>();    <span class="hljs-keyword">if</span> (      left &lt; size &amp;&amp;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[element], <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[left]) ===        <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>    ) &#123;      element = left;    &#125;    <span class="hljs-keyword">if</span> (      left &lt; size &amp;&amp;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[element], <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[right]) ===        <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>    ) &#123;      element = right;    &#125;    <span class="hljs-keyword">if</span> (index !== element) &#123;      <span class="hljs-title class_">Swap</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>, index, element);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">siftDown</span>(element);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回小根堆的最小值或者大根堆的最大值但不会删除该值</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">findMinimum</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>[<span class="hljs-number">0</span>] : <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heap</span>.<span class="hljs-property">length</span>;  &#125;  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">0</span>;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第十章 树</title>
    <link href="/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%A0%91/"/>
    <url>/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-comment">//util.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;</code></pre></div><p>//</p><h2 id="树的基本构造"><a href="#树的基本构造" class="headerlink" title="树的基本构造"></a>树的基本构造</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key; <span class="hljs-comment">//节点值</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">//左侧子节点引用</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">//右侧节点引用</span>  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compareFn</span> = compareFn; <span class="hljs-comment">//用来比较节点的值</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">//node类型的根节点</span>  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 向树中插入一个新的键</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);    &#125;  &#125;  <span class="hljs-title function_">insertNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span>) &#123;        node.<span class="hljs-property">left</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">left</span>, key);      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;        node.<span class="hljs-property">right</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">right</span>, key);      &#125;    &#125;  &#125;  <span class="hljs-title function_">serachNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">serachNode</span>(node.<span class="hljs-property">left</span>, key);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">serachNode</span>(node.<span class="hljs-property">right</span>, key);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 在树中查找一个键。如果节点存在，则返回 true；如果不存在，则返回false</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">search</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">serachNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);  &#125;  <span class="hljs-title function_">inOrderTraverseNode</span>(<span class="hljs-params">node, callback</span>) &#123;    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inOrderTraverseNode</span>(node.<span class="hljs-property">left</span>, callback);      <span class="hljs-title function_">callback</span>(node.<span class="hljs-property">key</span>);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inOrderTraverseNode</span>(node.<span class="hljs-property">right</span>, callback);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 通过中序遍历方式遍历所有节点</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">inOrderTraverse</span>(<span class="hljs-params">callback</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inOrderTraverseNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, callback);  &#125;  <span class="hljs-title function_">preOrderTraverseNode</span>(<span class="hljs-params">node, callback</span>) &#123;    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-title function_">callback</span>(node.<span class="hljs-property">key</span>);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preOrderTraverseNode</span>(node.<span class="hljs-property">left</span>, callback);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preOrderTraverseNode</span>(node.<span class="hljs-property">right</span>, callback);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 通过先序遍历方式遍历所有节点</span><span class="hljs-comment">   * preOrderTraverse</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">preOrderTraverse</span>(<span class="hljs-params">callback</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preOrderTraverseNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, callback);  &#125;  <span class="hljs-title function_">postOrderTraverseNode</span>(<span class="hljs-params">node, callback</span>) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postOrderTraverseNode</span>(node.<span class="hljs-property">left</span>, callback);    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postOrderTraverseNode</span>(node.<span class="hljs-property">right</span>, callback);    <span class="hljs-title function_">callback</span>(node.<span class="hljs-property">key</span>);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 通过后序遍历方式遍历所有节点</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">postOrderTraverse</span>(<span class="hljs-params">callback</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postOrderTraverseNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, callback);  &#125;  <span class="hljs-title function_">minNode</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">let</span> current = node;    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">left</span> != <span class="hljs-literal">null</span>) &#123;      current = current.<span class="hljs-property">left</span>;    &#125;    <span class="hljs-keyword">return</span> current;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回树中最小的值/键</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">min</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">minNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>);  &#125;  <span class="hljs-title function_">maxNode</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">let</span> current = node;    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">right</span> != <span class="hljs-literal">null</span>) &#123;      current = current.<span class="hljs-property">right</span>;    &#125;    <span class="hljs-keyword">return</span> current;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 返回树中最大的值/键</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">max</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">maxNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>);  &#125;  <span class="hljs-title function_">removeNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      node.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeNode</span>(node.<span class="hljs-property">left</span>, key);      <span class="hljs-keyword">return</span> node;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeNode</span>(node.<span class="hljs-property">right</span>, key);      <span class="hljs-keyword">return</span> node;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//第一种情况，是删除叶节点</span>      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;        node = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> node;        <span class="hljs-comment">//第二种情况左子树为null</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span>) &#123;        node = node.<span class="hljs-property">right</span>;        <span class="hljs-keyword">return</span> node;        <span class="hljs-comment">//第三种情况右子树为null</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;        node = node.<span class="hljs-property">left</span>;        <span class="hljs-keyword">return</span> node;        <span class="hljs-comment">//第四种情况，左右子树都存在，需要找到右子树的自小节点或者左子树的最大节点来替换node</span>      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> aux = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">minNode</span>(node.<span class="hljs-property">right</span>);        node.<span class="hljs-property">key</span> = aux.<span class="hljs-property">key</span>;        node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeNode</span>(node.<span class="hljs-property">right</span>, aux.<span class="hljs-property">key</span>);        <span class="hljs-keyword">return</span> node;      &#125;    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 从树中移除某个键</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);  &#125;&#125;</code></pre></div><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">BinarySearchTree</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Node</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">BalancerFactor</span> = &#123;  <span class="hljs-attr">UNBALANCED_RIGHT</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">SLIGHTLY_UNBALANCED_RIGHT</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">BALANCED</span>: <span class="hljs-number">3</span>,  <span class="hljs-attr">SLIGHTLY_UNBALANCED_LEFT</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">UNBALANCED_LEFT</span>: <span class="hljs-number">5</span>,&#125;;<span class="hljs-comment">//avl树就是自平衡二叉树，就是节点的左右子树的高度差不会超过1</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BinarySearchTree</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">super</span>(compareFn);  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);  &#125;  <span class="hljs-title function_">insertNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-comment">//当这棵树是空树的时候</span>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key);      <span class="hljs-comment">//小于向前节点</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      node.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">left</span>, key);      <span class="hljs-comment">//大于当前节点</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">right</span>, key);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//和当前节点值相同时</span>      <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-comment">//判断是否平衡</span>    <span class="hljs-keyword">const</span> balancerFactor = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node);    <span class="hljs-keyword">if</span> (balancerFactor === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_LEFT</span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">left</span>.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;        node = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(node);      &#125; <span class="hljs-keyword">else</span> &#123;        node = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLR</span>(node);      &#125;    &#125;    <span class="hljs-keyword">if</span> (balancerFactor === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_RIGHT</span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">right</span>.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;        node = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(node);      &#125; <span class="hljs-keyword">else</span> &#123;        node = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRL</span>(node);      &#125;    &#125;    <span class="hljs-keyword">return</span> node;  &#125;  <span class="hljs-title function_">removeNode</span>(<span class="hljs-params">node, key</span>) &#123;    node = <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">removeNode</span>(node, key);    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-comment">//空树也是平衡树</span>      <span class="hljs-keyword">return</span> node;    &#125;    <span class="hljs-keyword">const</span> balancerFactor = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node);    <span class="hljs-keyword">if</span> (balancerFactor === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_LEFT</span>) &#123;      <span class="hljs-keyword">const</span> balancerFactorLeft = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node.<span class="hljs-property">left</span>);      <span class="hljs-keyword">if</span> (        balancerFactorLeft === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_LEFT</span> ||        balancerFactorLeft === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">SLIGHTLY_UNBALANCED_LEFT</span>      ) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(node);      &#125;      <span class="hljs-keyword">if</span> (balancerFactorLeft === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">SLIGHTLY_UNBALANCED_RIGHT</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLR</span>(node.<span class="hljs-property">left</span>);      &#125;    &#125;    <span class="hljs-keyword">if</span> (balancerFactor === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_RIGHT</span>) &#123;      <span class="hljs-keyword">const</span> balancerFactorRight = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBalanceFactor</span>(node.<span class="hljs-property">right</span>);      <span class="hljs-keyword">if</span> (        balancerFactorRight === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">UNBALANCED_RIGHT</span> ||        balancerFactorRight === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">SLIGHTLY_UNBALANCED_RIGHT</span>      ) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(node);      &#125;      <span class="hljs-keyword">if</span> (balancerFactorRight === <span class="hljs-title class_">BalancerFactor</span>.<span class="hljs-property">SLIGHTLY_UNBALANCED_LEFT</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRL</span>(node.<span class="hljs-property">right</span>);      &#125;    &#125;    <span class="hljs-keyword">return</span> node;  &#125;  <span class="hljs-comment">// 计算一个节点高度</span>  <span class="hljs-title function_">getNodeHeight</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNodeHeight</span>(node.<span class="hljs-property">left</span>),      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNodeHeight</span>(node.<span class="hljs-property">right</span>)    );  &#125;  <span class="hljs-comment">// 计算一个节点的平衡因子并返回其值</span>  <span class="hljs-title function_">getBalanceFactor</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> heightDifference =      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNodeHeight</span>(node.<span class="hljs-property">left</span>) - <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getNodeHeight</span>(node.<span class="hljs-property">right</span>);    <span class="hljs-keyword">switch</span> (heightDifference) &#123;      <span class="hljs-keyword">case</span> -<span class="hljs-number">2</span>:        <span class="hljs-keyword">break</span>;      <span class="hljs-attr">default</span>:        <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-comment">// 左左（LL）：向右的单旋转</span>  <span class="hljs-title function_">rotationLL</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> temp = node.<span class="hljs-property">left</span>;    node.<span class="hljs-property">right</span> = temp.<span class="hljs-property">left</span>;    temp.<span class="hljs-property">right</span> = node;    <span class="hljs-keyword">return</span> temp;  &#125;  <span class="hljs-title function_">rotationRR</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> temp = node.<span class="hljs-property">right</span>;    node.<span class="hljs-property">left</span> = temp.<span class="hljs-property">right</span>;    temp.<span class="hljs-property">left</span> = node;    <span class="hljs-keyword">return</span> temp;  &#125;  <span class="hljs-title function_">rotationLR</span>(<span class="hljs-params">node</span>) &#123;    node.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(node.<span class="hljs-property">left</span>);    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(node);  &#125;  <span class="hljs-title function_">rotationRL</span>(<span class="hljs-params">node</span>) &#123;    node.<span class="hljs-property">right</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(node.<span class="hljs-property">right</span>);    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(node);  &#125;&#125;</code></pre></div><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 在红黑树中，每个节点都遵循以下规则：</span><span class="hljs-comment">// (1) 顾名思义，每个节点不是红的就是黑的；</span><span class="hljs-comment">// (2) 树的根节点是黑的；</span><span class="hljs-comment">// (3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；</span><span class="hljs-comment">// (4) 如果一个节点是红的，那么它的两个子节点都是黑的；</span><span class="hljs-comment">// (5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；</span><span class="hljs-comment">// (6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">BinarySearchTree</span>, &#123; <span class="hljs-title class_">Node</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.js&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">super</span>(key);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> = <span class="hljs-literal">null</span>;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Colors</span> = &#123;  <span class="hljs-attr">RED</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">BLACK</span>: <span class="hljs-number">2</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedBlackTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">BinarySearchTree</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">super</span>(compareFn);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compareFn</span> = compareFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-title function_">isRed</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">isRed</span>;  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, key);  &#125;  <span class="hljs-title function_">insertNode</span>(<span class="hljs-params">node, key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span>) &#123;        node.<span class="hljs-property">left</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedBlackNode</span>(key);        node.<span class="hljs-property">left</span>.<span class="hljs-property">parent</span> = node;        <span class="hljs-keyword">return</span> node.<span class="hljs-property">left</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">left</span>, key);      &#125;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(key, node.<span class="hljs-property">key</span>) === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>) &#123;      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span>) &#123;        node.<span class="hljs-property">right</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedBlackNode</span>(key);        node.<span class="hljs-property">right</span>.<span class="hljs-property">parent</span> = node;        <span class="hljs-keyword">return</span> node.<span class="hljs-property">right</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertNode</span>(node.<span class="hljs-property">right</span>, key);      &#125;    &#125;  &#125;  <span class="hljs-title function_">fixTreeProperties</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">while</span> (      node &amp;&amp;      node.<span class="hljs-property">parent</span> &amp;&amp;      node.<span class="hljs-property">parent</span>.<span class="hljs-property">color</span>.<span class="hljs-title function_">isRed</span>() &amp;&amp;      node.<span class="hljs-property">color</span> !== <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>    ) &#123;      <span class="hljs-keyword">let</span> parent = node.<span class="hljs-property">parent</span>;      <span class="hljs-keyword">const</span> grendparent = parent.<span class="hljs-property">parent</span>;      <span class="hljs-comment">// 情形 A1：父节点是左侧子节点</span>      <span class="hljs-keyword">if</span> (grendparent &amp;&amp; grendparent.<span class="hljs-property">left</span> === parent) &#123;        <span class="hljs-keyword">const</span> uncle = grendparent.<span class="hljs-property">right</span>;        <span class="hljs-keyword">if</span> (uncle &amp;&amp; uncle.<span class="hljs-property">color</span> === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>) &#123;          grendparent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;          uncle.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          parent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          node = grendparent;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 情形 2A：节点是右侧子节点——左旋转</span>          <span class="hljs-keyword">if</span> (node === parent.<span class="hljs-property">right</span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(parent);            node = parent;            parent = node.<span class="hljs-property">parent</span>;          &#125;          <span class="hljs-comment">// 情形 3A：节点是左侧子节点——右旋转</span>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(grendparent);          parent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          grendparent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;          node = parent;        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> uncle = grendparent.<span class="hljs-property">left</span>;        <span class="hljs-keyword">if</span> (uncle &amp;&amp; uncle.<span class="hljs-property">color</span> === <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>) &#123;          grendparent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;          uncle.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          parent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          node = grendparent;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 情形 2B：节点是左侧子节点——右旋转</span>          <span class="hljs-keyword">if</span> (node === parent.<span class="hljs-property">left</span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationLL</span>(parent);            node = parent;            parent = node.<span class="hljs-property">parent</span>;          &#125;          <span class="hljs-comment">// 情形 3B：节点是右侧子节点——左旋转</span>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">rotationRR</span>(grendparent);          parent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;          grendparent.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">RED</span>;          node = parent;        &#125;      &#125;    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>.<span class="hljs-property">color</span> = <span class="hljs-title class_">Colors</span>.<span class="hljs-property">BLACK</span>;  &#125;  <span class="hljs-title function_">rotationLL</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> temp = node.<span class="hljs-property">left</span>;    node.<span class="hljs-property">left</span> = temp.<span class="hljs-property">right</span>;    <span class="hljs-keyword">if</span> (temp.<span class="hljs-property">right</span> &amp;&amp; temp.<span class="hljs-property">right</span>.<span class="hljs-property">key</span>) &#123;      temp.<span class="hljs-property">right</span>.<span class="hljs-property">parent</span> = node;    &#125;    temp.<span class="hljs-property">parent</span> = node.<span class="hljs-property">parent</span>;    <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">parent</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = temp;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (node === node.<span class="hljs-property">parent</span>.<span class="hljs-property">left</span>) &#123;        node.<span class="hljs-property">parent</span>.<span class="hljs-property">left</span> = temp;      &#125; <span class="hljs-keyword">else</span> &#123;        node.<span class="hljs-property">parent</span>.<span class="hljs-property">right</span> = temp;      &#125;    &#125;    temp.<span class="hljs-property">right</span> = node;    node.<span class="hljs-property">parent</span> = temp;  &#125;  <span class="hljs-title function_">rotationRR</span>(<span class="hljs-params">node</span>) &#123;    <span class="hljs-keyword">const</span> temp = node.<span class="hljs-property">right</span>;    node.<span class="hljs-property">right</span> = temp.<span class="hljs-property">left</span>;    <span class="hljs-keyword">if</span> (temp.<span class="hljs-property">left</span> &amp;&amp; temp.<span class="hljs-property">left</span>.<span class="hljs-property">key</span>) &#123;      temp.<span class="hljs-property">left</span>.<span class="hljs-property">parent</span> = node;    &#125;    temp.<span class="hljs-property">parent</span> = node.<span class="hljs-property">parent</span>;    <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">parent</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = temp;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (node === node.<span class="hljs-property">parent</span>.<span class="hljs-property">left</span>) &#123;        node.<span class="hljs-property">parent</span>.<span class="hljs-property">left</span> = temp;      &#125; <span class="hljs-keyword">else</span> &#123;        node.<span class="hljs-property">parent</span>.<span class="hljs-property">right</span> = temp;      &#125;    &#125;    temp.<span class="hljs-property">right</span> = node;    node.<span class="hljs-property">parent</span> = temp;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第八章 字典和散列表</title>
    <link href="/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <url>/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="字典和散列表"><a href="#字典和散列表" class="headerlink" title="字典和散列表"></a>字典和散列表</h1><h2 id="Util-js"><a href="#Util-js" class="headerlink" title="Util.js"></a>Util.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;</code></pre></div><h2 id="linked-list-models-js"><a href="#linked-list-models-js" class="headerlink" title="linked-list-models.js"></a>linked-list-models.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义每个节点的信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">undefined</span>;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element, next, prev</span>) &#123;    <span class="hljs-variable language_">super</span>(element, next);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = prev;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePair</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`[<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.key&#125;</span>,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.value&#125;</span>]`</span>;  &#125;&#125;</code></pre></div><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ValuePair</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; defaultToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dictionary</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">toStrFn = defaultToString</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span> = toStrFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 向字典中添加新元素。如果 key 已经存在，那么已存在的 value 会 被新的值覆盖。</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">value</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> &amp;&amp; value != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key)] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(key, value);      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">//通过使用键值作为参数来从字典中移除键值对应的数据值</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasKey</span>(key)) &#123;      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key)];      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 如果某个键值存在于该字典中，返回 true，否则返回 false</span>  <span class="hljs-title function_">hasKey</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key)] != <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-comment">//  通过以键值作为参数查找特定的数值并返回</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> valuePair = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span>[key]];    <span class="hljs-keyword">return</span> valuePair == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;undefined&quot;</span> : valuePair.<span class="hljs-property">value</span>;  &#125;  <span class="hljs-comment">//删除该字典中的所有值</span>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">//返回字典所包含值的数量。与数组的 length 属性类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>).<span class="hljs-property">length</span>;  &#125;  <span class="hljs-comment">//在 size 等于零的时候返回 true，否则返回 false</span>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 将字典所包含的所有键名以数组形式返回</span>  <span class="hljs-title function_">keys</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">keyValues</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">valuePair</span>) =&gt;</span> valuePair.<span class="hljs-property">key</span>);  &#125;  <span class="hljs-comment">// 将字典所包含的所有数值以数组形式返回</span>  <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">keyValues</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">valuePair</span>) =&gt;</span> valuePair.<span class="hljs-property">value</span>);  &#125;  <span class="hljs-comment">//将字典中所有[键，值]对返回</span>  <span class="hljs-title function_">keyValues</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// return Object.values(this.table);</span>    <span class="hljs-keyword">const</span> valuePairs = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasKey</span>(key)) &#123;        valuePairs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[key]);      &#125;    &#125;    <span class="hljs-keyword">return</span> valuePairs;  &#125;  <span class="hljs-comment">//迭代字典中所有的键值对。callbackFn 有两个参数:key 和value。该方法可以在回调函数返回 false 时被中止(和 Array 类中的 every 方法相似)。</span>  <span class="hljs-title function_">foreach</span>(<span class="hljs-params">callbackFN</span>) &#123;    <span class="hljs-keyword">const</span> valuePairs = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">keyValues</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; valuePairs.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callbackFN</span>(valuePairs[i].<span class="hljs-property">key</span>, valuePairs[i].<span class="hljs-property">value</span>);      <span class="hljs-keyword">if</span> (result === <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">break</span>;      &#125;    &#125;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;    <span class="hljs-keyword">const</span> valuePairs=<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">keyValues</span>()    <span class="hljs-keyword">let</span> str=valuePairs[<span class="hljs-number">0</span>].<span class="hljs-title function_">toString</span>()    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>=<span class="hljs-number">1</span>;i&lt;valuePairs.<span class="hljs-property">length</span>;i++)&#123;      str+=<span class="hljs-string">`,<span class="hljs-subst">$&#123;valuePairs[i].toString()&#125;</span>`</span>    &#125;    <span class="hljs-keyword">return</span> str  &#125;&#125;</code></pre></div><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>HashTable 类，也叫 HashMap 类，它是 Dictionary 类的一种散列表实现方式。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ValuePair</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models&quot;</span>;<span class="hljs-keyword">import</span> &#123; defaultToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 基础版，相同的hashkey的话会被覆盖</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">toStrFn = defaultToString</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span> = toStrFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 向散列表增加一个新的项（也能更新散列表）</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">key</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; <span class="hljs-variable">value</span></span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(position, value);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-comment">// 根据键值从散列表中移除值</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> hash = <span class="hljs-variable language_">this</span>.<span class="hljs-property">hashCode</span>[key];    <span class="hljs-keyword">const</span> valuePair = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[hash];    <span class="hljs-keyword">if</span> (valuePair != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[hash];      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 返回根据键值检索到的特定的值</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> valuePair = thia.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key)];    <span class="hljs-keyword">return</span> valuePair == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : valuePair.<span class="hljs-property">value</span>;  &#125;  <span class="hljs-title function_">loseloseHashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">&quot;number&quot;</span>) &#123;      <span class="hljs-keyword">return</span> key;    &#125;    <span class="hljs-keyword">const</span> tableKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key);    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tableKey.<span class="hljs-property">length</span>; i++) &#123;      hash += <span class="hljs-variable language_">this</span>.<span class="hljs-property">tableKey</span>.<span class="hljs-title function_">charCodeAt</span>(tableKey[i]);    &#125;    <span class="hljs-keyword">return</span> hash % <span class="hljs-number">37</span>;  &#125;  <span class="hljs-title function_">hashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loseloseHashCode</span>(key);  &#125;&#125;</code></pre></div><h2 id="处理散列表中的冲突"><a href="#处理散列表中的冲突" class="headerlink" title="处理散列表中的冲突"></a>处理散列表中的冲突</h2><p>分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defaultToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../LinkedList/LinkedList&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ValuePair</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTableSeparateChaining</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">toStrFn = defaultToString</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span> = toStrFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-title function_">loseloseHashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">&quot;number&quot;</span>) &#123;      <span class="hljs-keyword">return</span> key;    &#125;    <span class="hljs-keyword">const</span> tableKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key);    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tableKey.<span class="hljs-property">length</span>; i++) &#123;      hash += <span class="hljs-variable language_">this</span>.<span class="hljs-property">tableKey</span>.<span class="hljs-title function_">charCodeAt</span>(tableKey[i]);    &#125;    <span class="hljs-keyword">return</span> hash % <span class="hljs-number">37</span>;  &#125;  <span class="hljs-title function_">hashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loseloseHashCode</span>(key);  &#125;  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> || value != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position] == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();      &#125;      <span class="hljs-keyword">const</span> valuePair = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(key, value);      <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position].<span class="hljs-title function_">push</span>(valuePair);      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">const</span> linkedList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position];    <span class="hljs-keyword">if</span> (linkedList != <span class="hljs-literal">null</span> &amp;&amp; !linkedList.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">let</span> current = linkedList.<span class="hljs-title function_">getHead</span>();      <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">element</span>.<span class="hljs-property">key</span> === key) &#123;          <span class="hljs-keyword">return</span> current.<span class="hljs-property">element</span>.<span class="hljs-property">value</span>;        &#125;        current = current.<span class="hljs-property">next</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">const</span> linkedList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position];    <span class="hljs-keyword">if</span> (linkedList != <span class="hljs-literal">null</span> &amp;&amp; !linkedList.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">let</span> current = linkedList.<span class="hljs-title function_">getHead</span>();      <span class="hljs-keyword">while</span> (!current) &#123;        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">element</span>.<span class="hljs-property">key</span> === key) &#123;          linkedList.<span class="hljs-title function_">remove</span>(current.<span class="hljs-property">element</span>);          <span class="hljs-keyword">if</span> (linkedList.<span class="hljs-title function_">isEmpty</span>()) &#123;            <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position];          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        current = current.<span class="hljs-property">next</span>;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;&#125;</code></pre></div><p>另一种解决冲突的方法是线性探查。之所以称作线性，是因为它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defaultToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../LinkedList/LinkedList&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ValuePair</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTableLinearProbing</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">toStrFn = defaultToString</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">toStrFn</span> = toStrFn;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = &#123;&#125;;  &#125;  <span class="hljs-title function_">loseloseHashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">&quot;number&quot;</span>) &#123;      <span class="hljs-keyword">return</span> key;    &#125;    <span class="hljs-keyword">const</span> tableKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key);    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tableKey.<span class="hljs-property">length</span>; i++) &#123;      hash += <span class="hljs-variable language_">this</span>.<span class="hljs-property">tableKey</span>.<span class="hljs-title function_">charCodeAt</span>(tableKey[i]);    &#125;    <span class="hljs-keyword">return</span> hash % <span class="hljs-number">37</span>;  &#125;  <span class="hljs-comment">//另外一种散列函数</span>  <span class="hljs-title function_">djb2HashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> tableKey = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toStrFn</span>(key);    <span class="hljs-keyword">let</span> hash = <span class="hljs-number">5381</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; tableKey.<span class="hljs-property">length</span>; i++) &#123;      hash = hash * <span class="hljs-number">33</span> + tableKey.<span class="hljs-title function_">charCodeAt</span>(i);    &#125;    <span class="hljs-keyword">return</span> hash % <span class="hljs-number">1013</span>;  &#125;  <span class="hljs-title function_">hashCode</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loseloseHashCode</span>(key);  &#125;  <span class="hljs-title function_">put</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span> &amp;&amp; value != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position]) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(key, value);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> index = position + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index]) &#123;          index++;        &#125;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValuePair</span>(key, value);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position]) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position].<span class="hljs-property">key</span> === key) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position].<span class="hljs-property">value</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> index = position + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> !== key) &#123;          index++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> === key) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">value</span>;        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-title function_">remove</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position]) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position].<span class="hljs-property">key</span> === key) &#123;        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[position];        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">verifyRemoveSideEffect</span>(key, position);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> index = position + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> !== key) &#123;          index++;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span> === key) &#123;          <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index];          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">verifyRemoveSideEffect</span>(key, index);          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-title function_">verifyRemoveSideEffect</span>(<span class="hljs-params">key, removedPosition</span>) &#123;    <span class="hljs-keyword">const</span> hash = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hashCode</span>(key);    <span class="hljs-keyword">let</span> index = removedPosition + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index] != <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">const</span> posHash = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index].<span class="hljs-property">key</span>];      <span class="hljs-keyword">if</span> (posHash &lt;= hash || posHash &lt;= removedPosition) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[removedPosition] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index];        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span>[index];        removedPosition = index;      &#125;      index++;    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第七章 集合</title>
    <link href="/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9B%86%E5%90%88/"/>
    <url>/2022/11/20/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set1</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">// 向集合添加一个新元素</span>  <span class="hljs-title function_">add</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(element)) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[element] = element;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 从集合移除一个元素</span>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">has</span>(element)) &#123;      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[element];      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 如果元素在集合中，返回 true，否则返回 false</span>  <span class="hljs-title function_">has</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-comment">// return element in this.items;</span>    <span class="hljs-comment">// 优化</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 我们也可以在代码中使用 this.items.hasOwnProperty(element)。但是， 如果这样的话，代码检查工具如 ESLint 会抛出一个错误。错误的原因为不是所 有的对象都继承了 Object.prototype，甚至继承了 Object.prototype 的对 象上的 hasOwnProperty 方法也有可能被覆盖，导致代码不能正常工作。要避 免出现任何问题，使用 Object.prototype.hasOwnProperty.call 是更安 全的做法。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>, element);  &#125;  <span class="hljs-comment">// 移除集合中的所有元素</span>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">// 返回集合所包含元素的数量。它与数组的 length 属性类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>).<span class="hljs-property">length</span>;  &#125;  <span class="hljs-comment">// 返回一个包含集合中所有值(元素)的数组</span>  <span class="hljs-title function_">values</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>);  &#125;  <span class="hljs-comment">// union 并集:对于给定的两个集合，返回一个包含两个集合中所有元素的新集合</span>  <span class="hljs-title function_">union</span>(<span class="hljs-params">otherElements</span>) &#123;    <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set1</span>();    <span class="hljs-keyword">const</span> otherValue = otherElements.<span class="hljs-title function_">values</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; otherValue.<span class="hljs-property">length</span>; i++) &#123;      set.<span class="hljs-title function_">add</span>(otherValue[i]);    &#125;    <span class="hljs-keyword">const</span> values = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">values</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.<span class="hljs-property">length</span>; i++) &#123;      set.<span class="hljs-title function_">add</span>(values[i]);    &#125;    <span class="hljs-keyword">return</span> set;  &#125;  <span class="hljs-title function_">intersection</span>(<span class="hljs-params">otherSet</span>) &#123;    <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set1</span>();    <span class="hljs-comment">// const values = this.values();</span>    <span class="hljs-comment">// for (let i = 0; i &lt; values.length; i++) &#123;</span>    <span class="hljs-comment">//   if (otherSet.has(values[i])) &#123;</span>    <span class="hljs-comment">//     set.add(values[i]);</span>    <span class="hljs-comment">//   &#125;</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">//针对长度不同的set做交集的时候的优化</span>    <span class="hljs-keyword">let</span> values = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">values</span>();    <span class="hljs-keyword">let</span> otherValues = otherSet.<span class="hljs-title function_">values</span>();    <span class="hljs-keyword">let</span> biggerSet = values;    <span class="hljs-keyword">let</span> smallerSet = otherValues;    <span class="hljs-keyword">if</span> (biggerSet.<span class="hljs-property">length</span> - smallerSet.<span class="hljs-property">length</span> &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">let</span> middle = biggerSet;      biggerSet = smallerSet;      smallerSet = middle;    &#125;    smallerSet.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (biggerSet.<span class="hljs-title function_">includes</span>(item)) &#123;        set.<span class="hljs-title function_">add</span>(item);      &#125;    &#125;);    <span class="hljs-keyword">return</span> set;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集</span><span class="hljs-comment">合的元素的新集合</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; otherSet </span><span class="hljs-comment">   * <span class="hljs-doctag">@returns</span> </span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">difference</span>(<span class="hljs-params">otherSet</span>) &#123;    <span class="hljs-keyword">const</span> differenceSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set1</span>();    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (!otherSet.<span class="hljs-title function_">has</span>(item)) &#123;        differenceSet.<span class="hljs-title function_">add</span>(item);      &#125;    &#125;);    <span class="hljs-keyword">return</span> differenceSet;  &#125;  <span class="hljs-title function_">isSubsetOf</span>(<span class="hljs-params">otherSet</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() &gt; otherSet.<span class="hljs-title function_">size</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">let</span> isSubset = <span class="hljs-literal">true</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">values</span>().<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (!otherSet.<span class="hljs-title function_">has</span>(item)) &#123;        isSubset = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;);    <span class="hljs-keyword">return</span> isSubset;  &#125;&#125;<span class="hljs-comment">// const set = new Set1();</span><span class="hljs-comment">// set.add(1);</span><span class="hljs-comment">// console.log(set.values()); // 输出[1] console.log(set.has(1)); // 输出true console.log(set.size()); // 输出1</span><span class="hljs-comment">// set.add(2);</span><span class="hljs-comment">// console.log(set.values()); // 输出[1, 2] console.log(set.has(2)); // 输出true console.log(set.size()); // 输出2</span><span class="hljs-comment">// set.delete(1);</span><span class="hljs-comment">// console.log(set.values()); // 输出[2]</span><span class="hljs-comment">// set.delete(2);</span><span class="hljs-comment">// console.log(set.values()); // 输出[]</span><span class="hljs-comment">// const setA = new Set1();</span><span class="hljs-comment">// setA.add(1);</span><span class="hljs-comment">// setA.add(2);</span><span class="hljs-comment">// setA.add(3);</span><span class="hljs-comment">// const setB = new Set1();</span><span class="hljs-comment">// setB.add(3);</span><span class="hljs-comment">// setB.add(4);</span><span class="hljs-comment">// setB.add(5);</span><span class="hljs-comment">// setB.add(6);</span><span class="hljs-comment">// const unionAB = setA.union(setB);</span><span class="hljs-comment">// console.log(unionAB.values());</span><span class="hljs-comment">// const setA = new Set1();</span><span class="hljs-comment">// setA.add(1);</span><span class="hljs-comment">// setA.add(2);</span><span class="hljs-comment">// setA.add(3);</span><span class="hljs-comment">// const setB = new Set1();</span><span class="hljs-comment">// setB.add(2);</span><span class="hljs-comment">// setB.add(3);</span><span class="hljs-comment">// setB.add(4);</span><span class="hljs-comment">// const intersectionAB = setA.intersection(setB);</span><span class="hljs-comment">// console.log(intersectionAB.values());</span><span class="hljs-comment">// const setA = new Set1();</span><span class="hljs-comment">// setA.add(1);</span><span class="hljs-comment">// setA.add(2);</span><span class="hljs-comment">// const setB = new Set1();</span><span class="hljs-comment">// setB.add(1);</span><span class="hljs-comment">// setB.add(2);</span><span class="hljs-comment">// setB.add(3);</span><span class="hljs-comment">// const setC = new Set1();</span><span class="hljs-comment">// setC.add(2);</span><span class="hljs-comment">// setC.add(3);</span><span class="hljs-comment">// setC.add(4);</span><span class="hljs-comment">// console.log(setA.isSubsetOf(setB));</span><span class="hljs-comment">// console.log(setA.isSubsetOf(setC));</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Set1</span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层</title>
    <link href="/2022/11/20/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2022/11/20/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="/2022/11/20/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2022/11/20/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2022/11/20/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2022/11/20/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层</title>
    <link href="/2022/11/20/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2022/11/20/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是Puppeteer</title>
    <link href="/2022/11/08/Puppeteer/"/>
    <url>/2022/11/08/Puppeteer/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Puppeteer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>物理层</title>
    <link href="/2022/11/06/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2022/11/06/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="物理层的接口特性"><a href="#物理层的接口特性" class="headerlink" title="物理层的接口特性"></a>物理层的接口特性</h2><p>物理层解决如何在连接各种计算机的传输媒体上传输比特流数据，而不是指具体的传输媒体，就是具体的010101</p><p>物理层的主要任务：确定与传输媒体接口相关的一些特性</p><p>1.机械特性。定义物理连接的特性，规定物理连接时所采用的规格，接口形状，引脚数量和排列状况</p><p>2.电气特性。规定传输二进制位时，线路上信号的电压范围，阻抗匹配，传输速率·和距离限制等</p><p>3.功能特性。指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途</p><p>4.规程特性（过程特性）定义各条物理线路的工作规程和时许关系</p><h2 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h2><p>通信的目的是传输消息</p><p>数据：传输信息的实体，通常是有意义的符号序列</p><p>信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式</p><p>​            数字信号/离散信号：代表信息的参数的取值是离散的</p><p>​            模拟信号/连续信号：代表消息的参数的取值是连续的</p><p>信源：产生和发送数据的源头</p><p>信宿：接受数据的终点</p><p>信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和接受信道</p><p>信道 按传输信号分为 模拟信道和数字信道，按传输介质分为有线信道和无线信道</p><h2 id="设计数据通信系统要考虑3个问题"><a href="#设计数据通信系统要考虑3个问题" class="headerlink" title="设计数据通信系统要考虑3个问题"></a>设计数据通信系统要考虑3个问题</h2><ul><li><p>采用单工通信/半双工通信/全双工通信方式？</p></li><li><p>采用串行通信/并行通信？</p></li><li><p>采用同步通信还是异步通信</p></li></ul><h3 id="三种通信方式"><a href="#三种通信方式" class="headerlink" title="三种通信方式"></a>三种通信方式</h3><p>单工通信</p><p>​    只有一个方向的通信而没有反方向的交互，仅需一条信道</p><p>半双工通信/双向交替通信</p><p>​    通信的双方都可以发送或者接受信息，但是任何一方都不能同时发送或者接受</p><p>全双工/双向同时通信</p><p>​    通信双方可以同时发送或者接受信息，也需要两条信道</p><h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><p>串行传输。将表示一个字符的8位二进制数按由低位到高位的顺序依次发送，速度慢，费用低，适合远距离传输</p><p>并行传输。将表示一个字符的8位二进制数同时通过8条信道发送。速度快，费用高，适合近距离传输，计算机内部就是并行传输</p><p>同步传输。 在同步传输模式下，数据的传送是以一个数据块为单位，因此同步传输又称为区块传输，在传输数据时，需要先送出一个或者多个同步字符，再送出一批数据</p><p>异步传输。异步传输是将比特分成小组进行传输，小组可以是8位的一个字符或者更长，发送方可以在任何时候发送这些比特组，而接收方不知道他们会在什么时候到达，传送数据时，加一个字符起始位和字符终止位</p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>码元是指一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称之为k进制码元，而该时长称之为码元宽度，当码元的离散状态有m个时（m&gt;2），此时码元称之为m进制码元。</p><p>一码元可以携带多个比特的信息量，例如使用二进制码元的时候只有两种状态·的码元，1，0</p><p>k进制码元，例如4进制码元，码元的离散状态有4个，四种高低不同的码元，00，01，10，11</p><h2 id="数字通信系统数据传输速率的两种表示方法"><a href="#数字通信系统数据传输速率的两种表示方法" class="headerlink" title="数字通信系统数据传输速率的两种表示方法"></a>数字通信系统数据传输速率的两种表示方法</h2><p>速率也叫数据率，是指数据的传输速率，表示单位时间传输的数据量，可以用码元传输速率和信息传输速率来表示</p><p>码元传输速率：也叫码元速率，波形速率，调制速率，符号速率，他表示单位时间内数字通信系统所传输的码元个数（也称为脉冲个数或者信号变化的次数），单位是波特(Baud),1波特表示数字通信每秒传输一个码元</p><p>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关。<br>$$<br>R=1/T(B)<br>$$<br>信息传输速率：别名信息速率，比特率，表示单位时间内数字通信系统传输的二进制码元个数即比特数，单位是比特/秒（b/s）</p><p>关系：若一个码元携带nbit的信息量，则M Baud的码元传输速率所对应的信息传输速率为Mxnbit/s</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="/2022/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2022/11/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="计算机网路的概念"><a href="#计算机网路的概念" class="headerlink" title="计算机网路的概念"></a>计算机网路的概念</h4><p>计算机网络是一个将分散的，具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</p><p>计算机网络是互连的，自治的计算机集合</p><p>互连-通过通信链路互联互通</p><p>自治-无主从关系</p><h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><p>数据通信</p><p>资源共享</p><p>分布式处理</p><p>提高可靠性</p><p>负载均衡</p><h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><p>组成部分：硬件，软件，协议（一系列规则和约定的集合）</p><p>工作方式：</p><p>​    1.边缘部分  为用户直接使用的 ：c/s方式。 P2P方式</p><p>​    2.核心部分  为边缘部分服务</p><p>功能组成：</p><p>​    分为通信子网和资源子网，通信子网实现数据通信，资源子网实现资源共享和数据处理</p><p>​    资源子网是实现资源共享功能的设备和软件的集合，包括OSI参考模型中的应用层，表示层，会话层</p><p>​    通信子网是由各种传输介质，通信设备，相应的网络协议组成，包括OSI参考模型中的传输层，网络层，数据链路层，物理层等组成</p><h4 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h4><ol><li>按分布范围分广域网(WAN),城域网(MAN)，局域网(LAN),个人区域网(PAN)，前两者使用的是交换技术，后两者使用的是广播技术</li><li>按使用者分为公共网和专用网</li><li>按交换技术分为电路交换 报文交换分组交换</li><li>按拓扑结构分为 总线型 星型 环型网状型</li><li>按传播技术分为广播式网络（共享公共通信信道）点对点网络 （是用分组存储转发和路由选择机制）</li></ol><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h5><p>速率就是数据率或者数据传输率或者比特率</p><p>比特 由0/1组成</p><p>连接计算机网络上的主机在数字信道上传送数据位数的速率</p><p>单位是b/s kb/s Mb/s Gb/s Tb/s</p><p>速率使用小写的b表示，而存储容量 1Byte 字节=8 bit</p><p>1kb/s=10^3b/s</p><p>1Mb/s=10^3 kb/s =10^6b/s</p><p>1Gb/s=10^3 Mb/s =10^6 kb/s=10^9 b/s</p><p>1Tb/s=10^3 Gb/s=….</p><h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><p>原本指的是某个信号具有的频带宽度，及最高频率和最低频率之差，单位是赫兹hz</p><p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一个点到另一个点所能通过的最高数据率，单位是比特每秒 b/s kb/s mb/s gb/s tb/s</p><p>网络设备具备的最高速度</p><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>表示单位时间内通过的某个网络(或者信道，接口)的数据量，单位是b/s Kb/s Mb/s</p><p>吞吐量受网络带宽或者网络的额定速率的限制</p><h5 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h5><p>指数据(报文/分组/比特流)从网络或早或者链路的一端传送到另一端所需要的时间，也叫时延或者迟延，单位是s</p><p>时延分为发送时延(传输时延)，传播时延，排队时延，处理时延</p><p>发送时延：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需要的时间<br>$$<br>发送时延=数据长度/信号带宽(发送速率)<br>$$<br>传播时延：取决于电磁波传播速度和链路长度<br>$$<br>传播时延=信道长度/电磁波在信道上的传播速率<br>$$<br>排队时延：等待输入/出链路可用</p><p>处理时延：检错找出口</p><h5 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h5><p>$$<br>时延带宽积=传播时延*带宽<br>$$</p><p>时延带宽积又称为以比特为单位的链路长度，既某段链路现在有多少比特。 容量</p><h5 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h5><p>从发送方发送数据开始到发送方到接收方确认（接收方收到数据后立即发送确认）总共经历的时延</p><p>RTT包括末端处理时间，往返传播时延=传播时延*2</p><h5 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h5><p>$$<br>信道利用率=有数据通过的时间/（有+无）数据通过的时间<br>$$</p><p>$$<br>网络利用率=信道利用率加权平均值<br>$$</p><h4 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h4><p>网络体系分层结构是从功能上描述计算机网络的结构</p><p>计算机网络体系结构简称计算机网络体系结构是分层结构</p><p>每层遵循某些网络协议以完成本层的功能</p><p>计算机网络体系结构是计算机网络的各层及其协议的集合</p><p>第n层在向n+1层提供服务的时候，该服务不仅包括第n层本身的功能，海波啊哭哦由下层服务提供的功能</p><p>仅仅在相邻层间有街口，且所提供的服务的具体实现细节对上一层完全屏蔽</p><p>体系结构是抽象的·，而实现是指运行的一些软件和硬件</p><h4 id="OSI-ISO参考模型"><a href="#OSI-ISO参考模型" class="headerlink" title="OSI/ISO参考模型"></a>OSI/ISO参考模型</h4><p>应用层</p><p>​    所有能和用户交互产生网络流量的程序</p><p>​    典型的应用层服务：</p><p>​            文件传输（FTP）</p><p>​            电子邮件 （SMTP）</p><p>​            万维网（http）</p><p>表示层</p><p>​    用于处理在两个通信系统中交换信息的表达方式(语法和语义)</p><p>​    功能一：数据格式变换</p><p>​    功能二：数据加密解密</p><p>​    功能三：数据压缩和恢复</p><p>​    主要协议：JPEG,ASCII</p><p>会话层</p><p>​     向表示层实体/用户进程提供建立连接并在连接上有序地传输数据，这是会话，也是建立同步(SYN)</p><p>​     功能一：建立，管理，终止会话</p><p>​     功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步，适用于传输大文件</p><p>​     主要协议：ADSP，ASP</p><p>传输层</p><p>​     负责主机中两个进程的通信，即端对端的通信，传输单位是报文段或者用户数据报</p><p>​     功能一：可靠传输，不可靠传输</p><p>​     功能二：差错控制</p><p>​     功能三：流量控制</p><p>​    主要协议：TCP,UDP</p><p>网络层</p><p>​     主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报</p><p>​     功能一：路由选择 最佳路径</p><p>​     功能二：流量控制</p><p>​     功能三：差错控制</p><p>​     功能四：拥塞控制</p><p>​    若所有的结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞</p><p>​    主要协议：IP,IPX,ICMP,IGMP,ARP,RARP,OSPF</p><p>数据链路层</p><p>​    主要任务是把网络层传下来的数据报组装成帧。数据链路层的传输单位是帧。</p><p>​    功能一：成帧（定义帧的开始和结束）</p><p>​    功能二：差错控制 帧错+位错</p><p>​    功能三：流量控制</p><p>​    功能四：访问（接入）控制 控制对信道的访问</p><p>​    主要协议：SDLC,HDLC,PPP,STP</p><p>物理层</p><p>​    主要任务是在物理媒体上实现比特流的透明传输。物理层传输单位是比特。</p><p>​    透明传输：指不管所传数据是怎什么样的比特组合，都应当能够在链路上传送。</p><p>​    功能一：定义接口特性</p><p>​    功能二：定义传输模式 单工  半双工 双工</p><p>​    功能三： 定义传输速率</p><p>​    功能四：比特同步</p><p>​    功能五：比特编码</p><p>​    主要协议：Rj45，802.3</p><h5 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h5><p>传输过程中上面4层是端对端协议传输，下面是点对点传输会经过中间系统 ，中间系统只有下三层，OSI参考模型的传输过程经历打包和拆包的过程，在应用层数据向下传输的过程中要加首部header，从表示层向下传输也要加header，数据链路层首尾都要加header，物理层不需要，因为物理层已经是010101，解包就是通过对应的协议解析header</p><h5 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h5><p>TCP/IP参考模型由应用层，传输层，网际层，网络接口层组成，应用层对应应用层，表示层，会话层，传输层就是对应传输层，网际层就是对应网络层，网络接口层对应的是数据链路层和物理层。</p><p>应用层对应的协议是HTTP,FTP,DNS</p><p>传输层对应的协议是TCP,UDP</p><p>网际层对应的协议是IP</p><p>网络接口层对应的协议是Ethernet，ATM，Frame Relay</p><h6 id="osi参考模型和tcp-ip参考模型"><a href="#osi参考模型和tcp-ip参考模型" class="headerlink" title="osi参考模型和tcp/ip参考模型"></a>osi参考模型和tcp/ip参考模型</h6><p>相同点：</p><p>​    都分层</p><p>​    基于独立的协议栈的概念</p><p>​    可以实现异构网络互联</p><p>不同点</p><p>面向连接分为三个阶段，第一个是建立连接，在此阶段，发出一个建立连接的请求。只有在连接建立成功之后才能进行数据传输，当数据传输完成就必须释放连接，面向无连接没有三个阶段，他直接进行传输</p><p>osi定义了三点：服务，协议，接口</p><p>osi先出现，参考模型先于协议发明，不偏向特定协议</p><p>tcp/ip设计之初考虑到了异构网互联问题，将IP作为重要层次</p><p>osi参考模型网络层是面向无连接和面向连接的，tcp/ip是面向无连接的</p><p>传输层osi是无连接的。tcp/ip是面向有连接和无连接的</p><h5 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h5><p>结合了osi和tcp/ip的优点</p><p>应用层 支持各种网络应用   FTP. SMTP. HTTP</p><p>表示层  进程和进程间的数据传输 TCP UDP</p><p>网络层 源主机到目的主机的数据分组路由与转发 IP ICMP OSPF等</p><p>数据链路层 将网络层传下来的数据报文组装成帧。 Ethernet ，PPP </p><p>物理层  进行比特传输</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react源码</title>
    <link href="/2022/11/02/react%E6%BA%90%E7%A0%81/"/>
    <url>/2022/11/02/react%E6%BA%90%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p><a href="https://7kms.github.io/react-illustration-series/">https://7kms.github.io/react-illustration-series/</a></p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>react源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scss笔记</title>
    <link href="/2022/10/30/scss%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/30/scss%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$font-stack</span>: Helvetica, sans-serif;<span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#333</span>;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> <span class="hljs-variable">$font-stack</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;&#125;</code></pre></div><p>scss的变量是以$开头的，css也有自己的变量，他和scss不同，scss变量会被scss编译，css变量会包含在输出文件中，css变量对不同的元素有不同的值，scss变量一次只有一个值，scss变量是命令式的，这意味着如果你使用一个变量然后改变它的值，之前使用的值不变，css是声明事的，如果中途改变了值，拿他之前和之后的值都会发生变化</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$variable</span>: value <span class="hljs-number">1</span>;<span class="hljs-selector-class">.rule-1</span> &#123;  value: <span class="hljs-variable">$variable</span>;&#125;<span class="hljs-variable">$variable</span>: value <span class="hljs-number">2</span>;<span class="hljs-selector-class">.rule-2</span> &#123;  value: <span class="hljs-variable">$variable</span>;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.rule-1</span> &#123;  value: value <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.rule-2</span> &#123;  value: value <span class="hljs-number">2</span>;&#125;</code></pre></div><p>Sass 变量与所有 Sass 标识符一样，将连字符和下划线视为相同。这意味着<code>$font-size</code>and<code>$font_size</code>都指的是同一个变量。这是 Sass 早期的历史遗留问题，当时<em>它只</em>允许在标识符名称中使用下划线。一旦 Sass 添加了对连字符的支持以匹配CSS的语法，这两者就等同于使迁移更容易。</p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>!default scss提供了这个符号来编写默认变量，特别是当你编写scss库的时候</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// _library.scss</span><span class="hljs-variable">$black</span>: <span class="hljs-number">#000</span> !default;<span class="hljs-variable">$border-radius</span>: <span class="hljs-number">0.25rem</span> !default;<span class="hljs-variable">$box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.5rem</span> <span class="hljs-number">1rem</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-variable">$black</span>, <span class="hljs-number">0.15</span>) !default;<span class="hljs-selector-tag">code</span> &#123;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$border-radius</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">$box-shadow</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// style.scss</span><span class="hljs-keyword">@use</span> <span class="hljs-string">&#x27;library&#x27;</span> with (  <span class="hljs-variable">$black</span>: <span class="hljs-number">#222</span>,会覆盖默认的变量值  <span class="hljs-variable">$border-radius</span>: <span class="hljs-number">0.1rem</span>);</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-tag">code</span> &#123;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0.1rem</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.5rem</span> <span class="hljs-number">1rem</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">34</span>, <span class="hljs-number">34</span>, <span class="hljs-number">34</span>, <span class="hljs-number">0.15</span>);&#125;</code></pre></div><p>不能修改由<a href="https://sass-lang.com/documentation/modules">内置模块</a>定义的变量</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;sass:math&quot;</span> as math;<span class="hljs-comment">// This assignment will fail.</span>math.<span class="hljs-variable">$pi</span>: <span class="hljs-number">0</span>;</code></pre></div><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>在样式表顶层声明的变量是<em>全局</em>的。这意味着在声明它们之后，可以在其模块中的任何地方访问它们。但并非所有变量都是如此。在块中声明的那些（ SCSS中的花括号或 Sass 中的缩进代码）通常是<em>local</em>，并且只能在它们声明的块中访问。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$global-variable</span>: global value;<span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-variable">$local-variable</span>: local value;  global: <span class="hljs-variable">$global-variable</span>;  local: <span class="hljs-variable">$local-variable</span>;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  global: <span class="hljs-variable">$global-variable</span>;  <span class="hljs-comment">// This would fail, because $local-variable isn&#x27;t in scope:</span>  <span class="hljs-comment">// local: $local-variable;</span>&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.content</span> &#123;  global: global value;  local: local value;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  global: global value;&#125;</code></pre></div><p>局部变量甚至可以声明为与全局变量同名。如果发生这种情况，实际上有两个不同的变量同名：一个是本地的，一个是全局的。这有助于确保编写局部变量的作者不会意外更改他们甚至不知道的全局变量的值。</p><div class="code-wrapper"><pre><code class="hljs css">$variable: global value;<span class="hljs-selector-class">.content</span> &#123;  $variable: local value;  value: $variable;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  value: $variable;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123;  value: second global value;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  value: second global value;&#125;</code></pre></div><p>如果您需要在本地范围内（例如在 mixin 中）设置全局变量的值，则可以使用该<code>!global</code>标志。标记为的变量声明<code>!global</code>将<em>始终</em>分配给全局范围。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$variable</span>: first global value;<span class="hljs-selector-class">.content</span> &#123;  <span class="hljs-variable">$variable</span>: second global value !global;  value: <span class="hljs-variable">$variable</span>;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  value: <span class="hljs-variable">$variable</span>;&#125;</code></pre></div><p>Css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123;  value: second global value;&#125;<span class="hljs-selector-class">.sidebar</span> &#123;  value: second global value;&#125;</code></pre></div><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$dark-theme</span>: true !default;<span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#f8bbd0</span> !default;<span class="hljs-variable">$accent-color</span>: <span class="hljs-number">#6a1b9a</span> !default;<span class="hljs-keyword">@if</span> <span class="hljs-variable">$dark-theme</span> &#123;  <span class="hljs-variable">$primary-color</span>: <span class="hljs-built_in">darken</span>(<span class="hljs-variable">$primary-color</span>, <span class="hljs-number">60%</span>);  <span class="hljs-variable">$accent-color</span>: <span class="hljs-built_in">lighten</span>(<span class="hljs-variable">$accent-color</span>, <span class="hljs-number">60%</span>);&#125;<span class="hljs-selector-class">.button</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$primary-color</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-variable">$accent-color</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.button</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#750c30</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#f5ebfc</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;&#125;</code></pre></div><h3 id="⚠️注意！"><a href="#⚠️注意！" class="headerlink" title="⚠️注意！"></a>⚠️注意！</h3><p>流控制范围内的变量可以修改外部范围内的现有变量，但它们不能在那里声明新变量。确保变量在分配之前已经声明，即使您需要将其声明为 <code>null</code>.</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-tag">nav</span> &#123;  <span class="hljs-selector-tag">ul</span> &#123;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">list-style</span>: none;  &#125;  <span class="hljs-selector-tag">li</span> &#123; <span class="hljs-attribute">display</span>: inline-block; &#125;  <span class="hljs-selector-tag">a</span> &#123;    <span class="hljs-attribute">display</span>: block;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">6px</span> <span class="hljs-number">12px</span>;    <span class="hljs-attribute">text-decoration</span>: none;  &#125;&#125;</code></pre></div><h3 id="scss片段"><a href="#scss片段" class="headerlink" title="scss片段"></a>scss片段</h3><p>你可以创建一个scss片段进行重复利用，例如编写一个以下环线开头的scss文件，而这个文件不会被编写成css文件，他可以在其他scss中被引用，使用@use进行引用这个文件</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// _base.scss</span><span class="hljs-variable">$font-stack</span>: Helvetica, sans-serif;<span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#333</span>;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> <span class="hljs-variable">$font-stack</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// styles.scss</span><span class="hljs-keyword">@use</span> <span class="hljs-string">&#x27;base&#x27;</span>;<span class="hljs-selector-class">.inverse</span> &#123;  <span class="hljs-attribute">background-color</span>: base.<span class="hljs-variable">$primary-color</span>;  <span class="hljs-attribute">color</span>: white;&#125;</code></pre></div><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> theme(<span class="hljs-variable">$theme</span>: DarkGray) &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-variable">$theme</span>;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-variable">$theme</span>, .<span class="hljs-number">25</span>);  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.info</span> &#123;  <span class="hljs-keyword">@include</span> theme;&#125;<span class="hljs-selector-class">.alert</span> &#123;  <span class="hljs-keyword">@include</span> theme(<span class="hljs-variable">$theme</span>: DarkRed);&#125;<span class="hljs-selector-class">.success</span> &#123;  <span class="hljs-keyword">@include</span> theme(<span class="hljs-variable">$theme</span>: DarkGreen);&#125;</code></pre></div><p>转化成</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.info</span> &#123;  <span class="hljs-attribute">background</span>: DarkGray;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">169</span>, <span class="hljs-number">169</span>, <span class="hljs-number">169</span>, <span class="hljs-number">0.25</span>);  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.alert</span> &#123;  <span class="hljs-attribute">background</span>: DarkRed;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">139</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>);  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;<span class="hljs-selector-class">.success</span> &#123;  <span class="hljs-attribute">background</span>: DarkGreen;  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.25</span>);  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;&#125;</code></pre></div><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">/* This CSS will print because %message-shared is extended. */</span>%message-shared &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-comment">// This CSS won&#x27;t print because %equal-heights is never extended.</span>%equal-heights &#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">flex-wrap</span>: wrap;&#125;<span class="hljs-selector-class">.message</span> &#123;  <span class="hljs-keyword">@extend</span> %message-shared;&#125;<span class="hljs-selector-class">.success</span> &#123;  <span class="hljs-keyword">@extend</span> %message-shared;  <span class="hljs-attribute">border-color</span>: green;&#125;<span class="hljs-selector-class">.error</span> &#123;  <span class="hljs-keyword">@extend</span> %message-shared;  <span class="hljs-attribute">border-color</span>: red;&#125;<span class="hljs-selector-class">.warning</span> &#123;  <span class="hljs-keyword">@extend</span> %message-shared;  <span class="hljs-attribute">border-color</span>: yellow;&#125;</code></pre></div><h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;sass:math&quot;</span>;<span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-tag">article</span><span class="hljs-selector-attr">[role=<span class="hljs-string">&quot;main&quot;</span>]</span> &#123;  <span class="hljs-attribute">width</span>: math.<span class="hljs-built_in">div</span>(<span class="hljs-number">600px</span>, <span class="hljs-number">960px</span>) * <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-tag">aside</span><span class="hljs-selector-attr">[role=<span class="hljs-string">&quot;complementary&quot;</span>]</span> &#123;  <span class="hljs-attribute">width</span>: math.<span class="hljs-built_in">div</span>(<span class="hljs-number">300px</span>, <span class="hljs-number">960px</span>) * <span class="hljs-number">100%</span>;  <span class="hljs-attribute">margin-left</span>: auto;&#125;</code></pre></div><h3 id="选择器列表"><a href="#选择器列表" class="headerlink" title="选择器列表"></a>选择器列表</h3><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.alert</span>, <span class="hljs-selector-class">.warning</span> &#123;  <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">0</span>;  &#125;&#125;</code></pre></div><p>转成css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.alert</span> <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-class">.alert</span> <span class="hljs-selector-tag">p</span>, <span class="hljs-selector-class">.warning</span> <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-class">.warning</span> <span class="hljs-selector-tag">p</span> &#123;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="选择器组合器"><a href="#选择器组合器" class="headerlink" title="选择器组合器"></a>选择器组合器</h3><p>您也可以嵌套使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators#Combinators">组合</a>器的选择器。您可以将组合器放在外部选择器的末尾，内部选择器的开头，或者甚至都放在两者之间。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-tag">ul</span> &gt; &#123;  <span class="hljs-selector-tag">li</span> &#123;    <span class="hljs-attribute">list-style-type</span>: none;  &#125;&#125;<span class="hljs-selector-tag">h2</span> &#123;  + <span class="hljs-selector-tag">p</span> &#123;    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid gray;  &#125;&#125;<span class="hljs-selector-tag">p</span> &#123;  ~ &#123;    <span class="hljs-selector-tag">span</span> &#123;      <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;    &#125;  &#125;&#125;</code></pre></div><p>等价于css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &gt; <span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">list-style-type</span>: none;&#125;<span class="hljs-selector-tag">h2</span> + <span class="hljs-selector-tag">p</span> &#123;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> solid gray;&#125;<span class="hljs-selector-tag">p</span> ~ <span class="hljs-selector-tag">span</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;&#125;</code></pre></div><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>您可以使用<a href="https://sass-lang.com/documentation/interpolation">插值</a>将 变量和函数调用等<a href="https://sass-lang.com/documentation/syntax/structure#expressions">表达式中的值注入选择器。</a>这在您编写<a href="https://sass-lang.com/documentation/at-rules/mixin">mixins</a>时特别有用，因为它允许您根据用户传入的参数创建选择器。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> define-emoji(<span class="hljs-variable">$name</span>, <span class="hljs-variable">$glyph</span>) &#123;  <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.emoji-</span>#&#123;<span class="hljs-variable">$name</span>&#125; &#123;    <span class="hljs-attribute">font-family</span>: IconFont;    <span class="hljs-attribute">font-variant</span>: normal;    <span class="hljs-attribute">font-weight</span>: normal;    <span class="hljs-attribute">content</span>: <span class="hljs-variable">$glyph</span>;  &#125;&#125;<span class="hljs-keyword">@include</span> define-emoji(<span class="hljs-string">&quot;women-holding-hands&quot;</span>, <span class="hljs-string">&quot;👭&quot;</span>);</code></pre></div><p>转成css</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@charset</span> <span class="hljs-string">&quot;UTF-8&quot;</span>;<span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.emoji-women-holding-hands</span> &#123;  <span class="hljs-attribute">font-family</span>: IconFont;  <span class="hljs-attribute">font-variant</span>: normal;  <span class="hljs-attribute">font-weight</span>: normal;  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;👭&quot;</span>;&#125;</code></pre></div><p>插值几乎可以在 Sass 样式表中的任何地方使用，以将<a href="https://sass-lang.com/documentation/syntax/structure#expressions">SassScript 表达式</a>的结果嵌入到 CSS 块中。只需在以下任何地方包装一个表达式<code>#&#123;&#125;</code>：</p><h4 id="在sassscript中使用"><a href="#在sassscript中使用" class="headerlink" title="在sassscript中使用"></a>在sassscript中使用</h4><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> inline-animation(<span class="hljs-variable">$duration</span>) &#123;  <span class="hljs-variable">$name</span>: inline-#&#123;<span class="hljs-built_in">unique-id</span>()&#125;;  <span class="hljs-keyword">@keyframes</span> #&#123;<span class="hljs-variable">$name</span>&#125; &#123;    <span class="hljs-keyword">@content</span>;  &#125;  <span class="hljs-attribute">animation-name</span>: <span class="hljs-variable">$name</span>;  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-variable">$duration</span>;  <span class="hljs-attribute">animation-iteration-count</span>: infinite;&#125;<span class="hljs-selector-class">.pulse</span> &#123;  <span class="hljs-keyword">@include</span> inline-animation(<span class="hljs-number">2s</span>) &#123;    from &#123; <span class="hljs-attribute">background-color</span>: yellow &#125;    to &#123; <span class="hljs-attribute">background-color</span>: red &#125;  &#125;&#125;</code></pre></div><p>转成css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.pulse</span> &#123;  <span class="hljs-attribute">animation-name</span>: inline-uoqjh6kaq;  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">2s</span>;  <span class="hljs-attribute">animation-iteration-count</span>: infinite;&#125;<span class="hljs-keyword">@keyframes</span> inline-uoqjh6kaq &#123;  <span class="hljs-selector-tag">from</span> &#123;    <span class="hljs-attribute">background-color</span>: yellow;  &#125;  <span class="hljs-selector-tag">to</span> &#123;    <span class="hljs-attribute">background-color</span>: red;  &#125;&#125;</code></pre></div><h4 id="引用字符串"><a href="#引用字符串" class="headerlink" title="引用字符串"></a>引用字符串</h4><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.example</span> &#123;  unquoted: #&#123;&quot;string&quot;&#125;;&#125;</code></pre></div><p>Css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.example</span> &#123;  unquoted: #&#123;&quot;string&quot;&#125;;&#125;</code></pre></div><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><p>在sass中和在css中一样，属性声明定义匹配元素选择器的样式，但是sass添加了额外的功能，例如样式的值可以是任何变量</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.circle</span> &#123;  <span class="hljs-variable">$size</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-variable">$size</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-variable">$size</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$size</span> * <span class="hljs-number">0.5</span>;&#125;</code></pre></div><p>转成css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.circle</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>;&#125;</code></pre></div><p>属性的名称可以包含<a href="https://sass-lang.com/documentation/interpolation">插值</a>，这使得可以根据需要动态生成属性。您甚至可以插入整个属性名称！</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> prefix(<span class="hljs-variable">$property</span>, <span class="hljs-variable">$value</span>, <span class="hljs-variable">$prefixes</span>) &#123;  <span class="hljs-keyword">@each</span> <span class="hljs-variable">$prefix</span> in <span class="hljs-variable">$prefixes</span> &#123;    -#&#123;<span class="hljs-variable">$prefix</span>&#125;-#&#123;<span class="hljs-variable">$property</span>&#125;: <span class="hljs-variable">$value</span>;  &#125;  #&#123;<span class="hljs-variable">$property</span>&#125;: <span class="hljs-variable">$value</span>;&#125;<span class="hljs-selector-class">.gray</span> &#123;  <span class="hljs-keyword">@include</span> prefix(filter, grayscale(<span class="hljs-number">50%</span>), moz webkit);&#125;</code></pre></div><p>转成</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.gray</span> &#123;  -moz-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">50%</span>);  -webkit-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">50%</span>);  <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">50%</span>);&#125;</code></pre></div><p>许多CSS属性都以作为一种命名空间的相同前缀开头。例如，<code>font-family</code>，<code>font-size</code>，并且<code>font-weight</code>都以 开头<code>font-</code>。Sass 通过允许嵌套属性声明使这变得更容易且更少冗余。外部属性名称被添加到内部，用连字符分隔。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.enlarge</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">transition</span>: &#123;    property: font-size;    duration: <span class="hljs-number">4s</span>;    delay: <span class="hljs-number">2s</span>;  &#125;  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>; &#125;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.enlarge</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">transition-property</span>: font-size;  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">4s</span>;  <span class="hljs-attribute">transition-delay</span>: <span class="hljs-number">2s</span>;&#125;<span class="hljs-selector-class">.enlarge</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36px</span>;&#125;</code></pre></div><p>其中一些CSS属性具有使用命名空间作为属性名称的简写版本。对于这些，您可以编写简写值<em>和</em> 更明确的嵌套版本</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.info-page</span> &#123;  <span class="hljs-attribute">margin</span>: auto &#123;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">10px</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">2px</span>;  &#125;&#125;</code></pre></div><p>Css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.info-page</span> &#123;  <span class="hljs-attribute">margin</span>: auto;  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">2px</span>;&#125;</code></pre></div><p>如果希望通过true/false来控制属性的隐藏和展示，如果一个声明的值是<a href="https://sass-lang.com/documentation/values/null"><code>null</code></a>或一个空的未加<a href="https://sass-lang.com/documentation/values/strings#unquoted">引号的字符串</a>，Sass 根本不会将该声明编译成CSS。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$rounded-corners</span>: false;<span class="hljs-selector-class">.button</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-built_in">if</span>(<span class="hljs-variable">$rounded-corners</span>, <span class="hljs-number">5px</span>, null);&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;&#125;</code></pre></div><p>定义css变量</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-variable">$primary</span>: <span class="hljs-number">#81899b</span>;<span class="hljs-variable">$accent</span>: <span class="hljs-number">#302e24</span>;<span class="hljs-variable">$warn</span>: <span class="hljs-number">#dfa612</span>;<span class="hljs-selector-pseudo">:root</span> &#123;  <span class="hljs-attr">--primary</span>: #&#123;<span class="hljs-variable">$primary</span>&#125;;  <span class="hljs-attr">--accent</span>: #&#123;<span class="hljs-variable">$accent</span>&#125;;  <span class="hljs-attr">--warn</span>: #&#123;<span class="hljs-variable">$warn</span>&#125;;  <span class="hljs-comment">// Even though this looks like a Sass variable, it&#x27;s valid CSS so it&#x27;s not</span>  <span class="hljs-comment">// evaluated.</span>  <span class="hljs-attr">--consumed-by-js</span>: <span class="hljs-variable">$primary</span>;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;  <span class="hljs-attr">--primary</span>: <span class="hljs-number">#81899b</span>;  <span class="hljs-attr">--accent</span>: <span class="hljs-number">#302e24</span>;  <span class="hljs-attr">--warn</span>: <span class="hljs-number">#dfa612</span>;  <span class="hljs-attr">--consumed-by-js</span>: $primary;&#125;</code></pre></div><h3 id="父选择器"><a href="#父选择器" class="headerlink" title="父选择器"></a>父选择器</h3><p>父选择器<code>&amp;</code>是 Sass 发明的一种特殊选择器，在<a href="https://sass-lang.com/documentation/style-rules#nesting">嵌套选择器</a>中用于引用外部选择器。它可以以更复杂的方式重用外部选择器，例如添加<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">伪类</a>或在父级<em>之前添加选择器。</em></p><p>当在内部选择器中使用父选择器时，它会被相应的外部选择器替换。发生这种情况而不是正常的嵌套行为</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.alert</span> &#123;  <span class="hljs-comment">// The parent selector can be used to add pseudo-classes to the outer</span>  <span class="hljs-comment">// selector.</span>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;    <span class="hljs-attribute">font-weight</span>: bold;  &#125;  <span class="hljs-comment">// It can also be used to style the outer selector in a certain context, such</span>  <span class="hljs-comment">// as a body set to use a right-to-left language.</span>  <span class="hljs-selector-attr">[dir=rtl]</span> &amp; &#123;    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;  &#125;  <span class="hljs-comment">// You can even use it as an argument to pseudo-class selectors.</span>  <span class="hljs-selector-pseudo">:not</span>(&amp;) &#123;    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;  &#125;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.alert</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">font-weight</span>: bold;&#125;<span class="hljs-selector-attr">[dir=rtl]</span> <span class="hljs-selector-class">.alert</span> &#123;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;&#125;<span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.alert</span>) &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.8</span>;&#125;</code></pre></div><p>您还可以使用父选择器向外部选择器添加额外的后缀。<a href="http://getbem.com/">这在使用像BEM</a> 这样使用高度结构化类名的方法时特别有用。只要外部选择器以字母数字名称结尾（如类、ID和元素选择器），您就可以使用父选择器附加附加文本。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.accordion</span> &#123;  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">4rem</span> auto;  <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Raleway&quot;</span>, sans-serif;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f4f4f4</span>;  &amp;__copy &#123;    <span class="hljs-attribute">display</span>: none;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span> <span class="hljs-number">1.5rem</span> <span class="hljs-number">2rem</span> <span class="hljs-number">1.5rem</span>;    <span class="hljs-attribute">color</span>: gray;    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">500</span>;    &amp;<span class="hljs-attr">--open</span> &#123;      <span class="hljs-attribute">display</span>: block;    &#125;  &#125;&#125;</code></pre></div><p>Css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.accordion</span> &#123;  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">4rem</span> auto;  <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Raleway&quot;</span>, sans-serif;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f4f4f4</span>;&#125;<span class="hljs-selector-class">.accordion__copy</span> &#123;  <span class="hljs-attribute">display</span>: none;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">1rem</span> <span class="hljs-number">1.5rem</span> <span class="hljs-number">2rem</span> <span class="hljs-number">1.5rem</span>;  <span class="hljs-attribute">color</span>: gray;  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">500</span>;&#125;<span class="hljs-selector-class">.accordion__copy--open</span> &#123;  <span class="hljs-attribute">display</span>: block;&#125;</code></pre></div><h3 id="占位符选择器"><a href="#占位符选择器" class="headerlink" title="占位符选择器"></a>占位符选择器</h3><p>占位符选择器是以%开头的选择器，他不会包含在输出css文件中，</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-selector-class">.alert</span><span class="hljs-selector-pseudo">:hover</span>, %<span class="hljs-selector-tag">strong</span>-alert &#123;  <span class="hljs-attribute">font-weight</span>: bold;&#125;%<span class="hljs-selector-tag">strong</span>-alert<span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">color</span>: red;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.alert</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">font-weight</span>: bold;&#125;</code></pre></div><p>占位符的使用</p><div class="code-wrapper"><pre><code class="hljs scss">%toolbelt &#123;  <span class="hljs-attribute">box-sizing</span>: border-box;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">#000</span>, .<span class="hljs-number">12</span>) solid;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span> <span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">#000</span>, .<span class="hljs-number">5</span>) solid; &#125;&#125;<span class="hljs-selector-class">.action-buttons</span> &#123;  <span class="hljs-keyword">@extend</span> %toolbelt;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#4285f4</span>;&#125;<span class="hljs-selector-class">.reset-buttons</span> &#123;  <span class="hljs-keyword">@extend</span> %toolbelt;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#cddc39</span>;&#125;</code></pre></div><p>css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.action-buttons</span>, <span class="hljs-selector-class">.reset-buttons</span> &#123;  <span class="hljs-attribute">box-sizing</span>: border-box;  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">1px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.12</span>) solid;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span> <span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-class">.action-buttons</span><span class="hljs-selector-pseudo">:hover</span>, <span class="hljs-selector-class">.reset-buttons</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>) solid;&#125;<span class="hljs-selector-class">.action-buttons</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#4285f4</span>;&#125;<span class="hljs-selector-class">.reset-buttons</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#cddc39</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
      <category>scss</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在webpack中配置typescript</title>
    <link href="/2022/10/24/%E5%9C%A8webpack%E4%B8%AD%E9%85%8D%E7%BD%AEtypescript/"/>
    <url>/2022/10/24/%E5%9C%A8webpack%E4%B8%AD%E9%85%8D%E7%BD%AEtypescript/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>typescript类型体操</title>
    <link href="/2022/10/23/typescript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"/>
    <url>/2022/10/23/typescript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="内置工具和类型体操"><a href="#内置工具和类型体操" class="headerlink" title="内置工具和类型体操"></a><strong>内置工具和类型体操</strong></h1><p><strong>类型系统其实在很多语言里面都是有的，比如Java、Swift、C++等等，但是相对来说TypeScript的类型非常灵活：</strong></p><p>这是因为TypeScript的目的是为JavaScript添加一套类型校验系统，因为JavaScript本身的灵活性，也让TypeScript类型系统</p><p>不得不增加更附加的功能以适配JavaScript的灵活性；</p><p>所以TypeScript是一种可以支持类型编程的类型系统； </p><p><strong>这种类型编程系统为TypeScript增加了很大的灵活度，同时也增加了它的难度：</strong></p><p>如果你不仅仅在开发业务的时候为自己的JavaScript代码增加上类型约束，那么基本不需要太多的类型编程能力；</p><p>但是如果你在开发一些框架、库，或者通用性的工具，为了考虑各种适配的情况，就需要使用类型编程； </p><p><strong>TypeScript本身为我们提供了类型工具，帮助我们辅助进行类型转换（前面有用过关于this的类型工具）。</strong></p><p><strong>很多开发者为了进一步增强自己的TypeScript编程能力，还会专门去做一些类型体操的题目：</strong></p><p><a href="https://github.com/type-challenges/type-challenges">https://github.com/type-challenges/type-challenges</a></p><p><a href="https://ghaiklor.github.io/type-challenges-solutions/en/">https://ghaiklor.github.io/type-challenges-solutions/en/</a></p><h3 id="条件类型（Conditional-Types）"><a href="#条件类型（Conditional-Types）" class="headerlink" title="条件类型（Conditional Types）"></a><strong>条件类型（Conditional Types）</strong></h3><p>很多时候，日常开发中我们需要基于输入的值来决定输出的值，同样我们也需要基于输入的值的类型来决定输出的值的类型</p><p><strong>条件类型（</strong>Conditional types）就是用来帮助我们描述输入类型和输出类型之间的关系。</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-title function_">live</span>(): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-title function_">woof</span>(): <span class="hljs-built_in">void</span>;&#125; <span class="hljs-keyword">type</span> <span class="hljs-title class_">Example1</span> = <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>; <span class="hljs-keyword">type</span> <span class="hljs-title class_">Example2</span> = <span class="hljs-title class_">RegExp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> ? <span class="hljs-built_in">number</span> : <span class="hljs-built_in">string</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-comment">// 举个栗子: 函数的重载</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1: <span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1: <span class="hljs-built_in">string</span>, num2: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><span class="hljs-comment">// 错误的做法: 类型扩大化</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span><span class="hljs-comment">//正确的写法</span><span class="hljs-keyword">function</span> sum&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;(<span class="hljs-attr">num1</span>: T, <span class="hljs-attr">num2</span>: T): T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>? <span class="hljs-attr">number</span>:<span class="hljs-built_in">string</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-keyword">return</span> num1 + num2&#125;</code></pre></div><p>条件类型看起来有点像 JavaScript 中的条件表达式（<code>条件 ? true 表达式 : false 表达式</code>）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">SomeType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OtherType</span> ? <span class="hljs-title class_">TrueType</span> : <span class="hljs-title class_">FalseType</span>;</code></pre></div><h4 id="条件类型约束"><a href="#条件类型约束" class="headerlink" title="条件类型约束"></a>条件类型约束</h4><p>通常，条件类型的检查将为我们提供一些新信息。 就像使用类型守卫缩小范围可以给我们提供更具体的类型一样，条件类型的 true 分支将根据我们检查的类型进一步约束泛型。</p><p>让我们来看看下面的例子：</p><div class="code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">type</span> MessageOf&lt;<span class="hljs-built_in">T</span>&gt; = <span class="hljs-built_in">T</span>[<span class="hljs-string">&quot;message&quot;</span>];<span class="hljs-built_in">Type</span> &#x27;<span class="hljs-string">&quot;message&quot;</span>&#x27; cannot be used to <span class="hljs-built_in">index</span> <span class="hljs-built_in">type</span> &#x27;<span class="hljs-built_in">T</span>&#x27;.<span class="hljs-built_in">Type</span> &#x27;<span class="hljs-string">&quot;message&quot;</span>&#x27; cannot be used to <span class="hljs-built_in">index</span> <span class="hljs-built_in">type</span> &#x27;<span class="hljs-built_in">T</span>&#x27;.</code></pre></div><p>在本例中，TypeScript 产生错误是因为不知道 <code>T</code> 有一个名为 <code>message</code> 的属性。 我们可以约束 <code>T</code>，TypeScript 也不会再抱怨了：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MessageOf</span>&lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-built_in">unknown</span> &#125;&gt; = T[<span class="hljs-string">&quot;message&quot;</span>]; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Email</span> &#123;  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;&#125; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> &#123;  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;&#125; <span class="hljs-keyword">type</span> <span class="hljs-title class_">EmailMessageContents</span> = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Email</span>&gt;;</code></pre></div><p>然而，如果我们希望 <code>MessageOf</code> 接受任何类型，并且在 <code>message</code> 属性不可用的情况下默认为 <code>never</code> 之类的类型，我们应该怎么做呢？ 我们可以通过移出约束并引入条件类型来实现这一点：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MessageOf</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-built_in">unknown</span> &#125; ? T[<span class="hljs-string">&quot;message&quot;</span>] : <span class="hljs-built_in">never</span>; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Email</span> &#123;  <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>;&#125; <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Dog</span> &#123;  <span class="hljs-title function_">bark</span>(): <span class="hljs-built_in">void</span>;&#125; <span class="hljs-keyword">type</span> <span class="hljs-title class_">EmailMessageContents</span> = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Email</span>&gt;; <span class="hljs-keyword">type</span> <span class="hljs-title class_">DogMessageContents</span> = <span class="hljs-title class_">MessageOf</span>&lt;<span class="hljs-title class_">Dog</span>&gt;;</code></pre></div><p>在 true 分支中，TypeScript 知道 <code>T</code> <em>将</em> 有一个 <code>message</code> 属性。</p><p>作为另一个示例，我们还可以编写一个名为 <code>Flatten</code> 的类型，它将数组类型扁平为它们的元素类型，但在其他情况下不会处理它们：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Flatten</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>[] ? T[<span class="hljs-built_in">number</span>] : T; <span class="hljs-comment">// Extracts out the element type.</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Str</span> = <span class="hljs-title class_">Flatten</span>&lt;<span class="hljs-built_in">string</span>[]&gt;;<span class="hljs-comment">//type Str = string</span> <span class="hljs-comment">// Leaves the type alone.</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Num</span> = <span class="hljs-title class_">Flatten</span>&lt;<span class="hljs-built_in">number</span>&gt;;<span class="hljs-comment">//number</span></code></pre></div><h4 id="在条件类型中推断（infer）"><a href="#在条件类型中推断（infer）" class="headerlink" title="在条件类型中推断（infer）"></a><strong>在条件类型中推断（infer）</strong></h4><p>我们发现自己使用条件类型来应用约束，然后提取出类型。 这最终成为一种非常常见的操作，条件类型使其变得更容易。</p><p>条件类型为我们提供了一种使用 <code>infer</code> 关键字从 true 分支中与之进行比较的类型中进行推断的方法。 例如，我们可以在 <code>Flatten</code> 中推断元素类型，而不是使用索引访问类型“手动”提取它：</p><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">Flatten&lt;<span class="hljs-keyword">Type</span>&gt; </span>= <span class="hljs-keyword">Type</span> <span class="hljs-type">extends </span><span class="hljs-keyword">Array</span>&lt;infer Item&gt; ? Item : <span class="hljs-type">Type</span>;</code></pre></div><p>在这里，我们使用 <code>infer</code> 关键字以声明方式引入一个名为 <code>Item</code> 的新泛型类型变量，而不是指定如何在 true 分支中检索元素类型 <code>T</code>。 这使我们不必考虑如何挖掘和探索我们感兴趣的类型的结构。</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">CalcFnType</span> = <span class="hljs-function">(<span class="hljs-params">num1: <span class="hljs-built_in">number</span>, num2: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;abc&quot;</span>&#125;<span class="hljs-comment">// 总结类型体操题目: MyReturnType：推断返回值  传入的值必须是函数 </span><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyReturnType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R? <span class="hljs-attr">R</span>: <span class="hljs-built_in">never</span><span class="hljs-comment">//推断参数类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyParameterType</span>&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: infer A) =&gt; <span class="hljs-built_in">any</span>? <span class="hljs-attr">A</span>: <span class="hljs-built_in">never</span><span class="hljs-comment">// 获取一个函数的返回值类型: 内置工具 returntypeß</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">CalcReturnType</span> = <span class="hljs-title class_">MyReturnType</span>&lt;<span class="hljs-title class_">CalcFnType</span>&gt;<span class="hljs-keyword">type</span> <span class="hljs-title class_">FooReturnType</span> = <span class="hljs-title class_">MyReturnType</span>&lt;<span class="hljs-keyword">typeof</span> foo&gt;<span class="hljs-comment">// type FooReturnType2 = MyReturnType&lt;boolean&gt;</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">CalcParameterType</span> = <span class="hljs-title class_">MyParameterType</span>&lt;<span class="hljs-title class_">CalcFnType</span>&gt;<span class="hljs-keyword">export</span> &#123;&#125;</code></pre></div><p>我们可以使用 <code>infer</code> 关键字编写一些有用的助手类型别名。 例如，对于简单的情况，我们可以从函数类型中提取返回类型：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-title class_">Type</span>&gt; = <span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">never</span>[]) =&gt; infer <span class="hljs-title class_">Return</span>  ? <span class="hljs-title class_">Return</span>  : <span class="hljs-built_in">never</span>; <span class="hljs-keyword">type</span> <span class="hljs-title class_">Num</span> = <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">number</span>&gt;;<span class="hljs-comment">//type Num = number</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Str</span> = <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>&gt;;<span class="hljs-comment">//type Str = string</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Bools</span> = <span class="hljs-title class_">GetReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">boolean</span>, b: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>[]&gt;;<span class="hljs-comment">//type Bools = boolean[]</span></code></pre></div><h4 id="分发条件类型（Distributive-Conditional-Types）"><a href="#分发条件类型（Distributive-Conditional-Types）" class="headerlink" title="分发条件类型（Distributive Conditional Types）"></a><strong>分发条件类型（Distributive Conditional Types）</strong></h4><p><strong>当在泛型中使用条件类型的时候，如果传入一个联合类型，就会变成</strong> <strong>分发的（</strong>distributive****）</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> toArray&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span>? T[]: <span class="hljs-built_in">never</span><span class="hljs-comment">// number[]|string[]</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumArray</span> = toArray&lt;<span class="hljs-built_in">number</span>&gt;<span class="hljs-comment">// number[]|string[] 而不是 (number|string)[]</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">NumAndStrArray</span> = toArray&lt;<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span>&gt;</code></pre></div><p>通常，分布性是所需的行为。 要避免这种行为，可以用方括号括起 <code>extends</code> 关键字的两边。</p><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">ToArrayNonDist&lt;<span class="hljs-keyword">Type</span>&gt; </span>= [<span class="hljs-keyword">Type</span>] extends [any] ? <span class="hljs-keyword">Type</span>[] : <span class="hljs-type">never</span>; // <span class="hljs-symbol">&#x27;StrOrNumArr</span>&#x27; 不再是一个联合类型<span class="hljs-keyword">type</span> <span class="hljs-type">StrOrNumArr </span>= ToArrayNonDist&lt;string | number&gt;;//<span class="hljs-keyword">type</span> <span class="hljs-type">StrOrNumArr </span>= (string | number)[]</code></pre></div><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<Type></h3><p><strong>用于构造一个Type下面的所有属性都设置为可选的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYPartial</span>&lt;T&gt; = &#123;  [P <span class="hljs-keyword">in</span> keyof T]?: T[P] &#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKunOptional</span> = <span class="hljs-title class_">HYPartial</span>&lt;<span class="hljs-title class_">IKun</span>&gt;</code></pre></div><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a><strong>Required<Type></strong></h3><p>用于构造一个Type下面的所有属性全都设置为必填的类型，这个工具类型跟 Partial 相反。</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYRequired</span>&lt;T&gt; = &#123;  [P <span class="hljs-keyword">in</span> keyof T]-?: T[P] &#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun2</span> = <span class="hljs-title class_">Required</span>&lt;<span class="hljs-title class_">IKun</span>&gt;</code></pre></div><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a><strong>Readonly<Type></strong></h3><p><strong>用于构造一个Type下面的所有属性全都设置为只读的类型，意味着这个类型的所有的属性全都不可以重新赋值</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYReadonly</span>&lt;T&gt; = &#123;  <span class="hljs-keyword">readonly</span> [P <span class="hljs-keyword">in</span> keyof T]: T[P] &#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun2</span> = <span class="hljs-title class_">HYReadonly</span>&lt;<span class="hljs-title class_">IKun</span>&gt;</code></pre></div><h3 id="Record-lt-Keys-Type-gt"><a href="#Record-lt-Keys-Type-gt" class="headerlink" title="Record&lt;Keys, Type&gt;"></a><strong>Record&lt;Keys, Type&gt;</strong></h3><p><strong>用于构造一个对象类型，它所有的key(键)都是Keys类型，它所有的value(值)都是Type类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;  slogan?: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-comment">// name | age | slogan</span><span class="hljs-keyword">type</span> keys = keyof <span class="hljs-title class_">IKun</span>; <span class="hljs-comment">//keyof 会变成联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Res</span> = keyof <span class="hljs-built_in">any</span>; <span class="hljs-comment">// =&gt; number|string|symbol type Res = string | number | symbol</span><span class="hljs-comment">// 确实keys一定是可以作为key的联合类型 keyof any=&gt;string | number | symbol 一定可以作为对象的key</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYRecord</span>&lt;<span class="hljs-title class_">Keys</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>, T&gt; = &#123;  [P <span class="hljs-keyword">in</span> <span class="hljs-title class_">Keys</span>]: T;&#125;;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> t1 = <span class="hljs-string">&quot;上海&quot;</span> | <span class="hljs-string">&quot;北京&quot;</span> | <span class="hljs-string">&quot;洛杉矶&quot;</span>;<span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYRecord</span>&lt;t1, <span class="hljs-title class_">IKun</span>&gt;;<span class="hljs-keyword">const</span> <span class="hljs-attr">ikuns</span>: <span class="hljs-title class_">IKuns</span> = &#123;  上海: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xxx&quot;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,  &#125;,  北京: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;yyy&quot;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>,  &#125;,  洛杉矶: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zzz&quot;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,  &#125;,&#125;;</code></pre></div><h3 id="Pick-lt-Type-Keys-gt"><a href="#Pick-lt-Type-Keys-gt" class="headerlink" title="Pick&lt;Type, Keys&gt;"></a><strong>Pick&lt;Type, Keys&gt;</strong></h3><p>用于构造一个类型，它是从Type类型里面挑了一些属性Keys</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYPick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;  [P <span class="hljs-keyword">in</span> K]: T[P]&#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYPick</span>&lt;<span class="hljs-title class_">IKun</span>, <span class="hljs-string">&quot;slogan&quot;</span>|<span class="hljs-string">&quot;name&quot;</span>&gt;</code></pre></div><h3 id="Omit-lt-Type-Keys-gt"><a href="#Omit-lt-Type-Keys-gt" class="headerlink" title="Omit&lt;Type, Keys&gt;"></a><strong>Omit&lt;Type, Keys&gt;</strong></h3><p><strong>用于构造一个类型，它是从Type类型里面过滤了一些属性Keys</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  slogan?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYOmit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;  [P <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> P <span class="hljs-keyword">extends</span> K ? <span class="hljs-attr">never</span>: P]: T[P]&#125;<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYOmit</span>&lt;<span class="hljs-title class_">IKun</span>, <span class="hljs-string">&quot;slogan&quot;</span>|<span class="hljs-string">&quot;name&quot;</span>&gt;<span class="hljs-keyword">export</span> &#123;&#125;</code></pre></div><h3 id="Exclude-lt-UnionType-ExcludedMembers-gt"><a href="#Exclude-lt-UnionType-ExcludedMembers-gt" class="headerlink" title="Exclude&lt;UnionType, ExcludedMembers&gt;"></a><strong>Exclude&lt;UnionType, ExcludedMembers&gt;</strong></h3><p>从联合类型中排除一些类型</p><div class="code-wrapper"><pre><code class="hljs fsharp"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sing&quot;</span> <span class="hljs-operator">|</span> <span class="hljs-string">&quot;dance&quot;</span> <span class="hljs-operator">|</span> <span class="hljs-string">&quot;rap&quot;</span><span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYExclude</span><span class="hljs-operator">&lt;</span>T, E<span class="hljs-operator">&gt;</span> <span class="hljs-operator">=</span> T extends E<span class="hljs-operator">?</span> never<span class="hljs-operator">:</span> T<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> <span class="hljs-operator">=</span> HYExclude<span class="hljs-operator">&lt;</span>IKun, <span class="hljs-string">&quot;rap&quot;</span><span class="hljs-operator">&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>&gt;;<span class="hljs-comment">//type T0 = &quot;b&quot; | &quot;c&quot;</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span>&gt;;<span class="hljs-comment">//type T1 = &quot;c&quot;</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-title class_">Function</span>&gt;;<span class="hljs-comment">//type T2 = string | number</span></code></pre></div><h3 id="Extract-lt-Type-Union-gt"><a href="#Extract-lt-Type-Union-gt" class="headerlink" title="Extract&lt;Type, Union&gt;"></a><strong>Extract&lt;Type, Union&gt;</strong></h3><p><strong>用于构造一个类型，它是从Type类型里面提取了所有可以赋给Union的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;f&quot;</span>&gt;;<span class="hljs-comment">//type T0 = &quot;a&quot;</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">Extract</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-title class_">Function</span>&gt;;<span class="hljs-comment">//type T1 = () =&gt; void</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun</span> = <span class="hljs-string">&quot;sing&quot;</span> | <span class="hljs-string">&quot;dance&quot;</span> | <span class="hljs-string">&quot;rap&quot;</span><span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYExtract</span>&lt;T, E&gt; = T <span class="hljs-keyword">extends</span> E? <span class="hljs-attr">T</span>: <span class="hljs-built_in">never</span><span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYExtract</span>&lt;<span class="hljs-title class_">IKun</span>, <span class="hljs-string">&quot;rap&quot;</span>|<span class="hljs-string">&quot;dance&quot;</span>&gt;</code></pre></div><h3 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a><strong>NonNullable<Type></strong></h3><p><strong>用于构造一个类型，这个类型从Type中排除了所有的null、undefined的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKun</span> = <span class="hljs-string">&quot;sing&quot;</span> | <span class="hljs-string">&quot;dance&quot;</span> | <span class="hljs-string">&quot;rap&quot;</span> | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span><span class="hljs-comment">// 确实keys一定是可以作为key的联合类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYNonNullable</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">null</span>|<span class="hljs-literal">undefined</span> ? <span class="hljs-attr">never</span>: T<span class="hljs-comment">// IKun都变成可选的</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IKuns</span> = <span class="hljs-title class_">HYNonNullable</span>&lt;<span class="hljs-title class_">IKun</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt;;<span class="hljs-comment">//type T0 = string | number</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">NonNullable</span>&lt;<span class="hljs-built_in">string</span>[] | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>&gt;;<span class="hljs-comment">//type T1 = string[]</span></code></pre></div><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a><strong>ReturnType<Type></strong></h3><p><strong>用于构造一个含有Type函数的返回值的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>): &#123; <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> &#125;; <span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T0</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt;;     <span class="hljs-comment">//type T0 = string</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt;;     <span class="hljs-comment">//type T1 = void</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = <span class="hljs-title class_">ReturnType</span>&lt;&lt;T&gt;<span class="hljs-function">() =&gt;</span> T&gt;;     <span class="hljs-comment">//type T2 = unknown</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T3</span> = <span class="hljs-title class_">ReturnType</span>&lt;&lt;T <span class="hljs-keyword">extends</span> U, U <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>[]&gt;<span class="hljs-function">() =&gt;</span> T&gt;;     <span class="hljs-comment">//type T3 = number[]</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> f1&gt;;     <span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T4</span> = &#123;    <span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>;    <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T5</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">any</span>&gt;;     <span class="hljs-comment">//type T5 = any</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T6</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">never</span>&gt;;     <span class="hljs-comment">//type T6 = never</span><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T7</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-built_in">string</span>&gt;;<span class="hljs-comment">//Type &#x27;string&#x27; does not satisfy the constraint &#x27;(...args: any) =&gt; any&#x27;.</span></code></pre></div><h3 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a><strong>InstanceType<Type></strong></h3><p><strong>用于构造一个由所有Type的构造函数的实例类型组成的类型</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;&#125;<span class="hljs-comment">// 类型体操</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYInstanceType</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (  ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; infer R  ? R  : <span class="hljs-built_in">never</span>;<span class="hljs-keyword">const</span> <span class="hljs-attr">p1</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">// typeof Person: 构造函数具体的类型</span><span class="hljs-comment">// InstanceType构造函数创建出来的实例对象的类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">HYPerson</span> = <span class="hljs-title class_">HYInstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>&gt;;<span class="hljs-keyword">const</span> <span class="hljs-attr">p2</span>: <span class="hljs-title class_">HYPerson</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">// 构造函数的例子</span><span class="hljs-comment">// 通过的创建实例的工具函数时会用到这个InstanceType T必须是一个构造函数</span><span class="hljs-keyword">function</span> factory&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">new</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt;(  <span class="hljs-attr">ctor</span>: T): <span class="hljs-title class_">HYInstanceType</span>&lt;T&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">ctor</span>();&#125;<span class="hljs-keyword">const</span> p3 = <span class="hljs-title function_">factory</span>(<span class="hljs-title class_">Person</span>);<span class="hljs-keyword">const</span> d = <span class="hljs-title function_">factory</span>(<span class="hljs-title class_">Dog</span>);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>类型体操</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tsconfig.js文件解读</title>
    <link href="/2022/10/23/tsconfig-js%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/"/>
    <url>/2022/10/23/tsconfig-js%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>tsconfig</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tsconfig</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS常见的布局方式</title>
    <link href="/2022/10/22/CSS%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/10/22/CSS%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="css常见的几种布局方式"><a href="#css常见的几种布局方式" class="headerlink" title="css常见的几种布局方式"></a>css常见的几种布局方式</h1><h2 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h2><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.wrapper</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">max-width</span>: <span class="hljs-number">960px</span>;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>      内容内容 内容内容 内容内容 内容内容 内容内容 内容内容 内容内容    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>单列布局是指在页面中居中布局，margin：auto 0，可以让块级元素居中显示，max-width被设置，在页面中当页面宽度大于960px时，会以max-width进行布局，当页面小于max-width时就会缩小宽度</p><h2 id="两列自适应布局"><a href="#两列自适应布局" class="headerlink" title="两列自适应布局"></a>两列自适应布局</h2><h3 id="两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式"><a href="#两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式" class="headerlink" title="两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式"></a><strong>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式</strong></h3><h4 id="float-overflow-hidden"><a href="#float-overflow-hidden" class="headerlink" title="float+overflow:hidden"></a>float+overflow:hidden</h4><p>如果是普通的两列布局，<strong>浮动+普通元素的margin</strong>便可以实现，但如果是自适应的两列布局，利用<strong>float+overflow:hidden</strong>便可以实现，这种办法主要通过overflow触发BFC,而BFC不会重叠浮动元素。由于设置overflow:hidden并不会触发IE6-浏览器的haslayout属性，所以需要设置zoom:1来兼容IE6-浏览器。具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.parent</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">        zoom: <span class="hljs-number">1</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: brown;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">        zoom: <span class="hljs-number">1</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><strong>注意点:如果侧边栏在右边时，注意渲染顺序。即在HTML中，先写侧边栏后写主内容</strong></p><h4 id="使用flex布局"><a href="#使用flex布局" class="headerlink" title="使用flex布局"></a>使用flex布局</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.parent</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: brown;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="使用grid布局"><a href="#使用grid布局" class="headerlink" title="使用grid布局"></a>使用grid布局</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.parent</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: grid;</span><span class="language-css">        <span class="hljs-attribute">grid-template-columns</span>: auto <span class="hljs-number">1</span>fr;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: green;</span><span class="language-css">        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">10px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: brown;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>三栏布局就是中间宽度可以自由缩放，两边宽度是固定的</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是dom结构必须是先写中间列部分，这样实现中间列可以优先加载</strong>。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        <span class="hljs-attribute">left</span>: -<span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: blue;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        <span class="hljs-attribute">right</span>: -<span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>圣杯布局<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>圣杯布局父元素需要设置中间的div的padding，使用float进行布局，当中间元素占据width：100%时，左右两边的div会被挤下去，所以需要使用margin，和position进行定位</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>三个部分都设定为左浮动，<strong>否则左右两边内容上不去，就不可能与中间列同一行</strong>。然后设置center的宽度为100%(<strong>实现中间列内容自适应</strong>)，此时，left和right部分会跳到下一行</li></ul><p><img src="https://pic1.zhimg.com/v2-4f1da13dbb42ee61e7986fe27bca776c_r.jpg" alt="img"></p><ul><li>通过设置margin-left为负值让left和right部分回到与center部分同一行</li></ul><p><img src="https://pic4.zhimg.com/80/v2-6d1a7a6762acbe5ab9c315d01554031b_1440w.webp" alt="img"></p><ul><li>通过设置父容器的padding-left和padding-right，让左右两边留出间隙。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-c7a36f977b49d4fa46f0f5a9782c2be6_1440w.webp" alt="img"></p><ul><li>通过设置相对定位，让left和right部分移动到两边。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-b7e5a97b8d57e023ee457dc13f0206d2_1440w.webp" alt="img"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行</li><li>如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决，下文会介绍)</li></ul><p><img src="https://pic3.zhimg.com/80/v2-8bb2a97acd1f52376d69638faf64c4a2_1440w.webp" alt="img"></p><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p><strong>同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题</strong>。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">min-width</span>: <span class="hljs-number">600px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span> <span class="hljs-selector-class">.inner</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>; //新增部分</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: blue;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span>双飞翼布局<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="实现步骤-前两步与圣杯布局一样"><a href="#实现步骤-前两步与圣杯布局一样" class="headerlink" title="实现步骤(前两步与圣杯布局一样)"></a>实现步骤(前两步与圣杯布局一样)</h4><ul><li>三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；</li><li>通过设置margin-left为负值让left和right部分回到与center部分同一行；</li><li>center部分增加一个内层div，并设margin: 0 200px；</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p><strong>多加一层 dom 树节点，增加渲染树生成的计算量</strong>。</p><h4 id="两种布局实现方式对比"><a href="#两种布局实现方式对比" class="headerlink" title="两种布局实现方式对比:"></a>两种布局实现方式对比:</h4><ul><li>两种布局方式都是把主列放在文档流最前面，使主列优先加载。</li><li>两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。</li><li>两种布局方式的不同之处在于如何处理中间主列的位置： <strong>圣杯布局是利用父容器的左、右内边距+两个从列相对定位</strong>； <strong>双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整</strong></li></ul><h2 id="等高布局"><a href="#等高布局" class="headerlink" title="等高布局"></a>等高布局</h2><p>等高布局是指子元素在父元素中高度相等的布局方式。接下来我们介绍常见几种实现方式：</p><h3 id="利用正padding-负margin"><a href="#利用正padding-负margin" class="headerlink" title="利用正padding+负margin"></a>利用正padding+负margin</h3><p>我们通过等布局便可解决圣杯布局的第二点缺点，因为背景是在 padding 区域显示的，<strong>设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉</strong>。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器。新增代码如下：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        <span class="hljs-attribute">left</span>: -<span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: yellow;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: blue;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        <span class="hljs-attribute">right</span>: -<span class="hljs-number">220px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.center</span>,</span><span class="language-css">      <span class="hljs-selector-class">.left</span>,</span><span class="language-css">      <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">10000px</span>;</span><span class="language-css">        <span class="hljs-attribute">margin-bottom</span>: -<span class="hljs-number">10000px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-comment">/* 把溢出背景切掉 */</span></span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>等高布局<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="利用背景图片"><a href="#利用背景图片" class="headerlink" title="利用背景图片"></a>利用背景图片</h3><p>这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的css样式就可以轻松实现,但此方法不适合流体布局等高列的布局。</p><p>在制作样式之前需要一张类似下面的背景图：</p><p><img src="https://pic1.zhimg.com/80/v2-c4a4a0bfe32023c4773ee8f10e3918fc_1440w.webp" alt="img"></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”container</span> <span class="hljs-attr">clearfix</span>”&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”left”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">”content”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”right”</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>.container &#123;  background: url(&quot;column.png&quot;) repeat-y;  width: 960px;  margin: 0 auto;&#125;.left &#123;  float: left;  width: 220px;&#125;.content &#123;  float: left;  width: 480px;&#125;.right &#123;  float: left;  width: 220px;&#125;</code></pre></div><h3 id="模仿表格布局"><a href="#模仿表格布局" class="headerlink" title="模仿表格布局"></a>模仿表格布局</h3><p>这是一种非常简单，易于实现的方法。不过兼容性不好，在ie6-7无法正常运行。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.table</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: auto;</span><span class="language-css">        <span class="hljs-attribute">min-width</span>: <span class="hljs-number">1000px</span>;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">display</span>: table;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.tableRow</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: table-row;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.tableCell</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: table-cell;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">33%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.cell1</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#f00</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.cell2</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#0f0</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.cell3</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#00f</span>;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container table&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;containerInner tableRow&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column tableCell cell1&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left aside&quot;</span>&gt;</span>....<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column tableCell cell2&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content section&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column tableCell cell3&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right aside&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="使用边框和定位"><a href="#使用边框和定位" class="headerlink" title="使用边框和定位"></a>使用边框和定位</h3><p>这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#wrapper</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">960px</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;<span class="hljs-selector-id">#mainContent</span> &#123;  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">220px</span> solid <span class="hljs-number">#dfdfdf</span>;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">width</span>: <span class="hljs-number">740px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;    <span class="hljs-attribute">background</span>: green;&#125;<span class="hljs-selector-id">#sidebar</span> &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-number">#dfdfdf</span>;  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">740px</span>;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">220px</span>;&#125;&lt;<span class="hljs-selector-tag">div</span> id=&quot;wrapper&quot;&gt;    &lt;<span class="hljs-selector-tag">div</span> id=&quot;mainContent&quot;&gt;...&lt;/<span class="hljs-selector-tag">div</span>&gt;    &lt;<span class="hljs-selector-tag">div</span> id=&quot;sidebar&quot;&gt;...&lt;/<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;</code></pre></div><h2 id="粘连布局"><a href="#粘连布局" class="headerlink" title="粘连布局"></a>粘连布局</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>有一块内容<code>&lt;main&gt;</code>，当<code>&lt;main&gt;</code>的高康足够长的时候，紧跟在<code>&lt;main&gt;</code>后面的元素<code>&lt;footer&gt;</code>会跟在<code>&lt;main&gt;</code>元素的后面。</li><li>当<code>&lt;main&gt;</code>元素比较短的时候(比如小于屏幕的高度),我们期望这个<code>&lt;footer&gt;</code>元素能够“粘连”在屏幕的底部</li></ul><p><img src="https://pic1.zhimg.com/80/v2-08f08fceaca93e547a19441984cc8720_1440w.webp" alt="img"></p><p>具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      * &#123;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-tag">html</span>,</span><span class="language-css">      <span class="hljs-selector-tag">body</span> &#123;</span><span class="language-css">        <span class="hljs-comment">/* //高度一层层继承下来 */</span></span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-id">#wrap</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: pink;</span><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-id">#wrap</span> <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">50px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-id">#footer</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: deeppink;</span><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><span class="language-css">        <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;</span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>        main <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>        main <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>        main <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><h3 id="1-footer必须是一个独立的结构，与wrap没有任何嵌套关系"><a href="#1-footer必须是一个独立的结构，与wrap没有任何嵌套关系" class="headerlink" title="(1)footer必须是一个独立的结构，与wrap没有任何嵌套关系"></a>(1)footer必须是一个独立的结构，与wrap没有任何嵌套关系</h3><h3 id="2-wrap区域的高度通过设置min-height，变为视口高度"><a href="#2-wrap区域的高度通过设置min-height，变为视口高度" class="headerlink" title="(2)wrap区域的高度通过设置min-height，变为视口高度"></a>(2)wrap区域的高度通过设置min-height，变为视口高度</h3><h3 id="3-footer要使用margin为负来确定自己的位置"><a href="#3-footer要使用margin为负来确定自己的位置" class="headerlink" title="(3)footer要使用margin为负来确定自己的位置"></a>(3)footer要使用margin为负来确定自己的位置</h3><h3 id="4-在main区域需要设置-padding-bottom。这也是为了防止负-margin-导致-footer-覆盖任何实际内容。"><a href="#4-在main区域需要设置-padding-bottom。这也是为了防止负-margin-导致-footer-覆盖任何实际内容。" class="headerlink" title="(4)在main区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。"></a>(4)在main区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。</h3>]]></content>
    
    
    
    <tags>
      
      <tag>css布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grid布局</title>
    <link href="/2022/10/19/Grid%E5%B8%83%E5%B1%80/"/>
    <url>/2022/10/19/Grid%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="网格布局的基本概念"><a href="#网格布局的基本概念" class="headerlink" title="网格布局的基本概念"></a>网格布局的基本概念</h1><p>Grid是二维的网格布局系统，可用于布局页面主要的区域布局或小型组件，flex是一维的布局</p><h2 id="什么是网格？"><a href="#什么是网格？" class="headerlink" title="什么是网格？"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E6%A0%BC%EF%BC%9F">什么是网格？</a></h2><p>网格是一组相交的水平线和垂直线，它定义了网格的列和行。我们可以将网格元素放置在与这些行和列相关的位置上。CSS 网格布局具有以下特点</p><h3 id="固定的位置和弹性的轨道的大小"><a href="#固定的位置和弹性的轨道的大小" class="headerlink" title="固定的位置和弹性的轨道的大小"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%9B%BA%E5%AE%9A%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%BC%B9%E6%80%A7%E7%9A%84%E8%BD%A8%E9%81%93%E7%9A%84%E5%A4%A7%E5%B0%8F">固定的位置和弹性的轨道的大小</a></h3><p>你可以使用固定的单位尺寸来构建网格，例如px,或者使用专门为grid创建的新的单位fr用来创建弹性网格。</p><h3 id="元素位置"><a href="#元素位置" class="headerlink" title="元素位置"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE">元素位置</a></h3><p>你可以用使用行好，行名或者一个标定来精确的定位每个网格的排列</p><h3 id="创建额外的轨道来包含元素"><a href="#创建额外的轨道来包含元素" class="headerlink" title="创建额外的轨道来包含元素"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%88%9B%E5%BB%BA%E9%A2%9D%E5%A4%96%E7%9A%84%E8%BD%A8%E9%81%93%E6%9D%A5%E5%8C%85%E5%90%AB%E5%85%83%E7%B4%A0">创建额外的轨道来包含元素</a></h3><p>可以使用网格布局定义一个显式网格，但是根据规范它会处理你加在网格外面的内容，当必要时它会自动增加行和列，它会尽可能多的容纳所有的列。</p><h3 id="创建额外的轨道来包含元素-1"><a href="#创建额外的轨道来包含元素-1" class="headerlink" title="创建额外的轨道来包含元素"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%88%9B%E5%BB%BA%E9%A2%9D%E5%A4%96%E7%9A%84%E8%BD%A8%E9%81%93%E6%9D%A5%E5%8C%85%E5%90%AB%E5%85%83%E7%B4%A0">创建额外的轨道来包含元素</a></h3><p>可以使用网格布局定义一个显式网格，但是根据规范它会处理你加在网格外面的内容，当必要时它会自动增加行和列，它会尽可能多的容纳所有的列。</p><p>使用display:grid/inline-grid就可以是用网格</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Four<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Five<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;  <span class="hljs-attribute">display</span>: grid;&#125;</code></pre></div><p><img src="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/1-grid-inspector.png" alt="Using the Grid Highlighter in DevTools to view a grid"></p><p>我们通过 <strong>grid-template-columns</strong> 和 <strong>grid-template-rows</strong> 属性来定义网格中的行和列,这些属性定义了网格的轨道。一个网格轨道就是网格中任意两条线之间的空间。在下图中你可以看到一个高亮的轨道——网格的第一个行轨道。</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;div <span class="hljs-keyword">class</span>=&quot;wrapper&quot;&gt;   &lt;div&gt;One&lt;/div&gt;   &lt;div&gt;Two&lt;/div&gt;   &lt;div&gt;Three&lt;/div&gt;   &lt;div&gt;Four&lt;/div&gt;   &lt;div&gt;Five&lt;/div&gt;&lt;/div&gt;.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">200</span>px <span class="hljs-number">200</span>px <span class="hljs-number">200</span>px;//每一列的宽度都是<span class="hljs-number">200</span>px，分为三列&#125;</code></pre></div><h3 id="fr"><a href="#fr" class="headerlink" title="fr"></a>fr</h3><p>f r是专门用于grid的单位，新的<code>fr</code>单位代表网格容器中可用空间的一等份。下一个网格定义将创建三个相等宽度的轨道，这些轨道会随着可用空间增长和收缩。</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;div <span class="hljs-keyword">class</span>=&quot;wrapper&quot;&gt;   &lt;div&gt;One&lt;/div&gt;   &lt;div&gt;Two&lt;/div&gt;   &lt;div&gt;Three&lt;/div&gt;   &lt;div&gt;Four&lt;/div&gt;   &lt;div&gt;Five&lt;/div&gt;&lt;/div&gt;.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;//这样将等分为三分&#125;.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">2</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;//这样就是分为四分，其中第一个div站两份&#125;.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">500</span>px <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;//还可以和其他单位混用，第一个是固定单位，其他剩余的等分&#125;</code></pre></div><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;&#125;</code></pre></div><p>也可以写成</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);//<span class="hljs-number">1</span>fr重复<span class="hljs-number">3</span>次，就是三等分&#125;</code></pre></div><p>Repeat 语句可以用于重复轨道列表中的一部分。在下面的例子中我创建了一个网格：它起始轨道为 20 像素，接着重复了 6 个<code>1fr</code>的轨道，最后再添加了一个 20 像素的轨道。</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">20</span>px repeat(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>fr) <span class="hljs-number">20</span>px;&#125;</code></pre></div><p>Repeat 语句可以传入一个轨道列表，因此你可以用它来创建一个多轨道模式的重复轨道列表。在下一个例子中，网格将有共计 10 个轨道，为 1 个<code>1fr</code>轨道后面跟着 1 个<code>2fr</code>轨道，该模式重复 5 次。</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr);&#125;</code></pre></div><h3 id="grid-auto-rows和grid-auto-columns"><a href="#grid-auto-rows和grid-auto-columns" class="headerlink" title="grid-auto-rows和grid-auto-columns"></a>grid-auto-rows和grid-auto-columns</h3><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Four<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Five<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>.wrapper &#123;  display: grid;  grid-template-columns: repeat(3, 1fr);  grid-auto-rows: 200px;&#125;</code></pre></div><p>Grid-auto-rows是用来定义每一行的默认高度，或者定义1fr的宽度，grid-auto-columns也是一样</p><p>网格用 minmax() 函数来解决这个问题。在下一个例子中我用 minmax() 作为 grid-auto-rows 的值。自动创建的行高将会是最小 100 像素，最大为 auto。用 auto 意味着行的尺寸将会根据内容的大小来自动变换：根据本行中最高的单元，把空间扩展到足够容纳该单元</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;  display: grid;  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);  grid-auto-<span class="hljs-keyword">rows</span>: minmax(<span class="hljs-number">100</span>px, auto);//还可以使用minax来定义每个轨道的区间，这个定义的是最小值为<span class="hljs-number">100</span>px，最大值为auto，可以由内容撑开&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Two    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I have some more content in.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This makes me taller than 100 pixels.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Three<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Four<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Five<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><iframe class="sample-code-frame" title="轨道大小和minmax()" id="frame_轨道大小和_minmax" width="230" height="490" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E8%BD%A8%E9%81%93%E5%A4%A7%E5%B0%8F%E5%92%8C_minmax.html" loading="lazy"></iframe><h3 id="跨轨道放置网格元素"><a href="#跨轨道放置网格元素" class="headerlink" title="跨轨道放置网格元素"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E8%B7%A8%E8%BD%A8%E9%81%93%E6%94%BE%E7%BD%AE%E7%BD%91%E6%A0%BC%E5%85%83%E7%B4%A0">跨轨道放置网格元素</a></h3><p>grid-column-start：是用于从哪条列网格线开始，开始的索引是1，而不是0</p><p>grid-column-end：是从哪一条列网格线结束</p><p>grid-row-start：从哪条线开始行</p><p>grid-row-end：结束行</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;    display: grid;    grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);    grid-auto-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px;&#125;.box1 &#123;    grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;//从第一条列线开始    grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;//到第<span class="hljs-number">4</span>条列线结束    grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;//从第一条航线开始    grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;//到第三条航线结束&#125;.box2 &#123;    grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;    grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">3</span>;    grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">5</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="跨轨道放置网格元素 sample" id="frame_跨轨道放置网格元素" width="220" height="410" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E8%B7%A8%E8%BD%A8%E9%81%93%E6%94%BE%E7%BD%AE%E7%BD%91%E6%A0%BC%E5%85%83%E7%B4%A0.html" loading="lazy"></iframe><h2 id="网格单元"><a href="#网格单元" class="headerlink" title="网格单元"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E7%BD%91%E6%A0%BC%E5%8D%95%E5%85%83">网格单元</a></h2><p>网格单元就是指最小的网格单位</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/1_grid_cell.png" alt="The first cell of the grid highlighted"></p><h2 id="网格区域"><a href="#网格区域" class="headerlink" title="网格区域"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E7%BD%91%E6%A0%BC%E5%8C%BA%E5%9F%9F">网格区域</a></h2><p>是指每一个所占的区域</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/1_grid_area.png" alt="A grid area"></p><h2 id="网格间距"><a href="#网格间距" class="headerlink" title="网格间距"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E7%BD%91%E6%A0%BC%E9%97%B4%E8%B7%9D">网格间距</a></h2><p>是指每个网格之间间距</p><p>column-gap：指的是两列之间的间距</p><p>row-gap：指两行之间的间距</p><p>gap：是row-gap和column-gap的缩写</p><div class="code-wrapper"><pre><code class="hljs angelscript">.wrapper &#123;   display: grid;   grid-template-columns: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1f</span>r);   column-gap: <span class="hljs-number">10</span>px;   row-gap: <span class="hljs-number">1</span>em;&#125;&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span>&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><iframe class="sample-code-frame" title="网格间距 sample" id="frame_网格间距" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E7%BD%91%E6%A0%BC%E9%97%B4%E8%B7%9D.html" loading="lazy"></iframe><p>间距使用的空间会在 使用弹性长度 fr 的轨道的空间计算前就被留出来，间距的尺寸定义行为和普通轨道一致，但不同的是你不能向其中插入任何内容。从以基线定位的角度来说，间距就像一条很宽的基线。</p><h2 id="嵌套网格"><a href="#嵌套网格" class="headerlink" title="嵌套网格"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E5%B5%8C%E5%A5%97%E7%BD%91%E6%A0%BC">嵌套网格</a></h2><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box1</span>&quot;&gt;        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">nested</span>&quot;&gt;<span class="hljs-symbol">a</span>&lt;/<span class="hljs-symbol">div</span>&gt;        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">nested</span>&quot;&gt;<span class="hljs-symbol">b</span>&lt;/<span class="hljs-symbol">div</span>&gt;        &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">nested</span>&quot;&gt;<span class="hljs-symbol">c</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;    &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><p><img src="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/1_nested_grids_in_flow.png" alt="Nested grid in flow"></p><p>如果把 <code>box1</code> 设置成 <code>display: grid</code> 你可以给它定义轨道然后它也会变成一个网格元素，它的子级元素也会排列在这个新网格元素中。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">3</span>;   <span class="hljs-attribute">display</span>: grid;   <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);&#125;</code></pre></div><iframe class="sample-code-frame" title="嵌套网格 sample" id="frame_嵌套网格" width="600" height="410" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E5%B5%8C%E5%A5%97%E7%BD%91%E6%A0%BC.html" loading="lazy"></iframe><h2 id="使用z-index控制层级"><a href="#使用z-index控制层级" class="headerlink" title="使用z-index控制层级"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E4%BD%BF%E7%94%A8z-index%E6%8E%A7%E5%88%B6%E5%B1%82%E7%BA%A7">使用<code>z-index</code>控制层级</a></h2><p>多个网格项目可以占用同一个网格单位。如果我们回到之前根据网格线编号放置网格项目的话，我们可以更改此项来使两个网格项目重叠。</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box</span> <span class="hljs-symbol">box5</span>&quot;&gt;<span class="hljs-symbol">Five</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;   display: grid;   grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);   grid-auto-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px;&#125;.box1 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;&#125;.box2 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">2</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="使用z-index控制层级" id="frame_l_ex" width="210" height="410" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.l_ex.html" loading="lazy"></iframe><p>网格项目 <code>box2</code> 现在覆盖于 <code>box1 之上，其覆盖顺序遵循文档流的原始顺序（后来居上）</code></p><h3 id="控制顺序"><a href="#控制顺序" class="headerlink" title="控制顺序"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout#%E6%8E%A7%E5%88%B6%E9%A1%BA%E5%BA%8F">控制顺序</a></h3><p>我们可以在网格项目发生重叠时使用 <code>z-index</code> 属性控制重叠的顺序——就像放置网格项目一样。如果我们给 <code>box2</code> 设定一个低于 <code>box1</code> 的 <code>z-index</code> 值的话，<code>box2</code> 将会显示在 box1 的下方。</p><div class="code-wrapper"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;   display: grid;   grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: repeat(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);   grid-auto-<span class="hljs-keyword">rows</span>: <span class="hljs-number">100</span>px;&#125;.box1 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;   z-<span class="hljs-keyword">index</span>: <span class="hljs-number">2</span>;&#125;.box2 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">2</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;   z-<span class="hljs-keyword">index</span>: <span class="hljs-number">1</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="控制顺序 sample" id="frame_控制顺序" width="210" height="410" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout/_sample_.%E6%8E%A7%E5%88%B6%E9%A1%BA%E5%BA%8F.html" loading="lazy"></iframe><h2 id="grid-column-和-grid-row-的简写"><a href="#grid-column-和-grid-row-的简写" class="headerlink" title="grid-column 和 grid-row 的简写"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#grid-column_%E5%92%8C_grid-row_%E7%9A%84%E7%AE%80%E5%86%99"><code>grid-column</code> 和 <code>grid-row</code> 的简写</a></h2><p>grid-column-start和grid-column-end的缩写是grid-column，grid-row-start和grid-row-end的缩写</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> /  <span class="hljs-number">2</span>;&#125;<span class="hljs-selector-class">.box4</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="grid-column 和 grid-row 的简写 sample" id="frame_grid-column_和_grid-row_的简写" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.grid-column_%E5%92%8C_grid-row_%E7%9A%84%E7%AE%80%E5%86%99.html" loading="lazy"></iframe><h2 id="默认跨度"><a href="#默认跨度" class="headerlink" title="默认跨度"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E9%BB%98%E8%AE%A4%E8%B7%A8%E5%BA%A6">默认跨度</a></h2><p>实际上如果一个元素只延伸一个轨道的话，你可以省略 <code>grid-column-end</code> 或 <code>grid-row-end</code> 值。元素默认延伸一个轨道</p><h3 id="默认跨度的普通写法"><a href="#默认跨度的普通写法" class="headerlink" title="默认跨度的普通写法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E9%BB%98%E8%AE%A4%E8%B7%A8%E5%BA%A6%E7%9A%84%E6%99%AE%E9%80%9A%E5%86%99%E6%B3%95">默认跨度的普通写法</a></h3><p>我们最初的示例的普通写法会是这样：</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">3</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;   <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.box4</span> &#123;   <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;   <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">3</span>;&#125;</code></pre></div><h3 id="默认跨度的简写"><a href="#默认跨度的简写" class="headerlink" title="默认跨度的简写"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E9%BB%98%E8%AE%A4%E8%B7%A8%E5%BA%A6%E7%9A%84%E7%AE%80%E5%86%99">默认跨度的简写</a></h3><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> ;//可以省略第二个值   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span> ;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> ;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> ;&#125;<span class="hljs-selector-class">.box4</span> &#123;   <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;   <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span> ;&#125;</code></pre></div><iframe class="sample-code-frame" title="默认跨度的简写 sample" id="frame_默认跨度的简写" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.%E9%BB%98%E8%AE%A4%E8%B7%A8%E5%BA%A6%E7%9A%84%E7%AE%80%E5%86%99.html" loading="lazy"></iframe><h2 id="grid-area-属性"><a href="#grid-area-属性" class="headerlink" title="grid-area 属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#grid-area_%E5%B1%9E%E6%80%A7"><code>grid-area</code> 属性</a></h2><p>我们可以更进一步，给每个元素只定义一个属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-area"><code>grid-area</code></a>。值的顺序如下</p><ul><li>grid-row-start</li><li>grid-column-start</li><li>grid-row-end</li><li>grid-column-end</li></ul><div class="code-wrapper"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;   &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;One&lt;/<span class="hljs-keyword">div</span>&gt;   &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;Two&lt;/<span class="hljs-keyword">div</span>&gt;   &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;Three&lt;/<span class="hljs-keyword">div</span>&gt;   &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box4&quot;</span>&gt;Four&lt;/<span class="hljs-keyword">div</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;.box1 &#123;   grid-area: <span class="hljs-number">1</span> <span class="hljs-regexp">/ 1 /</span> <span class="hljs-number">4</span> / <span class="hljs-number">2</span>;&#125;.box2 &#123;   grid-area: <span class="hljs-number">1</span> <span class="hljs-regexp">/ 3 /</span> <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;&#125;.box3 &#123;   grid-area: <span class="hljs-number">1</span> <span class="hljs-regexp">/ 2 /</span> <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;&#125;.box4 &#123;   grid-area: <span class="hljs-number">3</span> <span class="hljs-regexp">/ 2 /</span> <span class="hljs-number">4</span> / <span class="hljs-number">4</span>;&#125;</code></pre></div><p><code>grid-area</code> 的值的顺序看起来可能有点奇怪，比如说它正好和定义 margin 和 padding 的简写的值的顺序相反。但如果说是因为它与 CSS 书写模式规范中的书写方向相关就不难理解了。我们会在之后的文章中探讨网格与书写模式的关系，但我们有 4 个书写流关联的方向：</p><ul><li>块起始（block-start）</li><li>块结束（block-end）</li><li>行起始（inline-start）</li><li>行结束（inline-end）</li></ul><h2 id="反方向计数"><a href="#反方向计数" class="headerlink" title="反方向计数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E5%8F%8D%E6%96%B9%E5%90%91%E8%AE%A1%E6%95%B0">反方向计数</a></h2><p>我们也可以从行和块结束线开始反方向计数，对于英语来说就是右端的列线和底端的行线。这些线会被记为 <code>-1</code>，然后你可以从这往前数，所以倒数第 2 条线会被记为 <code>-2</code>。值得注意的是最后一条线是指显式定义网格的最后一条线，即由 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 定义的网格，并不把隐式定义网格的加入的行和列纳入考虑。</p><p>下面这个示例中，我们通过从右端和底端开始定义布局，把之前的示例的布局翻转了。</p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;div <span class="hljs-keyword">class</span>=&quot;wrapper&quot;&gt;   &lt;div <span class="hljs-keyword">class</span>=&quot;box1&quot;&gt;One&lt;/div&gt;   &lt;div <span class="hljs-keyword">class</span>=&quot;box2&quot;&gt;Two&lt;/div&gt;   &lt;div <span class="hljs-keyword">class</span>=&quot;box3&quot;&gt;Three&lt;/div&gt;   &lt;div <span class="hljs-keyword">class</span>=&quot;box4&quot;&gt;Four&lt;/div&gt;&lt;/div&gt;.box1 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-1</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-2</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-4</span>;&#125;.box2 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-3</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-4</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-3</span>;&#125;.box3 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-2</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-3</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-1</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-2</span>;&#125;.box4 &#123;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-2</span>;   grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-4</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">-3</span>;   grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">-4</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="反方向计数 sample" id="frame_反方向计数" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.%E5%8F%8D%E6%96%B9%E5%90%91%E8%AE%A1%E6%95%B0.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><h3 id="使元素跨越整个网格"><a href="#使元素跨越整个网格" class="headerlink" title="使元素跨越整个网格"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E4%BD%BF%E5%85%83%E7%B4%A0%E8%B7%A8%E8%B6%8A%E6%95%B4%E4%B8%AA%E7%BD%91%E6%A0%BC">使元素跨越整个网格</a></h3><p>拥有从开始计数和从末尾计数这两种定位方法使得使一个元素跨越整个网格变得很方便：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / -<span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="间距"><a href="#间距" class="headerlink" title="间距"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E9%97%B4%E8%B7%9D">间距</a></h2><p>CSS 网格规范加入了用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/row-gap"><code>row-gap</code></a> 属性定义列间距和行间距的能力。这两个属性的行为和多列布局中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a> 属性很像。</p><p><strong>备注：</strong> 在浏览器首次引入网格属性 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-gap"><code>column-gap</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/row-gap"><code>row-gap</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/gap"><code>gap</code></a> 时，具有 <code>grid-</code> 前缀。分别是 <code>grid-column-gap</code>、<code>grid-row-gap</code> 和 <code>grid-gap</code>。</p><p>浏览器正在更新它们的渲染引擎，以删除这一前缀，但是携带有前缀的版本将以别名的形式进行维护，使得它们可以被安全地使用。</p><p>间距只出现在网格轨道与轨道之间，它们并不会出现在网格容器的四周。通过在网格容器上定义这些属性，我们给上例加上了间距：</p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">wrapper</span>&quot;&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box1</span>&quot;&gt;<span class="hljs-symbol">One</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box2</span>&quot;&gt;<span class="hljs-symbol">Two</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box3</span>&quot;&gt;<span class="hljs-symbol">Three</span>&lt;/<span class="hljs-symbol">div</span>&gt;   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">box4</span>&quot;&gt;<span class="hljs-symbol">Four</span>&lt;/<span class="hljs-symbol">div</span>&gt;&lt;/<span class="hljs-symbol">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> ;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">4</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span> ;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> ;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> ;&#125;<span class="hljs-selector-class">.box4</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / <span class="hljs-number">4</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span> ;&#125;<span class="hljs-selector-class">.wrapper</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">100px</span>);    <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">row-gap</span>: <span class="hljs-number">1em</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="间距 sample" id="frame_间距" width="300" height="350" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.%E9%97%B4%E8%B7%9D.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem;"></iframe><p>间距可以使用gap进行简写</p><h2 id="使用-span-关键字"><a href="#使用-span-关键字" class="headerlink" title="使用 span 关键字"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid#%E4%BD%BF%E7%94%A8_span_%E5%85%B3%E9%94%AE%E5%AD%97">使用 <code>span</code> 关键字</a></h2><p>除了”起始线与结束线“的定位方法，你还可以使用”起始线与跨越轨道数量“的定位方法</p><div class="code-wrapper"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;   &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box1&quot;</span>&gt;One&lt;/div&gt;   &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box2&quot;</span>&gt;Two&lt;/div&gt;   &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box3&quot;</span>&gt;Three&lt;/div&gt;   &lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;box4&quot;</span>&gt;Four&lt;/div&gt;&lt;/div&gt;<span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">3</span>;&#125;<span class="hljs-selector-class">.box2</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">3</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;&#125;<span class="hljs-selector-class">.box3</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.box4</span> &#123;    <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">2</span> / span <span class="hljs-number">2</span>;    <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">3</span>;&#125;</code></pre></div><iframe class="sample-code-frame" title="使用 span 关键字 sample" id="frame_使用_span_关键字" width="300" height="330" src="https://yari-demos.prod.mdn.mozit.cloud/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid/_sample_.%E4%BD%BF%E7%94%A8_span_%E5%85%B3%E9%94%AE%E5%AD%97.html" loading="lazy" style="box-sizing: content-box; border: 1px solid var(--border-primary); max-width: 100%; width: calc((100% - 2rem) - 2px); background: rgb(255, 255, 255); border-radius: var(--elem-radius); padding: 1rem; color: rgb(27, 27, 27); font-family: Inter, &quot;system-ui&quot;, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><p>你也可以在 <code>grid-row-start</code>/<code>grid-row-end</code> 和 <code>grid-column-start</code>/<code>grid-column-end</code> 属性中使用 <code>span</code> 关键字。接下来两个例子会创建同样的网格。第一个例子中我们设定了起始行，然后说我们想结束线在跨越 3 条线之后。那这个元素就会从 1 号线开始，跨越 3 条线，到 4 号线结束。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row-end</span>: span <span class="hljs-number">3</span>;&#125;</code></pre></div><p>第二个例子中，我们定义了结束行线，然后设置起始线为跨越 3 条线。意味着这个元素会从指定的线往上跨越 3 条线。这个元素会从 4 号线开始，跨越 3 条线到 1 号线。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box1</span> &#123;    <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row-start</span>: span <span class="hljs-number">3</span>;    <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">4</span>;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
      <category>Grid</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Grid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-testing-library单元测试组件库学习</title>
    <link href="/2022/10/16/react-testing-librar%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/10/16/react-testing-librar%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BB%84%E4%BB%B6%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Testing-Library"><a href="#React-Testing-Library" class="headerlink" title="React Testing Library"></a>React Testing Library</h1><p><a href="https://github.com/testing-library/react-testing-library"><code>React Testing Library</code></a>是在DOM Testing Library的基础上增加了一些API用于React组件测试，如果项目通过create-react-app创建的项目提供了开箱即用的<strong>React Testing Library</strong>.，如果你不是使用creact-react-app创建项目，可以使用例如·npm/yarn</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install --save-dev @testing-library/react</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">yarn add <span class="hljs-attr">--dev</span> <span class="hljs-keyword">@testing-library</span>/react</code></pre></div><h2 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem<a href="https://testing-library.com/docs/react-testing-library/intro/#the-problem"></a></h2><p>如果你想写可持续性的测试为你的组件，作为这个目标的一部分，如果你想避免你的测试包含组件的详细的细节，并且专注于你的测试给你的组件带来信心，你的测试是可维护的，并且重构你的组件并不会破坏测试，和减慢你开发的进度</p><h2 id="This-solution"><a href="#This-solution" class="headerlink" title="This solution"></a>This solution<a href="https://testing-library.com/docs/react-testing-library/intro/#this-solution"></a></h2><p>React Testing Library测试库是非常轻量化的解决方案，它提供了基于react-dom和react-dom/test-utils，您的测试与您的软件使用方式越相似，它们能给您的信心就越大。你的测试将使用实际的DOM节点，而不是处理渲染的组件实例，这个工具库将提供函数有助于和用户相同的方式访问DOM，以更贴近用户的使用的方式测试组件，这个库可以作为enzyme的替代品</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123;rest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;msw&#x27;</span><span class="hljs-keyword">import</span> &#123;setupServer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;msw/node&#x27;</span><span class="hljs-comment">//用于mock 数据请求</span><span class="hljs-keyword">import</span> &#123;render, fireEvent, waitFor, screen&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@testing-library/react&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@testing-library/jest-dom&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Fetch</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../fetch&#x27;</span><span class="hljs-comment">//mock 请求数据的接口，模拟返回的数据</span><span class="hljs-keyword">const</span> server = <span class="hljs-title function_">setupServer</span>(  rest.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/greeting&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, ctx</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title function_">res</span>(ctx.<span class="hljs-title function_">json</span>(&#123;<span class="hljs-attr">greeting</span>: <span class="hljs-string">&#x27;hello there&#x27;</span>&#125;))  &#125;),)<span class="hljs-comment">//建立api 的mock 在所有测试以前</span><span class="hljs-title function_">beforeAll</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title function_">listen</span>())<span class="hljs-comment">//每次测试完后都重置请求</span><span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title function_">resetHandlers</span>())<span class="hljs-comment">//关闭请求</span><span class="hljs-title function_">afterAll</span>(<span class="hljs-function">() =&gt;</span> server.<span class="hljs-title function_">close</span>())<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;loads and displays greeting&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fetch</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/greeting&quot;</span> /&gt;</span></span>)<span class="hljs-comment">//模拟用户点击事件</span>  fireEvent.<span class="hljs-title function_">click</span>(screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-string">&#x27;Load Greeting&#x27;</span>))<span class="hljs-comment">//等待直到获取请求成功并且组件调用setState和重新渲染</span>  <span class="hljs-comment">//waitFor会等待直到回调函数响应成功</span>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitFor</span>(<span class="hljs-function">() =&gt;</span> screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;heading&#x27;</span>))<span class="hljs-comment">// assert that the alert message is correct using</span><span class="hljs-comment">// toHaveTextContent, a custom matcher from jest-dom.</span>  <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;heading&#x27;</span>)).<span class="hljs-title function_">toHaveTextContent</span>(<span class="hljs-string">&#x27;hello there&#x27;</span>)  <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;button&#x27;</span>)).<span class="hljs-title function_">toBeDisabled</span>()&#125;)<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;handles server error&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-comment">//重写测试接口</span>  server.<span class="hljs-title function_">use</span>(    rest.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/greeting&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, ctx</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">res</span>(ctx.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>))    &#125;),  )  <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fetch</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/greeting&quot;</span> /&gt;</span></span>)  fireEvent.<span class="hljs-title function_">click</span>(screen.<span class="hljs-title function_">getByText</span>(<span class="hljs-string">&#x27;Load Greeting&#x27;</span>))  <span class="hljs-keyword">await</span> <span class="hljs-title function_">waitFor</span>(<span class="hljs-function">() =&gt;</span> screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;alert&#x27;</span>))  <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;alert&#x27;</span>)).<span class="hljs-title function_">toHaveTextContent</span>(<span class="hljs-string">&#x27;Oops, failed to fetch!&#x27;</span>)  <span class="hljs-title function_">expect</span>(screen.<span class="hljs-title function_">getByRole</span>(<span class="hljs-string">&#x27;button&#x27;</span>)).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeDisabled</span>()&#125;)</code></pre></div><p>推荐使用<a href="https://github.com/mswjs/msw">Mock Service Worker</a> 这个库来mock window.fetch API</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123;useState, useReducer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><span class="hljs-keyword">const</span> initialState = &#123;  <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,  <span class="hljs-attr">greeting</span>: <span class="hljs-literal">null</span>,&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">greetingReducer</span>(<span class="hljs-params">state, action</span>) &#123;  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SUCCESS&#x27;</span>: &#123;      <span class="hljs-keyword">return</span> &#123;        <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">greeting</span>: action.<span class="hljs-property">greeting</span>,      &#125;    &#125;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ERROR&#x27;</span>: &#123;      <span class="hljs-keyword">return</span> &#123;        <span class="hljs-attr">error</span>: action.<span class="hljs-property">error</span>,        <span class="hljs-attr">greeting</span>: <span class="hljs-literal">null</span>,      &#125;    &#125;    <span class="hljs-attr">default</span>: &#123;      <span class="hljs-keyword">return</span> state    &#125;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fetch</span>(<span class="hljs-params">&#123;url&#125;</span>) &#123;  <span class="hljs-keyword">const</span> [&#123;error, greeting&#125;, dispatch] = <span class="hljs-title function_">useReducer</span>(    greetingReducer,    initialState,  )  <span class="hljs-keyword">const</span> [buttonClicked, setButtonClicked] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchGreeting</span> = <span class="hljs-keyword">async</span> url =&gt;    axios      .<span class="hljs-title function_">get</span>(url)      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> &#123;data&#125; = response        <span class="hljs-keyword">const</span> &#123;greeting&#125; = data        <span class="hljs-title function_">dispatch</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SUCCESS&#x27;</span>, greeting&#125;)        <span class="hljs-title function_">setButtonClicked</span>(<span class="hljs-literal">true</span>)      &#125;)      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;        <span class="hljs-title function_">dispatch</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ERROR&#x27;</span>, error&#125;)      &#125;)  <span class="hljs-keyword">const</span> buttonText = buttonClicked ? <span class="hljs-string">&#x27;Ok&#x27;</span> : <span class="hljs-string">&#x27;Load Greeting&#x27;</span>  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> fetchGreeting(url)&#125; disabled=&#123;buttonClicked&#125;&gt;</span><span class="language-xml">        &#123;buttonText&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      &#123;greeting &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;greeting&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>&#125;</span><span class="language-xml">      &#123;error &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>Oops, failed to fetch!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>react-testing-library</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>canvas笔记</title>
    <link href="/2022/10/12/canvas%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/12/canvas%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mobx的使用3⃣️</title>
    <link href="/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%89/"/>
    <url>/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>mobx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mobx的使用二</title>
    <link href="/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C/"/>
    <url>/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="集成React（react-integration）"><a href="#集成React（react-integration）" class="headerlink" title="集成React（react-integration）"></a>集成React（react-integration）</h1><p>用法:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span> <span class="hljs-comment">// Or &quot;mobx-react&quot;.</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-title class_">ReactElement</span>)</code></pre></div><p>MobX 可以独立于 React 运行, 但是他们通常是结合在一起使用, 在 <a href="https://zh.mobx.js.org/the-gist-of-mobx.html">Mobx的宗旨（The gist of MobX）</a> 一文中你会经常看见集成React最重要的一部分：用于包裹React Component的 <code>observer</code> <a href="https://reactjs.org/docs/higher-order-components.html">HOC</a>方法。</p><p><code>observer</code> 是你可以自主选择的，<a href="https://zh.mobx.js.org/installation.html#installation">在安装时（during installation）</a>独立提供的 React bindings 包。 在下面的例子中,我们将使用更加轻量的<a href="https://github.com/mobxjs/mobx/tree/main/packages/mobx-react-lite"><code>mobx-react-lite</code> 包</a>。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;    secondsPassed = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> += <span class="hljs-number">1</span>    &#125;&#125;<span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>()<span class="hljs-comment">//被`observer`包裹的函数式组件会被监听在它每一次调用前发生的任何变化</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; timer &#125;</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> <span class="hljs-attr">timer</span>=<span class="hljs-string">&#123;myTimer&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;    myTimer.<span class="hljs-title function_">increaseTimer</span>()&#125;, <span class="hljs-number">1000</span>)</code></pre></div><p><code>observer</code> HOC 将自动订阅 React components 中任何 <em>在渲染期间</em> 被使用的 <em>可被观察的对象</em> 。 因此, 当任何可被观察的对象 <em>变化</em> 发生时候 组件会自动进行重新渲染（re-render）。 它还会确保组件在 <em>没有变化</em> 发生的时候不会进行重新渲染（re-render）。 但是, 更改组件的可观察对象的不可读属性, 也不会触发重新渲染（re-render）。</p><p>在实际项目中，这一特性使得MobX应用程序能够很好的进行开箱即用的优化，并且通常不需要任何额外的代码来防止过度渲染。</p><p>要想让<code>observer</code>生效, 并不需要关心这些对象 <em>如何传递到</em> 组件的（它们只要能传递给组件即可 ·译者注）, 只需要关心他们是否是可读的。 深层嵌套的可观察对象也没有问题, 复杂的表达式类似 <code>todos[0].author.displayName</code> 也是可以使用的。 与其他必须显式声明或预先计算数据依赖关系的框架（例如 selectors）相比，这种发生的订阅机制就显得更加精确和高效。</p><h3 id="observer-组件中使用外部状态-（Using-external-state-in-observer-components）"><a href="#observer-组件中使用外部状态-（Using-external-state-in-observer-components）" class="headerlink" title="observer 组件中使用外部状态 （Using external state in observer components）"></a><code>observer</code> 组件中使用外部状态 （Using external state in <code>observer</code> components）</h3><p>使用props的方式</p><p>可被观察对象可以通过组件的props属性传入 (在下面的例子中):</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>() <span class="hljs-comment">// See the Timer definition above.</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; timer &#125;</span>) =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>)<span class="hljs-comment">// 通过props传递myTimer.</span><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> <span class="hljs-attr">timer</span>=<span class="hljs-string">&#123;myTimer&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>使用全局变量的方式</p><p>虽然我们不关心是 <em>如何</em> 引用（reference）的可观察对象,但是我们可以使用 （consume） 外部作用域（outer scopes directly）的可观察对象 (类似通过 import这样的方法, 等等)：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>() <span class="hljs-comment">//  Timer 定义在上面.</span><span class="hljs-comment">// 没有props, `myTimer` 立刻变成了闭包。</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;myTimer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>直接使用可观察对象效果很好，但是这通常会是通过模块引入，这种写法可能会使单元测试变得复杂。 因此，我们建议使用React Context。</p><p>使用<a href="https://reactjs.org/docs/context.html">React Context</a>共享整个可观察子树是一种很不错的选择：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;observer&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mobx-react-lite&#x27;</span><span class="hljs-keyword">import</span> &#123;createContext, useContext&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerContext</span> = createContext&lt;<span class="hljs-title class_">Timer</span>&gt;()<span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 从context中获取timer.</span>    <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">TimerContext</span>) <span class="hljs-comment">// 可以在上面查看 Timer的定义。</span>    <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>    )&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;new</span> <span class="hljs-attr">Timer</span>()&#125;&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">TimerContext.Provider</span>&gt;</span></span>,    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>需要注意的是我们并不推荐每一个不同的 <code>值（value）</code> 都通过不同的 <code>Provider</code>来传递 . 在使用Mobx的过程中不需要这样做, 因为共享的可观察对象会更新他自己。</p><h3 id="在observer-组件中使用全局可观察对象（Using-local-observable-state-in-observer-components）"><a href="#在observer-组件中使用全局可观察对象（Using-local-observable-state-in-observer-components）" class="headerlink" title="在observer 组件中使用全局可观察对象（Using local observable state in observer components）"></a>在<code>observer</code> 组件中使用全局可观察对象（Using local observable state in <code>observer</code> components）</h3><p>因为使用 <code>observer</code> 的可观察对象可以来自任何地方, 他们也可以使用local state（全局的state·译者注）。 再次声明，不同操作方式对于我们而言都是有价值的。</p><p>使用全局可观察对象的最简单的方式就是通过<code>useState</code>去存储一个全局可观察对象的引用。 需要注意的是, 因为我们不需要替换全局可观察对象的引用,所以我们其实可以完全不声明<code>useState</code>的更新方法:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> [timer] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>()) <span class="hljs-comment">// Timer的定义在上面（正如上面所说的那样这里我们忽略了更新方法的定义·译者注）。</span>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>如果你想要类似我们官方的例子那样自动更新 timer , 使用<code>useEffect</code> 可能是 React 中比较典型的写法：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> handle = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;        timer.<span class="hljs-title function_">increaseTimer</span>()    &#125;, <span class="hljs-number">1000</span>)    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">clearInterval</span>(handle)    &#125;&#125;, [timer])</code></pre></div><p>如刚才说的那样, 直接创建一个可观察的对象，而不是使用classes（这里的类指的是全局定义的Mobx state，在它们是使用class声明的）。 我们可以参考 <a href="https://zh.mobx.js.org/observable-state.html#observable">observable</a>这篇文章：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; observable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> [timer] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span>        <span class="hljs-title function_">observable</span>(&#123;            <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>,            <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;                <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span>++            &#125;        &#125;)    )    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p><code>const [store] = useState(() =&gt; observable(&#123; /* something */&#125;))</code> 是非常通用的一套写法， 为了简化这个写法我们可以调用<code>mobx-react-lite</code> 包中的 <a href="https://github.com/mobxjs/mobx-react#uselocalobservable-hook"><code>useLocalObservable</code></a> hook ,可以将上面的例子简化成：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer, useLocalObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useLocalObservable</span>(<span class="hljs-function">() =&gt;</span> (&#123;        <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>,        <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span>++        &#125;    &#125;))    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><h3 id="不要将可观察对象传递到-不是observer的组件中（Don’t-pass-observables-into-components-that-aren’t-observer）"><a href="#不要将可观察对象传递到-不是observer的组件中（Don’t-pass-observables-into-components-that-aren’t-observer）" class="headerlink" title="不要将可观察对象传递到 不是observer的组件中（Don’t pass observables into components that aren’t observer）"></a>不要将可观察对象传递到 不是<code>observer</code>的组件中（Don’t pass observables into components that aren’t <code>observer</code>）</h3><p>通过<code>observer</code>包裹的组件 <em>只可以</em> 订阅到在 <em>他们自己</em> 渲染的期间的可观察对象. 如果要将可观察对象 objects / arrays / maps 传递到子组件中, 他们必须被 <code>observer</code> 包裹。 通过callback回调的组件也是一样。</p><p>如果你非要传递可观察对象到未被<code>observer</code>包裹的组件中， 要么是因为它是第三方组件，要么你需要组件对Mobx无感知，那你必须在传递前 <a href="https://zh.mobx.js.org/observable-state.html#%E5%B0%86-observable-%E8%BD%AC%E6%8D%A2%E5%9B%9E%E6%99%AE%E9%80%9A%E7%9A%84-javascript-%E9%9B%86%E5%90%88">转换可观察对象为显式 （convert the observables to plain JavaScript values or structures）</a> 。</p><p>关于上述的详细描述, 可以看一下下面的使用 <code>todo</code> 对象的例子， 一个 <code>TodoView</code> (observer)组件和一个虚构的接收一组对象映射入参的不是<code>observer</code>的<code>GridRow</code>组件</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Todo</span> &#123;    title = <span class="hljs-string">&quot;test&quot;</span>    done = <span class="hljs-literal">true</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">TodoView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; todo &#125;: &#123; todo: Todo &#125;</span>) =&gt;</span>   <span class="hljs-comment">// 错误: GridRow 不能获取到 todo.title/ todo.done 的变更</span>   <span class="hljs-comment">//       因为他不是一个观察者（observer。</span>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;todo&#125;</span> /&gt;</span></span>   <span class="hljs-comment">// 正确:在 `TodoView` 中显式的声明相关的`todo` ，</span>   <span class="hljs-comment">//      到data中。</span>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;&#123;</span></span></span><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">title:</span> <span class="hljs-attr">todo.title</span>,</span></span><span class="hljs-tag"><span class="language-xml">       <span class="hljs-attr">done:</span> <span class="hljs-attr">todo.done</span></span></span><span class="hljs-tag"><span class="language-xml">   &#125;&#125; /&gt;</span></span>   <span class="hljs-comment">// 正确: 使用 `toJS`也是可以的, 并且是更清晰直白的方式。</span>   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;toJS(todo)&#125;</span> /&gt;</span></span>)</code></pre></div><h3 id="回调组件可能会需要-lt-Observer-gt-（-Callback-components-might-require-lt-Observer-gt-）"><a href="#回调组件可能会需要-lt-Observer-gt-（-Callback-components-might-require-lt-Observer-gt-）" class="headerlink" title="回调组件可能会需要&lt;Observer&gt;（ Callback components might require &lt;Observer&gt;）"></a>回调组件可能会需要<code>&lt;Observer&gt;</code>（ Callback components might require <code>&lt;Observer&gt;</code>）</h3><p>想象一下在同样的例子中, <code>GridRow</code> 携带一个 <code>onRender</code>回调函数。 <code>onRender</code> 是 <code>GridRow</code>渲染生命周期的一部分, 而不是 <code>TodoView</code> 的render (甚至在语法层面都能看出来)，我们不得不保证回调组件是一个 <code>observer</code> 组件。 或者，我们可以使用 <a href="https://github.com/mobxjs/mobx-react#observer">``</a>创建一个匿名观察者：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TodoView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; todo &#125;: &#123; todo: Todo &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 错误: GridRow.onRender 不能获得 todo.title / todo.done 中的改变</span>    <span class="hljs-comment">//        因为它不是一个观察者（observer） 。</span>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">onRender</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;todo.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>&#125; /&gt;</span>    <span class="hljs-comment">// 正确: 将回调组件通过Observer包裹将会正确的获得变化。</span>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridRow</span> <span class="hljs-attr">onRender</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">Observer</span>&gt;</span>&#123;() =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;todo.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Observer</span>&gt;</span>&#125; /&gt;</span>&#125;)</code></pre></div><p><strong>mobx-react vs. mobx-react-lite</strong></p><p>在本文中我们使用 <code>mobx-react-lite</code> 作为默认包。 <a href="https://github.com/mobxjs/mobx-react/">mobx-react</a> 是他的大兄弟，它里面也引用了 <code>mobx-react-lite</code> 包。 它提供了很多在新项目中不再需要的特性， mobx-react附加的特性有：</p><ol><li>对于React class components的支持。</li><li><code>Provider</code> 和<code>inject</code>. MobX的这些东西在有 React.createContext 替代后变得不必要了。</li><li>特殊的观察对象 <code>propTypes</code>。</li></ol><p>要注意 <code>mobx-react</code> 是全量包，也会暴露 <code>mobx-react-lite</code>包中的任何方法,其中包含对函数组件的支持。 如果你使用 <code>mobx-react</code>，那就不要添加 <code>mobx-react-lite</code> 的依赖和引用了。</p><p><strong>observer 🆚 React.memo</strong></p><p><code>observer</code> 会自动的使用 <code>memo</code>, 所以 <code>observer</code> 不需要再包裹 <code>memo</code>。 <code>memo</code> 会被 observer 组件安全的使用，因为任何在props中的改变(很深的) 都会被<code>observer</code>响应。</p><p><strong>应用<code>observer</code> 到基于class的组件</strong></p><p>如上所述，class 组件只在<code>mobx-react</code>包中得到支持， <code>mobx-react-lite</code>并不支持。 简而言之，你可以和函数式组件一样使用 <code>observer</code>包裹class 组件：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;React&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;        <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-keyword">const</span> &#123; timer &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>        &#125;    &#125;)</code></pre></div><p>可以阅读 <a href="https://github.com/mobxjs/mobx-react#api-documentation">mobx-react 文档</a> 获得更详细的信息。</p><p><strong>当你想要将<code>observer</code> 和其他高阶组件（HOC·译者注）一起使用, 需要首先调用 <code>observer</code></strong></p><p>当 <code>observer</code> 需要和装饰器或者其他高阶组件（HOC）一起使用时，请确保 <code>observer</code> 是最内层的 (最先调用的) 装饰器，否则的话它可能不会工作</p><p><strong>从 props导出计算属性</strong></p><p>在某些情况下你的组件本地可观察对象（local observables）的计算属性可能依赖于一些你组件接受到的参数（props）。 但是,这一系列从React组件接收到的参数（props）本身并不是可观察对象，所以更改这些组件的属性（props）并不会使得计算属性响应。你可能需要手动的从最新的数据来更新全局可观察对象的状态来触发计算属性更新。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer, useLocalObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; offset &#125;</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useLocalObservable</span>(<span class="hljs-function">() =&gt;</span> (&#123;        offset, <span class="hljs-comment">// 初始化offset</span>        <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>,        <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span>++        &#125;,        <span class="hljs-keyword">get</span> <span class="hljs-title function_">offsetTime</span>() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">offset</span> <span class="hljs-comment">// 这里的&#x27;offset&#x27;不是&#x27;props&#x27;传入的那个</span>        &#125;    &#125;))    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">//同步来自 &#x27;props&#x27; 的偏差到可观察对象 &#x27;timer&#x27;</span>        timer.<span class="hljs-property">offset</span> = offset    &#125;, [offset])    <span class="hljs-comment">//作为demo用途，初始化一个定时器.</span>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">const</span> handle = <span class="hljs-built_in">setInterval</span>(timer.<span class="hljs-property">increaseTimer</span>, <span class="hljs-number">1000</span>)        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">clearInterval</span>(handle)        &#125;    &#125;, [])    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.offsetTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>在实际项目中你可能很少需要这种写法, 因为 <code>return &lt;span&gt;Seconds passed: &#123;timer.secondsPassed - offset&#125;&lt;/span&gt;</code> 更加简单, 虽然是稍微低效率的解决方案。</p><p><strong>useEffect 与 可观察对象</strong></p><p><code>useEffect</code> 可以被用于触发需要发生的副作用, 它将会被约束在React 组建的生命周期中。 使用 <code>useEffect</code>需要指定详细的依赖。 对于 MobX 却不是必须的, 因为 MobX 拥有一种真正的能检查到依赖发发生的方法， <code>autorun</code>。 结合 <code>autorun</code>可以很轻松的在生命周期组件中使用<code>useEffect</code>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; observer, useLocalObservable, useAsObservableSource &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react-lite&quot;</span><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">useLocalObservable</span>(<span class="hljs-function">() =&gt;</span> (&#123;        <span class="hljs-attr">secondsPassed</span>: <span class="hljs-number">0</span>,        <span class="hljs-title function_">increaseTimer</span>(<span class="hljs-params"></span>) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span>++        &#125;    &#125;))    <span class="hljs-comment">// 在Effect方法之上触发可观察对象变化。</span>    <span class="hljs-title function_">useEffect</span>(        <span class="hljs-function">() =&gt;</span>            <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;                <span class="hljs-keyword">if</span> (timer.<span class="hljs-property">secondsPassed</span> &gt; <span class="hljs-number">60</span>) <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Still there. It&#x27;s a minute already?!!&quot;</span>)            &#125;),        []    )    <span class="hljs-comment">// 作为demo用途在Effect里定义一个定时器。</span>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">const</span> handle = <span class="hljs-built_in">setInterval</span>(timer.<span class="hljs-property">increaseTimer</span>, <span class="hljs-number">1000</span>)        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">clearInterval</span>(handle)        &#125;    &#125;, [])    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Seconds passed: &#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;)<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)</code></pre></div><p>需要注意的是我们在effect方法返回了一个创建自<code>autorun</code> 的清除方法。 这一点是非常重要的, 因为他确保了 <code>autorun</code> 在组件卸载的时候被清除了！</p><p>依赖数组可以保持为空，除非是一个不可观察对象的值需要触发autorun重新运行，你才需要将它添加到这里面。 请确保你的格式正确,你可以创建一个<code>定时器（timer）</code> (上面的例子中) 作为依赖。 这是安全并且无副作用的， 因为它引用的依赖根本不会改变。</p><p>如果你不想显式的在Effect中定义可观察对象请使用<code>reaction</code>而不是<code>autorun</code>，他们的传参是完全相同的。</p><h1 id="优化React组件渲染-🚀"><a href="#优化React组件渲染-🚀" class="headerlink" title="优化React组件渲染 {🚀}"></a>优化React组件渲染 {🚀}</h1>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>mobx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>杀手级的TypeScript功能：const断言</title>
    <link href="/2022/10/06/%E6%9D%80%E6%89%8B%E7%BA%A7%E7%9A%84TypeScript%E5%8A%9F%E8%83%BD%EF%BC%9Aconst%E6%96%AD%E8%A8%80/"/>
    <url>/2022/10/06/%E6%9D%80%E6%89%8B%E7%BA%A7%E7%9A%84TypeScript%E5%8A%9F%E8%83%BD%EF%BC%9Aconst%E6%96%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><code>const assertions</code>是ts3.4新增的功能，们可以用这个新功能省略很多繁琐的类型声明</p><h3 id="const-assertions"><a href="#const-assertions" class="headerlink" title="const assertions"></a>const assertions</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello&quot;</span> &#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code></pre></div><p>官方的解释是</p><p>const断言是ts3.4新增的一种构造函数，他的语法是用const代替type的类型断言，例如 <code>123 as const</code>），当我们使用const进行断言literal expression的时候，会做以下处理</p><ol><li>该表达式的字面量类型不会被扩展</li><li>对象字面量获取的是readonly属性</li><li>array literals将会变成readonly tuples</li></ol><p>官方的解释会比较困惑</p><h3 id="No-type-widening-for-literal-types-文字类型没有类型扩展"><a href="#No-type-widening-for-literal-types-文字类型没有类型扩展" class="headerlink" title="No type widening for literal types [文字类型没有类型扩展]"></a>No type widening for literal types [文字类型没有类型扩展]</h3><p>通过const断言，文字类型不会被扩展为更加宽泛的类型，当我们使用const声明字面量变量的时候，类型就会等于右侧的字面量</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&#x27;x&#x27;</span>; <span class="hljs-comment">// x has the type &#x27;x&#x27;</span></code></pre></div><p>const关键字可以确保不会重新分配变量类型并且会保证更加严格的类型定义，但是，如果我们使用let替代const的时候，let就会变成更加宽泛的类型</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&#x27;x&#x27;</span>; <span class="hljs-comment">// has the type &#x27;x&#x27; </span><span class="hljs-keyword">let</span> y = <span class="hljs-string">&#x27;x&#x27;</span>;   <span class="hljs-comment">// has the type string</span></code></pre></div><p>y会扩展为更加宽泛的值，允许分配其他值给y,而x只能是字面量的x,如果我们向让let也可以这么做，就可以使用const断言</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> y = <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// y has type &#x27;x&#x27;</span></code></pre></div><h3 id="object-literals-get-readonly-properties-对象字面量获得只读属性"><a href="#object-literals-get-readonly-properties-对象字面量获得只读属性" class="headerlink" title="object literals get readonly properties [对象字面量获得只读属性]"></a>object literals get readonly properties [对象字面量获得只读属性]</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> action = &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, &#125; <span class="hljs-comment">// has type &#123; type: string &#125;</span></code></pre></div><p>const声明对象时，却依然会出现属性的扩展</p><p>如果你熟悉使用redux的时候，action用于执行修改变量，对外界来说，redux是全局不可修改的state store,state只能通过action在reducer中进行修改，reducer是纯函数，他会返回更新之后的state的版本，在action被dispatch之后、</p><p>在redux中，通常情况下，是在actionCreator中创建action,actionCreators是纯函数，它会返回redux action的字面量的对象，以及提供参数给action</p><p>用一个例子进行解释说明</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params">n: number</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n,  &#125;&#125;<span class="hljs-keyword">const</span> action = <span class="hljs-title function_">setCount</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">// action has type</span><span class="hljs-comment">// &#123; type: string, payload: number &#125;</span></code></pre></div><p>type的类型应该是字面量的，但是会被自动转换成更加宽泛的类型，在TS3.4以前，我们需要显示的指定返回值类型才可以达到类似的效果，</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetCount</span> &#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>;  <span class="hljs-attr">payload</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">const</span> setCount = (<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">SetCount</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n,  &#125;&#125;<span class="hljs-keyword">const</span> action = <span class="hljs-title function_">setCount</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">// action has type SetCount</span></code></pre></div><p>ts3.4以后使用const断言也可以实现同样的效果,而且是只读属性的</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">const</span>&gt;&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n  &#125;&#125;<span class="hljs-keyword">const</span> action = <span class="hljs-title function_">setCount</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">// action has type</span><span class="hljs-comment">//  &#123; readonly type: &quot;SET_COUNT&quot;; readonly payload: number &#125;;</span></code></pre></div><p>对于使用了联合类型的action,在没有使用const断言的时候会比较麻烦</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetCount</span> &#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>;  <span class="hljs-attr">payload</span>: <span class="hljs-built_in">number</span>;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResetCount</span> &#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;RESET_COUNT&#x27;</span>;&#125;<span class="hljs-keyword">const</span> setCount = (<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">SetCount</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n,  &#125;&#125;<span class="hljs-keyword">const</span> resetCount = (): <span class="hljs-function"><span class="hljs-params">ResetCount</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;RESET_COUNT&#x27;</span>,  &#125;&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">CountActions</span> = <span class="hljs-title class_">SetCount</span> | <span class="hljs-title class_">ResetCount</span></code></pre></div><p>通过使用const的用法</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setCount</span> = (<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">const</span>&gt;&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_COUNT&#x27;</span>,    <span class="hljs-attr">payload</span>: n  &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">resetCount</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">const</span>&gt;&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;RESET_COUNT&#x27;</span>  &#125;&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">CountActions</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> setCount&gt; | <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> resetCount&gt;;</code></pre></div><h3 id="Array-literals-become-readonly-tuples"><a href="#Array-literals-become-readonly-tuples" class="headerlink" title="Array literals become readonly tuples"></a>Array literals become <code>readonly</code> tuples</h3><div class="code-wrapper"><pre><code class="hljs sqf">const <span class="hljs-built_in">action</span> = &#123;  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;SET_HOURS&#x27;</span>,  payload: [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>],&#125;<span class="hljs-comment">//  &#123; type: string; payload: number[]; &#125;</span><span class="hljs-built_in">action</span>.payload.push(<span class="hljs-number">12</span>) <span class="hljs-comment">// no error</span></code></pre></div><p>action。payload是可以修改的</p><p>如果使用了const断言</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> action = &lt;<span class="hljs-keyword">const</span>&gt;&#123;  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_HOURS&#x27;</span>,  <span class="hljs-attr">payload</span>: [<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]&#125;<span class="hljs-comment">// &#123;</span><span class="hljs-comment">//  readonly type: &quot;SET_HOURS&quot;;</span><span class="hljs-comment">//  readonly payload: readonly [8, 12, 5, 8];</span><span class="hljs-comment">// &#125;</span>action.<span class="hljs-property">payload</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">12</span>);  <span class="hljs-comment">// error - Property &#x27;push&#x27; does not exist on type &#x27;readonly [8, 12, 5, 8]&#x27;.</span></code></pre></div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;  <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>,  <span class="hljs-attr">y</span>: [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>],  <span class="hljs-attr">z</span>: &#123;    <span class="hljs-attr">a</span>:      &#123;  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span> &#125;  &#125; &#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;</code></pre></div><p>转换成</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: &#123;  readonly <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>;  readonly <span class="hljs-attr">y</span>: readonly [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>];  readonly <span class="hljs-attr">z</span>: &#123;    readonly <span class="hljs-attr">a</span>: &#123;      readonly <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>;    &#125;;  &#125;;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React18+Typescript的使用</title>
    <link href="/2022/10/05/React18-Typescript%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/05/React18-Typescript%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>Typescript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Enzyme react 单元测试</title>
    <link href="/2022/09/25/Enzyme-react-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/09/25/Enzyme-react-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="enyzme不再支持react18，如果需要使用请使用官方的测试工具React-Testing-Library"><a href="#enyzme不再支持react18，如果需要使用请使用官方的测试工具React-Testing-Library" class="headerlink" title="enyzme不再支持react18，如果需要使用请使用官方的测试工具React Testing Library"></a>enyzme不再支持react18，如果需要使用请使用官方的测试工具React Testing Library</h1><p><strong>enzyme</strong> / ˈenzaɪm /</p><p>Enzyme是一种react的javascript的单元测试工具，可以轻松的测试react组件的输出，Enyzme的API主要是模仿jq的api来进行DOM的遍历和操作</p><p>安装方式</p><div class="code-wrapper"><pre><code class="hljs bash">npm i --save-dev enzyme enzyme-adapter-react-17</code></pre></div><p>enzyme的配置方式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Enzyme</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme-adapter-react-17&#x27;</span>;<span class="hljs-title class_">Enzyme</span>.<span class="hljs-title function_">configure</span>(&#123; <span class="hljs-attr">adapter</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>() &#125;);</code></pre></div><p>Enzyme的三种渲染组件的方式</p><h4 id="Shallow-Rendering"><a href="#Shallow-Rendering" class="headerlink" title="Shallow Rendering"></a>Shallow Rendering</h4><p>是对官方的Shallow Renderer的封装，将组件渲染成虚拟DOM对象，只会渲染第一层，子组件将不会渲染出来，因此效率非常高，不需要DOM环境，并且可以以JQ的方式访问组件</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; shallow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme&#x27;</span>;<span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);<span class="hljs-comment">// ...</span></code></pre></div><h5 id="常见的api"><a href="#常见的api" class="headerlink" title="常见的api"></a>常见的api</h5><h6 id="at-index-gt-ShallowWrapper"><a href="#at-index-gt-ShallowWrapper" class="headerlink" title=".at(index) =&gt; ShallowWrapper"></a><code>.at(index) =&gt; ShallowWrapper</code></h6><p>通过索引获取对应的wrapper</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);<span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">at</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">props</span>().<span class="hljs-property">foo</span>).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);</code></pre></div><p>和get方法相似，但是返回值是reactElement不是wrapper</p><p>first方法相当于at(0),last方法相当于返回最后一个</p><h6 id="childAt-index-gt-ShallowWrapper"><a href="#childAt-index-gt-ShallowWrapper" class="headerlink" title=".childAt(index) =&gt; ShallowWrapper"></a><code>.childAt(index) =&gt; ShallowWrapper</code></h6><p>通过索引找到第几个子元素，返回wrapper</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ToDoList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;items&#125;</span> /&gt;</span></span>);<span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;ul&#x27;</span>).<span class="hljs-title function_">childAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">type</span>()).<span class="hljs-property">to</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-string">&#x27;li&#x27;</span>);</code></pre></div><h6 id="children-selector-gt-ShallowWrapper"><a href="#children-selector-gt-ShallowWrapper" class="headerlink" title=".children([selector]) =&gt; ShallowWrapper"></a><code>.children([selector]) =&gt; ShallowWrapper</code></h6><p>找到所有子元素，可以传入可选参数，返回wrapper</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ToDoList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&#123;items&#125;</span> /&gt;</span></span>);<span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;ul&#x27;</span>).<span class="hljs-title function_">children</span>()).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(items.<span class="hljs-property">length</span>);</code></pre></div><h6 id="closest-selector-gt-ShallowWrapper"><a href="#closest-selector-gt-ShallowWrapper" class="headerlink" title=".closest(selector) =&gt; ShallowWrapper"></a><code>.closest(selector) =&gt; ShallowWrapper</code></h6><p>返回匹配到的选择器的第一个选择器的wrapper</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">shallow</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);<span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">find</span>(<span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">closest</span>(<span class="hljs-string">&#x27;.bar&#x27;</span>)).<span class="hljs-property">to</span>.<span class="hljs-property">have</span>.<span class="hljs-title function_">lengthOf</span>(<span class="hljs-number">1</span>);</code></pre></div><h4 id="Full-DOM-Rendering"><a href="#Full-DOM-Rendering" class="headerlink" title="Full DOM Rendering"></a>Full DOM Rendering</h4><p>完全渲染，它将组件渲染加载成一个真实的DOM节点，用来测试DOM API的交互和组件的生命周期，用到了jsdom来模拟浏览器环境</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; mount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme&#x27;</span>;<span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">mount</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);</code></pre></div><h4 id="Static-Rendered-Markup"><a href="#Static-Rendered-Markup" class="headerlink" title="Static Rendered Markup"></a>Static Rendered Markup</h4><p>静态渲染，它将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库解析这段字符串，并返回一个Cheerio的实例对象，可以用来分析组件的html结构</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;enzyme&#x27;</span>;<span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>);<span class="hljs-comment">// ...</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>单元测试</category>
      
      <category>Enzyme</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>secket.io笔记</title>
    <link href="/2022/09/24/secket-io%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/24/secket-io%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>目前是4.x版本</p><h2 id="什么是-Socket-IO"><a href="#什么是-Socket-IO" class="headerlink" title="什么是 Socket.IO"></a>什么是 Socket.IO</h2><p>Socket.IO 是一个库，可以在客户端和服务器之间实现 <strong>低延迟</strong>, <strong>双向</strong> 和 <strong>基于事件的</strong> 通信。</p><p><img src="https://socket.io/zh-CN/images/bidirectional-communication2.png" alt="Diagram of a communication between a server and a client"></p><p>它建立在 <a href="https://fr.wikipedia.org/wiki/WebSocket">WebSocket</a> 协议之上，并提供额外的保证，例如回退到 HTTP 长轮询或自动重新连接。</p><p>这里只介绍socket.io在web端的使用</p><p>这是一个websocket的实例</p><p><em>服务器</em> (基于 <a href="https://github.com/websockets/ws">ws</a>)</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i ws</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">WebSocketServer</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ws&quot;</span>;<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServer</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span> &#125;);server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 向客户端发送消息</span>  socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;hello from server&quot;</span>,    <span class="hljs-attr">content</span>: [ <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span> ]  &#125;));  <span class="hljs-comment">// 从客户端接收消息</span>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> packet = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);    <span class="hljs-keyword">switch</span> (packet.<span class="hljs-property">type</span>) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello from server&quot;</span>:        <span class="hljs-comment">// ...</span>        <span class="hljs-keyword">break</span>;    &#125;  &#125;);&#125;);</code></pre></div><p>客户端</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">WebSocket</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ws&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:3000&quot;</span>);socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 向服务器发送消息</span>  socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;hello from server&quot;</span>,    <span class="hljs-attr">content</span>: [ <span class="hljs-number">3</span>, <span class="hljs-string">&quot;4&quot;</span> ]  &#125;));&#125;);<span class="hljs-comment">// 从服务器接收消息</span>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; data &#125;</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> packet = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);  <span class="hljs-keyword">switch</span> (packet.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hello from server&quot;</span>:      <span class="hljs-comment">// ...</span>      <span class="hljs-keyword">break</span>;  &#125;&#125;);</code></pre></div><p>socket.io的示例,需要先安装socket.io和socket.io-client</p><p>服务端</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(<span class="hljs-number">3000</span>);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 向客户端发送消息</span>  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">4</span>]) &#125;);  <span class="hljs-comment">// 从客户端接收消息</span>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...</span>  &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;ws://localhost:3000&quot;</span>);<span class="hljs-comment">// 向服务器发送消息</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;6&quot;</span>, &#123; <span class="hljs-number">7</span>: <span class="hljs-title class_">Uint8Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">8</span>]) &#125;);<span class="hljs-comment">// 从服务器接收消息</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello from server&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h2 id="Socket-IO-不是什么"><a href="#Socket-IO-不是什么" class="headerlink" title="Socket.IO 不是什么"></a>Socket.IO 不是什么</h2><p>Socket.IO <strong>不是</strong> WebSocket实现。是基于WebSocket协议</p><p>尽管 Socket.IO 确实在可能的情况下使用 WebSocket 进行传输，但它为每个数据包添加了额外的元数据。这就是为什么 WebSocket 客户端将无法成功连接到 Socket.IO 服务器，而 Socket.IO 客户端也将无法连接到普通 WebSocket 服务器。</p><div class="code-wrapper"><pre><code class="hljs abnf">// 警告：客户端将无法连接！const socket <span class="hljs-operator">=</span> io(<span class="hljs-string">&quot;ws://echo.websocket.org&quot;</span>)<span class="hljs-comment">;</span></code></pre></div><h2 id="Socket-IO特点"><a href="#Socket-IO特点" class="headerlink" title="Socket.IO特点"></a>Socket.IO特点</h2><h3 id="HTTP-长轮询回退"><a href="#HTTP-长轮询回退" class="headerlink" title="HTTP 长轮询回退"></a>HTTP 长轮询回退</h3><p>如果无法建立 WebSocket 连接，连接将回退到 HTTP 长轮询。</p><h3 id="自动重新连接"><a href="#自动重新连接" class="headerlink" title="自动重新连接"></a>自动重新连接</h3><p>在某些特定情况下，服务器和客户端之间的 WebSocket 连接可能会中断，而双方都不知道链接的断开状态。</p><p>这就是为什么 Socket.IO 包含一个心跳机制，它会定期检查连接的状态。</p><p>当客户端最终断开连接时，它会以指数回退延迟自动重新连接，以免使服务器不堪重负。</p><h3 id="数据包缓冲"><a href="#数据包缓冲" class="headerlink" title="数据包缓冲"></a>数据包缓冲</h3><p>当客户端断开连接时，数据包会自动缓冲，并在重新连接时发送</p><h3 id="收到后的回调"><a href="#收到后的回调" class="headerlink" title="收到后的回调"></a>收到后的回调</h3><p>Socket.IO 提供了一种方便的方式来发送事件和接收响应    </p><p><em>发件人</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response); <span class="hljs-comment">// &quot;got it&quot;</span>&#125;);</code></pre></div><p><em>接收者</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg, callback</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// &quot;world&quot;</span>  <span class="hljs-title function_">callback</span>(<span class="hljs-string">&quot;got it!&quot;</span>);&#125;);</code></pre></div><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p><a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/">在服务器端，您可以向所有连接的客户端</a>或<a href="https://socket.io/zh-CN/docs/v4/rooms/">客户端的子集</a>发送事件：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 到所有连接的客户端</span>io.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">// 致“news”房间中的所有连接客户端</span>io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;news&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);</code></pre></div><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>命名空间允许您在单个共享连接上拆分应用程序的逻辑。例如，如果您想创建一个只有授权用户才能加入的“管理员”频道，这可能很有用。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 普通用户</span>&#125;);io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 管理员用户</span>&#125;);</code></pre></div><h2 id="运作原理"><a href="#运作原理" class="headerlink" title="运作原理"></a>运作原理</h2><p>Socket.IO 服务器 (Node.js) 和 Socket.IO 客户端（浏览器, Node.js, or <a href="https://socket.io/zh-CN/docs/v4/#what-socketio-is">其他编程语言</a>）之间的双向通道尽可能使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">WebSocket 连接</a>建立，并将使用 HTTP 长轮询作为后备。</p><p>Socket.IO 代码库分为两个不同的层：</p><ul><li>底层通道：我们称之为Engine.IO，Socket.IO内部的引擎</li><li>高级 API：Socket.IO 本身</li></ul><h2 id="Engine-IO"><a href="#Engine-IO" class="headerlink" title="Engine.IO"></a>Engine.IO</h2><p>Engine.IO 负责建立服务器和客户端之间的低级连接。它处理：</p><ul><li>各种<a href="https://socket.io/zh-CN/docs/v4/how-it-works/#transports">传输</a>和<a href="https://socket.io/zh-CN/docs/v4/how-it-works/#upgrade-mechanism">升级机制</a></li><li><a href="https://socket.io/zh-CN/docs/v4/how-it-works/#disconnection-detection">断线检测</a></li></ul><p>源代码可以在这里找到：</p><ul><li>服务器：<a href="https://github.com/socketio/engine.io">https://github.com/socketio/engine.io</a></li><li>客户端：<a href="https://github.com/socketio/engine.io-client">https://github.com/socketio/engine.io-client</a></li><li>解析器：<a href="https://github.com/socketio/engine.io-parser">https://github.com/socketio/engine.io-parser</a></li><li>协议说明：<a href="https://github.com/socketio/engine.io-protocol">https://github.com/socketio/engine.io-protocol</a></li></ul><h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>目前有两种实现的传输:</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/how-it-works/#http-long-polling">HTTP 长轮询</a></li><li><a href="https://socket.io/zh-CN/docs/v4/how-it-works/#websocket">WebSocket</a></li></ul><h4 id="HTTP-长轮询"><a href="#HTTP-长轮询" class="headerlink" title="HTTP 长轮询"></a>HTTP 长轮询</h4><p>THTTP 长轮询传输（也简称为“轮询”）由连续的 HTTP 请求组成：</p><ul><li>长时间运行的 <code>GET</code> 请求，用于从服务器接收数据</li><li>短时 <code>POST</code> 请求，用于向服务器发送数据</li></ul><p>由于传输的性质，可能会在同一个 HTTP 请求中连接并发送连续的请求。</p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 传输由<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocket 连接</a>组成，它在服务器和客户端之间提供双向和低延迟的通信通道。</p><p>由于传输的性质，每个发射都在其自己的 WebSocket 帧中发送（有些发射甚至可能导致两个不同的 WebSocket 帧，更多信息<a href="https://socket.io/zh-CN/docs/v4/custom-parser/#the-default-parser">在这里</a>).</p><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>在 Engine.IO 连接开始时，服务器发送一些信息：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;FSDjX-WRwSA4zTZMALqx&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;upgrades&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;websocket&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;pingInterval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">25000</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;pingTimeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20000</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>复制</p><ul><li><code>sid</code> 是会话的ID，它必须包含在sid所有后续HTTP请求的查询参数中</li><li><code>upgrades</code> 数组包含服务器支持的所有“更好”传输的列表</li><li><code>pingInterval</code> 和 <code>pingTimeout</code> 值用于心跳</li></ul><h3 id="升级机制"><a href="#升级机制" class="headerlink" title="升级机制"></a>升级机制</h3><p>默认情况下，客户端使用 HTTP 长轮询传输建立连接。</p><p><strong>为什么呢?</strong></p><p>虽然 WebSocket 显然是建立双向通信的最佳方式，但经验表明，由于企业代理、个人防火墙、防病毒软件…</p><p>从用户的角度来看，一个不成功的 WebSocket 连接可以转化为等待实时应用程序开始交换数据的至少 10 秒。 这在<strong>感知</strong>上会损害用户体验。</p><p>总而言之，Engine.io首先关注可靠性和用户体验，其次关注潜在的 UX 改进和提高服务器性能。</p><p>要升级，客户端将：</p><ul><li>确保其传出缓冲区为空</li><li>将当前传输设置为只读模式</li><li>尝试与其他传输建立连接</li><li>如果成功，关闭第一个传输</li></ul><p>您可以在浏览器的网络监视器中查看：</p><p><img src="https://socket.io/zh-CN/assets/images/network-monitor-2e47dbe233100aa290595f8687a9fcba.png" alt="Successful upgrade"></p><ol><li>握手 (包含会话 ID — 此处, <code>zBjrh...AAAK</code> — 用于后续请求)</li><li>发送数据 (HTTP 长轮询)</li><li>接收数据 (HTTP 长轮询)</li><li>升级 (WebSocket)</li><li>接收数据 (HTTP 长轮询, WebSocket连接建立成功后关闭)</li></ol><h3 id="断线检测"><a href="#断线检测" class="headerlink" title="断线检测"></a>断线检测</h3><p>Engine.IO 连接在以下情况下被视为关闭：</p><ul><li>一个 HTTP 请求（GET 或 POST）失败（例如，当服务器关闭时）</li><li>WebSocket 连接关闭（例如，当用户关闭其浏览器中的选项卡时）</li><li><code>socket.disconnect()</code> 在服务器端或客户端调用</li></ul><p>还有一个心跳机制检查服务器和客户端之间的连接是否仍然正常运行：</p><p>在给定的时间间隔（ <code>pingInterval</code>握手中发送的值），服务器发送一个 PING 数据包，客户端有几秒钟（该<code>pingTimeout</code>值）发送一个 PONG 数据包。如果服务器没有收到返回的 PONG 数据包，则认为连接已关闭。反之，如果客户端在 内没有收到 PING 包<code>pingInterval + pingTimeout</code>，则认为连接已关闭。</p><h2 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h2><p>Socket.IO 通过 Engine.IO 连接提供了一些附加功能：</p><ul><li>自动重连</li><li><a href="https://socket.io/zh-CN/docs/v4/client-offline-behavior/#buffered-events">数据包缓冲</a></li><li><a href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">收到后的回调</a></li><li>广播 <a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/">到所有客户端</a> 或 <a href="https://socket.io/zh-CN/docs/v4/rooms/">客户端的子集</a>（我们称之为“房间”）</li><li><a href="https://socket.io/zh-CN/docs/v4/namespaces/">多路复用</a>（我们称之为“命名空间”）</li></ul><p>源代码可以在这里找到：</p><ul><li>服务器：<a href="https://github.com/socketio/socket.io">https://github.com/socketio/socket.io</a></li><li>客户端：<a href="https://github.com/socketio/socket.io-client">https://github.com/socketio/socket.io-client</a></li><li>解析器：<a href="https://github.com/socketio/socket.io-parser">https://github.com/socketio/socket.io-parser</a></li><li>协议说明：<a href="https://github.com/socketio/socket.io-protocol">https://github.com/socketio/socket.io-protocol</a></li></ul><h1 id="服务器安装"><a href="#服务器安装" class="headerlink" title="服务器安装"></a>服务器安装</h1><div class="code-wrapper"><pre><code class="hljs sh">npm install socket.io</code></pre></div><p>安装特定版本：</p><div class="code-wrapper"><pre><code class="hljs sh">npm install socket.io@version</code></pre></div><p>默认情况下，Socket.IO 使用<a href="https://www.npmjs.com/package/ws">ws</a>包提供的 WebSocket 服务器。</p><h1 id="服务器初始化"><a href="#服务器初始化" class="headerlink" title="服务器初始化"></a>服务器初始化</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="只使用Socket"><a href="#只使用Socket" class="headerlink" title="只使用Socket"></a>只使用Socket</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//commonjs</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Server</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//esmodule</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);io.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p>您还可以将端口作为第一个参数传递：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(<span class="hljs-number">3000</span>, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><p>这隐式启动了一个 Node.js<a href="https://nodejs.org/docs/latest/api/http.html#http_class_http_server">HTTP 服务器</a>，可以通过 <code>io.httpServer</code>。</p><h3 id="使用HTTP服务器"><a href="#使用HTTP服务器" class="headerlink" title="使用HTTP服务器"></a>使用HTTP服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><h3 id="使用HTTPS服务器"><a href="#使用HTTPS服务器" class="headerlink" title="使用HTTPS服务器"></a>使用HTTPS服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(&#123;  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/key.pem&quot;</span>),  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/cert.pem&quot;</span>)&#125;);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p>使用客户端证书身份验证：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(&#123;  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-key.pem&quot;</span>),  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-cert.pem&quot;</span>),  <span class="hljs-attr">requestCert</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">ca</span>: [    <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-cert.pem&quot;</span>)  ]&#125;);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">rawSocket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// if you need the certificate details (it is no longer available once the handshake is completed)</span>  rawSocket.<span class="hljs-property">peerCertificate</span> = rawSocket.<span class="hljs-property">request</span>.<span class="hljs-property">client</span>.<span class="hljs-title function_">getPeerCertificate</span>();&#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">conn</span>.<span class="hljs-property">peerCertificate</span>);  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://example.com&quot;</span>, &#123;  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-key.pem&quot;</span>),  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/client-cert.pem&quot;</span>),  <span class="hljs-attr">ca</span>: [    <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/server-cert.pem&quot;</span>)  ]&#125;);</code></pre></div><h3 id="使用HTTP-2服务器"><a href="#使用HTTP-2服务器" class="headerlink" title="使用HTTP/2服务器"></a>使用HTTP/2服务器</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; readFileSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fs&quot;</span>;<span class="hljs-keyword">import</span> &#123; createSecureServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http2&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createSecureServer</span>(&#123;  <span class="hljs-attr">allowHTTP1</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">key</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/key.pem&quot;</span>),  <span class="hljs-attr">cert</span>: <span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&quot;/path/to/my/cert.pem&quot;</span>)&#125;);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><h3 id="使用-Express"><a href="#使用-Express" class="headerlink" title="使用 Express"></a>使用 Express</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//esmodule</span><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//ts</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;express&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app);<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p><u>在这里使用<code>app.listen(3000)</code>将不起作用，因为它会创建一个新的 HTTP 服务器。</u></p><h3 id="使用-Koa"><a href="#使用-Koa" class="headerlink" title="使用 Koa"></a>使用 Koa</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app.<span class="hljs-title function_">callback</span>());<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>(app.<span class="hljs-title function_">callback</span>());<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123; <span class="hljs-comment">/* options */</span> &#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><h3 id="使用-µWebSockets-js"><a href="#使用-µWebSockets-js" class="headerlink" title="使用 µWebSockets.js"></a>使用 µWebSockets.js</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">App</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;uWebSockets.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">App</span>();<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();io.<span class="hljs-title function_">attachApp</span>(app);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">(<span class="hljs-params">token</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (!token) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;port already in use&quot;</span>);  &#125;&#125;);</code></pre></div><h3 id="使用-Fastify"><a href="#使用-Fastify" class="headerlink" title="使用 Fastify"></a>使用 Fastify</h3><p>您需要注册<a href="https://github.com/alemagio/fastify-socket.io"><code>fastify-socket.io</code></a>插件：</p><ul><li><p>CommonJS</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fastify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fastify&quot;</span>);<span class="hljs-keyword">const</span> fastifyIO = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fastify-socket.io&quot;</span>);<span class="hljs-keyword">const</span> server = <span class="hljs-title function_">fastify</span>();server.<span class="hljs-title function_">register</span>(fastifyIO);server.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">req, reply</span>) =&gt;</span> &#123;  server.<span class="hljs-property">io</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>);&#125;);server.<span class="hljs-title function_">ready</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// we need to wait for the server to be ready, else `server.io` is undefined</span>  server.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...</span>  &#125;);&#125;);server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div></li><li><p>ES modules</p></li><li><p>```js<br>import fastify from “fastify”;<br>import fastifyIO from “fastify-socket.io”;</p><p>const server = fastify();<br>server.register(fastifyIO);</p><p>server.get(“/“, (req, reply) =&gt; {<br>  server.io.emit(“hello”);<br>});</p><p>server.ready().then(() =&gt; {<br>  // we need to wait for the server to be ready, else <code>server.io</code> is undefined<br>  server.io.on(“connection”, (socket) =&gt; {</p><div class="code-wrapper"><pre><code class="hljs">// ...</code></pre></div><p>  });<br>});</p><p>server.listen(3000);</p><div class="code-wrapper"><pre><code class="hljs moonscript">  - TypeScript```ts<span class="hljs-keyword">import</span> fastify <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fastify&quot;</span>;<span class="hljs-keyword">import</span> fastifyIO <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;fastify-socket.io&quot;</span>;const server = fastify();server.register(fastifyIO);server.get(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-params">(req, reply)</span> =&gt;</span> &#123;  server.<span class="hljs-built_in">io</span>.emit(<span class="hljs-string">&quot;hello&quot;</span>);&#125;);server.ready().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  // we need to wait <span class="hljs-keyword">for</span> the server to be ready, <span class="hljs-keyword">else</span> `server.<span class="hljs-built_in">io</span>` is undefined  server.<span class="hljs-built_in">io</span>.on(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">(socket)</span> =&gt;</span> &#123;    // ...  &#125;);&#125;);server.listen(<span class="hljs-number">3000</span>);</code></pre></div></li></ul><h1 id="服务器实例"><a href="#服务器实例" class="headerlink" title="服务器实例"></a>服务器实例</h1><p>服务器实例（通常<code>io</code>在代码示例中调用）具有一些可能在您的应用程序中使用的属性。</p><p>它还继承了<a href="https://socket.io/zh-CN/docs/v4/namespaces/#main-namespace">主命名空间</a>的所有方法，例如<a href="https://socket.io/zh-CN/docs/v4/server-api/#namespaceusefn"><code>namespace.use()</code></a>（参见<a href="https://socket.io/zh-CN/docs/v4/middlewares/">此处</a>）或 <a href="https://socket.io/zh-CN/docs/v4/server-api/#namespaceallsockets"><code>namespace.allSockets()</code></a>.</p><h2 id="服务器-engine"><a href="#服务器-engine" class="headerlink" title="服务器#engine"></a>服务器#engine</h2><p>对底层 Engine.IO 服务器的引用。</p><p>它可用于获取当前连接的客户端数量：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = io.<span class="hljs-property">engine</span>.<span class="hljs-property">clientsCount</span>;<span class="hljs-comment">// 根据您的用法，可能与主命名空间中的Socket实例计数相似或不相似</span><span class="hljs-keyword">const</span> count2 = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">sockets</span>.<span class="hljs-property">size</span>;</code></pre></div><p>或者生成自定义会话 ID（<code>sid</code>查询参数）：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> uuid = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;uuid&quot;</span>);io.<span class="hljs-property">engine</span>.<span class="hljs-property">generateId</span> = <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> &#123;  <span class="hljs-keyword">return</span> uuid.<span class="hljs-title function_">v4</span>(); <span class="hljs-comment">// 必须在所有socket.io服务器上都是唯一的</span>&#125;</code></pre></div><p>从<code>socket.io@4.1.0</code>开始，Engine.IO 服务器发出三个特殊事件：</p><ul><li><code>initial_headers</code>: 将在编写会话的第一个 HTTP 请求（握手）的响应标头之前发出，允许您自定义它们。</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;initial_headers&quot;</span>, <span class="hljs-function">(<span class="hljs-params">headers, req</span>) =&gt;</span> &#123;  headers[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-string">&quot;123&quot;</span>;  headers[<span class="hljs-string">&quot;set-cookie&quot;</span>] = <span class="hljs-string">&quot;mycookie=456&quot;</span>;&#125;);</code></pre></div><ul><li><code>headers</code>: 将在编写会话的每个 HTTP 请求的响应头之前发出（包括 WebSocket 升级），允许您自定义它们。</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;headers&quot;</span>, <span class="hljs-function">(<span class="hljs-params">headers, req</span>) =&gt;</span> &#123;  headers[<span class="hljs-string">&quot;test&quot;</span>] = <span class="hljs-string">&quot;789&quot;</span>;&#125;);</code></pre></div><ul><li><code>connection_error</code>: 当连接异常关闭时发出</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">engine</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">req</span>);      <span class="hljs-comment">// the request object</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">code</span>);     <span class="hljs-comment">// the error code, for example 1</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>);  <span class="hljs-comment">// the error message, for example &quot;Session ID unknown&quot;</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">context</span>);  <span class="hljs-comment">// some additional error context</span>&#125;);</code></pre></div><p>以下是可能的错误代码列表：</p><table><thead><tr><th>Code</th><th>Message</th></tr></thead><tbody><tr><td>0</td><td>“Transport unknown”</td></tr><tr><td>1</td><td>“Session ID unknown”</td></tr><tr><td>2</td><td>“Bad handshake method”</td></tr><tr><td>3</td><td>“Bad request”</td></tr><tr><td>4</td><td>“Forbidden”</td></tr><tr><td>5</td><td>“Unsupported protocol version”</td></tr></tbody></table><h3 id="socketsJoin"><a href="#socketsJoin" class="headerlink" title="socketsJoin"></a><code>socketsJoin</code></h3><p>此方法使匹配的 Socket 实例加入指定的房间：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances join the &quot;room1&quot; room</span>io.<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room1&quot;</span>);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room join the &quot;room2&quot; and &quot;room3&quot; rooms</span>io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsJoin</span>([<span class="hljs-string">&quot;room2&quot;</span>, <span class="hljs-string">&quot;room3&quot;</span>]);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace join the &quot;room2&quot; room</span>io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room2&quot;</span>);<span class="hljs-comment">// this also works with a single socket ID</span>io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">socketsJoin</span>(<span class="hljs-string">&quot;room1&quot;</span>);</code></pre></div><h3 id="socketsLeave"><a href="#socketsLeave" class="headerlink" title="socketsLeave"></a><code>socketsLeave</code></h3><p>该方法使匹配的 Socket 实例离开指定房间：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances leave the &quot;room1&quot; room</span>io.<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room1&quot;</span>);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room leave the &quot;room2&quot; and &quot;room3&quot; rooms</span>io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsLeave</span>([<span class="hljs-string">&quot;room2&quot;</span>, <span class="hljs-string">&quot;room3&quot;</span>]);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace leave the &quot;room2&quot; room</span>io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room2&quot;</span>);<span class="hljs-comment">// this also works with a single socket ID</span>io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">socketsLeave</span>(<span class="hljs-string">&quot;room1&quot;</span>);</code></pre></div><h3 id="disconnectSockets"><a href="#disconnectSockets" class="headerlink" title="disconnectSockets"></a><code>disconnectSockets</code></h3><p>此方法使匹配的 Socket 实例断开连接：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// make all Socket instances disconnect</span>io.<span class="hljs-title function_">disconnectSockets</span>();<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room disconnect (and discard the low-level connection)</span>io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">disconnectSockets</span>(<span class="hljs-literal">true</span>);<span class="hljs-comment">// make all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace disconnect</span>io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">disconnectSockets</span>();<span class="hljs-comment">// this also works with a single socket ID</span>io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">disconnectSockets</span>();</code></pre></div><h3 id="fetchSockets"><a href="#fetchSockets" class="headerlink" title="fetchSockets"></a><code>fetchSockets</code></h3><p>此方法返回匹配的 Socket 实例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// return all Socket instances of the main namespace</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-comment">// return all Socket instances in the &quot;room1&quot; room of the main namespace</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-comment">// return all Socket instances in the &quot;room1&quot; room of the &quot;admin&quot; namespace</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/admin&quot;</span>).<span class="hljs-title function_">in</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-comment">// this also works with a single socket ID</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">in</span>(theSocketId).<span class="hljs-title function_">fetchSockets</span>();</code></pre></div><p>上例中的<code>sockets</code>变量是一个对象数组，暴露了通常的 Socket 类的一个子集：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> socket <span class="hljs-keyword">of</span> sockets) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">handshake</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">data</span>);  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-comment">/* ... */</span>);  socket.<span class="hljs-title function_">join</span>(<span class="hljs-comment">/* ... */</span>);  socket.<span class="hljs-title function_">leave</span>(<span class="hljs-comment">/* ... */</span>);  socket.<span class="hljs-title function_">disconnect</span>(<span class="hljs-comment">/* ... */</span>);&#125;</code></pre></div><p><code>data</code>属性是一个任意对象，可用于在 Socket.IO 服务器之间共享信息：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-property">data</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;alice&quot;</span>;&#125;);<span class="hljs-comment">// server B</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sockets[<span class="hljs-number">0</span>].<span class="hljs-property">data</span>.<span class="hljs-property">username</span>); <span class="hljs-comment">// &quot;alice&quot;</span></code></pre></div><h3 id="serverSideEmit"><a href="#serverSideEmit" class="headerlink" title="serverSideEmit"></a><code>serverSideEmit</code></h3><p>此方法允许在<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">多服务器设置</a>中向集群的其他 Socket.IO 服务器发出事件。</p><p>语法：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div><p>在接收方：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// prints &quot;world&quot;</span>&#125;);</code></pre></div><p>也支持确认：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, responses</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(responses[<span class="hljs-number">0</span>]); <span class="hljs-comment">// prints &quot;pong&quot;</span>&#125;);<span class="hljs-comment">// server B</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;  <span class="hljs-title function_">cb</span>(<span class="hljs-string">&quot;pong&quot;</span>);&#125;);</code></pre></div><p>笔记：</p><ul><li><code>connection</code>，<code>connect</code> 和 <code>new_namespace</code> 字符串是保留的，不能在您的应用程序中使用。</li><li>您可以发送任意数量的参数，但目前不支持二进制结构（参数数组将被<code>JSON.stringify</code>-ed）</li></ul><p>例子：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-string">&quot;4&quot;</span> &#125;);</code></pre></div><ul><li>如果其他 Socket.IO 服务器在给定延迟后没有响应，则调用确认回调可能会出错</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">serverSideEmit</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, responses</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (err) &#123;    <span class="hljs-comment">// at least one Socket.IO server has not responded</span>    <span class="hljs-comment">// the &#x27;responses&#x27; array contains all the responses already received though</span>  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// success! the &#x27;responses&#x27; array contains one object per other Socket.IO server in the cluster</span>  &#125;&#125;);</code></pre></div><h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><p>Server 实例发出一个事件（好吧，从技术上讲是两个，但<code>connect</code>它是<code>connection</code>的别名）：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/server-instance/#connection"><code>connection</code></a></li></ul><h3 id="connection"><a href="#connection" class="headerlink" title="connection"></a><code>connection</code></h3><p>此事件在新连接时触发。第一个参数是一个<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/">Socket实例</a>.</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h1 id="Socket-实例（服务器端）"><a href="#Socket-实例（服务器端）" class="headerlink" title="Socket 实例（服务器端）"></a>Socket 实例（服务器端）</h1><p><code>Socket</code>是与客户端交互的基础类。它继承了 Node.js<a href="https://nodejs.org/api/events.html#class-eventemitter">EventEmitter</a>的所有方法，例如<a href="https://socket.io/zh-CN/docs/v4/server-api/#socketemiteventname-args">emit</a>, <a href="https://socket.io/zh-CN/docs/v4/server-api/#socketoneventname-callback">on</a>, <a href="https://socket.io/zh-CN/docs/v4/server-api/#socketonceeventname-listener">once</a> 或 <a href="https://socket.io/zh-CN/docs/v4/server-api/#socketremovelistenereventname-listener">removeListener</a>.</p><p><img src="https://socket.io/zh-CN/images/bidirectional-communication-socket.png" alt="Bidirectional communication between server and client"></p><p>除了：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/emitting-events/#basic-emit">发出</a> 和 <a href="https://socket.io/zh-CN/docs/v4/listening-to-events/">监听</a> 事件</li><li><a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients-except-the-sender">广播事件</a></li><li><a href="https://socket.io/zh-CN/docs/v4/rooms/#joining-and-leaving">加入和离开房间</a></li></ul><p>Socket 实例有一些可能在您的应用程序中使用的属性：</p><h2 id="Socket-id"><a href="#Socket-id" class="headerlink" title="Socket#id"></a>Socket#id</h2><p>每个新连接都分配有一个随机的 20 个字符的标识符。</p><p>此标识符与客户端的值同步。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// ojIckSD2jqNzOqIrAGzL</span>&#125;);<span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// ojIckSD2jqNzOqIrAGzL</span>&#125;);</code></pre></div><p>创建后，Socket 会加入由其自己的 id 标识的房间，这意味着您可以将其用于私人消息传递：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;private message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">anotherSocketId, msg</span>) =&gt;</span> &#123;    socket.<span class="hljs-title function_">to</span>(anotherSocketId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;private message&quot;</span>, socket.<span class="hljs-property">id</span>, msg);  &#125;);&#125;);</code></pre></div><p>注意：您不能覆盖此标识符，因为它在 Socket.IO 代码库的多个部分中使用。</p><h2 id="Socket-handshake"><a href="#Socket-handshake" class="headerlink" title="Socket#handshake"></a>Socket#handshake</h2><p>此对象包含有关在 Socket.IO 会话开始时发生的握手的一些详细信息。</p><div class="code-wrapper"><pre><code class="hljs text">&#123;  headers: /* the headers of the initial request */  query: /* the query params of the initial request */  auth: /* the authentication payload */  time: /* the date of creation (as string) */  issued: /* the date of creation (unix timestamp) */  url: /* the request URL string */  address: /* the ip of the client */  xdomain: /* whether the connection is cross-domain */  secure: /* whether the connection is secure */&#125;</code></pre></div><p>例子：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;headers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;user-agent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxx&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;accept&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*/*&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;example.com&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;connection&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;close&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;EIO&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;transport&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;polling&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;t&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;NNjNltH&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;issued&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1606005226969</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/socket.io/?EIO=4&amp;transport=polling&amp;t=NNjNltH&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;::ffff:1.2.3.4&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;xdomain&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;secure&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="Socket-rooms"><a href="#Socket-rooms" class="headerlink" title="Socket#rooms"></a>Socket#rooms</h2><p>这是对 Socket 当前所在<a href="https://socket.io/zh-CN/docs/v4/rooms/">房间</a>的引用。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// Set &#123; &lt;socket.id&gt; &#125;</span>  socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;room1&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// Set &#123; &lt;socket.id&gt;, &quot;room1&quot; &#125;</span>&#125;);</code></pre></div><h2 id="Socket-data"><a href="#Socket-data" class="headerlink" title="Socket#data"></a>Socket#data</h2><p>可以与<code>fetchSockets()</code>实用程序方法结合使用的任意对象：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server A</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-property">data</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;alice&quot;</span>;&#125;);<span class="hljs-comment">// server B</span><span class="hljs-keyword">const</span> sockets = <span class="hljs-keyword">await</span> io.<span class="hljs-title function_">fetchSockets</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sockets[<span class="hljs-number">0</span>].<span class="hljs-property">data</span>.<span class="hljs-property">username</span>); <span class="hljs-comment">// &quot;alice&quot;</span></code></pre></div><h2 id="Socket-conn"><a href="#Socket-conn" class="headerlink" title="Socket#conn"></a>Socket#conn</h2><p>对底层 Engine.IO 套接字的引用（参见<a href="https://socket.io/zh-CN/docs/v4/how-it-works/">此处</a>）。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;initial transport&quot;</span>, socket.<span class="hljs-property">conn</span>.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// prints &quot;polling&quot;</span>  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;upgrade&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;upgraded transport&quot;</span>, socket.<span class="hljs-property">conn</span>.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// prints &quot;websocket&quot;</span>  &#125;);  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packet&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called for each packet received</span>  &#125;);  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packetCreate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called for each packet sent</span>  &#125;);  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;drain&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// called when the write buffer is drained</span>  &#125;);  socket.<span class="hljs-property">conn</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called when the underlying connection is closed</span>  &#125;);&#125;);</code></pre></div><h2 id="Additional-attributes"><a href="#Additional-attributes" class="headerlink" title="Additional attributes"></a>Additional attributes</h2><p>只要您不覆盖任何现有属性，您就可以将任何属性附加到 Socket 实例并在以后使用它：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// in a middleware</span>io.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (socket, next) =&gt; &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>(socket);    socket.<span class="hljs-property">user</span> = user;  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unknown user&quot;</span>));  &#125;&#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">user</span>);  <span class="hljs-comment">// in a listener</span>  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;set username&quot;</span>, <span class="hljs-function">(<span class="hljs-params">username</span>) =&gt;</span> &#123;    socket.<span class="hljs-property">username</span> = username;  &#125;);&#125;);</code></pre></div><h2 id="Socket-middlewares"><a href="#Socket-middlewares" class="headerlink" title="Socket middlewares"></a>Socket middlewares</h2><p>这些中间件看起来很像通常的<a href="https://socket.io/zh-CN/docs/v4/middlewares/">中间价</a>，除了它们是为每个传入的数据包调用的：</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">[event, ...args], next</span>) =&gt;</span> &#123;  <span class="hljs-comment">// do something with the packet (logging, authorization, rate limiting...)</span>  <span class="hljs-comment">// do not forget to call next() at the end</span>  <span class="hljs-title function_">next</span>();&#125;);</code></pre></div><p>复制</p><p><code>next</code>也可以使用错误对象调用该方法。在这种情况下，事件将不会到达注册的事件处理程序，而<code>error</code>是会发出一个事件：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">[event, ...args], next</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUnauthorized</span>(event)) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unauthorized event&quot;</span>));    &#125;    <span class="hljs-title function_">next</span>();  &#125;);  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err &amp;&amp; err.<span class="hljs-property">message</span> === <span class="hljs-string">&quot;unauthorized event&quot;</span>) &#123;      socket.<span class="hljs-title function_">disconnect</span>();    &#125;  &#125;);&#125;);</code></pre></div><p>复制</p><p>注意：此功能仅存在于服务器端。对于客户端，您可能对<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#catch-all-listeners">catch-all listeners</a>感兴趣。</p><h2 id="Events-1"><a href="#Events-1" class="headerlink" title="Events"></a>Events<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#events"></a></h2><p>在服务器端，Socket 实例发出两个特殊事件：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnect"><code>disconnect</code></a></li><li><a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnecting"><code>disconnecting</code></a></li></ul><h3 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a><code>disconnect</code><a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnect"></a></h3><p>此事件由 Socket 实例在断开连接时触发。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...</span>  &#125;);&#125;);</code></pre></div><p>复制</p><p>以下是可能的原因列表：</p><table><thead><tr><th>Reason</th><th>Description</th></tr></thead><tbody><tr><td><code>server namespace disconnect</code></td><td>socket被<a href="https://socket.io/zh-CN/docs/v4/server-api/#socketdisconnectclose">socket.disconnect</a>强行断开</td></tr><tr><td><code>client namespace disconnect</code></td><td>客户端使用<a href="https://socket.io/zh-CN/docs/v4/client-api/#socketdisconnect">socket.disconnect()</a>手动断开socket</td></tr><tr><td><code>server shutting down</code></td><td>服务器正在关闭</td></tr><tr><td><code>ping timeout</code></td><td><code>pingTimeout</code> 客户端在延迟中没有发送 PONG 数据包</td></tr><tr><td><code>transport close</code></td><td>连接已关闭（例如：用户失去连接，或网络从 WiFi 更改为 4G）</td></tr><tr><td><code>transport error</code></td><td>连接遇到错误</td></tr></tbody></table><h3 id="disconnecting"><a href="#disconnecting" class="headerlink" title="disconnecting"></a><code>disconnecting</code><a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#disconnecting"></a></h3><p>当<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#socketrooms">Socket#rooms</a>集不为空时，此事件类似于<code>disconnect</code>但更早触发。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnecting&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> room <span class="hljs-keyword">of</span> socket.<span class="hljs-property">rooms</span>) &#123;      <span class="hljs-keyword">if</span> (room !== socket.<span class="hljs-property">id</span>) &#123;        socket.<span class="hljs-title function_">to</span>(room).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;user has left&quot;</span>, socket.<span class="hljs-property">id</span>);      &#125;    &#125;  &#125;);&#125;);</code></pre></div><p>注意：这些事件以及<code>connect</code>, <code>connect_error</code>, <code>newListener</code> 和 <code>removeListener</code>是不应在您的应用程序中使用的特殊事件:</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD, will throw an error</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;disconnect&quot;</span>);</code></pre></div><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>中间件函数是为每个传入连接执行的函数。</p><p>中间件函数可用于：</p><ul><li>logging</li><li>authentication / authorization</li><li>rate limiting</li></ul><p>Note: this function will be executed only once per connection (even if the connection consists in multiple HTTP requests).</p><h2 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h2><p>中间件函数可以访问<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/">Socket 实例</a>和下一个注册的中间件函数。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isValid</span>(socket.<span class="hljs-property">request</span>)) &#123;    <span class="hljs-title function_">next</span>();  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;invalid&quot;</span>));  &#125;&#125;);</code></pre></div><p>您可以注册几个中间件函数，它们将按顺序执行：</p><div class="code-wrapper"><pre><code class="hljs moonscript"><span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;  <span class="hljs-built_in">next</span>();&#125;);<span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;  <span class="hljs-built_in">next</span>(new Error(<span class="hljs-string">&quot;thou shall not pass&quot;</span>));//<span class="hljs-built_in">error</span>可以作为参数传递到下一层，其他不可以&#125;);<span class="hljs-built_in">io</span>.use(<span class="hljs-function"><span class="hljs-params">(socket, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;  // <span class="hljs-keyword">not</span> executed, since the previous middleware has returned an <span class="hljs-built_in">error</span>  <span class="hljs-built_in">next</span>();&#125;);</code></pre></div><p>请确保在任何情况下都调用<code>next（）</code>。 否则，连接将一直挂起，直到在给定超时后关闭。</p><p><strong>重要提示</strong>：执行中间件时，Socket 实例实际上并未连接，这意味着<code>disconnect</code>如果连接最终失败，则不会发出任何事件。</p><p>例如，如果客户端手动关闭连接：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// next is called after the client disconnection</span>    <span class="hljs-title function_">next</span>();  &#125;, <span class="hljs-number">1000</span>);  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// not triggered</span>  &#125;);&#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-comment">// not triggered</span>&#125;);<span class="hljs-comment">// client-side</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>();<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  socket.<span class="hljs-title function_">disconnect</span>();&#125;, <span class="hljs-number">500</span>);</code></pre></div><h2 id="发送凭据"><a href="#发送凭据" class="headerlink" title="发送凭据"></a>发送凭据</h2><p><code>auth</code>客户端可以使用以下选项发送凭据：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// plain object</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;  <span class="hljs-attr">auth</span>: &#123;    <span class="hljs-attr">token</span>: <span class="hljs-string">&quot;abc&quot;</span>  &#125;&#125;);<span class="hljs-comment">// or with a function</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;  <span class="hljs-attr">auth</span>: <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;    <span class="hljs-title function_">cb</span>(&#123;      <span class="hljs-attr">token</span>: <span class="hljs-string">&quot;abc&quot;</span>    &#125;);  &#125;&#125;);</code></pre></div><p>可以在服务器端的<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#sockethandshake">握手</a>对象中访问这些凭据：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> token = socket.<span class="hljs-property">handshake</span>.<span class="hljs-property">auth</span>.<span class="hljs-property">token</span>;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h2 id="处理中间件错误"><a href="#处理中间件错误" class="headerlink" title="处理中间件错误"></a>处理中间件错误</h2><p>如果<code>next</code>使用 Error 对象调用该方法，则连接将被拒绝并且客户端将收到一个<code>connect_error</code>事件。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// prints the message associated with the error</span>&#125;);</code></pre></div><p>您可以将其他详细信息附加到错误对象：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;not authorized&quot;</span>);  err.<span class="hljs-property">data</span> = &#123; <span class="hljs-attr">content</span>: <span class="hljs-string">&quot;Please retry later&quot;</span> &#125;; <span class="hljs-comment">// additional details</span>  <span class="hljs-title function_">next</span>(err);&#125;);<span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>); <span class="hljs-comment">// true</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>); <span class="hljs-comment">// not authorized</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">data</span>); <span class="hljs-comment">// &#123; content: &quot;Please retry later&quot; &#125;</span>&#125;);</code></pre></div><h2 id="与Express中间件的兼容性"><a href="#与Express中间件的兼容性" class="headerlink" title="与Express中间件的兼容性"></a>与Express中间件的兼容性</h2><p>大多数现有的<a href="http://expressjs.com/en/resources/middleware.html">Express 中间件</a>模块应该与 Socket.IO 兼容，您只需要一个小包装函数来使方法签名匹配：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = middleware =&gt; <span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> <span class="hljs-title function_">middleware</span>(socket.<span class="hljs-property">request</span>, &#123;&#125;, next);</code></pre></div><p>复制</p><p>结束请求-响应周期并且不调用的中间件函数<code>next()</code>将不起作用。</p><p><a href="https://www.npmjs.com/package/express-session">express-session</a>示例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(<span class="hljs-title function_">session</span>(&#123; <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;cats&quot;</span> &#125;)));io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> session = socket.<span class="hljs-property">request</span>.<span class="hljs-property">session</span>;&#125;);</code></pre></div><p><a href="http://www.passportjs.org/">Passport</a>示例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;express-session&quot;</span>);<span class="hljs-keyword">const</span> passport = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;passport&quot;</span>);io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(<span class="hljs-title function_">session</span>(&#123; <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;cats&quot;</span> &#125;)));io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(passport.<span class="hljs-title function_">initialize</span>()));io.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">wrap</span>(passport.<span class="hljs-title function_">session</span>()));io.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">socket, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">request</span>.<span class="hljs-property">user</span>) &#123;    <span class="hljs-title function_">next</span>();  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">next</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unauthorized&quot;</span>))  &#125;&#125;);</code></pre></div><p>可以在<a href="https://github.com/socketio/socket.io/tree/master/examples/passport-example">此处</a>找到 Passport 的完整示例。</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>您将在下面找到在反向代理解决方案后面部署 Socket.IO 服务器所需的配置，例如：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nginx">NginX</a></li><li><a href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#apache-httpd">Apache HTTPD</a></li><li><a href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nodejs-http-proxy">Node.js <code>http-proxy</code></a></li></ul><p>在多服务器设置中，请查看<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">此处</a>的文档。</p><h2 id="NginX"><a href="#NginX" class="headerlink" title="NginX"></a>NginX</h2><p><code>/etc/nginx/nginx.conf</code>内容：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;  <span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> example.com;    <span class="hljs-section">location</span> / &#123;      <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;      <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;      <span class="hljs-attribute">proxy_pass</span> http://localhost:3000;      <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;      <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;      <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;    &#125;  &#125;&#125;</code></pre></div><p>有关的：</p><ul><li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass">proxy_pass 稳定</a></li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#nginx-configuration">多服务器设置中的配置</a></li></ul><p>如果您只想转发 Socket.IO 请求（例如当 NginX 处理静态内容时）：</p><div class="code-wrapper"><pre><code class="hljs text">http &#123;  server &#123;    listen 80;    root /var/www/html;    location /socket.io/ &#123;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection &quot;upgrade&quot;;    &#125;  &#125;&#125;</code></pre></div><p>或使用自定义<a href="https://socket.io/zh-CN/docs/v4/server-options/#path">路径</a>:</p><div class="code-wrapper"><pre><code class="hljs text">http &#123;  server &#123;    listen 80;    root /var/www/html;    location /my-custom-path/ &#123;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection &quot;upgrade&quot;;    &#125;  &#125;&#125;</code></pre></div><p>在这种情况下，必须相应地配置服务器和客户端：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(&#123;  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/my-custom-path/&quot;</span>&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/my-custom-path/&quot;</span>&#125;);</code></pre></div><h2 id="Apache-HTTPD"><a href="#Apache-HTTPD" class="headerlink" title="Apache HTTPD"></a>Apache HTTPD</h2><p><code>/usr/local/apache2/conf/httpd.conf</code>内容：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Listen</span> <span class="hljs-number">80</span><span class="hljs-attribute">ServerName</span> example.com<span class="hljs-attribute">LoadModule</span> mpm_event_module             modules/mod_mpm_event.so<span class="hljs-attribute">LoadModule</span> authn_file_module            modules/mod_authn_file.so<span class="hljs-attribute">LoadModule</span> authn_core_module            modules/mod_authn_core.so<span class="hljs-attribute">LoadModule</span> authz_host_module            modules/mod_authz_host.so<span class="hljs-attribute">LoadModule</span> authz_groupfile_module       modules/mod_authz_groupfile.so<span class="hljs-attribute">LoadModule</span> authz_user_module            modules/mod_authz_user.so<span class="hljs-attribute">LoadModule</span> authz_core_module            modules/mod_authz_core.so<span class="hljs-attribute">LoadModule</span> headers_module               modules/mod_headers.so<span class="hljs-attribute">LoadModule</span> lbmethod_byrequests_module   modules/mod_lbmethod_byrequests.so<span class="hljs-attribute">LoadModule</span> proxy_module                 modules/mod_proxy.so<span class="hljs-attribute">LoadModule</span> proxy_balancer_module        modules/mod_proxy_balancer.so<span class="hljs-attribute">LoadModule</span> proxy_http_module            modules/mod_proxy_http.so<span class="hljs-attribute">LoadModule</span> proxy_wstunnel_module        modules/mod_proxy_wstunnel.so<span class="hljs-attribute">LoadModule</span> rewrite_module               modules/mod_rewrite.so<span class="hljs-attribute">LoadModule</span> slotmem_shm_module           modules/mod_slotmem_shm.so<span class="hljs-attribute">LoadModule</span> unixd_module                 modules/mod_unixd.so<span class="hljs-attribute">User</span> daemon<span class="hljs-attribute">Group</span> daemon<span class="hljs-attribute">ProxyPass</span> / http://localhost:<span class="hljs-number">3000</span>/<span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">on</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> websocket<span class="hljs-meta"> [NC]</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Connection&#125;</span> upgrade<span class="hljs-meta"> [NC]</span><span class="hljs-attribute">RewriteRule</span> ^/?(.*) <span class="hljs-string">&quot;ws://localhost:3000/$1&quot;</span><span class="hljs-meta"> [P,L]</span><span class="hljs-attribute">ProxyTimeout</span> <span class="hljs-number">3</span></code></pre></div><p>有关的：</p><ul><li><a href="https://httpd.apache.org/docs/2.4/en/mod/mod_proxy_wstunnel.html">mod_proxy_wstunnel 文档</a></li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration">多服务器设置中的配置</a></li></ul><h2 id="Node-js-http-proxy"><a href="#Node-js-http-proxy" class="headerlink" title="Node.js http-proxy"></a>Node.js <code>http-proxy</code><a href="https://socket.io/zh-CN/docs/v4/reverse-proxy/#nodejs-http-proxy"></a></h2><p>安装： <code>npm i http-proxy</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> httpProxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http-proxy&quot;</span>);httpProxy  .<span class="hljs-title function_">createProxyServer</span>(&#123;    <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,    <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>,  &#125;)  .<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>);</code></pre></div><p>复制</p><p><a href="https://github.com/http-party/node-http-proxy#readme">Documentation</a></p><h2 id="Caddy-2"><a href="#Caddy-2" class="headerlink" title="Caddy 2"></a>Caddy 2</h2><p><a href="https://caddyserver.com/v2">Caddy 2</a>中<code>Caddyfile</code>的内容</p><div class="code-wrapper"><pre><code class="hljs text">example.com &#123;  rewrite /path /path/  handle /path/* &#123;    uri strip_prefix /path    rewrite * /socket.io&#123;path&#125;    reverse_proxy localhost:3000 &#123;      header_up Host &#123;host&#125;      header_up X-Real-IP &#123;remote&#125;    &#125;  &#125;&#125;</code></pre></div><p>有关的：</p><ul><li><a href="https://caddy.community/t/i-cant-get-socket-io-proxy-to-work-on-v2/8703/2">解决方案论坛帖子</a></li><li><a href="https://caddyserver.com/docs/caddyfile/directives">Caddyfile 指令</a></li></ul><h1 id="使用多个节点"><a href="#使用多个节点" class="headerlink" title="使用多个节点"></a>使用多个节点</h1><p>部署多个 Socket.IO 服务器时，需要注意两件事：</p><ul><li>如果启用了 HTTP 长轮询（这是默认设置），则启用粘性会话：见<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#enabling-sticky-session">下文</a></li><li>使用兼容的适配器，请参见<a href="https://socket.io/zh-CN/docs/v4/adapter/">此处</a></li></ul><h2 id="粘性负载平衡"><a href="#粘性负载平衡" class="headerlink" title="粘性负载平衡"></a>粘性负载平衡</h2><p>如果您计划在不同的进程或机器之间分配连接负载，则必须确保与特定会话 ID 关联的所有请求都到达发起它们的进程。</p><h3 id="为什么需要粘性会话"><a href="#为什么需要粘性会话" class="headerlink" title="为什么需要粘性会话"></a>为什么需要粘性会话</h3><p>这是因为 HTTP 长轮询传输在 Socket.IO 会话的生命周期内发送多个 HTTP 请求。</p><p>事实上，Socket.IO 在技术上可以在没有粘性会话的情况下工作，具有以下同步（虚线）：</p><p><img src="https://socket.io/zh-CN/assets/images/mutiple-nodes-no-sticky-babd7860f217e09eefc2db73e5012f91.png" alt="Using multiple nodes without sticky sessions"></p><p>虽然显然可以实现，但我们认为 Socket.IO 服务器之间的这种同步过程会对您的应用程序造成很大的性能影响。</p><p>评论：</p><ul><li>如果不启用粘性会话，由于“会话 ID 未知”，您将遇到 HTTP 400 错误</li><li>WebSocket 传输没有这个限制，因为它依赖于整个会话的单个 TCP 连接。这意味着如果您禁用 HTTP 长轮询传输，您将不需要粘性会话：</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://io.yourhost.com&quot;</span>, &#123;  <span class="hljs-comment">// WARNING: in that case, there is no fallback to long-polling</span>  <span class="hljs-attr">transports</span>: [ <span class="hljs-string">&quot;websocket&quot;</span> ] <span class="hljs-comment">// or [ &quot;websocket&quot;, &quot;polling&quot; ] (the order matters)</span>&#125;);</code></pre></div><p>文档：<a href="https://socket.io/zh-CN/docs/v4/client-options/#transports"><code>transports</code></a></p><h3 id="启用粘性会话的方式"><a href="#启用粘性会话的方式" class="headerlink" title="启用粘性会话的方式"></a>启用粘性会话的方式</h3><p>要实现粘性会话，主要有两种解决方案：</p><ul><li>基于 cookie 路由客户端（推荐解决方案）</li><li>根据客户端的原始地址路由客户端</li></ul><p>您将在下面找到一些常见负载平衡解决方案的示例：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#nginx-configuration">NginX</a> (基于IP)</li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration">Apache HTTPD</a> (基于cookie)</li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#haproxy-configuration">HAProxy</a> (基于cookie)</li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#traefik">Traefik</a> (基于cookie)</li><li><a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#using-nodejs-cluster">Node.js <code>cluster</code> module</a></li></ul><p><strong>重要提示</strong>：如果您处于 CORS 情况（前端域与服务器域不同）并且会话亲和性是通过 cookie 实现的，则需要允许凭据：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>)(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://front-domain.com&quot;</span>,    <span class="hljs-attr">methods</span>: [<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>],    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>  &#125;&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io-client&quot;</span>);<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>, &#123;  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>&#125;);</code></pre></div><p>没有它，浏览器将不会发送 cookie，您将遇到 HTTP 400“会话 ID 未知”响应。更多信息<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">在这里</a>.</p><h3 id="NginX-配置"><a href="#NginX-配置" class="headerlink" title="NginX 配置"></a>NginX 配置</h3><p>在文件的<code>http &#123; &#125;</code>部分中<code>nginx.conf</code>，您可以声明一个<code>upstream</code>包含要平衡负载的 Socket.IO 进程列表的部分：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;  <span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">3000</span>;    <span class="hljs-attribute">server_name</span> io.yourhost.com;    <span class="hljs-section">location</span> / &#123;      <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;      <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;      <span class="hljs-attribute">proxy_pass</span> http://nodes;      <span class="hljs-comment"># enable WebSockets</span>      <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;      <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;      <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;    &#125;  &#125;  <span class="hljs-section">upstream</span> nodes &#123;    <span class="hljs-comment"># enable sticky session with either &quot;hash&quot; (uses the complete IP address)</span>    <span class="hljs-attribute">hash</span> <span class="hljs-variable">$remote_addr</span> consistent;    <span class="hljs-comment"># or &quot;ip_hash&quot; (uses the first three octets of the client IPv4 address, or the entire IPv6 address)</span>    <span class="hljs-comment"># ip_hash;</span>    <span class="hljs-comment"># or &quot;sticky&quot; (needs commercial subscription)</span>    <span class="hljs-comment"># sticky cookie srv_id expires=1h domain=.example.com path=/;</span>    <span class="hljs-attribute">server</span> app01:<span class="hljs-number">3000</span>;    <span class="hljs-attribute">server</span> app02:<span class="hljs-number">3000</span>;    <span class="hljs-attribute">server</span> app03:<span class="hljs-number">3000</span>;  &#125;&#125;</code></pre></div><p>请注意<code>hash</code>指示连接将是粘性的说明。</p><p>确保您还在<code>worker_processes</code>最顶层配置以指示 NginX 应该使用多少工作人员。您可能还想研究调整块<code>worker_connections</code>内的设置<code>events &#123; &#125;</code>。</p><h3 id="Apache-HTTPD-配置"><a href="#Apache-HTTPD-配置" class="headerlink" title="Apache HTTPD 配置"></a>Apache HTTPD 配置<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/#apache-httpd-configuration"></a></h3><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Header</span> add Set-Cookie <span class="hljs-string">&quot;SERVERID=sticky.%&#123;BALANCER_WORKER_ROUTE&#125;e; path=/&quot;</span> env=BALANCER_ROUTE_CHANGED<span class="hljs-section">&lt;Proxy <span class="hljs-string">&quot;balancer://nodes_polling&quot;</span>&gt;</span>    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app01:3000&quot;</span> route=app01    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app02:3000&quot;</span> route=app02    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;http://app03:3000&quot;</span> route=app03    <span class="hljs-attribute">ProxySet</span> stickysession=SERVERID<span class="hljs-section">&lt;/Proxy&gt;</span><span class="hljs-section">&lt;Proxy <span class="hljs-string">&quot;balancer://nodes_ws&quot;</span>&gt;</span>    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app01:3000&quot;</span> route=app01    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app02:3000&quot;</span> route=app02    <span class="hljs-attribute">BalancerMember</span> <span class="hljs-string">&quot;ws://app03:3000&quot;</span> route=app03    <span class="hljs-attribute">ProxySet</span> stickysession=SERVERID<span class="hljs-section">&lt;/Proxy&gt;</span><span class="hljs-attribute">RewriteEngine</span> <span class="hljs-literal">On</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> =websocket<span class="hljs-meta"> [NC]</span><span class="hljs-attribute">RewriteRule</span> /(.*) balancer://nodes_ws/$<span class="hljs-number">1</span><span class="hljs-meta"> [P,L]</span><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;HTTP:Upgrade&#125;</span> !=websocket<span class="hljs-meta"> [NC]</span><span class="hljs-attribute">RewriteRule</span> /(.*) balancer://nodes_polling/$<span class="hljs-number">1</span><span class="hljs-meta"> [P,L]</span><span class="hljs-attribute">ProxyTimeout</span> <span class="hljs-number">3</span></code></pre></div><p>链接：</p><ul><li><a href="https://github.com/socketio/socket.io/tree/master/examples/cluster-httpd">例子</a></li><li><a href="https://httpd.apache.org/docs/2.4/en/mod/mod_proxy.html#proxypass">文档</a></li></ul><h3 id="HAProxy-配置"><a href="#HAProxy-配置" class="headerlink" title="HAProxy 配置"></a>HAProxy 配置</h3><div class="code-wrapper"><pre><code class="hljs text"># Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/listen chat  bind *:80  default_backend nodesbackend nodes  option httpchk HEAD /health  http-check expect status 200  cookie io prefix indirect nocache # using the `io` cookie set upon handshake  server app01 app01:3000 check cookie app01  server app02 app02:3000 check cookie app02  server app03 app03:3000 check cookie app03</code></pre></div><p>链接：</p><ul><li><a href="https://github.com/socketio/socket.io/tree/master/examples/cluster-haproxy">例子</a></li><li><a href="http://cbonte.github.io/haproxy-dconv/2.4/configuration.html#cookie">文档</a></li></ul><h3 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h3><p>使用容器标签：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># docker-compose.yml</span><span class="hljs-attr">services:</span>  <span class="hljs-attr">traefik:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">traefik:2.4</span>    <span class="hljs-attr">volumes:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span>    <span class="hljs-attr">links:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">server</span>  <span class="hljs-attr">server:</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">my-image:latest</span>    <span class="hljs-attr">labels:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.http.routers.my-service.rule=PathPrefix(`/`)&quot;</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true</span></code></pre></div><p>使用<a href="https://doc.traefik.io/traefik/v2.0/providers/file/">文件提供程序</a>：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">## Dynamic configuration</span><span class="hljs-attr">http:</span>  <span class="hljs-attr">services:</span>    <span class="hljs-attr">my-service:</span>      <span class="hljs-attr">rule:</span> <span class="hljs-string">&quot;PathPrefix(`/`)&quot;</span>      <span class="hljs-attr">loadBalancer:</span>        <span class="hljs-attr">sticky:</span>          <span class="hljs-attr">cookie:</span>            <span class="hljs-attr">name:</span> <span class="hljs-string">server_id</span>            <span class="hljs-attr">httpOnly:</span> <span class="hljs-literal">true</span></code></pre></div><p>链接：</p><ul><li><a href="https://github.com/socketio/socket.io/tree/master/examples/cluster-traefik">例子</a></li><li><a href="https://doc.traefik.io/traefik/v2.0/routing/services/#sticky-sessions">文档</a></li></ul><h3 id="使用-Node-js-集群"><a href="#使用-Node-js-集群" class="headerlink" title="使用 Node.js 集群"></a>使用 Node.js 集群</h3><p>就像 NginX 一样，Node.js 通过<code>cluster</code>模块提供了内置的集群支持。</p><p>有几种解决方案，具体取决于您的用例：</p><table><thead><tr><th>NPM 包</th><th>这个怎么运作</th></tr></thead><tbody><tr><td><a href="https://github.com/darrachequesne/socket.io-sticky"><code>@socket.io/sticky</code></a></td><td>路由基于<code>sid</code>查询参数</td></tr><tr><td><a href="https://github.com/indutny/sticky-session"><code>sticky-session</code></a></td><td>路由是基于<code>connection.remoteAddress</code></td></tr><tr><td><a href="https://github.com/wzrdtales/socket-io-sticky-session"><code>socketio-sticky-session</code></a></td><td>基于<code>x-forwarded-for</code>报头的路由）</td></tr></tbody></table><p>示例<code>@socket.io/sticky</code>:</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cluster&quot;</span>);<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Server</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;socket.io&quot;</span>);<span class="hljs-keyword">const</span> numCPUs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;os&quot;</span>).<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> &#123; setupMaster, setupWorker &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/sticky&quot;</span>);<span class="hljs-keyword">const</span> &#123; createAdapter, setupPrimary &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@socket.io/cluster-adapter&quot;</span>);<span class="hljs-keyword">if</span> (cluster.<span class="hljs-property">isMaster</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Master <span class="hljs-subst">$&#123;process.pid&#125;</span> is running`</span>);  <span class="hljs-keyword">const</span> httpServer = http.<span class="hljs-title function_">createServer</span>();  <span class="hljs-comment">// setup sticky sessions</span>  <span class="hljs-title function_">setupMaster</span>(httpServer, &#123;    <span class="hljs-attr">loadBalancingMethod</span>: <span class="hljs-string">&quot;least-connection&quot;</span>,  &#125;);  <span class="hljs-comment">// setup connections between the workers</span>  <span class="hljs-title function_">setupPrimary</span>();  <span class="hljs-comment">// needed for packets containing buffers (you can ignore it if you only send plaintext objects)</span>  <span class="hljs-comment">// Node.js &lt; 16.0.0</span>  cluster.<span class="hljs-title function_">setupMaster</span>(&#123;    <span class="hljs-attr">serialization</span>: <span class="hljs-string">&quot;advanced&quot;</span>,  &#125;);  <span class="hljs-comment">// Node.js &gt; 16.0.0</span>  <span class="hljs-comment">// cluster.setupPrimary(&#123;</span>  <span class="hljs-comment">//   serialization: &quot;advanced&quot;,</span>  <span class="hljs-comment">// &#125;);</span>  httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numCPUs; i++) &#123;    cluster.<span class="hljs-title function_">fork</span>();  &#125;  cluster.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-function">(<span class="hljs-params">worker</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Worker <span class="hljs-subst">$&#123;worker.process.pid&#125;</span> died`</span>);    cluster.<span class="hljs-title function_">fork</span>();  &#125;);&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Worker <span class="hljs-subst">$&#123;process.pid&#125;</span> started`</span>);  <span class="hljs-keyword">const</span> httpServer = http.<span class="hljs-title function_">createServer</span>();  <span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer);  <span class="hljs-comment">// use the cluster adapter</span>  io.<span class="hljs-title function_">adapter</span>(<span class="hljs-title function_">createAdapter</span>());  <span class="hljs-comment">// setup connection with the primary process</span>  <span class="hljs-title function_">setupWorker</span>(io);  io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;    <span class="hljs-comment">/* ... */</span>  &#125;);&#125;</code></pre></div><h2 id="在节点之间传递事件"><a href="#在节点之间传递事件" class="headerlink" title="在节点之间传递事件"></a>在节点之间传递事件</h2><p>既然您有多个接受连接的Socket.IO 节点，如果您想向所有客户端（或某个<a href="https://socket.io/zh-CN/docs/v4/rooms/">房间</a>中的客户端）广播事件，您将需要某种方式在进程或计算机之间传递消息。</p><p>负责路由消息的接口就是我们所说的<a href="https://socket.io/zh-CN/docs/v4/adapter/">Adapter</a>。</p><h1 id="处理-CORS"><a href="#处理-CORS" class="headerlink" title="处理 CORS"></a>处理 CORS</h1><p>从 Socket.IO v3 开始，您需要显式启用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">跨域资源共享</a>(CORS)。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://example.com&quot;</span>  &#125;&#125;);</code></pre></div><p>所有选项都将转发到<a href="https://www.npmjs.com/package/cors">cors</a>包。可以在<a href="https://github.com/expressjs/cors#configuration-options">此处</a>找到完整的选项列表。</p><p>带有 cookie ( <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">withCredentials</a>) 和附加标头的示例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span><span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://example.com&quot;</span>,    <span class="hljs-attr">allowedHeaders</span>: [<span class="hljs-string">&quot;my-custom-header&quot;</span>],    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>  &#125;&#125;);<span class="hljs-comment">// client-side</span><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://api.example.com&quot;</span>, &#123;  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">extraHeaders</span>: &#123;    <span class="hljs-string">&quot;my-custom-header&quot;</span>: <span class="hljs-string">&quot;abcd&quot;</span>  &#125;&#125;);</code></pre></div><p>注意：如果您的 Web 应用程序和服务器不是从同一个端口提供服务，这也适用于 localhost</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;http://localhost:8080&quot;</span>  &#125;&#125;);httpServer.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);</code></pre></div><p>您可以使用以下选项禁止所有跨域请求<a href="https://socket.io/zh-CN/docs/v4/server-options/#allowrequest"><code>allowRequest</code></a> option:</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">allowRequest</span>: <span class="hljs-function">(<span class="hljs-params">req, callback</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> noOriginHeader = req.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span> === <span class="hljs-literal">undefined</span>;    <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, noOriginHeader);  &#125;&#125;);</code></pre></div><h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#troubleshooting"></a></h2><h3 id="缺少-CORS-标头“Access-Control-Allow-Origin”"><a href="#缺少-CORS-标头“Access-Control-Allow-Origin”" class="headerlink" title="缺少 CORS 标头“Access-Control-Allow-Origin”"></a>缺少 CORS 标头“Access-Control-Allow-Origin”<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#cors-header-access-control-allow-origin-missing"></a></h3><p>完整的错误信息：</p><blockquote><p><em>跨域请求被阻止：同源策略不允许读取位于 …/socket.io/?EIO=4&amp;transport=polling&amp;t=NMnp2WI 的远程资源。（原因：缺少 CORS 标头“Access-Control-Allow-Origin”）。</em></p></blockquote><p>如果您已正确配置您的服务器（见<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#configuration">上文</a>），这可能意味着您的浏览器无法访问 Socket.IO 服务器。</p><p>以下命令：</p><div class="code-wrapper"><pre><code class="hljs text">curl &quot;https://api.example.com/socket.io/?EIO=4&amp;transport=polling&quot;</code></pre></div><p>应该返回类似：</p><div class="code-wrapper"><pre><code class="hljs text">0&#123;&quot;sid&quot;:&quot;Lbo5JLzTotvW3g2LAAAA&quot;,&quot;upgrades&quot;:[&quot;websocket&quot;],&quot;pingInterval&quot;:25000,&quot;pingTimeout&quot;:20000&#125;</code></pre></div><p>如果不是这种情况，请检查您的服务器是否正在侦听并且实际上可以在给定端口上访问。</p><h3 id="如果-CORS-标头“Access-Control-Allow-Origin”为“-”，则不支持凭据"><a href="#如果-CORS-标头“Access-Control-Allow-Origin”为“-”，则不支持凭据" class="headerlink" title="如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭据"></a>如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭据<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#credential-is-not-supported-if-the-cors-header-access-control-allow-origin-is-"></a></h3><p>完整的错误信息：</p><blockquote><p><em>跨域请求被阻止：同源策略不允许读取位于“…/socket.io/?EIO=4&amp;transport=polling&amp;t=NvQfU77”的远程资源。（原因：如果 CORS 标头“Access-Control-Allow-Origin”为“*”，则不支持凭证）</em></p></blockquote><p>您不能同时设置<a href="https://socket.io/zh-CN/docs/v4/client-options/#withcredentials"><code>withCredentials</code></a> 为 <code>true</code> 和 <code>origin: *</code>，您需要使用特定的来源：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createServer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;http&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Server</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io&quot;</span>;<span class="hljs-keyword">const</span> httpServer = <span class="hljs-title function_">createServer</span>();<span class="hljs-keyword">const</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(httpServer, &#123;  <span class="hljs-attr">cors</span>: &#123;    <span class="hljs-attr">origin</span>: <span class="hljs-string">&quot;https://my-frontend.com&quot;</span>,    <span class="hljs-comment">// or with an array of origins</span>    <span class="hljs-comment">// origin: [&quot;https://my-frontend.com&quot;, &quot;https://my-other-frontend.com&quot;, &quot;http://localhost:3000&quot;],</span>    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>  &#125;&#125;);</code></pre></div><h3 id="CORS-标头“Access-Control-Allow-Credentials”中预期为“true”"><a href="#CORS-标头“Access-Control-Allow-Credentials”中预期为“true”" class="headerlink" title="CORS 标头“Access-Control-Allow-Credentials”中预期为“true”"></a>CORS 标头“Access-Control-Allow-Credentials”中预期为“true”<a href="https://socket.io/zh-CN/docs/v4/handling-cors/#expected-true-in-cors-header-access-control-allow-credentials"></a></h3><p>完整的错误信息：</p><blockquote><p><em>跨域请求被阻止：同源策略不允许读取位于 …/socket.io/?EIO=4&amp;transport=polling&amp;t=NvQny19 的远程资源。（原因：CORS 标头“Access-Control-Allow-Credentials”中预期为“true”）</em></p></blockquote><p>在这种情况下，在客户端上<a href="https://socket.io/zh-CN/docs/v4/client-options/#withcredentials"><code>withCredentials</code></a>设置为<code>true</code>，但服务器缺少选项<code>credentials</code>中的属性<a href="https://socket.io/zh-CN/docs/v4/server-options/#cors"><code>cors</code></a> 。请参见上面的示例。</p><h1 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h1><p>在下面的示例中，<code>io</code>对象来自：</p><ul><li>使用 <code>&lt;script&gt;</code> 引入</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>复制</p><ul><li>使用 ESM 引入</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://cdn.socket.io/4.3.2/socket.io.esm.min.js&quot;</span>;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>复制</p><ul><li>NPM</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; io &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;socket.io-client&quot;</span>;</code></pre></div><h2 id="来自同一域"><a href="#来自同一域" class="headerlink" title="来自同一域"></a>来自同一域<a href="https://socket.io/zh-CN/docs/v4/client-initialization/#from-the-same-domain"></a></h2><p>如果您的前端与您的服务器在同一个域上提供服务，您可以简单地使用：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>();</code></pre></div><p>服务器 URL 将从 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location">window.location</a>对象中推导出来</p><h2 id="来自不同的域"><a href="#来自不同的域" class="headerlink" title="来自不同的域"></a>来自不同的域<a href="https://socket.io/zh-CN/docs/v4/client-initialization/#from-a-different-domain"></a></h2><p>如果您的前端不是来自与服务器相同的域，则必须传递服务器的 URL。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>);</code></pre></div><p>在这种情况下，请确保在服务器上启用 <a href="https://socket.io/zh-CN/docs/v4/handling-cors/">跨域资源共享 (CORS)</a>。</p><h5 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h5><p>您可以使用<code>https</code> 或 <code>wss</code> (分别为, <code>http</code> 或 <code>ws</code>).</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// the following forms are similar</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com&quot;</span>);<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;wss://server-domain.com&quot;</span>);<span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;server-domain.com&quot;</span>); <span class="hljs-comment">// only in the browser when the page is served over https (will not work in Node.js)</span></code></pre></div><h2 id="自定义命名空间"><a href="#自定义命名空间" class="headerlink" title="自定义命名空间"></a>自定义命名空间<a href="https://socket.io/zh-CN/docs/v4/client-initialization/#custom-namespace"></a></h2><p>在上面的示例中，客户端将连接到主命名空间。对于大多数用例来说，仅使用主命名空间就足够了，但您可以使用以下命令指定命名空间：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// same origin version</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;/admin&quot;</span>);<span class="hljs-comment">// cross origin version</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&quot;https://server-domain.com/admin&quot;</span>);</code></pre></div><p>您可以<a href="https://socket.io/zh-CN/docs/v4/namespaces/">在此处</a>找到有关名称空间的更多详细信息。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置<a href="https://socket.io/zh-CN/docs/v4/client-initialization/#options"></a></h2><p>可在<a href="https://socket.io/zh-CN/docs/v4/client-options/">此处</a>找到可用配置的完整列表</p><h1 id="Socket-实例（客户端）"><a href="#Socket-实例（客户端）" class="headerlink" title="Socket 实例（客户端）"></a>Socket 实例（客户端）</h1><p><code>Socket</code>是与服务器交互的基础类。它继承了 Node.js<a href="https://nodejs.org/api/events.html#class-eventemitter">EventEmitter</a>的大部分方法，例如 <a href="https://socket.io/zh-CN/docs/v4/client-api/#socketemiteventname-args">emit</a>, <a href="https://socket.io/zh-CN/docs/v4/client-api/#socketoneventname-callback">on</a>, <a href="https://socket.io/zh-CN/docs/v4/client-api/#socketonceeventname-callback">once</a> 或 <a href="https://socket.io/zh-CN/docs/v4/client-api/#socketoffeventname">off</a>。</p><p><img src="https://socket.io/zh-CN/images/bidirectional-communication-socket.png" alt="Bidirectional communication between server and client"></p><p>除了<a href="https://socket.io/zh-CN/docs/v4/emitting-events/">emitting</a> 和 <a href="https://socket.io/zh-CN/docs/v4/listening-to-events/">listening to</a>事件之外，Socket 实例还有一些可能在您的应用程序中使用的属性：</p><h2 id="Socket-id-1"><a href="#Socket-id-1" class="headerlink" title="Socket#id"></a>Socket#id<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketid"></a></h2><p>每个新连接都分配有一个随机的 20 个字符的标识符。</p><p>此标识符与服务器端的值同步。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// server-side</span>io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// x8WIv7-mJelg7on_ALbx</span>&#125;);<span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// x8WIv7-mJelg7on_ALbx</span>&#125;);socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">id</span>); <span class="hljs-comment">// undefined</span>&#125;);</code></pre></div><h2 id="Socket-connected"><a href="#Socket-connected" class="headerlink" title="Socket#connected"></a>Socket#connected<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketconnected"></a></h2><p>该属性描述套接字当前是否连接到服务器。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">connected</span>); <span class="hljs-comment">// true</span>&#125;);socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">connected</span>); <span class="hljs-comment">// false</span>&#125;);</code></pre></div><h2 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket#io"></a>Socket#io<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketio"></a></h2><p>对基础<a href="https://socket.io/zh-CN/docs/v4/client-api/#manager">Manager</a>的引用。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> engine = socket.<span class="hljs-property">io</span>.<span class="hljs-property">engine</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(engine.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// in most cases, prints &quot;polling&quot;</span>  engine.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;upgrade&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(engine.<span class="hljs-property">transport</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// in most cases, prints &quot;websocket&quot;</span>  &#125;);  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packet&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called for each packet received</span>  &#125;);  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;packetCreate&quot;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; type, data &#125;</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called for each packet sent</span>  &#125;);  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;drain&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// called when the write buffer is drained</span>  &#125;);  engine.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;    <span class="hljs-comment">// called when the underlying connection is closed</span>  &#125;);&#125;);</code></pre></div><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#lifecycle"></a></h2><p><img src="https://socket.io/images/client_socket_events.png" alt="Lifecycle diagram"></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#events"></a></h2><p>Socket 实例发出三个特殊事件：</p><ul><li><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect"><code>connect</code></a></li><li><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect-error"><code>connect_error</code></a></li><li><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#disconnect"><code>disconnect</code></a></li></ul><p>请注意，从 Socket.IO v3 开始，Socket 实例不再发出任何与重新连接逻辑相关的事件。您可以直接监听 Manager 实例上的事件：</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;reconnect_attempt&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);socket.<span class="hljs-property">io</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;reconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><p>更多信息可以在<a href="https://socket.io/zh-CN/docs/v4/migrating-from-2-x-to-3-0/#the-socket-instance-will-no-longer-forward-the-events-emitted-by-its-manager">迁移指南</a>中找到</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a><code>connect</code><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect"></a></h3><p>此事件由 Socket 实例在连接<strong>和</strong>重新连接时触发。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><p>请注意，您不应在<code>connect</code>处理程序本身中注册事件处理程序，因为每次 Socket 重新连接时都会注册一个新的处理程序：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;);&#125;);<span class="hljs-comment">// GOOD</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;);</code></pre></div><h3 id="connect-error"><a href="#connect-error" class="headerlink" title="connect_error"></a><code>connect_error</code><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#connect_error"></a></h3><p>在以下情况下触发此事件：</p><ul><li>低级连接无法建立</li><li>服务器在<a href="https://socket.io/zh-CN/docs/v4/middlewares/">中间件功能</a>中拒绝连接</li></ul><p>在第一种情况下，Socket 会在 <a href="https://socket.io/zh-CN/docs/v4/client-options/#reconnectiondelay">给定的延迟</a>之后自动尝试重新连接。</p><p>在后一种情况下，您需要手动重新连接。您可能需要更新凭据：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// either by directly modifying the `auth` attribute</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  socket.<span class="hljs-property">auth</span>.<span class="hljs-property">token</span> = <span class="hljs-string">&quot;abcd&quot;</span>;  socket.<span class="hljs-title function_">connect</span>();&#125;);<span class="hljs-comment">// or if the `auth` attribute is a function</span><span class="hljs-keyword">const</span> socket = <span class="hljs-title function_">io</span>(&#123;  <span class="hljs-attr">auth</span>: <span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;    <span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>));  &#125;&#125;);socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connect_error&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    socket.<span class="hljs-title function_">connect</span>();  &#125;, <span class="hljs-number">1000</span>);&#125;);</code></pre></div><h3 id="disconnect-1"><a href="#disconnect-1" class="headerlink" title="disconnect"></a><code>disconnect</code><a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#disconnect"></a></h3><p>此事件在断开连接时触发。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><p>复制</p><p>以下是可能的原因列表：</p><table><thead><tr><th>Reason</th><th>Description</th></tr></thead><tbody><tr><td><code>io server disconnect</code></td><td>服务器已使用<a href="https://socket.io/zh-CN/docs/v4/server-api/#socketdisconnectclose">socket.disconnect()</a>强制断开socket</td></tr><tr><td><code>io client disconnect</code></td><td>使用<a href="https://socket.io/zh-CN/docs/v4/client-api/#socketdisconnect">socket.disconnect()</a>手动断开socket</td></tr><tr><td><code>ping timeout</code></td><td>服务器未在该<code>pingInterval + pingTimeout</code>范围内发送 PING</td></tr><tr><td><code>transport close</code></td><td>连接已关闭（例如：用户失去连接，或网络从 WiFi 更改为 4G）</td></tr><tr><td><code>transport error</code></td><td>连接遇到错误（例如：服务器在 HTTP 长轮询周期中被杀死）</td></tr></tbody></table><p>前两种情况（显式断开），客户端不会尝试重新连接，需要手动调用<code>socket.connect()</code>.</p><p>在所有其他情况下，客户端将等待一个小的<a href="https://socket.io/zh-CN/docs/v4/client-options/#reconnectiondelay">随机延迟</a>，然后尝试重新连接：</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (reason === <span class="hljs-string">&quot;io server disconnect&quot;</span>) &#123;    <span class="hljs-comment">// the disconnection was initiated by the server, you need to reconnect manually</span>    socket.<span class="hljs-title function_">connect</span>();<span class="hljs-comment">//服务器断开的，需要手动执行重连</span>  &#125;  <span class="hljs-comment">// else the socket will automatically try to reconnect</span>&#125;);</code></pre></div><p>注意：这些事件以及<code>disconnecting</code>, <code>newListener</code> 和 <code>removeListener</code>是不应在您的应用程序中使用的特殊事件：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD, will throw an error</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;disconnect&quot;</span>);</code></pre></div><h1 id="离线行为"><a href="#离线行为" class="headerlink" title="离线行为"></a>离线行为</h1><h2 id="缓冲事件"><a href="#缓冲事件" class="headerlink" title="缓冲事件"></a>缓冲事件<a href="https://socket.io/zh-CN/docs/v4/client-offline-behavior/#buffered-events"></a></h2><p>默认情况下，在 Socket 未连接时发出的任何事件都将被缓冲，直到重新连接。</p><p>虽然在大多数情况下很有用（当重新连接延迟很短时），但它可能会在连接恢复时导致大量事件。</p><p>有几种解决方案可以防止这种行为，具体取决于您的用例：</p><ul><li>使用Socket 实例的<a href="https://socket.io/zh-CN/docs/v4/client-socket-instance/#socketconnected">connected 属性</a> attribute of the Socket instance</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (socket.<span class="hljs-property">connected</span>) &#123;  socket.<span class="hljs-title function_">emit</span>( <span class="hljs-comment">/* ... */</span> );&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// ...</span>&#125;</code></pre></div><ul><li>使用 <a href="https://socket.io/zh-CN/docs/v4/emitting-events/#volatile-events">volatile 事件</a></li></ul><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>( <span class="hljs-comment">/* ... */</span> );</code></pre></div><h1 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h1><p>有几种方法可以在服务器和客户端之间发送事件。</p><h2 id="基本的-emit"><a href="#基本的-emit" class="headerlink" title="基本的 emit"></a>基本的 emit<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E5%9F%BA%E6%9C%AC%E7%9A%84-emit"></a></h2><p>Socket.IO API 的灵感来自 Node.js <a href="https://nodejs.org/docs/latest/api/events.html#events_events">EventEmitter</a>，这意味着您可以在一侧发出事件并在另一侧注册侦听器：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// world</span>&#125;);</code></pre></div><p>这也适用于另一个方向：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg); <span class="hljs-comment">// world</span>  &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div><p>您可以发送任意数量的参数，并且支持所有可序列化的数据结构，包括像<a href="https://nodejs.org/docs/latest/api/buffer.html#buffer_buffer">Buffer</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">TypedArray</a>这样的二进制对象。</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, &#123; <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">5</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">6</span>]) &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// client-side</span>socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1, arg2, arg3</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// 1</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg2); <span class="hljs-comment">// &quot;2&quot;</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg3); <span class="hljs-comment">// &#123; 3: &#x27;4&#x27;, 5: ArrayBuffer (1) [ 6 ] &#125;</span>&#125;);</code></pre></div><p>无需<code>JSON.stringify()</code>，因为它会为您完成。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// BAD</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;));<span class="hljs-comment">// GOOD</span>socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;);</code></pre></div><p>笔记：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a>对象将被转换为（并作为）它们的字符串表示形式，例如<code>1970-01-01T00:00:00.000Z</code></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>必须手动序列化：</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> serializedMap = [...myMap.<span class="hljs-title function_">entries</span>()];<span class="hljs-keyword">const</span> serializedSet = [...mySet.<span class="hljs-title function_">keys</span>()];</code></pre></div><ul><li>您可以使用该<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#tojson_behavior"><code>toJSON()</code></a>方法自定义对象的序列化</li></ul><p>一个类的例子：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;  #hp;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.#hp = <span class="hljs-number">42</span>;  &#125;  <span class="hljs-title function_">toJSON</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hp</span>: <span class="hljs-variable language_">this</span>.#hp &#125;;  &#125;&#125;socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;here&#x27;s a hero&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>());</code></pre></div><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E5%9B%9E%E8%B0%83"></a></h2><p>事件很棒，但在某些情况下，您可能需要更经典的请求-响应 API。在 Socket.IO 中，此功能称为确认。</p><p>您可以添加一个回调作为<code>emit()</code>的最后一个参数，一旦对方确认事件，就会调用此回调：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;update item&quot;</span>, <span class="hljs-function">(<span class="hljs-params">arg1, arg2, callback</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg1); <span class="hljs-comment">// 1</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg2); <span class="hljs-comment">// &#123; name: &quot;updated&quot; &#125;</span>    <span class="hljs-title function_">callback</span>(&#123;      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;ok&quot;</span>    &#125;);  &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;update item&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;updated&quot;</span> &#125;, <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">status</span>); <span class="hljs-comment">// ok</span>&#125;);</code></pre></div><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E8%B6%85%E6%97%B6"></a></h2><p>从 Socket.IO v4.4.0 开始，您现在可以为每个发射分配超时：</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">timeout</span>(<span class="hljs-number">5000</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;my-event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (err) &#123;    <span class="hljs-comment">// the other side did not acknowledge the event in the given delay</span>  &#125;&#125;);</code></pre></div><p>You can also use both a timeout and an <a href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">acknowledgement</a>:</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">timeout</span>(<span class="hljs-number">5000</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;my-event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (err) &#123;    <span class="hljs-comment">// the other side did not acknowledge the event in the given delay</span>  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response);  &#125;&#125;);</code></pre></div><h2 id="易失性事件"><a href="#易失性事件" class="headerlink" title="易失性事件"></a>易失性事件<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#%E6%98%93%E5%A4%B1%E6%80%A7%E4%BA%8B%E4%BB%B6"></a></h2><p>易失性事件是在底层连接未准备好时不会发送的事件（有点像<a href="https://fr.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>，在可靠性方面）。</p><p>例如，如果您需要发送在线游戏中角色的位置（因为只有最新的值才有用），这可能会很有趣。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;might or might not be received&quot;</span>);</code></pre></div><p>另一个用例是在客户端未连接时丢弃事件（默认情况下，事件会被缓冲直到重新连接）。</p><p>例子：</p><p><em>服务器</em></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;connect&quot;</span>);  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);  &#125;);&#125;);</code></pre></div><p><em>客户端</em></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;  socket.<span class="hljs-property">volatile</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;ping&quot;</span>, ++count);&#125;, <span class="hljs-number">1000</span>);</code></pre></div><p>如果重新启动服务器，您将在控制台中看到：</p><div class="code-wrapper"><pre><code class="hljs text">connect1234# the server is restarted, the client automatically reconnectsconnect91011</code></pre></div><p>如果没有<code>volatile</code>标志，您将看到：</p><div class="code-wrapper"><pre><code class="hljs text">connect1234# the server is restarted, the client automatically reconnects and sends its buffered eventsconnect567891011</code></pre></div><h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><p>有几种方法可以处理在服务器和客户端之间传输的事件。</p><h2 id="EventEmitter-方法"><a href="#EventEmitter-方法" class="headerlink" title="EventEmitter 方法"></a>EventEmitter 方法<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#eventemitter-methods"></a></h2><p>在服务器端，Socket 实例扩展了 Node.js <a href="https://nodejs.org/docs/latest/api/events.html#events_events">EventEmitter</a>类。</p><p>在客户端，Socket 实例使用<a href="https://github.com/component/emitter">component-emitter</a>库提供的事件发射器，它公开了 EventEmitter 方法的子集。</p><h3 id="socket-on-eventName-listener"><a href="#socket-on-eventName-listener" class="headerlink" title="socket.on(eventName, listener)"></a>socket.on(eventName, listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoneventname-listener"></a></h3><p>将<em>侦听器</em>函数添加到名为<em>eventName</em>的事件的侦听器数组的末尾。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;details&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h3 id="socket-once-eventName-listener"><a href="#socket-once-eventName-listener" class="headerlink" title="socket.once(eventName, listener)"></a>socket.once(eventName, listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketonceeventname-listener"></a></h3><p>为名为<em>eventName</em>的事件添加<strong>一次性</strong>监听函数</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;details&quot;</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h3 id="socket-off-eventName-listener"><a href="#socket-off-eventName-listener" class="headerlink" title="socket.off(eventName, listener)"></a>socket.off(eventName, listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoffeventname-listener"></a></h3><p>从名为<em>eventName</em>的事件的侦听器数组中移除指定的<em>侦听器</em>。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params">...args</span>) =&gt; &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args);&#125;socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;details&quot;</span>, listener);<span class="hljs-comment">// and then later...</span>socket.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;details&quot;</span>, listener);</code></pre></div><h3 id="socket-removeAllListeners-eventName"><a href="#socket-removeAllListeners-eventName" class="headerlink" title="socket.removeAllListeners([eventName])"></a>socket.removeAllListeners([eventName])<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketremovealllistenerseventname"></a></h3><p>删除所有侦听器，或指定<em>eventName</em>的侦听器。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// for a specific event</span>socket.<span class="hljs-title function_">removeAllListeners</span>(<span class="hljs-string">&quot;details&quot;</span>);<span class="hljs-comment">// for all events</span>socket.<span class="hljs-title function_">removeAllListeners</span>();</code></pre></div><h2 id="Catch-all-侦听器"><a href="#Catch-all-侦听器" class="headerlink" title="Catch-all 侦听器"></a>Catch-all 侦听器<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#catch-all-listeners"></a></h2><p>从 Socket.IO v3 开始，受<a href="https://github.com/EventEmitter2/EventEmitter2">EventEmitter2</a>库启发的新 API 允许声明 Catch-all 侦听器。</p><p>此功能在客户端和服务器上均可用。</p><h3 id="socket-onAny-listener"><a href="#socket-onAny-listener" class="headerlink" title="socket.onAny(listener)"></a>socket.onAny(listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketonanylistener"></a></h3><p>添加一个监听器，当任何事件发出时将被触发。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">onAny</span>(<span class="hljs-function">(<span class="hljs-params">eventName, ...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h3 id="socket-prependAny-listener"><a href="#socket-prependAny-listener" class="headerlink" title="socket.prependAny(listener)"></a>socket.prependAny(listener)<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketprependanylistener"></a></h3><p>添加一个监听器，当任何事件发出时将被触发。侦听器被添加到侦听器数组的开头。</p><div class="code-wrapper"><pre><code class="hljs js">socket.<span class="hljs-title function_">prependAny</span>(<span class="hljs-function">(<span class="hljs-params">eventName, ...args</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre></div><h3 id="socket-offAny-listener"><a href="#socket-offAny-listener" class="headerlink" title="socket.offAny([listener])"></a>socket.offAny([listener])<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#socketoffanylistener"></a></h3><p>删除所有catch-all侦听器或给定的侦听器。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">listener</span> = (<span class="hljs-params">eventName, ...args</span>) =&gt; &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eventName, args);&#125;socket.<span class="hljs-title function_">onAny</span>(listener);<span class="hljs-comment">// and then later...</span>socket.<span class="hljs-title function_">offAny</span>(listener);<span class="hljs-comment">// or all listeners</span>socket.<span class="hljs-title function_">offAny</span>();</code></pre></div><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#validation"></a></h2><p>事件参数的验证超出了 Socket.IO 库的范围。</p><p>JS 生态系统中有许多包涵盖了这个用例，其中包括：</p><ul><li><a href="https://www.npmjs.com/package/joi">joi</a></li><li><a href="https://www.npmjs.com/package/ajv">ajv</a></li><li><a href="https://www.npmjs.com/package/validatorjs">validatorjs</a></li></ul><p>带有<a href="https://joi.dev/api/">joi</a>和<a href="https://socket.io/zh-CN/docs/v4/emitting-events/#acknowledgements">acknowledgements</a>的示例：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Joi</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;joi&quot;</span>);<span class="hljs-keyword">const</span> userSchema = <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">object</span>(&#123;  <span class="hljs-attr">username</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">max</span>(<span class="hljs-number">30</span>).required(),  <span class="hljs-attr">email</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">email</span>().required()&#125;);io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;create user&quot;</span>, <span class="hljs-function">(<span class="hljs-params">payload, callback</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;      <span class="hljs-comment">// not an acknowledgement</span>      <span class="hljs-keyword">return</span> socket.<span class="hljs-title function_">disconnect</span>();    &#125;    <span class="hljs-keyword">const</span> &#123; error, value &#125; = userSchema.<span class="hljs-title function_">validate</span>(payload);    <span class="hljs-keyword">if</span> (error) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(&#123;        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;KO&quot;</span>,        error      &#125;);    &#125;    <span class="hljs-comment">// do something with the value, and then</span>    <span class="hljs-title function_">callback</span>(&#123;      <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;OK&quot;</span>    &#125;);  &#125;);&#125;);</code></pre></div><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理<a href="https://socket.io/zh-CN/docs/v4/listening-to-events/#error-handling"></a></h2><p>Socket.IO 库中目前没有内置的错误处理，这意味着您必须捕获任何可能在侦听器中引发的错误。</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;list items&quot;</span>, <span class="hljs-keyword">async</span> (callback) =&gt; &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">await</span> <span class="hljs-title function_">findItems</span>();      <span class="hljs-title function_">callback</span>(&#123;        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;OK&quot;</span>,        items      &#125;);    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-title function_">callback</span>(&#123;        <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;NOK&quot;</span>      &#125;);    &#125;  &#125;);&#125;);</code></pre></div><p>在服务器端，使用<code>EventEmitter.captureRejections = true</code>（实验性，请参见<a href="https://nodejs.org/api/events.html#events_capture_rejections_of_promises">此处</a>）也可能很有趣，具体取决于您的用例。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;events&quot;</span>).<span class="hljs-property">captureRejections</span> = <span class="hljs-literal">true</span>;io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;list products&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-keyword">const</span> products = <span class="hljs-keyword">await</span> <span class="hljs-title function_">findProducts</span>();    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;products&quot;</span>, products);  &#125;);  socket[<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;nodejs.rejection&#x27;</span>)] = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    socket.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;error&quot;</span>, err);  &#125;;&#125;);</code></pre></div><h1 id="广播事件"><a href="#广播事件" class="headerlink" title="广播事件"></a>广播事件</h1><p>Socket.IO 使向所有连接的客户端发送事件变得容易。</p><h5 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h5><p>请注意，广播是<strong>仅服务器</strong>功能。</p><h2 id="给所有连接的客户端"><a href="#给所有连接的客户端" class="headerlink" title="给所有连接的客户端"></a>给所有连接的客户端<a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients"></a></h2><p><img src="https://socket.io/zh-CN/images/broadcasting.png" alt="Broadcasting to all connected clients"></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div><h5 id="CAUTION"><a href="#CAUTION" class="headerlink" title="CAUTION"></a>CAUTION</h5><p>当前断开连接（或正在重新连接）的客户端将不会收到该事件。将此事件存储在某处（例如在数据库中）取决于您的用例。</p><h2 id="除发送者外的所有连接的客户端"><a href="#除发送者外的所有连接的客户端" class="headerlink" title="除发送者外的所有连接的客户端"></a>除发送者外的所有连接的客户端<a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#to-all-connected-clients-except-the-sender"></a></h2><p><img src="https://socket.io/zh-CN/images/broadcasting2.png" alt="Broadcasting to all connected clients excepting the sender"></p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-property">broadcast</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);&#125;);</code></pre></div><h5 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h5><p>在上面的示例中，使用<code>socket.emit(&quot;hello&quot;, &quot;world&quot;)</code>（不带<code>broadcast</code>标志）会将事件发送到“客户端 A”。您可以在<a href="https://socket.io/zh-CN/docs/v4/emit-cheatsheet/">备忘单</a>中找到发送事件的所有方式的列表。</p><h2 id="使用多个-Socket-IO-服务器"><a href="#使用多个-Socket-IO-服务器" class="headerlink" title="使用多个 Socket.IO 服务器"></a>使用多个 Socket.IO 服务器<a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#with-multiple-socketio-servers"></a></h2><p>广播也适用于多个 Socket.IO 服务器。</p><p>您只需将默认适配器替换为<a href="https://socket.io/zh-CN/docs/v4/adapter/">Redis 适配器</a>或其他<a href="https://socket.io/zh-CN/docs/v4/redis-adapter/">兼容的适配器</a>。</p><p><img src="https://socket.io/zh-CN/images/broadcasting-redis.png" alt="Broadcasting with Redis"></p><p>在某些情况下，您可能只想向连接到当前服务器的客户端广播。您可以使用<code>local</code>标志实现此目的：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-property">local</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);</code></pre></div><p>复制</p><p><img src="https://socket.io/zh-CN/images/broadcasting-redis-local.png" alt="Broadcasting with Redis but local"></p><p>为了在广播时针对特定客户，请参阅有关<a href="https://socket.io/zh-CN/docs/v4/rooms/">Rooms</a>的文档。</p><h1 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h1><p>sockets可以<code>join</code> 和 <code>leave</code><em>房间</em>。它可用于向一部分客户端广播事件：</p><p><img src="https://socket.io/zh-CN/images/rooms.png" alt="Broadcasting to all clients in a room"></p><h5 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h5><p>请注意，房间是一个<strong>仅限服务器</strong>的概念（即客户端无权访问它已加入的房间列表）。</p><h2 id="加入和离开"><a href="#加入和离开" class="headerlink" title="加入和离开"></a>加入和离开<a href="https://socket.io/zh-CN/docs/v4/rooms/#joining-and-leaving"></a></h2><p>您可以调用<code>join</code>以将socket订阅到给定的频道：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;some room&quot;</span>);&#125;);</code></pre></div><p>然后在广播或发射时简单地使用<code>to</code> 或 <code>in</code>（它们是相同的）：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;some room&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);</code></pre></div><p>您可以同时发射到多个房间：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room1&quot;</span>).<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room2&quot;</span>).<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;room3&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);</code></pre></div><p>在这种情况下，将执行<a href="https://en.wikipedia.org/wiki/Union_(set_theory)">联合</a>：至少在其中一个房间中的每个socket都将获得<strong>一次</strong>事件（即使socket在两个或更多房间中）。</p><p>您还可以从给定的socket广播到房间：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;some room&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;some event&quot;</span>);&#125;);</code></pre></div><p>在这种情况下，房间中<strong>除</strong>发送者之外的每个socket都会收到该事件。</p><p><img src="https://socket.io/zh-CN/images/rooms2.png" alt="Broadcasting to all clients in a room excepting the sender"></p><p>要离开频道，您调用<code>leave</code>的方式与<code>join</code>相同。</p><h2 id="默认房间"><a href="#默认房间" class="headerlink" title="默认房间"></a>默认房间<a href="https://socket.io/zh-CN/docs/v4/rooms/#default-room"></a></h2><p>Socket.IO 中的每一个<code>socket</code>都由一个随机的、不可猜测的、唯一的标识符<a href="https://socket.io/zh-CN/docs/v4/server-socket-instance/#socketid">Socket#id</a>。为了您的方便，每个socket都会自动加入一个由其自己的 id 标识的房间。</p><p>这使得实现私人消息变得容易：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;private message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">anotherSocketId, msg</span>) =&gt;</span> &#123;    socket.<span class="hljs-title function_">to</span>(anotherSocketId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;private message&quot;</span>, socket.<span class="hljs-property">id</span>, msg);  &#125;);&#125;);</code></pre></div><h2 id="示例用例"><a href="#示例用例" class="headerlink" title="示例用例"></a>示例用例<a href="https://socket.io/zh-CN/docs/v4/rooms/#sample-use-cases"></a></h2><ul><li>向给定用户的每个设备/选项卡广播数据</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">async</span> (socket) =&gt; &#123;  <span class="hljs-keyword">const</span> userId = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserId</span>(socket);  socket.<span class="hljs-title function_">join</span>(userId);  <span class="hljs-comment">// and then later</span>  io.<span class="hljs-title function_">to</span>(userId).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;hi&quot;</span>);&#125;);</code></pre></div><p>复制</p><ul><li>发送有关给定实体的通知</li></ul><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">async</span> (socket) =&gt; &#123;  <span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchProjects</span>(socket);  projects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">project</span> =&gt;</span> socket.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;project:&quot;</span> + project.<span class="hljs-property">id</span>));  <span class="hljs-comment">// and then later</span>  io.<span class="hljs-title function_">to</span>(<span class="hljs-string">&quot;project:4321&quot;</span>).<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;project updated&quot;</span>);&#125;);</code></pre></div><h2 id="断开"><a href="#断开" class="headerlink" title="断开"></a>断开<a href="https://socket.io/zh-CN/docs/v4/rooms/#disconnection"></a></h2><p>断开连接后，<code>leave</code>会自动将它们所属的所有通道连接起来，您不需要进行特殊的拆卸。</p><p>您可以通过监听<code>disconnecting</code>事件来获取 Socket 所在的房间：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function"><span class="hljs-params">socket</span> =&gt;</span> &#123;  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnecting&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(socket.<span class="hljs-property">rooms</span>); <span class="hljs-comment">// the Set contains at least the socket ID</span>  &#125;);  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;disconnect&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// socket.rooms.size === 0</span>  &#125;);&#125;);</code></pre></div><h2 id="使用多个-Socket-IO-服务器-1"><a href="#使用多个-Socket-IO-服务器-1" class="headerlink" title="使用多个 Socket.IO 服务器"></a>使用多个 Socket.IO 服务器<a href="https://socket.io/zh-CN/docs/v4/rooms/#with-multiple-socketio-servers"></a></h2><p>与<a href="https://socket.io/zh-CN/docs/v4/broadcasting-events/#with-multiple-socketio-servers">全局广播</a>一样，向房间广播也适用于多个 Socket.IO 服务器。</p><p>您只需要将默认的<a href="https://socket.io/zh-CN/docs/v4/glossary/#adapter">Adapter</a>替换为 Redis Adapter。更多关于它的信息在<a href="https://socket.io/zh-CN/docs/v4/redis-adapter/">这里</a>。</p><p><img src="https://socket.io/zh-CN/images/rooms-redis.png" alt="Broadcasting to all clients in a room with Redis"></p><h2 id="实施细节"><a href="#实施细节" class="headerlink" title="实施细节"></a>实施细节<a href="https://socket.io/zh-CN/docs/v4/rooms/#implementation-details"></a></h2><p>“房间”功能由我们称为适配器的东西实现。该适配器是一个服务器端组件，负责：</p><ul><li>存储 Socket 实例和房间之间的关系</li><li>向所有（或部分）客户端广播事件</li></ul><p>您可以在<a href="https://github.com/socketio/socket.io-adapter">此处</a>找到默认内存适配器的代码。</p><p>基本上，它包含两个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">ES6 Maps</a>:</p><ul><li><code>sids</code>: <code>Map&lt;SocketId, Set&lt;Room&gt;&gt;</code></li><li><code>rooms</code>: <code>Map&lt;Room, Set&lt;SocketId&gt;&gt;</code></li></ul><p>调用<code>socket.join(&quot;the-room&quot;)</code>将导致：</p><ul><li>在<code>sids</code> Map中，将“the-room”添加到由Socket ID 标识的 Set</li><li>在<code>rooms</code> Map 中，将Socket ID 添加到由字符串“the-room”标识的 Set 中</li></ul><p>然后在广播时使用这两个地图：</p><ul><li>对所有套接字的广播（<code>io.emit()</code>）循环通过<code>sids</code>Map，并将数据包发送到所有sockets</li><li>对给定房间的广播 ( <code>io.to(&quot;room21&quot;).emit()</code>）循环通过<code>rooms</code>Map 中的 Set，并将数据包发送到所有匹配的sockets</li></ul><p>您可以通过以下方式访问这些对象：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// main namespace</span><span class="hljs-keyword">const</span> rooms = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">rooms</span>;<span class="hljs-keyword">const</span> sids = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">sids</span>;<span class="hljs-comment">// custom namespace</span><span class="hljs-keyword">const</span> rooms = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/my-namespace&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">rooms</span>;<span class="hljs-keyword">const</span> sids = io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/my-namespace&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-property">sids</span>;</code></pre></div><p>笔记：</p><ul><li>这些对象并不意味着直接修改，您应该始终使用<a href="https://socket.io/zh-CN/docs/v4/server-api/#socketjoinroom"><code>socket.join(...)</code></a> 和 <a href="https://socket.io/zh-CN/docs/v4/server-api/#socketleaveroom"><code>socket.leave(...)</code></a>来代替。</li><li>在<a href="https://socket.io/zh-CN/docs/v4/using-multiple-nodes/">多服务器</a>设置中，<code>rooms</code> 和 <code>sids</code>对象不会在 Socket.IO 服务器之间共享（房间可能只“存在”在一个服务器上而不是另一个服务器上）。</li></ul><h2 id="房间事件"><a href="#房间事件" class="headerlink" title="房间事件"></a>房间事件<a href="https://socket.io/zh-CN/docs/v4/rooms/#room-events"></a></h2><p>从<code>socket.io@3.1.0</code>开始，底层适配器将发出以下事件：</p><ul><li><code>create-room</code> (argument: room)</li><li><code>delete-room</code> (argument: room)</li><li><code>join-room</code> (argument: room, id)</li><li><code>leave-room</code> (argument: room, id)</li></ul><p>例子：</p><div class="code-wrapper"><pre><code class="hljs js">io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;create-room&quot;</span>, <span class="hljs-function">(<span class="hljs-params">room</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`room <span class="hljs-subst">$&#123;room&#125;</span> was created`</span>);&#125;);io.<span class="hljs-title function_">of</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-property">adapter</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;join-room&quot;</span>, <span class="hljs-function">(<span class="hljs-params">room, id</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`socket <span class="hljs-subst">$&#123;id&#125;</span> has joined room <span class="hljs-subst">$&#123;room&#125;</span>`</span>);&#125;);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>websocket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket.io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是websocket</title>
    <link href="/2022/09/24/%E4%BB%80%E4%B9%88%E6%98%AFwebsocket/"/>
    <url>/2022/09/24/%E4%BB%80%E4%B9%88%E6%98%AFwebsocket/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>webSocket是一种网络传输协议，可以在单个TCP连接上进行全双工通信，位于OSI模型的应用层，webSocket协议在2011年由IETF标准化为RFC6455,由RFC7936补充规范，WEB IDL中的webSocket api由W3C标准化，websocket是一种和http不同的协议，但是都是属于OSI模型的应用层，可以通过HTTP的80端口和443端口进行通信，支持HTTP代理和中介，和http协议兼容，为了实现兼容性，webSocket进行握手使用HTTP Upgrade头从http协议改成webSocket协议，websocket支持浏览器和服务器进行双向通信，可以进行实时通信，不需要客户端发起请求，目前大部分浏览器都支持websocket,和HTTP不同，websocket支持全双工通信，websocket还可以TCP之上实现消息流</p><p>websocket协议有两种标识符分别是ws和wss，分别是明文传输和加密传输。websocket不支持#，除了这些，其他都和http相同</p><div class="code-wrapper"><pre><code class="hljs awk">ws:<span class="hljs-regexp">//</span>example.com/wsapiwss:<span class="hljs-regexp">//</span>secure.example.com/wsapi</code></pre></div><h4 id="websocket的优点"><a href="#websocket的优点" class="headerlink" title="websocket的优点"></a>websocket的优点</h4><ul><li><p>比较少的控制开销，在服务器和客户端通信的时候，用于协议控制的数据包头部相对较小，在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2到10字节，对于客户端到服务器的内容，此头部还需要加额外的4字节的掩码，相对于http每次都要携带完整的头部，明显减少了开销</p></li><li><p>更强的实时性，由于协议是全双工的，所以服务器可以随时主动的给客户端发送数据，相对于HTTP请求需要客户端发送请求并且等待服务器响应，减少了等待时间，即使和Comet等类似的长轮询比较，它也可以在短时间传递更多的数据</p></li><li><p>保持连接状态，与HTTP不同的是，webSocket需要先建立连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息，而http每次请求可能需要携带验证信息</p></li><li><p>更好的二进制支持，webSocket定义了二进制帧，他会比HTTP更i轻松的处理二进制文件</p></li><li><p>更好的压缩效果，相对于HTTP压缩，websocket在适当的扩展的支持下，可以沿用之前的内容的上下文，在传递类似的数据的时候可以显著的提高压缩率</p></li></ul><p>webSocket是独立的，建立在TCP上的协议，websocket通过HTTP/1.1的101状态吗继续握手，为了建立Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“<a href="https://zh.m.wikipedia.org/wiki/%E6%8F%A1%E6%89%8B_(%E6%8A%80%E6%9C%AF)">握手</a>”（Handshaking）</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>客户端请求：</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==<span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://example.com<span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>chat, superchat<span class="hljs-attribute">Sec-WebSocket-Version</span><span class="hljs-punctuation">: </span>13</code></pre></div><p>服务器的回应</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>chat</code></pre></div><ul><li>Connection必须设置Upgrade，表示客户端希望连接升级。</li><li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li><li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算<a href="https://zh.m.wikipedia.org/wiki/SHA-1">SHA-1</a>摘要，之后进行<a href="https://zh.m.wikipedia.org/wiki/Base64">Base64</a>编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li><li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin字段是必须的。如果缺少origin字段，WebSocket服务器需要回复HTTP 403 状态码（禁止访问）。[<a href="https://zh.m.wikipedia.org/zh-hans/WebSocket#cite_note-16">16]</a></li><li>其他一些定义在HTTP协议中的字段，如<a href="https://zh.m.wikipedia.org/wiki/Cookie">Cookie</a>等，也可以在Websocket中使用。</li></ul><h4 id="websocket的基本使用"><a href="#websocket的基本使用" class="headerlink" title="websocket的基本使用"></a>websocket的基本使用</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;wss://echo.websocket.org&quot;</span>);ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection open ...&quot;</span>);   ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hello WebSockets!&quot;</span>);&#125;;ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Received Message: &quot;</span> + evt.<span class="hljs-property">data</span>);  ws.<span class="hljs-title function_">close</span>();&#125;;ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Connection closed.&quot;</span>);&#125;;</code></pre></div><blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:8080&#x27;</span>);</code></pre></div></blockquote><p>wenSocket作为构造函数，用于新建WebSocket实例，执行完上面的例子之后，客户端就会和服务器进行连接</p><h5 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h5><p>readyState属性是返回当前状态，共有四种状态</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (ws.<span class="hljs-property">readyState</span>) &#123;  <span class="hljs-keyword">case</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">CONNECTING</span>:    <span class="hljs-comment">// do something</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>:    <span class="hljs-comment">// do something</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">CLOSING</span>:    <span class="hljs-comment">// do something</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-keyword">case</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">CLOSED</span>:    <span class="hljs-comment">// do something</span>    <span class="hljs-keyword">break</span>;  <span class="hljs-attr">default</span>:    <span class="hljs-comment">// this never happens</span>    <span class="hljs-keyword">break</span>;&#125;</code></pre></div><h5 id="open属性监听连接之后的回调函数"><a href="#open属性监听连接之后的回调函数" class="headerlink" title="open属性监听连接之后的回调函数"></a>open属性监听连接之后的回调函数</h5><div class="code-wrapper"><pre><code class="hljs javascript">ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Server!&#x27;</span>);&#125;<span class="hljs-comment">//执行多个回调函数可以使用addEventListener</span>ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;  ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Server!&#x27;</span>);&#125;);</code></pre></div><h5 id="实例对象的onclose属性，用于指定连接关闭后的回调函数"><a href="#实例对象的onclose属性，用于指定连接关闭后的回调函数" class="headerlink" title="实例对象的onclose属性，用于指定连接关闭后的回调函数"></a>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数</h5><div class="code-wrapper"><pre><code class="hljs js">ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-keyword">var</span> code = event.<span class="hljs-property">code</span>;  <span class="hljs-keyword">var</span> reason = event.<span class="hljs-property">reason</span>;  <span class="hljs-keyword">var</span> wasClean = event.<span class="hljs-property">wasClean</span>;  <span class="hljs-comment">// handle close event</span>&#125;;ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-keyword">var</span> code = event.<span class="hljs-property">code</span>;  <span class="hljs-keyword">var</span> reason = event.<span class="hljs-property">reason</span>;  <span class="hljs-keyword">var</span> wasClean = event.<span class="hljs-property">wasClean</span>;  <span class="hljs-comment">// handle close event</span>&#125;);</code></pre></div><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数</p><div class="code-wrapper"><pre><code class="hljs javascript">ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-keyword">var</span> data = event.<span class="hljs-property">data</span>;  <span class="hljs-comment">// 处理数据</span>&#125;;ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-keyword">var</span> data = event.<span class="hljs-property">data</span>;  <span class="hljs-comment">// 处理数据</span>&#125;);</code></pre></div><p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象</p><div class="code-wrapper"><pre><code class="hljs javascript">ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> event.<span class="hljs-property">data</span> === <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received data string&quot;</span>);  &#125;  <span class="hljs-keyword">if</span>(event.<span class="hljs-property">data</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ArrayBuffer</span>)&#123;    <span class="hljs-keyword">var</span> buffer = event.<span class="hljs-property">data</span>;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received arraybuffer&quot;</span>);  &#125;&#125;</code></pre></div><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p><blockquote><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 收到的是 blob 数据</span>ws.<span class="hljs-property">binaryType</span> = <span class="hljs-string">&quot;blob&quot;</span>;ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">size</span>);&#125;;<span class="hljs-comment">// 收到的是 ArrayBuffer 数据</span>ws.<span class="hljs-property">binaryType</span> = <span class="hljs-string">&quot;arraybuffer&quot;</span>;ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">byteLength</span>);&#125;;</code></pre></div></blockquote><p>实例对象的<code>send()</code>方法用于向服务器发送数据。</p><blockquote><div class="code-wrapper"><pre><code class="hljs javascript">ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;your message&#x27;</span>);</code></pre></div></blockquote><p>发送blob对象的例子</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> file = <span class="hljs-variable language_">document</span>  .<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input[type=&quot;file&quot;]&#x27;</span>)  .<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];ws.<span class="hljs-title function_">send</span>(file);</code></pre></div><p>发送ArrayBuffer对象的例子</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Sending canvas ImageData as ArrayBuffer</span><span class="hljs-keyword">var</span> img = canvas_context.<span class="hljs-title function_">getImageData</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">400</span>, <span class="hljs-number">320</span>);<span class="hljs-keyword">var</span> binary = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(img.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; img.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>; i++) &#123;  binary[i] = img.<span class="hljs-property">data</span>[i];&#125;ws.<span class="hljs-title function_">send</span>(binary.<span class="hljs-property">buffer</span>);</code></pre></div><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">10000000</span>);socket.<span class="hljs-title function_">send</span>(data);<span class="hljs-keyword">if</span> (socket.<span class="hljs-property">bufferedAmount</span> === <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 发送完毕</span>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 发送还没结束</span>&#125;</code></pre></div><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p><blockquote><div class="code-wrapper"><pre><code class="hljs javascript">socket.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-comment">// handle error event</span>&#125;;socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;  <span class="hljs-comment">// handle error event</span>&#125;)</code></pre></div></blockquote><h4 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h4><p>如果用node实现websocket</p><ul><li><a href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li><li><a href="http://socket.io/">Socket.IO</a></li><li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>websocket</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mobx的使用</title>
    <link href="/2022/09/20/mobx%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/20/mobx%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><em>任何可以从应用状态中派生出来的值都应该被自动派生出来。</em></p><p>MobX 是一个身经百战的库，它通过运用透明的函数式响应编程（Transparent Functional Reactive Programming，TFRP）使状态管理变得简单和可扩展。</p><p>😙</p><h5 id="简单直接"><a href="#简单直接" class="headerlink" title="简单直接"></a>简单直接</h5><p>编写无模板的极简代码来精准描述出你的意图。要更新一个记录字段？使用熟悉的 JavaScript 赋值就行。要在异步进程中更新数据？不需要特殊的工具，响应性系统会侦测到你所有的变更并把它们传送到其用武之地。</p><p>🚅</p><h5 id="轻松实现最优渲染"><a href="#轻松实现最优渲染" class="headerlink" title="轻松实现最优渲染"></a>轻松实现最优渲染</h5><p>所有对数据的变更和使用都会在运行时被追踪到，并构成一个截取所有状态和输出之间关系的依赖树。这样保证了那些依赖于状态的计算只有在真正需要时才会运行，就像 React 组件一样。无需使用记忆化或选择器之类容易出错的次优技巧来对组件进行手动优化。</p><p>🤹🏻‍♂️</p><h5 id="架构自由"><a href="#架构自由" class="headerlink" title="架构自由"></a>架构自由</h5><p>MobX 不会用它自己的规则来限制你，它可以让你在任意 UI 框架之外管理你的应用状态。这样会使你的代码低耦合、可移植和最重要的——容易测试。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">import</span> &#123; observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span><span class="hljs-comment">// 对应用状态进行建模。</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;    secondsPassed = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">increase</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> += <span class="hljs-number">1</span>    &#125;    <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondsPassed</span> = <span class="hljs-number">0</span>    &#125;&#125;<span class="hljs-keyword">const</span> myTimer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>()<span class="hljs-comment">// 构建一个使用 observable 状态的“用户界面”。</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TimerView</span> = <span class="hljs-title function_">observer</span>(<span class="hljs-function">(<span class="hljs-params">&#123; timer &#125;</span>) =&gt;</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> timer.reset()&#125;&gt;已过秒数：&#123;timer.secondsPassed&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>))<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">TimerView</span> <span class="hljs-attr">timer</span>=<span class="hljs-string">&#123;myTimer&#125;</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)<span class="hljs-comment">// 每秒更新一次‘已过秒数：X’中的文本。</span><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;    myTimer.<span class="hljs-title function_">increase</span>()&#125;, <span class="hljs-number">1000</span>)</code></pre></div><p>围绕 React 组件 <code>TimerView</code> 的 <code>observer</code> 包装会自动侦测到依赖于 observable <code>timer.secondsPassed</code> 的渲染——即使这种依赖关系没有被明确定义出来。 响应性系统会负责在未来<em>恰好那个</em>字段被更新的时候将组件重新渲染。</p><p>每个事件（<code>onClick</code> 或 <code>setInterval</code>）都会调用一个用来更新 <em>observable 状态</em> <code>myTimer.secondsPassed</code> 的 <em>action</em>（<code>myTimer.increase</code> 或 <code>myTimer.reset</code>）。Observable 状态的变更会被精确地传送到 <code>TimerView</code> 中所有依赖于它们的<em>计算</em>和<em>副作用</em>里。</p><p><img src="https://zh.mobx.js.org/assets/zh.flow.png" alt="MobX 单向流"></p><h1 id="MobX-主旨"><a href="#MobX-主旨" class="headerlink" title="MobX 主旨"></a>MobX 主旨</h1><p>Mobx区分了应用程序的三个概念</p><ul><li>State</li><li>Actions</li><li>Derivations</li></ul><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p><em>State(状态)</em> 是驱动你的应用程序的数据。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Todo</span> &#123;    id = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()    title = <span class="hljs-string">&quot;&quot;</span>    finished = <span class="hljs-literal">false</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">title</span>: observable,            <span class="hljs-attr">finished</span>: observable,            <span class="hljs-attr">toggle</span>: action        &#125;)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title    &#125;    <span class="hljs-title function_">toggle</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">finished</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">finished</span>    &#125;&#125;</code></pre></div><p>将 State 存储在任何您喜欢的数据结构中：普通对象、数组、类、循环数据结构或引用。这与MobX的工作方式无关。</p><p>只要确保所有响应式的属性都被标记为<code>observable</code></p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>action是用来改变state中的数据，比如用户事件处理、后端推送数据处理、调度器事件处理等等。</p><h3 id="创建-Derivations-以便自动对-State-变化进行响应"><a href="#创建-Derivations-以便自动对-State-变化进行响应" class="headerlink" title="创建 Derivations 以便自动对 State 变化进行响应"></a>创建 Derivations 以便自动对 State 变化进行响应</h3><p><em>任何</em> 来源是<em>State(状态)</em> 并且不需要进一步交互的东西都是 Derivation(派生)</p><p>Derivations 包括许多方式:</p><ul><li><em>用户界面</em></li><li><em>派生数据</em> , 比如剩余未完成<code>todos</code>的数量</li><li><em>后端集成</em> , 比如发送改变到服务器端</li></ul><p>Mobx 区分了两种 Derivation :</p><ul><li><em>Computed values</em>,总是可以通过纯函数从当前的可观测 State 中派生。</li><li><em>Reactions</em>, 当 State 改变时需要自动运行的副作用 (命令式编程和响应式编程之间的桥梁)</li></ul><p>当最开始使用MobX时，人们容易过度使用 <em>Reaction</em>。</p><p>黄金法则是，如果要基于当前 State 创建值，请始终使用 <em>computed</em></p><h4 id="通过-computed-对派生值进行建模"><a href="#通过-computed-对派生值进行建模" class="headerlink" title="通过 computed 对派生值进行建模"></a>通过 computed 对派生值进行建模</h4><p>你可以通过定义 getter 方法并使用 <code>makeObservable</code> 将其标记为 <code>computed</code> 的方式创建一个 <em>computed</em> 值。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TodoList</span> &#123;    todos = []    <span class="hljs-keyword">get</span> <span class="hljs-title function_">unfinishedTodoCount</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">finished</span>).<span class="hljs-property">length</span>    &#125;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">todos</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">todos</span>: observable,            <span class="hljs-attr">unfinishedTodoCount</span>: computed        &#125;)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">todos</span> = todos    &#125;&#125;</code></pre></div><p>Mobx 会确保 <code>unfinishedTodoCount</code> 会在todos数组发生变化中或者 todos中的一个对象中的 <code>finished</code>属性被修改时自动更新</p><h4 id="Reaction会产生副作用"><a href="#Reaction会产生副作用" class="headerlink" title="Reaction会产生副作用"></a>Reaction会产生副作用</h4><p>作为用户，要想在屏幕上看到状态或计算值的变化，就需要一个重新绘制部分GUI的 <em>reactions</em> 。</p><p>Reaction 和 computed 类似，但并不产生信息，而是产生副作用，如打印到控制台、发出网络请求、增量更新 React 组件树以便更新DOM等。</p><p>简而言之，<em>reaction</em> 是 <a href="https://en.wikipedia.org/wiki/Reactive_programming">响应式编程</a>和<a href="https://en.wikipedia.org/wiki/Imperative_programming">指令式编程</a>之间的桥梁。</p><p>到目前为止，最常用的 reaction 形式是UI组件。 注意，action 和 reaction 都可能引起副作用。 副作用应有一个清晰的、显式的起源，例如在提交表单时发出网络请求，应该从相关的事件处理程序显式触发。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>Mobx 使用单向数据流，利用 <em>action</em> 改变 <em>state</em> ，进而更新所有受影响的 <em>view</em></p><p><img src="https://zh.mobx.js.org/assets/action-state-view.png" alt="Action, State, View"></p><ol><li>所有的 <em>derivations</em> 将在 <em>state</em> 改变时<strong>自动且原子化地更新</strong>。因此不可能观察中间值。</li><li>所有的 <em>derivations</em> 默认将会<strong>同步</strong>更新，这意味着 <em>action</em> 可以在 <em>state</em> 改变 之后安全的直接获得 computed 值。</li><li><em>computed value</em> 的更新是<strong>惰性</strong>的，任何 computed value 在需要他们的副作用发生之前都是不激活的。</li><li>所有的 <em>computed value</em> 都应是<strong>纯函数</strong>,他们不应该修改 <em>state</em>。</li></ol><h2 id="Observable-state"><a href="#Observable-state" class="headerlink" title="Observable state"></a>Observable state</h2><p>属性，完整的对象，数组，Maps 和 Sets 都可以被转化为可观察对象。 使得对象可观察的基本方法是使用 <code>makeObservable</code> 为每个属性指定一个注解。 最重要的注解如下：</p><ul><li><code>observable</code> 定义一个存储 state 的可追踪字段。</li><li><code>action</code> 将一个方法标记为可以修改 state 的 action。</li><li><code>computed</code> 标记一个可以由 state 派生出新的值并且缓存其输出的 getter。</li></ul><p>像数组，Maps 和 Sets 这样的集合都将被自动转化为可观察对象</p><h4 id="makeObservable"><a href="#makeObservable" class="headerlink" title="makeObservable"></a><code>makeObservable</code></h4><p>用法：</p><ul><li><code>makeObservable(target, annotations?, options?)</code></li></ul><p>这个函数会将已存在的对象属性转换成可观察地对象，任何target对象包括class都可以作为target传递。一般情况下，<code>makeObservable</code> 是在类的构造函数中调用的，并且它的第一个参数是 <code>this</code> 。 <code>annotations</code> 参数将会为每一个成员映射 <a href="https://zh.mobx.js.org/observable-state.html#%E5%8F%AF%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3">注解</a>。需要注意的是，当使用 <a href="https://zh.mobx.js.org/enabling-decorators.html">装饰器</a> 时，<code>annotations</code> 参数将会被忽略。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, computed, action, flow &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">value</span>: observable,            <span class="hljs-attr">double</span>: computed,            <span class="hljs-attr">increment</span>: action,            <span class="hljs-attr">fetch</span>: flow        &#125;)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">double</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;    *<span class="hljs-title function_">fetch</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/value&quot;</span>)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = response.<span class="hljs-title function_">json</span>()    &#125;&#125;所有带注解 的字段都是 不可配置的。所有的不可观察（无状态）的字段（action, flow）都是 不可写的。</code></pre></div><h4 id="makeAutoObservable"><a href="#makeAutoObservable" class="headerlink" title="makeAutoObservable"></a><code>makeAutoObservable</code></h4><p>使用：</p><ul><li><code>makeAutoObservable(target, overrides?, options?)</code></li></ul><p>相当于是加强版的makeObservable函数，他会自动根据传入的对象属性自动转成可观察属性，</p><p>与使用 <code>makeObservable</code> 相比，<code>makeAutoObservable</code> 函数更紧凑，也更容易维护，因为新成员不需要显式地提及。 然而，<code>makeAutoObservable</code> 不能被用于带有 super 的类或 <a href="https://zh.mobx.js.org/subclassing.html">子类</a></p><p>推断规则：</p><ul><li>所有 <em>自有</em> 属性都成为 <code>observable</code>。</li><li>所有 <code>get</code>ters 都成为 <code>computed</code>。</li><li>所有 <code>set</code>ters 都成为 <code>action</code>。</li><li>所有 <em>prototype 中的 functions</em> 都成为 <code>autoAction</code>。</li><li>所有 <em>prototype 中的 generator functions</em> 都成为 <code>flow</code>。（需要注意，generators 函数在某些编译器配置中无法被检测到，如果 flow 没有正常运行，请务必明确地指定 <code>flow</code> 注解。）</li><li>在 <code>overrides</code> 参数中标记为 <code>false</code> 的成员将不会被添加注解。例如，将其用于像标识符这样的只读字段。</li></ul><h4 id="observable"><a href="#observable" class="headerlink" title="observable"></a><code>observable</code></h4><p>用法：</p><ul><li><code>observable(source, overrides?, options?)</code></li></ul><p><code>observable</code> 注解可以作为一个函数进行调用，从而一次性将整个对象变成可观察的。 <code>source</code> 对象将会被克隆并且所有的成员都将会成为可观察的，类似于 <code>makeAutoObservable</code> 做的那样。 同样，你可以传入一个 <code>overrides</code> 对象来为特定的成员提供特定的注解。 </p><p>由 <code>observable</code> 返回的对象将会使用 Proxy 包装，这意味着之后被添加到这个对象中的属性也将被侦测并使其转化为可观察对象（除非禁用 <a href="https://zh.mobx.js.org/configuration.html#proxy-%E9%80%89%E9%A1%B9">proxy</a>）。</p><p><code>observable</code> 方法也可以被像 <a href="https://zh.mobx.js.org/api.html#observablearray">arrays</a>，<a href="https://zh.mobx.js.org/api.html#observablemap">Maps</a> 和 <a href="https://zh.mobx.js.org/api.html#observableset">Sets</a> 这样的集合调用。这些集合也将被克隆并转化为可观察对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observable, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">observable</span>([    &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Spoil tea&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">true</span> &#125;,    &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Make coffee&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> &#125;])<span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(        <span class="hljs-string">&quot;Remaining:&quot;</span>,        todos            .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> !todo.<span class="hljs-property">completed</span>)            .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">title</span>)            .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;, &quot;</span>)    )&#125;)<span class="hljs-comment">// 打印: &#x27;Remaining: Make coffee&#x27;</span>todos[<span class="hljs-number">0</span>].<span class="hljs-property">completed</span> = <span class="hljs-literal">false</span><span class="hljs-comment">// 打印: &#x27;Remaining: Spoil tea, Make coffee&#x27;</span>todos[<span class="hljs-number">2</span>] = &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Take a nap&quot;</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> &#125;<span class="hljs-comment">// 打印: &#x27;Remaining: Spoil tea, Make coffee, Take a nap&#x27;</span>todos.<span class="hljs-title function_">shift</span>()<span class="hljs-comment">// 打印: &#x27;Remaining: Make coffee, Take a nap&#x27;</span></code></pre></div><p>使用autorun可以在响应式的数据发生改变的时候，自动执行对应的回调函数</p><p>可观察的数组还有一些特别好用的实用函数：</p><ul><li><code>clear()</code> 从数组中清除所有元素。</li><li><code>replace(newItems)</code> 将数组中现有的元素全部替换成 newItems。</li><li><code>remove(value)</code> 根据 value 从数组中删除一个元素。如果找到并删除了元素，返回 <code>true</code>。</li></ul><p><strong>注意：基本数据类型和类的实例不能转换成可观察的对象</strong></p><p><strong><code>make(Auto)Observable</code> 和 <code>observable</code> 之间最主要的区别</strong>在于，<code>make(Auto)Observable</code> 会修改你作为第一个参数传入的对象，而 <code>observable</code> 会创建一个可观察的 <em>副本</em> 对象</p><p>第二个区别是，<code>observable</code> 会创建一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><code>Proxy</code></a> 对象，以便能够在你将该对象当作动态查询映射使用时捕获将要添加的属性。 如果你想把一个对象转化为可观察对象，而这个对象具有一个常规结构，其中所有的成员都是事先已知的，那么我们建议使用 <code>makeObservable</code>，因为非代理对象的速度稍快一些，而且它们在调试器和 <code>console.log</code> 中更容易检查。</p><p>因此，<code>make(Auto)Observable</code> 推荐在工厂函数中使用。 值得一提的是，可以将 <code>&#123; proxy: false &#125;</code> 作为 option 传入 <code>observable</code> 获取非代理副本</p><h2 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h2><h3 id="使用-actions-更新-state"><a href="#使用-actions-更新-state" class="headerlink" title="使用 actions 更新 state"></a>使用 actions 更新 state</h3><p>用法：</p><ul><li><code>action</code> <em>（注解）</em></li><li><code>action(fn)</code></li><li><code>action(name, fn)</code></li></ul><p>actions就是用来修改state中的数据的，</p><p>尽管 <a href="https://zh.mobx.js.org/observable-state.html#makeautoobservable"><code>makeAutoObservable</code></a> 可以自动帮你声明一部分 actions，但是 MobX 还是要求你声明你的 actions。Actions 可以帮助你更好的组织你的代码并提供以下性能优势：</p><ol><li>它们在 <a href="https://zh.mobx.js.org/api.html#transaction">transactions</a> 内部运行。任何可观察对象在最外层的 action 完成之前都不会被更新，这一点保证了在 action 完成之前，action 执行期间生成的中间值或不完整的值对应用程序的其余部分都是不可见的。</li><li>默认情况下，不允许在 actions 之外改变 state。这有助于在代码中清楚地对状态更新发生的位置进行定位。</li></ol><p><code>action</code> 注解应该仅用于会<em>修改</em> state 的函数。派生其他信息（执行查询或者过滤数据）的函数<em>不应该</em>被标记为 actions，以便 MobX 可以对它们的调用进行跟踪。 带有 <code>action</code> 注解的成员是不可枚举的。</p><p>makeObservable</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">value</span>: observable,            <span class="hljs-attr">increment</span>: action        &#125;)    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 观察者不会看到中间状态.</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;&#125;</code></pre></div><p>makeAutoObservable</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;&#125;</code></pre></div><p>action.bound</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">value</span>: observable,            <span class="hljs-attr">increment</span>: action.<span class="hljs-property">bound</span>        &#125;)    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;&#125;<span class="hljs-keyword">const</span> doubler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Doubler</span>()<span class="hljs-comment">// 这样调用 increment 是安全的, 因为它已经被绑定了。</span><span class="hljs-built_in">setInterval</span>(doubler.<span class="hljs-property">increment</span>, <span class="hljs-number">1000</span>)</code></pre></div><p>Action(fn)</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observable, action &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">observable</span>(&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">action</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;    state.<span class="hljs-property">value</span>++    state.<span class="hljs-property">value</span>++&#125;)<span class="hljs-title function_">increment</span>(state)</code></pre></div><p>runInAction</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; observable, runInAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">observable</span>(&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">runInAction</span>(<span class="hljs-function">() =&gt;</span> &#123;    state.<span class="hljs-property">value</span>++    state.<span class="hljs-property">value</span>++&#125;)</code></pre></div><h3 id="使用-action-包装函数"><a href="#使用-action-包装函数" class="headerlink" title="使用 action 包装函数"></a>使用 <code>action</code> 包装函数</h3><p>为了尽可能地利用 MobX 的事务性，actions 应该尽可能被传到外围。如果一个类方法会修改 state，可以将其标记为 action。把事件处理函数标记为 actions 就更好了，因为最外层的事务起着决定性作用。一个未被标记的、会接着调用两个 actions 的事件处理函数仍然将会生成两个事务。</p><p>为了帮助创建基于 action 的事件处理函数，<code>action</code> 不仅仅是一个注解，更是一个高阶函数。可以使用函数将它作为一个参数来调用，在这种情况下它将会返回一个有着相同签名的使用 <code>action</code> 包装过的函数。</p><p>例如在 React 中，可以按照下面的方式包装 <code>onClick</code> 事件处理函数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ResetButton</span> = (<span class="hljs-params">&#123; formState &#125;</span>) =&gt; (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;action(e</span> =&gt;</span> &#123;</span><span class="language-xml">            formState.resetPendingUploads()</span><span class="language-xml">            formState.resetValues()</span><span class="language-xml">            e.stopPropagation()</span><span class="language-xml">        &#125;)&#125;</span><span class="language-xml">    &gt;</span><span class="language-xml">        Reset form</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>)</code></pre></div><p>为了更好的调试体验，我们推荐为被包装的函数命名，或者将名称作为 <code>action</code> 的第一个参数进行传递    </p><p><strong>注意：actions不会被跟踪</strong>，就是不能触发autorun</p><p>actions 的另一个特征是它们是 <a href="https://zh.mobx.js.org/api.html#untracked">不可追踪</a> 的。当从副作用或者计算值（非常罕见）中调用 action 时，该 action 读取的可观察对象将不会算作该 derivation 的依赖项。</p><p><code>makeAutoObservable</code>，<code>extendObservable</code> 和 <code>observable</code> 使用一种特殊的 <code>action</code>， 叫做 <code>autoAction</code>， 它会在运行时确定函数是 derivation 还是 action。</p><h3 id="action-bound"><a href="#action-bound" class="headerlink" title="action.bound"></a><code>action.bound</code></h3><p>用法：</p><ul><li><code>action.bound</code> <em>（注解）</em></li></ul><p><code>action.bound</code> 注解可用于将方法自动绑定到正确的实例，这样 <code>this</code> 会始终被正确绑定在函数内部</p><p>使用makeAutoObservable(o,{},{autoBind:true}) 自动绑定所有的actions和flow</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Doubler</span> &#123;    value = <span class="hljs-number">0</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123;&#125;, &#123; <span class="hljs-attr">autoBind</span>: <span class="hljs-literal">true</span> &#125;)    &#125;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>++    &#125;        *<span class="hljs-title function_">flow</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;http://example.com/value&quot;</span>)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-keyword">yield</span> response.<span class="hljs-title function_">json</span>()    &#125;&#125;</code></pre></div><h3 id="runInAction"><a href="#runInAction" class="headerlink" title="runInAction"></a><code>runInAction</code></h3><p>用法：</p><ul><li><code>runInAction(fn)</code></li></ul><p>使用这个工具函数来创建一个会被立即调用的临时 action。在异步进程中非常有用。 </p><h3 id="Actions-和继承"><a href="#Actions-和继承" class="headerlink" title="Actions 和继承"></a>Actions 和继承</h3><p>只有定义在<strong>原型</strong>上的函数可以被子类<strong>覆盖</strong>：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;    <span class="hljs-comment">// on instance class filed</span>    arrowAction = <span class="hljs-function">() =&gt;</span> &#123;&#125;    <span class="hljs-comment">// on prototype</span>    <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) &#123;&#125;    <span class="hljs-title function_">boundAction</span>(<span class="hljs-params"></span>) &#123;&#125;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">arrowAction</span>: action            <span class="hljs-attr">action</span>: action,            <span class="hljs-attr">boundAction</span>: action.<span class="hljs-property">bound</span>,        &#125;)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;    <span class="hljs-comment">// THROWS: TypeError: Cannot redefine property: arrowAction</span>    arrowAction = <span class="hljs-function">() =&gt;</span> &#123;&#125;    <span class="hljs-comment">// OK</span>    <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) &#123;&#125;    <span class="hljs-title function_">boundAction</span>(<span class="hljs-params"></span>) &#123;&#125;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">super</span>()        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">arrowAction</span>: override,            <span class="hljs-attr">action</span>: override,            <span class="hljs-attr">boundAction</span>: override,        &#125;)    &#125;&#125;</code></pre></div><p>想要将单个的 <em>action</em> <strong>绑定</strong> 到 <code>this</code>，可以使用 <code>action.bound</code> 代替箭头函数</p><h3 id="异步-actions"><a href="#异步-actions" class="headerlink" title="异步 actions"></a>异步 actions</h3><p>从本质上讲，异步进程在 MobX 中不需要任何特殊处理，因为不论是何时引发的所有 reactions 都将会自动更新。 而且因为可观察对象是可变的，因此在 action 执行过程中保持对它们的引用一般是安全的。 然而，在异步进程中更新可观察对象的每个步骤（tick）都应该被标识为 <code>action</code>。 我们可以通过利用上述的 API 以多种方式实现这一点，如下所示。</p><p>例如，在处理 Promise 时，更新 state 的处理程序应该被 <code>action</code> 包装起来，或者被标记为 actions，如下所示。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span> 的决议处理程序是我们以内联的方式处理的，但是会在一开始的 action 执行完成之后运行，因此需要使用 action 对它们进行包装：<span class="hljs-keyword">import</span> &#123; action, makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;    githubProjects = []    state = <span class="hljs-string">&quot;pending&quot;</span> <span class="hljs-comment">// &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-title function_">fetchGithubProjectsSomehow</span>().<span class="hljs-title function_">then</span>(            <span class="hljs-title function_">action</span>(<span class="hljs-string">&quot;fetchSuccess&quot;</span>, <span class="hljs-function"><span class="hljs-params">projects</span> =&gt;</span> &#123;                <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)                <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span>            &#125;),            <span class="hljs-title function_">action</span>(<span class="hljs-string">&quot;fetchError&quot;</span>, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span>            &#125;)        )    &#125;&#125;</code></pre></div><p>如果 Promise 的处理函数是类的字段，它们将由 <code>makeAutoObservable</code> 自动包装为 <code>action</code>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;    githubProjects = []    state = <span class="hljs-string">&quot;pending&quot;</span> <span class="hljs-comment">// &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-title function_">fetchGithubProjectsSomehow</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">projectsFetchSuccess</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">projectsFetchFailure</span>)    &#125;    projectsFetchSuccess = <span class="hljs-function"><span class="hljs-params">projects</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span>    &#125;    projectsFetchFailure = <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span>    &#125;&#125;</code></pre></div><p><code>await</code> 之后的任何操作都不与其同在一个 tick 中，因此它们需要使用 action 包装。 在这里，我们可以利用 <code>runInAction</code>：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; runInAction, makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;    githubProjects = []    state = <span class="hljs-string">&quot;pending&quot;</span> <span class="hljs-comment">// &quot;pending&quot;, &quot;done&quot; or &quot;error&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchGithubProjectsSomehow</span>()            <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)            <span class="hljs-title function_">runInAction</span>(<span class="hljs-function">() =&gt;</span> &#123;                <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span>            &#125;)        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-title function_">runInAction</span>(<span class="hljs-function">() =&gt;</span> &#123;                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span>            &#125;)        &#125;    &#125;&#125;</code></pre></div><p>使用flow+generator</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; flow, makeAutoObservable, flowResult &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;    githubProjects = []    state = <span class="hljs-string">&quot;pending&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">fetchProjects</span>: flow        &#125;)    &#125;    <span class="hljs-comment">// 注意星号, 这是一个 generator 函数!</span>    *<span class="hljs-title function_">fetchProjects</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = []        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// Yield 代替 await.</span>            <span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetchGithubProjectsSomehow</span>()            <span class="hljs-keyword">const</span> filteredProjects = <span class="hljs-title function_">somePreprocessing</span>(projects)            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;done&quot;</span>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">githubProjects</span> = filteredProjects        &#125; <span class="hljs-keyword">catch</span> (error) &#123;            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;error&quot;</span>        &#125;    &#125;&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>()<span class="hljs-keyword">const</span> projects = <span class="hljs-keyword">await</span> <span class="hljs-title function_">flowResult</span>(store.<span class="hljs-title function_">fetchProjects</span>())</code></pre></div><h2 id="Computers"><a href="#Computers" class="headerlink" title="Computers"></a>Computers</h2><p>使用：</p><ul><li><code>computed</code> <em>（注解）</em></li><li><code>computed(options)</code> <em>（注解）</em></li><li><code>computed(fn, options?)</code></li></ul><p>计算值可以用来从其他可观察对象中派生信息。 计算值采用惰性求值，会缓存其输出，并且只有当其依赖的可观察对象被改变时才会重新计算。 它们在不被任何值观察时会被暂时停用。</p><p>计算值可以通过在 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">getters</a> 上添加 <code>computed</code> 注解来创建。 使用 <code>makeObservable</code> 将 getter 声明为 computed。或者如果你希望所有的 getters 被自动声明为 <code>computed</code>，可以使用 <code>makeAutoObservable</code>，<code>observable</code> 或者 <code>extendObservable</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeObservable, observable, computed, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderLine</span> &#123;    price = <span class="hljs-number">0</span>    amount = <span class="hljs-number">1</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">price</span>) &#123;        <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>, &#123;            <span class="hljs-attr">price</span>: observable,            <span class="hljs-attr">amount</span>: observable,            <span class="hljs-attr">total</span>: computed        &#125;)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">total</span>() &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Computing...&quot;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">amount</span>    &#125;&#125;<span class="hljs-keyword">const</span> order = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderLine</span>(<span class="hljs-number">0</span>)<span class="hljs-keyword">const</span> stop = <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Total: &quot;</span> + order.<span class="hljs-property">total</span>)&#125;)<span class="hljs-comment">// Computing...</span><span class="hljs-comment">// Total: 0</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(order.<span class="hljs-property">total</span>)<span class="hljs-comment">// (不会重新计算!)</span><span class="hljs-comment">// 0</span>order.<span class="hljs-property">amount</span> = <span class="hljs-number">5</span><span class="hljs-comment">// Computing...</span><span class="hljs-comment">// (无需 autorun)</span>order.<span class="hljs-property">price</span> = <span class="hljs-number">2</span><span class="hljs-comment">// Computing...</span><span class="hljs-comment">// Total: 10</span><span class="hljs-title function_">stop</span>()order.<span class="hljs-property">price</span> = <span class="hljs-number">3</span><span class="hljs-comment">// 计算值和 autorun 都不会被重新计算.</span></code></pre></div><p>相比之下，如果 <code>total</code> 没有被注解，那么 <code>autorun</code> 会把副作用运行 3 次， 因为它将直接依赖于 <code>total</code> 和 <code>amount</code></p><p><img src="https://zh.mobx.js.org/assets/computed-example.png" alt="computed graph"></p><p>上图是为以上示例创建的依赖图。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>使用计算值时，请遵循下面的最佳实践：</p><ol><li>它们不应该有副作用或者更新其他可观察对象。</li><li>避免创建和返回新的可观察对象。</li><li>它们不应该依赖非可观察对象的值</li></ol><h2 id="使用-reactions-处理副作用-🚀"><a href="#使用-reactions-处理副作用-🚀" class="headerlink" title="使用 reactions 处理副作用 {🚀}"></a>使用 reactions 处理副作用 {🚀}</h2><p>为了理解 MobX，让我们看一下如何创建 reactions。 最简单的方式是使用 <a href="https://zh.mobx.js.org/reactions.html#autorun"><code>autorun</code></a> 工具函数。 除此之外，还有 <a href="https://zh.mobx.js.org/reactions.html#reaction"><code>reaction</code></a> 和 <a href="https://zh.mobx.js.org/reactions.html#when"><code>when</code></a></p><h3 id="Autorun"><a href="#Autorun" class="headerlink" title="Autorun"></a>Autorun</h3><p>用法：</p><ul><li><code>autorun(effect: (reaction) =&gt; void)</code></li></ul><p><code>autorun</code> 函数接受一个函数作为参数，每当该函数所观察的值发生变化时，它都应该运行。 当你自己创建 <code>autorun</code> 时，它也会运行一次。它仅仅对可观察状态的变化做出响应，比如那些你用 <code>observable</code> 或者 <code>computed</code> 注释的。</p><h3 id="tracking-如何工作"><a href="#tracking-如何工作" class="headerlink" title="tracking 如何工作"></a>tracking 如何工作</h3><p>Autorun 通过在<em>响应式上下文</em>运行 <code>effect</code> 来工作。在给定的函数执行期间，MobX 会持续跟踪被 effect 直接或间接<em>读取</em>过的所有可观察对象和计算值。 一旦函数执行完毕，MobX 将收集并订阅所有被读取过的可观察对象，并等待其中任意一个再次发生改变。 一旦有改变发生，<code>autorun</code> 将会再次触发，重复整个过程。</p><p><img src="https://zh.mobx.js.org/assets/autorun.png" alt="autorun"></p><p>这就是下面的示例的工作方式。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; makeAutoObservable, autorun &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;    name    energyLevel    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> = <span class="hljs-number">100</span>        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">reduceEnergy</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> -= <span class="hljs-number">10</span>    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">isHungry</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> &lt; <span class="hljs-number">50</span>    &#125;&#125;<span class="hljs-keyword">const</span> giraffe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Gary&quot;</span>)<span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Energy level:&quot;</span>, giraffe.<span class="hljs-property">energyLevel</span>)&#125;)<span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (giraffe.<span class="hljs-property">isHungry</span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now I&#x27;m hungry!&quot;</span>)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I&#x27;m not hungry!&quot;</span>)    &#125;&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now let&#x27;s change state!&quot;</span>)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    giraffe.<span class="hljs-title function_">reduceEnergy</span>()&#125;</code></pre></div><p>运行上面的代码，你将会看到下面的输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">100</span><span class="hljs-attribute">I</span>&#x27;m not hungry!<span class="hljs-attribute">Now</span> let&#x27;s change state!<span class="hljs-attribute">Energy</span> level: <span class="hljs-number">90</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">80</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">70</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">60</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">50</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">40</span><span class="hljs-attribute">Now</span> I&#x27;m hungry!<span class="hljs-attribute">Energy</span> level: <span class="hljs-number">30</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">20</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">10</span><span class="hljs-attribute">Energy</span> level: <span class="hljs-number">0</span></code></pre></div><p>autorun会比较前后值是否发生了改变，如果没有发生改变，就不会执行，当值发生变化的时候，才会重新执行</p><h3 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h3><p>用法：</p><ul><li><code>reaction(() =&gt; value, (value, previousValue, reaction) =&gt; &#123; sideEffect &#125;, options?)</code>.</li></ul><p>第一个参数，是指需要监听那个state的变化，第二个参数是当数据变化的时候需要执行的函数，reaction</p><p>和autorun比较，autorun是针对所有的state，reaction是针对特定的state，而且reaction在初始化，不会执行，只有在state</p><p>发生变化时才会执行</p><p>在下面的例子中，reaction 只会在 <code>isHungry</code> 发生改变时被触发一次。 在 <em>effect</em> 函数中使用的 <code>giraffe.energyLevel</code> 的更改，并不会触发 <em>effect</em> 函数。如果你想要 <code>reaction</code> 也对这个值的变化做出反应， 你需要在 <em>data</em> 函数中访问并返回它。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; makeAutoObservable, reaction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;    name    energyLevel    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> = <span class="hljs-number">100</span>        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">reduceEnergy</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> -= <span class="hljs-number">10</span>    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">isHungry</span>() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">energyLevel</span> &lt; <span class="hljs-number">50</span>    &#125;&#125;<span class="hljs-keyword">const</span> giraffe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Gary&quot;</span>)<span class="hljs-title function_">reaction</span>(    <span class="hljs-function">() =&gt;</span> giraffe.<span class="hljs-property">isHungry</span>,    <span class="hljs-function"><span class="hljs-params">isHungry</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (isHungry) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now I&#x27;m hungry!&quot;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I&#x27;m not hungry!&quot;</span>)        &#125;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Energy level:&quot;</span>, giraffe.<span class="hljs-property">energyLevel</span>)    &#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Now let&#x27;s change state!&quot;</span>)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    giraffe.<span class="hljs-title function_">reduceEnergy</span>()&#125;</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs pf">Now let&#x27;s change <span class="hljs-keyword">state</span>!Now I&#x27;m hungry!Energy level: <span class="hljs-number">40</span></code></pre></div><h3 id="When"><a href="#When" class="headerlink" title="When"></a>When</h3><p>使用：</p><ul><li><code>when(predicate: () =&gt; boolean, effect?: () =&gt; void, options?)</code></li><li><code>when(predicate: () =&gt; boolean, options?): Promise</code></li></ul><p><code>when</code> 会观察并运行给定的 <em>predicate</em> 函数，直到其返回 <code>true</code>。 一旦 predicate 返回了 true，给定的 <em>effect</em> 函数就会执行并且自动执行器函数将会被清理掉。</p><p>如果你没有传入 <code>effect</code> 函数，<code>when</code> 函数返回一个 <code>Promise</code> 类型的 disposer，并允许你手动取消</p><p><code>when</code> 对于以响应式的方式将值清理或取消掉十分有用。 例如：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; when, makeAutoObservable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span> &#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>, &#123; <span class="hljs-attr">dispose</span>: <span class="hljs-literal">false</span> &#125;)        <span class="hljs-title function_">when</span>(            <span class="hljs-comment">// Once...</span>            <span class="hljs-function">() =&gt;</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isVisible</span>,            <span class="hljs-comment">// ... then.</span>            <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispose</span>()        )    &#125;    <span class="hljs-keyword">get</span> <span class="hljs-title function_">isVisible</span>() &#123;        <span class="hljs-comment">// 表示此项目是否可见.</span>    &#125;    <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 清理一些资源.</span>    &#125;&#125;</code></pre></div><p>一旦 <code>isVisible</code> 变成 <code>false</code>，<code>dispose</code> 方法将会被调用， 并对 <code>MyResource</code> 做一些清理操作</p><h3 id="await-when"><a href="#await-when" class="headerlink" title="await when(...)"></a><code>await when(...)</code></h3><p>如果你没有提供 <code>effect</code> 函数，<code>when</code> 将会返回一个 <code>Promise</code>。这样会跟 <code>async / await</code> 很好地结合在一起，让你可以等待可观察对象中的变化。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">await</span> <span class="hljs-title function_">when</span>(<span class="hljs-function">() =&gt;</span> that.<span class="hljs-property">isVisible</span>)    <span class="hljs-comment">// etc...</span>&#125;</code></pre></div><p>如果要提前取消 <code>when</code>，可以对它返回的 Promise 调用 <code>.cancel()</code> 函数。</p><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><p>这里是一些 reactive context 需要遵守的规则：</p><ol><li>默认情况下，如果可观察对象发生了改变，受其影响的 reactions 会立即（同步）运行。然而，它们直到当前最外层的 (trans)action 执行结束后才会运行。</li><li>autorun 只会跟踪给定函数在同步执行过程中所读取的可观察对象，不会跟踪异步发生的变化。</li><li>autorun 不会跟踪被其调用的 action 所读取的可观察对象，因为 action 始终<em>不会被追踪</em>。</li></ol><h3 id="Always-dispose-of-reactions"><a href="#Always-dispose-of-reactions" class="headerlink" title="Always dispose of reactions"></a>Always dispose of reactions</h3><p>传递给 <code>autorun</code>，<code>reaction</code> 和 <code>when</code> 的函数只有在它们观察的所有对象都被 GC 之后才会被 GC。原则上，它们一直等待可观察对象发生新的变化。 为了阻止 reactions 永远地等待下去，它们总是会返回一个 disposer 函数，该函数可以用来停止执行并且取消订阅所使用的任何可观察对象</p><div class="code-wrapper"><pre><code class="hljs arcade">const counter = observable(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-comment">// 初始化一个 autorun 并且打印 0.</span>const disposer = autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(counter.<span class="hljs-built_in">count</span>)&#125;)<span class="hljs-comment">// 打印: 1</span>counter.<span class="hljs-built_in">count</span>++<span class="hljs-comment">// 停止 autorun.</span>disposer()<span class="hljs-comment">// 不会打印消息.</span>counter.<span class="hljs-built_in">count</span>++</code></pre></div><p>我们强烈建议你，一旦不再需要这些方法中的副作用时，请务必调用它们所返回的 disposer 函数。 否则可能导致内存泄漏。</p><p><code>reaction</code> 和 <code>autorun</code> 中 effect 函数的第二个参数 <code>reaction</code> 也可以被用来提前把 reaction 清理掉（通过调用 <code>reaction.dispose()</code>）。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vat</span> &#123;    value = <span class="hljs-number">1.2</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)    &#125;&#125;<span class="hljs-keyword">const</span> vat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vat</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderLine</span> &#123;    price = <span class="hljs-number">10</span>    amount = <span class="hljs-number">1</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">makeAutoObservable</span>(<span class="hljs-variable language_">this</span>)        <span class="hljs-comment">// 这个 autorun 将会和本 OrderLine 实例一起进行 GC,</span>        <span class="hljs-comment">// 因为它只使用了来自 `this` 的可观察对象.</span>        <span class="hljs-comment">// 所以不一定非要在删除 OrderLine 实例后立刻把它清理掉。</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disposer1</span> = <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">doSomethingWith</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">amount</span>)        &#125;)        <span class="hljs-comment">// 这个 autorun 将不会和本 OrderLine 实例一起进行 GC,</span>        <span class="hljs-comment">// 因为 vat 保存了对这个 autorun 的引用用于通知改变,</span>        <span class="hljs-comment">// 这样反过来又会把 &#x27;this&#x27; 保存在作用域中。</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">disposer2</span> = <span class="hljs-title function_">autorun</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">doSomethingWith</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">amount</span> * vat.<span class="hljs-property">value</span>)        &#125;)    &#125;    <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 所以, 为了避免内存问题, 当不再需要 reactions 之后</span>        <span class="hljs-comment">// 务必要调用 disposers.</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">disposer1</span>()        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">disposer2</span>()    &#125;&#125;</code></pre></div><h2 id="谨慎地使用-reactions！"><a href="#谨慎地使用-reactions！" class="headerlink" title="谨慎地使用 reactions！"></a>谨慎地使用 reactions！</h2><p>就像上面已经说过的那样，你不会经常创建 reactions。 很有可能你的应用程序不会直接使用这些 API 中的任何一个，而只会通过比如使用 mobx-react 绑定中的 <code>observer</code> 这样间接的方式创建出 reaction。</p><p>在你创建 reaction 之前，最好检查一下它是否符合下面几条原则：</p><ol><li><strong>只有在引起副作用的一方与副作用之间没有直接关系的情况下才使用 reaction</strong>： 如果一个副作用会为了响应很小的一组 events 或 actions 而执行，那么直接从那些特定的 action 中触发这个副作用通常会更容易理解。例如，如果按下表单提交按钮会导致一个 POST 网络请求的发送，那么为了响应 <code>onclick</code> 事件，直接触发这个副作用就会比通过 reaction 间接触发更容易理解。相比之下，如果你对表单状态的一切修改最后都会被自动存储到 localStorage，那么使用一个 reaction 可能就会很有帮助，这样你就不用在每个独立的 <code>onChange</code> 事件中触发这个副作用了。</li><li><strong>reactions 不应该更新其他可观察对象</strong>：这个 reaction 是否会修改其他可观察对象？如果答案是肯定的，那么你一般应该把你想要更新的可观察对象注解为 <a href="https://zh.mobx.js.org/computeds.html"><code>computed</code></a> 值。例如，如果一个待办事项的集合 <code>todos</code> 发生了变化，那么请不要使用 reaction 来计算剩余待办 <code>remainingTodos</code> 的数量，而要把 <code>remainingTodos</code> 注解为计算值。这将使得代码更容易理解和调试。reaction 不应该计算生成新的数据，而只应该触发副作用。</li><li><strong>reactions 应该是独立的</strong>：你的代码是否依赖其他必须首先运行的 reaction？如果发生这种情况，你可能违反了第一条规则， 你可以选择将你需要创建的新 reaction 合并到它所依赖 reaction 中。MobX 并不能保证 reaction 的执行顺序。</li></ol><p>有些实践并不符合上述原则。这就是为什么它们是<em>原则</em>，而不是<em>法则</em>。 但是，例外情况很少见，只有在万不得已的情况下才违反它们。</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>mobx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>jest常见问题解析</title>
    <link href="/2022/09/19/jest%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/19/jest%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h4 id="jest-‘beforeEach’-is-not-defined-eslint-no-undef"><a href="#jest-‘beforeEach’-is-not-defined-eslint-no-undef" class="headerlink" title="##jest ‘beforeEach’ is not defined .eslint no-undef"></a>##jest ‘beforeEach’ is not defined .eslint no-undef</h4><p><img src="https://img1.imgtp.com/2022/09/19/mkE2sSaP.png" alt="QQ截图20220919211238.png"></p><p>需要在.eslintrc文件加上这一段</p><div class="code-wrapper"><pre><code class="hljs prolog">&#123;  <span class="hljs-string">&quot;overrides&quot;</span>: [    &#123;      <span class="hljs-string">&quot;files&quot;</span>: [        <span class="hljs-string">&quot;**/*.spec.js&quot;</span>,        <span class="hljs-string">&quot;**/*.spec.jsx&quot;</span>      ],      <span class="hljs-string">&quot;env&quot;</span>: &#123;        <span class="hljs-string">&quot;jest&quot;</span>: true      &#125;    &#125;  ]&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>单元测试</category>
      
      <category>jest</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第六章链表</title>
    <link href="/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AD%E7%AB%A0%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E5%85%AD%E7%AB%A0%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="Util-js"><a href="#Util-js" class="headerlink" title="Util.js"></a>Util.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 对两个数值进行浅层比较</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultEquals</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a === b;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultToString</span>(<span class="hljs-params">item</span>) &#123;  <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">null</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item === <span class="hljs-literal">undefined</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;undefined&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span> || item <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>`</span>;  &#125;  <span class="hljs-keyword">return</span> item.<span class="hljs-title function_">toString</span>();&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Compare</span> = &#123;  <span class="hljs-attr">LESS_THAN</span>: -<span class="hljs-number">1</span>,  <span class="hljs-attr">BIGGER_THAN</span>: <span class="hljs-number">1</span>,&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">defaultCompare</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">if</span> (a === b) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span> : <span class="hljs-title class_">Compare</span>.<span class="hljs-property">BIGGER_THAN</span>;&#125;</code></pre></div><h2 id="linked-list-models-js"><a href="#linked-list-models-js" class="headerlink" title="linked-list-models.js"></a>linked-list-models.js</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义每个节点的信息</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">undefined</span>;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element, next, prev</span>) &#123;    <span class="hljs-variable language_">super</span>(element, next);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = prev;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePair</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">key, value</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">`[<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.key&#125;</span>,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.value&#125;</span>]`</span>;  &#125;&#125;</code></pre></div><h2 id="普通链表"><a href="#普通链表" class="headerlink" title="普通链表"></a>普通链表</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defaultEquals &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Node</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">equalFn = defaultEquals</span>) &#123;    <span class="hljs-comment">// 用来存储链表中的元素数量</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-comment">//自定义 用来比较是否相等 如果没有定义则使用默认的比较方法</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">equalFn</span> = equalFn;  &#125;  <span class="hljs-comment">//向链表尾部添加一个新元素</span>  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);    <span class="hljs-comment">// 先判断链表为空的情况</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">undefined</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-comment">// 循环找到最后一个节点</span>      <span class="hljs-keyword">while</span> (current.<span class="hljs-property">next</span> != <span class="hljs-literal">null</span>) &#123;        current = current.<span class="hljs-property">next</span>;      &#125;      current.<span class="hljs-property">next</span> = node;    &#125;    <span class="hljs-comment">// 数值加一</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;  &#125;  <span class="hljs-comment">// 向链表的特定位置插入一个新元素</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">element, position</span>) &#123;    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">const</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;        node.<span class="hljs-property">next</span> = current;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(position - <span class="hljs-number">1</span>);        <span class="hljs-keyword">const</span> current = previous.<span class="hljs-property">next</span>;        previous.<span class="hljs-property">next</span> = node;        node.<span class="hljs-property">next</span> = current;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 返回链表中特定位置的元素。如果链表中不存在这样的元素，则返回 undefined</span>  <span class="hljs-title function_">getElementAt</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index &amp;&amp; current != <span class="hljs-literal">null</span>; i++) &#123;      current = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> current;  &#125;  <span class="hljs-comment">// 从链表中移除一个元素</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">const</span> currentIndex = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">indexOf</span>(element);    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeAt</span>(currentIndex);  &#125;  <span class="hljs-comment">// 返回元素在链表中的索引。如果链表中没有该元素则返回-1</span>  <span class="hljs-title function_">indexOf</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &amp;&amp; current != <span class="hljs-literal">null</span>; i++) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">equalFn</span>(element, current.<span class="hljs-property">element</span>)) &#123;        <span class="hljs-keyword">return</span> i;      &#125;      current = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  &#125;  <span class="hljs-comment">// 从链表的特定位置移除一个元素</span>  <span class="hljs-title function_">removeAt</span>(<span class="hljs-params">position</span>) &#123;    <span class="hljs-comment">// 边界判断</span>    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> || position &lt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">let</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-comment">// 当是第一个值时</span>    <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = current.<span class="hljs-property">next</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// for循环拿到curent</span>      <span class="hljs-comment">// for (let i = 0; i &lt; position; i++) &#123;</span>      <span class="hljs-comment">//   /**</span>      <span class="hljs-comment">//    * 获得之前的值，当到达目标值的时候，current.next就指向下一个值了，previous指向前一个之</span>      <span class="hljs-comment">//    */</span>      <span class="hljs-comment">//   previous = current;</span>      <span class="hljs-comment">//   current = current.next;</span>      <span class="hljs-comment">// &#125;</span>      <span class="hljs-comment">// 重构</span>      previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(position - <span class="hljs-number">1</span>);      current = previous.<span class="hljs-property">next</span>;      previous.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;    <span class="hljs-keyword">return</span> current.<span class="hljs-property">element</span>;  &#125;  <span class="hljs-comment">// 如果链表中不包含任何元素，返回 true，如果链表长度大于 0则返回 false</span>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 返回链表包含的元素个数，与数组的 length 属性类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>;  &#125;  <span class="hljs-comment">// 返回表示整个链表的字符串。由于列表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值</span>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;    <span class="hljs-keyword">let</span> objString = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.head.element&#125;</span>`</span>;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &amp;&amp; current != <span class="hljs-literal">null</span>; i++) &#123;      objString += <span class="hljs-string">`,<span class="hljs-subst">$&#123;current.element&#125;</span>`</span>;      current = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> objString;  &#125;&#125;</code></pre></div><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">DoublyNode</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../linked-list-models.js&quot;</span>;<span class="hljs-keyword">import</span> &#123; defaultEquals &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util.js&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./LinkedList.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">equalsFn = defaultEquals</span>) &#123;    <span class="hljs-variable language_">super</span>(equalsFn);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">undefined</span>;  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">element, index</span>) &#123;    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyNode</span>(element);      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (thid.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = node;        &#125; <span class="hljs-keyword">else</span> &#123;          node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;          current.<span class="hljs-property">prev</span> = node;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;        &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;        current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;        current.<span class="hljs-property">next</span> = node;        node.<span class="hljs-property">prev</span> = current;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = node;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index - <span class="hljs-number">1</span>);        current = previous.<span class="hljs-property">next</span>;        previous.<span class="hljs-property">next</span> = node;        node.<span class="hljs-property">prev</span> = previous;        node.<span class="hljs-property">next</span> = current;        current.<span class="hljs-property">prev</span> = node;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> falses;  &#125;  <span class="hljs-title function_">removeAt</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = current.<span class="hljs-property">next</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">1</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">undefined</span>;        &#125; <span class="hljs-keyword">else</span> &#123;          current.<span class="hljs-property">prev</span> = <span class="hljs-literal">undefined</span>;        &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>)) &#123;        current = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index);        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = current.<span class="hljs-property">prev</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">undefined</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        current = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index);        current.<span class="hljs-property">prev</span>.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;        current.<span class="hljs-property">next</span>.<span class="hljs-property">prev</span> = current.<span class="hljs-property">prev</span>;        current.<span class="hljs-property">next</span> = <span class="hljs-literal">undefined</span>;        current.<span class="hljs-property">prev</span> = <span class="hljs-literal">undefined</span>;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;      <span class="hljs-keyword">return</span> current.<span class="hljs-property">element</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;&#125;</code></pre></div><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defaultEquals &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./LinkedList.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularLinkedList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">equalsFn = defaultEquals</span>) &#123;    <span class="hljs-variable language_">super</span>(equalsFn);  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">element, index</span>) &#123;    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>) &#123;      <span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-literal">null</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;          node.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node;          current = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>());          current.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index - <span class="hljs-number">1</span>);        current = previous.<span class="hljs-property">next</span>;        previous.<span class="hljs-property">next</span> = node;        node.<span class="hljs-property">next</span> = currents;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-title function_">removeAt</span>(<span class="hljs-params">index</span>) &#123;    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>()) &#123;      <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;      <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>() === <span class="hljs-number">1</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">const</span> removed = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;          current = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>());          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>.<span class="hljs-property">next</span>;          current.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;          current = removed;        &#125;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">const</span> previous = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getElementAt</span>(index - <span class="hljs-number">1</span>);        current = previous.<span class="hljs-property">next</span>;        previous.<span class="hljs-property">next</span> = current.<span class="hljs-property">next</span>;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;      <span class="hljs-keyword">return</span> current.<span class="hljs-property">element</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;  &#125;&#125;</code></pre></div><h2 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Compare</span>, defaultCompare, defaultEquals &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util&quot;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">LinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./LinkedList.js&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortLinkedList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">equalsFn = defaultEquals, compareFn = defaultCompare</span>) &#123;    <span class="hljs-variable language_">super</span>(equalsFn);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compareFn</span> = compareFn;  &#125;  <span class="hljs-title function_">insert</span>(<span class="hljs-params">element, index = <span class="hljs-number">0</span></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>().<span class="hljs-title function_">insert</span>(element, index);    &#125;    <span class="hljs-keyword">const</span> position = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getIndexNextSortedElement</span>(element);    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>().<span class="hljs-title function_">insert</span>(element, position);  &#125;  <span class="hljs-title function_">getIndexNextSortedElement</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">let</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">size</span>(); i++) &#123;      <span class="hljs-keyword">const</span> comp = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compareFn</span>(element, current.<span class="hljs-property">element</span>);      <span class="hljs-keyword">if</span> (comp === <span class="hljs-title class_">Compare</span>.<span class="hljs-property">LESS_THAN</span>) &#123;        <span class="hljs-keyword">return</span> i;      &#125;      current = current.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> i;  &#125;&#125;</code></pre></div><h2 id="通过链表创建栈"><a href="#通过链表创建栈" class="headerlink" title="通过链表创建栈"></a>通过链表创建栈</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">DoublyLinkedList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./DoublyLinkedList&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackLinkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyLinkedList</span>();  &#125;  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">push</span>(element);  &#125;  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">removeAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">size</span>() - <span class="hljs-number">1</span>);  &#125;  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">getElementAt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">size</span>() - <span class="hljs-number">1</span>);  &#125;  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">isEmpty</span>();  &#125;  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">size</span>();  &#125;  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">clear</span>();  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>.<span class="hljs-title function_">toString</span>();  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）第五章 队列与双端队列</title>
    <link href="/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/09/17/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h4 id="队列和双端队列"><a href="#队列和双端队列" class="headerlink" title="##队列和双端队列"></a>##队列和双端队列</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 首先需要一个用于存储队列中元素的数据结构。我们可以使用数组，就像上一章的 Stack</span><span class="hljs-comment">类那样。但是，为了写出一个在获取元素时更高效的数据结构，我们将使用一个对象来存储我们</span><span class="hljs-comment">的元素（行&#123;3&#125;）。你会发现 Queue 类和 Stack 类非常类似，只是添加和移除元素的原则不同</span><span class="hljs-comment">也可以声明一个 count 属性来帮助我们控制队列的大小（行&#123;1&#125;）。此外，由于我们将要从队</span><span class="hljs-comment">列前端移除元素，同样需要一个变量来帮助我们追踪第一个元素。因此，声明一个 lowestCount</span><span class="hljs-comment">变量（行&#123;2&#125;）</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-comment">// 向队列尾部添加一个（或多个）新的项</span>  <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">...elements</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elements.<span class="hljs-property">length</span>; i++) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>] = elements[i];      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;    &#125;  &#125;  <span class="hljs-comment">// 移除队列的第一项（即排在队列最前面的项）并返回被移除的元素</span>  <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>++;    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">// 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做</span>  <span class="hljs-comment">// 任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。该方</span>  <span class="hljs-comment">// 法在其他语言中也可以叫作 front 方法</span>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];  &#125;  <span class="hljs-comment">// 如果队列中不包含任何元素，返回 true，否则返回 false</span>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 返回队列包含的元素个数，与数组的 length 属性类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>;  &#125;  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> str;    &#125;    str = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>; i++) &#123;      str += <span class="hljs-string">`,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.items[i]&#125;</span>`</span>;    &#125;    <span class="hljs-keyword">return</span> str;  &#125;&#125;<span class="hljs-comment">// const queue = new Queue();</span><span class="hljs-comment">// console.log(queue.isEmpty()); // 输出 true</span><span class="hljs-comment">// queue.enqueue(&quot;John&quot;);</span><span class="hljs-comment">// queue.enqueue(&quot;Jack&quot;);</span><span class="hljs-comment">// console.log(queue.toString()); // John,Jack</span><span class="hljs-comment">// queue.enqueue(&quot;Camila&quot;);</span><span class="hljs-comment">// console.log(queue.toString()); // John, Jack, Camila</span><span class="hljs-comment">// console.log(queue.size()); // 输出 3</span><span class="hljs-comment">// console.log(queue.isEmpty()); // 输出 false</span><span class="hljs-comment">// queue.dequeue(); // 移除 John</span><span class="hljs-comment">// queue.dequeue(); // 移除 Jack</span><span class="hljs-comment">// console.log(queue.toString()); // Camila</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Queue</span>;</code></pre></div><h4 id="双端队列数据结构"><a href="#双端队列数据结构" class="headerlink" title="双端队列数据结构"></a>双端队列数据结构</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Deque</span> &#123;  <span class="hljs-comment">// 双端队列，遵循先进先出和后进先出</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> === <span class="hljs-number">0</span>;  &#125;  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>;  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> str;    &#125;    str = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> + <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>; i++) &#123;      str += <span class="hljs-string">`,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.items[i]&#125;</span>`</span>;    &#125;    <span class="hljs-keyword">return</span> str;  &#125;  <span class="hljs-comment">// 该方法在双端队列前端添加新的元素</span>  <span class="hljs-title function_">addFront</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addBack</span>(element);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>--;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>] = element;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i - <span class="hljs-number">1</span>];      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-number">0</span>] = element;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span> = <span class="hljs-number">0</span>;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;    &#125;  &#125;  <span class="hljs-comment">// 该方法在双端队列后端添加新的元素（实现方法和 Queue 类中的enqueue 方法相同）</span>  <span class="hljs-title function_">addBack</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>] = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;  &#125;  <span class="hljs-comment">// 该方法会从双端队列前端移除第一个元素（实现方法和 Queue 类中的dequeue 方法相同）</span>  <span class="hljs-title function_">removeFront</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>++;    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">//该方法会从双端队列后端移除第一个元素（实现方法和 Stack 类中的pop 方法一样）。</span>  <span class="hljs-title function_">removeBack</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-comment">// 该方法返回双端队列前端的第一个元素（实现方法和 Queue 类中的 peek方法一样）。</span>  <span class="hljs-title function_">peekFront</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">lowestCount</span>];  &#125;  <span class="hljs-comment">// 该方法返回双端队列后端的第一个元素（实现方法和 Stack 类中的 peek方法一样）</span>  <span class="hljs-title function_">peekBack</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];  &#125;&#125;<span class="hljs-comment">// const deque = new Deque();</span><span class="hljs-comment">// console.log(deque.isEmpty()); // 输出 true</span><span class="hljs-comment">// deque.addBack(&quot;John&quot;);</span><span class="hljs-comment">// deque.addBack(&quot;Jack&quot;);</span><span class="hljs-comment">// console.log(deque.toString()); // John, Jack</span><span class="hljs-comment">// deque.addBack(&quot;Camila&quot;);</span><span class="hljs-comment">// console.log(deque.toString()); // John, Jack, Camila</span><span class="hljs-comment">// console.log(deque.size()); // 输出 3</span><span class="hljs-comment">// console.log(deque.isEmpty()); // 输出 false</span><span class="hljs-comment">// deque.removeFront(); // 移除 John</span><span class="hljs-comment">// console.log(deque.toString()); // Jack, Camila</span><span class="hljs-comment">// deque.removeBack(); // Camila 决定离开</span><span class="hljs-comment">// console.log(deque.toString()); // Jack</span><span class="hljs-comment">// deque.addFront(&quot;John&quot;); // John 回来询问一些信息</span><span class="hljs-comment">// console.log(deque.toString()); // John, Jack</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Deque</span>;</code></pre></div><h4 id="使用队列和双端队列来解决问题"><a href="#使用队列和双端队列来解决问题" class="headerlink" title="使用队列和双端队列来解决问题"></a>使用队列和双端队列来解决问题</h4><h5 id="循环队列——击鼓传花游戏"><a href="#循环队列——击鼓传花游戏" class="headerlink" title="循环队列——击鼓传花游戏"></a>循环队列——击鼓传花游戏</h5><p>这其中的一种叫作循环队列。循环队列的一个例子就是击鼓传花游戏（hot  potato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）。</p><p>实现一个模拟的击鼓传花游戏，要用到本章开头实现的 Queue 类（行{1}）。我们会得到一 份名单，把里面的名字全都加入队列（行{2}）。给定一个数字，然后迭代队列。从队列开头移 除一项，再将其添加到队列末尾（行{3}），模拟击鼓传花（如果你把花传给了旁边的人，你被 淘汰的威胁就立刻解除了）。一旦达到给定的传递次数，拿着花的那个人就被淘汰了（从队列中 移除——行{4}）。最后只剩下一个人的时候，这个人就是胜者（行{5}）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Queue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Queue.js&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">hotPotato</span>(<span class="hljs-params">elementsList, num</span>) &#123;  <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();  <span class="hljs-keyword">const</span> elimitatedList = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; elementsList.<span class="hljs-property">length</span>; i++) &#123;    queue.<span class="hljs-title function_">enqueue</span>(elementsList[i]);  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue.<span class="hljs-title function_">toString</span>(), <span class="hljs-string">&quot;----&quot;</span>);  <span class="hljs-keyword">while</span> (queue.<span class="hljs-title function_">size</span>() &gt; <span class="hljs-number">1</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;      queue.<span class="hljs-title function_">enqueue</span>(queue.<span class="hljs-title function_">dequeue</span>());    &#125;    elimitatedList.<span class="hljs-title function_">push</span>(queue.<span class="hljs-title function_">dequeue</span>());  &#125;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">winner</span>: queue.<span class="hljs-title function_">dequeue</span>(),    <span class="hljs-attr">eliminated</span>: elimitatedList,  &#125;;&#125;<span class="hljs-keyword">const</span> names = [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Camila&quot;</span>, <span class="hljs-string">&quot;Ingrid&quot;</span>, <span class="hljs-string">&quot;Carl&quot;</span>];<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">hotPotato</span>(names, <span class="hljs-number">7</span>);result.<span class="hljs-property">eliminated</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>在击鼓传花游戏中被淘汰。`</span>);&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`胜利者： <span class="hljs-subst">$&#123;result.winner&#125;</span>`</span>);</code></pre></div><p>以上算法的输出如下。</p><p> Camila 在击鼓传花游戏中被淘汰。</p><p> Jack 在击鼓传花游戏中被淘汰。</p><p> Carl 在击鼓传花游戏中被淘汰。</p><p> Ingrid 在击鼓传花游戏中被淘汰。 </p><p> 胜利者：John</p><h5 id="回文检查器"><a href="#回文检查器" class="headerlink" title="回文检查器"></a>回文检查器</h5><p>下面是维基百科对回文的解释。 回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。 有不同的算法可以检查一个词组或字符串是否为回文。最简单的方式是将字符串反向排列并 检查它和原字符串是否相同。如果两者相同，那么它就是一个回文。我们也可以用栈来完成，但 是利用数据结构来解决这个问题的最简单方法是使用双端队列</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Deque</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Deque.js&quot;</span>;<span class="hljs-comment">// 回文字符串检测</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-params">aString</span>) &#123;  <span class="hljs-keyword">if</span> (aString == <span class="hljs-literal">null</span> || (aString != <span class="hljs-literal">null</span> &amp;&amp; aString.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 判断是否相等，不相等就返回</span>  <span class="hljs-keyword">let</span> isEqual = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 获得第一个和最后一个字符</span>  <span class="hljs-keyword">let</span> firstChar, lastChar;  <span class="hljs-keyword">const</span> deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deque</span>();  <span class="hljs-comment">// 先将字符串转成小写然后再去掉空格重新拼接</span>  aString = aString.<span class="hljs-title function_">toLocaleLowerCase</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(aString);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; aString.<span class="hljs-property">length</span>; i++) &#123;    deque.<span class="hljs-title function_">addBack</span>(aString.<span class="hljs-title function_">charAt</span>(i));  &#125;  <span class="hljs-comment">// while循环拿到第一个和最后一个进行比较，只有在isEqual为true才继续比奥,只有一个的时候跳出</span>  <span class="hljs-keyword">while</span> (deque.<span class="hljs-title function_">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; isEqual) &#123;    firstChar = deque.<span class="hljs-title function_">removeFront</span>();    lastChar = deque.<span class="hljs-title function_">removeBack</span>();    <span class="hljs-keyword">if</span> (lastChar !== firstChar) &#123;      isEqual = <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> isEqual;&#125;<span class="hljs-comment">// 全是true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;a&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;aa&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;kayak&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;kayak&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;level&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;level&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(  <span class="hljs-string">&quot;Was it a car or a cat I saw&quot;</span>,  <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;Was it a car or a cat I saw&quot;</span>));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Step on no pets&quot;</span>, <span class="hljs-title function_">palindromeChecker</span>(<span class="hljs-string">&quot;Step on no pets&quot;</span>));</code></pre></div><p>在我们开始解释算法逻辑之前，需要检查传入的字符串参数是否合法（行{1}）。如果不合 法，我们返回 false。 对于这个算法，我们将使用在本章实现的 Deque 类（行{2}）。由于可能接收到同时包含大 小写字母的字符串，我们会将所有字母转化为小写，同时移除所有的空格（行{3}）。如果你愿意， 也可以移除所有的特殊字符，例如!、?、-、(和)等。为了保证算法简洁，我们会跳过这部分。 然后，我们会对字符串中的所有字符执行 enqueue 操作（行{4}）。如果所有元素都在双端 队列中（如果只有一个字符的话，那它肯定是回文）并且首尾字符相同的话（行{5}），我们将 从前端移除一个元素（行{6}），再从后端移除一个元素（行{7}）。要使字符串为回文，移除的 两个字符必须相同。如果字符不同的话，这个字符串就不是一个回文（行{8}）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jest学习笔记</title>
    <link href="/2022/09/16/jest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/16/jest%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="Jest安装"><a href="#Jest安装" class="headerlink" title="##Jest安装"></a>##Jest安装</h4><div class="code-wrapper"><pre><code class="hljs q">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> jest</code></pre></div><h4 id="常见的匹配器"><a href="#常见的匹配器" class="headerlink" title="常见的匹配器"></a>常见的匹配器</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;two plus two is four&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">4</span>);&#125;);</code></pre></div><p><code>toBe</code>使用 <code>Object.is</code>来进行精准匹配的测试。 如果您想要检查对象的值，请使用 <code>toEqual</code> 代替：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;对象赋值&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>&#125;;  data[<span class="hljs-string">&#x27;two&#x27;</span>] = <span class="hljs-number">2</span>;  <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toEqual</span>(&#123;<span class="hljs-attr">one</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">two</span>: <span class="hljs-number">2</span>&#125;);&#125;);</code></pre></div><p><code>toEqual</code> 递归检查对象或数组的每个字段</p><h5 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h5><p>代码中的<code>undefined</code>, <code>null</code>, and <code>false</code>有不同含义，若你在测试时不想区分他们，可以用真值判断。 Jest提供helpers供你使用。</p><ul><li><code>toBeNull</code> 只匹配 <code>null</code></li><li><code>toBeUndefined</code> 只匹配 <code>undefined</code></li><li><code>toBeDefined</code> 与 <code>toBeUndefined</code> 相反</li><li><code>toBeTruthy</code> 匹配任何 <code>if</code> 语句为真</li><li><code>toBeFalsy</code> 匹配任何 <code>if</code> 语句为假</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span>;  <span class="hljs-title function_">expect</span>(n).<span class="hljs-title function_">toBeNull</span>();  <span class="hljs-title function_">expect</span>(n).<span class="hljs-title function_">toBeDefined</span>();  <span class="hljs-title function_">expect</span>(n).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeUndefined</span>();  <span class="hljs-title function_">expect</span>(n).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeTruthy</span>();  <span class="hljs-title function_">expect</span>(n).<span class="hljs-title function_">toBeFalsy</span>();&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;zero&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> z = <span class="hljs-number">0</span>;  <span class="hljs-title function_">expect</span>(z).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeNull</span>();  <span class="hljs-title function_">expect</span>(z).<span class="hljs-title function_">toBeDefined</span>();  <span class="hljs-title function_">expect</span>(z).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeUndefined</span>();  <span class="hljs-title function_">expect</span>(z).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBeTruthy</span>();  <span class="hljs-title function_">expect</span>(z).<span class="hljs-title function_">toBeFalsy</span>();&#125;);</code></pre></div><h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h5><p>大多数的比较数字有等价的匹配器</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;two plus two&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> value = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeGreaterThan</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//大于</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeGreaterThanOrEqual</span>(<span class="hljs-number">3.5</span>);<span class="hljs-comment">//大于等于</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeLessThan</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//小于</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeLessThanOrEqual</span>(<span class="hljs-number">4.5</span>);<span class="hljs-comment">//小于等于</span>  <span class="hljs-comment">// toBe and toEqual are equivalent for numbers</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">4</span>);  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toEqual</span>(<span class="hljs-number">4</span>);&#125;);</code></pre></div><p>对于比较浮点数相等，使用 <code>toBeCloseTo</code> 而不是 <code>toEqual</code>，因为你不希望测试取决于一个小小的舍入误差。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;两个浮点数字相加&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> value = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;  <span class="hljs-comment">//expect(value).toBe(0.3);           这句会报错，因为浮点数有舍入误差</span>  <span class="hljs-title function_">expect</span>(value).<span class="hljs-title function_">toBeCloseTo</span>(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// 这句可以运行</span>&#125;);&#125;);</code></pre></div><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>您可以检查对具有 <code>toMatch</code> 正则表达式的字符串︰</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;there is no I in team&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(<span class="hljs-string">&#x27;team&#x27;</span>).<span class="hljs-property">not</span>.<span class="hljs-title function_">toMatch</span>(<span class="hljs-regexp">/I/</span>);&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;but there is a &quot;stop&quot; in Christoph&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(<span class="hljs-string">&#x27;Christoph&#x27;</span>).<span class="hljs-title function_">toMatch</span>(<span class="hljs-regexp">/stop/</span>);&#125;);</code></pre></div><h5 id="数组和可迭代对象"><a href="#数组和可迭代对象" class="headerlink" title="数组和可迭代对象"></a>数组和可迭代对象</h5><p> <code>toContain</code>来检查一个数组或可迭代对象是否包含某个特定项</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> shoppingList = [  <span class="hljs-string">&#x27;diapers&#x27;</span>,  <span class="hljs-string">&#x27;kleenex&#x27;</span>,  <span class="hljs-string">&#x27;trash bags&#x27;</span>,  <span class="hljs-string">&#x27;paper towels&#x27;</span>,  <span class="hljs-string">&#x27;milk&#x27;</span>,];<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;shoppingList数组中包含milk&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(shoppingList).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">&#x27;milk&#x27;</span>);  <span class="hljs-title function_">expect</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(shoppingList)).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">&#x27;milk&#x27;</span>);&#125;);</code></pre></div><h5 id="thorw"><a href="#thorw" class="headerlink" title="thorw"></a>thorw</h5><p>你想测试某函数在调用时是否抛出了错误，你需要使用 <code>toThrow</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compileAndroidCode</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;you are using the wrong JDK&#x27;</span>);&#125;<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;compiling android goes as expected&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-title function_">expect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compileAndroidCode</span>()).<span class="hljs-title function_">toThrow</span>();  <span class="hljs-title function_">expect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compileAndroidCode</span>()).<span class="hljs-title function_">toThrow</span>(<span class="hljs-title class_">Error</span>);  <span class="hljs-comment">// 你可以自己定义确切的错误消息内容或者使用正则表达式</span>  <span class="hljs-title function_">expect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compileAndroidCode</span>()).<span class="hljs-title function_">toThrow</span>(<span class="hljs-string">&#x27;you are using the wrong JDK&#x27;</span>);  <span class="hljs-title function_">expect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">compileAndroidCode</span>()).<span class="hljs-title function_">toThrow</span>(<span class="hljs-regexp">/JDK/</span>);&#125;);</code></pre></div><h4 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h4><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>为你的测试返回一个Promise，则Jest会等待Promise的resove状态 如果 Promise 的状态变为 rejected, 测试将会失败</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the data is peanut butter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;peanut butter&#x27;</span>);  &#125;);&#125;);</code></pre></div><h5 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the data is peanut butter&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();  <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;peanut butter&#x27;</span>);&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the fetch fails with an error&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  expect.<span class="hljs-title function_">assertions</span>(<span class="hljs-number">1</span>);  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();  &#125; <span class="hljs-keyword">catch</span> (e) &#123;    <span class="hljs-title function_">expect</span>(e).<span class="hljs-title function_">toMatch</span>(<span class="hljs-string">&#x27;error&#x27;</span>);  &#125;&#125;);</code></pre></div><p>你也可以将 <code>async</code> and <code>await</code>和 <code>.resolves</code> or <code>.rejects</code>一起使用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the data is peanut butter&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">fetchData</span>()).<span class="hljs-property">resolves</span>.<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;peanut butter&#x27;</span>);&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the fetch fails with an error&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-keyword">await</span> <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">fetchData</span>()).<span class="hljs-property">rejects</span>.<span class="hljs-title function_">toMatch</span>(<span class="hljs-string">&#x27;error&#x27;</span>);&#125;);</code></pre></div><p>如果期望Promise被Reject，则需要使用 <code>.catch</code> 方法。 请确保添加 <code>expect.assertions</code> 来验证一定数量的断言被调用。 否则，一个fulfilled状态的Promise不会让测试用例失败。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the fetch fails with an error&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  expect.<span class="hljs-title function_">assertions</span>(<span class="hljs-number">1</span>);  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetchData</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-title function_">expect</span>(e).<span class="hljs-title function_">toMatch</span>(<span class="hljs-string">&#x27;error&#x27;</span>));&#125;);</code></pre></div><h5 id="测试回调函数"><a href="#测试回调函数" class="headerlink" title="测试回调函数"></a>测试回调函数</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;the data is peanut butter&#x27;</span>, <span class="hljs-function"><span class="hljs-params">done</span> =&gt;</span> &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">error, data</span>) &#123;    <span class="hljs-keyword">if</span> (error) &#123;      <span class="hljs-title function_">done</span>(error);      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;peanut butter&#x27;</span>);      <span class="hljs-title function_">done</span>();    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">done</span>(error);    &#125;  &#125;  <span class="hljs-title function_">fetchData</span>(callback);&#125;);</code></pre></div><p>测试回调函数时，需要使用done方法，不能直接传入一个函数，否则没办法测试，需要使用上上面的格式</p><h5 id="resolves-rejects"><a href="#resolves-rejects" class="headerlink" title=".resolves / .rejects"></a><code>.resolves</code> / <code>.rejects</code></h5><p>您还可以使用 <code>.resolves</code> 匹配器在您期望的声明，Jest 会等待这一 Promise 来解决。 如果 Promise 被拒绝，则测试将自动失败。</p><div class="code-wrapper"><pre><code class="hljs lisp">test(&#x27;the data is peanut butter&#x27;, () =&gt; &#123;  return expect(<span class="hljs-name">fetchData</span>()).resolves.toBe(&#x27;peanut butter&#x27;)<span class="hljs-comment">;</span>&#125;)<span class="hljs-comment">;</span></code></pre></div><p>必须要使用return，在 <code>fetchData</code> 返回的这个 promise 变更为 resolved 状态、then() 有机会执行之前，测试就已经被视为已经完成了。</p><p>如果你希望Promise返回rejected，你需要使用 <code>.rejects</code> 匹配器。 它和 <code>.resolves</code> 匹配器是一样的使用方式。 如果 Promise 被拒绝，则测试将自动失败。</p><div class="code-wrapper"><pre><code class="hljs lisp">test(&#x27;the fetch fails with an error&#x27;, () =&gt; &#123;  return expect(<span class="hljs-name">fetchData</span>()).rejects.toMatch(&#x27;error&#x27;)<span class="hljs-comment">;</span>&#125;)<span class="hljs-comment">;</span></code></pre></div><h4 id="Jest的钩子函数"><a href="#Jest的钩子函数" class="headerlink" title="Jest的钩子函数"></a>Jest的钩子函数</h4><p>jest有4个钩子函数</p><ul><li>beforeAll()钩子函数会在所有的测试用例之前执行  只会执行一次</li><li>beforeEach()钩子函数 会在每个测试用例执行之前执行一次，每个测试用例执行前都会执行一次</li><li>afterEach() 钩子函数会在每个测试用里执行完之后执行执行一次</li><li>alfterAll() 钩子函数会在所有用力执行完后执行</li></ul><h4 id="生成jest配置文件jest-config-js"><a href="#生成jest配置文件jest-config-js" class="headerlink" title="生成jest配置文件jest.config.js"></a>生成jest配置文件jest.config.js</h4><div class="code-wrapper"><pre><code class="hljs ada">npx jest <span class="hljs-comment">--init</span></code></pre></div><h4 id="mock函数"><a href="#mock函数" class="headerlink" title="mock函数"></a>mock函数</h4><p>Mock 函数允许你测试代码之间的连接——实现方式包括：擦除函数的实际实现、捕获对函数的调用 ( 以及在这些调用中传递的参数) 、在使用 <code>new</code> 实例化时捕获构造函数的实例、允许测试时配置返回值。</p><p>有两种方法可以模拟函数：要么在测试代码中创建一个 mock 函数，要么编写一个<a href="https://jestjs.io/zh-Hans/docs/manual-mocks"><code>手动 mock</code></a>来覆盖模块依赖。</p><h5 id="使用-mock-函数"><a href="#使用-mock-函数" class="headerlink" title="使用 mock 函数"></a>使用 mock 函数<a href="https://jestjs.io/zh-Hans/docs/mock-functions#%E4%BD%BF%E7%94%A8-mock-%E5%87%BD%E6%95%B0"></a></h5><p>假设我们要测试函数 <code>forEach</code> 的内部实现，这个函数为传入的数组中的每个元素调用一次回调函数。</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">forEach</span>(items, callback) &#123;  <span class="hljs-keyword">for</span> (let <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">index</span> &lt; items.length; <span class="hljs-keyword">index</span>++) &#123;    callback(items[<span class="hljs-keyword">index</span>]);  &#125;&#125;</code></pre></div><p>为了测试此函数，我们可以使用一个 mock 函数，然后检查 mock 函数的状态来确保回调函数如期调用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mockCallback = jest.<span class="hljs-title function_">fn</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-number">42</span> + x);<span class="hljs-title function_">forEach</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], mockCallback);<span class="hljs-comment">// 此 mock 函数被调用了两次</span><span class="hljs-title function_">expect</span>(mockCallback.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 第一次调用函数时的第一个参数是 0</span><span class="hljs-title function_">expect</span>(mockCallback.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 第二次调用函数时的第一个参数是 1</span><span class="hljs-title function_">expect</span>(mockCallback.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// 第一次函数调用的返回值是 42</span><span class="hljs-title function_">expect</span>(mockCallback.<span class="hljs-property">mock</span>.<span class="hljs-property">results</span>[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">42</span>);</code></pre></div><h5 id="mock-属性"><a href="#mock-属性" class="headerlink" title=".mock 属性"></a><code>.mock</code> 属性</h5><p>所有的 mock 函数都有这个特殊的 <code>.mock</code>属性，它保存了关于此函数如何被调用、调用时的返回值的信息。 <code>.mock</code> 属性还追踪每次调用时 <code>this</code>的值，所以我们同样可以也检视（inspect） <code>this</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myMock1 = jest.<span class="hljs-title function_">fn</span>();<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myMock1</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMock1.<span class="hljs-property">mock</span>.<span class="hljs-property">instances</span>);<span class="hljs-comment">// &gt; [ &lt;a&gt; ]</span><span class="hljs-keyword">const</span> myMock2 = jest.<span class="hljs-title function_">fn</span>();<span class="hljs-keyword">const</span> b = &#123;&#125;;<span class="hljs-keyword">const</span> bound = myMock2.<span class="hljs-title function_">bind</span>(b);<span class="hljs-title function_">bound</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMock2.<span class="hljs-property">mock</span>.<span class="hljs-property">contexts</span>);<span class="hljs-comment">// &gt; [ &lt;b&gt; ]</span></code></pre></div><p>这些 mock 成员变量在测试中非常有用，用于说明这些 function 是如何被调用、实例化或返回的：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// The function was called exactly once</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// The first arg of the first call to the function was &#x27;first arg&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;first arg&#x27;</span>);<span class="hljs-comment">// The second arg of the first call to the function was &#x27;second arg&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;second arg&#x27;</span>);<span class="hljs-comment">// The return value of the first call to the function was &#x27;return value&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">results</span>[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;return value&#x27;</span>);<span class="hljs-comment">// The function was called with a certain `this` context: the `element` object.</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">contexts</span>[<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(element);<span class="hljs-comment">// This function was instantiated exactly twice</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">instances</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// The object returned by the first instantiation of this function</span><span class="hljs-comment">// had a `name` property whose value was set to &#x27;test&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">instances</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<span class="hljs-comment">// The first argument of the last call to the function was &#x27;test&#x27;</span><span class="hljs-title function_">expect</span>(someMockFunction.<span class="hljs-property">mock</span>.<span class="hljs-property">lastCall</span>[<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;test&#x27;</span>);</code></pre></div><h5 id="Mock-的返回值"><a href="#Mock-的返回值" class="headerlink" title="Mock 的返回值"></a>Mock 的返回值<a href="https://jestjs.io/zh-Hans/docs/mock-functions#mock-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"></a></h5><p>Mock 函数也可以用于在测试期间将测试值注入代码︰</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myMock = jest.<span class="hljs-title function_">fn</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myMock</span>());<span class="hljs-comment">// &gt; undefined</span>myMock.<span class="hljs-title function_">mockReturnValueOnce</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">mockReturnValueOnce</span>(<span class="hljs-string">&#x27;x&#x27;</span>).<span class="hljs-title function_">mockReturnValue</span>(<span class="hljs-literal">true</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myMock</span>(), <span class="hljs-title function_">myMock</span>(), <span class="hljs-title function_">myMock</span>(), <span class="hljs-title function_">myMock</span>());<span class="hljs-comment">// &gt; 10, &#x27;x&#x27;, true, true</span></code></pre></div><p>在函数连续传递风格（functional continuation-passing style）的代码中时，Mock 函数也非常有效。 以这种代码风格有助于避免复杂的中间操作，便于直观表现组件的真实意图，这有利于在它们被调用之前，将值直接注入到测试中。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> filterTestFn = jest.<span class="hljs-title function_">fn</span>();<span class="hljs-comment">// Make the mock return `true` for the first call,</span><span class="hljs-comment">// and `false` for the second call</span>filterTestFn.<span class="hljs-title function_">mockReturnValueOnce</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">mockReturnValueOnce</span>(<span class="hljs-literal">false</span>);<span class="hljs-keyword">const</span> result = [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> <span class="hljs-title function_">filterTestFn</span>(num));<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<span class="hljs-comment">// &gt; [11]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filterTestFn.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">// 11</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filterTestFn.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">// 12</span></code></pre></div><p>大多数现实世界例子中，实际是在依赖的组件上配一个模拟函数并配置它，但手法是相同的。 在这些情况下，尽量避免在非真正想要进行测试的任何函数内实现逻辑。</p><h5 id="模拟模块"><a href="#模拟模块" class="headerlink" title="模拟模块"></a>模拟模块<a href="https://jestjs.io/zh-Hans/docs/mock-functions#%E6%A8%A1%E6%8B%9F%E6%A8%A1%E5%9D%97"></a></h5><p>假定有个从 API 获取用户的类。 该类用 <a href="https://github.com/axios/axios">axios</a> 调用 API 然后返回 <code>data</code>，其中包含所有用户的属性：</p><p>users.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Users</span> &#123;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users.json&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> resp.<span class="hljs-property">data</span>);  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Users</span>;</code></pre></div><p>现在，为测试该方法而不实际调用 API (使测试缓慢与脆弱)，我们可以用 <code>jest.mock(...)</code> 函数自动模拟 axios 模块。</p><p>一旦模拟模块，我们可为 <code>.get</code> 提供一个 <code>mockResolvedValue</code> ，它会返回假数据用于测试。 实际上，我们想说的是我们想让<code>axios.get(&#39;/users.json&#39;)</code> 有个伪造的响应结果。</p><p>users.test.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">Users</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./users&#x27;</span>;jest.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;axios&#x27;</span>);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;should fetch users&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> users = [&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>&#125;];  <span class="hljs-keyword">const</span> resp = &#123;<span class="hljs-attr">data</span>: users&#125;;  axios.<span class="hljs-property">get</span>.<span class="hljs-title function_">mockResolvedValue</span>(resp);  <span class="hljs-comment">// or you could use the following depending on your use case:</span>  <span class="hljs-comment">// axios.get.mockImplementation(() =&gt; Promise.resolve(resp))</span>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Users</span>.<span class="hljs-title function_">all</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">expect</span>(data).<span class="hljs-title function_">toEqual</span>(users));&#125;);</code></pre></div><h5 id="模拟-部分模块"><a href="#模拟-部分模块" class="headerlink" title="模拟 部分模块"></a>模拟 部分模块</h5><p>模块的子集可以被模拟，模块的其他部分可以维持当前实现：</p><p>foo-bar-baz.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">bar</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-string">&#x27;bar&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; <span class="hljs-string">&#x27;baz&#x27;</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//test.js</span><span class="hljs-keyword">import</span> defaultExport, &#123;bar, foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../foo-bar-baz&#x27;</span>;jest.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;../foo-bar-baz&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> originalModule = jest.requireActual(<span class="hljs-string">&#x27;../foo-bar-baz&#x27;</span>);  <span class="hljs-comment">//Mock the default export and named export &#x27;foo&#x27;</span>  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">__esModule</span>: <span class="hljs-literal">true</span>,    ...originalModule,    <span class="hljs-attr">default</span>: jest.<span class="hljs-title function_">fn</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;mocked baz&#x27;</span>),    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;mocked foo&#x27;</span>,  &#125;;&#125;);<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;should do a partial mock&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> defaultExportResult = <span class="hljs-title function_">defaultExport</span>();  <span class="hljs-title function_">expect</span>(defaultExportResult).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;mocked baz&#x27;</span>);  <span class="hljs-title function_">expect</span>(defaultExport).<span class="hljs-title function_">toHaveBeenCalled</span>();  <span class="hljs-title function_">expect</span>(foo).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;mocked foo&#x27;</span>);  <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">bar</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);&#125;);</code></pre></div><h5 id="Mock-实现"><a href="#Mock-实现" class="headerlink" title="Mock 实现"></a>Mock 实现<a href="https://jestjs.io/zh-Hans/docs/mock-functions#mock-%E5%AE%9E%E7%8E%B0"></a></h5><p>还有，在某些情况下用Mock函数替换指定返回值是非常有用的。 可以用 <code>jest.fn</code> 或 <code>mockImplementationOnce</code>方法来实现Mock函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMockFn = jest.<span class="hljs-title function_">fn</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>));<span class="hljs-title function_">myMockFn</span>(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));<span class="hljs-comment">// &gt; true</span></code></pre></div><p>当你需要根据别的模块定义默认的Mock函数实现时，<code>mockImplementation</code> 方法是非常有用的。</p><p>foo.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// some implementation;</span>&#125;;</code></pre></div><p>test.js</p><div class="code-wrapper"><pre><code class="hljs js">jest.<span class="hljs-title function_">mock</span>(<span class="hljs-string">&#x27;../foo&#x27;</span>); <span class="hljs-comment">// this happens automatically with automocking</span><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../foo&#x27;</span>);<span class="hljs-comment">// foo is a mock function</span>foo.<span class="hljs-title function_">mockImplementation</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-number">42</span>);<span class="hljs-title function_">foo</span>();<span class="hljs-comment">// &gt; 42</span></code></pre></div><p>当你需要模拟某个函数调用返回不同结果时，请使用 <code>mockImplementationOnce</code> 方法︰</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMockFn = jest  .<span class="hljs-title function_">fn</span>()  .<span class="hljs-title function_">mockImplementationOnce</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>))  .<span class="hljs-title function_">mockImplementationOnce</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>));<span class="hljs-title function_">myMockFn</span>(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));<span class="hljs-comment">// &gt; true</span><span class="hljs-title function_">myMockFn</span>(<span class="hljs-function">(<span class="hljs-params">err, val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));<span class="hljs-comment">// &gt; false</span></code></pre></div><p>当 <code>mockImplementationOne</code>定义的实现逐个调用完毕时， 如果定义了<code>jest.fn </code>，它将使用 <code>jest.fn </code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myMockFn = jest  .<span class="hljs-title function_">fn</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;default&#x27;</span>)  .<span class="hljs-title function_">mockImplementationOnce</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;first call&#x27;</span>)  .<span class="hljs-title function_">mockImplementationOnce</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;second call&#x27;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myMockFn</span>(), <span class="hljs-title function_">myMockFn</span>(), <span class="hljs-title function_">myMockFn</span>(), <span class="hljs-title function_">myMockFn</span>());<span class="hljs-comment">// &gt; &#x27;first call&#x27;, &#x27;second call&#x27;, &#x27;default&#x27;, &#x27;default&#x27;</span></code></pre></div><p>大多数情况下，我们的函数调用都是链式的，如果你希望创建的函数支持链式调用（因为返回了this），可以使用<code>.mockReturnThis()</code> 函数来支持。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObj = &#123;  <span class="hljs-attr">myMethod</span>: jest.<span class="hljs-title function_">fn</span>().<span class="hljs-title function_">mockReturnThis</span>(),&#125;;<span class="hljs-comment">// is the same as</span><span class="hljs-keyword">const</span> otherObj = &#123;  <span class="hljs-attr">myMethod</span>: jest.<span class="hljs-title function_">fn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;  &#125;),&#125;;</code></pre></div><h5 id="自定义匹配器"><a href="#自定义匹配器" class="headerlink" title="自定义匹配器"></a>自定义匹配器<a href="https://jestjs.io/zh-Hans/docs/mock-functions#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%B9%E9%85%8D%E5%99%A8"></a></h5><p>最后，测试Mock函数需要写大量的断言，为了减少代码量，我们提供了一些自定义匹配器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// The mock function was called at least once</span><span class="hljs-title function_">expect</span>(mockFunc).<span class="hljs-title function_">toHaveBeenCalled</span>();<span class="hljs-comment">// The mock function was called at least once with the specified args</span><span class="hljs-title function_">expect</span>(mockFunc).<span class="hljs-title function_">toHaveBeenCalledWith</span>(arg1, arg2);<span class="hljs-comment">// The last call to the mock function was called with the specified args</span><span class="hljs-title function_">expect</span>(mockFunc).<span class="hljs-title function_">toHaveBeenLastCalledWith</span>(arg1, arg2);<span class="hljs-comment">// All calls and the name of the mock is written as a snapshot</span><span class="hljs-title function_">expect</span>(mockFunc).<span class="hljs-title function_">toMatchSnapshot</span>();</code></pre></div><p>这些匹配器是断言Mock函数的语法糖。 你可以根据自己的需要自行选择匹配器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// The mock function was called at least once</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span>).<span class="hljs-title function_">toBeGreaterThan</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// The mock function was called at least once with the specified args</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>).<span class="hljs-title function_">toContainEqual</span>([arg1, arg2]);<span class="hljs-comment">// The last call to the mock function was called with the specified args</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]).<span class="hljs-title function_">toEqual</span>([  arg1,  arg2,]);<span class="hljs-comment">// The first arg of the last call to the mock function was `42`</span><span class="hljs-comment">// (note that there is no sugar helper for this specific of an assertion)</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>[mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">42</span>);<span class="hljs-comment">// A snapshot will check that a mock was invoked the same number of times,</span><span class="hljs-comment">// in the same order, with the same arguments. 它还会在名称上断言。 它还会在名称上断言。</span><span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-property">mock</span>.<span class="hljs-property">calls</span>).<span class="hljs-title function_">toEqual</span>([[arg1, arg2]]);<span class="hljs-title function_">expect</span>(mockFunc.<span class="hljs-title function_">getMockName</span>()).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;a mock name&#x27;</span>);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>单元测试</category>
      
      <category>jest</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习JavaScript数据结构与算法（第3版）读书笔记</title>
    <link href="/2022/09/14/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/14/%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="第四章栈"><a href="#第四章栈" class="headerlink" title="##第四章栈"></a>##第四章栈</h4><p>使用数组来定义数据结构</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];  &#125;  <span class="hljs-comment">// 添加一个（或几个）新元素到栈顶,返回值是数组的长度</span>  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(element);  &#125;  <span class="hljs-comment">//移除栈顶的元素，同时返回被移除的元素</span>  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">pop</span>();  &#125;  <span class="hljs-comment">//返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）</span>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];  &#125;  <span class="hljs-comment">// 如果栈里没有任何元素就返回 true，否则返回 false</span>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-comment">// 移除栈里的所有元素</span>  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];  &#125;  <span class="hljs-comment">//返回栈里的元素个数。该方法和数组的 length 属性很类似</span>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;  &#125;&#125;</code></pre></div><p>使用对象来定义栈</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;  &#125;  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>] = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;  &#125;  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>;  &#125;  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> === <span class="hljs-number">0</span>;  &#125;  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;    <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>];    <span class="hljs-keyword">return</span> result;  &#125;  <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = &#123;&#125;;    <span class="hljs-comment">// while(!this.isEmpty())&#123;</span>    <span class="hljs-comment">//   this.pop()</span>    <span class="hljs-comment">// &#125;</span>  &#125;  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>];  &#125;  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;    <span class="hljs-keyword">let</span> str = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>; i++) &#123;      str = str + <span class="hljs-string">`,<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.items[i]&#125;</span>`</span>;    &#125;    <span class="hljs-keyword">return</span> str;  &#125;&#125;</code></pre></div><p>保护数据结构内部元素</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(stack)); <span class="hljs-comment">// &#123;1&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(stack)); <span class="hljs-comment">// &#123;2&#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-property">items</span>);</code></pre></div><p>外部可以直接拿到内部的数据，因为js中没有私有属性</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_count</span> = <span class="hljs-number">0</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_items</span> = &#123;&#125;;  &#125; &#125;</code></pre></div><p>一部分开发者胡使用下划线作为私有属性的规范，但是这样依然可以被访问，没有实质性的作用</p><h5 id="用-ES2015-的限定作用域-Symbol-实现类"><a href="#用-ES2015-的限定作用域-Symbol-实现类" class="headerlink" title="用 ES2015 的限定作用域 Symbol 实现类"></a>用 ES2015 的限定作用域 Symbol 实现类</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> _items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;stackItem&quot;</span>);<span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">//使用计算属性和symbol的形式</span>    <span class="hljs-variable language_">this</span>[_items] = &#123;&#125;;  &#125;&#125;</code></pre></div><p>虽然这种方式可以让上述方法没办法访问内部属性但是可以通过<code>Object.getOwnPropertySymbol(stack)</code>可以访问到以Symbol为key的属性</p><h5 id="用-ES2015-的-WeakMap-实现类"><a href="#用-ES2015-的-WeakMap-实现类" class="headerlink" title="用 ES2015 的 WeakMap 实现类"></a>用 ES2015 的 WeakMap 实现类</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakMapStack</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;    items.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>,[])  &#125;  <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>)&#123;    items.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">push</span>(element)  &#125;  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">pop</span>()  &#125;  <span class="hljs-comment">//...</span>&#125;</code></pre></div><p>现在我们知道了，items 在 Stack 类里是真正的私有属性。采用这种方法，代码的可读性 不强，而且在扩展该类时无法继承私有属性。鱼和熊掌不可兼得！</p><h5 id="使用栈的实例"><a href="#使用栈的实例" class="headerlink" title="使用栈的实例"></a>使用栈的实例</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 将十进制转成二进制</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Stack</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Stack.js&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">decimalToBinary</span>(<span class="hljs-params">decNumber</span>) &#123;  decNumber = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Number</span>(decNumber));  <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();  <span class="hljs-keyword">let</span> dec = decNumber;  <span class="hljs-keyword">while</span> (dec &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(dec % <span class="hljs-number">2</span>));    stack.<span class="hljs-title function_">push</span>(dec % <span class="hljs-number">2</span>);    dec = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(dec / <span class="hljs-number">2</span>);  &#125;  <span class="hljs-keyword">let</span> binaryString = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">while</span> (!stack.<span class="hljs-title function_">isEmpty</span>()) &#123;    binaryString += stack.<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">toString</span>();  &#125;  <span class="hljs-keyword">return</span> binaryString;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 把十进制转换成基数为 2～36 的任意进制</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Stack</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Stack.js&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">baseConverter</span>(<span class="hljs-params">decNumber, base</span>) &#123;  <span class="hljs-keyword">let</span> dec = decNumber;  <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();  <span class="hljs-keyword">const</span> digits = <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">if</span> (!(base &gt;= <span class="hljs-number">2</span> &amp;&amp; base &lt;= <span class="hljs-number">36</span>)) &#123;    <span class="hljs-keyword">return</span> str;  &#125;  <span class="hljs-keyword">while</span> (dec &gt; <span class="hljs-number">0</span>) &#123;    arr.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(dec % base));    dec = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(dec / base);  &#125;  <span class="hljs-keyword">while</span> (!arr.<span class="hljs-title function_">isEmpty</span>()) &#123;    str += digits[arr.<span class="hljs-title function_">pop</span>()];  &#125;  <span class="hljs-keyword">return</span> str;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">baseConverter</span>(<span class="hljs-number">100345</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 11000011111111001</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">baseConverter</span>(<span class="hljs-number">100345</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// 303771</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">baseConverter</span>(<span class="hljs-number">100345</span>, <span class="hljs-number">16</span>)); <span class="hljs-comment">// 187F9</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">baseConverter</span>(<span class="hljs-number">100345</span>, <span class="hljs-number">35</span>)); <span class="hljs-comment">// 2BW0</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/09/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/09/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理</title>
    <link href="/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2022/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3项目搭建</title>
    <link href="/2022/09/13/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/09/13/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="项目搭建规范"><a href="#项目搭建规范" class="headerlink" title="项目搭建规范"></a>项目搭建规范</h1><h2 id="一-代码规范"><a href="#一-代码规范" class="headerlink" title="一. 代码规范"></a>一. 代码规范</h2><h3 id="1-1-集成editorconfig配置"><a href="#1-1-集成editorconfig配置" class="headerlink" title="1.1. 集成editorconfig配置"></a>1.1. 集成editorconfig配置</h3><p>EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># http://editorconfig.org</span><span class="hljs-string">root</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span>[<span class="hljs-string">*</span>] <span class="hljs-comment"># 表示所有文件适用</span><span class="hljs-string">charset</span> <span class="hljs-string">=</span> <span class="hljs-string">utf-8</span> <span class="hljs-comment"># 设置文件字符集为 utf-8</span><span class="hljs-string">indent_style</span> <span class="hljs-string">=</span> <span class="hljs-string">space</span> <span class="hljs-comment"># 缩进风格（tab | space）</span><span class="hljs-string">indent_size</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 缩进大小</span><span class="hljs-string">end_of_line</span> <span class="hljs-string">=</span> <span class="hljs-string">lf</span> <span class="hljs-comment"># 控制换行类型(lf | cr | crlf)</span><span class="hljs-string">trim_trailing_whitespace</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 去除行首的任意空白字符</span><span class="hljs-string">insert_final_newline</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 始终在文件末尾插入一个新行</span>[<span class="hljs-string">*.md</span>] <span class="hljs-comment"># 表示仅 md 文件适用以下规则</span><span class="hljs-string">max_line_length</span> <span class="hljs-string">=</span> <span class="hljs-string">off</span><span class="hljs-string">trim_trailing_whitespace</span> <span class="hljs-string">=</span> <span class="hljs-literal">false</span></code></pre></div><p>VSCode需要安装一个插件：EditorConfig for VS Code</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2gh989yj30pj05ggmb.jpg" alt="image-20210722215138665"></p><h3 id="1-2-使用prettier工具"><a href="#1-2-使用prettier工具" class="headerlink" title="1.2. 使用prettier工具"></a>1.2. 使用prettier工具</h3><p>Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。</p><p>1.安装prettier</p><div class="code-wrapper"><pre><code class="hljs shell">npm install prettier -D</code></pre></div><p>2.配置.prettierrc文件：</p><ul><li>useTabs：使用tab缩进还是空格缩进，选择false；</li><li>tabWidth：tab是空格的情况下，是几个空格，选择2个；</li><li>printWidth：当行字符的长度，推荐80，也有人喜欢100或者120；</li><li>singleQuote：使用单引号还是双引号，选择true，使用单引号；</li><li>trailingComma：在多行输入的尾逗号是否添加，设置为 <code>none</code>；</li><li>semi：语句末尾是否要加分号，默认值true，选择false表示不加；</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;useTabs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;tabWidth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;printWidth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">80</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;singleQuote&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;trailingComma&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;none&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;semi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>3.创建.prettierignore忽略文件</p><div class="code-wrapper"><pre><code class="hljs gradle"><span class="hljs-regexp">/dist/</span>*.local.output.js<span class="hljs-regexp">/node_modules/</span>****<span class="hljs-comment">/*.svg</span><span class="hljs-comment">**/</span>*.sh<span class="hljs-regexp">/public/</span>*</code></pre></div><p>4.VSCode需要安装prettier的插件</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2acx21rj30ow057mxp.jpg" alt="image-20210722214543454"></p><p>5.测试prettier是否生效</p><ul><li>测试一：在代码中保存代码；</li><li>测试二：配置一次性修改的命令,批量修改；</li></ul><p>在package.json中配置一个scripts：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;prettier&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;prettier --write .&quot;</span></code></pre></div><h3 id="1-3-使用ESLint检测"><a href="#1-3-使用ESLint检测" class="headerlink" title="1.3. 使用ESLint检测"></a>1.3. 使用ESLint检测</h3><p>1.在前面创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。</p><p>2.VSCode需要安装ESLint插件：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsq2oq26odj30pw05faaq.jpg" alt="image-20210722215933360"></p><p>3.解决eslint和prettier冲突的问题：</p><p>安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装）</p><div class="code-wrapper"><pre><code class="hljs shell">npm i eslint-plugin-prettier eslint-config-prettier -D</code></pre></div><p>添加在eslintrc中添加prettier插件：</p><div class="code-wrapper"><pre><code class="hljs json">extends<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>  <span class="hljs-string">&quot;plugin:vue/vue3-essential&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-string">&quot;eslint:recommended&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-string">&quot;@vue/typescript/recommended&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-string">&quot;@vue/prettier&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-string">&quot;@vue/prettier/@typescript-eslint&quot;</span><span class="hljs-punctuation">,</span>  &#x27;plugin<span class="hljs-punctuation">:</span>prettier/recommended&#x27;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span></code></pre></div><h3 id="1-4-git-Husky和eslint"><a href="#1-4-git-Husky和eslint" class="headerlink" title="1.4. git Husky和eslint"></a>1.4. git Husky和eslint</h3><p>虽然我们已经要求项目使用eslint了，但是不能保证组员提交代码之前都将eslint中的问题解决掉了：</p><ul><li><p>也就是我们希望保证代码仓库中的代码都是符合eslint规范的；</p></li><li><p>那么我们需要在组员执行 <code>git commit </code> 命令的时候对其进行校验，如果不符合eslint规范，那么自动通过规范进行修复；</p></li></ul><p>那么如何做到这一点呢？可以通过Husky工具：</p><ul><li>husky是一个git hook工具，可以帮助我们触发git提交的各个阶段：pre-commit、commit-msg、pre-push</li></ul><p>如何使用husky呢？</p><p>这里我们可以使用自动配置命令：</p><div class="code-wrapper"><pre><code class="hljs shell">npx husky-init &amp;&amp; npm install</code></pre></div><p>这里会做三件事：</p><p>1.安装husky相关的依赖：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq0o5jxmj30bb04qwen.jpg" alt="image-20210723112648927"></p><p>2.在项目目录下创建 <code>.husky</code> 文件夹：</p><div class="code-wrapper"><pre><code class="hljs cmake">npx huksy <span class="hljs-keyword">install</span></code></pre></div><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq16zo75j307703mt8m.jpg" alt="image-20210723112719634"></p><p>3.在package.json中添加一个脚本：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq26phpxj30dj06fgm3.jpg" alt="image-20210723112817691"></p><p>接下来，我们需要去完成一个操作：在进行commit时，执行lint脚本：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqq3hn229j30nf04z74q.jpg" alt="image-20210723112932943"></p><p>这个时候我们执行git commit的时候会自动对代码进行lint校验。</p><h3 id="1-5-git-commit规范"><a href="#1-5-git-commit规范" class="headerlink" title="1.5. git commit规范"></a>1.5. git commit规范</h3><h4 id="1-5-1-代码提交风格"><a href="#1-5-1-代码提交风格" class="headerlink" title="1.5.1. 代码提交风格"></a>1.5.1. 代码提交风格</h4><p>通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw17gaqjj30to0cj3zp.jpg"></p><p>但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen</p><ul><li>Commitizen 是一个帮助我们编写规范 commit message 的工具；</li></ul><p>1.安装Commitizen</p><div class="code-wrapper"><pre><code class="hljs shell">npm install commitizen -D</code></pre></div><p>2.安装cz-conventional-changelog，并且初始化cz-conventional-changelog：</p><div class="code-wrapper"><pre><code class="hljs shell">npx commitizen init cz-conventional-changelog --save-dev --save-exact</code></pre></div><p>这个命令会帮助我们安装cz-conventional-changelog：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvz2odi4j30ek00zmx2.jpg" alt="image-20210723145249096"></p><p>并且在package.json中进行配置：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvzftay5j30iu04k74d.jpg"></p><p>这个时候我们提交代码需要使用 <code>npx cz</code>：</p><ul><li>第一步是选择type，本次更新的类型</li></ul><table><thead><tr><th>Type</th><th>作用</th></tr></thead><tbody><tr><td>feat</td><td>新增特性 (feature)</td></tr><tr><td>fix</td><td>修复 Bug(bug fix)</td></tr><tr><td>docs</td><td>修改文档 (documentation)</td></tr><tr><td>style</td><td>代码格式修改(white-space, formatting, missing semi colons, etc)</td></tr><tr><td>refactor</td><td>代码重构(refactor)</td></tr><tr><td>perf</td><td>改善性能(A code change that improves performance)</td></tr><tr><td>test</td><td>测试(when adding missing tests)</td></tr><tr><td>build</td><td>变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）</td></tr><tr><td>ci</td><td>更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等</td></tr><tr><td>chore</td><td>变更构建流程或辅助工具(比如更改测试环境)</td></tr><tr><td>revert</td><td>代码回退</td></tr></tbody></table><ul><li>第二步选择本次修改的范围（作用域）</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8ca15oj30r600wmx4.jpg" alt="image-20210723150147510"></p><ul><li>第三步选择提交的信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8mq3zlj60ni01hmx402.jpg" alt="image-20210723150204780"></p><ul><li>第四步提交详细的描述信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8y05bjj30kt01fjrb.jpg" alt="image-20210723150223287"></p><ul><li>第五步是否是一次重大的更改</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw9z5vbij30bm00q744.jpg" alt="image-20210723150322122"></p><ul><li>第六步是否影响某个open issue</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwar8xp1j30fq00ya9x.jpg" alt="image-20210723150407822"></p><p>我们也可以在scripts中构建一个命令来执行 cz：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwc4gtkxj30e207174t.jpg" alt="image-20210723150526211"></p><h4 id="1-5-2-代码提交验证"><a href="#1-5-2-代码提交验证" class="headerlink" title="1.5.2. 代码提交验证"></a>1.5.2. 代码提交验证</h4><p>如果我们按照cz来规范了提交风格，但是依然有同事通过 <code>git commit</code> 按照不规范的格式提交应该怎么办呢？</p><ul><li>我们可以通过commitlint来限制提交；</li></ul><p>1.安装 @commitlint/config-conventional 和 @commitlint/cli</p><div class="code-wrapper"><pre><code class="hljs shell">npm i @commitlint/config-conventional @commitlint/cli -D</code></pre></div><p>2.在根目录创建commitlint.config.js文件，配置commitlint</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>]&#125;</code></pre></div><p>3.使用husky生成commit-msg文件，验证提交信息：</p><div class="code-wrapper"><pre><code class="hljs shell">npx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot;</code></pre></div><h2 id="二-第三方库集成"><a href="#二-第三方库集成" class="headerlink" title="二. 第三方库集成"></a>二. 第三方库集成</h2><h3 id="2-1-vue-config-js配置"><a href="#2-1-vue-config-js配置" class="headerlink" title="2.1. vue.config.js配置"></a>2.1. vue.config.js配置</h3><p>vue.config.js有三种配置方式：</p><ul><li>方式一：直接通过CLI提供给我们的选项来配置：<ul><li>比如publicPath：配置应用程序部署的子目录（默认是 <code>/</code>，相当于部署在 <code>https://www.my-app.com/</code>）；</li><li>比如outputDir：修改输出的文件夹；</li></ul></li><li>方式二：通过configureWebpack修改webpack的配置：<ul><li>可以是一个对象，直接会被合并；</li><li>可以是一个函数，会接收一个config，可以通过config来修改配置；</li></ul></li><li>方式三：通过chainWebpack修改webpack的配置：<ul><li>是一个函数，会接收一个基于  <a href="https://github.com/mozilla-neutrino/webpack-chain">webpack-chain</a> 的config对象，可以对配置进行修改；</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">outputDir</span>: <span class="hljs-string">&#x27;./build&#x27;</span>,  <span class="hljs-comment">// configureWebpack: &#123;</span>  <span class="hljs-comment">//   resolve: &#123;</span>  <span class="hljs-comment">//     alias: &#123;</span>  <span class="hljs-comment">//       views: &#x27;@/views&#x27;</span>  <span class="hljs-comment">//     &#125;</span>  <span class="hljs-comment">//   &#125;</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-comment">// configureWebpack: (config) =&gt; &#123;</span>  <span class="hljs-comment">//   config.resolve.alias = &#123;</span>  <span class="hljs-comment">//     &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;),</span>  <span class="hljs-comment">//     views: &#x27;@/views&#x27;</span>  <span class="hljs-comment">//   &#125;</span>  <span class="hljs-comment">// &#125;,</span>  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    config.<span class="hljs-property">resolve</span>.<span class="hljs-property">alias</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;@&#x27;</span>, path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)).<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, <span class="hljs-string">&#x27;@/views&#x27;</span>)  &#125;&#125;</code></pre></div><h3 id="2-2-vue-router集成"><a href="#2-2-vue-router集成" class="headerlink" title="2.2. vue-router集成"></a>2.2. vue-router集成</h3><p>安装vue-router的最新版本：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install vue-router@next</code></pre></div><p>创建router对象：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RouteRecordRaw</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">RouteRecordRaw</span>[] = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/main&#x27;</span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/main&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/main/main.vue&#x27;</span>)  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;../views/login/login.vue&#x27;</span>)  &#125;]<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;  routes,  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>()&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router</code></pre></div><p>安装router：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><p>在App.vue中配置跳转：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/main&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h3 id="2-3-vuex集成"><a href="#2-3-vuex集成" class="headerlink" title="2.3. vuex集成"></a>2.3. vuex集成</h3><p>安装vuex：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install vuex@next</code></pre></div><p>创建store对象：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;coderwhy&#x27;</span>    &#125;  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><p>安装store：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">use</span>(store).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><p>在App.vue中使用：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; $store.state.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div><h3 id="2-4-element-plus集成"><a href="#2-4-element-plus集成" class="headerlink" title="2.4. element-plus集成"></a>2.4. element-plus集成</h3><p>Element Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库：</p><ul><li>相信很多同学在Vue2中都使用过element-ui，而element-plus正是element-ui针对于vue3开发的一个UI组件库；</li><li>它的使用方式和很多其他的组件库是一样的，所以学会element-plus，其他类似于ant-design-vue、NaiveUI、VantUI都是差不多的；</li></ul><p>安装element-plus</p><div class="code-wrapper"><pre><code class="hljs shell">npm install element-plus</code></pre></div><h4 id="2-4-1-全局引入"><a href="#2-4-1-全局引入" class="headerlink" title="2.4.1. 全局引入"></a>2.4.1. 全局引入</h4><p>一种引入element-plus的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementPlus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/lib/theme-chalk/index.css&#x27;</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">use</span>(router).<span class="hljs-title function_">use</span>(store).<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementPlus</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><h4 id="2-4-2-局部引入"><a href="#2-4-2-局部引入" class="headerlink" title="2.4.2. 局部引入"></a>2.4.2. 局部引入</h4><p>也就是在开发中用到某个组件对某个组件进行引入：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;h2&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h2&gt;    &lt;el-button&gt;默认按钮&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot;&gt;主要按钮&lt;/el-button&gt;    &lt;el-button type=&quot;success&quot;&gt;成功按钮&lt;/el-button&gt;    &lt;el-button type=&quot;info&quot;&gt;信息按钮&lt;/el-button&gt;    &lt;el-button type=&quot;warning&quot;&gt;警告按钮&lt;/el-button&gt;    &lt;el-button type=&quot;danger&quot;&gt;危险按钮&lt;/el-button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;import &#123; ElButton &#125; from &#x27;element-plus&#x27;export default defineComponent(&#123;  name: &#x27;App&#x27;,  components: &#123;    ElButton  &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</code></pre></div><p>但是我们会发现是没有对应的样式的，引入样式有两种方式：</p><ul><li>全局引用样式（像之前做的那样）；</li><li>局部引用样式（通过babel的插件）；</li></ul><p>1.安装babel的插件：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install babel-plugin-import -D</code></pre></div><p>2.配置babel.config.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">plugins</span>: [    [      <span class="hljs-string">&#x27;import&#x27;</span>,      &#123;        <span class="hljs-attr">libraryName</span>: <span class="hljs-string">&#x27;element-plus&#x27;</span>,        <span class="hljs-attr">customStyleName</span>: <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;          <span class="hljs-keyword">return</span> <span class="hljs-string">`element-plus/lib/theme-chalk/<span class="hljs-subst">$&#123;name&#125;</span>.css`</span>        &#125;      &#125;    ]  ],  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>]&#125;</code></pre></div><p>但是这里依然有个弊端：</p><ul><li>这些组件我们在多个页面或者组件中使用的时候，都需要导入并且在components中进行注册；</li><li>所以我们可以将它们在全局注册一次；</li></ul><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;  <span class="hljs-title class_">ElButton</span>,  <span class="hljs-title class_">ElTable</span>,  <span class="hljs-title class_">ElAlert</span>,  <span class="hljs-title class_">ElAside</span>,  <span class="hljs-title class_">ElAutocomplete</span>,  <span class="hljs-title class_">ElAvatar</span>,  <span class="hljs-title class_">ElBacktop</span>,  <span class="hljs-title class_">ElBadge</span>,&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus/lib/components&#x27;</span><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<span class="hljs-keyword">const</span> components = [  <span class="hljs-title class_">ElButton</span>,  <span class="hljs-title class_">ElTable</span>,  <span class="hljs-title class_">ElAlert</span>,  <span class="hljs-title class_">ElAside</span>,  <span class="hljs-title class_">ElAutocomplete</span>,  <span class="hljs-title class_">ElAvatar</span>,  <span class="hljs-title class_">ElBacktop</span>,  <span class="hljs-title class_">ElBadge</span>]<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cpn <span class="hljs-keyword">of</span> components) &#123;  app.<span class="hljs-title function_">component</span>(cpn.<span class="hljs-property">name</span>, cpn)&#125;</code></pre></div><p>20211212 新版本按需自动导入elementplus</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// webpack.config.js</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">AutoImport</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;unplugin-auto-import/webpack&#x27;</span>)<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Components</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;unplugin-vue-components/webpack&#x27;</span>)<span class="hljs-keyword">const</span> &#123; ElementPlusResolver &#125; = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span>)module.exports = &#123;  <span class="hljs-comment">// ...</span>  plugins: [    <span class="hljs-title function_ invoke__">AutoImport</span>(&#123;      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title function_ invoke__">ElementPlusResolver</span>()],    &#125;),    <span class="hljs-title function_ invoke__">Components</span>(&#123;      <span class="hljs-attr">resolvers</span>: [<span class="hljs-title function_ invoke__">ElementPlusResolver</span>()],    &#125;),  ],&#125;</code></pre></div><h3 id="2-5-axios集成"><a href="#2-5-axios集成" class="headerlink" title="2.5. axios集成"></a>2.5. axios集成</h3><p>安装axios：</p><div class="code-wrapper"><pre><code class="hljs shell">npm install axios</code></pre></div><p>封装axios：</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> axios, &#123; <span class="hljs-title class_">AxiosInstance</span>, <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Result</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./types&#x27;</span><span class="hljs-keyword">import</span> &#123; useUserStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/@/store/modules/user&#x27;</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HYRequest</span> &#123;  <span class="hljs-keyword">private</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">AxiosInstance</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">options</span>: <span class="hljs-title class_">AxiosRequestConfig</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options: AxiosRequestConfig</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = axios.<span class="hljs-title function_">create</span>(options)    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;        <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">useUserStore</span>().<span class="hljs-property">getToken</span>        <span class="hljs-keyword">if</span> (token) &#123;          config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span>        &#125;        <span class="hljs-keyword">return</span> config      &#125;,      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> err      &#125;    )    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 拦截响应的数据</span>        <span class="hljs-keyword">if</span> (res.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>        &#125;        <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>      &#125;,      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> err      &#125;    )  &#125;  request&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>        .<span class="hljs-property">request</span>&lt;<span class="hljs-built_in">any</span>, <span class="hljs-title class_">AxiosResponse</span>&lt;<span class="hljs-title class_">Result</span>&lt;T&gt;&gt;&gt;(config)        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-title function_">resolve</span>((res <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Promise</span>&lt;T&gt;)        &#125;)        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;          <span class="hljs-title function_">reject</span>(err)        &#125;)    &#125;)  &#125;  get&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span> &#125;)  &#125;  post&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span> &#125;)  &#125;  patch&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PATCH&#x27;</span> &#125;)  &#125;  <span class="hljs-keyword">delete</span>&lt;T = <span class="hljs-built_in">any</span>&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">AxiosRequestConfig</span>): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;DELETE&#x27;</span> &#125;)  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HYRequest</span></code></pre></div><h3 id="2-6-VSCode配置"><a href="#2-6-VSCode配置" class="headerlink" title="2.6. VSCode配置"></a>2.6. VSCode配置</h3><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;workbench.iconTheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vscode-great-icons&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">17</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;eslint.migration.2_x&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;[javascript]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dbaeumer.vscode-eslint&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;files.autoSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;afterDelay&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.tabSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;terminal.integrated.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">16</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.renderWhitespace&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;all&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.quickSuggestions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;strings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;debug.console.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">15</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;window.zoomLevel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;emmet.includeLanguages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;javascript&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;javascriptreact&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;explorer.confirmDragAndDrop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;workbench.tree.indent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">16</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;javascript.updateImportsOnFileMove.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;always&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.wordWrap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;on&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;path-intellisense.mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;@&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceRoot&#125;/src&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;hediet.vscode-drawio.local-storage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eyIuZHJhd2lvLWNvbmZpZyI6IntcImxhbmd1YWdlXCI6XCJcIixcImN1c3RvbUZvbnRzXCI6W10sXCJsaWJyYXJpZXNcIjpcImdlbmVyYWw7YmFzaWM7YXJyb3dzMjtmbG93Y2hhcnQ7ZXI7c2l0ZW1hcDt1bWw7YnBtbjt3ZWJpY29uc1wiLFwiY3VzdG9tTGlicmFyaWVzXCI6W1wiTC5zY3JhdGNocGFkXCJdLFwicGx1Z2luc1wiOltdLFwicmVjZW50Q29sb3JzXCI6W1wiRkYwMDAwXCIsXCIwMENDNjZcIixcIm5vbmVcIixcIkNDRTVGRlwiLFwiNTI1MjUyXCIsXCJGRjMzMzNcIixcIjMzMzMzM1wiLFwiMzMwMDAwXCIsXCIwMENDQ0NcIixcIkZGNjZCM1wiLFwiRkZGRkZGMDBcIl0sXCJmb3JtYXRXaWR0aFwiOjI0MCxcImNyZWF0ZVRhcmdldFwiOmZhbHNlLFwicGFnZUZvcm1hdFwiOntcInhcIjowLFwieVwiOjAsXCJ3aWR0aFwiOjExNjksXCJoZWlnaHRcIjoxNjU0fSxcInNlYXJjaFwiOnRydWUsXCJzaG93U3RhcnRTY3JlZW5cIjp0cnVlLFwiZ3JpZENvbG9yXCI6XCIjZDBkMGQwXCIsXCJkYXJrR3JpZENvbG9yXCI6XCIjNmU2ZTZlXCIsXCJhdXRvc2F2ZVwiOnRydWUsXCJyZXNpemVJbWFnZXNcIjpudWxsLFwib3BlbkNvdW50ZXJcIjowLFwidmVyc2lvblwiOjE4LFwidW5pdFwiOjEsXCJpc1J1bGVyT25cIjpmYWxzZSxcInVpXCI6XCJcIn0ifQ==&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;hediet.vscode-drawio.theme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Kennedy&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.fontFamily&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Source Code Pro, &#x27;Courier New&#x27;, monospace&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.smoothScrolling&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esbenp.prettier-vscode&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;workbench.colorTheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Atom One Dark&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;vetur.completion.autoImport&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;security.workspace.trust.untrustedFiles&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;open&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;eslint.lintTask.enable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;eslint.alwaysShowStatus&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>  <span class="hljs-attr">&quot;editor.codeActionsOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;source.fixAll.eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="三-接口文档"><a href="#三-接口文档" class="headerlink" title="三. 接口文档"></a>三. 接口文档</h2><p><a href="https://documenter.getpostman.com/view/12387168/TzsfmQvw">https://documenter.getpostman.com/view/12387168/TzsfmQvw</a></p><p>baseURL的值：</p><div class="code-wrapper"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">152.136</span>.<span class="hljs-number">185.210</span>:<span class="hljs-number">5000</span></code></pre></div><p>设置全局token的方法：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> res = pm.<span class="hljs-property">response</span>.<span class="hljs-title function_">json</span>();pm.<span class="hljs-property">globals</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;token&quot;</span>, res.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>);</code></pre></div><p>接口文档v2版本：（有部分更新）</p><p><a href="https://documenter.getpostman.com/view/12387168/TzzDKb12">https://documenter.getpostman.com/view/12387168/TzzDKb12</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟列表的实现</title>
    <link href="/2022/09/11/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/11/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现一个时间格式化工具</title>
    <link href="/2022/09/11/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/09/11/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 如何封装一个时间格式化工具</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">formatTime</span>(<span class="hljs-params">timeStamp, fmtString</span>) &#123;  <span class="hljs-comment">// 1.先将时间戳转成Date的形式</span>  <span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(timeStamp);  <span class="hljs-comment">// 2.建立正则表达式和值匹配的映射</span>  <span class="hljs-keyword">const</span> dateObject = &#123;    <span class="hljs-string">&quot;y+&quot;</span>: date.<span class="hljs-title function_">getFullYear</span>(),    <span class="hljs-string">&quot;M+&quot;</span>: date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>,    <span class="hljs-string">&quot;d+&quot;</span>: date.<span class="hljs-title function_">getDate</span>(),    <span class="hljs-string">&quot;h+&quot;</span>: date.<span class="hljs-title function_">getHours</span>(),    <span class="hljs-string">&quot;m+&quot;</span>: date.<span class="hljs-title function_">getMinutes</span>(),    <span class="hljs-string">&quot;s+&quot;</span>: date.<span class="hljs-title function_">getSeconds</span>(),  &#125;;  <span class="hljs-comment">// 遍历dateObject匹配</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> dateObject) &#123;    <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(key);    <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(fmtString)) &#123;      fmtString = fmtString.<span class="hljs-title function_">replace</span>(reg, (dateObject[key] + <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">padStart</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));    &#125;  &#125;  <span class="hljs-keyword">return</span> fmtString;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">formatTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>(), <span class="hljs-string">&quot;yyyy-MM-dd:hh:mm:ss&quot;</span>)); <span class="hljs-comment">//2022-09-11:17:05:48</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>electron 安装问题</title>
    <link href="/2022/09/11/electron-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/11/electron-%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs crmsh">$ npm install electron --save-devnpm ERR! code <span class="hljs-number">1</span>npm ERR! path C:\Users\<span class="hljs-number">10152</span>\Desktop\study\代码碎屑\electron练习\my-electron-app\node_modules\electronnpm ERR! command failednpm ERR! command C:\WINDOWS\system32\cmd.exe /d /s /c <span class="hljs-keyword">node</span> <span class="hljs-title">install</span>.jsnpm ERR! RequestError: <span class="hljs-keyword">read</span> ECONNRESETnpm ERR!     at ClientRequest.<span class="hljs-tag">&lt;anonymous&gt;</span> (C:\Users\<span class="hljs-number">10152</span>\Desktop\study\代码碎屑\electron练习\my-electron-app\node_modules\got\source\request-as-event-emitter.js:<span class="hljs-number">178</span>:<span class="hljs-number">14</span>)npm ERR!     at Object.onceWrapper (<span class="hljs-keyword">node</span><span class="hljs-title">:events</span>:<span class="hljs-number">642</span>:<span class="hljs-number">26</span>)npm ERR!     at ClientRequest.emit (<span class="hljs-keyword">node</span><span class="hljs-title">:events</span>:<span class="hljs-number">539</span>:<span class="hljs-number">35</span>)npm ERR!     at ClientRequest.origin.emit (C:\Users\<span class="hljs-number">10152</span>\Desktop\study\代码碎屑\electron练习\my-electron-app\node_modules\@szmarczak\http-timer\source\index.js:<span class="hljs-number">37</span>:<span class="hljs-number">11</span>)npm ERR!     at TLSSocket.socketErrorListener (<span class="hljs-keyword">node</span><span class="hljs-title">:_http_client</span>:<span class="hljs-number">454</span>:<span class="hljs-number">9</span>)npm ERR!     at TLSSocket.emit (<span class="hljs-keyword">node</span><span class="hljs-title">:events</span>:<span class="hljs-number">527</span>:<span class="hljs-number">28</span>)npm ERR!     at emitErrorNT (<span class="hljs-keyword">node</span><span class="hljs-title">:internal</span>/streams/destroy:<span class="hljs-number">157</span>:<span class="hljs-number">8</span>)npm ERR!     at emitErrorCloseNT (<span class="hljs-keyword">node</span><span class="hljs-title">:internal</span>/streams/destroy:<span class="hljs-number">122</span>:<span class="hljs-number">3</span>)npm ERR!     at processTicksAndRejections (<span class="hljs-keyword">node</span><span class="hljs-title">:internal</span>/process/task_queues:<span class="hljs-number">83</span>:<span class="hljs-number">21</span>)npm ERR! A complete log of this run can be found <span class="hljs-keyword">in</span>:npm ERR!     D:\nodejs\node_cache\_logs\<span class="hljs-number">2022</span>-<span class="hljs-number">09</span>-<span class="hljs-number">10</span>T16_55_35_246Z-debug-<span class="hljs-number">0</span>.log</code></pre></div><p>eletron安装不成功可以设置下源</p><div class="code-wrapper"><pre><code class="hljs awk">npm config set ELECTRON_MIRROR https:<span class="hljs-regexp">//</span>npmmirror.com<span class="hljs-regexp">/mirrors/</span>electron/</code></pre></div><h4 id="electron-控制台中文乱码问题"><a href="#electron-控制台中文乱码问题" class="headerlink" title="electron 控制台中文乱码问题"></a>electron 控制台中文乱码问题</h4><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;   <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;</span><span class="hljs-keyword">Error</span>: <span class="hljs-keyword">no</span> <span class="hljs-keyword">test</span> specified\<span class="hljs-string">&quot; &amp;&amp; exit 1&quot;</span>,   <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;chcp 65001 &amp;&amp; electron .&quot;</span> &#125;,</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Electron</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Electron学习</title>
    <link href="/2022/09/10/Electron%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/10/Electron%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Electron</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>https了解</title>
    <link href="/2022/09/09/https%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/09/09/https%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http3了解</title>
    <link href="/2022/09/09/http3%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/09/09/http3%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node学习笔记</title>
    <link href="/2022/09/09/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/09/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-number">1.</span>node的输出<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">clear</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">trace</span>()<span class="hljs-number">2.</span>常见的全局对象特殊的全局对象，是各个模块都有的，但不是属于全局的__dirname<span class="hljs-comment">//获取当前文件所在的路径，不包括后面的文件名</span>__filename<span class="hljs-comment">//获取当前文件所在的路径名称包括文件名</span><span class="hljs-built_in">exports</span><span class="hljs-variable language_">module</span><span class="hljs-built_in">require</span>常见的全局对象process对象<span class="hljs-variable language_">console</span>对象定时器对象<span class="hljs-number">3.</span><span class="hljs-variable language_">global</span>和<span class="hljs-variable language_">window</span>的区别node中每一个文件都是一个独立的模块<span class="hljs-number">4.</span>模块化立即调用函数(<span class="hljs-variable constant_">IIFE</span>)是解决模块化的一种方式<span class="hljs-title class_">CommonJS</span>(<span class="hljs-variable constant_">CJS</span>)<span class="hljs-title class_">ESmodule</span>每个模块都有<span class="hljs-built_in">exports</span>,他会默认指向空对象,<span class="hljs-built_in">exports</span>指向的一个对象并在另外一个模块中被引用时，他们是指向同一个对象<span class="hljs-built_in">require</span>是对<span class="hljs-built_in">exports</span>的浅拷贝浅拷贝的本质就是引用赋值<span class="hljs-built_in">exports</span>中修改变量会使<span class="hljs-built_in">require</span>发生变化<span class="hljs-built_in">require</span>中的修改不会对<span class="hljs-built_in">exports</span>造成影响，因为<span class="hljs-built_in">require</span>是对<span class="hljs-built_in">exports</span>的拷贝<span class="hljs-number">5.</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>每一个模块都有一个<span class="hljs-variable language_">module</span>实例commomjs中没有<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>的概念，node中使用的是<span class="hljs-title class_">Moudle</span>类，每一个模块都是<span class="hljs-title class_">Modlue</span>的实例，也是<span class="hljs-variable language_">module</span>所以在<span class="hljs-title class_">Node</span>中真正导出的其实不是<span class="hljs-keyword">export</span>,而是<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>为什么<span class="hljs-built_in">exports</span>也可以导出因为<span class="hljs-variable language_">module</span>对象的<span class="hljs-built_in">exports</span>属性是<span class="hljs-keyword">export</span>对象的一个引用，也就是<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=<span class="hljs-built_in">exports</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>导出的值才是<span class="hljs-built_in">require</span>的值，默认<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>==<span class="hljs-keyword">export</span>,如果<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>指向另外一个值，则<span class="hljs-built_in">require</span>会引用这个值，而不是<span class="hljs-keyword">export</span>的值<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>的赋值是在顶层的<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=<span class="hljs-built_in">exports</span><span class="hljs-built_in">exports</span>=<span class="hljs-number">123</span><span class="hljs-comment">//module.exports在顶层引用的，如果后面再次修改exports的指向，则会无效</span><span class="hljs-number">6.</span><span class="hljs-built_in">require</span>()的查找规则<span class="hljs-number">1.</span>如果x是核心模块，直接会返回核心模块，<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;x&quot;</span>)<span class="hljs-comment">//会直接返回，停止查找</span><span class="hljs-number">2.</span>x是以./或者../或者/开头的会先将x当作一个文件先查找，如果有后缀名，则按后缀名格式查找，如果没有后缀名则<span class="hljs-number">1.</span>直接查找文件x<span class="hljs-number">2.</span>查找x.<span class="hljs-property">js</span><span class="hljs-number">3.</span>查找x.<span class="hljs-property">json</span><span class="hljs-number">4.</span>查找x.<span class="hljs-property">node</span>如果没有找到对应的文件，则会把他当成一个目录，查找里面的index文件<span class="hljs-number">1.</span>x/index.<span class="hljs-property">js</span><span class="hljs-number">2.</span>x/index.<span class="hljs-property">json</span><span class="hljs-number">3.</span>x/index.<span class="hljs-property">node</span>否则报错 not found<span class="hljs-number">3.</span>如果直接是一个<span class="hljs-title function_">X</span>(没有路径) 并且X不是一个核心模块则从最里面的node_module-&gt;最外面的node_module中去寻找<span class="hljs-number">7.</span><span class="hljs-built_in">require</span>的加载过程是同步的 <span class="hljs-number">8.</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>=&#123;&#125; <span class="hljs-built_in">exports</span>=<span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>===<span class="hljs-keyword">export</span>=&#123;&#125; <span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span>=<span class="hljs-built_in">exports</span><span class="hljs-number">9.</span>在源码中<span class="hljs-built_in">exports</span>=<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span><span class="hljs-number">10.</span>模块的加载过程模块在被第一次引入时，模块中的js代码会被运行一次模块被对此引入时，会被缓存，最终只会被加载一次如果有循环引入，他会按深度优先搜索遍历的方式进行加载<span class="hljs-number">11.</span><span class="hljs-variable constant_">ES</span> modules中<span class="hljs-keyword">export</span> &#123;&#125;<span class="hljs-comment">//不是一个对象，里面放置要到处的变量的列表</span><span class="hljs-keyword">import</span>默认必须放到顶部，<span class="hljs-keyword">import</span>是异步加载，<span class="hljs-keyword">import</span>加载模块不可以放到逻辑代码中<span class="hljs-title function_">import</span>().<span class="hljs-title function_">then</span>()<span class="hljs-comment">//进行动态加载</span><span class="hljs-number">12.</span>commonJS加载过程commonjs加载js文件的过程是运行时加载，并且是同步的，就是js引擎在执行代码的过程中加载模块同步意味着一个文件在没有加载结束之前，后面的代码都不加在commonjs通过<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>的导出一个对象，导出的是一个对象意味者可以将这个对象的引用在其他模块中赋值给其他变量，但是最终他们会指向同一个变量，那么一个变量修改了对象的属性，所有地方都会修改注意：<span class="hljs-built_in">require</span>进行解构的时候不会修改，因为解构会固定下当前的值<span class="hljs-number">13.</span><span class="hljs-variable constant_">ES</span> <span class="hljs-variable language_">module</span>的加载过程   <span class="hljs-variable constant_">ES</span> <span class="hljs-variable constant_">MODULE</span>加载js是编译的时候加载的，并且是异步的   编译时加载意味着<span class="hljs-keyword">import</span>不能和运行相关的内容放在一起使用   比如<span class="hljs-keyword">from</span>后面的路径要动态获取   比如不能将<span class="hljs-keyword">import</span>放到<span class="hljs-keyword">if</span>语句的代码块里面，所以es <span class="hljs-variable language_">module</span>时静态解析   异步意味着js引擎遇到<span class="hljs-keyword">import</span>时会获取到这个js文件，但是这个获取的过程是异步的，并不会阻塞进程的执行   <span class="hljs-keyword">type</span>-=<span class="hljs-variable language_">module</span>相当于script上的<span class="hljs-keyword">async</span>属性，如果后面还有js代码，他不会阻塞js代码的执行   <span class="hljs-variable constant_">ES</span> <span class="hljs-title class_">Module</span>通过<span class="hljs-keyword">export</span>导出的是变量本身的引用： <span class="hljs-keyword">export</span>在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（<span class="hljs-variable language_">module</span> environment record）； 模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的； 而在导入的地方，我们是可以实时的获取到绑定的最新值的；  所以，如果在导出的模块中修改了变化，那么导入的地方可以实时获取最新的变量；  注意：在导入的地方不可以修改变量，因为它只是被绑定到了这个变量上（其实是一个常量）   <span class="hljs-number">14.</span>在node中要使用es <span class="hljs-variable language_">module</span> 方式一：package.<span class="hljs-property">json</span>中配置<span class="hljs-attr">type</span>:<span class="hljs-variable language_">module</span> 方式二:使用以.<span class="hljs-property">mjs</span>结尾的文件 <span class="hljs-number">15.</span>内置模块path 从路径获取信息 <span class="hljs-title function_">dirname</span>()<span class="hljs-comment">//获取文件的父文件夹</span> <span class="hljs-title function_">basename</span>()<span class="hljs-comment">//获取文件名</span> <span class="hljs-title function_">extname</span>()<span class="hljs-comment">//获取文件扩展名</span> 路径的拼接 如果我们希望将多个路径进行拼接，但是不同的操作系统可能是使用不同的分隔符 这个时候我们可以使用path.<span class="hljs-property">join</span>函数 将文件和某个文件夹拼接 如果我们希望将某个文件和文件夹拼接，可以使用path.<span class="hljs-property">resolve</span> resolve函数会判断我们拼接的路径前面是否有/或者../或者./ 如果有表示是一个绝对路径，会返回对应的拼接路径 如果没有，那么会和当前执行文件所在的文件夹进行路径的拼接 path.<span class="hljs-title function_">resolve</span>() 方法将路径或路径片段的序列解析为绝对路径。 如果没有传入 path 片段，则 path.<span class="hljs-title function_">resolve</span>() 将返回当前工作目录的绝对路径。  path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;/foo/bar&#x27;</span>, <span class="hljs-string">&#x27;./baz&#x27;</span>);            <span class="hljs-comment">// 返回: &#x27;/foo/bar/baz&#x27;</span>            path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;/foo/bar&#x27;</span>, <span class="hljs-string">&#x27;/tmp/file/&#x27;</span>);            <span class="hljs-comment">// 返回: &#x27;/tmp/file&#x27;</span>            path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;wwwroot&#x27;</span>, <span class="hljs-string">&#x27;static_files/png/&#x27;</span>, <span class="hljs-string">&#x27;../gif/image.gif&#x27;</span>);            <span class="hljs-comment">// 如果当前工作目录是 /home/myself/node，</span>            <span class="hljs-comment">// 则返回 &#x27;/home/myself/node/wwwroot/static_files/gif/image.gif&#x27;</span> <span class="hljs-number">16.</span>fs模块 fs操作文件的三种方式</code></pre></div><p><img src="https://img1.imgtp.com/2022/09/11/T30nJvRF.png" alt="QQ截图20220618120700.png"></p><p>17.文件描述符</p><p>​    在POSIX系统上，对于每个进程，内核都维护者一张当前打开的资源和文件的表格</p><p>​    每个打开的文件都会分配一个称为文件秒师傅的简单数字标识符</p><p>​    在系统层，所有系统操作都是使用这些文件描述符来标识和跟踪每一个特定文件</p><p>​    windows系统有不同的机制</p><p>​    fs.open()用于分配新的文件描述符，一旦被分配，则文件描述符可用于文件的读取数据，向文件写入数据或者请求关于文件的信息</p><p><img src="https://img1.imgtp.com/2022/09/11/TXLJdkIn.png" alt="QQ截图20220619093740.png"></p><p>18.文件的读写</p><p>​    </p><div class="code-wrapper"><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File(<span class="hljs-params">path</span>,<span class="hljs-params">options</span>?,<span class="hljs-params">callback</span>)</span>   <span class="hljs-comment">//读取文件的内容</span>fs.write<span class="hljs-constructor">File(<span class="hljs-params">file</span>,<span class="hljs-params">data</span>,<span class="hljs-params">options</span>?,<span class="hljs-params">callback</span>)</span> <span class="hljs-comment">//写入文件</span></code></pre></div><p><img src="https://img1.imgtp.com/2022/09/11/gbD9UytN.png" alt="QQ截图20220619094754.png"></p><div class="code-wrapper"><pre><code class="hljs dts">options中的属性<span class="hljs-symbol">flag:</span>写入的方式<span class="hljs-symbol">w:</span>打开文件写入，默认值w+:打开文件进行读写，如果不存在则会创建文件r+:打开文件进行读写，如果不存在就会抛出异常<span class="hljs-symbol">r:</span>打开文件读取，读取时的默认值<span class="hljs-symbol">a:</span>打开要写入的文件，将流放在文件的末尾，如果不存在则会创建文件a+:打开文件进行读写，将流放到文件末尾，如果不存在则创建<span class="hljs-symbol">encoding:</span>字符的编码现在基本上使用utf<span class="hljs-number">-8</span>如果不填encoding则会返回buffer</code></pre></div><p>19.文件夹的操作</p><p><img src="https://img1.imgtp.com/2022/09/11/ladw1Jt6.png" alt="QQ截图20220619093820.png"><br>20.events模块</p><p>​     Node中的核心API都是基于异步事件驱动的：</p><p>​     发出事件和监听事件都是通过EventEmitter类来完成，他们都是属于events对象</p><p>​      </p><div class="code-wrapper"><pre><code class="hljs mel">const <span class="hljs-keyword">emitter</span>=new EventEmitter()<span class="hljs-keyword">emitter</span>.on(eventName.listener)<span class="hljs-comment">//监听事件，也可以使用addListener</span><span class="hljs-keyword">emitter</span>.off(eventName.listener)<span class="hljs-comment">//移出事件监听，也可以使用removeLitener</span><span class="hljs-keyword">emitter</span>.<span class="hljs-keyword">emit</span>(eventName,...args?)<span class="hljs-comment">//发出事件，可以携带参数</span></code></pre></div><p><img src="https://img1.imgtp.com/2022/09/11/gbfKncoB.png" alt="QQ截图20220619135051.png"><br><img src="https://img1.imgtp.com/2022/09/11/z58jVfjS.png" alt="QQ截图20220619135226.png"></p><div class="code-wrapper"><pre><code class="hljs shij">emitter.once(eventName,listener)事件只监听一次emitter.prependListener()将监听事件添加到最前面emitter.prependOnceListener()将监听事件添加到最前面但只监听一次emitter.removeAllListeners(eventName?)移除所有事件</code></pre></div><p>21、npm包管理工具</p><p>​            npm run start=&gt;npm start</p><p>​            npm run test=&gt;npm test</p><p>​            npm run stop=&gt;npm stop</p><p>​            npm run restart=&gt;npm restart</p><p>22.npm config get cache //cmd中执行查看缓存所在目录</p><p>23.Buffer类</p><p>​    使用Buffer来存储二进制</p><p>​    buf=Buffer.from()//转换成buffer</p><p>​    中文会转换成unicode编码  3个unicode编码代表一个汉字 默认是utf8编码</p><p>​    <code>buf.toString([encoding[, start[, end]]])</code>//解码 encode默认是utf8</p><p>​    buffer的另外一种创建方式</p><p>​    <code>Buffer.alloc(size[, fill[, encoding]])</code> size表示创建的大小 默认是utf8</p><p>​    buffer可以将图片转换成二进制流进行传输，也可以把二进制转换成图片存储</p><p>24.读取文件返回的是一个二进制流</p><p><img src="https://img1.imgtp.com/2022/09/11/yyxGHUMi.png" alt="QQ截图20220623141058.png"><br>25.读取图片并且写入到另外一个文件</p><p><img src="https://img1.imgtp.com/2022/09/11/TduZGuBK.png" alt="QQ截图20220623141209.png"><br>26.sharp插件进行设置图片</p><p>27.Buffer的创建过程</p><p>​    事实上我们创建Buffer时，并不会频繁的向操作系统申请内存，它会默认先申请一个8 * 1024个字节大小的内存， 也就是8kb</p><p>28.Buffer的源码</p><p>29.进程和线程</p><p>​    进程:启动一个程序，既可以默认开启一个进程（也可以多进程）</p><p>​    线程：操作系统能够运行调度的最小单位</p><p>30.Node事件循环的阶段</p><p>​     一次完整的事件循环Tick分成很多个阶段</p><p>​    定时器(Timer):本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数</p><p>​    待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到 ECONNREFUSED</p><p>​    idle, prepare：仅系统内部使用</p><p>​    轮询（Poll）：检索新的 I/O 事件；执行与 I/O 相关的回调</p><p>​    检测：setImmediate() 回调函数在这里执行</p><p>​    关闭的回调函数：一些关闭的回调函数，如：socket.on(‘close’, …)</p><p>31.Node的微任务和宏任务</p><p>​    微任务队列</p><p>​    nettick queue:process.nextTick</p><p>​    other queue:Promise的then回调，queueMicrotask</p><p>​    宏任务队列</p><p>​    timer queue:setTimeout,setInterval    </p><p>​    poll queue :IO事件</p><p>​    check queue:setImmediate</p><p>​    close queue:close事件</p><p>32.Stream可以读取或者写入部分</p><p>​    4.中基本的流类型</p><p>​        writable:可以向其写人数据的流 fs.createWriteStream()</p><p>​        Readable:可以从中读取数据的流 fs.createReadStream()</p><p>​        Duplex：同时为Readable和wratable net.Socket</p><p>​        Transform:Duplex可以在写入和读取数据时修改或者转换数据的流  zlib.createDeflate()</p><p>33.Readable</p><p><img src="https://img1.imgtp.com/2022/09/11/QggeUwVk.png" alt="QQ截图20220624165628.png"><br>34.writable</p><p><img src="https://img1.imgtp.com/2022/09/11/14Ca9DGs.png" alt="QQ截图20220624183130.png"><br>35.pipe</p><p>从读取到输出到另外一个文件也可以这么写</p><p><img src="https://img1.imgtp.com/2022/09/11/14Ca9DGs.png" alt="QQ截图20220624183130.png"><br>36.http</p><p>安装nodemon来热更新自动启动</p><p>37.axios可以在浏览器用也可以在node中用，浏览器用的是xhr,node中使用的是http内置模块</p><p>38.文件上传</p><p>39.express</p><p>​        express核心是中间件</p><p>​        安装express</p><p>​        1.创建一个文件夹 </p><p>​        2.npx express-generator</p><p>​        3.npm install</p><p>​        4.DEBUG=express:* npm start</p><p>​        第二种安装方式</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<span class="hljs-built_in">npm</span> install express</code></pre></div><p>40.中间件</p><p>41.文件上传</p><p>​    使用multer  npm install multer</p><p>42.打印日志</p><p>​    使用morgan npm install morgan</p><p>43express路由</p><p>44.使用express部署静态资源，将express作为静态资源服务器</p><p>45.错误处理</p><p>46.调用express()到底创建的是什么</p><p>47.app.listen()启动服务器</p><p>​        如何可以结合原生来启动服务器</p><p>​        express-&gt;http.createServer.listen</p><p>48.app.use(中间件)内部发生了什么</p><p>49.用户发送了请求，中间件是如何被回调</p><p>50.next的为什么会执行下一个中间件</p><p>51.koa洋葱模型</p><p>​        koa的同步和异步都是符合洋葱模型的</p><p>​        express只有同步代码才会符合洋葱模型</p><p>52.koa和express的区别</p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用axios封装请求工具</title>
    <link href="/2022/09/09/%E4%BD%BF%E7%94%A8axios%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/09/09/%E4%BD%BF%E7%94%A8axios%E5%B0%81%E8%A3%85%E8%AF%B7%E6%B1%82%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//request.js</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">AxiosInstance</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RequestInterceptors</span>, <span class="hljs-title class_">RequestConfig</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./type&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElLoading</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-plus&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_LOADING</span> = <span class="hljs-literal">true</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">axiosRequest</span> &#123;  <span class="hljs-attr">instance</span>: <span class="hljs-title class_">AxiosInstance</span>;  interceptors?: <span class="hljs-title class_">RequestInterceptors</span>;  <span class="hljs-attr">showLoading</span>: boolean;  loading?: any;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">config: RequestConfig</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = axios.<span class="hljs-title function_">create</span>(config);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span> = config.<span class="hljs-property">showLoading</span> ?? <span class="hljs-variable constant_">DEFAULT_LOADING</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span> = config.<span class="hljs-property">interceptors</span>;    <span class="hljs-comment">// 将config中的拦截器传入</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestInterceptor</span>,      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestInterceptorCatch</span>,    );    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseInterceptor</span>,      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseInterceptorCatch</span>,    );    <span class="hljs-comment">// 设置通用的拦截器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span>) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span> = <span class="hljs-title class_">ElLoading</span>.<span class="hljs-title function_">service</span>(&#123;            <span class="hljs-attr">lock</span>: <span class="hljs-literal">true</span>,            <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;正在请求数据。。。。。&quot;</span>,            <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>,          &#125;);        &#125;        <span class="hljs-keyword">return</span> config;      &#125;,      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> err;      &#125;,    );    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(      <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span>?.<span class="hljs-title function_">close</span>();        <span class="hljs-keyword">const</span> data = res.<span class="hljs-property">data</span>;        <span class="hljs-keyword">if</span> (data.<span class="hljs-property">returnCode</span> == <span class="hljs-string">&quot;-1001&quot;</span>) &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求失败————————————————————————————&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-keyword">return</span> data;        &#125;      &#125;,      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">loading</span>?.<span class="hljs-title function_">close</span>();        <span class="hljs-keyword">if</span> (err.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&quot;404&quot;</span>) &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;页面不存在&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> err;      &#125;,    );  &#125;  request&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">requestInterceptor</span>) &#123;        config = config.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">requestInterceptor</span>(config);      &#125;      <span class="hljs-keyword">if</span> (config.<span class="hljs-property">showLoading</span> === <span class="hljs-literal">false</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span> = config.<span class="hljs-property">showLoading</span>;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span>        .<span class="hljs-property">request</span>&lt;any, T&gt;(config)        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (config.<span class="hljs-property">interceptors</span>?.<span class="hljs-property">responseInterceptor</span>) &#123;            res = config.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">responseInterceptor</span>(res);          &#125;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span> = <span class="hljs-variable constant_">DEFAULT_LOADING</span>;          <span class="hljs-title function_">resolve</span>(res);        &#125;)        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">showLoading</span> = <span class="hljs-variable constant_">DEFAULT_LOADING</span>;          <span class="hljs-title function_">reject</span>(err);          <span class="hljs-keyword">return</span> err;        &#125;);    &#125;);  &#125;  get&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span> &#125;);  &#125;  post&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span> &#125;);  &#125;  <span class="hljs-keyword">delete</span>&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;DELETE&quot;</span> &#125;);  &#125;  patch&lt;T = any&gt;(<span class="hljs-attr">config</span>: <span class="hljs-title class_">RequestConfig</span>&lt;T&gt;): <span class="hljs-title class_">Promise</span>&lt;T&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>&lt;T&gt;(&#123; ...config, <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;PATCH&quot;</span> &#125;);  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> axiosRequest;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//type.js</span><span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">AxiosRequestConfig</span>, <span class="hljs-title class_">AxiosResponse</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<span class="hljs-keyword">export</span> interface <span class="hljs-title class_">RequestInterceptors</span>&lt;T = <span class="hljs-title class_">AxiosResponse</span>&gt; &#123;  requestInterceptor?: <span class="hljs-function">(<span class="hljs-params">config: AxiosRequestConfig</span>) =&gt;</span> <span class="hljs-title class_">AxiosRequestConfig</span>;  requestInterceptorCatch?: <span class="hljs-function">(<span class="hljs-params">error: any</span>) =&gt;</span> any;  responseInterceptor?: <span class="hljs-function">(<span class="hljs-params">res: T</span>) =&gt;</span> T;  responseInterceptorCatch?: <span class="hljs-function">(<span class="hljs-params">error: any</span>) =&gt;</span> any;&#125;<span class="hljs-keyword">export</span> interface <span class="hljs-title class_">RequestConfig</span>&lt;T = <span class="hljs-title class_">AxiosResponse</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AxiosRequestConfig</span> &#123;  interceptors?: <span class="hljs-title class_">RequestInterceptors</span>&lt;T&gt;;  showLoading?: boolean;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//index.js</span><span class="hljs-keyword">import</span> axiosRequest <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./request&quot;</span>;<span class="hljs-keyword">import</span> localCache <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/cache&quot;</span>;<span class="hljs-keyword">const</span> httpRequest = <span class="hljs-keyword">new</span> <span class="hljs-title function_">axiosRequest</span>(&#123;  <span class="hljs-attr">baseURL</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_APP_BASE_URL</span>,  <span class="hljs-attr">timeout</span>: <span class="hljs-title class_">Number</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_TIME_OUT</span>),  <span class="hljs-attr">interceptors</span>: &#123;    <span class="hljs-attr">requestInterceptor</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> token = localCache.<span class="hljs-title function_">getCache</span>(<span class="hljs-string">&quot;token&quot;</span>);      <span class="hljs-keyword">if</span> (token) &#123;        config.<span class="hljs-property">headers</span> = &#123;&#125;;        config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;token&#125;</span>`</span>;      &#125;      <span class="hljs-keyword">return</span> config;    &#125;,    <span class="hljs-attr">requestInterceptorCatch</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> error;    &#125;,    <span class="hljs-attr">responseInterceptor</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> res;    &#125;,    <span class="hljs-attr">responseInterceptorCatch</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> error;    &#125;,  &#125;,&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> httpRequest;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>axios</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gulp学习</title>
    <link href="/2022/09/08/gulp%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/08/gulp%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>glup</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>rollup学习</title>
    <link href="/2022/09/08/rollup%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/08/rollup%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>rollup</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vite3学习</title>
    <link href="/2022/09/08/vite3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/08/vite3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>vite</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack5学习</title>
    <link href="/2022/09/08/webpack5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/08/webpack5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//path.js</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> appDir = process.<span class="hljs-title function_">cwd</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Current directory: <span class="hljs-subst">$&#123;appDir&#125;</span>`</span>);<span class="hljs-keyword">const</span> <span class="hljs-title function_">resolveApp</span> = (<span class="hljs-params">relativePath</span>) =&gt; path.<span class="hljs-title function_">resolve</span>(appDir, relativePath);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = resolveApp;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//webpack.common.js</span><span class="hljs-keyword">const</span> resolveApp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./paths&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">DefinePlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">CopyWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;copy-webpack-plugin&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">ESLintPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;eslint-webpack-plugin&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<span class="hljs-keyword">const</span> productionConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.prod&#x27;</span>);<span class="hljs-keyword">const</span> developmentConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.dev&#x27;</span>);<span class="hljs-comment">/***</span><span class="hljs-comment"> * 这里有三种方法来进行代码分离，它可以减少打包文件大小，减少文件的加载时间</span><span class="hljs-comment"> *  它主要的目的是将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件；</span><span class="hljs-comment">    比如默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，</span><span class="hljs-comment">就会影响首页的加载速度</span><span class="hljs-comment">    代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能</span><span class="hljs-comment">      1.入口起点：使用entry配置手动分离代码；</span><span class="hljs-comment">      2.防止重复：使用Entry Dependencies或者SplitChunksPlugin去重和分离代码；</span><span class="hljs-comment">      3.动态导入：通过模块的内联函数调用来分离代码</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">commonConfig</span> = (<span class="hljs-params">env, args</span>) =&gt; &#123;  <span class="hljs-keyword">const</span> devMode = args.<span class="hljs-property">mode</span> !== <span class="hljs-string">&#x27;production&#x27;</span>;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">entry</span>: [<span class="hljs-string">&#x27;./src/index.js&#x27;</span>],    <span class="hljs-comment">// 多入口文件 如果两个文件引用相同的代码会造成重复打包，增大单个bundle的大小，从而浪费带宽</span>    <span class="hljs-comment">// entry: &#123;</span>    <span class="hljs-comment">//   index: &#x27;./src/index.js&#x27;,</span>    <span class="hljs-comment">//   another: &#x27;./src/another-module.js&#x27;</span>    <span class="hljs-comment">// &#125;,</span>    <span class="hljs-comment">//将公共的包分离出来，减小bundle体积</span>    <span class="hljs-comment">// entry: &#123;</span>    <span class="hljs-comment">//   index: &#123;</span>    <span class="hljs-comment">//     import: &#x27;./src/index.js&#x27;,</span>    <span class="hljs-comment">//     dependOn: &#x27;shared&#x27;</span>    <span class="hljs-comment">//   &#125;,</span>    <span class="hljs-comment">//   another: &#123;</span>    <span class="hljs-comment">//     import: &#x27;./src/another-module.js&#x27;,</span>    <span class="hljs-comment">//     dependOn: &#x27;shared&#x27;</span>    <span class="hljs-comment">//   &#125;,</span>    <span class="hljs-comment">//   shared: &#x27;lodash&#x27;</span>    <span class="hljs-comment">// &#125;,</span>    <span class="hljs-attr">output</span>: &#123;      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;js/[name].bundle.js&#x27;</span>,      <span class="hljs-comment">// 为import().then异步加载使用</span>      <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;js/[name].[hash:6].chunk.js&#x27;</span>,      <span class="hljs-comment">// 必须是一个绝对路径</span>      <span class="hljs-attr">path</span>: <span class="hljs-title function_">resolveApp</span>(<span class="hljs-string">&#x27;./dist&#x27;</span>),      <span class="hljs-comment">// 重新打包时清理dist文件夹</span>      <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>      <span class="hljs-comment">// 使用webpack-dev-middleware需要 目的是让文件在服务器中也可以使用,找到对应的文件,要在生产环境放到服务器中才加</span>      <span class="hljs-comment">// output中的path的作用是告知webpack之后的输出目录</span>      <span class="hljs-comment">// publicPath: &quot;/&quot;,</span>      <span class="hljs-comment">// Asset Modules 将这个模块下的文件输出到dist下的指定文件夹</span>      <span class="hljs-comment">// assetModuleFilename: &quot;img/[name].[hash:6][ext]&quot;</span>    &#125;,    <span class="hljs-comment">// /如果我们要在单个 HTML 页面上使用多个入口点，还需要 optimization.runtimeChunk: &#x27;single&#x27;</span>    <span class="hljs-comment">// optimization: &#123;</span>    <span class="hljs-comment">//   runtimeChunk: &#x27;single&#x27;</span>    <span class="hljs-comment">// &#125;,</span>    <span class="hljs-attr">optimization</span>: &#123;      <span class="hljs-comment">// optimization.chunkIds配置用于告知webpack模块的id采用什么算法生成</span>      <span class="hljs-comment">// natural: 使用自然数(不推荐),</span>      <span class="hljs-comment">// named: 使用包所在目录作为name(在开发环境推荐)</span>      <span class="hljs-comment">// deterministic: 生成id, 针对相同文件生成的id是不变</span>      <span class="hljs-comment">// chunkIds: devMode ? &#x27;deterministic&#x27; : &#x27;named&#x27;,</span>      <span class="hljs-comment">// 方式二使用splitChunkPlugin默认集成</span>      <span class="hljs-attr">splitChunks</span>: &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * async 默认 针对异步导入</span><span class="hljs-comment">         * initial 针对同步导入</span><span class="hljs-comment">         * all 针对同步和异步</span><span class="hljs-comment">         */</span>        <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,        <span class="hljs-comment">// 最小尺寸: 如果拆分出来一个, 那么拆分出来的这个包的大小最小为minSize</span>        <span class="hljs-attr">minSize</span>: <span class="hljs-number">20000</span>,        <span class="hljs-comment">// 将大于maxSize的包, 拆分成不小于minSize的包</span>        <span class="hljs-attr">maxSize</span>: <span class="hljs-number">20000</span>,        <span class="hljs-comment">// 表示至少被引入一次的包才会被分包，没有引用过的不会被打包</span>        <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span>,        <span class="hljs-comment">/**</span><span class="hljs-comment">         * cacheGroups：</span><span class="hljs-comment"> 用于对拆分的包就行分组，比如一个lodash在拆分之后，并不会立即打包，而是会等到有没有其他符合规则的包一起来打</span><span class="hljs-comment">包；</span><span class="hljs-comment"> test属性：匹配符合规则的包；</span><span class="hljs-comment"> name属性：拆分包的name属性；</span><span class="hljs-comment"> filename属性：拆分包的名称，可以自己使用placeholder属性</span><span class="hljs-comment">         */</span>        <span class="hljs-attr">cacheGroups</span>: &#123;          <span class="hljs-attr">vendor</span>: &#123;            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;js/[id]_venders.js&#x27;</span>,            <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span>          &#125;,          <span class="hljs-attr">default</span>: &#123;            <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;js/common_[id].js&#x27;</span>,            <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>          &#125;        &#125;      &#125;,      <span class="hljs-comment">/**optimization. runtimeChunk配置</span><span class="hljs-comment">       * 配置runtime相关的代码是否抽取到一个单独的chunk中：</span><span class="hljs-comment">       * runtime相关的代码指的是在运行环境中，对模块进行解析、加载、模块信息相关的代码；</span><span class="hljs-comment">       * 抽离出来后，有利于浏览器缓存的策略：</span><span class="hljs-comment">       * 比如我们修改了业务代码（main），那么runtime和component、bar的chunk是不需要重新加载的</span><span class="hljs-comment">       * 比如我们修改了component、bar的代码，那么main中的代码是不需要重新加载的</span><span class="hljs-comment">       *   true/multiple ：针对每个入口打包一个runtime文件；</span><span class="hljs-comment">             single 打包一个runtime文件</span><span class="hljs-comment">             object: name name属性决定runtimeChunk的名称；</span><span class="hljs-comment">       */</span>      <span class="hljs-attr">runtimeChunk</span>: &#123;        <span class="hljs-attr">name</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">entrypoint</span>) &#123;          <span class="hljs-keyword">return</span> <span class="hljs-string">`other-<span class="hljs-subst">$&#123;entrypoint.name&#125;</span>`</span>;        &#125;      &#125;    &#125;,    <span class="hljs-attr">module</span>: &#123;      <span class="hljs-attr">rules</span>: [        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,          <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,          <span class="hljs-comment">// 本质上是依赖于typescript(typescript compiler)</span>          <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>        &#125;,        &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx$/i</span>, <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span> &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.m?js$/i</span>,          <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,          <span class="hljs-comment">// 将es6=》es5</span>          <span class="hljs-attr">use</span>: &#123;            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>          &#125;        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,          <span class="hljs-attr">use</span>: [            devMode ? <span class="hljs-string">&#x27;style-loader&#x27;</span> : <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,            &#123;              <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,              <span class="hljs-attr">options</span>: &#123;                <span class="hljs-comment">// 允许在使用css-loader之前加载多少个模块 postcss-loader</span>                <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>              &#125;            &#125;,            <span class="hljs-string">&#x27;postcss-loader&#x27;</span>          ]        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/i</span>,          <span class="hljs-attr">use</span>: [            devMode ? <span class="hljs-string">&#x27;style-loader&#x27;</span> : <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,            &#123;              <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,              <span class="hljs-attr">options</span>: &#123;                <span class="hljs-comment">// 0 =&gt; no loaders (default);</span>                <span class="hljs-comment">// 1 =&gt; postcss-loader;</span>                <span class="hljs-comment">// 2 =&gt; postcss-loader, less-loader</span>                <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">2</span>              &#125;            &#125;,            <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,            <span class="hljs-string">&#x27;less-loader&#x27;</span>          ]        &#125;,        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：</span><span class="hljs-comment">         * 1.asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现</span><span class="hljs-comment">         * 2.asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现</span><span class="hljs-comment">         * 3.asset/source 导出资源的源代码。之前通过使用 raw-loader 实现</span><span class="hljs-comment">         * 4.asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源</span><span class="hljs-comment">  体积限制实现</span><span class="hljs-comment">         */</span>        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpeg|svg|gif|jpg)$/</span>,          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset&#x27;</span>,          <span class="hljs-attr">generator</span>: &#123;            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;img/[name].[hash:6].[ext]&#x27;</span>          &#125;,          <span class="hljs-attr">parser</span>: &#123;            <span class="hljs-attr">dataUrlCondition</span>: &#123;              <span class="hljs-attr">maxSize</span>: <span class="hljs-number">100</span> * <span class="hljs-number">1024</span>            &#125;          &#125;        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(woff|woff2|eot|ttf|otf)$/i</span>,          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset/resource&#x27;</span>,          <span class="hljs-attr">generator</span>: &#123;            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;font/[name].[hash:6].[ext]&#x27;</span>          &#125;        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(csv|tsv)$/</span>,          <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;csv-loader&#x27;</span>]        &#125;,        &#123;          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.xml$/</span>,          <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;xml-loader&#x27;</span>]        &#125;      ]    &#125;,    <span class="hljs-attr">resolve</span>: &#123;      <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.wasm&#x27;</span>, <span class="hljs-string">&#x27;.mjs&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>, <span class="hljs-string">&#x27;.jsx&#x27;</span>, <span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.vue&#x27;</span>],      <span class="hljs-attr">alias</span>: &#123;        <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">resolveApp</span>(<span class="hljs-string">&#x27;./src&#x27;</span>)      &#125;    &#125;,    <span class="hljs-attr">plugins</span>: [      <span class="hljs-keyword">new</span> <span class="hljs-title class_">ESLintPlugin</span>(),      <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;developement&#x27;</span>,        <span class="hljs-comment">// html模板</span>        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/asset/index.html&#x27;</span>      &#125;),      <span class="hljs-comment">// 定义全局常量</span>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefinePlugin</span>(&#123;        <span class="hljs-attr">BASE_URL</span>: <span class="hljs-string">&#x27;&quot;./&quot;&#x27;</span>      &#125;),      <span class="hljs-comment">// 复制文件到dist文件夹</span>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyWebpackPlugin</span>(&#123;        <span class="hljs-attr">patterns</span>: [          &#123;            <span class="hljs-attr">from</span>: <span class="hljs-string">&#x27;src/asset&#x27;</span>,            <span class="hljs-attr">globOptions</span>: &#123;              <span class="hljs-attr">ignore</span>: [<span class="hljs-string">&#x27;**/index.html&#x27;</span>, <span class="hljs-string">&#x27;**/.DS_Store&#x27;</span>]            &#125;          &#125;        ]      &#125;)    ]  &#125;;&#125;;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env, args</span>) =&gt;</span> &#123;  <span class="hljs-keyword">switch</span> (args.<span class="hljs-property">mode</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;development&#x27;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">commonConfig</span>(env, args), developmentConfig);    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;production&#x27;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">commonConfig</span>(env, args), productionConfig);    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;No matching configuration was fou)nd!&#x27;</span>);  &#125;&#125;;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//webpack.dev.js</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">HotModuleReplacementPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">entry</span>: [<span class="hljs-string">&#x27;webpack-hot-middleware/client?noInfo=false&amp;reload=true&#x27;</span>],  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,  <span class="hljs-comment">// 在开发环境中使用</span>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,  <span class="hljs-comment">// --watch 需要手动刷新页面不方便</span>  <span class="hljs-comment">// 开启本地服务器</span>  <span class="hljs-comment">// 官方其实有提到，建议 devServer.publicPath 与 output.publicPath相同</span>  <span class="hljs-attr">devServer</span>: &#123;    <span class="hljs-attr">static</span>: <span class="hljs-string">&#x27;./dist&#x27;</span>,    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  hot: &#x27;only&#x27;：表示热模块替换，编译失败后不会刷新整个页面</span><span class="hljs-comment">     */</span>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//开启gzip压缩</span>    <span class="hljs-attr">port</span>: <span class="hljs-string">&#x27;auto&#x27;</span>, <span class="hljs-comment">//修改本地服务器端口号, auto由服务器自动分配一个端口号</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * historyApiFallback是开发中一个非常常见的属性，它主要的作用是解决SPA页面在路由跳转之后，进行页面刷新</span><span class="hljs-comment">时，返回404的错误</span><span class="hljs-comment">    如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容</span><span class="hljs-comment">     */</span>    <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">//  设置主机地址</span>    <span class="hljs-comment">// host: &#x27;0.0.0.0&#x27;,</span>    <span class="hljs-comment">// 是否自动打开浏览器</span>    <span class="hljs-comment">// open: true,</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置开发代理</span><span class="hljs-comment">     */</span>    <span class="hljs-attr">proxy</span>: &#123;      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000/api&#x27;</span>,        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>      &#125;    &#125;  &#125;,  <span class="hljs-attr">plugins</span>: [    <span class="hljs-comment">// 使用webpack-hot-middleware替代webpack-dev-middleware开启热更新，因为webpack-dev-middleware不能够热更新</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HotModuleReplacementPlugin</span>()  ]&#125;;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//webpack.prod.js</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">CssMinimizerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;css-minimizer-webpack-plugin&#x27;</span>);<span class="hljs-comment">// const TerserPlugin = require(&#x27;terser-webpack-plugin&#x27;);</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;source-map&#x27;</span>,  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 生产环境中使用CDN，不需要下载包，排除这些库</span><span class="hljs-comment">   */</span>  <span class="hljs-attr">externals</span>: &#123;    <span class="hljs-comment">// window._</span>    <span class="hljs-attr">lodash</span>: <span class="hljs-string">&#x27;_&#x27;</span>,    <span class="hljs-comment">// window.dayjs</span>    <span class="hljs-attr">dayjs</span>: <span class="hljs-string">&#x27;dayjs&#x27;</span>  &#125;,  <span class="hljs-comment">// optimization: &#123;</span>  <span class="hljs-comment">//   //  生产环境中有tree shaking</span>  <span class="hljs-comment">//   minimize: false,</span>  <span class="hljs-comment">//   minimizer: [</span>  <span class="hljs-comment">//     // 对js代码进行压缩相关的操作，开发环境不需要压缩，减少打包时间</span>  <span class="hljs-comment">//     new TerserPlugin(&#123;</span>  <span class="hljs-comment">//       parallel: true,</span>  <span class="hljs-comment">//       extractComments: false,</span>  <span class="hljs-comment">//       terserOptions: &#123;</span>  <span class="hljs-comment">//         compress: &#123;</span>  <span class="hljs-comment">//           arguments: false,</span>  <span class="hljs-comment">//           dead_code: true</span>  <span class="hljs-comment">//         &#125;,</span>  <span class="hljs-comment">//         mangle: true,</span>  <span class="hljs-comment">//         toplevel: true,</span>  <span class="hljs-comment">//         keep_classnames: true,</span>  <span class="hljs-comment">//         keep_fnames: true</span>  <span class="hljs-comment">//       &#125;</span>  <span class="hljs-comment">//     &#125;)</span>  <span class="hljs-comment">//   ]</span>  <span class="hljs-comment">// &#125;,</span>  <span class="hljs-attr">plugins</span>: [    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 该插件将 CSS 提取到单独的文件中。它为每个包含 CSS 的 JS 文件创建一个 CSS 文件。它支持 CSS 和 SourceMaps 的按需加载。它建立在新的 webpack v5 功能之上，需要 webpack 5 才能工作。</span><span class="hljs-comment">     * 异步加载</span><span class="hljs-comment">无重复编译（性能）</span><span class="hljs-comment">更容易使用</span><span class="hljs-comment">特定于 CSS</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;css/[name].[contenthash:8].css&#x27;</span>,      <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;css/[name].[contenthash:8].css&#x27;</span>    &#125;),    <span class="hljs-comment">// 对css进行压缩 这样写可以只在production中使用</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>()  ]&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Hash、ContentHash、ChunkHash</span><span class="hljs-comment"> */</span><span class="hljs-comment">//  在我们给打包的文件进行命名的时候，会使用placeholder，placeholder中有几个属性比较相似：</span><span class="hljs-comment">// p hash、chunkhash、contenthash</span><span class="hljs-comment">// p hash本身是通过MD4的散列函数处理后，生成一个128位的hash值（32个十六进制）；</span><span class="hljs-comment">// n hash值的生成和整个项目有关系：</span><span class="hljs-comment">// p 比如我们现在有两个入口index.js和main.js；</span><span class="hljs-comment">// p 它们分别会输出到不同的bundle文件中，并且在文件名称中我们有使用hash；</span><span class="hljs-comment">// p 这个时候，如果修改了index.js文件中的内容，那么hash会发生变化；</span><span class="hljs-comment">// p 那就意味着两个文件的名称都会发生变化；</span><span class="hljs-comment">// n chunkhash可以有效的解决上面的问题，它会根据不同的入口进行借来解析来生成hash值：</span><span class="hljs-comment">// p 比如我们修改了index.js，那么main.js的chunkhash是不会发生改变的；</span><span class="hljs-comment">// n contenthash表示生成的文件hash名称，只和内容有关系：</span><span class="hljs-comment">// p 比如我们的index.js，引入了一个style.css，style.css有被抽取到一个独立的css文件中；</span><span class="hljs-comment">// p 这个css文件在命名时，如果我们使用的是chunkhash；</span><span class="hljs-comment">// p 那么当index.js文件的内容发生变化时，css文件的命名也会发生变化；</span><span class="hljs-comment">// p 这个时候我们可以使用contenthash</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//server.js</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-keyword">const</span> webpackDevMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-dev-middleware&#x27;</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./config/webpack.common&#x27;</span>)(&#123;&#125;, &#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span> &#125;);<span class="hljs-keyword">const</span> compiler = <span class="hljs-title function_">webpack</span>(config);<span class="hljs-comment">// Tell express to use the webpack-dev-middleware and use the webpack.config.js</span><span class="hljs-comment">// configuration file as a base.</span>app.<span class="hljs-title function_">use</span>(  <span class="hljs-title function_">webpackDevMiddleware</span>(compiler, &#123;    <span class="hljs-attr">publicPath</span>: config.<span class="hljs-property">output</span>.<span class="hljs-property">publicPath</span>  &#125;));<span class="hljs-comment">// webpack-hot-middleware可以开启热更新</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-hot-middleware&#x27;</span>)(compiler));<span class="hljs-comment">// Serve the files on port 3000.</span>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">4000</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Example app listening on port 4000!\n&#x27;</span>);&#125;);</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">//package,son</span><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config ./config/webpack.common.js  --mode production --env production&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve --open  --config ./config/webpack.common.js  --mode development --env development&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config ./config/webpack.common.js --watch  --mode development --env development&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;serve&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node server.js&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;type-check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tsc --noEmit&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;type-check-watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tsc --noEmit --watch&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;prettier&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;prettier --write .&quot;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>常用构建工具</category>
      
      <category>webpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用正则表达式</title>
    <link href="/2022/09/08/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/09/08/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建正则</span>   <span class="hljs-comment">// 1&gt; 匹配的规则pattern</span>   <span class="hljs-comment">// 2&gt; 匹配的修饰符flags</span>   <span class="hljs-keyword">const</span> re1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;ig&quot;</span>)   <span class="hljs-keyword">const</span> re2 = <span class="hljs-regexp">/abc/ig</span> <span class="hljs-comment">// 我是注释</span></code></pre></div><h4 id="正则表达式的使用方法"><a href="#正则表达式的使用方法" class="headerlink" title="正则表达式的使用方法"></a>正则表达式的使用方法</h4><p>JavaScript中的正则表达式被用于 RegExp 的 exec 和 test 方法</p><p>也包括 String 的 match、matchAll、replace、search 和 split 方法</p><p>exec : 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;fdabc123 faBC323 dfABC222 A2324aaBc&quot;</span>;<span class="hljs-keyword">const</span> re1 = <span class="hljs-regexp">/abc/gi</span>;<span class="hljs-comment">// console.log(re1.test(message));</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">exec</span>(message));<span class="hljs-comment">/**</span><span class="hljs-comment"> * [</span><span class="hljs-comment">  &#x27;aBC&#x27;,</span><span class="hljs-comment">  index: 10,</span><span class="hljs-comment">  input: &#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;,</span><span class="hljs-comment">  groups: undefined</span><span class="hljs-comment">]</span><span class="hljs-comment"> */</span></code></pre></div><p>test:一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;fdabc123 faBC323 dfABC222 A2324aaBc&quot;</span>;<span class="hljs-keyword">const</span> re1 = <span class="hljs-regexp">/abc/gi</span>; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(re1.<span class="hljs-title function_">test</span>(message));</code></pre></div><p>match:一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// match方法</span><span class="hljs-keyword">const</span> res2 = message.<span class="hljs-title function_">match</span>(re1);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2);<span class="hljs-comment">//[ &#x27;abc&#x27;, &#x27;aBC&#x27;, &#x27;ABC&#x27;, &#x27;aBc&#x27; ]</span></code></pre></div><p>matchAll :一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// matchAll</span><span class="hljs-keyword">const</span> res = message.<span class="hljs-title function_">matchAll</span>(re1);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> iterator <span class="hljs-keyword">of</span> res) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator);&#125;[  <span class="hljs-string">&#x27;abc&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;</span>,  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>][  <span class="hljs-string">&#x27;aBC&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">10</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;</span>,  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>][  <span class="hljs-string">&#x27;ABC&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">19</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;</span>,  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>][  <span class="hljs-string">&#x27;aBc&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">32</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;fdabc123 faBC323 dfABC222 A2324aaBc&#x27;</span>,  <span class="hljs-attr">groups</span>: <span class="hljs-literal">undefined</span>]</code></pre></div><p>search :一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。</p><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> result5 = message.<span class="hljs-keyword">search</span>(re1)console.<span class="hljs-built_in">log</span>(result5)</code></pre></div><p>replace:一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串</p><p>split:一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中 的 String 方法</p><h4 id="修饰符flag的使用"><a href="#修饰符flag的使用" class="headerlink" title="修饰符flag的使用"></a>修饰符flag的使用</h4><p>常见的修饰符</p><p>g:全局匹配</p><p>i:不区分大小写</p><p>m:多行匹配</p><h4 id="规则-–-字符类"><a href="#规则-–-字符类" class="headerlink" title="规则 – 字符类"></a>规则 – 字符类</h4><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\d</span>  平匹配数字<span class="hljs-number">0</span>-<span class="hljs-number">9</span><span class="hljs-string">\s</span>  空格符号，包括空格，制表符<span class="hljs-string">\t</span> , 换行符<span class="hljs-string">\n,和其他少数稀有字符，例如\v,\f,\r</span><span class="hljs-string">\w</span>  表示单字字符  字母、数字、下划线</code></pre></div><p>反向类</p><p>\D 表示非数字的其他字符包括数字</p><p>\W 表示非单字字符</p><p>\S 非空格字符</p><h4 id="规则-–-锚点"><a href="#规则-–-锚点" class="headerlink" title="规则 – 锚点"></a>规则 – 锚点</h4><p>符号 ^ 和符号 $ 在正则表达式中具有特殊的意义，它们被称为“锚点”</p><p>符号 ^ 匹配文本开头；</p><p>符号 $ 匹配文本末尾；</p><p>词边界（Word boundary）</p><p>​    词边界 \b 是一种检查，就像 ^ 和 $ 一样，它会检查字符串中的位置是否是词边界</p><p>​    词边界测试 \b 检查位置的一侧是否匹配 \w，而另一侧则不匹配 “\w”</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message = <span class="hljs-string">&quot;My name! is WHY.&quot;</span>;<span class="hljs-comment">// 需求: name, name必须是一个单独的词</span><span class="hljs-comment">// 词边界</span><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\bname\b/i</span>.<span class="hljs-title function_">test</span>(message)) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;有name, name有边界&quot;</span>);&#125;<span class="hljs-comment">// 词边界的应用</span><span class="hljs-keyword">const</span> infos = <span class="hljs-string">&quot;now time is 11:56, 12:00 eat food, number is 123:456&quot;</span>;<span class="hljs-keyword">const</span> timeRe = <span class="hljs-regexp">/\b\d\d:\d\d\b/gi</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infos.<span class="hljs-title function_">match</span>(timeRe));<span class="hljs-comment">/**</span><span class="hljs-comment"> * 有name, name有边界</span><span class="hljs-comment">[ &#x27;11:56&#x27;, &#x27;12:00&#x27; ]</span><span class="hljs-comment"> */</span></code></pre></div><h4 id="规则-–-转义字符串"><a href="#规则-–-转义字符串" class="headerlink" title="规则 – 转义字符串"></a>规则 – 转义字符串</h4><p>转义字符要做常规字符来使用，需要使用对其进行转义，只要在它前面加个反斜杠</p><p>常见的需要转义的字符：</p><div class="code-wrapper"><pre><code class="hljs 1c">[] \  ^ $ . <span class="hljs-string">| ? * + ()</span></code></pre></div><h6 id="斜杠符号-‘-’-并不是一个特殊符号，但是在字面量正则表达式中也需要转义"><a href="#斜杠符号-‘-’-并不是一个特殊符号，但是在字面量正则表达式中也需要转义" class="headerlink" title="斜杠符号 ‘/’ 并不是一个特殊符号，但是在字面量正则表达式中也需要转义"></a>斜杠符号 ‘/’ 并不是一个特殊符号，但是在字面量正则表达式中也需要转义</h6><h4 id="集合（Sets）和范围（Ranges）"><a href="#集合（Sets）和范围（Ranges）" class="headerlink" title="集合（Sets）和范围（Ranges）"></a>集合（Sets）和范围（Ranges）</h4><h6 id="有时候我们只要选择多个匹配字符的其中之一就可以"><a href="#有时候我们只要选择多个匹配字符的其中之一就可以" class="headerlink" title="有时候我们只要选择多个匹配字符的其中之一就可以"></a>有时候我们只要选择多个匹配字符的其中之一就可以</h6><div class="code-wrapper"><pre><code class="hljs"> 有时候我们只要选择多个匹配字符的其中之一就可以</code></pre></div><p>集合  []  表示匹配中括号里面的任意一个字符</p><p>范围  </p><p>​    [0-9] 方括号也可以包含字符范围，例如匹配从a到z范围的字母[a-z],[0-5],</p><p>​    \d  ===[0-9]</p><p>​    \w ===[a-zA-Z0-9]</p><p>​    .    点表示匹配除换行符之外的所有字符</p><h5 id="排除范围：除了普通的范围匹配，还有类似-…-的“排除”范围匹配"><a href="#排除范围：除了普通的范围匹配，还有类似-…-的“排除”范围匹配" class="headerlink" title="排除范围：除了普通的范围匹配，还有类似 [^…] 的“排除”范围匹配"></a>排除范围：除了普通的范围匹配，还有类似 [^…] 的“排除”范围匹配</h5><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>数量  {n} 确切的数  ,{n,m} 表示多少范围匹配</p><p>缩写</p><p>​    +  表示一个或者多个 ==={1，}</p><p>​    ？表示零个或者一个 ==={0，1}</p><p>​    *  表示零个或者多个 ==={0，}</p><h4 id="贪婪（-Greedy）和惰性（-lazy）模式"><a href="#贪婪（-Greedy）和惰性（-lazy）模式" class="headerlink" title="贪婪（ Greedy）和惰性（ lazy）模式"></a>贪婪（ Greedy）和惰性（ lazy）模式</h4><p>默认是贪婪模式，</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.贪婪模式/惰性模式</span><span class="hljs-keyword">const</span> message =  <span class="hljs-string">&quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;</span>;<span class="hljs-comment">// 默认.+采用贪婪模式</span><span class="hljs-keyword">const</span> nameRe = <span class="hljs-regexp">/《.+》/gi</span>;<span class="hljs-keyword">const</span> result1 = message.<span class="hljs-title function_">match</span>(nameRe);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);<span class="hljs-comment">//[ &#x27;《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27; ]</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message =  <span class="hljs-string">&quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;</span>;<span class="hljs-comment">// // 默认.+采用贪婪模式</span><span class="hljs-comment">// const nameRe = /《.+》/gi;</span><span class="hljs-comment">// const result1 = message.match(nameRe);</span><span class="hljs-comment">// console.log(result1);</span><span class="hljs-comment">// 使用惰性模式</span><span class="hljs-keyword">const</span> nameRe = <span class="hljs-regexp">/《.+?》/gi</span>;<span class="hljs-keyword">const</span> result1 = message.<span class="hljs-title function_">match</span>(nameRe);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1);<span class="hljs-comment">//[ &#x27;《黄金时代》&#x27;, &#x27;《沉默的大多数》&#x27;, &#x27;《一只特立独行的猪》&#x27; ]</span></code></pre></div><p>默认情况下的匹配规则是查找到匹配的内容后，会继续向后查找，一直找到最后一个匹配的内容 , 这种匹配的方式，我们称之为贪婪模式（Greedy）</p><p>懒惰模式中的量词与贪婪模式中的是相反的。 </p><p>只要获取到对应的内容后，就不再继续向后匹配； </p><p>我们可以在量词后面再加一个问号 ‘?’ 来启用它； </p><p> 所以匹配模式变为 *? 或 +?，甚至将 ‘?’ 变为 ?</p><h4 id="捕获组（capturing-group）"><a href="#捕获组（capturing-group）" class="headerlink" title="捕获组（capturing group）"></a>捕获组（capturing group）</h4><p>模式的一部分可以用括号括起来 (…)，这称为“捕获组（capturing group）”</p><p>模式的一部分可以用括号括起来 (…)，这称为“捕获组（capturing group）”。</p><p> ◼ 这有两个作用： </p><p>​    它允许将匹配的一部分作为结果数组中的单独项；</p><p>​     它将括号视为一个整体； </p><p>​            方法 str.match(regexp)，如果 regexp 没有 g 标志，将查找第一个匹配并将它作为一个数组返回：</p><p>​                  在索引 0 处：完全匹配。</p><p>​                  在索引 1 处：第一个括号的内容。 </p><p>​                 在索引 2 处：第二个括号的内容。 </p><p>​                     …等等</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.捕获组</span><span class="hljs-keyword">const</span> message =  <span class="hljs-string">&quot;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&quot;</span>;<span class="hljs-comment">// 使用惰性模式</span><span class="hljs-comment">//这是通过在开始括号之后立即放置 ?&lt;name&gt; 来完成的</span><span class="hljs-keyword">const</span> nameRe = <span class="hljs-regexp">/(?:《)(?&lt;why&gt;.+?)(?:》)/gi</span>;<span class="hljs-comment">//可以给捕获组起名字</span><span class="hljs-keyword">const</span> iterator = message.<span class="hljs-title function_">matchAll</span>(nameRe);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> iterator) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);&#125;<span class="hljs-comment">// 2.将捕获组作为整体</span><span class="hljs-keyword">const</span> info = <span class="hljs-string">&quot;dfabcabcfabcdfdabcabcabcljll;jk;j&quot;</span>;<span class="hljs-keyword">const</span> abcRe = <span class="hljs-regexp">/(abc)&#123;2,&#125;/gi</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-title function_">match</span>(abcRe));[  <span class="hljs-string">&#x27;《黄金时代》&#x27;</span>,  <span class="hljs-string">&#x27;黄金时代&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">10</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;</span>,  <span class="hljs-attr">groups</span>: [<span class="hljs-title class_">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-attr">why</span>: <span class="hljs-string">&#x27;黄金时代&#x27;</span> &#125;][  <span class="hljs-string">&#x27;《沉默的大多数》&#x27;</span>,  <span class="hljs-string">&#x27;沉默的大多数&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">17</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;</span>,  <span class="hljs-attr">groups</span>: [<span class="hljs-title class_">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-attr">why</span>: <span class="hljs-string">&#x27;沉默的大多数&#x27;</span> &#125;][  <span class="hljs-string">&#x27;《一只特立独行的猪》&#x27;</span>,  <span class="hljs-string">&#x27;一只特立独行的猪&#x27;</span>,  <span class="hljs-attr">index</span>: <span class="hljs-number">26</span>,  <span class="hljs-attr">input</span>: <span class="hljs-string">&#x27;我最喜欢的两本书: 《黄金时代》和《沉默的大多数》、《一只特立独行的猪》&#x27;</span>,  <span class="hljs-attr">groups</span>: [<span class="hljs-title class_">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-attr">why</span>: <span class="hljs-string">&#x27;一只特立独行的猪&#x27;</span> &#125;][ <span class="hljs-string">&#x27;abcabc&#x27;</span>, <span class="hljs-string">&#x27;abcabcabc&#x27;</span> ]</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.将捕获组作为整体</span><span class="hljs-keyword">const</span> info = <span class="hljs-string">&quot;dfabcabcfabcdfdabcabcabcljcbacballnbanba;jk;j&quot;</span>;<span class="hljs-keyword">const</span> abcRe = <span class="hljs-regexp">/(abc|cba|nba)&#123;2,&#125;/gi</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-title function_">match</span>(abcRe));<span class="hljs-comment">//[ &#x27;abcabc&#x27;, &#x27;abcabcabc&#x27;, &#x27;cbacba&#x27;, &#x27;nbanba&#x27; ]</span></code></pre></div><p>非捕获组：</p><p>  有时我们需要括号才能正确应用量词，但我们不希望它们的内容出现在结果中。</p><p> 可以通过在开头添加 ?: 来排除组。</p>]]></content>
    
    
    <categories>
      
      <category>正则表达式</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的git操作</title>
    <link href="/2022/09/08/%E5%B8%B8%E7%94%A8%E7%9A%84git%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/09/08/%E5%B8%B8%E7%94%A8%E7%9A%84git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="git基本使用"><a href="#git基本使用" class="headerlink" title="##git基本使用"></a>##git基本使用</h4><h5 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h5><div class="code-wrapper"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span></code></pre></div><h5 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h5><div class="code-wrapper"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/coderwhy/</span>hy-react-web-music.git</code></pre></div><h4 id="检测文件的状态"><a href="#检测文件的状态" class="headerlink" title="检测文件的状态"></a>检测文件的状态</h4><div class="code-wrapper"><pre><code class="hljs lua">git <span class="hljs-built_in">status</span>git <span class="hljs-built_in">status</span> -sgit <span class="hljs-built_in">status</span> <span class="hljs-comment">--short</span></code></pre></div><h4 id="将所有文件添加到暂存区"><a href="#将所有文件添加到暂存区" class="headerlink" title="将所有文件添加到暂存区"></a>将所有文件添加到暂存区</h4><div class="code-wrapper"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .</code></pre></div><h4 id="将暂存区的文件提交"><a href="#将暂存区的文件提交" class="headerlink" title="将暂存区的文件提交"></a>将暂存区的文件提交</h4><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;提交信息&quot;</span></code></pre></div><h4 id="add-commit-进行合并操作"><a href="#add-commit-进行合并操作" class="headerlink" title="add commit 进行合并操作"></a>add commit 进行合并操作</h4><div class="code-wrapper"><pre><code class="hljs livecodeserver">git commit -<span class="hljs-keyword">a</span> -m <span class="hljs-string">&quot;修改文件&quot;</span></code></pre></div><h4 id="合并commit"><a href="#合并commit" class="headerlink" title="合并commit"></a>合并commit</h4><div class="code-wrapper"><pre><code class="hljs awk">git commit --amend  <span class="hljs-regexp">//</span>将两个commit合并成一个提交</code></pre></div><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p><div class="code-wrapper"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m <span class="hljs-string">&#x27;initial commit&#x27;</span>git <span class="hljs-keyword">add</span> forgotten_filegit <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span></code></pre></div><p>就是将再次commit的内容合并到之前的commit</p><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><div class="code-wrapper"><pre><code class="hljs jboss-cli">git loggit log <span class="hljs-params">--pretty=oneline</span>git log <span class="hljs-params">--oneline</span> <span class="hljs-params">--decorate</span> <span class="hljs-params">--graph</span> <span class="hljs-params">--all</span>   <span class="hljs-string">//</span>它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况</code></pre></div><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><div class="code-wrapper"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span>  <span class="hljs-comment">--hard HEAD^</span>git <span class="hljs-keyword">reset</span>  <span class="hljs-comment">--hard HEAD~1000</span>git <span class="hljs-keyword">reset</span>  <span class="hljs-comment">--hard 2d44982</span></code></pre></div><h4 id="管理远程仓库"><a href="#管理远程仓库" class="headerlink" title="管理远程仓库"></a>管理远程仓库</h4><div class="code-wrapper"><pre><code class="hljs <">git remote //查看远程仓库的命名git remote -v  //查看远程仓库地址git remote add &lt;shortname&gt; &lt;url&gt;  //添加远程仓库，让本地仓库和远程仓库建立连接git remote rename gitlab glab  //重命名远程仓库git remote remove gitlab  //移除远程仓库git remote show &lt;remote&gt;  //获取远程仓库信息例如git remote show origingit ls-remote &lt;remote&gt;  //显式地获得远程引用的完整列表</code></pre></div><h4 id="将代码push到远程仓库：将本地仓库的代码推送到远程仓库中"><a href="#将代码push到远程仓库：将本地仓库的代码推送到远程仓库中" class="headerlink" title="将代码push到远程仓库：将本地仓库的代码推送到远程仓库中"></a>将代码push到远程仓库：将本地仓库的代码推送到远程仓库中</h4><div class="code-wrapper"><pre><code class="hljs maxima">默认情况下是将当前分支（比如master）<span class="hljs-built_in">push</span>到<span class="hljs-built_in">origin</span>远程仓库的；git <span class="hljs-built_in">push</span>git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> mastergit <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> serverfix:awesomebranch  //远程分支和本地分支不同名时</code></pre></div><h4 id="从远程仓库fetch代码：从远程仓库获取最新的代码"><a href="#从远程仓库fetch代码：从远程仓库获取最新的代码" class="headerlink" title="从远程仓库fetch代码：从远程仓库获取最新的代码"></a>从远程仓库fetch代码：从远程仓库获取最新的代码</h4><div class="code-wrapper"><pre><code class="hljs sql">默认情况下是从origin中获取代码；git <span class="hljs-keyword">fetch</span>git <span class="hljs-keyword">fetch</span> origin获取到代码后默认并没有合并到本地仓库，我们需要通过<span class="hljs-keyword">merge</span>来合并；git <span class="hljs-keyword">merge</span></code></pre></div><h4 id="从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作"><a href="#从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作" class="headerlink" title="从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作"></a>从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作</h4><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">git</span> <span class="hljs-variable">pull</span> ===<span class="hljs-variable">git</span> <span class="hljs-variable">fetch</span> + <span class="hljs-variable">git</span> <span class="hljs-function"><span class="hljs-title">merge</span>(<span class="hljs-variable">rebase</span>)</span></code></pre></div><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><div class="code-wrapper"><pre><code class="hljs pgsql">$ git merge iss53Auto-merging <span class="hljs-keyword">index</span>.html<span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">index</span>.htmlAutomatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.</code></pre></div><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并 （unmerged）状态的文件：</p><div class="code-wrapper"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<span class="hljs-section">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><span class="hljs-section">=======</span>&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</code></pre></div><p>这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的 下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。 </p><p>冲突解决后，可以使用git status 来查看是否所有的冲突都解决了，然后再使用git commit进行提交</p><h4 id="Git标签（tag）-创建tag"><a href="#Git标签（tag）-创建tag" class="headerlink" title="Git标签（tag） - 创建tag"></a>Git标签（tag） - 创建tag</h4><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated），轻量标签很像一个不会改变的分支——它只是某个特定提交的引用，而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件 地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签</p><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span>  //轻量标签git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;附注标签&quot;</span>git show v1.<span class="hljs-number">4</span>  //可以看到标签信息和与之对应的提交信息 输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息</code></pre></div><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a><strong>列出标签</strong></h4><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">（可带上可选的 -l</span> 选项 --list）git <span class="hljs-keyword">tag</span> <span class="hljs-title">-l</span> <span class="hljs-string">&quot;v1.8.5*&quot;</span>  //列出v1.<span class="hljs-number">8.5</span>开头的标签</code></pre></div><h4 id="push-tag"><a href="#push-tag" class="headerlink" title="push tag"></a>push tag</h4><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin <span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin --tags  <span class="hljs-comment">//推送所有标签</span>使用 git <span class="hljs-keyword">push</span> &lt;remote&gt; --tags 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。</code></pre></div><h4 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h4><div class="code-wrapper"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v1.<span class="hljs-number">1</span></code></pre></div><h4 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h4><div class="code-wrapper"><pre><code class="hljs awk">git push origin  --<span class="hljs-keyword">delete</span> v1.<span class="hljs-number">1</span>  <span class="hljs-regexp">//</span>第一种方式 git push &lt;remote&gt; :refs<span class="hljs-regexp">/tags/</span>&lt;tagname&gt;  <span class="hljs-regexp">//</span>第二种方式</code></pre></div><h4 id="切换到目标tag版本"><a href="#切换到目标tag版本" class="headerlink" title="切换到目标tag版本"></a>切换到目标tag版本</h4><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout <span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span>   <span class="hljs-comment">//虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用</span></code></pre></div><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p><div class="code-wrapper"><pre><code class="hljs armasm">$ git checkout -<span class="hljs-keyword">b</span> version2 <span class="hljs-built_in">v2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span></code></pre></div><p>如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍 微有些不同，这时就要当心了。</p><h4 id="Git创建分支"><a href="#Git创建分支" class="headerlink" title="Git创建分支"></a>Git创建分支</h4><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch testing</span></code></pre></div><h4 id="Git切换分支"><a href="#Git切换分支" class="headerlink" title="Git切换分支"></a>Git切换分支</h4><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git checkout testing</span></code></pre></div><h4 id="创建分支同时切换"><a href="#创建分支同时切换" class="headerlink" title="创建分支同时切换"></a>创建分支同时切换</h4><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b</span> testing</code></pre></div><h4 id="分支开发与合并"><a href="#分支开发与合并" class="headerlink" title="分支开发与合并"></a>分支开发与合并</h4><div class="code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-keyword">master</span><span class="hljs-title">git</span> merge hotfix</code></pre></div><h4 id="查看和删除分支"><a href="#查看和删除分支" class="headerlink" title="查看和删除分支"></a>查看和删除分支</h4><div class="code-wrapper"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span> 查看当前所有分支  带*就是head指针指向的分支，一般是当前分支git <span class="hljs-keyword">brabch </span>-v  查看最后一次提交git <span class="hljs-keyword">branch </span>--merged 查看所有合并到当前分支的分支git <span class="hljs-keyword">branch </span>--no-merged 查看所有没有合并到当前分支的分支  没有合并的分支不允许删除如果需要强制性删除 git <span class="hljs-keyword">branch </span>-D hotfixgit <span class="hljs-keyword">branch </span>--no-merged master  还没有合并到master的分支git <span class="hljs-keyword">branch </span>-d hotfix  删除hotfix分支</code></pre></div><h4 id="远程分支的管理"><a href="#远程分支的管理" class="headerlink" title="远程分支的管理"></a>远程分支的管理</h4><div class="code-wrapper"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> &lt;remote&gt; &lt;branch&gt;  推送远程分支git checkout -b serverfix <span class="hljs-built_in">origin</span>/serverfix  //创建分支并跟踪远程分支 下面是他的简写git checkout --<span class="hljs-built_in">track</span> &lt;remote&gt;/&lt;branch&gt; 跟踪远程分支git checkout -b <span class="hljs-built_in">sf</span> <span class="hljs-built_in">origin</span>/serverfix //创建和远程分支不一样的名字git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> &lt;branch&gt; 删除远程分支</code></pre></div><h4 id="Git-rebase用法"><a href="#Git-rebase用法" class="headerlink" title="Git rebase用法"></a>Git rebase用法</h4><div class="code-wrapper"><pre><code class="hljs crmsh">git checkout experimentgit rebase <span class="hljs-keyword">master</span><span class="hljs-title">git</span> checkout <span class="hljs-keyword">master</span><span class="hljs-title">git</span> merge experiment</code></pre></div><p>它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用</p><p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行 应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。</p><p>假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 –onto 选项， 选中在 client 分支里但不在server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：</p><div class="code-wrapper"><pre><code class="hljs crmsh">git rebase --onto <span class="hljs-keyword">master</span> <span class="hljs-title">server</span> client</code></pre></div><p>以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”</p><p>接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到server 分支，再对其执行变基命令的多个步骤</p><div class="code-wrapper"><pre><code class="hljs crmsh">git rebase <span class="hljs-keyword">master</span> <span class="hljs-title">server</span> 相当于git checkout servergit rebase <span class="hljs-literal">master</span></code></pre></div><h5 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h5><p>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基</p><h5 id="用变基解决变基"><a href="#用变基解决变基" class="headerlink" title="用变基解决变基"></a>用变基解决变基</h5><p> 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patchid”。 </p><p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的 </p><p>修改，并把它们应用到新分支上。</p><p>举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情 </p><p>境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会： </p><p>• 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7） </p><p>• 检查其中哪些提交不是合并操作的结果（C2，C3，C4） </p><p>• 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’） </p><p>• 把查到的这些提交应用在 teamone/master 上面</p><p>从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果。在一个被变基然后强制推送的分支上再次执行变基。</p><p>在本例中另一种简单的方法是使用 <code>git pull --rebase</code> 命令而不是直接 git pull。 又或者你可以自己手动 完成这个过程，先 git fetch，再 git rebase teamone/master。 </p><p>如果你习惯使用 git pull ，同时又希望默认使用选项 –rebase，你可以执行这条语句 git config –global pull.rebase true 来更改 pull.rebase 的默认配置。</p><p>如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没 有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。 </p><p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull –rebase 命令，这样尽管不能避免伤痛，但能有所缓解。</p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><div class="code-wrapper"><pre><code class="hljs ada">对于未进行提交到暂存区域的git checkout <span class="hljs-comment">-- &lt;file&gt;</span></code></pre></div><p>请务必记得 git checkout – <file> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p><h4 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a><strong>Git</strong> 别名</h4><p>为git 命令设置别名</p><div class="code-wrapper"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.co</span> checkoutgit <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.br</span> branchgit <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.ci</span> commitgit <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span><span class="hljs-variable">.st</span> status</code></pre></div><p>这意味着，当要输入 git commit 时，只需要输入 git ci。</p><div class="code-wrapper"><pre><code class="hljs csharp">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span>.unstage <span class="hljs-string">&#x27;reset HEAD --&#x27;</span></code></pre></div><p>这会使下面的两个命令等价：</p><div class="code-wrapper"><pre><code class="hljs pgsql">git unstage fileAgit <span class="hljs-keyword">reset</span> HEAD <span class="hljs-comment">-- fileA</span></code></pre></div><p>这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：</p><div class="code-wrapper"><pre><code class="hljs csharp">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span>.last <span class="hljs-string">&#x27;log -1 HEAD&#x27;</span></code></pre></div><p>使用自定义指令来查看最后一次提交信息</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> <span class="hljs-literal">last</span></code></pre></div><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：</p><div class="code-wrapper"><pre><code class="hljs csharp">git config --<span class="hljs-keyword">global</span> <span class="hljs-keyword">alias</span>.visual <span class="hljs-string">&#x27;!gitk&#x27;</span></code></pre></div><h4 id="引用日志"><a href="#引用日志" class="headerlink" title="引用日志"></a>引用<strong>日志</strong></h4><p>当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用 所指向的历史。 </p><p>你可以使用 git reflog 来查看引用日志，引用日志只存在于本地仓库</p><div class="code-wrapper"><pre><code class="hljs angelscript">git <span class="hljs-built_in">ref</span>log</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript">$ git <span class="hljs-built_in">ref</span>log<span class="hljs-number">734713</span>b <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">0</span>&#125;: commit: fixed <span class="hljs-built_in">ref</span>s handling, added gc <span class="hljs-built_in">auto</span>, updatedd921970 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">1</span>&#125;: merge phedders/rdocs: Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span>strategy.<span class="hljs-number">1</span>c002dd <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">2</span>&#125;: commit: added some blame <span class="hljs-keyword">and</span> merge stuff<span class="hljs-number">1</span>c36188 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">3</span>&#125;: rebase -i (squash): updating HEAD<span class="hljs-number">95</span>df984 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">4</span>&#125;: commit: # This <span class="hljs-keyword">is</span> a combination of two commits.<span class="hljs-number">1</span>c36188 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">5</span>&#125;: rebase -i (squash): updating HEAD<span class="hljs-number">7e05</span>da5 <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">6</span>&#125;: rebase -i (pick): updating HEAD</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript">git show <span class="hljs-symbol">HEAD@</span>&#123;<span class="hljs-number">5</span>&#125;    <span class="hljs-comment">//如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @&#123;n&#125; 来 引用 reflog 中输出的提交记录。</span>git show <span class="hljs-symbol">master@</span>&#123;yesterday&#125;   <span class="hljs-comment">//查看你的 master 分支在昨天的时候指向了哪个提交，这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。</span></code></pre></div><h4 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先<strong>引用</strong></h4><div class="code-wrapper"><pre><code class="hljs awk">git show HEAD^   <span class="hljs-regexp">//</span> 可以查看上一次的提交  在window中不可用git show HEAD^^  <span class="hljs-regexp">//</span> win中可以使用git show <span class="hljs-string">&quot;HEAD^&quot;</span> <span class="hljs-regexp">//</span> win中要使用“”git show d921970^ <span class="hljs-regexp">//</span>某次提交的上一次提交</code></pre></div><p>另一种指明祖先提交的方法是 ~（波浪号）</p><div class="code-wrapper"><pre><code class="hljs dart">git <span class="hljs-keyword">show</span> HEAD~<span class="hljs-number">3</span>  也可以使用  git <span class="hljs-keyword">show</span> HEAD～～～</code></pre></div><h4 id="提交区间"><a href="#提交区间" class="headerlink" title="提交区间"></a>提交区<strong>间</strong></h4><p>可以用来制定那些提交需要合并到master分支</p><h5 id="双点"><a href="#双点" class="headerlink" title="双点"></a>双点</h5><p>这种语法可以选出在一个分支中而不再另外一个分支的中的提交</p><p>例如：</p><p>​    你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">git</span></span> <span class="hljs-built_in">log</span> master..experiment</code></pre></div><p>​    如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">git</span></span> <span class="hljs-built_in">log</span> experiment..master</code></pre></div><p>​    另一个常用的场景是查看你即将推送到远端的内容‘</p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> origin/master..HEAD</code></pre></div><h4 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h4><div class="code-wrapper"><pre><code class="hljs awk">git stash/git stash pushgit stash list <span class="hljs-regexp">//</span>获取暂存列表git stash apply <span class="hljs-regexp">//</span>应用最新的暂存文件git stash apply stash@&#123;<span class="hljs-number">2</span>&#125;  <span class="hljs-regexp">//</span>应用指定的暂存文件git stash pop <span class="hljs-regexp">//</span>应用暂存并且删除git stash drop <span class="hljs-regexp">//</span>删除暂存</code></pre></div><h4 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重<strong>写历史</strong></h4><h5 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h5><div class="code-wrapper"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span></code></pre></div><h5 id="合并多次提交信息"><a href="#合并多次提交信息" class="headerlink" title="合并多次提交信息"></a>合并多次提交信息</h5><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i HEAD~<span class="hljs-number">3</span></code></pre></div><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><div class="code-wrapper"><pre><code class="hljs stylus">git branch <span class="hljs-attr">--set-upstream-to</span>=origin/master  <span class="hljs-comment">//设置上游分支就可以只写 git pull了</span>git merge <span class="hljs-attr">--allow-unrelated-histories</span>  <span class="hljs-comment">//强制合并</span>git push origin head:<span class="hljs-selector-tag">main</span>  head默认指向<span class="hljs-selector-tag">main</span>如果要push master默认要这么写git push origin master:<span class="hljs-selector-tag">main</span>  如果想写git push就要这么写配置git push 指向上游路径master，就是配置好的git branch <span class="hljs-attr">--set-upstream-to</span>=origin/master调用git push 就会push到master,但是这样每个分支都是push到mastergit config push<span class="hljs-selector-class">.default</span> upstream  <span class="hljs-selector-attr">[--global]</span><span class="hljs-comment">//加上global可以全局使用，否则就是当前项目使用</span>git config push<span class="hljs-selector-class">.default</span> current  <span class="hljs-comment">//这个会先去仓库找有没有和本地相同的分支，如果没有就在远程创建一个新的和本地相同的分支</span>push<span class="hljs-selector-class">.default</span> 默认是simple 就是push相同的分支</code></pre></div><h5 id="Fast-forward-merge-is-not-possible-To-merge-this-request-first-rebase-locally"><a href="#Fast-forward-merge-is-not-possible-To-merge-this-request-first-rebase-locally" class="headerlink" title="Fast-forward merge is not possible. To merge this request, first rebase locally"></a><a href="https://stackoverflow.com/questions/53066369/fast-forward-merge-is-not-possible-to-merge-this-request-first-rebase-locally">Fast-forward merge is not possible. To merge this request, first rebase locally</a></h5><p>解决办法</p><p><code>git checkout master</code> 先切换到主分支</p><p><code>git pull origin master</code> 然后再pull分支下来</p><p><code>git checkout newBranch</code> 切换到当前分支</p><p><code>git rebase origin/master -i</code>    再rebase</p><p><code>git rebase --continue</code></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是tailwindcss</title>
    <link href="/2022/09/08/%E4%BB%80%E4%B9%88%E6%98%AFtailwindcss/"/>
    <url>/2022/09/08/%E4%BB%80%E4%B9%88%E6%98%AFtailwindcss/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
      <category>tailwindcss</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>http2了解</title>
    <link href="/2022/09/08/http2%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/09/08/http2%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fetch笔记</title>
    <link href="/2022/09/08/fetch%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/fetch%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>fetch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ajax笔记</title>
    <link href="/2022/09/08/ajax%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/ajax%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="ajax的封装"><a href="#ajax的封装" class="headerlink" title="##ajax的封装"></a>##ajax的封装</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">&#123;</span><span class="hljs-params">  url,</span><span class="hljs-params">  method = <span class="hljs-string">&quot;get&quot;</span>,</span><span class="hljs-params">  data = &#123;&#125;,</span><span class="hljs-params">  headers = &#123;&#125;,</span><span class="hljs-params">  success,</span><span class="hljs-params">  failure,</span><span class="hljs-params">&#125; = &#123;&#125;</span>) &#123;  <span class="hljs-comment">// 1.创建对象</span>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();  <span class="hljs-comment">// 2.监听数据</span>  xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span> || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;      <span class="hljs-comment">// xhr.responseXML/xhr.responseText</span>      success &amp;&amp; <span class="hljs-title function_">success</span>(xhr.<span class="hljs-property">response</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      failure &amp;&amp; <span class="hljs-title function_">failure</span>(&#123; <span class="hljs-attr">status</span>: xhr.<span class="hljs-property">status</span>, <span class="hljs-attr">message</span>: xhr.<span class="hljs-property">statusText</span> &#125;);    &#125;  &#125;;  <span class="hljs-comment">// 现在返回的数据类型一般都是json,如果设置为空字符串则会使用text作为默认值</span>  <span class="hljs-comment">// 3.设置类型</span>  xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;  <span class="hljs-comment">// xhr.responseType=&quot;xml&quot;/blob/text/arraybuffer等</span>  <span class="hljs-comment">// 4.设置过期超时事件</span>  xhr.<span class="hljs-property">timeout</span> = timeout;  <span class="hljs-comment">// 5.open方法</span>  <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&quot;GET&quot;</span>) &#123;    <span class="hljs-keyword">const</span> queryString = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> data) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(data, key)) &#123;        <span class="hljs-keyword">const</span> item = data[key];        queryString.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;item&#125;</span>`</span>);      &#125;    &#125;    url = url + <span class="hljs-string">&quot;?&quot;</span> + queryString.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);    xhr.<span class="hljs-title function_">open</span>(method, url);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// post</span>    xhr.<span class="hljs-title function_">open</span>(method, url);    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);  &#125;  <span class="hljs-comment">// 6设置headers</span>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;      xhr.<span class="hljs-title function_">setRequestHeader</span>(key, headers[key]);    &#125;);  &#125;  <span class="hljs-keyword">if</span> (method.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&quot;POST&quot;</span>) &#123;    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&quot;GET&quot;</span>) &#123;    xhr.<span class="hljs-title function_">send</span>();  &#125;  <span class="hljs-comment">// return xhr可以用于调用abort()方法进行终止请求</span>  <span class="hljs-keyword">return</span> xhr;&#125;</code></pre></div><h4 id="ajax的promise的封装"><a href="#ajax的promise的封装" class="headerlink" title="ajax的promise的封装"></a>ajax的promise的封装</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">&#123; url, method = <span class="hljs-string">&quot;get&quot;</span>, data = &#123;&#125;, headers = &#123;&#125; &#125; = &#123;&#125;</span>) &#123;  <span class="hljs-comment">// 1.创建对象</span>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 2.监听数据</span>    xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span> || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;        <span class="hljs-comment">// xhr.responseXML/xhr.responseText</span>        <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">response</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-title function_">reject</span>(&#123; <span class="hljs-attr">status</span>: xhr.<span class="hljs-property">status</span>, <span class="hljs-attr">message</span>: xhr.<span class="hljs-property">statusText</span> &#125;);      &#125;    &#125;;    <span class="hljs-comment">// 现在返回的数据类型一般都是json,如果设置为空字符串则会使用text作为默认值</span>    <span class="hljs-comment">// 3.设置类型</span>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;    <span class="hljs-comment">// xhr.responseType=&quot;xml&quot;/blob/text/arraybuffer等</span>    <span class="hljs-comment">// 4.设置过期超时事件</span>    xhr.<span class="hljs-property">timeout</span> = timeout;    <span class="hljs-comment">// 5.open方法</span>    <span class="hljs-keyword">if</span> (method.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&quot;GET&quot;</span>) &#123;      <span class="hljs-keyword">const</span> queryString = [];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> data) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(data, key)) &#123;          <span class="hljs-keyword">const</span> item = data[key];          queryString.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;item&#125;</span>`</span>);        &#125;      &#125;      url = url + <span class="hljs-string">&quot;?&quot;</span> + queryString.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);      xhr.<span class="hljs-title function_">open</span>(method, url);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// post</span>      xhr.<span class="hljs-title function_">open</span>(method, url);      xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);    &#125;    <span class="hljs-comment">// 6设置headers</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(headers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;        xhr.<span class="hljs-title function_">setRequestHeader</span>(key, headers[key]);      &#125;);    &#125;    <span class="hljs-keyword">if</span> (method.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&quot;POST&quot;</span>) &#123;      xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.<span class="hljs-property">toUpperCase</span> === <span class="hljs-string">&quot;GET&quot;</span>) &#123;      xhr.<span class="hljs-title function_">send</span>();    &#125;  &#125;);  <span class="hljs-comment">// return xhr可以用于调用abort()方法进行终止请求</span>  promise.<span class="hljs-property">xhr</span> = xhr;  <span class="hljs-keyword">return</span> promise;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>Ajax</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react-router-v6笔记</title>
    <link href="/2022/09/08/react-router-v6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/react-router-v6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs qml"><span class="hljs-number">1.</span>前端路由的原理当<span class="hljs-built_in">url</span>发生变化的时候，引起页面不刷新来修改页面的内容的两个方法<span class="hljs-number">1.</span>通过修改<span class="hljs-built_in">url</span>中的hash的变化来修改页面的内容<span class="hljs-built_in">window</span>.onhashchange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">switch</span>(location.hash)&#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;#/a&quot;</span>:div.innerHTML=<span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-comment">//url的hash也就是锚点。本质上就是修改了window.location的href</span><span class="hljs-comment">//可以通过直接赋值location.hash来改变href.但是页面不会刷新，</span><span class="hljs-comment">//但是hash会带有#</span><span class="hljs-number">2.</span>可以使用HTML5的history模式来修改<span class="hljs-built_in">url</span>,他有六种模式来改变URL的变化而不刷新页面history.replactState():替换原来的路径history.pushState():使用新的路径history.popState():路径的回退history.go():向前或者向后改变路径history.back():向后改变路径</code></pre></div><p><img src="https://img1.imgtp.com/2022/09/13/WPC9CvI7.png" alt="QQ截图20220607102052.png"></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">2.</span>react-router有两部分组成<span class="hljs-number">1.</span>react-router<span class="hljs-comment">//这是核心代码</span><span class="hljs-number">2.</span>react-router-dom<span class="hljs-comment">//这是用于浏览器的</span><span class="hljs-number">3.</span>react-router-native<span class="hljs-comment">//这个适用于原生应用</span>使用react-router需要使用npm install react-router-dom 他会自动安装react-router<span class="hljs-number">3.</span>react-router的组件使用&lt;<span class="hljs-title class_">BrowserRouter</span>&gt;是使用history模式<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;    <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;    <span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span>,      root    );<span class="hljs-comment">//这就是目前比较普遍的用法，也是官方比较推荐的用法，将他包裹在App组件</span>   <span class="hljs-number">3.1</span>&lt;<span class="hljs-title class_">HashRouter</span>&gt;是使用hash模式，官方不推荐使用   <span class="hljs-number">3.2</span>&lt;link&gt;组件是跳转的组件，它最终会被渲染成a元素   <span class="hljs-number">3.3</span>&lt;<span class="hljs-title class_">NavLink</span>&gt;是在<span class="hljs-title class_">Link</span>的基础上增加了一些样式   <span class="hljs-number">3.3</span><span class="hljs-number">.1</span> to属性是<span class="hljs-title class_">Link</span>和<span class="hljs-title class_">NavLink</span>组件中最重要的属性，用于设置跳转的路径   <span class="hljs-number">3.4</span>.<span class="hljs-property">Route</span>组件   <span class="hljs-number">3.4</span><span class="hljs-number">.1</span> <span class="hljs-title class_">Route</span>组件主要适用于路由路径的匹配   <span class="hljs-number">3.4</span><span class="hljs-number">.2</span> path属性:用于设置匹配到的路径   <span class="hljs-number">3.4</span><span class="hljs-number">.3</span> component属性：设置匹配到的路径后渲染的组件，   <span class="hljs-number">3.4</span><span class="hljs-number">.4</span>.<span class="hljs-property">exact</span>:精准匹配   上述的属性属于v5的版本   在v6版本中所有&lt;<span class="hljs-title class_">Route</span>&gt;组件将放在&lt;<span class="hljs-title class_">Routes</span>&gt;中，component改成element,</code></pre></div><p><img src="https://img1.imgtp.com/2022/09/13/TzYXcXQV.png" alt="QQ截图20220607144416.png"></p><p><img src="https://img1.imgtp.com/2022/09/13/XwuhkKsl.png" alt="QQ截图20220607215036.png"></p><p><img src="https://img1.imgtp.com/2022/09/13/djJ6Fots.png" alt="QQ截图20220607144950.png"></p><div class="code-wrapper"><pre><code class="hljs angelscript">&lt;NavLink&gt;的用法用于可以处于当前访问连接时修改连接的样式，处于active状态v5的写法可以添加如下属性activeStyle:活跃时的样式activeClassName：活跃时添加<span class="hljs-keyword">class</span><span class="hljs-symbol">exact</span>精确匹配也可以使用自定义<span class="hljs-symbol">class</span></code></pre></div><p><img src="https://img1.imgtp.com/2022/09/13/Ml03VBOs.png" alt="QQ截图20220607151506.png"></p><p>v6的写法，不需要activeStyle和activeClassName，可以在普通的style和className中传入一个函数，更加灵活方便</p><p><img src="https://img1.imgtp.com/2022/09/13/EfvZ4TfB.png" alt="QQ截图20220607151735.png"></p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">Switch</span>的作用 <span class="hljs-built_in">V5</span> 在<span class="hljs-built_in">V6</span>没有该组件</code></pre></div><p>组件中获取路由参数，params中存在对饮的路由参数</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">params</span> = useParams()</code></pre></div><h4 id="Navigate导航"><a href="#Navigate导航" class="headerlink" title="Navigate导航"></a>Navigate导航</h4><p>Navigate用于路由的重定向</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;Route <span class="hljs-attribute">path</span>=<span class="hljs-string">&#x27;/home&#x27;</span> element=&#123;&lt;Navigate <span class="hljs-attribute">to</span>=<span class="hljs-string">&quot;/home/recommend&quot;</span>/&gt;&#125;/&gt;</code></pre></div><h4 id="Not-Found页面配置"><a href="#Not-Found页面配置" class="headerlink" title="Not Found页面配置"></a>Not Found页面配置</h4><div class="code-wrapper"><pre><code class="hljs awk">&lt;Route path=<span class="hljs-string">&#x27;*&#x27;</span> element=&#123;&lt;NotFound<span class="hljs-regexp">/&gt;&#125;/</span>&gt;</code></pre></div><h3 id="Search-Params"><a href="#Search-Params" class="headerlink" title="Search Params"></a>Search Params</h3><p><img src="https://img1.imgtp.com/2022/09/13/TdiJP94D.png" alt="QQ截图20220607203231.png"></p><h3 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h3><div class="code-wrapper"><pre><code class="hljs reasonml">import &#123; useNavigate &#125; from <span class="hljs-string">&quot;react-router-dom&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-constructor">SignupForm()</span> &#123;  <span class="hljs-keyword">let</span> navigate = use<span class="hljs-constructor">Navigate()</span>;  async <span class="hljs-keyword">function</span> handle<span class="hljs-constructor">Submit(<span class="hljs-params">event</span>)</span> &#123;    event.prevent<span class="hljs-constructor">Default()</span>;    await submit<span class="hljs-constructor">Form(<span class="hljs-params">event</span>.<span class="hljs-params">target</span>)</span>;    navigate(<span class="hljs-string">&quot;../success&quot;</span>, &#123; replace: <span class="hljs-literal">true</span> &#125;);  &#125;  return &lt;form onSubmit=&#123;handleSubmit&#125;&gt;&#123;<span class="hljs-comment">/* ... */</span>&#125;&lt;/form&gt;;&#125;使用useNavigate可以实现手动进行路由跳转，<span class="hljs-keyword">let</span> navigate = use<span class="hljs-constructor">Navigate()</span>;他会返回一个函数，参数有两个，一个是<span class="hljs-keyword">to</span>, 另一个optional second &#123; replace, state &#125; arg，或者使用历史调用栈类似于go<span class="hljs-number">(-1)</span>调用navigate<span class="hljs-number">(-1)</span></code></pre></div><h3 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation"></a>useLocation</h3><div class="code-wrapper"><pre><code class="hljs crmsh">let <span class="hljs-keyword">location</span> <span class="hljs-title">= useLocation</span>();//获取location</code></pre></div><p><img src="https://img1.imgtp.com/2022/09/13/LD2qs0Cd.png" alt="QQ截图20220607212846.png"></p><h3 id="withRouter-component"><a href="#withRouter-component" class="headerlink" title="withRouter(component)"></a>withRouter(component)</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;  useLocation,  useNavigate,  useParams,  useSearchParams&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">withRouter</span>(<span class="hljs-params">Component</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentWithRouterProp</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();    <span class="hljs-keyword">const</span> navigate = <span class="hljs-title function_">useNavigate</span>();    <span class="hljs-keyword">const</span> params = <span class="hljs-title function_">useParams</span>();    <span class="hljs-keyword">const</span> [searchParams] = <span class="hljs-title function_">useSearchParams</span>()    <span class="hljs-keyword">const</span> query = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(searchParams)    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span></span></span><span class="hljs-tag"><span class="language-xml">        &#123;<span class="hljs-attr">...props</span>&#125;</span></span><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">router</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">location</span>, <span class="hljs-attr">navigate</span>, <span class="hljs-attr">params</span>,<span class="hljs-attr">query</span> &#125;&#125;</span></span><span class="hljs-tag"><span class="language-xml">      /&gt;</span></span>    );  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">ComponentWithRouterProp</span>;&#125;<span class="hljs-comment">//在v6中没有这个高阶组件，因为v6都是使用到的是函数式组件，所以不需要，如果想用可以这样封装，在v5中的主要目的是为了手动调用路由可以获取到history,组件可以通过this.props.history,push()来手动进行路由跳转，v6可以使用到useNavigate()</span></code></pre></div><h4 id="路由的配置文件"><a href="#路由的配置文件" class="headerlink" title="路由的配置文件"></a>路由的配置文件</h4><p>通过像vue-router来将路由定义在单独的文件中</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//router.js</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Home&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeRecommend</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/HomeRecommend&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeRanking</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/HomeRanking&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeSongMenu</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/HomeSongMenu&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Category</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/Category&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Order</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../pages/Order&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">NotFound</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/NotFound&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/Detail&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../pages/User&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Navigate</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">About</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../pages/About&quot;</span>))<span class="hljs-keyword">const</span> <span class="hljs-title class_">Login</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../pages/Login&quot;</span>))<span class="hljs-keyword">const</span> routes = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Home</span>/&gt;</span></span>,    <span class="hljs-attr">children</span>: [      &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/recommend&quot;</span>/&gt;</span></span>      &#125;,      &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home/recommend&quot;</span>,        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HomeRecommend</span>/&gt;</span></span>      &#125;,      &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home/ranking&quot;</span>,        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HomeRanking</span>/&gt;</span></span>      &#125;,      &#123;        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home/songmenu&quot;</span>,        <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HomeSongMenu</span>/&gt;</span></span>      &#125;    ]  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">About</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/category&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Category</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/order&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Order</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/detail/:id&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Detail</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">User</span>/&gt;</span></span>  &#125;,  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;*&quot;</span>,    <span class="hljs-attr">element</span>: <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NotFound</span>/&gt;</span></span>  &#125;]<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> routes</code></pre></div><div class="code-wrapper"><pre><code class="hljs reasonml">&#123;use<span class="hljs-constructor">Routes(<span class="hljs-params">routes</span>)</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redux笔记</title>
    <link href="/2022/09/08/Redux%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/08/Redux%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="##纯函数"></a>##纯函数</h4><p> 确定的输入，一定会产生确定的输出；</p><p>函数在执行过程中，不能产生副作用</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>一个store文件夹由4个文件组成</p><p>actionCreator.js</p><p>这个文件是用来编写action,action是一个普通的JavaScript对象，用来描述这次更新的type和content</p><p>强制使用action的好处是可以清晰的知道数据到底发生了什么样的变化，所有的数据变化都是可跟追、可预测的；</p><p>当然，目前我们的action是固定的对象</p><p>真实应用中，我们会通过函数来定义，返回一个action</p><p>Redux要求我们通过action来更新数据,通过dispatch action来更新数据</p><div class="code-wrapper"><pre><code class="hljs coffeescript">//actionCreator.jsconst &#123; ADD_NUMBER, CHANGE_NAME &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./constants&quot;</span>)const changeNameAction = <span class="hljs-function"><span class="hljs-params">(name)</span> =&gt;</span> (&#123;  type: CHANGE_NAME,  name&#125;)const addNumberAction = <span class="hljs-function"><span class="hljs-params">(num)</span> =&gt;</span> (&#123;  type: ADD_NUMBER,  num&#125;)module.<span class="hljs-built_in">exports</span> = &#123;  changeNameAction,  addNumberAction&#125;</code></pre></div><p>constants.js 用来定义type常量</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ADD_NUMBER</span> = <span class="hljs-string">&quot;add_number&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHANGE_NAME</span> = <span class="hljs-string">&quot;change_name&quot;</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-variable constant_">ADD_NUMBER</span>,  <span class="hljs-variable constant_">CHANGE_NAME</span>&#125;</code></pre></div><p>reducer.js</p><p>reducer是将state和action联系起来的桥梁，reducer是纯函数，reducer做的事情是将传入的state和action结合起来生成新的state</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-variable constant_">ADD_NUMBER</span>, <span class="hljs-variable constant_">CHANGE_NAME</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./constants&quot;</span>)<span class="hljs-comment">// 初始化的数据</span><span class="hljs-keyword">const</span> initialState = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state = initialState, action</span>) &#123;  <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-attr">CHANGE_NAME</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">name</span>: action.<span class="hljs-property">name</span> &#125;    <span class="hljs-keyword">case</span> <span class="hljs-attr">ADD_NUMBER</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + action.<span class="hljs-property">num</span> &#125;    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">return</span> state  &#125;&#125;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = reducer</code></pre></div><p>index.js</p><p>创建store实例</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; createStore &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;redux&quot;</span>)<span class="hljs-keyword">const</span> reducer =  <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./reducer.js&quot;</span>)<span class="hljs-comment">// 创建的store</span><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = store</code></pre></div><p>使用store中的数据</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./store&quot;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store.<span class="hljs-title function_">getState</span>())</code></pre></div><p>修改store中的数据</p><div class="code-wrapper"><pre><code class="hljs js">store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeNameAction</span>(<span class="hljs-string">&quot;kobe&quot;</span>))</code></pre></div><p>订阅store中的数据</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./store&quot;</span>)<span class="hljs-keyword">const</span> unsubscribe = store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;订阅数据的变化:&quot;</span>, store.<span class="hljs-title function_">getState</span>())&#125;)<span class="hljs-comment">// 修改store中的数据: 必须action</span>store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;change_name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span> &#125;)store.<span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;change_name&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lilei&quot;</span> &#125;)<span class="hljs-title function_">unsubscribe</span>()</code></pre></div><h4 id="redux-三大核心-store-action-reducer"><a href="#redux-三大核心-store-action-reducer" class="headerlink" title="redux 三大核心 store action reducer"></a>redux 三大核心 store action reducer</h4><h4 id="redux-的三大原则"><a href="#redux-的三大原则" class="headerlink" title="redux 的三大原则"></a>redux 的三大原则</h4><ul><li>单一数据源<ol><li> 整个应用程序的state被存储在一颗object tree中，并且这个object tree只存储在一个 store 中</li><li>Redux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护</li><li>单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改</li></ol></li><li>State是只读的<ol><li>​    唯一修改State的方法一定是触发action，不要试图在其他地方通过任何的方式来修改State</li><li>​    这样就确保了View或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改state</li><li>这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race condition（竟态）的问题</li></ol></li><li>使用纯函数来执行修改<ol><li>​    通过reducer将 旧state和 actions联系在一起，并且返回一个新的State</li><li>​    随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state tree的一部分</li><li>   但是所有的reducer都应该是纯函数，不能产生任何的副作用</li></ol></li></ul><img src="https://img1.imgtp.com/2022/09/13/UQYkeCuR.png" alt="QQ截图20220913015123.png" style="zoom:200%;" /><p><img src="https://img1.imgtp.com/2022/09/13/6ShJ2AyZ.png" alt="QQ截图20220913015145.png"></p><h4 id="react和redux结合使用"><a href="#react和redux结合使用" class="headerlink" title="react和redux结合使用"></a>react和redux结合使用</h4><p>react-redux的使用</p><div class="code-wrapper"><pre><code class="hljs html">//index.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import App from &#x27;./App&#x27;;import &#123; Provider &#125; from &quot;react-redux&quot;import store from &quot;./store&quot;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render(  // <span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">&#123;store&#125;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>  // <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//在组件中使用</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span><span class="hljs-comment">// import store from &quot;../store&quot;</span><span class="hljs-keyword">import</span> &#123; addNumberAction, subNumberAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store/counter&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;  <span class="hljs-title function_">calcNumber</span>(<span class="hljs-params">num, isAdd</span>) &#123;    <span class="hljs-keyword">if</span> (isAdd) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">addNumber</span>(num)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">subNumber</span>(num)    &#125;  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> &#123; counter, banners, recommends, userInfo &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;user&#x27;</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>nickname: &#123;userInfo.nickname&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>About Page: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.calcNumber(6, true)&#125;&gt;+6<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.calcNumber(88, true)&#125;&gt;+88<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.calcNumber(6, false)&#125;&gt;-6<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.calcNumber(88, false)&#125;&gt;-88<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;banner&#x27;</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>轮播图数据:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">            &#123;</span><span class="language-xml">              banners.map((item, index) =&gt; &#123;</span><span class="language-xml">                return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml">              &#125;)</span><span class="language-xml">            &#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;recommend&#x27;</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>推荐数据:<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">            &#123;</span><span class="language-xml">              recommends.map((item, index) =&gt; &#123;</span><span class="language-xml">                return <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml">              &#125;)</span><span class="language-xml">            &#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; (&#123;  <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span>.<span class="hljs-property">counter</span>,  <span class="hljs-attr">banners</span>: state.<span class="hljs-property">home</span>.<span class="hljs-property">banners</span>,  <span class="hljs-attr">recommends</span>: state.<span class="hljs-property">home</span>.<span class="hljs-property">recommends</span>,  <span class="hljs-attr">userInfo</span>: state.<span class="hljs-property">user</span>.<span class="hljs-property">userInfo</span>&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch</span>) =&gt; (&#123;  <span class="hljs-title function_">addNumber</span>(<span class="hljs-params">num</span>) &#123;    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addNumberAction</span>(num))  &#125;,  <span class="hljs-title function_">subNumber</span>(<span class="hljs-params">num</span>) &#123;    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">subNumberAction</span>(num))  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="hljs-title class_">About</span>)</code></pre></div><p>没有使用react-redux的写法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store&quot;</span><span class="hljs-keyword">import</span> &#123; addNumberAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store/counter&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">super</span>()    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;      <span class="hljs-attr">counter</span>: store.<span class="hljs-title function_">getState</span>().<span class="hljs-property">counter</span>.<span class="hljs-property">counter</span>,      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,      <span class="hljs-attr">friends</span>: [        &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>&#125;,        &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">112</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>&#125;,        &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">113</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;james&quot;</span>&#125;,      ]    &#125;  &#125;  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;    store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">const</span> state = store.<span class="hljs-title function_">getState</span>().<span class="hljs-property">counter</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> &#125;)    &#125;)  &#125;  <span class="hljs-title function_">addNumber</span>(<span class="hljs-params">num</span>) &#123;    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addNumberAction</span>(num))  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> &#123; counter &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home Counter: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.addNumber(1)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.addNumber(5)&#125;&gt;+5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.addNumber(8)&#125;&gt;+8<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span></code></pre></div><h4 id="我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码"><a href="#我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码" class="headerlink" title="我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码"></a>我们可以将react组件中的异步操作放到redux中，使用中间件，中间件的目的是在dispatch的action和最终达到的reducer之间，扩展一些自己的代码</h4><p>使用redux-thunk来发布异步请求</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-thunk&quot;</span><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reducer&quot;</span><span class="hljs-comment">// 正常情况下 store.dispatch(object)</span><span class="hljs-comment">// 想要派发函数 store.dispatch(function)</span><span class="hljs-comment">// redux-devtools</span><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;<span class="hljs-attr">trace</span>: <span class="hljs-literal">true</span>&#125;) || compose;<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, <span class="hljs-title function_">composeEnhancers</span>(<span class="hljs-title function_">applyMiddleware</span>(thunk)))<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><p>定义一个返回函数的action</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchHomeMultidataAction</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-comment">// 如果是一个普通的action, 那么我们这里需要返回action对象</span>  <span class="hljs-comment">// 问题: 对象中是不能直接拿到从服务器请求的异步数据的</span>  <span class="hljs-comment">// return &#123;&#125;</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch, getState</span>) &#123;    <span class="hljs-comment">// 异步操作: 网络请求</span>    <span class="hljs-comment">// console.log(&quot;foo function execution-----&quot;, getState().counter)</span>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      <span class="hljs-keyword">const</span> banners = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">banner</span>.<span class="hljs-property">list</span>      <span class="hljs-keyword">const</span> recommends = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">recommend</span>.<span class="hljs-property">list</span>      <span class="hljs-comment">// dispatch(&#123; type: actionTypes.CHANGE_BANNERS, banners &#125;)</span>      <span class="hljs-comment">// dispatch(&#123; type: actionTypes.CHANGE_RECOMMENDS, recommends &#125;)</span>      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeBannersAction</span>(banners))      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeRecommendsAction</span>(recommends))    &#125;)  &#125;  <span class="hljs-comment">// 如果返回的是一个函数, 那么redux是不支持的</span>  <span class="hljs-comment">// return foo</span>&#125;</code></pre></div><h4 id="定义applyMiddleware中间件"><a href="#定义applyMiddleware中间件" class="headerlink" title="定义applyMiddleware中间件"></a>定义applyMiddleware中间件</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMiddleware</span>(<span class="hljs-params">store, ...fns</span>) &#123;  fns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;    <span class="hljs-title function_">fn</span>(store)  &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> applyMiddleware</code></pre></div><h4 id="定义log中间件"><a href="#定义log中间件" class="headerlink" title="定义log中间件"></a>定义log中间件</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">store</span>) &#123;  <span class="hljs-keyword">const</span> next = store.<span class="hljs-property">dispatch</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">logAndDispatch</span>(<span class="hljs-params">action</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;当前派发的action:&quot;</span>, action)    <span class="hljs-comment">// 真正派发的代码: 使用之前的dispatch进行派发</span>    <span class="hljs-title function_">next</span>(action)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;派发之后的结果:&quot;</span>, store.<span class="hljs-title function_">getState</span>())  &#125;  <span class="hljs-comment">// monkey patch: 猴补丁 =&gt; 篡改现有的代码, 对整体的执行逻辑进行修改</span>  store.<span class="hljs-property">dispatch</span> = logAndDispatch&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> log</code></pre></div><h4 id="定义thunk中间件"><a href="#定义thunk中间件" class="headerlink" title="定义thunk中间件"></a>定义thunk中间件</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">thunk</span>(<span class="hljs-params">store</span>) &#123;  <span class="hljs-keyword">const</span> next = store.<span class="hljs-property">dispatch</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchThunk</span>(<span class="hljs-params">action</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&quot;function&quot;</span>) &#123;      <span class="hljs-title function_">action</span>(store.<span class="hljs-property">dispatch</span>, store.<span class="hljs-property">getState</span>)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-title function_">next</span>(action)    &#125;  &#125;  store.<span class="hljs-property">dispatch</span> = dispatchThunk&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> thunk</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore, compose, combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span><span class="hljs-keyword">import</span> &#123; log, thunk, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./middleware&quot;</span><span class="hljs-comment">// import thunk from &quot;redux-thunk&quot;</span><span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./counter&quot;</span><span class="hljs-keyword">import</span> homeReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./home&quot;</span><span class="hljs-keyword">import</span> userReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./user&quot;</span><span class="hljs-comment">// 正常情况下 store.dispatch(object)</span><span class="hljs-comment">// 想要派发函数 store.dispatch(function)</span><span class="hljs-comment">// 将两个reducer合并在一起</span><span class="hljs-keyword">const</span> reducer = <span class="hljs-title function_">combineReducers</span>(&#123;  <span class="hljs-attr">counter</span>: counterReducer,  <span class="hljs-attr">home</span>: homeReducer,  <span class="hljs-attr">user</span>: userReducer&#125;)<span class="hljs-comment">// combineReducers实现原理(了解)</span><span class="hljs-comment">// function reducer(state = &#123;&#125;, action) &#123;</span><span class="hljs-comment">//   // 返回一个对象, store的state</span><span class="hljs-comment">//   return &#123;</span><span class="hljs-comment">//     counter: counterReducer(state.counter, action),</span><span class="hljs-comment">//     home: homeReducer(state.home, action),</span><span class="hljs-comment">//     user: userReducer(state.user, action)</span><span class="hljs-comment">//   &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// redux-devtools</span><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;<span class="hljs-attr">trace</span>: <span class="hljs-literal">true</span>&#125;) || compose;<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer)<span class="hljs-title function_">applyMiddleware</span>(store, log, thunk)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><h4 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h4><p>redux给我们提供了一个combineReducers函数可以方便的让我们对多个reducer进行合并</p><p>事实上，它也是将我们传入的reducers合并到一个对象中，最终返回一个combination的函数（相当于我们之前的reducer函 数了）； </p><p> 在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state；</p><p> 新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新</p><h4 id="Redux-Toolkit的用法"><a href="#Redux-Toolkit的用法" class="headerlink" title="Redux Toolkit的用法"></a>Redux Toolkit的用法</h4><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @reduxjs/toolkit react-redux</code></pre></div><p>Redux Toolkit 是官方推荐的编写 Redux 逻辑的方法。</p><p>redux toolkit API </p><ul><li>configureStore:包装createStore以提供简化的配置选项和良好的默认值。它可以自动组合你的 slice reducer，添加你提供 的任何 Redux 中间件，redux-thunk默认包含，并启用 Redux DevTools Extension</li><li>createSlice:接受reducer函数的对象、切片名称和初始状态值，并自动生成切片reducer，并带有相应的actions</li><li>createAsyncThunk:接受一个动作类型字符串和一个返回promise的函数，并生成一个pending/fulfilled/rejected基于该promise分派动作类型的 thunk</li></ul><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//store.index.js</span><span class="hljs-keyword">import</span> &#123; configureStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span><span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./features/counter&quot;</span><span class="hljs-keyword">import</span> homeReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./features/home&quot;</span><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">configureStore</span>(&#123;  <span class="hljs-attr">reducer</span>: &#123;    <span class="hljs-attr">counter</span>: counterReducer,    <span class="hljs-attr">home</span>: homeReducer  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">///features/counter.js</span><span class="hljs-keyword">import</span> &#123; createSlice &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span><span class="hljs-keyword">const</span> counterSlice = <span class="hljs-title function_">createSlice</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;counter&quot;</span>,<span class="hljs-comment">//用户标记slice的名词,在之后的redux-devtool中会显示对应的名词；</span>  <span class="hljs-comment">//初始化值</span>  <span class="hljs-attr">initialState</span>: &#123;    <span class="hljs-attr">counter</span>: <span class="hljs-number">888</span>  &#125;,  <span class="hljs-comment">//相当于之前的reducer函数</span>  <span class="hljs-attr">reducers</span>: &#123;    <span class="hljs-title function_">addNumber</span>(<span class="hljs-params">state, &#123; payload &#125;</span>) &#123;      state.<span class="hljs-property">counter</span> = state.<span class="hljs-property">counter</span> + payload    &#125;,    <span class="hljs-title function_">subNumber</span>(<span class="hljs-params">state, &#123; payload &#125;</span>) &#123;      state.<span class="hljs-property">counter</span> = state.<span class="hljs-property">counter</span> - payload    &#125;  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; addNumber, subNumber &#125; = counterSlice.<span class="hljs-property">actions</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> counterSlice.<span class="hljs-property">reducer</span></code></pre></div><p>//在组件中使用</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../hoc&quot;</span><span class="hljs-keyword">import</span> &#123; addNumber &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/features/counter&quot;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> &#123; counter &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>About Counter: &#123;counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; (&#123;  <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span>.<span class="hljs-property">counter</span>&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDispatchToProps</span> = (<span class="hljs-params">dispatch</span>) =&gt; (&#123;  <span class="hljs-title function_">addNumber</span>(<span class="hljs-params">num</span>) &#123;    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addNumber</span>(num))  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="hljs-title class_">About</span>)</code></pre></div><h4 id="Redux-Toolkit的异步操作"><a href="#Redux-Toolkit的异步操作" class="headerlink" title="Redux Toolkit的异步操作"></a>Redux Toolkit的异步操作</h4><p>Redux Toolkit默认已经给我们继承了Thunk相关的功能：createAsyncThunk</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createSlice, createAsyncThunk &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@reduxjs/toolkit&#x27;</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fetchHomeMultidataAction = <span class="hljs-title function_">createAsyncThunk</span>(  <span class="hljs-string">&quot;fetch/homemultidata&quot;</span>,   <span class="hljs-keyword">async</span> (extraInfo, &#123; dispatch, getState &#125;) =&gt; &#123;    <span class="hljs-comment">// console.log(extraInfo, dispatch, getState)</span>    <span class="hljs-comment">// 1.发送网络请求, 获取数据</span>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span>)    <span class="hljs-comment">// 2.取出数据, 并且在此处直接dispatch操作(可以不做)</span>    <span class="hljs-keyword">const</span> banners = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">banner</span>.<span class="hljs-property">list</span>    <span class="hljs-keyword">const</span> recommends = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">recommend</span>.<span class="hljs-property">list</span>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeBanners</span>(banners))    <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">changeRecommends</span>(recommends))    <span class="hljs-comment">// 3.返回结果, 那么action状态会变成fulfilled状态</span>    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>&#125;)<span class="hljs-keyword">const</span> homeSlice = <span class="hljs-title function_">createSlice</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>,  <span class="hljs-attr">initialState</span>: &#123;    <span class="hljs-attr">banners</span>: [],    <span class="hljs-attr">recommends</span>: []  &#125;,  <span class="hljs-attr">reducers</span>: &#123;    <span class="hljs-title function_">changeBanners</span>(<span class="hljs-params">state, &#123; payload &#125;</span>) &#123;      state.<span class="hljs-property">banners</span> = payload    &#125;,    <span class="hljs-title function_">changeRecommends</span>(<span class="hljs-params">state, &#123; payload &#125;</span>) &#123;      state.<span class="hljs-property">recommends</span> = payload    &#125;  &#125;,  <span class="hljs-comment">// extraReducers: &#123;</span>  <span class="hljs-comment">//   [fetchHomeMultidataAction.pending](state, action) &#123;</span>  <span class="hljs-comment">//     console.log(&quot;fetchHomeMultidataAction pending&quot;)</span>  <span class="hljs-comment">//   &#125;,</span>  <span class="hljs-comment">//   [fetchHomeMultidataAction.fulfilled](state, &#123; payload &#125;) &#123;</span>  <span class="hljs-comment">//     state.banners = payload.data.banner.list</span>  <span class="hljs-comment">//     state.recommends = payload.data.recommend.list</span>  <span class="hljs-comment">//   &#125;,</span>  <span class="hljs-comment">//   [fetchHomeMultidataAction.rejected](state, action) &#123;</span>  <span class="hljs-comment">//     console.log(&quot;fetchHomeMultidataAction rejected&quot;)</span>  <span class="hljs-comment">//   &#125;</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-attr">extraReducers</span>: <span class="hljs-function">(<span class="hljs-params">builder</span>) =&gt;</span> &#123;    <span class="hljs-comment">// builder.addCase(fetchHomeMultidataAction.pending, (state, action) =&gt; &#123;</span>    <span class="hljs-comment">//   console.log(&quot;fetchHomeMultidataAction pending&quot;)</span>    <span class="hljs-comment">// &#125;).addCase(fetchHomeMultidataAction.fulfilled, (state, &#123; payload &#125;) =&gt; &#123;</span>    <span class="hljs-comment">//   state.banners = payload.data.banner.list</span>    <span class="hljs-comment">//   state.recommends = payload.data.recommend.list</span>    <span class="hljs-comment">// &#125;)</span>  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; changeBanners, changeRecommends &#125; = homeSlice.<span class="hljs-property">actions</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> homeSlice.<span class="hljs-property">reducer</span></code></pre></div><h4 id="Redux-Toolkit的数据不可变性"><a href="#Redux-Toolkit的数据不可变性" class="headerlink" title="Redux Toolkit的数据不可变性"></a>Redux Toolkit的数据不可变性</h4><p>我们经常会进行浅拷贝来完成某些操作，但是浅拷贝事实上也是存在问题的</p><p>比如过大的对象，进行浅拷贝也会造成性能的浪费</p><p>比如浅拷贝后的对象，在深层改变时，依然会对之前的对象产生影响</p><p>事实上Redux Toolkit底层使用了immerjs的一个库来保证数据的不可变性</p><p>为了节约内存，又出现了一个新的算法：Persistent Data Structure（持久化数据结构或一致性 数据结构）；</p><p>​    用一种数据结构来保存数据；</p><p>​    当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会 对内存造成浪费；</p><h4 id="自定义connect函数"><a href="#自定义connect函数" class="headerlink" title="自定义connect函数"></a>自定义connect函数</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//connect.js</span><span class="hljs-comment">// connect的参数:</span><span class="hljs-comment">// 参数一: 函数</span><span class="hljs-comment">// 参数二: 函数</span><span class="hljs-comment">// 返回值: 函数 =&gt; 高阶组件</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">StoreContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./StoreContext&quot;</span>;<span class="hljs-comment">// import store from &quot;../store&quot;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">mapStateToProps, mapDispatchToProps, store</span>) &#123;  <span class="hljs-comment">// 高阶组件: 函数</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">WrapperComponent</span>) &#123;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> &#123;      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props, context</span>) &#123;        <span class="hljs-variable language_">super</span>(props)                <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-title function_">mapStateToProps</span>(context.<span class="hljs-title function_">getState</span>())      &#125;      <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">unsubscribe</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// this.forceUpdate()</span>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-title function_">getState</span>()))        &#125;)      &#125;      <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unsubscribe</span>()      &#125;      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> stateObj = <span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-title function_">getState</span>())        <span class="hljs-keyword">const</span> dispatchObj = <span class="hljs-title function_">mapDispatchToProps</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">dispatch</span>)        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrapperComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125; &#123;<span class="hljs-attr">...stateObj</span>&#125; &#123;<span class="hljs-attr">...dispatchObj</span>&#125;/&gt;</span></span>      &#125;    &#125;    <span class="hljs-title class_">NewComponent</span>.<span class="hljs-property">contextType</span> = <span class="hljs-title class_">StoreContext</span>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NewComponent</span>  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//StoreContext.js</span><span class="hljs-keyword">import</span> &#123; createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">StoreContext</span> = <span class="hljs-title function_">createContext</span>()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象的原型继承</title>
    <link href="/2022/09/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    <url>/2022/09/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h4 id="直接将父类的原型赋值给子类"><a href="#直接将父类的原型赋值给子类" class="headerlink" title="直接将父类的原型赋值给子类"></a>直接将父类的原型赋值给子类</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义Person构造函数(类)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, height, address</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">running</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);&#125;;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eating</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);&#125;;<span class="hljs-comment">// 定义学生类</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, height, address, sno, score</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;&#125;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;&#125;;<span class="hljs-keyword">const</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-title function_">getName</span>());<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;777&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>, <span class="hljs-string">&quot;999&quot;</span>, <span class="hljs-string">&quot;101010&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">getName</span>());</code></pre></div><p>这种方式会使父类和子类共用原型链上的方法，子类也会修改父类原型链的方法，修改或者添加子类原型链上的方法，父类也会受到影响，父类原型链上也会有这个方法</p><h4 id="通过父类实例实现继承"><a href="#通过父类实例实现继承" class="headerlink" title="通过父类实例实现继承"></a>通过父类实例实现继承</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义Person构造函数(类)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, height, address</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">running</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);&#125;;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eating</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);&#125;;<span class="hljs-comment">// 定义学生类</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">sno, score</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;&#125;<span class="hljs-comment">// Student.prototype指向Person实例</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = p1;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;&#125;;<span class="hljs-keyword">const</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;555&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-title function_">getName</span>());<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;777&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>, <span class="hljs-string">&quot;999&quot;</span>, <span class="hljs-string">&quot;101010&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">getName</span>());</code></pre></div><p>原型链继承虽然可以解决子类会修改父类的原型链上的方法的问题，但是子类无法查看父类的参数，也，也没办法修改父类的参数，打印看不到父类的参数，不可以给父类传参</p><h4 id="借用构造函数的继承"><a href="#借用构造函数的继承" class="headerlink" title="借用构造函数的继承"></a>借用构造函数的继承</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, height, address</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">running</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);&#125;;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eating</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);&#125;;<span class="hljs-comment">// 定义学生类</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, height, address, sno, score</span>) &#123;  <span class="hljs-comment">// 借用父类的构造函数</span>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, height, address);  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;&#125;<span class="hljs-comment">// Student.prototype指向Person实例</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = p1;<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;&#125;;<span class="hljs-keyword">const</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>, <span class="hljs-string">&quot;666&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-title function_">getName</span>());<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu.<span class="hljs-title function_">eating</span>());<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;777&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>, <span class="hljs-string">&quot;999&quot;</span>, <span class="hljs-string">&quot;101010&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">eating</span>());</code></pre></div><p>这种方式会调用两次父类的构造函数</p><p>一次在创建子类原型的时候</p><p>另一次在子类构造函数内部(也就是每次创建子类实例的时候)；</p><h4 id="组合寄生式继承"><a href="#组合寄生式继承" class="headerlink" title="组合寄生式继承"></a>组合寄生式继承</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">o</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();&#125;<span class="hljs-comment">// 创建寄生函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherit</span>(<span class="hljs-params">Subtype, Supertype</span>) &#123;  <span class="hljs-comment">// 方式一</span>  <span class="hljs-comment">// const obj=Object.create(Supertype.prototype)</span>  <span class="hljs-comment">// Subtype.prototype=obj</span>  <span class="hljs-comment">// 方式二</span>  <span class="hljs-title class_">Subtype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">createObject</span>(<span class="hljs-title class_">Supertype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Subtype</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">value</span>: <span class="hljs-title class_">Subtype</span>,  &#125;);  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-title class_">Subtype</span>, <span class="hljs-title class_">Supertype</span>);  <span class="hljs-comment">// Subtype.__proto__=Supertype</span>&#125;<span class="hljs-comment">// 寄生组合式继承</span><span class="hljs-comment">// 原型链/借用/原型式(对象之间)/寄生式函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, height</span>) &#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span> = height;&#125;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">running</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);&#125;;<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eating</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);&#125;;<span class="hljs-comment">//类方法</span><span class="hljs-title class_">Person</span>.<span class="hljs-property">sleep</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;static sleep&quot;</span>);&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age, height, sno, score</span>) &#123;  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age, height);  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;&#125;<span class="hljs-title function_">inherit</span>(<span class="hljs-title class_">Student</span>, <span class="hljs-title class_">Person</span>);<span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">studying</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;studying&quot;</span>);&#125;;<span class="hljs-comment">// 创建实例对象</span><span class="hljs-keyword">var</span> stu1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>, <span class="hljs-number">111</span>, <span class="hljs-number">100</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stu1);stu1.<span class="hljs-title function_">studying</span>();<span class="hljs-title class_">Student</span>.<span class="hljs-title function_">sleep</span>();</code></pre></div><h4 id="ES6中的继承"><a href="#ES6中的继承" class="headerlink" title="ES6中的继承"></a>ES6中的继承</h4><p>es6中增加了extends关键字来实现继承</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;   &#125;   <span class="hljs-title function_">running</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);   &#125;   <span class="hljs-title function_">eating</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;eating~&quot;</span>);   &#125;   <span class="hljs-keyword">static</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;static animal sleep&quot;</span>);   &#125; &#125; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;   <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age, sno, score</span>) &#123;     <span class="hljs-comment">// super可用来调用父类的构造函数、实例方法，静态方法</span>     <span class="hljs-variable language_">super</span>(name, age);     <span class="hljs-variable language_">this</span>.<span class="hljs-property">sno</span> = sno;     <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;   &#125;   <span class="hljs-title function_">studying</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;studying~&quot;</span>);   &#125; &#125; <span class="hljs-keyword">const</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;222&quot;</span>, <span class="hljs-string">&quot;333&quot;</span>, <span class="hljs-string">&quot;444&quot;</span>, <span class="hljs-string">&quot;555&quot;</span>); <span class="hljs-comment">// 类方法也可以实现继承</span> <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">sleep</span>();</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>call函数的实现</title>
    <link href="/2022/09/07/call%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/07/call%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">MyCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, ...args</span>) &#123;  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;  thisArg = thisArg != <span class="hljs-literal">null</span> ? <span class="hljs-title class_">Object</span>(thisArg) : globalThis; <span class="hljs-comment">//Object(thisArg)如果是基本类型将会将换成包装类，globalThis分别对应window/node的环境</span>  args = args || [];  thisArg.<span class="hljs-property">fn</span> = fn;  <span class="hljs-keyword">const</span> result = thisArg.<span class="hljs-title function_">fn</span>(...args);  <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span>;  <span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo函数被执行&quot;</span>, <span class="hljs-variable language_">this</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum函数被执行&quot;</span>, <span class="hljs-variable language_">this</span>, num1, num2);  <span class="hljs-keyword">return</span> num1 + num2;&#125;foo.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>);<span class="hljs-keyword">var</span> result = sum.<span class="hljs-title function_">call</span>(&#123;&#125;, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<span class="hljs-comment">// console.log(&quot;系统调用的结果:&quot;, result)</span><span class="hljs-comment">// 自己实现的函数的hycall方法</span><span class="hljs-comment">// 默认进行隐式绑定</span><span class="hljs-comment">// foo.hycall(&#123;name: &quot;why&quot;&#125;)</span>foo.<span class="hljs-title class_">MyCall</span>(<span class="hljs-literal">undefined</span>);<span class="hljs-keyword">var</span> result = sum.<span class="hljs-title class_">MyCall</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hycall的调用:&quot;</span>, result);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Apply函数的实现</title>
    <link href="/2022/09/07/Apply%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/07/Apply%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, args</span>) &#123;  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;  thisArg = thisArg != <span class="hljs-literal">null</span> ? <span class="hljs-title class_">Object</span>(thisArg) : globalThis;  <span class="hljs-keyword">if</span> (!(args <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;args is no array&quot;</span>);  &#125;  args = args || [];  thisArg.<span class="hljs-property">fn</span> = fn;  <span class="hljs-keyword">const</span> result = thisArg.<span class="hljs-title function_">fn</span>(...args);  <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span>;  <span class="hljs-keyword">return</span> result;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>节流函数的实现</title>
    <link href="/2022/09/07/%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/07/%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="节流函数的基本实现"><a href="#节流函数的基本实现" class="headerlink" title="节流函数的基本实现"></a>节流函数的基本实现</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params">fn, interval</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            <span class="hljs-title function_">fn</span>();</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">      &#125;, <span class="hljs-number">1000</span>);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="this和参数绑定"><a href="#this和参数绑定" class="headerlink" title="this和参数绑定"></a>this和参数绑定</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params">fn, interval</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">      &#125;, <span class="hljs-number">1000</span>);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="对立即执行进行控制"><a href="#对立即执行进行控制" class="headerlink" title="对立即执行进行控制"></a>对立即执行进行控制</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params">fn, interval, leading = <span class="hljs-literal">true</span></span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-comment">// 对立即执行进行控制</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (!leading &amp;&amp; startTime === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(</span><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">1000</span>,</span><span class="language-javascript">        <span class="hljs-literal">false</span></span><span class="language-javascript">      );</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>尾部执行控制</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="language-javascript">        fn,</span></span><span class="hljs-params"><span class="language-javascript">        interval,</span></span><span class="hljs-params"><span class="language-javascript">        &#123; leading = <span class="hljs-literal">true</span>, trailing = <span class="hljs-literal">false</span> &#125; = &#123;&#125;</span></span><span class="hljs-params"><span class="language-javascript">      </span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-comment">// 对立即执行进行控制</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (!leading &amp;&amp; startTime === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">            <span class="hljs-keyword">return</span>;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-comment">// 针对waitTime还有余数的时候</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (trailing &amp;&amp; !timer) &#123;</span><span class="language-javascript">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">              fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">              timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">              startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">            &#125;, waitTime);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(</span><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">1000</span>,</span><span class="language-javascript">        &#123; <span class="hljs-attr">trailing</span>: <span class="hljs-literal">true</span> &#125;</span><span class="language-javascript">      );</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="取消函数"><a href="#取消函数" class="headerlink" title="取消函数"></a>取消函数</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="language-javascript">        fn,</span></span><span class="hljs-params"><span class="language-javascript">        interval,</span></span><span class="hljs-params"><span class="language-javascript">        &#123; leading = <span class="hljs-literal">true</span>, trailing = <span class="hljs-literal">false</span> &#125; = &#123;&#125;</span></span><span class="hljs-params"><span class="language-javascript">      </span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">          <span class="hljs-comment">// 对立即执行进行控制</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (!leading &amp;&amp; startTime === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            startTime = nowTime;</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">            <span class="hljs-keyword">return</span>;</span><span class="language-javascript">          &#125;</span><span class="language-javascript">          <span class="hljs-comment">// 针对waitTime还有余数的时候</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (trailing &amp;&amp; !timer) &#123;</span><span class="language-javascript">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">              fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">              timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">              startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">            &#125;, waitTime);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消函数</span></span><span class="language-javascript">        _throttle.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">          startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _throttle;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(</span><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">1000</span>,</span><span class="language-javascript">        &#123; <span class="hljs-attr">trailing</span>: <span class="hljs-literal">true</span> &#125;</span><span class="language-javascript">      );</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">myThrottle</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="language-javascript">        fn,</span></span><span class="hljs-params"><span class="language-javascript">        interval,</span></span><span class="hljs-params"><span class="language-javascript">        &#123; leading = <span class="hljs-literal">true</span>, trailing = <span class="hljs-literal">false</span> &#125; = &#123;&#125;</span></span><span class="hljs-params"><span class="language-javascript">      </span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">try</span> &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">              <span class="hljs-keyword">try</span> &#123;</span><span class="language-javascript">              &#125; <span class="hljs-keyword">catch</span> (error) &#123;&#125;</span><span class="language-javascript">            &#125;);</span><span class="language-javascript">            <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">            <span class="hljs-comment">// 对立即执行进行控制</span></span><span class="language-javascript">            <span class="hljs-keyword">if</span> (!leading &amp;&amp; startTime === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">              startTime = nowTime;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">            <span class="hljs-keyword">const</span> waitTime = interval - (nowTime - startTime); <span class="hljs-comment">//第一次肯定会执行，因为startTime为0</span></span><span class="language-javascript">            <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">              <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">              <span class="hljs-keyword">const</span> res = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">              <span class="hljs-title function_">resolve</span>(res);</span><span class="language-javascript">              startTime = nowTime;</span><span class="language-javascript">              timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">              <span class="hljs-keyword">return</span>;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">            <span class="hljs-comment">// 针对waitTime还有余数的时候</span></span><span class="language-javascript">            <span class="hljs-keyword">if</span> (trailing &amp;&amp; !timer) &#123;</span><span class="language-javascript">              timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">                fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">                timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">                startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</span><span class="language-javascript">              &#125;, waitTime);</span><span class="language-javascript">            &#125;</span><span class="language-javascript">          &#125; <span class="hljs-keyword">catch</span> (error) &#123;</span><span class="language-javascript">            <span class="hljs-title function_">reject</span>(error);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消函数</span></span><span class="language-javascript">        _throttle.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">          startTime = <span class="hljs-number">0</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _throttle;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">myThrottle</span>(</span><span class="language-javascript">        <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;-----&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">1000</span>,</span><span class="language-javascript">        &#123; <span class="hljs-attr">trailing</span>: <span class="hljs-literal">true</span> &#125;</span><span class="language-javascript">      );</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>防抖函数的实现</title>
    <link href="/2022/09/07/%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/07/%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="节流函数的基本实现"><a href="#节流函数的基本实现" class="headerlink" title="节流函数的基本实现"></a>节流函数的基本实现</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params">fn, delay</span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 记录上一次的timer</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 返回需要执行的函数</span></span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript"></span><span class="language-javascript">          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">            <span class="hljs-title function_">fn</span>();</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span><span class="language-javascript">          &#125;, delay);</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">mydebounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-string">&quot;----------&quot;</span>);</span><span class="language-javascript">      &#125;, <span class="hljs-number">1000</span>);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="this的绑定和参数传递"><a href="#this的绑定和参数传递" class="headerlink" title="this的绑定和参数传递"></a>this的绑定和参数传递</h4><div class="code-wrapper"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params">fn, delay</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 记录上一次的timer</span></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 返回需要执行的函数</span></span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span></span><span class="language-javascript"><span class="language-xml">            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span></span><span class="language-javascript"><span class="language-xml">          &#125;, delay);</span></span><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">      inputEl.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">mydebounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;----------&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">      &#125;, <span class="hljs-number">1000</span>);</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><h4 id="取消功能的实现"><a href="#取消功能的实现" class="headerlink" title="取消功能的实现"></a>取消功能的实现</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params">fn, delay</span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 记录上一次的timer</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 返回需要执行的函数</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript"></span><span class="language-javascript">          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span><span class="language-javascript">          &#125;, delay);</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消功能</span></span><span class="language-javascript">        _debounce.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _debounce;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> buttonEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> debounce = <span class="hljs-title function_">mydebounce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;----------&quot;</span>);</span><span class="language-javascript">      &#125;, <span class="hljs-number">3000</span>);</span><span class="language-javascript"></span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = debounce;</span><span class="language-javascript"></span><span class="language-javascript">      buttonEl.<span class="hljs-property">onclick</span> = debounce.<span class="hljs-property">cancel</span>;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="实现立即执行功能"><a href="#实现立即执行功能" class="headerlink" title="实现立即执行功能"></a>实现立即执行功能</h4><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params">fn, delay, immediate = <span class="hljs-literal">false</span></span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 记录上一次的timer</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 记录是否需要第一次是否执行和immediate配合</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> isInvoke = <span class="hljs-literal">false</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 返回需要执行的函数</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          <span class="hljs-comment">// 当immediate为true时</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (immediate &amp;&amp; !isInvoke) &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            isInvoke = <span class="hljs-literal">true</span>;</span><span class="language-javascript">            <span class="hljs-keyword">return</span>;</span><span class="language-javascript">          &#125;</span><span class="language-javascript"></span><span class="language-javascript">          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">            fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span><span class="language-javascript">            isInvoke = <span class="hljs-literal">false</span>; <span class="hljs-comment">//重置</span></span><span class="language-javascript">          &#125;, delay);</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消功能</span></span><span class="language-javascript">        _debounce.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _debounce;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> buttonEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> debounce = <span class="hljs-title function_">mydebounce</span>(</span><span class="language-javascript">        <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;----------&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">3000</span>,</span><span class="language-javascript">        <span class="hljs-literal">true</span></span><span class="language-javascript">      );</span><span class="language-javascript"></span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = debounce;</span><span class="language-javascript"></span><span class="language-javascript">      buttonEl.<span class="hljs-property">onclick</span> = debounce.<span class="hljs-property">cancel</span>;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="获取返回值的实现"><a href="#获取返回值的实现" class="headerlink" title="获取返回值的实现"></a>获取返回值的实现</h4><p>获取返回值的方式有两种</p><p>传入回调函数</p><p>通过promise.then来获取</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mydebounce</span>(<span class="hljs-params"></span></span><span class="hljs-params"><span class="language-javascript">        fn,</span></span><span class="hljs-params"><span class="language-javascript">        delay,</span></span><span class="hljs-params"><span class="language-javascript">        immediate = <span class="hljs-literal">false</span>,</span></span><span class="hljs-params"><span class="language-javascript">        resultCallback = () =&gt; &#123;&#125;</span></span><span class="hljs-params"><span class="language-javascript">      </span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 记录上一次的timer</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 记录是否需要第一次是否执行和immediate配合</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> isInvoke = <span class="hljs-literal">false</span>;</span><span class="language-javascript">        <span class="hljs-comment">// 返回需要执行的函数</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">            <span class="hljs-keyword">try</span> &#123;</span><span class="language-javascript">              <span class="hljs-comment">//频繁触发执行都会先清除上一次的timer</span></span><span class="language-javascript">              <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">              <span class="hljs-comment">// 当immediate为true时</span></span><span class="language-javascript">              <span class="hljs-keyword">if</span> (immediate &amp;&amp; !isInvoke) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">const</span> result = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">                <span class="hljs-title function_">resultCallback</span>(result);</span><span class="language-javascript">                <span class="hljs-title function_">resolve</span>(result);</span><span class="language-javascript">                isInvoke = <span class="hljs-literal">true</span>;</span><span class="language-javascript">                <span class="hljs-keyword">return</span>;</span><span class="language-javascript">              &#125;</span><span class="language-javascript"></span><span class="language-javascript">              timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">                <span class="hljs-keyword">const</span> result = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);</span><span class="language-javascript">                <span class="hljs-title function_">resultCallback</span>(result);</span><span class="language-javascript">                <span class="hljs-title function_">resolve</span>(result);</span><span class="language-javascript">                timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 执行过函数之后, 将timer重新置null</span></span><span class="language-javascript">                isInvoke = <span class="hljs-literal">false</span>; <span class="hljs-comment">//重置</span></span><span class="language-javascript">              &#125;, delay);</span><span class="language-javascript">            &#125; <span class="hljs-keyword">catch</span> (error) &#123;</span><span class="language-javascript">              <span class="hljs-title function_">reject</span>(error);</span><span class="language-javascript">            &#125;</span><span class="language-javascript">          &#125;);</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 取消功能</span></span><span class="language-javascript">        _debounce.<span class="hljs-property">cancel</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">          timer = <span class="hljs-literal">null</span>;</span><span class="language-javascript">          isInvoke = <span class="hljs-literal">false</span>;</span><span class="language-javascript">        &#125;;</span><span class="language-javascript">        <span class="hljs-keyword">return</span> _debounce;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">const</span> inputEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;input&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> buttonEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);</span><span class="language-javascript">      <span class="hljs-keyword">const</span> debounce = <span class="hljs-title function_">mydebounce</span>(</span><span class="language-javascript">        <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e, <span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;----------&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-number">3000</span>,</span><span class="language-javascript">        <span class="hljs-literal">true</span></span><span class="language-javascript">      );</span><span class="language-javascript"></span><span class="language-javascript">      inputEl.<span class="hljs-property">oninput</span> = debounce;</span><span class="language-javascript"></span><span class="language-javascript">      buttonEl.<span class="hljs-property">onclick</span> = debounce.<span class="hljs-property">cancel</span>;</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>节流防抖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义事件总线</title>
    <link href="/2022/09/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <url>/2022/09/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-btn&quot;</span>&gt;</span>nav button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 类EventBus -&gt; 事件总线对象</span></span><span class="language-javascript">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">HYEventBus</span> &#123;</span><span class="language-javascript">      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span> = &#123;&#125;</span><span class="language-javascript">      &#125;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-title function_">on</span>(<span class="hljs-params">eventName, eventFn</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]</span><span class="language-javascript">        <span class="hljs-keyword">if</span> (!eventFns) &#123;</span><span class="language-javascript">          eventFns = []</span><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName] = eventFns</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        eventFns.<span class="hljs-title function_">push</span>(eventFn)</span><span class="language-javascript">      &#125;</span><span class="language-javascript">      </span><span class="language-javascript">      <span class="hljs-title function_">off</span>(<span class="hljs-params">eventName, eventFn</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]</span><span class="language-javascript">        <span class="hljs-keyword">if</span> (!eventFns) <span class="hljs-keyword">return</span></span><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; eventFns.<span class="hljs-property">length</span>; i++) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">const</span> fn = eventFns[i]</span><span class="language-javascript">          <span class="hljs-keyword">if</span> (fn === eventFn) &#123;</span><span class="language-javascript">            eventFns.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>)</span><span class="language-javascript">            <span class="hljs-keyword">break</span></span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-comment">// 如果eventFns已经清空了</span></span><span class="language-javascript">        <span class="hljs-keyword">if</span> (eventFns.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]</span><span class="language-javascript">        &#125;</span><span class="language-javascript">      &#125;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-title function_">emit</span>(<span class="hljs-params">eventName, ...args</span>) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">let</span> eventFns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventMap</span>[eventName]</span><span class="language-javascript">        <span class="hljs-keyword">if</span> (!eventFns) <span class="hljs-keyword">return</span></span><span class="language-javascript">        eventFns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;</span><span class="language-javascript">          <span class="hljs-title function_">fn</span>(...args)</span><span class="language-javascript">        &#125;)</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 使用过程</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HYEventBus</span>()</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// aside.vue组件中监听事件</span></span><span class="language-javascript">    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;navclick&quot;</span>, <span class="hljs-function">(<span class="hljs-params">name, age, height</span>) =&gt;</span> &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;navclick listener 01&quot;</span>, name, age, height)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">click</span> =  (<span class="hljs-params"></span>) =&gt; &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;navclick listener 02&quot;</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;navclick&quot;</span>, click)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">      eventBus.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;navclick&quot;</span>, click)</span><span class="language-javascript">    &#125;, <span class="hljs-number">5000</span>);</span><span class="language-javascript"></span><span class="language-javascript">    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;asideclick&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;asideclick listener&quot;</span>)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// nav.vue</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> navBtnEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.nav-btn&quot;</span>)</span><span class="language-javascript">    navBtnEl.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;自己监听到&quot;</span>)</span><span class="language-javascript">      eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;navclick&quot;</span>, <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>响应式原理的实现</title>
    <link href="/2022/09/05/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/05/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是响应式"><a href="#什么是响应式" class="headerlink" title="什么是响应式"></a>什么是响应式</h4><p>响应式就是当对象中的属性发生更改的时候，依赖该属性的函数也会重新执行</p><h4 id="封装一个响应式的函数"><a href="#封装一个响应式的函数" class="headerlink" title="封装一个响应式的函数"></a>封装一个响应式的函数</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个容器来收集依赖</span><span class="hljs-keyword">const</span> reactiveFns = [];<span class="hljs-comment">// 定义一个收集依赖的函数</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">watchFn</span> = (<span class="hljs-params">fn</span>) =&gt; &#123;  reactiveFns.<span class="hljs-title function_">push</span>(fn);&#125;;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = obj.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;普通的其他函数&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这个函数不需要有任何响应式&quot;</span>);&#125;obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;<span class="hljs-comment">// 当数据变化的时候，执行对应的函数</span>reactiveFns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;  <span class="hljs-title function_">fn</span>();&#125;);</code></pre></div><h4 id="依赖收集类的封装"><a href="#依赖收集类的封装" class="headerlink" title="依赖收集类的封装"></a>依赖收集类的封装</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = [];  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn);  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-title function_">fn</span>();    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  depend.<span class="hljs-title function_">addDepend</span>(fn);&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = obj.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;depend.<span class="hljs-title function_">notify</span>();</code></pre></div><h4 id="自动监听对象的变化"><a href="#自动监听对象的变化" class="headerlink" title="自动监听对象的变化"></a>自动监听对象的变化</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = [];  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn);  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-title function_">fn</span>();    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  depend.<span class="hljs-title function_">addDepend</span>(fn);&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);  &#125;,  <span class="hljs-comment">// receiver就是objProxy</span>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);  &#125;,&#125;);<span class="hljs-comment">// 使用对象代理的方式去操作对象，不要直接操作对象</span><span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = objProxy.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;depend.<span class="hljs-title function_">notify</span>();</code></pre></div><h4 id="依赖收集的管理"><a href="#依赖收集的管理" class="headerlink" title="依赖收集的管理"></a>依赖收集的管理</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = [];  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">addDepend</span>(<span class="hljs-params">fn</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">push</span>(fn);  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (fn) &#123;        <span class="hljs-title function_">fn</span>();      &#125;    &#125;);  &#125;&#125;<span class="hljs-comment">// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集</span><span class="hljs-keyword">let</span> activeReactiveFn = <span class="hljs-literal">null</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  activeReactiveFn = fn;  <span class="hljs-comment">// 先执行一次触发get进行依赖收集</span>  <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 将置为null</span>  activeReactiveFn = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">//使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-comment">// 根据target对象获取map的过程</span>  <span class="hljs-keyword">let</span> map = targetMap.<span class="hljs-title function_">get</span>(target); <span class="hljs-comment">//获取对应的对象的映射</span>  <span class="hljs-keyword">if</span> (!map) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    targetMap.<span class="hljs-title function_">set</span>(target, map);  &#125;  <span class="hljs-keyword">let</span> depend = map.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!depend) &#123;    depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();    map.<span class="hljs-title function_">set</span>(key, depend);  &#125;  <span class="hljs-keyword">return</span> depend;&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;  <span class="hljs-comment">// receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(receiver === objProxy)<span class="hljs-comment">//true</span>    <span class="hljs-comment">// 在get中获取对应的depend</span>    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);    <span class="hljs-comment">// 给depend添加响应函数</span>    depend.<span class="hljs-title function_">addDepend</span>(activeReactiveFn);    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);  &#125;,  <span class="hljs-comment">// receiver就是objProxy</span>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);    depend.<span class="hljs-title function_">notify</span>();  &#125;,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = objProxy.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age 发生变化是需要执行的----1&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age 发生变化是需要执行的----2&quot;</span>);&#125;);objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;james&quot;</span>;objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;curry&quot;</span>;objProxy.<span class="hljs-property">age</span> = <span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> info = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>,&#125;;<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">address</span>, <span class="hljs-string">&quot;监听address变化+++++++++1&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">address</span>, <span class="hljs-string">&quot;监听address变化+++++++++2&quot;</span>);&#125;);</code></pre></div><h4 id="重构Depend"><a href="#重构Depend" class="headerlink" title="重构Depend"></a>重构Depend</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集</span><span class="hljs-keyword">let</span> activeReactiveFn = <span class="hljs-literal">null</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Depend优化:</span><span class="hljs-comment">   *  1&gt; depend方法</span><span class="hljs-comment">   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (activeReactiveFn) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(activeReactiveFn);    &#125;  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (fn) &#123;        <span class="hljs-title function_">fn</span>();      &#125;    &#125;);  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  activeReactiveFn = fn;  <span class="hljs-comment">// 先执行一次触发get进行依赖收集</span>  <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 将置为null</span>  activeReactiveFn = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">//使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-comment">// 根据target对象获取map的过程</span>  <span class="hljs-keyword">let</span> map = targetMap.<span class="hljs-title function_">get</span>(target); <span class="hljs-comment">//获取对应的对象的映射</span>  <span class="hljs-keyword">if</span> (!map) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    targetMap.<span class="hljs-title function_">set</span>(target, map);  &#125;  <span class="hljs-keyword">let</span> depend = map.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!depend) &#123;    depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();    map.<span class="hljs-title function_">set</span>(key, depend);  &#125;  <span class="hljs-keyword">return</span> depend;&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">const</span> objProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;  <span class="hljs-comment">// receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;    <span class="hljs-comment">// 在get中获取对应的depend</span>    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);    <span class="hljs-comment">// 给depend添加响应函数</span>    depend.<span class="hljs-title function_">depend</span>();    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);  &#125;,  <span class="hljs-comment">// receiver就是objProxy</span>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);    <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);    depend.<span class="hljs-title function_">notify</span>();  &#125;,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> newName = objProxy.<span class="hljs-property">name</span>;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好啊, 李银河&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 100行</span>&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">name</span>, <span class="hljs-string">&quot;demo function -------&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age 发生变化是需要执行的----1&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objProxy.<span class="hljs-property">age</span>, <span class="hljs-string">&quot;age 发生变化是需要执行的----2&quot;</span>);&#125;);objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>;objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;james&quot;</span>;objProxy.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;curry&quot;</span>;objProxy.<span class="hljs-property">age</span> = <span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> info = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>,&#125;;<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">address</span>, <span class="hljs-string">&quot;监听address变化+++++++++1&quot;</span>);&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info.<span class="hljs-property">address</span>, <span class="hljs-string">&quot;监听address变化+++++++++2&quot;</span>);&#125;);</code></pre></div><h4 id="vue3对象的响应式操作"><a href="#vue3对象的响应式操作" class="headerlink" title="vue3对象的响应式操作"></a>vue3对象的响应式操作</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集</span><span class="hljs-keyword">let</span> activeReactiveFn = <span class="hljs-literal">null</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Depend优化:</span><span class="hljs-comment">   *  1&gt; depend方法</span><span class="hljs-comment">   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (activeReactiveFn) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(activeReactiveFn);    &#125;  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (fn) &#123;        <span class="hljs-title function_">fn</span>();      &#125;    &#125;);  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  activeReactiveFn = fn;  <span class="hljs-comment">// 先执行一次触发get进行依赖收集</span>  <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 将置为null</span>  activeReactiveFn = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">//使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-comment">// 根据target对象获取map的过程</span>  <span class="hljs-keyword">let</span> map = targetMap.<span class="hljs-title function_">get</span>(target); <span class="hljs-comment">//获取对应的对象的映射</span>  <span class="hljs-keyword">if</span> (!map) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    targetMap.<span class="hljs-title function_">set</span>(target, map);  &#125;  <span class="hljs-keyword">let</span> depend = map.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!depend) &#123;    depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();    map.<span class="hljs-title function_">set</span>(key, depend);  &#125;  <span class="hljs-keyword">return</span> depend;&#125;<span class="hljs-comment">// 对象的响应式</span><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;    <span class="hljs-comment">// receiver 表示当前的proxy,将receiver传入表示当前proxy,在对对象直接操作的时候可以同样对其进行监听get/set进行以下操作</span>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;      <span class="hljs-comment">// 在get中获取对应的depend</span>      <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);      <span class="hljs-comment">// 给depend添加响应函数</span>      depend.<span class="hljs-title function_">depend</span>();      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);    &#125;,    <span class="hljs-comment">// receiver就是objProxy</span>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;      <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver);      <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(target, key);      depend.<span class="hljs-title function_">notify</span>();    &#125;,  &#125;);&#125;<span class="hljs-keyword">const</span> objProxy = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-comment">// depend对象</span>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-comment">// depend对象</span>&#125;);<span class="hljs-keyword">const</span> infoProxy = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>,  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoProxy.<span class="hljs-property">address</span>);&#125;);infoProxy.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;北京市&quot;</span>;<span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">name</span>);&#125;);foo.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;bar&quot;</span>;</code></pre></div><h4 id="vue2对象的响应式操作"><a href="#vue2对象的响应式操作" class="headerlink" title="vue2对象的响应式操作"></a>vue2对象的响应式操作</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 目的是将fn先存起来在get中使用，就是在get中进行依赖收集</span><span class="hljs-keyword">let</span> activeReactiveFn = <span class="hljs-literal">null</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Depend</span> &#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Depend优化:</span><span class="hljs-comment">   *  1&gt; depend方法</span><span class="hljs-comment">   *  2&gt; 使用Set来保存依赖函数, 而不是数组[]</span><span class="hljs-comment">   */</span>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 依赖收集容器</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();  &#125;  <span class="hljs-comment">// 依赖收集的方法</span>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">if</span> (activeReactiveFn) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">add</span>(activeReactiveFn);    &#125;  &#125;  <span class="hljs-comment">// 更新方法</span>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reactiveFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (fn) &#123;        <span class="hljs-title function_">fn</span>();      &#125;    &#125;);  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">watchFn</span>(<span class="hljs-params">fn</span>) &#123;  activeReactiveFn = fn;  <span class="hljs-comment">// 先执行一次触发get进行依赖收集</span>  <span class="hljs-title function_">fn</span>();  <span class="hljs-comment">// 将置为null</span>  activeReactiveFn = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 封装一个depend函数，对对象中的每一个属性进行依赖收集管理</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>(); <span class="hljs-comment">//使用WeakMap可以让没有被引用了的对象被垃圾回收及时回收掉，因为weakMap是弱引用，可以被垃圾回收器回收</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDepend</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-comment">// 根据target对象获取map的过程</span>  <span class="hljs-keyword">let</span> map = targetMap.<span class="hljs-title function_">get</span>(target); <span class="hljs-comment">//获取对应的对象的映射</span>  <span class="hljs-keyword">if</span> (!map) &#123;    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    targetMap.<span class="hljs-title function_">set</span>(target, map);  &#125;  <span class="hljs-keyword">let</span> depend = map.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!depend) &#123;    depend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Depend</span>();    map.<span class="hljs-title function_">set</span>(key, depend);  &#125;  <span class="hljs-keyword">return</span> depend;&#125;<span class="hljs-comment">// 自动监听对象中属性的变化vue2-&gt;Object.defineProperty,vue3-&gt;Proxy</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> value = obj[key];    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(obj, key);        depend.<span class="hljs-title function_">depend</span>();        <span class="hljs-keyword">return</span> value;      &#125;,      <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;        value = newValue;        <span class="hljs-keyword">const</span> depend = <span class="hljs-title function_">getDepend</span>(obj, key);        depend.<span class="hljs-title function_">notify</span>();      &#125;,    &#125;);  &#125;);  <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-keyword">const</span> infoProxy = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>,  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoProxy.<span class="hljs-property">address</span>);&#125;);infoProxy.<span class="hljs-property">address</span> = <span class="hljs-string">&quot;北京市&quot;</span>;<span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;foo&quot;</span>,&#125;);<span class="hljs-title function_">watchFn</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">name</span>);&#125;);foo.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;bar&quot;</span>;foo.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;hhh&quot;</span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>搜集</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组转换成树形解构</title>
    <link href="/2022/09/05/%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A0%91%E5%BD%A2%E8%A7%A3%E6%9E%84/"/>
    <url>/2022/09/05/%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A0%91%E5%BD%A2%E8%A7%A3%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现自动柯里化函数</title>
    <link href="/2022/09/05/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    <url>/2022/09/05/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝的实现方式</title>
    <link href="/2022/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/09/05/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否是对象</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">const</span> valueType = <span class="hljs-keyword">typeof</span> value;  <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> &amp;&amp; (valueType === <span class="hljs-string">&quot;object&quot;</span> || valueType === <span class="hljs-string">&quot;function&quot;</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">originValue</span>) &#123;   <span class="hljs-comment">// 数据类型是symbol</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(originValue.<span class="hljs-property">description</span>);  &#125;  <span class="hljs-comment">// 原始数据类型直接返回</span>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(originValue)) &#123;    <span class="hljs-keyword">return</span> originValue;  &#125;  <span class="hljs-comment">// 判断是否是function</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">return</span> originValue;  &#125;  <span class="hljs-comment">// 判断是否是set类型</span>  <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;    <span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> originValue) &#123;      newSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepClone</span>(item));    &#125;    <span class="hljs-keyword">return</span> newSet;  &#125;  <span class="hljs-comment">// 判断是否是Map类型</span>  <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;    <span class="hljs-keyword">const</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> originValue) &#123;      newMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">deepClone</span>(value));    &#125;  &#125;  <span class="hljs-comment">// 判断是否是Array</span>  <span class="hljs-keyword">const</span> newOBj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(originValue) ? [] : &#123;&#125;;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> originValue) &#123;    newOBj[key] = <span class="hljs-title function_">deepClone</span>(originValue[key]);  &#125;  <span class="hljs-comment">// 单独遍历Symbol</span>  <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(originValue);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> symbolKey <span class="hljs-keyword">of</span> symbolKeys) &#123;    newOBj[<span class="hljs-title class_">Symbol</span>(symbolKey.<span class="hljs-property">description</span>)] = <span class="hljs-title function_">deepClone</span>(originValue[symbolKey]);  &#125;  <span class="hljs-keyword">return</span> newOBj;&#125;</code></pre></div><h4 id="当拷贝的对象中出现循环引用时"><a href="#当拷贝的对象中出现循环引用时" class="headerlink" title="当拷贝的对象中出现循环引用时"></a>当拷贝的对象中出现循环引用时</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否是对象</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">value</span>) &#123;  <span class="hljs-keyword">const</span> valueType = <span class="hljs-keyword">typeof</span> value;  <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span> &amp;&amp; (valueType === <span class="hljs-string">&quot;object&quot;</span> || valueType === <span class="hljs-string">&quot;function&quot;</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">originValue, map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;  <span class="hljs-comment">// 数据类型是symbol</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;symbol&quot;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>(originValue.<span class="hljs-property">description</span>);  &#125;  <span class="hljs-comment">// 原始数据类型直接返回</span>  <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(originValue)) &#123;    <span class="hljs-keyword">return</span> originValue;  &#125;  <span class="hljs-comment">// 判断是否是function</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> originValue === <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">return</span> originValue;  &#125;  <span class="hljs-comment">// 判断是否是set类型</span>  <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Set</span>) &#123;    <span class="hljs-keyword">const</span> newSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> originValue) &#123;      newSet.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">deepClone</span>(item));    &#125;    <span class="hljs-keyword">return</span> newSet;  &#125;  <span class="hljs-comment">// 判断是否是Map类型</span>  <span class="hljs-keyword">if</span> (originValue <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Map</span>) &#123;    <span class="hljs-keyword">const</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> originValue) &#123;      newMap.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">deepClone</span>(value));    &#125;  &#125;  <span class="hljs-comment">// 如果有循环引用的对象，return</span>  <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(originValue)) &#123;    <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(originValue);  &#125;  <span class="hljs-comment">// 判断是否是Array</span>  <span class="hljs-keyword">const</span> newOBj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(originValue) ? [] : &#123;&#125;;  map.<span class="hljs-title function_">set</span>(originValue, newOBj);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> originValue) &#123;    newOBj[key] = <span class="hljs-title function_">deepClone</span>(originValue[key], map);  &#125;  <span class="hljs-comment">// 以symbol作为key</span>  <span class="hljs-keyword">const</span> symbolKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(originValue);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> symbolKey <span class="hljs-keyword">of</span> symbolKeys) &#123;    newOBj[<span class="hljs-title class_">Symbol</span>(symbolKey.<span class="hljs-property">description</span>)] = <span class="hljs-title function_">deepClone</span>(      originValue[symbolKey],      map    );  &#125;  <span class="hljs-keyword">return</span> newOBj;&#125;<span class="hljs-comment">// const info = &#123;</span><span class="hljs-comment">//   name: &quot;why&quot;,</span><span class="hljs-comment">//   age: 18,</span><span class="hljs-comment">//   friend: &#123;</span><span class="hljs-comment">//     name: &quot;kobe&quot;,</span><span class="hljs-comment">//     address: &#123;</span><span class="hljs-comment">//       name: &quot;洛杉矶&quot;,</span><span class="hljs-comment">//       detail: &quot;斯坦普斯中心&quot;,</span><span class="hljs-comment">//     &#125;,</span><span class="hljs-comment">//   &#125;,</span><span class="hljs-comment">//   // self: info</span><span class="hljs-comment">// &#125;;</span><span class="hljs-comment">// info.self = info;</span><span class="hljs-comment">// let newObj = deepClone(info);</span><span class="hljs-comment">// console.log(newObj);</span><span class="hljs-comment">// console.log(newObj.self === newObj);</span><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;cba&quot;</span>, <span class="hljs-string">&quot;nba&quot;</span>]);<span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;s1&quot;</span>);<span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;s2&quot;</span>);<span class="hljs-keyword">const</span> info1 = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,  <span class="hljs-attr">friend</span>: &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>,    <span class="hljs-attr">address</span>: &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;洛杉矶&quot;</span>,      <span class="hljs-attr">detail</span>: <span class="hljs-string">&quot;斯坦普斯中心&quot;</span>,    &#125;,  &#125;,  <span class="hljs-comment">// 1.特殊类型: Set</span>  <span class="hljs-attr">set</span>: set,  <span class="hljs-comment">// 2.特性类型: function</span>  <span class="hljs-attr">running</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;running~&quot;</span>);  &#125;,  <span class="hljs-comment">// 3.值的特殊类型: Symbol</span>  <span class="hljs-attr">symbolKey</span>: <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;abc&quot;</span>),  <span class="hljs-comment">// 4.key是symbol时</span>  [s1]: <span class="hljs-string">&quot;aaaa&quot;</span>,  [s2]: <span class="hljs-string">&quot;bbbb&quot;</span>,&#125;;info1.<span class="hljs-property">self</span> = info1;<span class="hljs-keyword">const</span> newObj1 = <span class="hljs-title function_">deepClone</span>(info1);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj1);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise的实现</title>
    <link href="/2022/09/05/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/09/05/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve被调用&quot;</span>);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject被调用&quot;</span>);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;padding&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);  <span class="hljs-title function_">reject</span>(<span class="hljs-number">222</span>);&#125;);</code></pre></div><h4 id="then方法的结构设计"><a href="#then方法的结构设计" class="headerlink" title="then方法的结构设计"></a>then方法的结构设计</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilled</span> = onFulfilled;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejected</span> = onRejected;  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;padding&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);  <span class="hljs-title function_">reject</span>(<span class="hljs-number">222</span>);&#125;);<span class="hljs-comment">// 此时不可以进行链式调用，否则会报错</span>promise.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-number">1111</span>;  &#125;,  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;);</code></pre></div><h4 id="then方法的结构设计-优化"><a href="#then方法的结构设计-优化" class="headerlink" title="then方法的结构设计-优化"></a>then方法的结构设计-优化</h4><h5 id="解决then在状态确定之后调用的问题"><a href="#解决then在状态确定之后调用的问题" class="headerlink" title="解决then在状态确定之后调用的问题"></a>解决then在状态确定之后调用的问题</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">//当调用then的时候，状态已经确定</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;      <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;      <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);    &#125;    <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(onFulfilled);      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(onRejected);    &#125;  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;padding&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);  <span class="hljs-title function_">reject</span>(<span class="hljs-number">222</span>);&#125;);<span class="hljs-comment">// 调用then方法多次调用</span>promise.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res);  &#125;,  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;);promise.<span class="hljs-title function_">then</span>(  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res2:&quot;</span>, res);  &#125;,  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err2:&quot;</span>, err);  &#125;);<span class="hljs-comment">// const promise = new Promise((resolve, reject) =&gt; &#123;</span><span class="hljs-comment">//   resolve(&quot;aaaaa&quot;)</span><span class="hljs-comment">// &#125;)</span><span class="hljs-comment">// 在确定Promise状态之后, 再次调用then</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  promise.<span class="hljs-title function_">then</span>(    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res3:&quot;</span>, res);    &#125;,    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err3:&quot;</span>, err);    &#125;  );&#125;, <span class="hljs-number">1000</span>);</code></pre></div><h4 id="then方法的结构设计-优化二"><a href="#then方法的结构设计-优化二" class="headerlink" title="then方法的结构设计-优化二"></a>then方法的结构设计-优化二</h4><h5 id="解决then方法链式调用"><a href="#解决then方法链式调用" class="headerlink" title="解决then方法链式调用"></a>解决then方法链式调用</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject&quot;</span>);          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-comment">// try &#123;</span>        <span class="hljs-comment">//   const value = onFulfilled(this.value);</span>        <span class="hljs-comment">//   resolve(value);</span>        <span class="hljs-comment">// &#125; catch (error) &#123;</span>        <span class="hljs-comment">//   reject(error);</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-comment">// try &#123;</span>        <span class="hljs-comment">//   const reason = onRejected(this.reason);</span>        <span class="hljs-comment">//   resolve(reason);</span>        <span class="hljs-comment">// &#125; catch (error) &#123;</span>        <span class="hljs-comment">//   reject(error);</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// try &#123;</span>          <span class="hljs-comment">//   const value = onFulfilled(this.value);</span>          <span class="hljs-comment">//   resolve(value);</span>          <span class="hljs-comment">// &#125; catch (error) &#123;</span>          <span class="hljs-comment">//   reject(error);</span>          <span class="hljs-comment">// &#125;</span>          <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);        &#125;);        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// try &#123;</span>          <span class="hljs-comment">//   const reason = onRejected(this.reason);</span>          <span class="hljs-comment">//   resolve(reason);</span>          <span class="hljs-comment">// &#125; catch (error) &#123;</span>          <span class="hljs-comment">//   reject(error);</span>          <span class="hljs-comment">// &#125;</span>          <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);        &#125;);      &#125;    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;padding&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);  <span class="hljs-title function_">reject</span>(<span class="hljs-number">222</span>);&#125;);<span class="hljs-comment">// 调用then方法多次调用</span>promise  .<span class="hljs-title function_">then</span>(    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res);      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;aaaa&quot;</span>;      <span class="hljs-comment">// throw new Error(&quot;err message&quot;)</span>    &#125;,    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err1:&quot;</span>, err);      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bbbbb&quot;</span>;      <span class="hljs-comment">// throw new Error(&quot;err message&quot;)</span>    &#125;  )  .<span class="hljs-title function_">then</span>(    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res2:&quot;</span>, res);    &#125;,    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err2:&quot;</span>, err);    &#125;  );</code></pre></div><h4 id="catch的设计方法"><a href="#catch的设计方法" class="headerlink" title="catch的设计方法"></a>catch的设计方法</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    onRejected = onRejected || defaultOnRejected;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;状态pending&quot;</span>);  <span class="hljs-comment">// resolve(1111) // resolved/fulfilled</span>  <span class="hljs-title function_">reject</span>(<span class="hljs-number">2222</span>);&#125;);<span class="hljs-comment">// 调用then方法多次调用</span>promise  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;);</code></pre></div><h4 id="finally方法的设计"><a href="#finally方法的设计" class="headerlink" title="finally方法的设计"></a>finally方法的设计</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnFulfilled</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-keyword">return</span> value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onfinally</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;,      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;    );  &#125;&#125;<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;状态pending&quot;</span>);  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1111</span>); <span class="hljs-comment">// resolved/fulfilled</span>  <span class="hljs-comment">// reject(2222);</span>&#125;);<span class="hljs-comment">// 调用then方法多次调用</span>promise  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res1:&quot;</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;aaaaa&quot;</span>;  &#125;)  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res2:&quot;</span>, res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;)  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;finally&quot;</span>);  &#125;);</code></pre></div><h4 id="promise的类方法resolve-reject"><a href="#promise的类方法resolve-reject" class="headerlink" title="promise的类方法resolve/reject"></a>promise的类方法resolve/reject</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnFulfilled</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-keyword">return</span> value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onfinally</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;,      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;    );  &#125;  <span class="hljs-comment">// 就是将value转成fulfilled状态可以进行then调用</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);    &#125;);  &#125;  <span class="hljs-comment">// 将reason装成rejected状态</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason);    &#125;);  &#125;&#125;myPromise.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Hello World&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);&#125;);myPromise.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error Message&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);&#125;);</code></pre></div><h4 id="promise的类方法all-allSettled"><a href="#promise的类方法all-allSettled" class="headerlink" title="promise的类方法all/allSettled"></a>promise的类方法all/allSettled</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnFulfilled</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-keyword">return</span> value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onfinally</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;,      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;    );  &#125;  <span class="hljs-comment">// 就是将value转成fulfilled状态可以进行then调用</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);    &#125;);  &#125;  <span class="hljs-comment">// 将reason装成rejected状态</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason);    &#125;);  &#125;  <span class="hljs-comment">// all传入一个promise数组，如果promise item状态都是fulfulled，all才是fuldilled状态，否则只要出现了reject就会变成renject</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> values = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(res);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            <span class="hljs-title function_">reject</span>(err);          &#125;        );      &#125;);    &#125;);  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">allSettled</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> values = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(&#123;              <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>,              <span class="hljs-attr">value</span>: res,            &#125;);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>, <span class="hljs-attr">value</span>: err &#125;);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;        );      &#125;);    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1111</span>);  &#125;, <span class="hljs-number">1000</span>);&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2222</span>);  &#125;, <span class="hljs-number">2000</span>);&#125;);<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3333</span>);  &#125;, <span class="hljs-number">3000</span>);&#125;);myPromise  .<span class="hljs-title function_">all</span>([p1, p2, p3])  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);  &#125;);myPromise.<span class="hljs-title function_">allSettled</span>([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);&#125;);</code></pre></div><h4 id="promise类方法-any-race"><a href="#promise类方法-any-race" class="headerlink" title="promise类方法-any/race"></a>promise类方法-any/race</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义promise的三种状态</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 工具函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">execFunctionWithCatchError</span>(<span class="hljs-params">execFn, value, resolve, reject</span>) &#123;  <span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">execFn</span>(value);    <span class="hljs-title function_">resolve</span>(result);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-title function_">reject</span>(error);  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">myPromise</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;    <span class="hljs-comment">// 状态初始化</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>;    <span class="hljs-comment">// 定义resolve，reject的参数</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span> = [];    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-comment">// 只有状态是padding的时候才可以进行改变，否则将不会有输出</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-comment">// 将回调函数加入到微任务队列中，等调用then获取到onFulfilled函数的时候再调用执行</span>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> !== <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) <span class="hljs-keyword">return</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> &#123;            <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);          &#125;);        &#125;);      &#125;    &#125;;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-title function_">executor</span>(resolve, reject);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      <span class="hljs-title function_">reject</span>(error);    &#125;  &#125;  <span class="hljs-comment">// then方法的实现</span>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;    <span class="hljs-comment">// 将error传递下去交给catch处理</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnRejected</span> = (<span class="hljs-params">err</span>) =&gt; &#123;      <span class="hljs-keyword">throw</span> err;    &#125;;    <span class="hljs-keyword">const</span> <span class="hljs-title function_">defaultOnFulfilled</span> = (<span class="hljs-params">value</span>) =&gt; &#123;      <span class="hljs-keyword">return</span> value;    &#125;;    onRejected = onRejected || defaultOnRejected;    onFulfilled = onFulfilled || defaultOnFulfilled;    <span class="hljs-comment">// 返回一个promise,就可以进行链式调用了</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//当调用then的时候，状态已经确定</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span> &amp;&amp; onFulfilled) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onFulfilled, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, resolve, reject);      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span> &amp;&amp; onRejected) &#123;        <span class="hljs-title function_">execFunctionWithCatchError</span>(onRejected, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>, resolve, reject);      &#125;      <span class="hljs-comment">// 当状态还没有发生改变的时候,将成功的回调和失败的回调放入数组</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PROMISE_STATUS_PENDING</span>) &#123;        <span class="hljs-keyword">if</span> (onFulfilled) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onFulfilled,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,              resolve,              reject            );          &#125;);        &#125;        <span class="hljs-keyword">if</span> (onRejected) &#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedFns</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-title function_">execFunctionWithCatchError</span>(              onRejected,              <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>,              resolve,              reject            );          &#125;);        &#125;      &#125;    &#125;);  &#125;  <span class="hljs-keyword">catch</span>(onRejected) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>, onRejected);  &#125;  <span class="hljs-title function_">finally</span>(<span class="hljs-params">onfinally</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;,      <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">onfinally</span>();      &#125;    );  &#125;  <span class="hljs-comment">// 就是将value转成fulfilled状态可以进行then调用</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value);    &#125;);  &#125;  <span class="hljs-comment">// 将reason装成rejected状态</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason);    &#125;);  &#125;  <span class="hljs-comment">// all传入一个promise数组，如果promise item状态都是fulfulled，all才是fuldilled状态，否则只要出现了reject就会变成renject</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> values = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(res);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            <span class="hljs-title function_">reject</span>(err);          &#125;        );      &#125;);    &#125;);  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-title function_">allSettled</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> values = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(&#123;              <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">PROMISE_STATUS_FULFILLED</span>,              <span class="hljs-attr">value</span>: res,            &#125;);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            values.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">PROMISE_STATUS_REJECTED</span>, <span class="hljs-attr">value</span>: err &#125;);            <span class="hljs-keyword">if</span> (values.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">resolve</span>(values);            &#125;          &#125;        );      &#125;);    &#125;);  &#125;  <span class="hljs-comment">// 相当于是竞赛，谁的状态先改变就用谁的</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promsies</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      promsies.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(resolve, reject);      &#125;);    &#125;);  &#125;  <span class="hljs-comment">//有一个状态时fulfilled状态就是执行resolve,等所有都变成rejected状态才会是reject  和all相反</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">any</span>(<span class="hljs-params">promises</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">myPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> reasons = [];      promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;        promise.<span class="hljs-title function_">then</span>(          <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;            <span class="hljs-title function_">resolve</span>(res);          &#125;,          <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;            reasons.<span class="hljs-title function_">push</span>(err);            <span class="hljs-keyword">if</span> (reasons.<span class="hljs-property">length</span> === promises.<span class="hljs-property">length</span>) &#123;              <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(reasons));            &#125;          &#125;        );      &#125;);    &#125;);  &#125;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(<span class="hljs-number">1111</span>);  &#125;, <span class="hljs-number">3000</span>);&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2222</span>);  &#125;, <span class="hljs-number">2000</span>);&#125;);<span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">reject</span>(<span class="hljs-number">3333</span>);  &#125;, <span class="hljs-number">3000</span>);&#125;);myPromise  .<span class="hljs-title function_">race</span>([p1, p2, p3])  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err);  &#125;);myPromise  .<span class="hljs-title function_">any</span>([p1, p2, p3])  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res:&quot;</span>, res);  &#125;)  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;err:&quot;</span>, err.<span class="hljs-property">errors</span>);  &#125;);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>搜集</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现bind</title>
    <link href="/2022/09/05/%E5%AE%9E%E7%8E%B0bind/"/>
    <url>/2022/09/05/%E5%AE%9E%E7%8E%B0bind/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">mybind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, ...args</span>) &#123;  <span class="hljs-comment">// 获得this的指向，就是实际的调用者</span>  <span class="hljs-keyword">let</span> fn = <span class="hljs-variable language_">this</span>;  <span class="hljs-comment">// 获取thisArg,如果是基本数据类型除了null,undefined都转成包装类型，否则指向全局</span>  thisArg = thisArg != <span class="hljs-literal">null</span> ? <span class="hljs-title class_">Object</span>(thisArg) : globalThis;  <span class="hljs-comment">// bind会返回一个新的函数</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">newFn</span>(<span class="hljs-params">...argArr</span>) &#123;    <span class="hljs-comment">// 向thisArg对象添加这个方法</span>    thisArg.<span class="hljs-property">fn</span> = fn;    <span class="hljs-comment">// 合并参数</span>    <span class="hljs-keyword">const</span> argTotals = [...args, ...argArr];    <span class="hljs-comment">// 执行函数</span>    <span class="hljs-keyword">const</span> result = thisArg.<span class="hljs-title function_">fn</span>(...argTotals);    <span class="hljs-comment">// 执行完成后删除方法</span>    <span class="hljs-keyword">delete</span> thisArg.<span class="hljs-property">fn</span>;    <span class="hljs-keyword">return</span> result;  &#125;;&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo被执行&quot;</span>, <span class="hljs-variable language_">this</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2, num3, num4</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, num2, num3, num4);&#125;<span class="hljs-comment">// 系统的bind使用</span><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-title function_">bar</span>();<span class="hljs-keyword">var</span> newSum = sum.<span class="hljs-title function_">bind</span>(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>);<span class="hljs-title function_">newSum</span>();<span class="hljs-comment">// 使用自己定义的bind</span><span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">mybind</span>(<span class="hljs-string">&quot;abc&quot;</span>);<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">bar</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<span class="hljs-keyword">var</span> newSum = sum.<span class="hljs-title function_">mybind</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">newSum</span>(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>);</code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-React全家桶</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-React%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-React%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/09-React全家桶实战.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-小程序云开发</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/08-小程序云开发实战.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-小程序开发</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/07-小程序开发实战.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-Vue3全家桶实战</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-Vue3%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E6%88%98/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-Vue3%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/06-Vue3全家桶实战.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-前端工程化基础</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/05-前端工程化基础.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-框架实战</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/04-框架实战.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-JS高级</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E9%AB%98%E7%BA%A7/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/03-JS高级.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-JS基础</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-JS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="pdf/02-JS基础.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端八股文-html-css</title>
    <link href="/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-html-css/"/>
    <url>/2022/09/04/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87-html-css/</url>
    
    <content type="html"><![CDATA[<h1 id="01-HTML-CSS-常⻅⾯试题"><a href="#01-HTML-CSS-常⻅⾯试题" class="headerlink" title="01-HTML-CSS-常⻅⾯试题"></a>01-HTML-CSS-常⻅⾯试题</h1><h2 id="1-HTML-标签有哪些⾏内元素"><a href="#1-HTML-标签有哪些⾏内元素" class="headerlink" title="1.HTML 标签有哪些⾏内元素"></a><strong>1.HTML</strong> <strong>标签有哪些⾏内元素</strong></h2><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-tag">img</span>picture<span class="hljs-selector-tag">span</span><span class="hljs-selector-tag">input</span><span class="hljs-selector-tag">textarea</span>selectlabe</code></pre></div><h2 id="2-说说你对元素语义化的理解"><a href="#2-说说你对元素语义化的理解" class="headerlink" title="2.说说你对元素语义化的理解"></a><strong>2.说说你对元素语义化的理解</strong></h2><p>元素语义化就是⽤正确的元素做正确的事情。虽然在理论上，所以的html元素都可以通过css样式实现</p><p>相同的事情，但是这么做会使事情复杂化，所以我们需要元素语义化来降低复杂度。</p><p>元素语义化在我们实际的开发中有很多好处，⽐如：</p><p>提⾼代码的阅读性和可维护性;</p><p>减少coder之间的沟通成本;</p><p>能让语⾳合成⼯具正确识别⽹⻚元素的⽤途，以便做出正确的反应</p><p>有利于SEO(Search Engine Optimization)</p><h2 id="3-HTML-中有哪些语义化标签"><a href="#3-HTML-中有哪些语义化标签" class="headerlink" title="3.HTML 中有哪些语义化标签"></a><strong>3.HTML</strong> <strong>中有哪些语义化标签</strong></h2><ul><li>header</li><li>footer</li><li>main</li><li>aside</li><li>article</li><li>section</li><li>address</li><li>summary/details</li><li>menu</li><li>h1/h2/h3/h4/h5/h6</li><li>img</li><li>p</li><li>strong/italic</li></ul><h2 id="4-什么是-URL-编码-URL-Encode"><a href="#4-什么是-URL-编码-URL-Encode" class="headerlink" title="4.什么是 URL 编码 (URL Encode)"></a><strong>4.什么是</strong> <strong>URL</strong> <strong>编码</strong> <strong>(URL Encode)</strong></h2><p>encodeURI ⽤来编码<strong>URI</strong>，其不会编码保留字符。</p><p>encodeURIComponent ⽤来编码 URI<strong>参数</strong>，除了字符：A-Z a-z 0-9 - _ . ! ~ * ‘ ( )，都将会转义</p><h2 id="5-说说你对SEO-的理解"><a href="#5-说说你对SEO-的理解" class="headerlink" title="5.说说你对SEO****的理解"></a><strong>5.说说你对</strong>SEO****的理解</h2><p>SEO就是搜索引擎优化(Search Engine Optimization)，SEO通过了解搜索引擎的运⾏规则来调整⽹站，</p><p>以提⾼⽹站的曝光度,以及⽹站的排名。</p><p>Google 搜索引擎的⼯作流程主要分为三个阶段：</p><p><strong>抓取</strong>：Google 会使⽤名为“抓取⼯具”的⾃动程序搜索⽹络，以查找新⽹⻚或更新后的⽹⻚。Google 会</p><p>将这些⽹⻚的地址（即⽹址）存储在⼀个⼤型列表中，以便⽇后查看。我们会通过许多不同的⽅法查找</p><p>⽹⻚，但主要⽅法是跟踪我们已知的⽹⻚中的链接。</p><p><strong>编⼊索引</strong>：Google 会访问它通过抓取得知的⽹⻚，并会尝试分析每个⽹⻚的主题。Google 会分析⽹⻚</p><p>中的内容、图⽚和视频⽂件，尝试了解⽹⻚的主题。这些信息存储在 Google 索引中，⽽ Google 索引</p><p>是⼀个存储在海量计算机中的巨⼤数据库。</p><p><strong>呈现搜索结果</strong>：当⽤户在 Google 上进⾏搜索时，Google 会尝试确定最优质的搜索结果。“最佳”结果取</p><p>决于许多因素，包括⽤户的位置、语⾔、设备（桌⾯设备或⼿机）以及先前⽤过的搜索查询。例如，在</p><p>⽤户搜索“⾃⾏⻋维修店”后，Google 向巴黎⽤户显示的答案与向⾹港⽤户显示的答案有所不同。⽀付费</p><p>⽤不能提⾼⽹⻚在 Google 搜索结果中的排名，⽹⻚排名是完全依靠算法完成的。</p><h2 id="6-’-’-与-‘-’-选择器有什么不同"><a href="#6-’-’-与-‘-’-选择器有什么不同" class="headerlink" title="6.’+’ 与 ‘~’ 选择器有什么不同"></a><strong>6.’+’</strong> <strong>与</strong> <strong>‘~’</strong> <strong>选择器有什么不同</strong></h2><p>~ 是匹配元素之后的选择器</p><p>+ 是匹配相邻元素选择器</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是div下⾯的p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是div下⾯的p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css"><span class="hljs-selector-tag">div</span>+<span class="hljs-selector-tag">p</span> &#123;</span><span class="language-css"><span class="hljs-attribute">color</span>: red;</span><span class="language-css"> &#125;</span><span class="language-css"><span class="hljs-comment">/* 第⼀个p标签变红⾊了 */</span></span><span class="language-css"><span class="hljs-selector-tag">div</span>~<span class="hljs-selector-tag">p</span>&#123;</span><span class="language-css"><span class="hljs-attribute">color</span>:red;</span><span class="language-css"> &#125;</span><span class="language-css"><span class="hljs-comment">/* div后⾯的p标签都变成红⾊了 */</span></span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h2 id="7-说明text-align-居中的条件"><a href="#7-说明text-align-居中的条件" class="headerlink" title="7.说明text-align****居中的条件"></a><strong>7.说明</strong>text-align****居中的条件</h2><ul><li>text-align : 直接翻译过来设置⽂本的⽔平对⻬⽅式 (是继承属性)(是继承属性)</li><li>text-align 并不控制块元素⾃⼰的对⻬，只控制它的⾏内内容的对⻬</li><li>MDN解释: 定义⾏内内容（例如⽂字）如何相对它的块⽗元素对⻬(可以设置图⽚居中)</li><li>W3C官⽅⽂档解释: 设置⾏内(inline-level)元素(没有填满⽗元素)在快级⽗元素的对⻬⽅式</li></ul><h2 id="8-line-height为什么可以让⽂字垂直居中？"><a href="#8-line-height为什么可以让⽂字垂直居中？" class="headerlink" title="8. line-height为什么可以让⽂字垂直居中？"></a><strong>8. line-height</strong>为什么可以让⽂字垂直居中？</h2><p>line-height :两⾏⽂字基线( baseline )之间的间距 基线( baseline`):与⼩写字⺟x最底部对⻬的线</p><p>⼀⾏⽂本 等于 line-height</p><p>⾏⾼ - ⽂本⾼度 = ⾏距</p><p>属性值:</p><p>normal :取决于⽤户端。桌⾯浏览器（包括Firefox）使⽤默认值，约为1.2，这取决于元素的</p><p>font-family</p><p>&lt;数字&gt; :该属性的应⽤值是这个⽆单位数字&lt;数字&gt;乘以该元素的字体⼤⼩ 这是设置line</p><p>height的推荐⽅法，不会在继承时产⽣不确定的结果</p><p>&lt;⻓度&gt; :指定&lt;⻓度&gt;⽤于计算 line box 的⾼度 以 em 为单位的值可能会产⽣不确定的结果</p><p>&lt;百分⽐&gt; :与元素⾃身的字体⼤⼩有关。计算值是给定的百分⽐值乘以元素计算出的字体⼤</p><p>⼩。百分⽐值可能会带来不确定的结果</p><p>height :元素的整体⾼度 line-height :元素中每⼀⾏⽂字所占据的⾼度</p><p>假设div中只有⼀⾏⽂字，如何让这⾏⽂字在div内部垂直居中 让 line-height 等同于 height</p><h2 id="9-说说盒⼦模型包含哪些内容？"><a href="#9-说说盒⼦模型包含哪些内容？" class="headerlink" title="**9.**说说盒⼦模型包含哪些内容？"></a>**9.**说说盒⼦模型包含哪些内容？</h2><ul><li><p>内容</p><p>​         通过宽度和⾼度设置</p></li><li><p>内边距</p><p>​        通过padding设置</p></li><li><p>padding: </p><p>​        padding-top padding-right padding-bottom padding-left;</p></li><li><p>边框</p><p>​        通过border设置</p><p>​        border: border-width border-style border-color</p><ul><li><p>外边距</p><p> 通过margin设置</p><p>margin: margin-top margin-right margin-bottom margin-left</p></li></ul></li></ul><h2 id="10-说说你对margin-的传递和折叠的理解"><a href="#10-说说你对margin-的传递和折叠的理解" class="headerlink" title="*10.说说你对margin***的传递和折叠的理解"></a>*<em>10.<strong>说说你对</strong></em><em>margin</em>***的传递和折叠的理解</h2><ul><li>margin的传递⼀般是⽗⼦块元素之间,有margin-top传递,margin-bottom传递.<ul><li>margin-top传递: 当块级元素的顶部线和⽗元素的顶部线重叠，那么这个块级元素的margin-top值会传递给⽗元素</li><li>margin-bottom传递:当块级元素的底部线和⽗元素的底部线重叠，那么这个块级元素的margin</li></ul></li><li>bottom值会传递给⽗元素</li><li>折叠: 指的是 垂直⽅向上相邻的2个margin（margin-top、margin-bottom）有可能会合并为1个margin.</li><li>它有两个兄弟块级元素之间的上下margin的折叠,也有⽗⼦块元素之间的margin折叠</li></ul><h2 id="11-CSS-隐藏⻚⾯中某个元素的⼏种⽅法"><a href="#11-CSS-隐藏⻚⾯中某个元素的⼏种⽅法" class="headerlink" title="11.CSS 隐藏⻚⾯中某个元素的⼏种⽅法"></a><strong>11.CSS</strong> <strong>隐藏⻚⾯中某个元素的⼏种⽅法</strong></h2><p>display: none</p><p>​    通过 CSS 操控 display，移出⽂档流</p><p>opacity: 0</p><p>​    透明度为 0，仍在⽂档流中，当作⽤于其上的事件(如点击)仍有效</p><p>visibility: hidden</p><p>​    透明度为 0，仍在⽂档流中，<strong>但作⽤于其上的事件</strong>**(<strong><strong>如点击</strong></strong>)**<strong>⽆效</strong>，这也是</p><p>visibility:hidden 与 opacity: 0 的区别</p><p>​    content-visibility</p><p>​    移出⽂档流，但是再次显示时消耗性能低</p><p>​    绝对定位于当前⻚⾯的不可⻅位置    </p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: absolute;<span class="hljs-attribute">top</span>: -<span class="hljs-number">9000px</span>;<span class="hljs-attribute">left</span>: -<span class="hljs-number">9000px</span>;</code></pre></div><h2 id="12-box-sizing有什么作⽤？content-box和-border-box的区别"><a href="#12-box-sizing有什么作⽤？content-box和-border-box的区别" class="headerlink" title="12.box-sizing有什么作⽤？content-box和****border-box的区别"></a><strong>12.box-sizing</strong>有什么作⽤？<strong><strong>content-box</strong></strong>和****border-box的区别</h2><p>box-sizing⽤来设置盒⼦模型中宽⾼的计算⽅式：</p><p>​    content-box: padding、border都布置在width、height外边</p><p>​    border-box: padding、border都布置在width、height⾥边</p><h2 id="13-为什么会发⽣样式抖动"><a href="#13-为什么会发⽣样式抖动" class="headerlink" title="**13.**为什么会发⽣样式抖动"></a>**13.**为什么会发⽣样式抖动</h2><p>因为没有指定元素具体⾼度和宽度,⽐如数据还没有加载进来时元素⾼度是 100px(假设这⾥是100px)</p><p>数据加载进来后,因为有了数据,然后元素被撑⼤,所有出现了抖动</p><h2 id="14-说说浮动常⻅的规则？"><a href="#14-说说浮动常⻅的规则？" class="headerlink" title="**14.**说说浮动常⻅的规则？"></a>**14.**说说浮动常⻅的规则？</h2><ul><li><p>元素⼀旦浮动后, 脱离标准流</p><p>​    朝着向左或向右⽅向移动，直到⾃⼰的边界紧贴着包含块（⼀般是⽗元素）或者其他浮动元素的边界为⽌</p></li><li><p>定位元素会层叠在浮动元素上⾯</p><p>​    如果元素是向左（右）浮动，浮动元素的左（右）边界不能超出包含块的左（右）边界</p></li><li><p>浮动元素之间不能层叠</p><p>​    如果⼀个元素浮动，另⼀个浮动元素已经在那个位置了，后浮动的元素将紧贴着前⼀个浮动元素（左浮找左浮，右浮找右浮）</p><p>​    如果⽔平⽅向剩余的空间不够显示浮动元素，浮动元素将向下移动，直到有充⾜的空间为⽌</p></li><li><p>浮动元素不能与⾏内级内容层叠，⾏内级内容将会被浮动元素推出</p><p>​    ⽐如⾏内级元素、inline-block元素、块级元素的⽂字内容</p><p>​    ⾏内级元素、inline-block元素浮动后，其顶部将与所在⾏的顶部对⻬</p></li></ul><h2 id="15-为什么需要清除浮动？清除浮动有⼏种⽅法？"><a href="#15-为什么需要清除浮动？清除浮动有⼏种⽅法？" class="headerlink" title="**15.**为什么需要清除浮动？清除浮动有⼏种⽅法？"></a>**15.**为什么需要清除浮动？清除浮动有⼏种⽅法？</h2><p><strong>为什么需要清除浮动：</strong></p><p>1）由于浮动元素脱离了标准流，变成了浮动元素，不再向⽗元素汇报⾼度。所以⽗元素在计算⾼度时</p><p>并没有将浮动元素的⾼度计算进来，因此就造成了⾼度塌陷的问题 。解决⾼度塌陷的问题就叫做清除浮动（3分）</p><p>2）清除浮动的⽬的：是为了让⽗元素在计算⾼度的时候把浮动⼦元素的⾼度计算进去</p><p><strong>清除浮动有⼏种⽅法：</strong></p><p>给⽗元素设置固定⾼度，扩展性不好，不推荐</p><p>在⽗元素的最后增加⼀个空的块级⼦元素，并设置让他clear:both , 但是增加了⽆意义的空标签，</p><p>违反了结构与样式分离的原则</p><p>给⽗元素添加⼀个伪元素(推荐)</p><div class="code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clear_fix</span><span class="hljs-selector-pseudo">::after</span> &#123;<span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-attribute">display</span>: block;<span class="hljs-attribute">clear</span>:both;<span class="hljs-attribute">visibility</span>: hidden; <span class="hljs-comment">/* 浏览器兼容性 */</span><span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 浏览器兼容性 */</span>&#125;<span class="hljs-selector-class">.clear_fix</span> &#123; *zoom: <span class="hljs-number">1</span>; <span class="hljs-comment">/* IE6/7兼容性 */</span>&#125;</code></pre></div><p>overflflow:auto触发BFC来清除浮动（前提⾼度为auto）</p><h2 id="16-伪类与伪元素有什么区别"><a href="#16-伪类与伪元素有什么区别" class="headerlink" title="16.伪类与伪元素有什么区别?"></a><strong>16.<strong>伪类与伪元素有什么区别</strong></strong>?</h2><p>伪类使⽤单冒号，⽽伪元素使⽤双冒号。如 :hover 是伪类， ::before 是伪元素</p><p>伪元素会在⽂档流⽣成⼀个新的元素，并且可以使⽤ content 属性设置内容</p><h2 id="17-结构伪类-nth-child-n-和nth-of-type-n-的区别？"><a href="#17-结构伪类-nth-child-n-和nth-of-type-n-的区别？" class="headerlink" title="*17.结构伪类*nth-child(n)和nth-of-type(n)****的区别？"></a>*<em>17.<strong>结构伪类</strong></em>*nth-child(n)<strong><strong>和</strong></strong>nth-of-type(n)****的区别？</h2><p>:nth-child</p><p>是结构伪类选择器，选中⽗元素的第⼏个⼦元素 , 计数时与元素的类型⽆关。</p><p>:nth-of-type</p><p>是结构伪类选择器和nth-child类似，但是计数时只计算同种类型的元素。</p>]]></content>
    
    
    <categories>
      
      <category>前端八股文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react18 学习笔记</title>
    <link href="/2022/08/30/react18-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/30/react18-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="React开发依赖"><a href="#React开发依赖" class="headerlink" title="React开发依赖"></a>React开发依赖</h4><p>react开发必须依赖三个库：</p><ul><li><p>react   包含react所有必须的核心代码</p></li><li><p>react-dom react渲染在不同平台所需要的核心代码</p></li><li><p>babel  将jsx转换成React代码的工具</p><p>react 包含react web和react-native所拥有的核心代码</p><p>react-dom针对web和native完成的事情不同</p><p>​    web端react-dom会将jsx最终渲染成真实的DOM，显示在浏览器</p><p>​    native端 react-dom会将jsx最终渲染成原生的控件</p><p>babel是将jsx代码转成react.createElement</p></li></ul><h4 id="React组件化开发"><a href="#React组件化开发" class="headerlink" title="React组件化开发"></a>React组件化开发</h4><p>​    react中数据依赖来自两方面</p><p>​        参与界面更新的数据   当数据变量时，需要更新组件渲染的内容</p><p>​        不参与界面更新的数据  当数据变量时，不需要更新将组建渲染的内容，参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中，我们可以通过在构造函数中 this.state = {定义的数据}</p><p> 当我们的数据发生变化时，我们可以调用 this.setState 来更新数据，并且通知React进行update操作；在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面</p><ul><li><p>根据组件的定义方式，可以分为：函数组件(Functional Component )和类组件(Class Component)；</p></li><li><p>根据组件内部是否有状态需要维护，可以分成：无状态组件(Stateless Component )和有状态组件(Stateful Component)；</p></li><li><p>根据组件的不同职责，可以分成：展示型组件(Presentational Component)和容器型组件(Container Component)；</p></li><li><p>函数组件、无状态组件、展示型组件主要关注UI的展示；</p></li><li><p>类组件、有状态组件、容器型组件主要关注数据逻辑</p></li></ul><h4 id="JSX的条件渲染"><a href="#JSX的条件渲染" class="headerlink" title="JSX的条件渲染"></a>JSX的条件渲染</h4><p>​    在react中，所有条件判断都和普通的js代码一致，而vue中会使用v-if/v-show等来控制，react中没有这样封装好的指令</p><p>​    react常见的条件渲染方式</p><ul><li><p>条件判断语句</p></li><li><p>三元运算符</p></li><li><p>与运算符&amp;&amp;</p></li><li><p>display来控制</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;    <span class="hljs-comment">// 1.定义App根组件</span>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;      <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">super</span>()        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;          <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,          <span class="hljs-attr">isReady</span>: <span class="hljs-literal">false</span>,          <span class="hljs-attr">friend</span>: <span class="hljs-literal">undefined</span>        &#125;      &#125;      <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">const</span> &#123; isReady, friend &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>        <span class="hljs-comment">// 1.条件判断方式一: 使用if进行条件判断</span>        <span class="hljs-keyword">let</span> showElement = <span class="hljs-literal">null</span>        <span class="hljs-keyword">if</span> (isReady) &#123;          showElement = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>准备开始比赛吧<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>        &#125; <span class="hljs-keyword">else</span> &#123;          showElement = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>请提前做好准备!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>        &#125;        <span class="hljs-keyword">return</span> (          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">            &#123;/* 1.方式一: 根据条件给变量赋值不同的内容 */&#125;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;showElement&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">            &#123;/* 2.方式二: 三元运算符 */&#125;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; isReady ? <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>开始战斗!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>赶紧准备<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span> &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">            &#123;/* 3.方式三: &amp;&amp;逻辑与运算 */&#125;</span><span class="language-xml">            &#123;/* 场景: 当某一个值, 有可能为undefined时, 使用&amp;&amp;进行条件判断 */&#125;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123; friend &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;friend.name + &quot; &quot; + friend.desc&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>        )      &#125;    &#125;    <span class="hljs-comment">// 2.创建root并且渲染App组件</span>    <span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>))    root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>)  &lt;/script&gt;</code></pre></div></li></ul><p>1.react中，方法中this的默认是指向undefined的，</p><p>  2.vscode创建用户代码片段<br>3.<br> <div class="code-wrapper"><pre><code class="hljs js">jsx写注释&#123;<span class="hljs-comment">/* */</span>&#125; <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">        &#123;/*这是一段注释*/&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    )  &#125;&#125;</code></pre></div></p><p>​    4.</p><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">//这三个值无法在jsx中渲染出来</span>   test1:<span class="hljs-literal">undefined</span>   test2:<span class="hljs-literal">null</span>   text3:<span class="hljs-literal">false</span></code></pre></div><p>5.在jsx中对象类型不可以作为子元素,进行直接展示</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;this.state.obj&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>6.jsx嵌入表达式<br>    运算表达式<br>    三元运算符<br>    执行一个函数</p><p>7.jsx中的class用className<br>8.jsx中style的写法</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span>&quot;<span class="hljs-attr">red</span>&quot;,<span class="hljs-attr">fontSzie:</span>&quot;<span class="hljs-attr">24px</span>&quot;&#125;&#125;&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div><p>9.react的事件绑定<br>    react的事件绑定方法中this默认是undefined<br>    this的绑定的三种方式</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;    <span class="hljs-comment">// class fields</span>    name = <span class="hljs-string">&quot;App&quot;</span>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-comment">//类组件继承一定要加super()并且必须写在最上面</span>      <span class="hljs-variable language_">super</span>()      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;        <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span>,        <span class="hljs-attr">counter</span>: <span class="hljs-number">100</span>      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">btn1Click</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">btn1Click</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)    &#125;    <span class="hljs-title function_">btn1Click</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn1Click&quot;</span>, <span class="hljs-variable language_">this</span>);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span> &#125;)    &#125;    btn2Click = <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn2Click&quot;</span>, <span class="hljs-variable language_">this</span>)      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">1000</span> &#125;)    &#125;    <span class="hljs-title function_">btn3Click</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn3Click&quot;</span>, <span class="hljs-variable language_">this</span>);      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">9999</span> &#125;)    &#125;    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">const</span> &#123; message &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>      <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          &#123;/* 1.this绑定方式一: bind绑定 */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btn1Click&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          </span><span class="language-xml">          &#123;/* 2.this绑定方式二: ES6 class fields */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btn2Click&#125;</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml">          &#123;/* 3.this绑定方式三: 直接传入一个箭头函数(重要) */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> console.log(&quot;btn3Click&quot;)&#125;&gt;按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.btn3Click()&#125;&gt;按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前计数: &#123;this.state.counter&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>      )    &#125;  &#125;  <span class="hljs-comment">// 2.创建root并且渲染App组件</span>  <span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#root&quot;</span>))  root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span>)</code></pre></div><p> 10.react事件的传参</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(e)</span>=&gt;</span>&#123;         this.click3(e,item,name)       &#125;&#125;&gt;点击3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><p>​        可以用来传递event<br>​<br> 在执行事件函数时，有可能我们需要获取一些参数信息：比如event对象、其他参数<br> 情况一：获取event对象<br> 很多时候我们需要拿到event对象来做一些事情（比如阻止默认行为）<br> 假如我们用不到this，那么直接传入函数就可以获取到event对象；<br> 情况二：获取更多参数<br> 有更多参数时，我们最好的方式就是传入一个箭头函数，主动执行的事件函数，并且传入相关的其他参数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">const</span> &#123; message &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>      <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">          &#123;/* 1.event参数的传递 */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick.bind(this)&#125;</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event)</span> =&gt;</span> this.btnClick(event)&#125;&gt;按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          </span><span class="language-xml">          &#123;/* 2.额外的参数传递 */&#125;</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.btnClick.bind(this,</span> &quot;<span class="hljs-attr">kobe</span>&quot;, <span class="hljs-attr">30</span>)&#125;&gt;</span>按钮3(不推荐)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(event)</span> =&gt;</span> this.btnClick(event, &quot;why&quot;, 18)&#125;&gt;按钮4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>      )    &#125;</code></pre></div><p> 11.react的列表渲染使用最多的是使用map<br>     过滤filter<br>     截取slice<br> 12.React.createElement() jsx是他的语法糖</p><p>​    createElement需要传递三个参数</p><ul><li><p>type      当前ReactElement的类型，如果是标签元素，那么就使用字符串表示div,如果是组件元素就用组件的名称</p></li><li><p>config    所有jsx中的属性在config中都是对象的属性和值的形式存在，例如className作为class</p></li><li><p>children  存放在标签中的内容都是以children数组的形式存储</p><p><img src="https://img1.imgtp.com/2022/09/12/pgiZpbQL.png" alt="QQ截图20220912114717.png"></p></li></ul><p> 13.render() 将virtual Dom=&gt;Dom<br> 14.频繁的操作DOM，会产生回流和重绘<br> 15.React 组件名称首字母必须大写 html标签必须小写<br>     类组件需要继承自 React.Component<br>      类组件必须实现render函数<br> 16.函数式组件<br>      没有生命周期，也会被更新并挂载，但是没有生命周期函数；<br>      没有this(组件实例）；<br>     没有内部状态（state）<br> 17.render函数、函数式组件的返回类型<br>         组件，html元素<br>         数组、fragments<br>         Portals<br>         字符串或者数值类型<br>         Boolean，null<br> 18.react的生命周期</p><p>生命周期图谱</p><img src="https://img1.imgtp.com/2022/09/12/X4cHBQk6.png" alt="QQ截图20220912132938.png" style="zoom:200%;" /><img src="https://img1.imgtp.com/2022/09/12/ACO5RXp5.png" alt="QQ截图20220912133029.png" style="zoom:200%;" /><p> 常用的生命周期函数     </p><div class="code-wrapper"><pre><code class="hljs">    1.contructor()&#123;    &#125;     如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。     constructor中通常只做两件事情：     通过给 this.state 赋值对象来初始化内部的state；     为事件绑定实例（this）；    2.componentDidMount()      componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用          可以进行网络请求，添加订阅，DOM操作    3.componentDidUpdate(prevProps, prevState, snapshot)      会在更行后立即调用，首次渲染不会执行，可以使用setState方法，但是必须用于条件语句，当组件更新后，可以在此处对 DOM 进行操作，如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求    4.componentWillUnmount()      可以用于清楚timer,取消网络请求，取消订阅    5.不常用的生命周期      getDerivedStateFromProps：state 的值在任何时候都依赖于 props时使用；该方法返回一个对象来更新state；      getSnapshotBeforeUpdate：在React更新DOM之前回调的一个函数，可以获取DOM更新前的一些信息（比如说滚动位置）      shouldComponentUpdate：当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</code></pre></div><p>   19.组件通信<br>         1.父组件向子组件传递数据 传递参数是常量非string的时候要将其当作变量用{}</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Children2</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;里斯&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&#123;55&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Children2</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs">     2.子组件向父组件传递数据，定义回调函数传递给子组件调用</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;import AddCounter from &#x27;./AddCounter&#x27;import SubCounter from &#x27;./SubCounter&#x27;export class App extends Component &#123;  constructor() &#123;    super()    this.state = &#123;      counter: 100    &#125;  &#125;  changeCounter(count) &#123;    this.setState(&#123; counter: this.state.counter + count &#125;)  &#125;  render() &#123;    const &#123; counter &#125; = this.state    return (      &lt;div&gt;        &lt;h2&gt;当前计数: &#123;counter&#125;&lt;/h2&gt;        &lt;AddCounter addClick=&#123;(count) =&gt; this.changeCounter(count)&#125;/&gt;        &lt;SubCounter subClick=&#123;(count) =&gt; this.changeCounter(count)&#125;/&gt;      &lt;/div&gt;    )  &#125;&#125;export default App</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;// import PropTypes from &quot;prop-types&quot;export class AddCounter extends Component &#123;  addCount(count) &#123;    this.props.addClick(count)  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(1)&#125;&gt;+1&lt;/button&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(5)&#125;&gt;+5&lt;/button&gt;        &lt;button onClick=&#123;e =&gt; this.addCount(10)&#125;&gt;+10&lt;/button&gt;      &lt;/div&gt;    )  &#125;&#125;// AddCounter.propTypes = &#123;//   addClick: PropTypes.func// &#125;export default AddCounter</code></pre></div><div class="code-wrapper"><pre><code class="hljs">    3.跨组件通信Context，可以使用组件的组合来替代Context        </code></pre></div><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> React from <span class="hljs-string">&quot;react&quot;</span><span class="hljs-comment">// 1.创建一个Context并且设置默认值</span><span class="hljs-type">const</span> ThemeContext = React.<span class="hljs-built_in">createContext</span>(&#123; color: <span class="hljs-string">&quot;blue&quot;</span>, size: <span class="hljs-number">10</span> &#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ThemeContext</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-comment">// 1.创建一个Context</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UserContext</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//App.js//多个context传递数据的方式&lt;UserContext.Provider value=&#123;&#123;nickname: &quot;kobe&quot;, age: 30&#125;&#125;&gt;          &lt;ThemeContext.Provider value=&#123;&#123;color: &quot;red&quot;, size: &quot;30&quot;&#125;&#125;&gt;            &lt;Home &#123;...info&#125;/&gt;          &lt;/ThemeContext.Provider&gt; &lt;/UserContext.Provider&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//类组件的接受方式import React, &#123; Component &#125; from &#x27;react&#x27;import ThemeContext from &#x27;./context/theme-context&#x27;export class Profile extends Component &#123;  render() &#123;    console.log(this.context)    return (      &lt;div&gt;Profile&lt;/div&gt;    )  &#125;&#125;Profile.contextType = ThemeContextexport default Profile</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//函数式组件的接收方式import ThemeContext from &quot;./context/theme-context&quot;function HomeBanner() &#123;  return &lt;div&gt;    &#123;/* 函数式组件中使用Context共享的数据 */&#125;    &lt;ThemeContext.Consumer&gt;      &#123;        value =&gt; &#123;          return &lt;h2&gt; Banner theme:&#123;value.color&#125;&lt;/h2&gt;        &#125;      &#125;    &lt;/ThemeContext.Consumer&gt;  &lt;/div&gt;&#125;export default HomeBanner</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; Component &#125; from &#x27;react&#x27;import ThemeContext from &#x27;./context/theme-context&#x27;import UserContext from &#x27;./context/user-context&#x27;export class HomeInfo extends Component &#123;  //static contextType=ThemeContext 这种写法也可以  render() &#123;    // 4.第四步操作: 获取数据, 并且使用数据    console.log(this.context)    return (      &lt;div&gt;        &lt;h2&gt;HomeInfo: &#123;this.context.color&#125;&lt;/h2&gt;        &lt;UserContext.Consumer&gt;          &#123;            value =&gt; &#123;              return &lt;h2&gt;Info User: &#123;value.nickname&#125;&lt;/h2&gt;            &#125;          &#125;        &lt;/UserContext.Consumer&gt;      &lt;/div&gt;    )  &#125;&#125;// 3.第三步操作: 设置组件的contextType为某一个ContextHomeInfo.contextType = ThemeContextHomeInfo.displayName = &#x27;MyDisplayName&#x27;;//设置在devtool的显示名字export default HomeInfo</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//多个context的使用// Theme context，默认的 theme 是 “light” 值const ThemeContext = React.createContext(&#x27;light&#x27;);// 用户登录 contextconst UserContext = React.createContext(&#123;  name: &#x27;Guest&#x27;,&#125;);class App extends React.Component &#123;  render() &#123;    const &#123;signedInUser, theme&#125; = this.props;    // 提供初始 context 值的 App 组件    return (      &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;        &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt;          &lt;Layout /&gt;        &lt;/UserContext.Provider&gt;      &lt;/ThemeContext.Provider&gt;    );  &#125;&#125;function Layout() &#123;  return (    &lt;div&gt;      &lt;Sidebar /&gt;      &lt;Content /&gt;    &lt;/div&gt;  );&#125;// 一个组件可能会消费多个 contextfunction Content() &#123;  return (    &lt;ThemeContext.Consumer&gt;      &#123;theme =&gt; (        &lt;UserContext.Consumer&gt;          &#123;user =&gt; (            &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt;          )&#125;        &lt;/UserContext.Consumer&gt;      )&#125;    &lt;/ThemeContext.Consumer&gt;  );&#125;</code></pre></div><p>**什么时候使用Context.Consumer呢？</p><p>.当使用value的组件是一个函数式组件时；</p><p>.当组件中需要使用多个Context时；</p><p> 4.使用事件总线<br>   20.对props进行类型检查 propTypes</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;prop-types&quot;</span><span class="hljs-title class_">Children2</span>.<span class="hljs-property">propTypes</span> = &#123;          <span class="hljs-comment">// 必填属性</span>          <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,          <span class="hljs-attr">age</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>,          <span class="hljs-attr">time</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">array</span>        &#125;;        <span class="hljs-comment">// 可以定义默认·值</span><span class="hljs-title class_">Children2</span>.<span class="hljs-property">defaultProps</span>=&#123;          <span class="hljs-attr">time</span>:[<span class="hljs-string">&quot;2022/5/11&quot;</span>,<span class="hljs-string">&quot;2022/5/6&quot;</span>]        &#125;</code></pre></div><p> 21.props为什么不写也是可以的   </p><div class="code-wrapper"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><span class="hljs-comment"><span class="hljs-function">      super()</span></span><span class="hljs-comment"><span class="hljs-function">      this.state=&#123;&#125;</span></span><span class="hljs-function">    &#125;</span><span class="hljs-function"> 因为<span class="hljs-title">react</span>内部会强制性给当前实例复制<span class="hljs-title">props</span></span><span class="hljs-function"> <span class="hljs-title">this</span>.<span class="hljs-title">instance</span>=<span class="hljs-title">element</span>.<span class="hljs-title">props</span></span></code></pre></div><p>22.组件插槽的实现</p><div class="code-wrapper"><pre><code class="hljs html"> //App.js<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        &#123;/* 1.使用children实现插槽 */&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">NavBar</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体文本<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">NavBar</span>&gt;</span>        &#123;/* 2.使用props实现插槽 */&#125;        <span class="hljs-tag">&lt;<span class="hljs-name">NavBarTwo</span> </span><span class="hljs-tag">          <span class="hljs-attr">leftSlot</span>=<span class="hljs-string">&#123;btn&#125;</span></span><span class="hljs-tag">          <span class="hljs-attr">centerSlot</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">h2</span>&gt;</span>呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>&#125;          rightSlot=&#123;<span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体2<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#125;        /&gt;      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//NavBar.jsexport class NavBar extends Component &#123;  render() &#123;    const &#123; children &#125; = this.props    console.log(children)    return (      &lt;div className=&#x27;nav-bar&#x27;&gt;        &lt;div className=&quot;left&quot;&gt;&#123;children[0]&#125;&lt;/div&gt;        &lt;div className=&quot;center&quot;&gt;&#123;children[1]&#125;&lt;/div&gt;        &lt;div className=&quot;right&quot;&gt;&#123;children[2]&#125;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//NavBarTwo.jsimport React, &#123; Component &#125; from &#x27;react&#x27;export class NavBarTwo extends Component &#123;  render() &#123;    const &#123; leftSlot, centerSlot, rightSlot &#125; = this.props    return (      &lt;div className=&#x27;nav-bar&#x27;&gt;        &lt;div className=&quot;left&quot;&gt;&#123;leftSlot&#125;&lt;/div&gt;        &lt;div className=&quot;center&quot;&gt;&#123;centerSlot&#125;&lt;/div&gt;        &lt;div className=&quot;right&quot;&gt;&#123;rightSlot&#125;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre></div><p>通过children实现的方案虽然可行，但是有一个弊端：通过索引值获取传入的元素很容易出错，不能精准的获取传入的原生</p><p>23.setState<br>   setState是异步更新，可以显著提升性能<br>   如果每一次调用setState都进行一次更新，那么意味着render函数需要频繁的调用<br>   最好的办法是获取多个更新，之后进行批量更新<br>   如果同步更新了state,但是还没执行render函数，那么state和props不能保持同步<br>   state和props不能保持一致性，会在开发中产生很多问题</p><p>   为了拿到异步更新后的数据</p><p>​    setState的三种写法</p><p>​    </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-comment">// 1.setState更多用法</span>   <span class="hljs-comment">// 1.基本使用</span>   <span class="hljs-comment">// this.setState(&#123;</span>   <span class="hljs-comment">//   message: &quot;你好啊, 李银河&quot;</span>   <span class="hljs-comment">// &#125;)</span>   <span class="hljs-comment">// 2.setState可以传入一个回调函数,回调 函数中接收的 state 和 props 都保证为最新。回调函数 的返回值会与 state 进行浅合并。</span>   <span class="hljs-comment">// 好处一: 可以在回调函数中编写新的state的逻辑</span>   <span class="hljs-comment">// 好处二: 当前的回调函数会将之前的state和props传递进来</span>   <span class="hljs-comment">// this.setState((state, props) =&gt; &#123;</span>   <span class="hljs-comment">//   // 1.编写一些对新的state处理逻辑</span>   <span class="hljs-comment">//   // 2.可以获取之前的state和props值</span>   <span class="hljs-comment">//   console.log(this.state.message, this.props)</span>    <span class="hljs-comment">//获得最新的state和props</span><span class="hljs-comment">//   console.log(state, props)</span>   <span class="hljs-comment">//   return &#123;</span>   <span class="hljs-comment">//     message: &quot;你好啊, 李银河&quot;</span>   <span class="hljs-comment">//   &#125;</span>   <span class="hljs-comment">// &#125;)</span>   <span class="hljs-comment">// 3.setState在React的事件处理中是一个异步调用</span>   <span class="hljs-comment">// 如果希望在数据更新之后(数据合并), 获取到对应的结果执行一些逻辑代码</span>   <span class="hljs-comment">// 那么可以在setState中传入第二个参数: callback</span>   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊, 李银河&quot;</span> &#125;, <span class="hljs-function">() =&gt;</span> &#123;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;++++++:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>)   &#125;)   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;------:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>) &#125;</code></pre></div><h5 id="setState都是异步的吗"><a href="#setState都是异步的吗" class="headerlink" title="setState都是异步的吗"></a>setState都是异步的吗</h5><p>在React18以前，在组件的生命周期或者React合成事件中，setState是异步的，在setTimeout以及原生事件中是同步的，react18以后所有都是异步的，如果需要同步操作需要使用flushSync()</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 在react18之前, setTimeout中setState操作, 是同步操作</span>    <span class="hljs-comment">// 在react18之后, setTimeout中setState异步操作(批处理)</span>    <span class="hljs-title function_">flushSync</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊, 李银河&quot;</span> &#125;)    &#125;)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>)  &#125;, <span class="hljs-number">0</span>);</code></pre></div><p> 24.组件创建的时候会被调用一次<br> 25.render函数，组件更新时调用render函数会让所有子组件都会进行一次更新。使用shouldComponentUpdate这个生命周期函数可以控制state和props发生变化时是否重新调用render函数         </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps,nextState</span>)&#123;    <span class="hljs-comment">//next...是最新的数据</span>       <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">num</span>!==nextState.<span class="hljs-property">num</span>)&#123;         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>     &#125;</code></pre></div><p>​    在开发中每个组件都写shouldComponentUpdate比较麻烦，可以在使用PureComponent</p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span></span></code></pre></div><p> 26.PureComponent不能用于函数式组件，需要用memo</p><p>​     PureComponent就是对组件进行优化，避免频繁的调用render函数进行渲染，这个方法中调用!shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)，进行浅层比较</p><p> 27.state中的属性的不可变性<br> 28.react不建议直接在操作dom，可以使用ref<br>     使用ref的三种方式</p><div class="code-wrapper"><pre><code class="hljs react">import React,&#123;createRef&#125; from &quot;react&quot;;class RefDemo extends React.Component&#123;  constructor(props)&#123;    super(props)    this.state=&#123;&#125;    this.titleRef=createRef()    // 第三种使用函数    this.textInput = null;  &#125;  componentDidMount()&#123;     &#125;  componentWillUnmount()&#123;      &#125;  changeRef1()&#123;    // 方式一已经被淘汰了    this.refs.refTitle.innerHTML=&quot;hello ref&quot;  &#125;  changeRef2()&#123;    // 官方推荐以这种方式     this.titleRef.current.innerHTML=&quot;hello big&quot;    console.log(this.titleRef.current)  &#125;  focusTextInput()&#123;    this.textInput.focus()    console.log(this.textInput)  &#125;  render()&#123;    return (      &lt;div&gt;        &lt;h1 ref=&quot;refTitle&quot;&gt;hello react&lt;/h1&gt;        &lt;button onClick=&#123;()=&gt;this.changeRef1()&#125;&gt;按钮1&lt;/button&gt;        &lt;h1 ref=&#123;this.titleRef&#125;&gt;hello world&lt;/h1&gt;        &lt;button onClick=&#123;()=&gt;this.changeRef2()&#125;&gt;按钮2&lt;/button&gt;        &lt;button onClick=&#123;()=&gt;this.focusTextInput()&#125;&gt;focus&lt;/button&gt;        &lt;div&gt;&lt;input ref=&#123;element=&gt;this.textInput=element&#125; type=&quot;text&quot; /&gt;&lt;/div&gt;      &lt;/div&gt;    )  &#125;&#125;export default RefDemo</code></pre></div><p>函数式组件中没有ref属性，要使用const textInput = useRef(null);<br>可以通过ref访问子组件的方法和属性和vue一样</p><h4 id="key的注意事项"><a href="#key的注意事项" class="headerlink" title="key的注意事项"></a>key的注意事项</h4><p>key必须唯一</p><p>key不能够使用随机数（因为随机数在下一次render时会重新生成一个数字）</p><p>使用index作为key,对性能没有优化</p><p>26.受控组件</p><p>​    受控组件就是通过setState来控制值，state成为唯一的数据源</p><p>​    </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">inputChange</span>(<span class="hljs-params">event</span>) &#123;   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inputChange:&quot;</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">username</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span> &#125;) &#125; <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">const</span> &#123; username &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>   <span class="hljs-keyword">return</span> (     <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">       &#123;/* 受控组件 */&#125;</span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;username&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> this.inputChange(e)&#125;/&gt;</span><span class="language-xml"></span><span class="language-xml">       &#123;/* 非受控组件 */&#125;</span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>username: &#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>   ) &#125;</code></pre></div><p>当type为text/textarea/select的时候绑定的是value,需要使用事件onChange</p><p>当type为checkbox/radio的时候，绑定的是checked，使用onChange事件</p><div class="code-wrapper"><pre><code class="hljs lua">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;始终是非受控组件</code></pre></div><p>使用form进行表单提交</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlavorForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-variable language_">super</span>(props);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;coconut&#x27;</span>&#125;;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleChange</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleSubmit</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);  &#125;  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">value</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>&#125;);  &#125;  <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) &#123;    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;你喜欢的风味是: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">value</span>);    event.<span class="hljs-title function_">preventDefault</span>();  &#125;  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> (      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><span class="language-xml">          选择你喜欢的风味:</span><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;grapefruit&quot;</span>&gt;</span>葡萄柚<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lime&quot;</span>&gt;</span>酸橙<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;coconut&quot;</span>&gt;</span>椰子<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mango&quot;</span>&gt;</span>芒果<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>    );  &#125;&#125;</code></pre></div><p>当针对多个输入的时候</p><p>可以给每个input绑定唯一的name,然后利用计算属性名来进行赋值操作</p><div class="code-wrapper"><pre><code class="hljs react">handleSubmitClick(event) &#123;    // 1.阻止默认的行为    event.preventDefault()    // 2.获取到所有的表单数据, 对数据进行组件    console.log(&quot;获取所有的输入内容&quot;)    console.log(this.state.username, this.state.password)    // 3.以网络请求的方式, 将数据传递给服务器(ajax/fetch/axios)  &#125;  // handleUsernameChange(event) &#123;  //   this.setState(&#123; username: event.target.value &#125;)  // &#125;  // handlePasswordChange(event) &#123;  //   this.setState(&#123; password: event.target.value &#125;)  // &#125;  handleInputChange(event) &#123;    this.setState(&#123;      [event.target.name]: event.target.value    &#125;)  &#125;  render() &#123;    const &#123; username, password &#125; = this.state    return (      &lt;div&gt;        &lt;form onSubmit=&#123;e =&gt; this.handleSubmitClick(e)&#125;&gt;          &#123;/* 1.用户名和密码 */&#125;          &lt;label htmlFor=&quot;username&quot;&gt;            用户:             &lt;input               id=&#x27;username&#x27;               type=&quot;text&quot;               name=&#x27;username&#x27;               value=&#123;username&#125;               onChange=&#123;e =&gt; this.handleInputChange(e)&#125;            /&gt;          &lt;/label&gt;          &lt;label htmlFor=&quot;password&quot;&gt;            密码:             &lt;input               id=&#x27;password&#x27;               type=&quot;password&quot;               name=&#x27;password&#x27;               value=&#123;password&#125;               onChange=&#123;e =&gt; this.handleInputChange(e)&#125;            /&gt;          &lt;/label&gt;          &lt;button type=&#x27;submit&#x27;&gt;注册&lt;/button&gt;        &lt;/form&gt;      &lt;/div&gt;    )  &#125;</code></pre></div><p>27.非受控组件</p><p>非受控组件就是将表单数据交给DOM节点来处理，</p><div class="code-wrapper"><pre><code class="hljs react">class NameForm extends React.Component &#123;  constructor(props) &#123;    super(props);    this.handleSubmit = this.handleSubmit.bind(this);    this.input = React.createRef();  &#125;  handleSubmit(event) &#123;    alert(&#x27;A name was submitted: &#x27; + this.input.current.value);    event.preventDefault();  &#125;  render() &#123;、  //defaultValue是默认值    return (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;label&gt;          Name:          &lt;input  defaultValue=&quot;Bob&quot; type=&quot;text&quot; ref=&#123;this.input&#125; /&gt;        &lt;/label&gt;        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vim">&lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt; 和 &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt; 支持 defaultChecked，<span class="hljs-symbol">&lt;select&gt;</span> 和 <span class="hljs-symbol">&lt;textarea&gt;</span> 支持 defaultValue。</code></pre></div><p>28.高阶组件</p><p>高阶组件是一个函数，高阶组件的参数是一个组件，返回值也是一个组件。高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。HOC 是纯函数，没有副作用，高阶组件适用于抽取公共的逻辑</p><div class="code-wrapper"><pre><code class="hljs react">import &#123; PureComponent &#125; from &#x27;react&#x27;//props增强// 定义组件: 给一些需要特殊数据的组件, 注入propsfunction enhancedUserInfo(OriginComponent) &#123;  class NewComponent extends PureComponent &#123;    constructor(props) &#123;      super(props)      this.state = &#123;        userInfo: &#123;          name: &quot;coderwhy&quot;,          level: 99        &#125;      &#125;    &#125;    render() &#123;      return &lt;OriginComponent &#123;...this.props&#125; &#123;...this.state.userInfo&#125;/&gt;    &#125;  &#125;  return NewComponent&#125;export default enhancedUserInfo</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//我们也可以利用高阶函数来劫持生命周期，在生命周期中完成自己的逻辑</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">PureComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">logRenderTime</span>(<span class="hljs-params">OriginComponent</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">PureComponent</span> &#123;    <span class="hljs-title function_">UNSAFE_componentWillMount</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">beginTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()      <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">endTime</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()      <span class="hljs-keyword">const</span> interval = <span class="hljs-variable language_">this</span>.<span class="hljs-property">endTime</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">beginTime</span>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前<span class="hljs-subst">$&#123;OriginComponent.name&#125;</span>页面花费了<span class="hljs-subst">$&#123;interval&#125;</span>ms渲染完成!`</span>)    &#125;    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">OriginComponent</span> &#123;<span class="hljs-attr">...this.props</span>&#125;/&gt;</span></span>    &#125;  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> logRenderTime</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">//渲染鉴权，可以判断用户有没有登录，如果没有登录则渲染其他组件function loginAuth(OriginComponent) &#123;  return props =&gt; &#123;    // 从localStorage中获取token    const token = localStorage.getItem(&quot;token&quot;)    if (token) &#123;      return &lt;OriginComponent &#123;...props&#125;/&gt;    &#125; else &#123;      return &lt;h2&gt;请先登录, 再进行跳转到对应的页面中&lt;/h2&gt;    &#125;  &#125;&#125;export default loginAuth</code></pre></div><div class="code-wrapper"><pre><code class="hljs react">import ThemeContext from &quot;../context/theme_context&quot;//和context结合function withTheme(OriginComponment) &#123;  return (props) =&gt; &#123;    return (      &lt;ThemeContext.Consumer&gt;        &#123;          value =&gt; &#123;            return &lt;OriginComponment &#123;...value&#125; &#123;...props&#125;/&gt;          &#125;        &#125;      &lt;/ThemeContext.Consumer&gt;    )  &#125;&#125;export default withTheme</code></pre></div><p>不要在 render 方法中使用 HOC</p><p>HOC也有自己的一些缺陷：</p><p> HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难； HOC可以劫持props，在不遵守约定的情况下也可能造成冲突；</p><p>Hooks的出现，是开创性的，它解决了很多React之前的存在的问题</p><p>比如this指向问题、比如hoc的嵌套复杂度问题等等</p><p>29.ref的转发，获取函数式组件内部的ref 可以使用forwardRef高阶函数<br>30.Portals的使用，用于将渲染元素独立于父组件，渲染到其他元素之上。使用React.createPortal(child,container)<br>31.fragment的使用，相当于vue的template在实际的dom中不渲染，带key的时候不能使用短语法<br>    还可以使用短语发    </p><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Columns</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;&gt;        &lt;td&gt;<span class="hljs-type">Hello</span>&lt;/td&gt;        &lt;td&gt;<span class="hljs-type">World</span>&lt;/td&gt;      &lt;/&gt;    );  &#125;&#125;</code></pre></div><p> 32.StrictMode 开启react的严格模式，只有开发环境下起作用</p><p>​    StrictMode是用来突显应用程序中的潜在问题的工具</p><p>​    它为其后代元素触发额外的检查和警告</p><div class="code-wrapper"><pre><code class="hljs"> 可以识别不安全的生命周期 使用过时的ref的API 检测意外的副作用。</code></pre></div><p>​            组件的constructor会调用两次</p><p>​            生产环境终不悔调用两次</p><p>​    j检测使用废弃的findDOMNode方法</p><div class="code-wrapper"><pre><code class="hljs"> 检测过时的context api </code></pre></div><p>​            早期的Context是通过static属性声明Context对象属性，通过getChildContext返回Context对象等方式来使用Context的</p><p> 33.react中的css<br>     1.内联样式</p><p>​            style 接受一个采用小驼峰命名属性的 JavaScript 对象，，而不是 CSS 字符串</p><p>​            并且可以引用state中的状态来设置相关的样式</p><p>​            .内联样式, 样式之间不会有冲突</p><p>​             可以动态获取当前state中的状态</p><p>​             写法上都需要使用驼峰标识</p><p>​            某些样式没有提示</p><p>​            大量的样式, 代码混乱</p><p>​            某些样式无法编写(比如伪类/伪元素</p><div class="code-wrapper"><pre><code class="hljs"> 2.css modules     不是react特有的决绝方案，所有类似webpack配置环境都可以使用，在react中已经配置，在其他项目中使用需要在webpack.config.js中module:true      要创建xxx.moudle.css文件      不能使用连接符创建类名(.home-title)，js不支持，需要使用&#123;引入名字style.className&#125;来编写      不方便更改样式.不方便动态修改某些样式，依然需要使用内联样式  3.css in js      常用的 css in js库          styled-components              在多人协作中，css必定会出现命名冲突，与vue的scoped解决方案不同，react用styled-                    components的给类名加了随机字符的方式实现了css的私有化，它也是全局的          styled-components其实是一个组件，可以传入props          emotion          glamorous</code></pre></div><p>​        styled-components的本质是通过函数的调用，最终创建出一个组件，这个组件会自动添加上一个不重复的class</p><p>​        styled-components会给该class添加相关的样式，它支持css预处理器一样嵌套，支持直接子代选择器或者后代选择器，并且编写样式，可以通过&amp;符号获取当前元素，直接伪类选择器，伪元素等</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span><span class="hljs-keyword">import</span> &#123;  primaryColor,  largeSize&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./style/variables&quot;</span><span class="hljs-comment">// 1.基本使用</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">AppWrapper</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`</span><span class="hljs-string">  .footer &#123;</span><span class="hljs-string">    border: 1px solid orange;</span><span class="hljs-string">  &#125;</span><span class="hljs-string">// const obj = &#123;</span><span class="hljs-string">//   name: (props) =&gt; props.name || &quot;why&quot;</span><span class="hljs-string">// &#125;</span><span class="hljs-string">// 2.子元素单独抽取到一个样式组件</span><span class="hljs-string">// 3.可以接受外部传入的props</span><span class="hljs-string">// 4.可以通过attrs给标签模板字符串中提供的属性</span><span class="hljs-string">// 5.从一个单独的文件中引入变量</span><span class="hljs-string">export const SectionWrapper = styled.div.attrs(props =&gt; (&#123;</span><span class="hljs-string">  tColor: props.color || &quot;blue&quot;</span><span class="hljs-string">&#125;))`</span>  <span class="hljs-attr">border</span>: 1px solid red;  .<span class="hljs-property">title</span> &#123;    font-<span class="hljs-attr">size</span>: $&#123;<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> props.<span class="hljs-property">size</span>&#125;px;    <span class="hljs-attr">color</span>: $&#123;<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> props.<span class="hljs-property">tColor</span>&#125;;    &amp;:hover &#123;      background-<span class="hljs-attr">color</span>: purple;    &#125;  &#125;  .<span class="hljs-property">content</span> &#123;    font-<span class="hljs-attr">size</span>: $&#123;largeSize&#125;px;    <span class="hljs-attr">color</span>: $&#123;primaryColor&#125;;  &#125;<span class="hljs-string">`</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;styled-components&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-title class_">HYButton</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`</span><span class="hljs-string">  border: 1px solid red;</span><span class="hljs-string">  border-radius: 5px;</span><span class="hljs-string">`</span><span class="hljs-comment">// css样式的继承</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HYButtonWrapper</span> = <span class="hljs-title function_">styled</span>(<span class="hljs-title class_">HYButton</span>)<span class="hljs-string">`</span><span class="hljs-string">  background-color: #0f0;</span><span class="hljs-string">  color: #fff;</span><span class="hljs-string">`</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeWrapper</span> = styled.<span class="hljs-property">div</span><span class="hljs-string">`</span><span class="hljs-string">  .top &#123;</span><span class="hljs-string">    .banner &#123;</span><span class="hljs-string">      color: red;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">  &#125;</span><span class="hljs-string">  .bottom &#123;</span><span class="hljs-string">    .header &#123;</span><span class="hljs-string">      color: <span class="hljs-subst">$&#123;props =&gt; props.theme.color&#125;</span>;</span><span class="hljs-string">      font-size: <span class="hljs-subst">$&#123;props =&gt; props.theme.size&#125;</span>;</span><span class="hljs-string">    &#125;</span><span class="hljs-string"></span><span class="hljs-string">    .product-list &#123;</span><span class="hljs-string">      .item &#123;</span><span class="hljs-string">        color: blue;</span><span class="hljs-string">      &#125;</span><span class="hljs-string">    &#125;</span><span class="hljs-string">  &#125;</span><span class="hljs-string">`</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs"> 4.普通的csc会相互层叠，都会合并到全局的css中去，遭成影响到其他模块 5.less的编写方式  需要配置webpack   需要使用craco  目前针对creat-react-app 5 的配置 npm i @craco/craco@alpha</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>   <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco start&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco build&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;craco test&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-attr">&quot;eject&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts eject&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></div><p>​    </p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//craco.config.js</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">CracoLessPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;craco-less&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">plugins</span>: [    &#123;      <span class="hljs-attr">plugin</span>: <span class="hljs-title class_">CracoLessPlugin</span>,      <span class="hljs-attr">options</span>: &#123;        <span class="hljs-attr">lessLoaderOptions</span>: &#123;          <span class="hljs-attr">lessOptions</span>: &#123;            <span class="hljs-attr">modifyVars</span>: &#123; <span class="hljs-string">&#x27;@primary-color&#x27;</span>: <span class="hljs-string">&#x27;#1DA57A&#x27;</span> &#125;,            <span class="hljs-attr">javascriptEnabled</span>: <span class="hljs-literal">true</span>,          &#125;,        &#125;,      &#125;,    &#125;,  ],&#125;;</code></pre></div><h4 id="React中添加class"><a href="#React中添加class" class="headerlink" title="React中添加class"></a>React中添加class</h4><p>可以借助第三方库classnames</p><p> 34.axios中，axios({})这样是使用他默认创建的实例，如果要自己创建一个实例要使用axios.create({})</p><h4 id="react-transition-group"><a href="#react-transition-group" class="headerlink" title="react-transition-group"></a>react-transition-group</h4><p>  这个库可以帮助我们方便的实现组件的 入场 和 离场 动画，使用时需要进行额外的安装</p><div class="code-wrapper"><pre><code class="hljs sql">npm install react<span class="hljs-operator">-</span>transition<span class="hljs-operator">-</span><span class="hljs-keyword">group</span> <span class="hljs-comment">--save</span>yarn <span class="hljs-keyword">add</span> react<span class="hljs-operator">-</span>transition<span class="hljs-operator">-</span><span class="hljs-keyword">group</span></code></pre></div><p>react-transition-group主要包括四个组件</p><p>Tansition</p><p>​        该组件是一个和平台无关的组件（不一定要结合CSS）</p><p>​        在前端开发中，我们一般是结合CSS来完成样式，所以比较常用的是CSSTransition</p><p>CSSTransition</p><p>​        在前端开发中，通常使用CSSTransition来完成过渡动画</p><p>​        CSSTransition是基于Transition组件构建的</p><p>​        CSSTransition执行过程中，有三个状态：appear、enter、exit；</p><p>​        它们有三种状态，需要定义对应的CSS样式：</p><p>​        第一类，开始状态：对于的类是-appear、-enter、exit； </p><p>​        第二类：执行动画：对应的类是-appear-active、-enter-active、-exit-active； </p><p>​        第三类：执行结束：对应的类是-appear-done、-enter-done、-exit-done；</p><p>​        CSSTransition常用属性</p><p>​        in</p><p>​        classNames</p><p>​        timeout</p><p>​        appear</p><p>​        unmountOnExit</p><h6 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数:"></a>钩子函数:</h6><p>​                onEnter</p><p>​                onEntering</p><p>​                onEntered</p><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; createRef, PureComponent &#125; from &#x27;react&#x27;import &#123; CSSTransition &#125; from &quot;react-transition-group&quot;import &quot;./style.css&quot;export class App extends PureComponent &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      isShow: true    &#125;    this.sectionRef = createRef()  &#125;  render() &#123;    const &#123; isShow &#125; = this.state    return (      &lt;div&gt;        &lt;button onClick=&#123;e =&gt; this.setState(&#123;isShow: !isShow&#125;)&#125;&gt;切换&lt;/button&gt;        &#123;/* &#123; isShow &amp;&amp; &lt;h2&gt;哈哈哈&lt;/h2&gt; &#125; */&#125;        &lt;CSSTransition           nodeRef=&#123;this.sectionRef&#125;          in=&#123;isShow&#125;           unmountOnExit=&#123;true&#125;           classNames=&quot;why&quot;           timeout=&#123;2000&#125;          appear          onEnter=&#123;e =&gt; console.log(&quot;开始进入动画&quot;)&#125;          onEntering=&#123;e =&gt; console.log(&quot;执行进入动画&quot;)&#125;          onEntered=&#123;e =&gt; console.log(&quot;执行进入结束&quot;)&#125;          onExit=&#123;e =&gt; console.log(&quot;开始离开动画&quot;)&#125;          onExiting=&#123;e =&gt; console.log(&quot;执行离开动画&quot;)&#125;          onExited=&#123;e =&gt; console.log(&quot;执行离开结束&quot;)&#125;        &gt;          &lt;div className=&#x27;section&#x27; ref=&#123;this.sectionRef&#125;&gt;            &lt;h2&gt;哈哈哈&lt;/h2&gt;            &lt;p&gt;我是内容, 哈哈哈&lt;/p&gt;          &lt;/div&gt;        &lt;/CSSTransition&gt;      &lt;/div&gt;    )  &#125;&#125;export default App</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.why-appear</span>, <span class="hljs-selector-class">.why-enter</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.why-appear-active</span>, <span class="hljs-selector-class">.why-enter-active</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">2s</span> ease;&#125;<span class="hljs-comment">/* 离开动画 */</span><span class="hljs-selector-class">.why-exit</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.why-exit-active</span> &#123;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">2s</span> ease;&#125;</code></pre></div><p>SwitchTransition</p><p>​        两个组件显示和切换时，使用该组件</p><p>​        SwitchTransition中主要有一个属性：mode，有两个值</p><p>​            in-out：表示新组件先进入，旧组件再移除；</p><p>​            out-in：表示就组件先移除，新组建再进入</p><p>​        SwitchTransition组件里面要有CSSTransition或者Transition组件，不能直接包裹你想要切换的组件</p><p>​        SwitchTransition里面的CSSTransition或Transition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是 key属性</p><div class="code-wrapper"><pre><code class="hljs react">import React, &#123; PureComponent &#125; from &#x27;react&#x27;import &#123; SwitchTransition, CSSTransition &#125; from &#x27;react-transition-group&#x27;import &quot;./style.css&quot;export class App extends PureComponent &#123;  constructor() &#123;    super()     this.state = &#123;      isLogin: true    &#125;  &#125;  render() &#123;    const &#123; isLogin &#125; = this.state    return (      &lt;div&gt;        &lt;SwitchTransition mode=&#x27;out-in&#x27;&gt;          &lt;CSSTransition            key=&#123;isLogin ? &quot;exit&quot;: &quot;login&quot;&#125;            classNames=&quot;login&quot;            timeout=&#123;1000&#125;          &gt;            &lt;button onClick=&#123;e =&gt; this.setState(&#123; isLogin: !isLogin &#125;)&#125;&gt;              &#123; isLogin ? &quot;退出&quot;: &quot;登录&quot; &#125;            &lt;/button&gt;          &lt;/CSSTransition&gt;        &lt;/SwitchTransition&gt;      &lt;/div&gt;    )  &#125;&#125;export default App</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.login-enter</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100px</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.login-enter-active</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;&#125;<span class="hljs-selector-class">.login-exit</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.login-exit-active</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100px</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;&#125;</code></pre></div><p>TransitionGroup</p><p>​        将多个组件包裹在其中，一般用于列表中的元素的动画</p><p>​        ◼ 当我们有一组动画时，需要将这些CSSTransition放入到一个TransitionGroup中来完成动画：</p><div class="code-wrapper"><pre><code class="hljs react">&lt;TransitionGroup component=&quot;ul&quot;&gt;         &#123;           books.map((item, index) =&gt; &#123;             return (               &lt;CSSTransition key=&#123;item.id&#125; classNames=&quot;book&quot; timeout=&#123;1000&#125;&gt;                 &lt;li&gt;                   &lt;span&gt;&#123;item.name&#125;-&#123;item.price&#125;&lt;/span&gt;                   &lt;button onClick=&#123;e =&gt; this.removeBook(index)&#125;&gt;删除&lt;/button&gt;                 &lt;/li&gt;               &lt;/CSSTransition&gt;             )           &#125;)         &#125;       &lt;/TransitionGroup&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.book-enter</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">150px</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.book-enter-active</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;&#125;<span class="hljs-selector-class">.book-exit</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;&#125;<span class="hljs-selector-class">.book-exit-active</span> &#123;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">150px</span>);  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">1s</span> ease;&#125;</code></pre></div><p>36.react纯函数<br> 37.node中对ES6模块化的支持 在13.2.0以后对es6的支持，需要在package.json中添加属性”type”:”module”,导入文件时要跟上.js后缀名<br> 38.redux<br>     redux主要是负责状态管理<br>     store:createStore(reducer,..)<br>     state:通过store.getState()来获取当前state<br>     react的组成<br>         action:是用来更新数据，所有的数据变化，必须通过dispatch来派发action来更新，action可以是一个对象，也可以是一个函数，函数必须返回一个对象<br>         reducer：是将state和action连接起来，reducer是一个纯函数，reducer是将传入的reducer和action整和成为一个新的state<br>         dispatch:用来派发action<br>     redux的三大原则<br>         1.单一数据源<br>         2.state是只读的<br>         3.使用纯函数来执行修改<br> 39.单向数据流<br> 40.react动画中<TransitionGroup>中需要再用<cssTransition>包裹,否则会报错<br> 41.react-router<br>     默认是模糊匹配<br> 42.react-hook<br>     import React from “react”//这个是在函数式组件和类组件都要写，因为jsx是React.createElement()的语法糖，会在内部调用<br>     useState()<br>     Hook的使用规则：<br>         只能在函数最外层调用Hook,不要在循环，条件判断或者子函数中调用<br>         只能在React的函数组件中调用Hook,不要再其他js函数中使用</p><div class="code-wrapper"><pre><code class="hljs">  const [count, setCount] = useState(() =&gt; 10);//useState可以传入一个函数</code></pre></div><p>  console.log(“CounterHook渲染”);</p><p>  function handleBtnClick() {<br>    // setCount(count + 10);</p><p>​    setCount((prevCount) =&gt; prevCount + 10);//preCount是上一个count<br>​<br>​    如果你的更新函数返回值与当前 state 完全相同，则随后的重渲染会被完全跳过。<br>​    与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的     setState 结合展开运算符来达到合并更新对象的效果。<br>​    setState(prevState =&gt; {<br>​      // 也可以使用 Object.assign<br>​      return {…prevState, …updatedValues};<br>​    });<br>​    useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><p> 43.useEffect()<br>     useEffect(() =&gt; {<br>    console.log(“订阅一些事件”);</p><p>​    return () =&gt; {<br>​      console.log(“取消订阅事件”)<br>​    }<br>  }, []);//通过返回一个函数来执行类似componmentwillumnount来清除副作用，[]这个可以作为优化，只有在组件切换时才执行，[]只会执行一次，相当于是componentDiMount,componentWillUnmount<br>  44.useEffect第二个参数<br>   useEffect(() =&gt; {<br>​    console.log(“修改DOM”, count);<br>  }, [count]);//useEffect可以让某个属性发生改变时才执行，这个属性必须在useEffect的回调函数中有使用到<br>  如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行。这并不属于特殊情况 —— 它依然遵循依赖数组的工作方式。</p><p>使用多个useEffect可以分开使用，执行的时候会挨个执行</p><h4 id="45-useContext的使用"><a href="#45-useContext的使用" class="headerlink" title="45.useContext的使用"></a>45.useContext的使用</h4><p>​    useContext可以让多个Context传递给函数式组件的时候减少consumer的嵌套</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));root.<span class="hljs-title function_">render</span>(  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;name:</span> &quot;<span class="hljs-attr">why</span>&quot;, <span class="hljs-attr">level:</span> <span class="hljs-attr">99</span>&#125;&#125;&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">TokenContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span>&#x27;<span class="hljs-attr">coderwhy</span>&#x27;&#125;&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">TokenContext.Provider</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">UserContext.Provider</span>&gt;</span></span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UserContext</span>, <span class="hljs-title class_">ThemeContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./context&quot;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 使用Context</span>  <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">UserContext</span>)  <span class="hljs-keyword">const</span> theme = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>)  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>User: &#123;user.name&#125;-&#123;user.level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;color:</span> <span class="hljs-attr">theme.color</span>, <span class="hljs-attr">fontSize:</span> <span class="hljs-attr">theme.size</span>&#125;&#125;&gt;</span>Theme<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div><h4 id="46-useCallback的使用"><a href="#46-useCallback的使用" class="headerlink" title="46.useCallback的使用"></a>46.useCallback的使用</h4><p>useReducer不是redux的替代品，useReducer仅仅是useState的一种替代方案。在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分，或者这次修改的state需要依赖之前的state时，也可以使用。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;  <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + <span class="hljs-number">1</span> &#125;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> - <span class="hljs-number">1</span> &#125;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add_number&quot;</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + action.<span class="hljs-property">num</span> &#125;    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sub_number&quot;</span>:      <span class="hljs-keyword">return</span> &#123; ...state, <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> - action.<span class="hljs-property">num</span> &#125;    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">return</span> state  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html">const [state, dispatch] = useReducer(reducer, &#123; counter: 0, friends: [], user: &#123;&#125; &#125;)     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;increment&quot;&#125;)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;decrement&quot;&#125;)&#125;&gt;-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;add_number&quot;, num: 5&#125;)&#125;&gt;+5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;sub_number&quot;, num: 5&#125;)&#125;&gt;-5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> dispatch(&#123;type: &quot;add_number&quot;, num: 100&#125;)&#125;&gt;+100<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div><h4 id="47-useMemo的使用"><a href="#47-useMemo的使用" class="headerlink" title="47.useMemo的使用"></a>47.useMemo的使用</h4><p>在进行大量的计算的时候，使用useMemo可以避免重复的渲染</p><p>可以对子组件传递相同内容的对象的时候避免重新渲染</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">import</span> &#123; useMemo, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HelloWorld被渲染~&quot;</span>)  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>&#125;)<span class="hljs-keyword">function</span> <span class="hljs-title function_">calcNumTotal</span>(<span class="hljs-params">num</span>) &#123;  <span class="hljs-comment">// console.log(&quot;calcNumTotal的计算过程被调用~&quot;)</span>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;    total += i  &#125;  <span class="hljs-keyword">return</span> total&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-comment">// const result = calcNumTotal(50)</span>  <span class="hljs-comment">// 1.不依赖任何的值, 进行计算</span>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title function_">calcNumTotal</span>(<span class="hljs-number">50</span>)  &#125;, [])  <span class="hljs-comment">// 2.依赖count</span>  <span class="hljs-comment">// const result = useMemo(() =&gt; &#123;</span>  <span class="hljs-comment">//   return calcNumTotal(count*2)</span>  <span class="hljs-comment">// &#125;, [count])</span>  <span class="hljs-comment">// 3.useMemo和useCallback的对比</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;&#125;  <span class="hljs-comment">// const increment = useCallback(fn, [])</span>  <span class="hljs-comment">// const increment2 = useMemo(() =&gt; fn, [])</span>  <span class="hljs-comment">// 4.使用useMemo对子组件渲染进行优化</span>  <span class="hljs-comment">// const info = &#123; name: &quot;why&quot;, age: 18 &#125;</span>  <span class="hljs-keyword">const</span> info = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> (&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;), [])  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计算结果: &#123;result&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计数器: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setCount(count+1)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">result</span>=<span class="hljs-string">&#123;result&#125;</span> <span class="hljs-attr">info</span>=<span class="hljs-string">&#123;info&#125;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div><p>48.useCallback是针对回调函数进行优化，useMemo是对返回值进行优化。userCallback可以用于传递给被pureComponent或者memo包裹的子组件的函数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useState, useCallback, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-comment">// useCallback性能优化的点:</span><span class="hljs-comment">// 1.当需要将一个函数传递给子组件时, 最好使用useCallback进行优化, 将优化之后的函数, 传递给子组件</span><span class="hljs-comment">//如果没有使用usecallback，函数式组件在发生更新的时候，所有代码都会重新执行，传递给子组件的函数会重新生成，如果使用usecallback,会根据第二个参数数组中的值，是否生成新的函数，使子组件是否重新渲染</span><span class="hljs-comment">// props中的属性发生改变时, 组件本身就会被重新渲染，</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HYHome</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-keyword">const</span> &#123; increment &#125; = props  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;HYHome被渲染&quot;</span>)  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>increment+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">      &#123;/* 100个子组件 */&#125;</span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)  <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;hello&quot;</span>)  <span class="hljs-comment">// 闭包陷阱: useCallback  解决闭包陷阱方式一，但是会生成新的函数</span>  <span class="hljs-comment">// const increment = useCallback(function foo() &#123;</span>  <span class="hljs-comment">//   console.log(&quot;increment&quot;)</span>  <span class="hljs-comment">//   setCount(count+1)</span>  <span class="hljs-comment">// &#125;, [count])</span>  <span class="hljs-comment">// 进一步的优化: 当count发生改变时, 也使用同一个函数(了解)</span>  <span class="hljs-comment">// 做法一: 将count依赖移除掉, 缺点: 闭包陷阱,因为此时的foo和原来的foo不是同一个foo,而原来的foo依然使用之前的count</span>  <span class="hljs-comment">// const increment = useCallback(function foo() &#123;</span>  <span class="hljs-comment">//   console.log(&quot;increment&quot;)</span>  <span class="hljs-comment">//   setCount(count+1)</span>  <span class="hljs-comment">// &#125;, [])</span>  <span class="hljs-comment">// 做法二: useRef, 在组件多次渲染时, 返回的是同一个值</span>  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>()  countRef.<span class="hljs-property">current</span> = count  <span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">useCallback</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;increment&quot;</span>)    <span class="hljs-title function_">setCount</span>(countRef.<span class="hljs-property">current</span> + <span class="hljs-number">1</span>)  &#125;, [])  <span class="hljs-comment">// 普通的函数</span>  <span class="hljs-comment">// const increment = () =&gt; &#123;</span>  <span class="hljs-comment">//   setCount(count+1)</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>计数: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;increment&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HYHome</span> <span class="hljs-attr">increment</span>=<span class="hljs-string">&#123;increment&#125;/</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>message:&#123;message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setMessage(Math.random())&#125;&gt;修改message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-comment">// function foo(name) &#123;</span><span class="hljs-comment">//   function bar() &#123;</span><span class="hljs-comment">//     console.log(name)</span><span class="hljs-comment">//   &#125;</span><span class="hljs-comment">//   return bar</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// const bar1 = foo(&quot;why&quot;)</span><span class="hljs-comment">// bar1() // why</span><span class="hljs-comment">// bar1() // why</span><span class="hljs-comment">// const bar2 = foo(&quot;kobe&quot;)</span><span class="hljs-comment">// bar2() // kobe</span><span class="hljs-comment">// bar1() // why</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div><p>useCallback会返回一个函数的memoized(记忆的)，在依赖不变的情况下，多次定义的时候，返回的值是相同的。通常使用useCallback的目的是不希望子组件进行多次渲染，并不是为了函数继续缓存</p><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>useRef返回一个ref对象，返回的ref对象再组件的整个生命周期保持不变，会指向同一个对象</p><p>useRef的两种用法：</p><p>​    用法一：引入DOM(或者组件，但是需要class组件)元素</p><p>​    用法二： 保存一个数据，这个对象在整个生命周期可以保持不变</p><p>49.Refs的转发<br>      就是父组件想获取到子组件的ref,在高阶组件中转发refs<br>      可以使用React.forwardRef()<br>      const ref=useRef(initialValue)//初始化值后不会发生改变    </p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RefHookDemo02</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);  <span class="hljs-keyword">const</span> numRef = <span class="hljs-title function_">useRef</span>(count);  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;    numRef.<span class="hljs-property">current</span> = count;  &#125;, [count])  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      &#123;/* <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>numRef中的值: &#123;numRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count中的值: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> */&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count上一次的值: &#123;numRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>count这一次的值: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setCount(count + 10)&#125;&gt;+10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;<span class="hljs-comment">//useEffect和useRef结合使用可以修改numRef.current</span></code></pre></div><p>50.useImperativeHandle要和React.forwardRef()一起使用</p><p>通过forwardRef可以将ref转发到子组件，获取到子组件内部的ref,子组件拿到父组件创建的ref绑定到某个元素上，forwordRef会将子组件的DOM暴露给父组件，父组件拿到DOM之后可以任意操作，可以使用useImperativeHandle暴露固定的操作</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; memo, useRef, forwardRef, useImperativeHandle &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloWorld</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>()  <span class="hljs-comment">// 子组件对父组件传入的ref进行处理</span>  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">return</span> &#123;      <span class="hljs-title function_">focus</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;focus&quot;</span>)        inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()      &#125;,      <span class="hljs-title function_">setValue</span>(<span class="hljs-params">value</span>) &#123;        inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span> = value      &#125;    &#125;  &#125;)  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;/</span>&gt;</span></span>&#125;))<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> titleRef = <span class="hljs-title function_">useRef</span>()  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>()  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleDOM</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// console.log(inputRef.current)</span>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()    <span class="hljs-comment">// inputRef.current.value = &quot;&quot;</span>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">setValue</span>(<span class="hljs-string">&quot;哈哈哈&quot;</span>)  &#125;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;titleRef&#125;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputRef&#125;/</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleDOM&#125;</span>&gt;</span>DOM操作<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span></code></pre></div><p>51.自定义hook：就是将react的hook封装成函数<br>52.fiber的原理<br>53.不要在条件表达式中使用hook<br>54.使用normailze.css对项目进行初始化<br>    使用@craco/craco修改react 配置<br>        修改webpack的alias<br>    使用react-config-router进行路由配置<br>    使用styled-compoments进行写css样式<br>        background:url(${reuire()})//需要使用require来引入图片<br>        搜索框使用antDesign<br>        数据都是用redux来管理<br>        用redux-thunk进行异步请求<br>        配置redux-devtool<br>        将各个模块的redux分开写再各个文件中，然后进行合并，使用combineReducers<br>        store使用Provider进行传递<br>        所有组件用memo()包裹管理<br>        使用redux的hook:useDispatch()<br>                       useSelector(state=&gt;({}),shallowEqual)<br>                       shallowEqual//进行浅层比较,做优化<br>        Immutablejs可以解决使用拷贝来决绝数据可变性的问题，带来的性能问题        </p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> im=immutable<span class="hljs-keyword">const</span> info=&#123;&#125;<span class="hljs-keyword">const</span> imfoIM=im(info)imfoIm.<span class="hljs-keyword">set</span>()imfoIM.<span class="hljs-keyword">get</span>()imfoIm.list()imfoim.fromJS()<span class="hljs-comment">//深层次转换</span></code></pre></div><p>​        2.只能再react函数中调用成immutable类型<br>​            state.getIn([“a”,”b”])//相当于a.b<br>​            styled-components的传参<br>​            使用useCallback对需要传给子组件的函数进行包裹，可以有缓存，并提高性能<br>​<br>​            使用 redux-immutable中的commineReducer来优化combineReducer,提高性能</p><p>55 Hook的本质就是javascript函数，他要遵循两条规则<br>    1.只在最顶层使用hook<br>        不要再循环，条件或者嵌套函数中调用hook,确保总是再你的react函数的最顶层去调用他们<br>        遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确<br>    2.只能再react函数中调用Hook<br>      不要在普通的javascript中调用hook,可以在reat函数组件中调用hook,也可以在在定义hook中调用其他hook<br>56.自定义HOOK一定要以use开头<br>57.在两个组件中使用相同的 Hook 会共享 state 吗？不会。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。<br>58.自定义 Hook 如何获取独立的 state？每次调用 Hook，它都会获取独立的 state<br>    由于我们直接调用了 useFriendStatus，从 React 的角度来看，我们的组件只是调用了 useState 和 useEffect<br>59.惰性初始化state</p><p><code>initialState</code> 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, <span class="hljs-built_in">set</span>State] = useState(() =&gt; &#123;  <span class="hljs-keyword">const</span> initialState = someExpensiveComputation(props);  return initialState;&#125;);</code></pre></div><h4 id="60-useEffect是在每一轮渲染结束后执行"><a href="#60-useEffect是在每一轮渲染结束后执行" class="headerlink" title="60.useEffect是在每一轮渲染结束后执行"></a>60.useEffect是在每一轮渲染结束后执行</h4><p>61.组件卸载时需要清除effect创建的订阅，定时器等，useEffect函数需要返回一个清理函数</p><div class="code-wrapper"><pre><code class="hljs abnf">useEffect(() <span class="hljs-operator">=</span>&gt; &#123;  const subscription <span class="hljs-operator">=</span> props.source.subscribe()<span class="hljs-comment">;</span>  return () <span class="hljs-operator">=</span>&gt; &#123;    // 清除订阅    subscription.unsubscribe()<span class="hljs-comment">;</span>  &#125;<span class="hljs-comment">;</span>&#125;)<span class="hljs-comment">;</span></code></pre></div><p>为防止内存泄漏，清除函数会在组件卸载之前执行。另外，如果组件多次渲染，则会在子啊个effect之前，上一个effect就会被清除</p><h6 id="62-effect的执行时机"><a href="#62-effect的执行时机" class="headerlink" title="62.effect的执行时机"></a>62.effect的执行时机</h6><p>与componentDidMount,cimponentDidUpadate不同的是，在浏览器完成布局与绘制之后，</p><p>传给useEffect的函数会延迟调用，这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理情况，因此不应在函数值执行阻塞浏览器更新的操作</p><h6 id="63-useContext"><a href="#63-useContext" class="headerlink" title="63.useContext"></a>63.useContext</h6><div class="code-wrapper"><pre><code class="hljs reasonml">const MyContext= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>create<span class="hljs-constructor">Context(<span class="hljs-params">value</span>)</span>const value = use<span class="hljs-constructor">Context(MyContext)</span>;</code></pre></div><p>myContext是React.createContext的返回值，并返回该context的当前值，当前的value值由</p><p>他的上层组件距离当前组件最近的&lt;MyContext.Provider&gt;的value prop决定的</p><p>当Provider中的value发生更新的时候，useContext就会出发重新渲染，即使组件时使用React.emo包裹，或者使用shouldComponentUpdat生命周期，该组件都会重新渲染</p><p>只要MyConetext里面的值发生改变，使用了useContext的组件都会重新渲染，如果重新渲染开销大，可以使用memoization来优化</p><p>useContext(MyContext)===&gt;class中的static contextType=MyContext或者&lt;MyContext.Consumer&gt;</p><p><code>useContext(MyContext)</code> 只是让你能够<em>读取</em> context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件<em>提供</em> context。</p><h6 id="64-useReducer"><a href="#64-useReducer" class="headerlink" title="64.useReducer"></a>64.<code>useReducer</code></h6><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init);useState的替代方案在某些场合会比useState更加适用，例如 <span class="hljs-keyword">state</span> 逻辑较复杂且包含多个子值，或者下一个 <span class="hljs-keyword">state</span> 依赖于之前的 <span class="hljs-keyword">state</span> 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。</code></pre></div><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> initialState = &#123;count: <span class="hljs-number">0</span>&#125;;function reducer(<span class="hljs-keyword">state</span>, action) &#123;  switch (action.type) &#123;    case &#x27;increment&#x27;:      return &#123;count: <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span>&#125;;    case &#x27;decrement&#x27;:      return &#123;count: <span class="hljs-keyword">state</span>.count - <span class="hljs-number">1</span>&#125;;    <span class="hljs-keyword">default</span>:      throw new Error();  &#125;&#125;function Counter() &#123;  <span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialState);  return (    <span class="hljs-variable">&lt;&gt;</span>      Count: &#123;<span class="hljs-keyword">state</span>.count&#125;      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt;      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt;    &lt;/&gt;  );&#125;</code></pre></div><h4 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h4><p>useReducer的第三个参数传入一个函数，这样初始state将设置为传入函数的返回值</p><p>可以通过外部来传入</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">initialCount</span>) &#123;  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: initialCount&#125;;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) &#123;  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>&#125;;    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:      <span class="hljs-keyword">return</span> <span class="hljs-title function_">init</span>(action.<span class="hljs-property">payload</span>);    <span class="hljs-attr">default</span>:      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">&#123;initialCount&#125;</span>) &#123;  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialCount, init);  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><span class="language-xml">      Count: &#123;state.count&#125;</span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reset&#x27;, payload: initialCount&#125;)&#125;&gt;</span><span class="language-xml">        Reset</span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span>  );&#125;</code></pre></div><p>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description"><code>Object.is</code> 比较算法</a> 来比较 state。）</p><p>如果你在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code> 来进行优化。</p><p>useReducer不可以作为redux的替代方案，不可以进行数据共享</p><p>65.使用memo包裹函数，可以进行性能优化，会对props进行浅层比较，如果props没有发生更新，则不会重新渲染</p><p>66.没有优化以前。父组件发生改变子组件也会重新渲染</p><p>67.useCallback</p><p>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 <code>shouldComponentUpdate</code>）的子组件时，它将非常有用。</p><p><img src="https://img1.imgtp.com/2022/09/12/JXSSiW1v.png" alt="QQ截图20220620112711.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/7N1MVzzM.png" alt="QQ截图20220620112901.png"></p><p>68.useMeno</p><p>​    <code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code>。</p><p>useCallback是返回<a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> 回调函数。useMeno是返回一个memoized值</p><p>useMemo只会在依赖项发生改变时才会重新计算执行，返回新的值，避免每次渲染时都进行高开销的计算</p><p>记住，传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p><p>如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值</p><p><img src="https://img1.imgtp.com/2022/09/12/YMPGqZBu.png" alt="QQ截图20220620131653.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/9Z0ICdSV.png" alt="QQ截图20220620131701.png"></p><p>69.useRef</p><p>useRef返回一个ref对象，返回的ref对象在组件的整个生命周期保持不变</p><p>最常用的ref是两种用法</p><p>​    1.引入DOM(或者是class组件)元素，不可以用在函数组件中</p><p>​    2.保存一个数据，这个对象在整个生命周期中可以保持不变</p><p><img src="https://img1.imgtp.com/2022/09/12/dwdJVSSg.png" alt="QQ截图20220620143141.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/emUNGaLF.png" alt="QQ截图20220620143158.png"></p><p>70.<code>useImperativeHandle</code></p><p>useImperativeHandle要和forwardRef结合使用，使用useImperativeHandle可以使父元素不可以对子组件中的ref进行随意操作</p><p><img src="https://img1.imgtp.com/2022/09/12/Ey8AqNSp.png" alt="QQ截图20220620143648.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/crDRrvA5.png" alt="QQ截图20220620143735.png"></p><p>71.useLayoutEffect</p><p>​    和useEffect的区别是</p><p>​    useEffect会在渲染的内容更新到DOM之后再执行，而不会阻塞DOM的更新</p><p>​    useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新</p><p>​    <img src="https://img1.imgtp.com/2022/09/12/Zgl2puzy.png" alt="QQ截图20220620144244.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/a6VmoNdR.png" alt="QQ截图20220620144253.png"></p><p>72.redux-thunk</p><p>​     使用中间件目的是再dispatch的action和reducer之间扩展自己的代码，例如日志记录，调用异步接口，添加代码调试功能等等</p><p>​    可以使用redux-thunk发送异步请求</p><p>​    1.通常情况下。dispatch(action),actionn余姚是一个javascript对象</p><p>​    2.redux-thunk可以让dispatch(action函数)，action可以是一个函数</p><p>​    3.这个函数被调用的时候，会返回一个函数并给这个函数传一个patch,getState函数</p><p>​                dispatch函数用于再次派发action</p><p>​                getState函数获取到之前的状态</p><p><img src="C:\Users\10152\Desktop\study\memo\React\QQ截图20220620161818.png"></p><p><img src="https://img1.imgtp.com/2022/09/12/DaBjyVoU.png" alt="QQ截图20220620162945.png"></p><h6 id="73-redux-devtools"><a href="#73-redux-devtools" class="headerlink" title="73.redux-devtools"></a>73.redux-devtools</h6><p>是用来对redux中的状态进行跟踪调试</p><p><img src="https://img1.imgtp.com/2022/09/12/QsLGVWW4.png" alt="QQ截图20220620163435.png"></p><h5 id="74-combineReducers"><a href="#74-combineReducers" class="headerlink" title="74.combineReducers"></a>74.combineReducers</h5><p>redux中提供了一个函数combineReducers来合并多个reducer</p><p>combinerReducer的实现</p><p>​    它会将reducer合并，并且返回一个combation函数相当于是新的reducer</p><p>​    在执行combination函数的过程中，它会通过判断前后返回的数据是否相同来决定返回之前的state还是新的state；</p><p>   新的state会触发订阅者发生对应的刷新，而旧的state可以有效的组织订阅者发生刷新；</p><p><img src="https://img1.imgtp.com/2022/09/12/lfwbA1yr.png" alt="QQ截图20220620163958.png"></p><h5 id="75-useSelector"><a href="#75-useSelector" class="headerlink" title="75.useSelector()"></a>75.useSelector()</h5><div class="code-wrapper"><pre><code class="hljs pf">import React <span class="hljs-keyword">from</span> &#x27;react&#x27;import &#123; shallowEqual, useSelector &#125; <span class="hljs-keyword">from</span> &#x27;react-redux&#x27;export <span class="hljs-keyword">const</span> CounterComponent = () =&gt; &#123;  <span class="hljs-keyword">const</span> counter = useSelector((<span class="hljs-keyword">state</span>) =&gt; <span class="hljs-keyword">state</span>.counter,shallowEqual)  return <span class="hljs-variable">&lt;div&gt;</span>&#123;counter&#125;&lt;/div&gt;&#125;//在hook中使用redux,使用useSlectore来获取<span class="hljs-keyword">state</span></code></pre></div><h5 id="76-useDispatch"><a href="#76-useDispatch" class="headerlink" title="76.useDispatch()"></a>76.<code>useDispatch()</code></h5><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> dispatch = useDispatch()<span class="hljs-comment">//派发action</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs smali">export<span class="hljs-built_in"> const </span>Todos = () =&gt; &#123; <span class="hljs-built_in"> const </span>dispatch = useDispatch()  useEffect(() =&gt; &#123;    dispatch(fetchTodos())    // Safe to<span class="hljs-built_in"> add </span>dispatch to the dependencies<span class="hljs-built_in"> array</span><span class="hljs-built_in"></span>  &#125;, [dispatch])&#125;</code></pre></div><h5 id="77-useStore"><a href="#77-useStore" class="headerlink" title="77.useStore()"></a>77.<code>useStore()</code></h5><p>替代createStore()</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pinia笔记</title>
    <link href="/2022/08/23/pinia%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/23/pinia%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="Pinia和Vuex的区别"><a href="#Pinia和Vuex的区别" class="headerlink" title="Pinia和Vuex的区别"></a>Pinia和Vuex的区别</h4><p>Pinia主要是来替代Vuex的，pinia有更加简单的api，提供了composition api,和typesctript一起使用有更加可靠的类型推断支持</p><p>和vuex相比，pinia有很多优势</p><p>例如mutation不再存在</p><p>更好的typescript支持，vuex之前对ts的支持很不友好</p><p>不再有modules的嵌套解构，你可以灵活的使用每一个store，他们是通过扁平化的方式来进行相互使用</p><p>不再有命名空间的概念，不需要记住他们的复杂关系</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><div class="code-wrapper"><pre><code class="hljs mipsasm">yarn <span class="hljs-keyword">add </span>pinia<span class="hljs-comment"># or with npm</span>npm <span class="hljs-keyword">install </span>pinia</code></pre></div><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在vue3+vite中的使用</p><p>stores/index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> pinia</code></pre></div><p>main.js</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-keyword">import</span> pinia <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./stores&#x27;</span>createApp(App).use(pinia).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><h4 id="认识Store"><a href="#认识Store" class="headerlink" title="认识Store"></a>认识Store</h4><h5 id="什么是store"><a href="#什么是store" class="headerlink" title="什么是store"></a>什么是store</h5><p>一个store是一个实体，他会持有为绑定到组件树的状态和业务逻辑，换句话说，<strong>它托管全局状态</strong>。它有点像一个始终存在并且每个人都可以读取和写入的组件。你可以定义任意个store来管理你的状态。</p><h5 id="store有三个核心概念"><a href="#store有三个核心概念" class="headerlink" title="store有三个核心概念"></a>store有三个核心概念</h5><p>state，actions，getters，对应者数组的data，computed，methods</p><p>一旦store被实例化，你就可以直接在store上访问state，getters，actions中的任意属性</p><h4 id="定义Store"><a href="#定义Store" class="headerlink" title="定义Store"></a>定义Store</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><span class="hljs-keyword">const</span> useUser = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&quot;user&quot;</span>, &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <span class="hljs-attr">level</span>: <span class="hljs-number">100</span>  &#125;)&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useUser<span class="hljs-comment">//使用defineStore来定义store</span></code></pre></div><p>与Vue的Option API 类型类似的写法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Eduardo&#x27;</span> &#125;),  <span class="hljs-attr">getters</span>: &#123;    <span class="hljs-attr">doubleCount</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>,  &#125;,  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++    &#125;,  &#125;,&#125;)</code></pre></div><p>还有一种和setup函数类似的方法。我们可以传入一个定义响应式属性和方法的函数，并返回一个包含我们想要公开的属性和方法的对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//state</span>  <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Eduardo&#x27;</span>)  <span class="hljs-keyword">const</span> doubleCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>)<span class="hljs-comment">//getters</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;    count.<span class="hljs-property">value</span>++  &#125;<span class="hljs-comment">//actions</span>  <span class="hljs-keyword">return</span> &#123; count, name, doubleCount, increment &#125;&#125;)</code></pre></div><p>在组件中的使用</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;  <span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>  <span class="hljs-keyword">import</span> &#123; storeToRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>  <span class="hljs-keyword">import</span> useCounter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/stores/counter&#x27;</span>;  <span class="hljs-keyword">const</span> counterStore = <span class="hljs-title function_">useCounter</span>()<span class="hljs-comment">//如果需要解构state并保持响应性，可以使用toRefs/storeToRefs</span><span class="hljs-comment">// const &#123; count &#125; = toRefs(counterStore)</span>  <span class="hljs-keyword">const</span> &#123; count &#125; = <span class="hljs-title function_">storeToRefs</span>(counterStore)  <span class="hljs-keyword">function</span> <span class="hljs-title function_">incrementCount</span>(<span class="hljs-params"></span>) &#123;    counterStore.<span class="hljs-property">count</span>++  &#125;&lt;/script&gt;</code></pre></div><h4 id="state的使用"><a href="#state的使用" class="headerlink" title="state的使用"></a><code>state</code>的使用</h4><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> store = useStore()store.<span class="hljs-keyword">count</span>++</code></pre></div><p>重置state</p><div class="code-wrapper"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> store = useStore()store.$reset()</code></pre></div><div class="code-wrapper"><pre><code class="hljs pf"> // <span class="hljs-number">1</span>.一个个修改状态     <span class="hljs-keyword">user</span>Store.name = <span class="hljs-string">&quot;kobe&quot;</span>     <span class="hljs-keyword">user</span>Store.age = <span class="hljs-number">20</span>     <span class="hljs-keyword">user</span>Store.level = <span class="hljs-number">200</span>    // <span class="hljs-number">2</span>.一次性修改多个状态     <span class="hljs-keyword">user</span>Store.<span class="hljs-variable">$patch</span>(&#123;       name: <span class="hljs-string">&quot;james&quot;</span>,       age: <span class="hljs-number">35</span>     &#125;)  //<span class="hljs-variable">$patch</span>还可以传入一个函数  cartStore.<span class="hljs-variable">$patch</span>((<span class="hljs-keyword">state</span>) =&gt; &#123;  <span class="hljs-keyword">state</span>.items.push(&#123; name: &#x27;shoes&#x27;, quantity: <span class="hljs-number">1</span> &#125;)  <span class="hljs-keyword">state</span>.hasChanged = true&#125;)</code></pre></div><p>替换state</p><p>你不能替换整个state,可以整合它</p><div class="code-wrapper"><pre><code class="hljs reasonml">store.<span class="hljs-constructor">$patch(&#123; <span class="hljs-params">count</span>: 24 &#125;)</span></code></pre></div><h4 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">getters</span>: &#123;    <span class="hljs-comment">// 1.基本使用</span>    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-comment">// 2.一个getter引入另外一个getter</span>    <span class="hljs-title function_">doubleCountAddOne</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-comment">// this是store实例</span>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">doubleCount</span> + <span class="hljs-number">1</span>    &#125;,    <span class="hljs-comment">// 3.getters也支持返回一个函数</span>    <span class="hljs-title function_">getFriendById</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; state.<span class="hljs-property">friends</span>.<span class="hljs-property">length</span>; i++) &#123;          <span class="hljs-keyword">const</span> friend = state.<span class="hljs-property">friends</span>[i]          <span class="hljs-keyword">if</span> (friend.<span class="hljs-property">id</span> === id) &#123;            <span class="hljs-keyword">return</span> friend          &#125;        &#125;      &#125;    &#125;,    <span class="hljs-comment">// 4.getters中用到别的store中的数据</span>    <span class="hljs-title function_">showMessage</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-comment">// 1.获取user信息</span>      <span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUser</span>()      <span class="hljs-comment">// 2.获取自己的信息</span>      <span class="hljs-comment">// 3.拼接信息</span>      <span class="hljs-keyword">return</span> <span class="hljs-string">`name:<span class="hljs-subst">$&#123;userStore.name&#125;</span>-count:<span class="hljs-subst">$&#123;state.count&#125;</span>`</span>    &#125;  &#125;,</code></pre></div><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>actions相当于是methods</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,  &#125;),  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-comment">// since we rely on `this`, we cannot use an arrow function</span>      <span class="hljs-comment">//这里依赖this,所以不能使用箭头函数</span>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++    &#125;,    <span class="hljs-title function_">randomizeCounter</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">100</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>())    &#125;,  &#125;,&#125;)</code></pre></div><p>在actions中可以定义异步函数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mande &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mande&#x27;</span><span class="hljs-keyword">const</span> api = <span class="hljs-title function_">mande</span>(<span class="hljs-string">&#x27;/api/users&#x27;</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUsers = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;users&#x27;</span>, &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-attr">userData</span>: <span class="hljs-literal">null</span>,    <span class="hljs-comment">// ...</span>  &#125;),  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-keyword">async</span> <span class="hljs-title function_">registerUser</span>(<span class="hljs-params">login, password</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">userData</span> = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">post</span>(&#123; login, password &#125;)        <span class="hljs-title function_">showTooltip</span>(<span class="hljs-string">`Welcome back <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.userData.name&#125;</span>!`</span>)      &#125; <span class="hljs-keyword">catch</span> (error) &#123;        <span class="hljs-title function_">showTooltip</span>(error)        <span class="hljs-comment">// let the form component display the error</span>        <span class="hljs-keyword">return</span> error      &#125;    &#125;,  &#125;,&#125;)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex4.0</title>
    <link href="/2022/08/23/vuex4-0/"/>
    <url>/2022/08/23/vuex4-0/</url>
    
    <content type="html"><![CDATA[<h4 id="Vuex-是什么"><a href="#Vuex-是什么" class="headerlink" title="Vuex 是什么"></a>Vuex 是什么</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式 + 库</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p><img src="https://vuex.vuejs.org/vuex.png"></p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install vuex@next --save</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//store/index.js</span><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">CHANGE_INFO</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mutation_types&#x27;</span><span class="hljs-keyword">import</span> homeModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/home&#x27;</span><span class="hljs-keyword">import</span> counterModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/counter&#x27;</span><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;    <span class="hljs-comment">// 模拟数据</span>    <span class="hljs-comment">// counter: 100,</span>    <span class="hljs-attr">rootCounter</span>: <span class="hljs-number">100</span>,    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;coderwhy&quot;</span>,    <span class="hljs-attr">level</span>: <span class="hljs-number">100</span>,    <span class="hljs-attr">avatarURL</span>: <span class="hljs-string">&quot;http://xxxxxx&quot;</span>,    <span class="hljs-attr">friends</span>: [      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">111</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">112</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;,      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">113</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;james&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;    ],    <span class="hljs-comment">// 服务器数据</span>    <span class="hljs-comment">// banners: [],</span>    <span class="hljs-comment">// recommends: []</span>  &#125;),  <span class="hljs-attr">getters</span>: &#123;    <span class="hljs-comment">// 1.基本使用</span>    <span class="hljs-title function_">doubleCounter</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">counter</span> * <span class="hljs-number">2</span>    &#125;,    <span class="hljs-title function_">totalAge</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">friends</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">preValue, item</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> preValue + item.<span class="hljs-property">age</span>      &#125;, <span class="hljs-number">0</span>)    &#125;,    <span class="hljs-comment">// 2.在该getters属性中, 获取其他的getters</span>    <span class="hljs-title function_">message</span>(<span class="hljs-params">state, getters</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">`name:<span class="hljs-subst">$&#123;state.name&#125;</span> level:<span class="hljs-subst">$&#123;state.level&#125;</span> friendTotalAge:<span class="hljs-subst">$&#123;getters.totalAge&#125;</span>`</span>    &#125;,    <span class="hljs-comment">// 3.getters是可以返回一个函数的, 调用这个函数可以传入参数(了解)</span>    <span class="hljs-title function_">getFriendById</span>(<span class="hljs-params">state</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) &#123;        <span class="hljs-keyword">const</span> friend = state.<span class="hljs-property">friends</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === id)        <span class="hljs-keyword">return</span> friend      &#125;    &#125;  &#125;,  <span class="hljs-attr">mutations</span>: &#123;    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;      state.<span class="hljs-property">counter</span>++    &#125;,    <span class="hljs-title function_">changeName</span>(<span class="hljs-params">state, payload</span>) &#123;      state.<span class="hljs-property">name</span> = payload    &#125;,    <span class="hljs-title function_">incrementLevel</span>(<span class="hljs-params">state</span>) &#123;      state.<span class="hljs-property">level</span>++    &#125;,     <span class="hljs-comment">//使用计算属性，将常量作为参数名</span>    [<span class="hljs-variable constant_">CHANGE_INFO</span>](state, newInfo) &#123;      state.<span class="hljs-property">level</span> = newInfo.<span class="hljs-property">level</span>      state.<span class="hljs-property">name</span> = newInfo.<span class="hljs-property">name</span>      <span class="hljs-comment">// 重要的原则: 不要在mutation方法中执行异步操作</span>      <span class="hljs-comment">// fetch(&quot;xxxx&quot;).then(res =&gt; &#123;</span>      <span class="hljs-comment">//   res.json().then(res =&gt; &#123;</span>      <span class="hljs-comment">//     state.name = res.name</span>      <span class="hljs-comment">//   &#125;)</span>      <span class="hljs-comment">// &#125;)</span>    &#125;,    <span class="hljs-comment">// changeBanners(state, banners) &#123;</span>    <span class="hljs-comment">//   state.banners = banners</span>    <span class="hljs-comment">// &#125;,</span>    <span class="hljs-comment">// changeRecommends(state, recommends) &#123;</span>    <span class="hljs-comment">//   state.recommends = recommends</span>    <span class="hljs-comment">// &#125;</span>  &#125;,  <span class="hljs-attr">actions</span>: &#123;    <span class="hljs-title function_">incrementAction</span>(<span class="hljs-params">context</span>) &#123;      <span class="hljs-comment">// console.log(context.commit) // 用于提交mutation</span>      <span class="hljs-comment">// console.log(context.getters) // getters</span>      <span class="hljs-comment">// console.log(context.state) // state</span>      context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;increment&quot;</span>)    &#125;,    <span class="hljs-title function_">changeNameAction</span>(<span class="hljs-params">context, payload</span>) &#123;      context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;changeName&quot;</span>, payload)    &#125;,    <span class="hljs-comment">// fetchHomeMultidataAction(context) &#123;</span>    <span class="hljs-comment">//   // 1.返回Promise, 给Promise设置then</span>    <span class="hljs-comment">//   // fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;</span>    <span class="hljs-comment">//   //   res.json().then(data =&gt; &#123;</span>    <span class="hljs-comment">//   //     console.log(data)</span>    <span class="hljs-comment">//   //   &#125;)</span>    <span class="hljs-comment">//   // &#125;)</span>          <span class="hljs-comment">//   // 2.Promise链式调用</span>    <span class="hljs-comment">//   // fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;).then(res =&gt; &#123;</span>    <span class="hljs-comment">//   //   return res.json()</span>    <span class="hljs-comment">//   // &#125;).then(data =&gt; &#123;</span>    <span class="hljs-comment">//   //   console.log(data)</span>    <span class="hljs-comment">//   // &#125;)</span>    <span class="hljs-comment">//   return new Promise(async (resolve, reject) =&gt; &#123;</span>    <span class="hljs-comment">//     // 3.await/async</span>    <span class="hljs-comment">//     const res = await fetch(&quot;http://123.207.32.32:8000/home/multidata&quot;)</span>    <span class="hljs-comment">//     const data = await res.json()</span>            <span class="hljs-comment">//     // 修改state数据</span>    <span class="hljs-comment">//     context.commit(&quot;changeBanners&quot;, data.data.banner.list)</span>    <span class="hljs-comment">//     context.commit(&quot;changeRecommends&quot;, data.data.recommend.list)</span>    <span class="hljs-comment">//     resolve(&quot;aaaaa&quot;)</span>    <span class="hljs-comment">//   &#125;)</span>    <span class="hljs-comment">// &#125;</span>  &#125;,  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">home</span>: homeModule,    <span class="hljs-attr">counter</span>: counterModule  &#125;&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-comment">//main.js</span><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>createApp(App).use(store).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</code></pre></div><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>state中主要是管理全局的状态，所有状态都存储在state中</p><div class="code-wrapper"><pre><code class="hljs pf">//<span class="hljs-keyword">state</span>要放到computed中去使用export <span class="hljs-keyword">default</span> &#123;   computed: &#123;     storeCounter() &#123;       return this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.counter     &#125;   &#125; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//在setup中使用state 需要使用useStore</span>&lt;script setup&gt;  <span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>  <span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()  <span class="hljs-comment">// 如果对store.state进行解构或者赋值给另外一个变量，会变成非响应式的，要使用toRefs</span>  <span class="hljs-keyword">const</span> &#123; counter &#125; = <span class="hljs-title function_">toRefs</span>(store.<span class="hljs-property">state</span>)    <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// store.state.counter++</span>    store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;increment&quot;</span>)  &#125;&lt;/script&gt;</code></pre></div><h5 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a><code>mapState</code> 辅助函数</h5><p><code>mapState</code> 辅助函数帮助我们生成计算属性</p><div class="code-wrapper"><pre><code class="hljs pf">/ 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; <span class="hljs-keyword">from</span> &#x27;vuex&#x27;export <span class="hljs-keyword">default</span> &#123;  // ...  computed: mapState(&#123;    // 箭头函数可使代码更简练    count: <span class="hljs-keyword">state</span> =&gt; <span class="hljs-keyword">state</span>.count,    // 传字符串参数 &#x27;count&#x27; 等同于 `<span class="hljs-keyword">state</span> =&gt; <span class="hljs-keyword">state</span>.count`    countAlias: &#x27;count&#x27;,    // 为了能够使用 `this` 获取局部状态，必须使用常规函数    countPlusLocalState (<span class="hljs-keyword">state</span>) &#123;      return <span class="hljs-keyword">state</span>.count + this.localCount    &#125;  &#125;)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">computed: mapState([  <span class="hljs-regexp">//</span> 映射 this.count 为 store.state.count  <span class="hljs-string">&#x27;count&#x27;</span>])<span class="hljs-regexp">//</span>还可以传递数组</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">computed: &#123;  localComputed () &#123; <span class="hljs-regexp">/* ... */</span> &#125;,  <span class="hljs-regexp">//</span> 使用对象展开运算符将此对象混入到外部对象中  ...mapState(&#123;    <span class="hljs-regexp">//</span> ...  &#125;)&#125;</code></pre></div><p>//使用展开运算符和其他computed合并</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;     <span class="hljs-title function_">fullname</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;xxx&quot;</span>     &#125;,     <span class="hljs-comment">// name() &#123;</span>     <span class="hljs-comment">//   return this.$store.state.name</span>     <span class="hljs-comment">// &#125;,</span>     ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;level&quot;</span>, <span class="hljs-string">&quot;avatarURL&quot;</span>]),     ...<span class="hljs-title function_">mapState</span>(&#123;       <span class="hljs-attr">sName</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">name</span>,       <span class="hljs-attr">sLevel</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">level</span>     &#125;)   &#125; &#125;</code></pre></div><h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><p>getter类似于vue的computed</p><p>Getter 接受 state 作为其第一个参数</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-attr">state</span>: &#123;    <span class="hljs-attr">todos</span>: [      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;    ]  &#125;,  <span class="hljs-attr">getters</span>: &#123;    doneTodos (state) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">todos</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">done</span>)    &#125;  &#125;&#125;)</code></pre></div><h5 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h5><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p><div class="code-wrapper"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">store</span>.getters.doneTodos // -&gt;</span> [&#123; id: <span class="hljs-number">1</span>, <span class="hljs-keyword">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, done: <span class="hljs-literal">true</span> &#125;]</code></pre></div><p>Getter 也可以接受其他 getter 作为第二个参数：</p><div class="code-wrapper"><pre><code class="hljs stylus">getters: &#123;  <span class="hljs-comment">// ...</span>  doneTodosCount (state, getters) &#123;    return getters<span class="hljs-selector-class">.doneTodos</span><span class="hljs-selector-class">.length</span>  &#125;&#125;store<span class="hljs-selector-class">.getters</span><span class="hljs-selector-class">.doneTodosCount</span> <span class="hljs-comment">// -&gt; 1</span></code></pre></div><p>我们可以很容易地在任何组件中使用它：</p><div class="code-wrapper"><pre><code class="hljs kotlin">computed: &#123;  doneTodosCount () &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.getters.doneTodosCount  &#125;&#125;</code></pre></div><p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p><h5 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h5><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><div class="code-wrapper"><pre><code class="hljs pf">getters: &#123;  // ...  getTodoById: (<span class="hljs-keyword">state</span>) =&gt; (id) =&gt; &#123;    return <span class="hljs-keyword">state</span>.todos.find(todo =&gt; todo.id === id)  &#125;&#125;store.getters.getTodoById(<span class="hljs-number">2</span>) // -&gt; &#123; id: <span class="hljs-number">2</span>, text: &#x27;...&#x27;, done: false &#125;</code></pre></div><p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果</p><h5 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a><code>mapGetters</code> 辅助函数</h5><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">computed</span>: &#123;  <span class="hljs-comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>    ...<span class="hljs-title function_">mapGetters</span>([      <span class="hljs-string">&#x27;doneTodosCount&#x27;</span>,      <span class="hljs-string">&#x27;anotherGetter&#x27;</span>,      <span class="hljs-comment">// ...</span>    ])  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">...mapGetters(&#123;  <span class="hljs-regexp">//</span> 把 `this.doneCount` 映射为 `this.<span class="hljs-variable">$store</span>.getters.doneTodosCount`  doneCount: <span class="hljs-string">&#x27;doneTodosCount&#x27;</span>&#125;)<span class="hljs-regexp">//</span>还可以取别名</code></pre></div><h5 id="在setup中使用"><a href="#在setup中使用" class="headerlink" title="在setup中使用"></a>在setup中使用</h5><div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;  <span class="hljs-keyword">import</span> &#123; computed, toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;  <span class="hljs-keyword">import</span> &#123; mapGetters, useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()  <span class="hljs-comment">// 1.使用mapGetters</span>  <span class="hljs-comment">// const &#123; message: messageFn &#125; = mapGetters([&quot;message&quot;])</span>  <span class="hljs-comment">// const message = computed(messageFn.bind(&#123; $store: store &#125;))</span>  <span class="hljs-comment">// 2.直接解构, 并且包裹成ref</span>  <span class="hljs-comment">// const &#123; message &#125; = toRefs(store.getters)</span>  <span class="hljs-comment">// 3.针对某一个getters属性使用computed</span>  <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">message</span>)  <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeAge</span>(<span class="hljs-params"></span>) &#123;    store.<span class="hljs-property">state</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;kobe&quot;</span>  &#125;&lt;/script&gt;</code></pre></div><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</p><p>mutation的使用</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">CHANGE_INFO</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/store/mutation_types&quot;</span> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;   <span class="hljs-attr">computed</span>: &#123;   &#125;,   <span class="hljs-attr">methods</span>: &#123;     <span class="hljs-title function_">changeName</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-comment">// this.$store.state.name = &quot;李银河&quot;</span>       <span class="hljs-comment">//传参方式</span>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;changeName&quot;</span>, <span class="hljs-string">&quot;王小波&quot;</span>)     &#125;,     <span class="hljs-title function_">incrementLevel</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;incrementLevel&quot;</span>)     &#125;,     <span class="hljs-title function_">changeInfo</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">//这是定义常量的方式</span>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-variable constant_">CHANGE_INFO</span>, &#123;         <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;王二&quot;</span>,         <span class="hljs-attr">level</span>: <span class="hljs-number">200</span>       &#125;)     &#125;   &#125; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs pf">//在mutation中commit<span class="hljs-keyword">const</span> store = createStore(&#123;  <span class="hljs-keyword">state</span>: () =&gt; (&#123;    name: <span class="hljs-string">&quot;张三&quot;</span>,  &#125;),  mutations: &#123;    updateMut(<span class="hljs-keyword">state</span>, playload) &#123;      <span class="hljs-keyword">state</span>.name = playload;    &#125;,    updateMut2(<span class="hljs-keyword">state</span>, playload) &#123;      store.commit(<span class="hljs-string">&quot;updateMut&quot;</span>, playload);    &#125;,  &#125;,&#125;);</code></pre></div><h5 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h5><div class="code-wrapper"><pre><code class="hljs pf">mutations: &#123;  someMutation (<span class="hljs-keyword">state</span>) &#123;    api.callAsyncMethod(() =&gt; &#123;      <span class="hljs-keyword">state</span>.count++    &#125;)  &#125;&#125;</code></pre></div><p>我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><h5 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h5><div class="code-wrapper"><pre><code class="hljs awk">methods: &#123;      btnClick() &#123;        console.log(<span class="hljs-string">&quot;btnClick&quot;</span>)      &#125;,      <span class="hljs-regexp">//</span> ...mapMutations([<span class="hljs-string">&quot;changeName&quot;</span>, <span class="hljs-string">&quot;incrementLevel&quot;</span>, CHANGE_INFO])  使用常量，在template中要使用正确的函数名    &#125;</code></pre></div><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p>Action 通过 <code>store.dispatch</code> 方法触发：</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">store.<span class="hljs-built_in">dispatch</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//在action中也可以分发action</span>actions: &#123;  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">actionA</span> (<span class="hljs-params">&#123; commit &#125;</span>)</span> &#123;    commit(<span class="hljs-string">&#x27;gotData&#x27;</span>, <span class="hljs-keyword">await</span> getData())  &#125;,  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">actionB</span> (<span class="hljs-params">&#123; dispatch, commit &#125;</span>)</span> &#123;    <span class="hljs-keyword">await</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>) <span class="hljs-comment">// 等待 actionA 完成</span>    commit(<span class="hljs-string">&#x27;gotOtherData&#x27;</span>, <span class="hljs-keyword">await</span> getOtherData())  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在组件中使用methods: &#123;     <span class="hljs-regexp">//</span> counterBtnClick() &#123;     <span class="hljs-regexp">//</span>   this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&quot;incrementAction&quot;</span>)     <span class="hljs-regexp">//</span> &#125;,     <span class="hljs-regexp">//</span> nameBtnClick() &#123;     <span class="hljs-regexp">//</span>   this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&quot;changeNameAction&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>)     <span class="hljs-regexp">//</span> &#125;     <span class="hljs-regexp">//</span> ...mapActions([<span class="hljs-string">&quot;incrementAction&quot;</span>, <span class="hljs-string">&quot;changeNameAction&quot;</span>])   &#125;</code></pre></div><h4 id="Modules的使用"><a href="#Modules的使用" class="headerlink" title="Modules的使用"></a>Modules的使用</h4><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">actions</span>: &#123; ... &#125;,  <span class="hljs-attr">getters</span>: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> moduleB = &#123;  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,  <span class="hljs-attr">actions</span>: &#123; ... &#125;&#125;<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">a</span>: moduleA,    <span class="hljs-attr">b</span>: moduleB  &#125;&#125;)store.<span class="hljs-property">state</span>.<span class="hljs-property">a</span> <span class="hljs-comment">// -&gt; moduleA 的状态</span>store.<span class="hljs-property">state</span>.<span class="hljs-property">b</span> <span class="hljs-comment">// -&gt; moduleB 的状态</span></code></pre></div><p>当没有添加namaspaced默认情况下使用module的值</p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 1.使用state时, 是需要state.moduleName.xxx --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Counter模块的counter: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.state.counter.count</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 2.使用getters时, 是直接getters.xxx --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Counter模块的doubleCounter: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.getters.doubleCount</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementCount&quot;</span>&gt;</span>count模块+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 告诉Vuex发起网络请求</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 派发事件时, 默认也是不需要跟模块名称</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 提交mutation时, 默认也是不需要跟模块名称</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">incrementCount</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&quot;incrementCountAction&quot;</span>)</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">actions</span>: &#123;    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;      <span class="hljs-keyword">if</span> ((state.<span class="hljs-property">count</span> + rootState.<span class="hljs-property">count</span>) % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)      &#125;    &#125;  &#125;&#125;</code></pre></div><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">getters</span>: &#123;    sumWithRootCount (state, getters, rootState) &#123;      <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> + rootState.<span class="hljs-property">count</span>    &#125;  &#125;&#125;</code></pre></div><h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><p>默认情况下，模块内部的 action 和 mutation 仍然是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一个 action 或 mutation 作出响应。Getter 同样也默认注册在全局命名空间，但是目前这并非出于功能上的目的（仅仅是维持现状来避免非兼容性变更）。必须注意，不要在不同的、无命名空间的模块中定义两个相同的 getter 从而导致错误。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;  <span class="hljs-attr">modules</span>: &#123;    <span class="hljs-attr">account</span>: &#123;      <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,      <span class="hljs-comment">// 模块内容（module assets）</span>      <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;), <span class="hljs-comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>      <span class="hljs-attr">getters</span>: &#123;        isAdmin () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span>      &#125;,      <span class="hljs-attr">actions</span>: &#123;        login () &#123; ... &#125; <span class="hljs-comment">// -&gt; dispatch(&#x27;account/login&#x27;)</span>      &#125;,      <span class="hljs-attr">mutations</span>: &#123;        login () &#123; ... &#125; <span class="hljs-comment">// -&gt; commit(&#x27;account/login&#x27;)</span>      &#125;,      <span class="hljs-comment">// 嵌套模块</span>      <span class="hljs-attr">modules</span>: &#123;        <span class="hljs-comment">// 继承父模块的命名空间</span>        <span class="hljs-attr">myPage</span>: &#123;          <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),          <span class="hljs-attr">getters</span>: &#123;            profile () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/profile&#x27;]</span>          &#125;        &#125;,        <span class="hljs-comment">// 进一步嵌套命名空间</span>        <span class="hljs-attr">posts</span>: &#123;          <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,          <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),          <span class="hljs-attr">getters</span>: &#123;            popular () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/posts/popular&#x27;]</span>          &#125;        &#125;      &#125;    &#125;  &#125;&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml">//在组件中的写法</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Home Page<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 1.使用state时, 是需要state.moduleName.xxx --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Counter模块的counter: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.state.counter.count</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 2.使用getters时, 是直接getters.xxx --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Counter模块的doubleCounter: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.getters</span>[&quot;counter/doubleCount&quot;] &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementCount&quot;</span>&gt;</span>count模块+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 告诉Vuex发起网络请求</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>()</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 派发事件时, 默认也是不需要跟模块名称</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 提交mutation时, 默认也是不需要跟模块名称</span></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">incrementCount</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&quot;counter/incrementCountAction&quot;</span>)<span class="hljs-comment">//有命名空间的写法</span></span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p><h5 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h5><p>如果你希望使用全局 state 和 getter，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-attr">modules</span>: &#123;  <span class="hljs-attr">foo</span>: &#123;    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">getters</span>: &#123;      <span class="hljs-comment">// 在这个模块的 getter 中，`getters` 被局部化了</span>      <span class="hljs-comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span>      someGetter (state, getters, rootState, rootGetters) &#123;        getters.<span class="hljs-property">someOtherGetter</span> <span class="hljs-comment">// -&gt; &#x27;foo/someOtherGetter&#x27;</span>        rootGetters.<span class="hljs-property">someOtherGetter</span> <span class="hljs-comment">// -&gt; &#x27;someOtherGetter&#x27;</span>        rootGetters[<span class="hljs-string">&#x27;bar/someOtherGetter&#x27;</span>] <span class="hljs-comment">// -&gt; &#x27;bar/someOtherGetter&#x27;</span>      &#125;,      <span class="hljs-attr">someOtherGetter</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; ... &#125;    &#125;,    <span class="hljs-attr">actions</span>: &#123;      <span class="hljs-comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span>      <span class="hljs-comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span>      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;        getters.<span class="hljs-property">someGetter</span> <span class="hljs-comment">// -&gt; &#x27;foo/someGetter&#x27;</span>        rootGetters.<span class="hljs-property">someGetter</span> <span class="hljs-comment">// -&gt; &#x27;someGetter&#x27;</span>        rootGetters[<span class="hljs-string">&#x27;bar/someGetter&#x27;</span>] <span class="hljs-comment">// -&gt; &#x27;bar/someGetter&#x27;</span>        <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someOtherAction&#x27;</span>        <span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someOtherAction&#x27;</span>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;someMutation&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someMutation&#x27;</span>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;someMutation&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someMutation&#x27;</span>      &#125;,      someOtherAction (ctx, payload) &#123; ... &#125;    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue-router笔记</title>
    <link href="/2022/08/20/vue-router%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/20/vue-router%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址"><a href="#路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址" class="headerlink" title="路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址"></a>路由器维护一张映射表，映射表会决定数据的流向，一个ip地址对应的一台服务器的mac地址，一台服务器只有一个mac地址</h4><h4 id="url的hash"><a href="#url的hash" class="headerlink" title="url的hash"></a>url的hash</h4><p>url的hash也就是锚点(#),本质上就是改变window.location的href的属性</p><p>我们可以通过赋值location.hash来改变href,但是不刷新页面</p><p>hash的优势就是兼容性好，在IE中可以运行，但是就是有个缺陷，#，显得不像是一个真实的路径</p><div class="code-wrapper"><pre><code class="hljs js">&lt;body&gt;    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/home&quot;</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/about&quot;</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#app&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;hashchange&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">switch</span> (location.<span class="hljs-property">hash</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;#/home&quot;</span>:</span></span><span class="language-javascript"><span class="language-xml">            app.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;home&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;#/about&quot;</span>:</span></span><span class="language-javascript"><span class="language-xml">            app.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;about&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">default</span>:</span></span><span class="language-javascript"><span class="language-xml">            app.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;app&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">        &#125;</span></span><span class="language-javascript"><span class="language-xml">      &#125;);</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>  &lt;/body&gt;</code></pre></div><h4 id="html5-history-api"><a href="#html5-history-api" class="headerlink" title="html5 history api"></a>html5 history api</h4><p>history是html5新增的api 他有六种模式改变url而不刷新页面</p><p>replaceState  替换原来的路径</p><p>pushState  使用新的路径</p><p>popState 路径回退</p><p>go 向前或者向后改变路径</p><p>forward 向前改变路径</p><p>back 向后改变路径</p><div class="code-wrapper"><pre><code class="hljs js">&lt;body&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>about<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> show = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&quot;show&quot;</span>)[<span class="hljs-number">0</span>];</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> elea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;a&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elea);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;popstate&quot;</span>, historyChange);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;go&quot;</span>, historyChange);</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> elea) &#123;</span></span><span class="language-javascript"><span class="language-xml">        item.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">          e.<span class="hljs-title function_">preventDefault</span>();</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">const</span> href = item.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;href&quot;</span>);</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(href);</span></span><span class="language-javascript"><span class="language-xml">          history.<span class="hljs-title function_">pushState</span>(&#123;&#125;, <span class="hljs-string">&quot;&quot;</span>, href);</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-title function_">historyChange</span>();</span></span><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">historyChange</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">switch</span> (location.<span class="hljs-property">pathname</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/about&quot;</span>:</span></span><span class="language-javascript"><span class="language-xml">            show.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;about&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/home&quot;</span>:</span></span><span class="language-javascript"><span class="language-xml">            show.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;home&quot;</span>;</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">          <span class="hljs-attr">default</span>:</span></span><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">break</span>;</span></span><span class="language-javascript"><span class="language-xml">        &#125;</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/body&gt;</code></pre></div><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> vue-router</code></pre></div><h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><p>router/index.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;  createRouter,  createWebHashHistory,  createWebHistory,&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<span class="hljs-comment">// import Home from &#x27;../Views/Home.vue&#x27;</span><span class="hljs-comment">// import About from &#x27;../Views/About.vue&#x27;</span><span class="hljs-comment">// 路由的懒加载 ，可以进行分包，减少报的大小，进行按需加载   webpackChunkName设置包的名字</span><span class="hljs-comment">// const Home = () =&gt; import(/* webpackChunkName: &#x27;home&#x27; */&quot;../Views/Home.vue&quot;)</span><span class="hljs-comment">// const About = () =&gt; import(/* webpackChunkName: &#x27;about&#x27; */&quot;../Views/About.vue&quot;)</span><span class="hljs-comment">// 创建一个路由: 映射关系</span><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;  <span class="hljs-comment">// 指定采用的模式: hash</span>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),  <span class="hljs-comment">// history: createWebHistory(),</span>  <span class="hljs-comment">// 映射关系</span>  <span class="hljs-attr">routes</span>: [    &#123;<span class="hljs-comment">//设置默认路径并进行重定向</span>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,      <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/home&quot;</span>,    &#125;,    &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>,<span class="hljs-comment">//路由记录独一无二的名称</span>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/Home.vue&quot;</span>),<span class="hljs-comment">//组件懒加载</span>      <span class="hljs-attr">meta</span>: &#123;<span class="hljs-comment">//这是路由元信息，不在url中携带的信息</span>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,      &#125;,       <span class="hljs-comment">//子路由</span>      <span class="hljs-attr">children</span>: [        &#123;          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>,          <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/home/recommend&quot;</span>,        &#125;,        &#123;          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;recommend&quot;</span>, <span class="hljs-comment">// /home/recommend</span>          <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/HomeRecommend.vue&quot;</span>),        &#125;,        &#123;          <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;ranking&quot;</span>, <span class="hljs-comment">// /home/ranking</span>          <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/HomeRanking.vue&quot;</span>),        &#125;,      ],    &#125;,    &#123;      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;about&quot;</span>,      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/About.vue&quot;</span>),    &#125;,    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:id&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/User.vue&quot;</span>),    &#125;,    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/order&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/Order.vue&quot;</span>),    &#125;,    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/Login.vue&quot;</span>),    &#125;,    &#123;      <span class="hljs-comment">// abc/cba/nba  配置404页面</span>      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/:pathMatch(.*)*&quot;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/NotFound.vue&quot;</span>),    &#125;,  ],&#125;);<span class="hljs-comment">// 1.动态管理路由</span><span class="hljs-keyword">let</span> isAdmin = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (isAdmin) &#123;  <span class="hljs-comment">// 一级路由</span>  router.<span class="hljs-title function_">addRoute</span>(&#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/admin&quot;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/Admin.vue&quot;</span>),  &#125;);  <span class="hljs-comment">// 添加vip页面 &quot;home&quot;必须唯一</span>  router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&quot;home&quot;</span>, &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;vip&quot;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;../Views/HomeVip.vue&quot;</span>),  &#125;);&#125;<span class="hljs-comment">// 获取router中所有的映射路由对象</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(router.<span class="hljs-title function_">getRoutes</span>());<span class="hljs-comment">// 2.路由导航守卫</span><span class="hljs-comment">// 进行任何的路由跳转之前, 传入的beforeEach中的函数都会被回调</span><span class="hljs-comment">// 需求: 进入到订单(order)页面时, 判断用户是否登录(isLogin -&gt; localStorage保存token)</span><span class="hljs-comment">// 情况一: 用户没有登录, 那么跳转到登录页面, 进行登录的操作</span><span class="hljs-comment">// 情况二: 用户已经登录, 那么直接进入到订单页面</span>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// 1.进入到任何别的页面时, 都跳转到login页面</span>  <span class="hljs-comment">// if (to.path !== &quot;/login&quot;) &#123;</span>  <span class="hljs-comment">//   return &quot;/login&quot;</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-comment">// 2.进入到订单页面时, 判断用户是否登录</span>  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> === <span class="hljs-string">&quot;/order&quot;</span> &amp;&amp; !token) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/login&quot;</span>;  &#125;&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;</code></pre></div><p>//main.js</p><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-comment">// 5. 创建并挂载根实例</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">app</span> = Vue.createApp(<span class="hljs-keyword">App</span>)<span class="hljs-comment">//确保 _use_ 路由实例使</span><span class="hljs-comment">//整个应用支持路由。注册插件</span><span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(router)<span class="hljs-keyword">app</span>.mount(&#x27;#<span class="hljs-keyword">app</span>&#x27;)</code></pre></div><p>在组建中使用</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span>//home.vue<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home-nav&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/recommend&quot;</span>&gt;</span>推荐<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home/ranking&quot;</span>&gt;</span>排行<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;logoutClick&quot;</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 占位组件 --&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></code></pre></div><h2 id="lt-router-link-gt-Props"><a href="#lt-router-link-gt-Props" class="headerlink" title="&lt;router-link&gt; Props"></a><code>&lt;router-link&gt;</code> Props</h2><p>表示目标路由的链接。当被点击后，内部会立刻把 <code>to</code> 的值传到 <code>router.push()</code>，所以这个值可以是一个 <code>string</code> 或者是<a href="https://router.vuejs.org/zh/api/#routelocationraw">描述目标位置的对象</a>。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 字符串 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-comment">&lt;!-- 渲染结果 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#x27;/home&#x27;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-comment">&lt;!-- 同上 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/home&#x27; &#125;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-comment">&lt;!-- 命名的路由 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: &#x27;123&#x27; &#125;&#125;&quot;</span>&gt;</span>User<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-comment">&lt;!-- 带查询参数，下面的结果为 `/register?plan=private` --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;/register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125;&#125;&quot;</span>&gt;</span>  Register<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></code></pre></div><h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><p>设置 <code>replace</code> 属性的话，当点击时，会调用 <code>router.replace()</code>，而不是 <code>router.push()</code>，所以导航后不会留下历史记录。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/abc&quot;</span> <span class="hljs-attr">replace</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></code></pre></div><h5 id="active-class"><a href="#active-class" class="headerlink" title="active-class"></a>active-class</h5><p>链接激活时，应用于渲染的 <code>&lt;a&gt;</code> 的 class</p><p><strong>默认值</strong>：<code>&quot;router-link-active&quot;</code></p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;router-link <span class="hljs-attribute">to</span>=<span class="hljs-string">&quot;/about&quot;</span> replace <span class="hljs-attribute">active-class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;关于&lt;/router-link&gt;</code></pre></div><p>可以修改默认的class或者添加新的class</p><h5 id="exact-active-class"><a href="#exact-active-class" class="headerlink" title="exact-active-class"></a>exact-active-class</h5><p>链接精准激活时，应用于渲染的 <code>&lt;a&gt;</code> 的 class</p><p><strong>默认值</strong>：<code>&quot;router-link-exact-active&quot;</code></p><h4 id="带参数的动态路由匹配"><a href="#带参数的动态路由匹配" class="headerlink" title="带参数的动态路由匹配"></a>带参数的动态路由匹配</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User&lt;/div&gt;&#x27;</span>,&#125;<span class="hljs-comment">// 这些都会传递给 `createRouter`</span><span class="hljs-keyword">const</span> routes = [  <span class="hljs-comment">// 动态字段以冒号开始</span>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> &#125;,]</code></pre></div><p>参数可以被当前路由的params获取</p><div class="code-wrapper"><pre><code class="hljs crmsh">const <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;</span><span class="hljs-title">  template</span>: &#x27;<span class="hljs-tag">&lt;div&gt;</span><span class="hljs-keyword">User</span> <span class="hljs-title">&#123;&#123; $route</span>.<span class="hljs-keyword">params</span>.id &#125;&#125;<span class="hljs-tag">&lt;/div&gt;</span>&#x27;,&#125;</code></pre></div><h5 id="监听响应路由参数的变化"><a href="#监听响应路由参数的变化" class="headerlink" title="监听响应路由参数的变化"></a>监听响应路由参数的变化</h5><p>使用带有参数的路由时需要注意的是，当用户从 <code>/users/johnny</code> 导航到 <code>/users/jolyne</code> 时，<strong>相同的组件实例将被重复使用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会被调用</strong>。</p><p>要对同一个组件中参数的变化做出响应的话，你可以简单地 watch <code>$route</code> 对象上的任意属性，在这个场景中，就是 <code>$route.params</code> ：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = &#123;  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;...&#x27;</span>,  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.$watch(      <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>,      <span class="hljs-function">(<span class="hljs-params">toParams, previousParams</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 对路由变化做出响应...</span>      &#125;    )  &#125;,&#125;</code></pre></div><p>或者，使用 <code>beforeRouteUpdate</code> <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>，它也可以取消导航：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> User = &#123;  template: <span class="hljs-string">&#x27;...&#x27;</span>,  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>)</span> &#123;    <span class="hljs-comment">// 对路由变化做出响应...</span>    <span class="hljs-keyword">this</span>.userData = <span class="hljs-keyword">await</span> fetchUser(to.<span class="hljs-keyword">params</span>.id)  &#125;,&#125;</code></pre></div><h5 id="捕获所有路由或-404-Not-found-路由"><a href="#捕获所有路由或-404-Not-found-路由" class="headerlink" title="捕获所有路由或 404 Not found 路由"></a><strong>捕获所有路由或 404 Not found 路由</strong></h5><p>常规参数只匹配 url 片段之间的字符，用 <code>/</code> 分隔。如果我们想匹配<strong>任意路径</strong>，我们可以使用自定义的 <em>路径参数</em> 正则表达式，在 <em>路径参数</em> 后面的括号中加入 正则表达式 :</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  <span class="hljs-comment">// 将匹配所有内容并将其放在 `$route.params.pathMatch` 下</span>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:pathMatch(.*)*&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;NotFound&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFound</span> &#125;,  <span class="hljs-comment">// 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下</span>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user-:afterUser(.*)&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserGeneric</span> &#125;,]</code></pre></div><p>在这个特定的场景中，我们在括号之间使用了<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%9C%A8%E5%8F%82%E6%95%B0%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99">自定义正则表达式</a>，并将<code>pathMatch</code> 参数标记为<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0">可选可重复</a>。这样做是为了让我们在需要的时候，可以通过将 <code>path</code> 拆分成一个数组，直接导航到路由：</p><div class="code-wrapper"><pre><code class="hljs stylus">this.<span class="hljs-variable">$router</span><span class="hljs-selector-class">.push</span>(&#123;  name: <span class="hljs-string">&#x27;NotFound&#x27;</span>,  <span class="hljs-comment">// 保留当前路径并删除第一个字符，以避免目标 URL 以 `//` 开头。</span>  params: &#123; pathMatch: this.<span class="hljs-variable">$route</span><span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.substring</span>(<span class="hljs-number">1</span>)<span class="hljs-selector-class">.split</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &#125;,  <span class="hljs-comment">// 保留现有的查询和 hash 值，如果有的话</span>  query: this.<span class="hljs-variable">$route</span><span class="hljs-selector-class">.query</span>,  hash: this.<span class="hljs-variable">$route</span><span class="hljs-selector-class">.hash</span>,&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>NotFound: 您当前的路径</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$route.params.pathMatch</span> &#125;&#125;</span><span class="language-xml">不正确, 请输入正确的路径!<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></code></pre></div><p>这里还有另外一种写法：  注意：我在/:pathMatch(.*)后面又加了一个 *；</p><p>这时候$route.params.pathMatch将是数组</p><h4 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h4><p><strong>在 Vue 实例中，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用<code>this.$router.push</code></strong></p><p>想要导航到不同的 URL，可以使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，内部会调用这个方法，所以点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 相当于调用 <code>router.push(...)</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 字符串路径</span>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/users/eduardo&#x27;</span>)<span class="hljs-comment">// 带有路径的对象</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/eduardo&#x27;</span> &#125;)<span class="hljs-comment">// 命名的路由，并加上参数，让路由建立 url</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;eduardo&#x27;</span> &#125; &#125;)<span class="hljs-comment">// 带查询参数，结果是 /register?plan=private</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125; &#125;)<span class="hljs-comment">// 带 hash，结果是 /about#team</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#team&#x27;</span> &#125;)</code></pre></div><p><strong>注意</strong>：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> username = <span class="hljs-string">&#x27;eduardo&#x27;</span><span class="hljs-comment">// 我们可以手动建立 url，但我们必须自己处理编码</span>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">`/user/<span class="hljs-subst">$&#123;username&#125;</span>`</span>) <span class="hljs-comment">// -&gt; /user/eduardo</span><span class="hljs-comment">// 同样</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;username&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/eduardo</span><span class="hljs-comment">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; username &#125; &#125;) <span class="hljs-comment">// -&gt; /user/eduardo</span><span class="hljs-comment">// `params` 不能与 `path` 一起使用</span>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; username &#125; &#125;) <span class="hljs-comment">// -&gt; /user</span></code></pre></div><p>当指定 <code>params</code> 时，可提供 <code>string</code> 或 <code>number</code> 参数（或者对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params">可重复的参数</a>可提供一个数组）。<strong>任何其他类型（如 <code>undefined</code>、<code>false</code> 等）都将被自动字符串化</strong>。对于<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#repeatable-params">可选参数</a>，你可以提供一个空字符串（<code>&quot;&quot;</code>）来跳过它。</p><p>由于属性 <code>to</code> 与 <code>router.push</code> 接受的对象种类相同，所以两者的规则完全相同。</p><p><code>router.push</code> 和所有其他导航方法都会返回一个 <em>Promise</em>，让我们可以等到导航完成后才知道是成功还是失败。我们将在 <a href="https://router.vuejs.org/zh/guide/advanced/navigation-failures.html">Navigation Handling</a> 中详细介绍。</p><h5 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace"></a>router.replace</h5><p>它在导航时不会向 history 添加新记录</p><div class="code-wrapper"><pre><code class="hljs php">router.<span class="hljs-title function_ invoke__">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;)<span class="hljs-comment">// 相当于</span>router.<span class="hljs-title function_ invoke__">replace</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span> &#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs gcode"><span class="hljs-comment">// 向前移动一条记录，与 router.forward() 相同</span>router.go<span class="hljs-comment">(1)</span><span class="hljs-comment">// 返回一条记录，与 router.back() 相同</span>router.go<span class="hljs-comment">(-1)</span><span class="hljs-comment">// 前进 3 条记录</span>router.go<span class="hljs-comment">(3)</span><span class="hljs-comment">// 如果没有那么多记录，静默失败</span>router.go<span class="hljs-comment">(-100)</span>router.go<span class="hljs-comment">(100)</span></code></pre></div><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>用于相同的path之间的切换组件，想同时 (同级) 展示多个视图</p><p>你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code></p><div class="code-wrapper"><pre><code class="hljs pgsql">&lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view left-sidebar&quot; <span class="hljs-type">name</span>=&quot;LeftSidebar&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;&lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view main-content&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;&lt;router-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;view right-sidebar&quot; <span class="hljs-type">name</span>=&quot;RightSidebar&quot;&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dts">const <span class="hljs-attr">router</span> <span class="hljs-operator">=</span> createRouter(<span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">  history:</span> createWebHashHistory(),<span class="hljs-symbol">  routes:</span> [    <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      path:</span> <span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-symbol">      components:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        default:</span> Home,        <span class="hljs-comment">// LeftSidebar: LeftSidebar 的缩写</span>        LeftSidebar,        <span class="hljs-comment">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span>        RightSidebar,      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span>,  ],<span class="hljs-punctuation">&#125;</span>)</code></pre></div><h4 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h4><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123; ... &#125;)router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-comment">// 返回 false 以取消导航</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;)</code></pre></div><h5 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h5><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  &#123;    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>,    <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserDetails</span>,    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;      <span class="hljs-comment">// reject the navigation</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;,  &#125;,]</code></pre></div><h5 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h5><div class="code-wrapper"><pre><code class="hljs awk">const UserDetails = &#123;  template: `...`,  beforeRouteEnter(to, from) &#123;    <span class="hljs-regexp">//</span> 在渲染该组件的对应路由被验证前调用    <span class="hljs-regexp">//</span> 不能获取组件实例 `this` ！    <span class="hljs-regexp">//</span> 因为当守卫执行时，组件实例还没被创建！  &#125;,  beforeRouteUpdate(to, from) &#123;    <span class="hljs-regexp">//</span> 在当前路由改变，但是该组件被复用时调用    <span class="hljs-regexp">//</span> 举例来说，对于一个带有动态参数的路径 `<span class="hljs-regexp">/users/</span>:id`，在 `<span class="hljs-regexp">/users/</span><span class="hljs-number">1</span>` 和 `<span class="hljs-regexp">/users/</span><span class="hljs-number">2</span>` 之间跳转的时候，    <span class="hljs-regexp">//</span> 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    <span class="hljs-regexp">//</span> 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`  &#125;,  beforeRouteLeave(to, from) &#123;    <span class="hljs-regexp">//</span> 在导航离开渲染该组件的对应路由时调用    <span class="hljs-regexp">//</span> 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`  &#125;,&#125;</code></pre></div><h3 id="使用组合-API"><a href="#使用组合-API" class="headerlink" title="使用组合 API#"></a>使用组合 API<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88-api">#</a></h3><p>如果你正在使用<a href="https://v3.vuejs.org/guide/composition-api-setup.html#setup">组合 API 和 <code>setup</code> 函数</a>来编写组件，你可以通过 <code>onBeforeRouteUpdate</code> 和 <code>onBeforeRouteLeave</code> 分别添加 update 和 leave 守卫</p><h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程#"></a>完整的导航解析流程<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">#</a></h2><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h4 id="Vue-Router-和-组合式-API"><a href="#Vue-Router-和-组合式-API" class="headerlink" title="Vue Router 和 组合式 API"></a>Vue Router 和 组合式 API</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useRouter, useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()    <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()    <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushWithQuery</span>(<span class="hljs-params">query</span>) &#123;      router.<span class="hljs-title function_">push</span>(&#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;search&#x27;</span>,        <span class="hljs-attr">query</span>: &#123;          ...route.<span class="hljs-property">query</span>,        &#125;,      &#125;)    &#125;  &#125;,&#125;</code></pre></div><p>//useRouter=&gt;$router  useRoute=&gt;$route</p><h5 id="useLink"><a href="#useLink" class="headerlink" title="useLink"></a><code>useLink</code></h5><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>动态路由主要通过两个函数实现。<code>router.addRoute()</code> 和 <code>router.removeRoute()</code>。它们<strong>只</strong>注册一个新的路由，也就是说，如果新增加的路由与当前位置相匹配，就需要你用 <code>router.push()</code> 或 <code>router.replace()</code> 来<strong>手动导航</strong>，才能显示该新路由</p><h5 id="添加嵌套路由"><a href="#添加嵌套路由" class="headerlink" title="添加嵌套路由"></a>添加嵌套路由</h5><p>要将嵌套路由添加到现有的路由中，可以将路由的 <em>name</em> 作为第一个参数传递给 <code>router.addRoute()</code>，这将有效地添加路由，就像通过 <code>children</code> 添加的一样：</p><div class="code-wrapper"><pre><code class="hljs reasonml">router.add<span class="hljs-constructor">Route(&#123; <span class="hljs-params">name</span>: &#x27;<span class="hljs-params">admin</span>&#x27;, <span class="hljs-params">path</span>: &#x27;<span class="hljs-operator">/</span><span class="hljs-params">admin</span>&#x27;, <span class="hljs-params">component</span>: Admin &#125;)</span>router.add<span class="hljs-constructor">Route(&#x27;<span class="hljs-params">admin</span>&#x27;, &#123; <span class="hljs-params">path</span>: &#x27;<span class="hljs-params">settings</span>&#x27;, <span class="hljs-params">component</span>: AdminSettings &#125;</span></code></pre></div><p>这等效于：</p><div class="code-wrapper"><pre><code class="hljs php">router.<span class="hljs-title function_ invoke__">addRoute</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>,  <span class="hljs-attr">component</span>: Admin,  <span class="hljs-attr">children</span>: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;settings&#x27;</span>, <span class="hljs-attr">component</span>: AdminSettings &#125;],&#125;)</code></pre></div><p>Vue Router 提供了两个功能来查看现有的路由：</p><ul><li><a href="https://router.vuejs.org/zh/api/#hasroute"><code>router.hasRoute()</code></a>：检查路由是否存在。</li><li><a href="https://router.vuejs.org/zh/api/#getroutes"><code>router.getRoutes()</code></a>：获取一个包含所有路由记录的数组</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue3笔记(二)</title>
    <link href="/2022/08/18/Vue3%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <url>/2022/08/18/Vue3%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="64-异步组件"><a href="#64-异步组件" class="headerlink" title="64.异步组件"></a>64.异步组件</h4><p>vue2中的异步组件是使用import().then()来实现的</p><p>vue3中提供了函数defineAsyncComponent来实现异步组件，这这样可以对组件进行分包处理，不会打包到一个文件中，而是单独打到一个包中</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//方法一 因为这种方式也会返回一个promise</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncCategory</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&quot;./views/Category.vue&quot;</span>))</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//方法二</span><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ...从服务器获取组件</span>    <span class="hljs-title function_">resolve</span>(<span class="hljs-comment">/* 获取到的组件 */</span>)  &#125;)&#125;)<span class="hljs-comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></code></pre></div><p><code>defineAsyncComponent</code> 方法接收一个返回 Promise 的加载函数。这个 Promise 的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。你也可以调用 <code>reject(reason)</code> 表明加载失败。</p><p>全局注册方式</p><div class="code-wrapper"><pre><code class="hljs js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyComponent&#x27;</span>, <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span>  <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>)))</code></pre></div><p>defineAsyncComponent的高级选项</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;  <span class="hljs-comment">// 加载函数</span>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>),  <span class="hljs-comment">// 加载异步组件时使用的组件</span>  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>,  <span class="hljs-comment">// 展示加载组件前的延迟时间，默认为 200ms</span>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-comment">// 加载失败后展示的组件</span>  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,  <span class="hljs-comment">// 如果提供了一个 timeout 时间限制，并超时了</span>  <span class="hljs-comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>&#125;)</code></pre></div><h4 id="65-组件中的v-model"><a href="#65-组件中的v-model" class="headerlink" title="65.组件中的v-model"></a>65.组件中的v-model</h4><p>可以对组件进行双向数据绑定</p><ol><li>将内部原生 <code>input</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li><li>输入新的值时在 <code>input</code> 元素上触发 <code>update:modelValue</code> 事件</li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//App.js</span>&lt;<span class="hljs-title class_">CustomInput</span>  :modelValue=<span class="hljs-string">&quot;searchText&quot;</span>  @<span class="hljs-attr">update</span>:modelValue=<span class="hljs-string">&quot;newValue =&gt; searchText = newValue&quot;</span>/&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">CustomInput</span>.<span class="hljs-property">vue</span> --&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>]</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">CustomInput</span> v-model=<span class="hljs-string">&quot;searchText&quot;</span> /&gt;<span class="hljs-comment">//这是上面的简写 v-model就可以使用了</span></code></pre></div><p>方式二。使用computed来实现v-model</p><div class="code-wrapper"><pre><code class="hljs js">&lt;!-- <span class="hljs-title class_">CustomInput</span>.<span class="hljs-property">vue</span> --&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;modelValue&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">value</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">modelValue</span></span></span><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, value)</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span> /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><p>v-model的参数是可以修改的</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">MyComponent</span> v-<span class="hljs-attr">model</span>:title=<span class="hljs-string">&quot;bookTitle&quot;</span> /&gt;  <span class="hljs-comment">//在组件中修改props的值还有emits的值为title和update:title</span></code></pre></div><h6 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 <code>v-model</code> 绑定</h6><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">UserName</span>  v-<span class="hljs-attr">model</span>:first-name=<span class="hljs-string">&quot;first&quot;</span>  v-<span class="hljs-attr">model</span>:last-name=<span class="hljs-string">&quot;last&quot;</span>/&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">firstName</span>: <span class="hljs-title class_">String</span>,    <span class="hljs-attr">lastName</span>: <span class="hljs-title class_">String</span>  &#125;,  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:firstName&#x27;</span>, <span class="hljs-string">&#x27;update:lastName&#x27;</span>]&#125;&lt;/script&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;firstName&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;lastName&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><h6 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 <code>v-model</code> 修饰符</h6><p>我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">MyComponent</span> v-model.<span class="hljs-property">capitalize</span>=<span class="hljs-string">&quot;myText&quot;</span> /&gt;</code></pre></div><p>组件的 <code>v-model</code> 上所添加的修饰符，可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的组件中，我们声明了 <code>modelModifiers</code> 这个 prop，它的默认值是一个空对象</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">modelValue</span>: <span class="hljs-title class_">String</span>,    <span class="hljs-attr">modelModifiers</span>: &#123;      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;)    &#125;  &#125;,  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>],  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">modelModifiers</span>) <span class="hljs-comment">// &#123; capitalize: true &#125;</span>  &#125;&#125;&lt;/script&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定上被使用了。</p><p>有了 <code>modelModifiers</code> 这个 prop，我们就可以在原生事件侦听函数中检查它的值，然后决定触发的自定义事件中要向父组件传递什么值。在下面的代码里，我们就是在每次 <code>&lt;input&gt;</code> 元素触发 <code>input</code> 事件时将值的首字母大写：</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">modelValue</span>: <span class="hljs-title class_">String</span>,    <span class="hljs-attr">modelModifiers</span>: &#123;      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;)    &#125;  &#125;,  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:modelValue&#x27;</span>],  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">emitValue</span>(<span class="hljs-params">e</span>) &#123;      <span class="hljs-keyword">let</span> value = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">modelModifiers</span>.<span class="hljs-property">capitalize</span>) &#123;        value = value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)      &#125;      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, value)    &#125;  &#125;&#125;&lt;/script&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;emitValue&quot;</span> /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div><p>对于又有参数又有修饰符的 <code>v-model</code> 绑定，生成的 prop 名将是 <code>arg + &quot;Modifiers&quot;</code>。举例来说：</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">MyComponent</span> v-<span class="hljs-attr">model</span>:title.<span class="hljs-property">capitalize</span>=<span class="hljs-string">&quot;myText&quot;</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;titleModifiers&#x27;</span>],  <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:title&#x27;</span>],  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">titleModifiers</span>) <span class="hljs-comment">// &#123; capitalize: true &#125;</span>  &#125;&#125;</code></pre></div><h4 id="66-mixins"><a href="#66-mixins" class="headerlink" title="66.mixins"></a>66.mixins</h4><p>局部混入的写法</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">mixin</span> = &#123;  created() &#123;    console.log(<span class="hljs-number">1</span>)  &#125;&#125;createApp(&#123;  created() &#123;    console.log(<span class="hljs-number">2</span>)  &#125;,  mixins: [<span class="hljs-keyword">mixin</span>]&#125;)<span class="hljs-comment">// =&gt; 1</span><span class="hljs-comment">// =&gt; 2</span></code></pre></div><p>Mixin 钩子的调用顺序与提供它们的选项顺序相同，且会在组件自身的钩子前被调用</p><p>在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，<a href="https://cn.vuejs.org/guide/reusability/composables.html">Composition API</a> 是现在更推荐的方式。</p><p>app.mixin()全局的混入 但是vue3不推荐使用</p><h4 id="67-setup-函数"><a href="#67-setup-函数" class="headerlink" title="67.setup()函数"></a>67.setup()函数</h4><p>setup函数有两个参数：props,context,在setup函数里面不能使用this</p><p>context参数包含3个属性：</p><p>attrs：所有非props的attribute</p><p>slots:父组件传递过来的插槽</p><p>emit</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;    <span class="hljs-comment">// 透传 Attributes（非响应式的对象，等价于 $attrs）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-property">attrs</span>)    <span class="hljs-comment">// 插槽（非响应式的对象，等价于 $slots）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-property">slots</span>)    <span class="hljs-comment">// 触发事件（函数，等价于 $emit）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-property">emit</span>)    <span class="hljs-comment">// 暴露公共属性（函数）</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context.<span class="hljs-property">expose</span>)  &#125;&#125;</code></pre></div><p>context是非响应性的，可以进行解构</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; attrs, slots, emit, expose &#125;</span>) &#123;    ...  &#125;&#125;</code></pre></div><p><code>attrs</code> 和 <code>slots</code> 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 <code>attrs.x</code> 或 <code>slots.x</code> 的形式使用其中的属性。此外还需注意，和 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 的属性都<strong>不是</strong>响应式的。如果你想要基于 <code>attrs</code> 或 <code>slots</code> 的改变来执行副作用，那么你应该在 <code>onBeforeUpdate</code> 生命周期钩子中编写相关逻辑。</p><p>setup可以有返回值，可以在template中使用</p><p><code>setup</code> 函数的第一个参数是组件的 <code>props</code>。和标准的组件一致，一个 <code>setup</code> 函数的 <code>props</code> 是响应式的，并且会在传入新的 props 时同步更新。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>  &#125;,  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props.<span class="hljs-property">title</span>)  &#125;&#125;</code></pre></div><p>如果解构props会使数据失去响应性，如果需要结构请使用toRef()/toRefs()</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; toRefs, toRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;    <span class="hljs-comment">// 将 `props` 转为一个其中全是 ref 的对象，然后解构</span>    <span class="hljs-keyword">const</span> &#123; title &#125; = <span class="hljs-title function_">toRefs</span>(props)    <span class="hljs-comment">// `title` 是一个追踪着 `props.title` 的 ref</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title.<span class="hljs-property">value</span>)    <span class="hljs-comment">// 或者，将 `props` 的单个属性转为一个 ref</span>    <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">toRef</span>(props, <span class="hljs-string">&#x27;title&#x27;</span>)  &#125;&#125;</code></pre></div><p>请注意在模板中访问从 <code>setup</code> 返回的 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref">ref</a> 时，它会<a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#deep-reactivity">自动浅层解包</a>，因此你无须再在模板中为它写 <code>.value</code>。当通过 <code>this</code> 访问时也会同样如此解包。</p><p><strong>TIP</strong></p><p><strong><code>setup()</code> 自身并不含对组件实例的访问权，即在 <code>setup()</code> 中访问 <code>this</code> 会是 <code>undefined</code>。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</strong></p><h5 id="暴露公共属性"><a href="#暴露公共属性" class="headerlink" title="暴露公共属性"></a>暴露公共属性</h5><p><code>expose</code> 函数用于显式地限制该组件暴露出的属性，当父组件通过<a href="https://cn.vuejs.org/guide/essentials/template-refs.html#ref-on-component">模板引用</a>访问该组件的实例时，将仅能访问 <code>expose</code> 函数暴露出的内容：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; expose &#125;</span>) &#123;    <span class="hljs-comment">// 让组件实例处于 “关闭状态”</span>    <span class="hljs-comment">// 即不向父组件暴露任何东西</span>    <span class="hljs-title function_">expose</span>()    <span class="hljs-keyword">const</span> publicCount = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)    <span class="hljs-keyword">const</span> privateCount = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)    <span class="hljs-comment">// 有选择地暴露局部状态</span>    <span class="hljs-title function_">expose</span>(&#123; <span class="hljs-attr">count</span>: publicCount &#125;)  &#125;&#125;</code></pre></div><h5 id="与渲染函数一起使用"><a href="#与渲染函数一起使用" class="headerlink" title="与渲染函数一起使用#"></a>与渲染函数一起使用<a href="https://cn.vuejs.org/api/composition-api-setup.html#usage-with-render-functions">#</a></h5><p><code>setup</code> 也可以返回一个<a href="https://cn.vuejs.org/guide/extras/render-function.html">渲染函数</a>，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; h, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, count.<span class="hljs-property">value</span>)  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; h, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; expose &#125;</span>) &#123;    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)    <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; ++count.<span class="hljs-property">value</span>    <span class="hljs-title function_">expose</span>(&#123;      increment    &#125;)    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, count.<span class="hljs-property">value</span>)  &#125;&#125;</code></pre></div><h4 id="68-reactive-api"><a href="#68-reactive-api" class="headerlink" title="68. reactive api"></a>68. reactive api</h4><p>reactive可以将对象变成响应式对象  ，返回一个对象的响应式代理</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">account</span> = <span class="hljs-title function_ invoke__">reactive</span>(&#123;      <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;coderwhy&quot;</span>,      <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;1234567&quot;</span>    &#125;)</code></pre></div><p>reactive转换是深层的，他会影响所有的嵌套属性，reactive也会深层的解包所有ref属性，同时保持响应性</p><p>值得注意的是，当访问到某个响应式数组或 <code>Map</code> 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包。意思是</p><p>若要避免深层响应式转换，只想保留对这个对象顶层次访问的响应性，请使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive">shallowReactive()</a> 作替代</p><p>返回的对象以及其中嵌套的对象都会通过 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">ES Proxy</a> 包裹，因此<strong>不等于</strong>源对象，建议只使用响应式代理，避免使用原始对象。</p><p>ref 的解包：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; count &#125;)<span class="hljs-comment">// ref 会被解包</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span> === count.<span class="hljs-property">value</span>) <span class="hljs-comment">// true</span><span class="hljs-comment">// 会更新 `obj.count`</span>count.<span class="hljs-property">value</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span>) <span class="hljs-comment">// 2</span><span class="hljs-comment">// 也会更新 `count` ref</span>obj.<span class="hljs-property">count</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span>) <span class="hljs-comment">// 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 3</span></code></pre></div><p>注意当访问到某个响应式数组或 <code>Map</code> 这样的原生集合类型中的 ref 元素时，<strong>不会</strong>执行 ref 的解包：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> books = <span class="hljs-title function_">reactive</span>([<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Vue 3 Guide&#x27;</span>)])<span class="hljs-comment">// 这里需要 .value</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(books[<span class="hljs-number">0</span>].<span class="hljs-property">value</span>)<span class="hljs-keyword">const</span> map = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;count&#x27;</span>, <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)]]))<span class="hljs-comment">// 这里需要 .value</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;count&#x27;</span>).<span class="hljs-property">value</span>)</code></pre></div><p>将一个 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref">ref</a> 赋值给为一个 <code>reactive</code> 属性时，该 ref 会被自动解包：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;&#125;)obj.<span class="hljs-property">count</span> = count<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">count</span> === count.<span class="hljs-property">value</span>) <span class="hljs-comment">// true</span></code></pre></div><h4 id="69-ref-api"><a href="#69-ref-api" class="headerlink" title="69.ref api"></a>69.ref api</h4><p>ref 可以定义任何数据类型</p><p>ref会返回一个可变的响应式对象，该对象作为一个响应式的引用维护它内部的值,</p><div class="code-wrapper"><pre><code class="hljs pgsql">const <span class="hljs-keyword">info</span> = <span class="hljs-keyword">ref</span>(&#123;&#125;)console.log(<span class="hljs-keyword">info</span>.<span class="hljs-keyword">value</span>)</code></pre></div><p>在模板中使用ref的值，vue会自动帮助我们进行解包不需要使用.value,但是在setup函数内部，还是一个ref引用，必须使用.value的方式。在模板中的解包是浅层的解包</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-comment">// 2.定义从网络中获取的数据也是使用ref</span>      <span class="hljs-comment">// const musics = reactive([])</span>      const musics = <span class="hljs-built_in">ref</span>(<span class="hljs-selector-attr">[]</span>)      <span class="hljs-built_in">onMounted</span>(() =&gt; &#123;        const serverMusics = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;海阔天空&quot;</span>, <span class="hljs-string">&quot;小苹果&quot;</span>, <span class="hljs-string">&quot;野狼&quot;</span>]</span>        musics<span class="hljs-selector-class">.value</span> = serverMusics      &#125;)</code></pre></div><h4 id="70-readonly"><a href="#70-readonly" class="headerlink" title="70.readonly()"></a>70.readonly()</h4><p>传入一个对象，无论是响应式还是普通对象，还是ref对象，会返回一个对象的只读代理</p><p>可以用于给子组件传递数据的时候，不允许修改父组件传递的值，，readonly他会劫持proxy中的set方法，不允许修改</p><p>只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 <code>reactive()</code> 相同，但解包得到的值是只读的。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> original = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-keyword">const</span> copy = <span class="hljs-title function_">readonly</span>(original)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// 用来做响应性追踪</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy.<span class="hljs-property">count</span>)&#125;)<span class="hljs-comment">// 更改源属性会触发其依赖的侦听器</span>original.<span class="hljs-property">count</span>++<span class="hljs-comment">// 更改该只读副本将会失败，并会得到一个警告</span>copy.<span class="hljs-property">count</span>++ <span class="hljs-comment">// warning!</span></code></pre></div><p>其实本质上就是readonly返回的对象的setter方法被劫持了而已</p><h4 id="71-reactive判断的api"><a href="#71-reactive判断的api" class="headerlink" title="71.reactive判断的api"></a>71.reactive判断的api</h4><h5 id="isProxy"><a href="#isProxy" class="headerlink" title="isProxy"></a>isProxy</h5><p>​    检查对象是否是由reactive或者readonly创建的proxy</p><h5 id="isReactive"><a href="#isReactive" class="headerlink" title="isReactive"></a>isReactive</h5><p>检查一个对象是否是由 <a href="https://cn.vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a> 或 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 创建的代理</p><p>如果该代理是readonly创建的，但是包裹了由reactive创建的另外一个代理，他也会返回true</p><h5 id="isReadonly"><a href="#isReadonly" class="headerlink" title="isReadonly"></a>isReadonly</h5><p>检查一个对象是否是由 <a href="https://cn.vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a> 或 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreadonly"><code>shallowReadonly()</code></a> 创建的代理。</p><h5 id="toRow"><a href="#toRow" class="headerlink" title="toRow"></a>toRow</h5><p> 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）。</p><h5 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a>shallowReactive</h5><p>创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)。</p><h5 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a>shallowReadonly</h5><p>创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）</p><h4 id="72-toRefs"><a href="#72-toRefs" class="headerlink" title="72 toRefs"></a>72 toRefs</h4><p>如果使用es6的解构语法对reactive返回的对象进行解构，解构后获得的变量不是响应式的，可以使用toRefs将解构后的值变成响应式的</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> info = <span class="hljs-title function_">reactive</span>(&#123;         <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,         <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,         <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>       &#125;)       <span class="hljs-comment">// reactive被解构后会变成普通的值, 失去响应式</span>       <span class="hljs-keyword">const</span> &#123; name, age &#125; = <span class="hljs-title function_">toRefs</span>(info)</code></pre></div><p><code>toRefs</code> 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 <a href="https://cn.vuejs.org/api/reactivity-utilities.html#toref"><code>toRef</code></a>。</p><h4 id="73-toRef"><a href="#73-toRef" class="headerlink" title="73.toRef"></a>73.toRef</h4><p>将一个reactive对象的属性变成响应式的</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>&#125;)<span class="hljs-keyword">const</span> fooRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// 更改该 ref 会更新源属性</span>fooRef.<span class="hljs-property">value</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">foo</span>) <span class="hljs-comment">// 2</span><span class="hljs-comment">// 更改源属性也会更新该 ref</span>state.<span class="hljs-property">foo</span>++<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fooRef.<span class="hljs-property">value</span>) <span class="hljs-comment">// 3</span></code></pre></div><p>请注意，这不同于：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fooRef = <span class="hljs-title function_">ref</span>(state.<span class="hljs-property">foo</span>)</code></pre></div><p>上面这个 ref <strong>不会</strong>和 <code>state.foo</code> 保持同步，因为这个 <code>ref()</code> 接收到的是一个纯数值。</p><h4 id="74-ref其他api"><a href="#74-ref其他api" class="headerlink" title="74. ref其他api"></a>74. ref其他api</h4><h5 id="unref"><a href="#unref" class="headerlink" title="unref"></a>unref</h5><p>如果我们想要获取一个ref引用中的value，那么也可以通过unref方法：  如果参数是一个 ref，则返回内部值，否则返回参数本身；  这是 val = isRef(val) ? val.value : val 的语法糖函数</p><h5 id="isRef"><a href="#isRef" class="headerlink" title="isRef"></a>isRef</h5><p>判断值是否是一个ref对象。</p><h5 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a>shallowRef</h5><p>创建一个浅层的ref对象</p><h5 id="triggerRef"><a href="#triggerRef" class="headerlink" title="triggerRef"></a>triggerRef</h5><p>手动触发和 shallowRef 相关联的副作用：</p><h4 id="75-computed"><a href="#75-computed" class="headerlink" title="75.computed()"></a>75.computed()</h4><p>接受一个 getter 函数，返回一个只读的响应式 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref">ref</a> 对象。该 ref 通过 <code>.value</code> 暴露 getter 函数的返回值。它也可以接受一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 ref 对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> plusOne = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(plusOne.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span>plusOne.<span class="hljs-property">value</span>++ <span class="hljs-comment">// 错误</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> plusOne = <span class="hljs-title function_">computed</span>(&#123;  <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> count.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>,  <span class="hljs-attr">set</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;    count.<span class="hljs-property">value</span> = val - <span class="hljs-number">1</span>  &#125;&#125;)plusOne.<span class="hljs-property">value</span> = <span class="hljs-number">1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>) <span class="hljs-comment">// 0</span></code></pre></div><h4 id="76-在setup中获取组件实例"><a href="#76-在setup中获取组件实例" class="headerlink" title="76.在setup中获取组件实例"></a>76.在setup中获取组件实例</h4><div class="code-wrapper"><pre><code class="hljs js">&lt;show-info ref=<span class="hljs-string">&quot;showInfoRef&quot;</span>&gt;&lt;/show-info&gt;<span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">const</span> showInfoRef=<span class="hljs-title function_">ref</span>()<span class="hljs-keyword">return</span> &#123;showInfoRef&#125;&#125;</code></pre></div><h4 id="77-在setup中使用生命周期钩子函数"><a href="#77-在setup中使用生命周期钩子函数" class="headerlink" title="77.在setup中使用生命周期钩子函数"></a>77.在setup中使用生命周期钩子函数</h4><p>onBeforeMount</p><p>onMounted</p><p>onBeforeUpdate</p><p>onUpdated</p><p>onBeforeUnmounted</p><p>onUnounted</p><p>onActivited</p><p>onDeactivited</p><h4 id="78-provide"><a href="#78-provide" class="headerlink" title="78.provide"></a>78.provide</h4><ul><li><p>与注册生命周期钩子的 API 类似，<code>provide()</code> 必须在组件的 <code>setup()</code> 阶段同步调用。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;<span class="hljs-keyword">import</span> &#123; ref, provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> &#123; fooSymbol &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span><span class="hljs-comment">// 提供静态值</span><span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<span class="hljs-comment">// 提供响应式的值</span><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;count&#x27;</span>, count)<span class="hljs-comment">// 提供时将 Symbol 作为 key</span><span class="hljs-title function_">provide</span>(fooSymbol, count)&lt;/script&gt;</code></pre></div></li></ul><h4 id="79-inject"><a href="#79-inject" class="headerlink" title="79.inject()"></a>79.inject()</h4><p>第一个参数是注入的 key。Vue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，那么离得更近的组件将会“覆盖”链上更远的组件所提供的值。如果没有能通过 key 匹配到值，<code>inject()</code> 将返回 <code>undefined</code>，除非提供了一个默认值。</p><p>第二个参数是可选的，即在没有匹配到 key 时使用的默认值。它也可以是一个工厂函数，用来返回某些创建起来比较复杂的值。如果默认值本身就是一个函数，那么你必须将 <code>false</code> 作为第三个参数传入，表明这个函数就是默认值，而不是一个工厂函数。</p><p>与注册生命周期钩子的 API 类似，<code>inject()</code> 必须在组件的 <code>setup()</code> 阶段同步调用。</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;<span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> &#123; fooSymbol &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./injectionSymbols&#x27;</span><span class="hljs-comment">// 注入值的默认方式</span><span class="hljs-keyword">const</span> foo = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<span class="hljs-comment">// 注入响应式的值</span><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;count&#x27;</span>)<span class="hljs-comment">// 通过 Symbol 类型的 key 注入</span><span class="hljs-keyword">const</span> foo2 = <span class="hljs-title function_">inject</span>(fooSymbol)<span class="hljs-comment">// 注入一个值，若为空则使用提供的默认值</span><span class="hljs-keyword">const</span> bar = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;default value&#x27;</span>)<span class="hljs-comment">// 注入一个值，若为空则使用提供的工厂函数</span><span class="hljs-keyword">const</span> baz = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())<span class="hljs-comment">// 注入时为了表明提供的默认值是个函数，需要传入第三个参数</span><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;function&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;&#125;, <span class="hljs-literal">false</span>)&lt;/script&gt;</code></pre></div><h4 id="80-watch"><a href="#80-watch" class="headerlink" title="80.watch()"></a>80.watch()</h4><p>watch的api和option API中的watch类似</p><p>watch需要监听特定的数据源，并且执行其回调函数，默认情况下，他是惰性的，在初始化情况下不执行，只有在数据变化时才执行</p><p><code>watch()</code> 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。</p><p>第一个参数是侦听器的<strong>源</strong>。这个来源可以是以下几种：</p><ul><li>一个函数，返回一个值</li><li>一个 ref</li><li>一个响应式对象</li><li>…或是由以上类型的值组成的数组</li></ul><p>第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。</p><p>当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。</p><p>第三个可选的参数是一个对象，支持以下这些选项：</p><ul><li><p>**<code>immediate</code>**：在侦听器创建时立即触发回调。第一次调用时旧值是 <code>undefined</code>。</p></li><li><p>**<code>deep</code>**：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考<a href="https://cn.vuejs.org/guide/essentials/watchers.html#deep-watchers">深层侦听器</a>一节。</p></li><li><p>**<code>flush</code>**：调整回调函数的刷新时机。参考<a href="https://cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing">回调的刷新时机</a>一节。</p></li><li><p>**<code>onTrack / onTrigger</code>**：调试侦听器的依赖,参考<a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#watcher-debugging">调试侦听器</a>一节。</p></li></ul><p>与 <a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a> 相比，<code>watch()</code> 使我们可以：</p><ul><li>懒执行副作用；</li><li>更加明确是应该由哪个状态触发侦听器重新执行；</li><li>可以访问所侦听状态的前一个值和当前值。</li></ul><p>侦听一个 getter 函数：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">watch</span>(  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">count</span>,  <span class="hljs-function">(<span class="hljs-params">count, prevCount</span>) =&gt;</span> &#123;    <span class="hljs-comment">/* ... */</span>  &#125;)</code></pre></div><p>侦听一个 ref：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-title function_">watch</span>(count, <span class="hljs-function">(<span class="hljs-params">count, prevCount</span>) =&gt;</span> &#123;  <span class="hljs-comment">/* ... */</span>&#125;)</code></pre></div><p>当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>([fooRef, barRef], <span class="hljs-function">(<span class="hljs-params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;  <span class="hljs-comment">/* ... */</span>&#125;)</code></pre></div><p>当使用 getter 函数作为源时，回调只在此函数的返回值变化时才会触发。如果你想让回调在深层级变更时也能触发，你需要使用 <code>&#123; deep: true &#125;</code> 强制侦听器进入深层级模式。在深层级模式时，如果回调函数由于深层级的变更而被触发，那么新值和旧值将是同一个对象。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">watch</span>(  <span class="hljs-function">() =&gt;</span> state,  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;    <span class="hljs-comment">// newValue === oldValue</span>  &#125;,  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span><span class="hljs-comment">//在创建的时候执行一次 &#125;</span>)</code></pre></div><p>当直接侦听一个响应式对象时，侦听器会自动启用深层模式：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<span class="hljs-title function_">watch</span>(state, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">/* 深层级变更状态所触发的回调 */</span>&#125;)</code></pre></div><p><code>watch()</code> 和 <a href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a> 享有相同的刷新时机和调试选项：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(source, callback, &#123;  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span>,  <span class="hljs-title function_">onTrack</span>(<span class="hljs-params">e</span>) &#123;    <span class="hljs-keyword">debugger</span>  &#125;&#125;)</code></pre></div><h4 id="81-watchEffect"><a href="#81-watchEffect" class="headerlink" title="81.watchEffect()"></a>81.watchEffect()</h4><p>立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p><ul><li><p>第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。</p><p>第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。</p><p>返回值是一个用来停止该副作用的函数。</p></li><li><p><strong>示例</strong></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>))<span class="hljs-comment">// -&gt; 输出 0</span>count.<span class="hljs-property">value</span>++<span class="hljs-comment">// -&gt; 输出 1</span></code></pre></div><p>副作用清除：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-keyword">async</span> (onCleanup) =&gt; &#123;  <span class="hljs-keyword">const</span> &#123; response, cancel &#125; = <span class="hljs-title function_">doAsyncWork</span>(id.<span class="hljs-property">value</span>)  <span class="hljs-comment">// `cancel` 会在 `id` 更改时调用</span>  <span class="hljs-comment">// 以便取消之前</span>  <span class="hljs-comment">// 未完成的请求</span>  <span class="hljs-title function_">onCleanup</span>(cancel)  data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response&#125;)</code></pre></div><p>停止侦听器：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> stop = <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<span class="hljs-comment">// 当不再需要此侦听器时:</span><span class="hljs-title function_">stop</span>()</code></pre></div><p>选项：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, &#123;  <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span>,  <span class="hljs-title function_">onTrack</span>(<span class="hljs-params">e</span>) &#123;    <span class="hljs-keyword">debugger</span>  &#125;,  <span class="hljs-title function_">onTrigger</span>(<span class="hljs-params">e</span>) &#123;    <span class="hljs-keyword">debugger</span>  &#125;&#125;)</code></pre></div></li></ul><h4 id="82-hooks的封装"><a href="#82-hooks的封装" class="headerlink" title="82.hooks的封装"></a>82.hooks的封装</h4><p>封装usetitle</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//useTitle.js</span><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<span class="hljs-comment">//这是闭包函数</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useTitle</span>(<span class="hljs-params">titleValue</span>) &#123;  <span class="hljs-comment">// document.title = title</span>  <span class="hljs-comment">// 定义ref的引入数据</span>  <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">ref</span>(titleValue)  <span class="hljs-comment">// 监听title的改变</span>  <span class="hljs-title function_">watch</span>(title, <span class="hljs-function">(<span class="hljs-params">newValue</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = newValue  &#125;, &#123;    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>  &#125;)  <span class="hljs-comment">// 返回ref值</span>  <span class="hljs-keyword">return</span> &#123;    title  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-comment">//App.vue</span><span class="hljs-comment">// 2.修改标题</span>      <span class="hljs-keyword">const</span> &#123; title &#125; = <span class="hljs-title function_">useTitle</span>(<span class="hljs-string">&quot;首页&quot;</span>)      <span class="hljs-comment">// 3.监听按钮的点击  这样修改的是同一个值，不需要重复的调用usetitle(&quot;首页-流行&quot;)</span>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">popularClick</span>(<span class="hljs-params"></span>) &#123;        title.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;首页-流行&quot;</span>      &#125;      <span class="hljs-keyword">function</span> <span class="hljs-title function_">hotClick</span>(<span class="hljs-params"></span>) &#123;        title.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;首页-热门&quot;</span>      &#125;      <span class="hljs-keyword">function</span> <span class="hljs-title function_">songClick</span>(<span class="hljs-params"></span>) &#123;        title.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;首页-歌单&quot;</span>      &#125;</code></pre></div><h4 id="84-单文件组件-lt-script-setup-gt"><a href="#84-单文件组件-lt-script-setup-gt" class="headerlink" title="84.单文件组件 &lt;script setup&gt;"></a>84.单文件组件 <code>&lt;script setup&gt;</code></h4><script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。- 更少的样板内容，更简洁的代码。- 能够使用纯 TypeScript 声明 props 和自定义事件。- 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。- 更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。<div class="code-wrapper"><pre><code class="hljs js">&lt;script setup&gt;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello script setup&#x27;</span>)&lt;/script&gt;</code></pre></div>与普通的 `<script>` 只在组件被首次引入的时候执行一次不同，`<script setup>` 中的代码会在**每次组件实例被创建的时候执行**。响应式数据需要使用ref或者reactive来实现##### 顶层的绑定会被暴露给模板[#](https://cn.vuejs.org/api/sfc-script-setup.html#top-level-bindings-are-exposed-to-template)当使用 `<script setup>` 的时候，任何在 `<script setup>` 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用：<div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 变量</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> msg = <span class="hljs-string">&#x27;Hello!&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 函数</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;log&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div>import 导入的内容也会以同样的方式暴露。这意味着我们可以在模板表达式中直接使用导入的 helper 函数，而不需要通过 `methods` 选项来暴露它：<div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; capitalize &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./helpers&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">capitalize</span>(<span class="hljs-name">&#x27;hello&#x27;</span>) &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></code></pre></div>##### 组件的使用组件直接导入即可，不需要注册<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div>##### **`defineProps()`**，`defineEmits（）`用于在`<script setup>`中定义props和emits<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-comment">// 定义props</span></span><span class="language-javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span><span class="language-javascript">  <span class="hljs-attr">name</span>: &#123;</span><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span><span class="language-javascript">    <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;默认值&quot;</span></span><span class="language-javascript">  &#125;,</span><span class="language-javascript">  <span class="hljs-attr">age</span>: &#123;</span><span class="language-javascript">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,</span><span class="language-javascript">    <span class="hljs-attr">default</span>: <span class="hljs-number">0</span></span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;)</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-comment">// 绑定函数, 并且发出事件</span></span><span class="language-javascript"><span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;infoBtnClick&quot;</span>])</span><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showInfoBtnClick</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">  <span class="hljs-title function_">emits</span>(<span class="hljs-string">&quot;infoBtnClick&quot;</span>, <span class="hljs-string">&quot;showInfo内部发生了点击&quot;</span>)</span><span class="language-javascript">&#125;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-comment">// 定义foo的函数</span></span><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo function&quot;</span>)</span><span class="language-javascript">&#125;</span><span class="language-javascript"><span class="hljs-title function_">defineExpose</span>(&#123;</span><span class="language-javascript">  foo</span><span class="language-javascript">&#125;)</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>##### `defineExpose`使用 `<script setup>` 的组件是**默认关闭**的——即通过模板引用或者 `$parent` 链获取到的组件的公开实例，**不会**暴露任何在 `<script setup>` 中声明的绑定。可以通过 `defineExpose` 编译器宏来显式指定在 `<script setup>` 组件中要暴露出去的属性：<div class="code-wrapper"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> b = <span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>)</span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineExpose</span>(</span></span><span class="hljs-template-variable">&#123;</span><span class="hljs-template-variable">  a,</span><span class="hljs-template-variable">  b</span><span class="hljs-template-variable">&#125;</span><span class="language-xml">)</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3笔记</title>
    <link href="/2022/08/16/Vue3%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2022/08/16/Vue3%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h4 id="1-vue手脚架代价脚本-两种方式"><a href="#1-vue手脚架代价脚本-两种方式" class="headerlink" title="1.vue手脚架代价脚本  两种方式"></a>1.vue手脚架代价脚本  两种方式</h4><div class="code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">vue</span> <span class="hljs-string">create</span>  项目名  构建工具是<span class="hljs-string">webpack</span><span class="hljs-string">npm</span> <span class="hljs-string">init</span> <span class="hljs-string">vue</span>@<span class="hljs-string">latest</span>  <span class="hljs-string">1</span>.安装一个本地工具：<span class="hljs-built_in">create-vue</span>  <span class="hljs-string">2</span>.使用<span class="hljs-built_in">create-vue创建一个vue项目</span>  构建工具是<span class="hljs-string">vite</span></code></pre></div><h4 id="2-attrs"><a href="#2-attrs" class="headerlink" title="2.$attrs"></a>2.$attrs</h4><h4 id="3-emits"><a href="#3-emits" class="headerlink" title="3.emits"></a>3.emits</h4><p>vue3中增加了$emit事件的声明</p><h4 id="4-reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的"><a href="#4-reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的" class="headerlink" title="4.reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的"></a>4.reactive只能传入一个对象，定义复杂类型的数据，事实上编写的data函数在内部也是调用reactive来完成响应式的</h4><h4 id="5-ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包"><a href="#5-ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包" class="headerlink" title="5.ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包"></a>5.ref函数，用于定义简单类型的数据，也可以定义复杂类型的数据。ref会进行自动解包，ref的解包是浅层解包</h4><p>但是在深层次引用的时候，使用的时候是直接使用，在设置的时候需要用.value</p><h4 id="6-ref和reactive的使用场景"><a href="#6-ref和reactive的使用场景" class="headerlink" title="6.ref和reactive的使用场景"></a>6.ref和reactive的使用场景</h4><p>​        reactive可以应用于本地的数据，多个数据之间是有联系的，是聚合数据</p><p>​        其他场景可以运用ref,定义网络请求中的数据也是用ref</p><ol start="7"><li><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><code>readonly</code></h4></li></ol><p>​    不要违反单项数据流，把响应式的reactive或者ref传递给子组件，子组件可以修改数据，为了不要让子组件修改数据，可以将传入的响应式变成readonly</p><div class="code-wrapper"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> obj1=<span class="hljs-keyword">readonly</span>(obj)<span class="hljs-comment">//可以将这个obj1传递过去</span></code></pre></div><p>readonly会返回原始对象的只读代理，本质上是劫持proxy的set方法，不能进行设置新的值</p><h4 id="8-isProxy"><a href="#8-isProxy" class="headerlink" title="8.isProxy"></a>8.isProxy</h4><p>判断是否是由reactive或者readonly创建的proxy</p><h4 id="9-isReactive"><a href="#9-isReactive" class="headerlink" title="9.isReactive"></a>9.isReactive</h4><p> 检查对象是否是由reactive创建的响应式代理，如果该代理是由readonly创建的，但是包裹reactive,也是true</p><h4 id="10-isReadonly"><a href="#10-isReadonly" class="headerlink" title="10.isReadonly"></a>10.isReadonly</h4><p> 是否是readonly</p><h4 id="11-toRow"><a href="#11-toRow" class="headerlink" title="11.toRow"></a>11.toRow</h4><p>返回reactive或者readonly代理的原始对象</p><h4 id="12-shallowReactive"><a href="#12-shallowReactive" class="headerlink" title="12.shallowReactive"></a>12.shallowReactive</h4><p>  创建一个响应式代理，跟踪本身的property,但是不会执行嵌套对象的深层响应式代理</p><h4 id="13-shallowReadonly"><a href="#13-shallowReadonly" class="headerlink" title="13.shallowReadonly"></a>13.shallowReadonly</h4><p> 只读的浅层</p><h4 id="14-toRefs"><a href="#14-toRefs" class="headerlink" title="14.toRefs"></a>14.toRefs</h4><p> 将响应式对象转换成普通对象，里面的property转成ref,可以进行解构成ref响应式</p><div class="code-wrapper"><pre><code class="hljs reasonml">const &#123;a&#125;=<span class="hljs-keyword">to</span><span class="hljs-constructor">Refs(<span class="hljs-params">reactive</span>(&#123;<span class="hljs-params">a</span>:<span class="hljs-string">&quot;zjag&quot;</span>&#125;)</span>  <span class="hljs-comment">//可以用于reactive的解构</span></code></pre></div><p>reactive默认情况下解构的值没有响应式</p><h4 id="15-setup的生命周期"><a href="#15-setup的生命周期" class="headerlink" title="15.setup的生命周期"></a>15.setup的生命周期</h4><h4 id="16-Provide函数"><a href="#16-Provide函数" class="headerlink" title="16.Provide函数"></a>16.Provide函数</h4><h4 id="17-路由钩子函数"><a href="#17-路由钩子函数" class="headerlink" title="17.路由钩子函数"></a>17.路由钩子函数</h4><h4 id="18-beforeEach"><a href="#18-beforeEach" class="headerlink" title="18.beforeEach"></a>18.beforeEach</h4><p> 全局的前置守卫beforeEach是会在导航触发的时候被调用，他又两个参数to,from,又返回值，返回false则会取消当前导航，不返回或者返回undefined则使用默认导航，返回一个路由地址，可以是字符串，也可以是object，包括路由信息</p><h4 id="19-什么是MVVM，和MVC的区别"><a href="#19-什么是MVVM，和MVC的区别" class="headerlink" title="19.什么是MVVM，和MVC的区别"></a>19.什么是MVVM，和MVC的区别</h4><p>20.data必须是一个函数，并且返回一个对象，在vue2中，也可以传入一个对象，在vue3中必须使用函数</p><p>21.箭头函数不能定义method中的函数，因为箭头函数中·没有this,箭头函数的this是由上层作用域的this来决定的，所以不会指定到当前组件实例</p><p>22.在源码中this的指向</p><p>23.v-once 表示当前元素或者组件只会更新一次，就是初始化以后就不会再次渲染，包含的子组件也是渲染也是渲染一次，在特定多的场合使用可以提高性能</p><h4 id="24-v-text"><a href="#24-v-text" class="headerlink" title="24.v-text"></a>24.v-text</h4><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  //二者是等价的</span></code></pre></div><h4 id="25-v-html"><a href="#25-v-html" class="headerlink" title="25.v-html"></a>25.v-html</h4><p>可以将字符串转换成html</p><p>默认情况下，如果我们展示的内容本身是html 的，那么vue并不会对其进行特殊的解析。</p><p>如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> data() &#123;         <span class="hljs-keyword">return</span> &#123;          <span class="hljs-built_in"> count</span>: <span class="hljs-number">0</span>,           content: `<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; font-size: 30px;&quot;</span>&gt;</span>哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>`,         &#125;;       &#125;,</code></pre></div><h4 id="26-v-pre"><a href="#26-v-pre" class="headerlink" title="26.v-pre"></a>26.v-pre</h4><p>用于跳过元素和他的子元素的编译过程，显示原始的Mustach标签，就是不会对其进行编译</p><img src="https://img1.imgtp.com/2022/08/16/6QxUMw0k.png" alt="QQ截图20220805010351.png" style="zoom:200%;" /><p><img src="https://img1.imgtp.com/2022/08/16/RQQz8CXr.png" alt="QQ截图20220805010445.png"></p><h4 id="27-v-cloak"><a href="#27-v-cloak" class="headerlink" title="27.v-cloak"></a>27.v-cloak</h4><p>这个指令保持在元素上直到关联的组件实例结束编译，需要和css结合使用</p><img src="https://img1.imgtp.com/2022/08/16/0K3EfAAB.png" alt="图片1.png" style="zoom:200%;" /><h4 id="28-v-memo"><a href="#28-v-memo" class="headerlink" title="28.v-memo"></a>28.v-memo</h4><p>适用于性能优化，只有对应的数组中属性的值发生变化时才会重新渲染</p><img src="https://img1.imgtp.com/2022/08/16/JpOvHIxe.png" alt="QQ截图20220805011104.png" style="zoom:200%;" /><h4 id="29-v-bind"><a href="#29-v-bind" class="headerlink" title="29.v-bind"></a>29.v-bind</h4><p> v-bind的简写</p><h4 id="30-class绑定的语法"><a href="#30-class绑定的语法" class="headerlink" title="30.class绑定的语法"></a>30.class绑定的语法</h4><p>动态绑定的class可以和普通的class一起使用</p><p>:class可以是字符串，属性，对象，数组，计算属性返回一个对象，或是使用方法的调用返回一个对象或者数组</p><h4 id="31-style绑定的语法"><a href="#31-style绑定的语法" class="headerlink" title="31.style绑定的语法"></a>31.style绑定的语法</h4><p><img src="https://img1.imgtp.com/2022/08/16/7GFaKEon.png" alt="QQ截图20220805023313.png"></p><h4 id="32-name-”value”-动态绑定属性"><a href="#32-name-”value”-动态绑定属性" class="headerlink" title="32.:[name]=”value”  动态绑定属性"></a>32.:[name]=”value”  动态绑定属性</h4><h4 id="33-如下"><a href="#33-如下" class="headerlink" title="33.如下"></a>33.如下</h4> <div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;obj&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> //绑定对象 可以将所有对象的属性遍历，绑定过去</code></pre></div><h4 id="34-v-on事件绑定-简写"><a href="#34-v-on事件绑定-简写" class="headerlink" title="34.v-on事件绑定  @简写"></a>34.v-on事件绑定  @简写</h4><h4 id="35-v-on事件的参数传递"><a href="#35-v-on事件的参数传递" class="headerlink" title="35.v-on事件的参数传递"></a>35.v-on事件的参数传递</h4><p><img src="https://img1.imgtp.com/2022/08/16/gFZd2jBM.png" alt="QQ截图20220806014535.png"></p><h4 id="36-v-on的修饰符"><a href="#36-v-on的修饰符" class="headerlink" title="36.v-on的修饰符"></a>36.v-on的修饰符</h4><p><strong>.stop - 调用 event.stopPropagation()。</strong></p><p><strong>.prevent - 调用 event.preventDefault()。</strong></p><p><strong>.capture - 添加事件侦听器时使用 capture 模式。</strong></p><p><strong>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</strong></p><p><strong>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</strong></p><p><strong>.once - 只触发一次回调。</strong></p><p><strong>.left - 只当点击鼠标左键时触发。</strong></p><p><strong>.right - 只当点击鼠标右键时触发。</strong></p><p><strong>.middle - 只当点击鼠标中键时触发。</strong></p><p><strong>.passive - { passive: true } 模式添加侦听器</strong></p><h4 id="37-v-if-v-else-v-else-if"><a href="#37-v-if-v-else-v-else-if" class="headerlink" title="37.v-if ,v-else, v-else-if"></a>37.v-if ,v-else, v-else-if</h4><p>v-if的渲染原理</p><p>v-if是惰性的，只有在条件判断为true的时候，才会重新渲染。当为false的时候不会渲染</p><h4 id="38-v-show"><a href="#38-v-show" class="headerlink" title="38.v-show"></a>38.v-show</h4><h4 id="39-template元素"><a href="#39-template元素" class="headerlink" title="39.template元素"></a>39.template元素</h4><p>template元素可以在页面中不做渲染，可以用于包裹元素，但是不会在页面中渲染</p><h4 id="40-v-for和v-show的区别"><a href="#40-v-for和v-show的区别" class="headerlink" title="40.v-for和v-show的区别"></a>40.v-for和v-show的区别</h4><p><strong>首先，在用法上的区别：</strong></p><p>v-show是不支持template；</p><p>v-show不可以和v-else一起使用；</p><p><strong>其次，本质的区别：</strong></p><p>v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有存在的，只是通过CSS的display属性来进行切换；</p><p>v-if当条件为false时，其对应的原生压根不会被渲染到DOM中；</p><p><strong>开发中如何进行选择呢？</strong></p><p>如果我们的原生需要在显示和隐藏之间频繁的切换，那么使用v-show；</p><p>如果不会频繁的发生切换，那么使用v-if；</p><h4 id="41-v-for"><a href="#41-v-for" class="headerlink" title="41.v-for"></a>41.v-for</h4><p><img src="https://img1.imgtp.com/2022/08/16/Rt9R3gK5.png" alt="QQ截图20220806191249.png"></p><h4 id="42-数组跟新检测"><a href="#42-数组跟新检测" class="headerlink" title="42.数组跟新检测"></a>42.数组跟新检测</h4><p>vue会对以下数组的方法进行包裹，所以通过这些方法变更数组可以触发页面的更新</p><p><strong>push()</strong></p><p><strong>pop()</strong></p><p><strong>shift()</strong></p><p><strong>unshift()</strong></p><p><strong>splice()</strong></p><p><strong>sort()</strong></p><p><strong>reverse()</strong></p><p>这些方法都会直接修改原来的数组，</p><p>对于一些纯函数的数组方法，他会返回一个新的数组，所以必须将这个新的数组赋值给原来的属性</p><h4 id="43-v-for中key的作用"><a href="#43-v-for中key的作用" class="headerlink" title="43.v-for中key的作用"></a>43.v-for中key的作用</h4><p>key属性主要适用于Diff算法中，在新旧node对比时辨识vnode,如果不使用key,vue会使用一种最大限度减少动态元素并且尽可能的尝试就地复用或者修改相同类型的元素的算法</p><p>而使用了key时，他会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素</p><h4 id="44-什么是vnode"><a href="#44-什么是vnode" class="headerlink" title="44.什么是vnode"></a>44.什么是vnode</h4><p>vnode 全称virual node 就是虚拟节点，组件和元素都会被抽象成一个个虚拟节点，vnode本质就是一个个对象</p><h4 id="45-diff算法"><a href="#45-diff算法" class="headerlink" title="45.diff算法"></a>45.diff算法</h4><p>针对有key的vnode进行diff操作时</p><p><strong>1.首先会对新旧节点进行遍历，从头部开始，遇到相同的节点则继续，直到遇到不用的节点则跳出</strong></p><p><strong>2.然后再从新旧vnode节点的尾部开始遍历，遇到相同的节点则继续，遇到不同的节点则会跳出</strong></p><p><strong>3.如果最后新的节点更多，那么就添加新的节点</strong></p><p><strong>4.如果旧的节点比较多，则会移除旧的节点</strong></p><p><strong>5.如果中间存在无序的节点，就通过key建立所用途最大限度的复用旧节点</strong></p><h4 id="46-computed"><a href="#46-computed" class="headerlink" title="46.computed"></a>46.computed</h4><p>​    computed有缓存，只有依赖的属性发生变化的时候才会重新执行</p><p>​    computed和method的区别</p><p>​            computed是计算属性，method是方法，每次都会调用，computed只有数据变化时才会调用</p><p>​    computed的get set写法</p><p><img src="https://img1.imgtp.com/2022/08/16/u2w0mqRW.png" alt="QQ截图20220806170911.png"></p><h4 id="47-watch"><a href="#47-watch" class="headerlink" title="47.watch"></a>47.watch</h4><p><img src="https://img1.imgtp.com/2022/08/16/c9HE9R2T.png" alt="QQ截图20220807012240.png"></p><h2 id="回调的触发时机"><a href="#回调的触发时机" class="headerlink" title="回调的触发时机#"></a>回调的触发时机<a href="https://cn.vuejs.org/guide/essentials/watchers.html#callback-flush-timing">#</a></h2><p>当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。</p><p>默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新<strong>之前</strong>被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。</p><p>如果想在侦听器回调中能访问被 Vue 更新<strong>之后</strong>的DOM，你需要指明 <code>flush: &#39;post&#39;</code> 选项：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// ...</span>  <span class="hljs-attr">watch</span>: &#123;    <span class="hljs-attr">key</span>: &#123;      <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) &#123;&#125;,      <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span>    &#125;  &#125;&#125;</code></pre></div><h4 id="48-jsconfig-json主要是给vscode中给项目更好的提示，没有也没关系"><a href="#48-jsconfig-json主要是给vscode中给项目更好的提示，没有也没关系" class="headerlink" title="48.jsconfig.json主要是给vscode中给项目更好的提示，没有也没关系"></a>48.jsconfig.json主要是给vscode中给项目更好的提示，没有也没关系</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//vue.config.js</span><span class="hljs-keyword">const</span> &#123; defineConfig &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@vue/cli-service&#x27;</span>)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>(&#123;  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">configureWebpack</span>: &#123;    <span class="hljs-attr">resolve</span>: &#123;      <span class="hljs-comment">// 配置路径别名</span>      <span class="hljs-comment">// @是已经配置好的路径别名: 对应的是src路径</span>      <span class="hljs-attr">alias</span>: &#123;        <span class="hljs-string">&quot;utils&quot;</span>: <span class="hljs-string">&quot;@/utils&quot;</span>       &#125;    &#125;  &#125;&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">//jsconfig.json</span><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;target&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es5&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;esnext&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//定义根目录</span>    <span class="hljs-attr">&quot;moduleResolution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>      <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-string">&quot;src/*&quot;</span>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">//webpack配置了别名，为了给项目中更好的提示，可以在这里配置，否则写的时候没有提示</span>      <span class="hljs-attr">&quot;utils/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>        <span class="hljs-string">&quot;src/utils/*&quot;</span>      <span class="hljs-punctuation">]</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;lib&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>      <span class="hljs-string">&quot;esnext&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-string">&quot;dom&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-string">&quot;dom.iterable&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-string">&quot;scripthost&quot;</span>    <span class="hljs-punctuation">]</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h4 id="49-v-model"><a href="#49-v-model" class="headerlink" title="49.v-model"></a>49.v-model</h4><h4 id="50-使用手脚架开发"><a href="#50-使用手脚架开发" class="headerlink" title="50.使用手脚架开发"></a>50.使用手脚架开发</h4><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @vue<span class="hljs-regexp">/cli -g   /</span>/安装手脚架<span class="hljs-built_in">npm</span> update @vue<span class="hljs-regexp">/cli -g /</span>/更手脚架Vue create 项目的名称这种方式采用webpack作为构建工具现在官方已经不再作为推荐的手脚搭建工具了开始使用<span class="hljs-built_in">npm</span> init vue@latest 命令  使用vite作为构建工具</code></pre></div><img src="https://img1.imgtp.com/2022/08/15/2VVktFIN.png" alt="图片1.png" style="zoom:200%;" /><img src="https://img1.imgtp.com/2022/08/15/QcWf8mgQ.png" alt="图片2.png" style="zoom:200%;" /><img src="https://img1.imgtp.com/2022/08/15/hS9wL3j1.png" alt="图片3.png" style="zoom:200%;" /><img src="https://img1.imgtp.com/2022/08/15/0QrTy1qq.png" alt="图片4.png" style="zoom:200%;" /><p><img src="https://img1.imgtp.com/2022/08/16/v3jDRHw7.png" alt="QQ截图20220815210717.png"></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue/dist/vue.esm-bundler&quot;</span>;<span class="hljs-comment">// import App from &#x27;./App.vue&#x27;</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 当App是以对象的形式写的话就要使用 vue/dist/vue.esm-bundler</span><span class="hljs-comment"> * 这两种方式的不同，使用对象的方式，是因为如果引入的是vue,vue是runtime的代码，，不会编译template成</span><span class="hljs-comment"> * vnode,需要使用vue/dist/vue.esm-bundler</span><span class="hljs-comment"> * 里面包括compiler+runtime，可以将template-&gt;createVNode-&gt;Vnode-&gt;DOM,对象的写法是由</span><span class="hljs-comment"> * vue/dist/vue.esm-bundler的源码来完成的，.vue文件的写法是由vue-loader来完成template-&gt;vnode的过程</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = &#123;  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> &#123;&#125;;  &#125;,  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h1&gt;vue&lt;/h1&gt;`</span>,&#125;;<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>);</code></pre></div><h4 id="51-注册组件的方式"><a href="#51-注册组件的方式" class="headerlink" title="51.注册组件的方式"></a>51.注册组件的方式</h4><p>全局组件</p><p>局部组件</p><h4 id="52-父组件向子组件传递数据"><a href="#52-父组件向子组件传递数据" class="headerlink" title="52.父组件向子组件传递数据"></a>52.父组件向子组件传递数据</h4><p>父组件向子组件传递数据是通过props来完成的</p><div class="code-wrapper"><pre><code class="hljs js">&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// 写法一</span>  <span class="hljs-comment">// props: [&quot;height&quot;, &quot;name&quot;, &quot;gender&quot;, &quot;width&quot;],</span>  <span class="hljs-comment">// 写法二</span>  <span class="hljs-comment">// props: &#123;</span>  <span class="hljs-comment">//   height: Object,</span>  <span class="hljs-comment">//   name: Number,</span>  <span class="hljs-comment">//   gender: String,</span>  <span class="hljs-comment">//   width: Number,</span>  <span class="hljs-comment">// &#125;,</span>  <span class="hljs-comment">// 第三种写法</span>  <span class="hljs-comment">// 当默认值是对象或者函数的时候，必须返回一个函数</span>  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">propsB</span>: &#123;      <span class="hljs-comment">// 当props是一个函数的时候，这个不是一个工厂函数，而是作为一个默认值</span>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>,      <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;default&quot;</span>;      &#125;,    &#125;,    <span class="hljs-attr">h</span>: [<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">String</span>], <span class="hljs-comment">//可以是多种类型</span>    <span class="hljs-attr">a</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//表示是必填值</span>    &#125;,    <span class="hljs-attr">height</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,      <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;hhhh&quot;</span> &#125;),    &#125;,    <span class="hljs-attr">name</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,      <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;我是string&quot;</span>,    &#125;,    <span class="hljs-attr">gender</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,      <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];      &#125;,    &#125;,    <span class="hljs-attr">width</span>: &#123;      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,      <span class="hljs-attr">default</span>: <span class="hljs-number">88888</span>,    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre></div><h5 id="prop常见的两种用法"><a href="#prop常见的两种用法" class="headerlink" title="prop常见的两种用法"></a>prop常见的两种用法</h5><p>字符串数组，就是数组中的字符串就是attribute的名称，传递的数据类型时只能是字符串，不能是其他类型</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">show-info</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;why&quot;</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">:height</span>=<span class="hljs-string">&quot;1.88&quot;</span> </span><span class="hljs-tag">             <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;广州市&quot;</span> <span class="hljs-attr">abc</span>=<span class="hljs-string">&quot;cba&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span> /&gt;</span>//传递的数据类型不是string值，是其他类型或者是变量，必须用v-bind/:</code></pre></div><p>对象类型，对象类型我们可以指定attribute名称时，指定传递类型默认值，校验等</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">show-info</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">show-message</span>=<span class="hljs-string">&quot;哈哈哈哈&quot;</span>/&gt;</span></code></pre></div><h5 id="props允许的数据类型"><a href="#props允许的数据类型" class="headerlink" title="props允许的数据类型"></a>props允许的数据类型</h5><p><code>String,Number,Boolean,Array,Object,Date,Function,Symbol</code></p><h5 id="props的命名"><a href="#props的命名" class="headerlink" title="props的命名"></a>props的命名</h5><p>html中attribute名大小写不敏感，所以浏览器会把所有大写解释为小写，在模板中使用驼峰规则，的prop名要写成短横线</p><h4 id="53-非prop的attribute"><a href="#53-非prop的attribute" class="headerlink" title="53.非prop的attribute"></a>53.非prop的attribute</h4><p>当我们传递一个组件某个属性值，但是这个属性值没有对应的props和emits，就是非props的attribute，例如class,style,id等。</p><p>当组件有单个根节点时，非prop的attribute就会默认绑定到根节点上</p><p>如果不希望绑定到根节点，想要手动的绑定节点，可以在组件中设置</p><div class="code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-symbol">inheritAttr:</span><span class="hljs-literal">false</span></code></pre></div><p>就可以通过$attrs来访问所有的非props的attribute</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;$attr.class&quot;</span>&gt;</span>hhhhhhhh<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">    <span class="hljs-attr">inheritAttrs</span>:<span class="hljs-literal">false</span></span><span class="language-javascript">  &#125;</span></code></pre></div><p><strong>多个根节点的attribute</strong></p><p>如果是多个根节点的情况，多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个元素上</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attr&quot;</span>&gt;</span>hhhhhhhh<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>33333<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>4444<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p><em>注意</em>template模板中允许有多个根节点</p><h4 id="54-子组件向父组件从传递数据"><a href="#54-子组件向父组件从传递数据" class="headerlink" title="54.子组件向父组件从传递数据"></a>54.子组件向父组件从传递数据</h4><div class="code-wrapper"><pre><code class="hljs html">//子组件<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick(1)&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick(5)&quot;</span>&gt;</span>+5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;btnClick(10)&quot;</span>&gt;</span>+10<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">    <span class="hljs-comment">// 1.emits数组语法</span></span><span class="language-javascript">    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&quot;add&quot;</span>],</span><span class="language-javascript">    <span class="hljs-comment">// 2.emmits对象语法</span></span><span class="language-javascript">    <span class="hljs-comment">// emits: &#123;</span></span><span class="language-javascript">    <span class="hljs-comment">//   add: function(count) &#123;</span></span><span class="language-javascript">    <span class="hljs-comment">//     if (count &lt;= 10) &#123;</span></span><span class="language-javascript">    <span class="hljs-comment">//       return true</span></span><span class="language-javascript">    <span class="hljs-comment">//     &#125;</span></span><span class="language-javascript">    <span class="hljs-comment">//     return false</span></span><span class="language-javascript">    <span class="hljs-comment">//   &#125;</span></span><span class="language-javascript">    <span class="hljs-comment">// &#125;,</span></span><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title function_">btnClick</span>(<span class="hljs-params">count</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btnClick:&quot;</span>, count)</span><span class="language-javascript">        <span class="hljs-comment">// 让子组件发出去一个自定义事件</span></span><span class="language-javascript">        <span class="hljs-comment">// 第一个参数自定义的事件名称</span></span><span class="language-javascript">        <span class="hljs-comment">// 第二个参数是传递的参数</span></span><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-number">100</span>)</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//app,vue<span class="hljs-tag">&lt;<span class="hljs-name">add-counter</span> @<span class="hljs-attr">add</span>=<span class="hljs-string">&quot;addBtnClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">add-counter</span>&gt;</span></code></pre></div><h4 id="55-插槽slot"><a href="#55-插槽slot" class="headerlink" title="55.插槽slot"></a>55.插槽slot</h4><p>插槽的使用过程其实是抽取共性、预留不同</p><div class="code-wrapper"><pre><code class="hljs html">//show-message.vue//插槽的定义方式，使用<span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>标签进行占位，可以写入默认值，没有传递时就是用默认值<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是默认内容, 哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//插槽的使用<span class="hljs-tag">&lt;<span class="hljs-name">show-message</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>百度一下<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">show-message</span>&gt;</span></code></pre></div><h4 id="56-具名插槽的使用"><a href="#56-具名插槽的使用" class="headerlink" title="56.具名插槽的使用"></a>56.具名插槽的使用</h4><p>当需要插入不同的模块到不同的slot的时候，需要定义具体的名字。默认情况下不带名字时，会有默认的名字。</p><p>一个不带 name 的slot，会带有隐含的名字 default；</p><p>具名插槽使用的时候缩写：</p><p>跟 v-on 和 v-bind 一样，v-slot 也有缩写； </p><p> 即把参数之前的所有内容 (v-slot:) 替换为字符 #；</p><div class="code-wrapper"><pre><code class="hljs html">//nav-bar.vue<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav-bar&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;other&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//App.vue<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">nav-bar</span>&gt;</span>  //简写    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">left</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#123; leftText &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">center</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>//完整写法    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:right</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">nav-bar</span>&gt;</span>  <span class="hljs-comment">&lt;!-- nav-bar只给一个插槽传入数据 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">nav-bar</span>&gt;</span>  //动态插槽名    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">position</span>]&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">nav-bar</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot; position = &#x27;left&#x27; &quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot; position = &#x27;center&#x27; &quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot; position = &#x27;right&#x27; &quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">NavBar</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./NavBar.vue&#x27;</span></span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><span class="language-javascript">      <span class="hljs-title class_">NavBar</span></span><span class="language-javascript">    &#125;,</span><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">        <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;center&quot;</span>,</span><span class="language-javascript">        <span class="hljs-attr">leftText</span>: <span class="hljs-string">&quot;返回&quot;</span></span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h4 id="57-渲染作用域"><a href="#57-渲染作用域" class="headerlink" title="57.渲染作用域"></a>57.渲染作用域</h4><p>在vue模板中，父级模板的所有内容都是在父级作用域中编译完成的</p><p>子模版中所有内容都是在作用域中编译完成的，所以具名插槽的作用域是在父级，而作用域插槽的作用域是在子模版中</p><h4 id="58-作用域插槽"><a href="#58-作用域插槽" class="headerlink" title="58.作用域插槽"></a>58.作用域插槽</h4><p>作用域插槽可以通过插槽访问子组件的内容，而修改每个具体的样式</p><div class="code-wrapper"><pre><code class="hljs html">//tabControll.vue<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tab-control&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in titles&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tab-control-item&quot;</span></span><span class="hljs-tag">           <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: index === currentIndex &#125;&quot;</span></span><span class="hljs-tag">           @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;itemClick(index)&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">abc</span>=<span class="hljs-string">&quot;cba&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>//这是默认值        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">//App.vue<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.tab-control --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- &lt;tab-control :titles=&quot;[&#x27;流行&#x27;, &#x27;最新&#x27;, &#x27;优选&#x27;]&quot;/&gt; --&gt;</span>    <span class="hljs-comment">&lt;!-- 2.展示内容 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; pageContents[currentIndex] &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 1.tab-control: button --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-control</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 2.tab-control: a元素(重要) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-control</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 3.独占默认插槽的简写(了解) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-control</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 4.如果只有一个默认插槽, 那么template可以省略 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-control</span> <span class="hljs-attr">:titles</span>=<span class="hljs-string">&quot;[&#x27;衣服&#x27;, &#x27;鞋子&#x27;, &#x27;裤子&#x27;]&quot;</span> </span><span class="hljs-tag">                 @<span class="hljs-attr">tab-item-click</span>=<span class="hljs-string">&quot;tabItemClick&quot;</span></span><span class="hljs-tag">                 <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;props&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;&#123; props.item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-control</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h4 id="59-非父子组件之间的通信"><a href="#59-非父子组件之间的通信" class="headerlink" title="59.非父子组件之间的通信"></a>59.非父子组件之间的通信</h4><p>1.全局的事件总线</p><p>vue3中移除了$on,$off,$once方法，如果需要使用事件总线，可以使用第三方库，或者通过自己写的事件总线方法。事件总线不经可以用于非父子组件的通信，也可以用于任意组件的通信</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//event-bus.js  事件总线初始化</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HYEventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hy-event-store&#x27;</span><span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HYEventBus</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> eventBus</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//App.vue   在created声明周期中监听事件</span><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-comment">// fetch()</span>      <span class="hljs-comment">// 事件监听</span>      eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;whyEvent&quot;</span>, <span class="hljs-function">(<span class="hljs-params">name, age, height</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;whyEvent事件在app中监听&quot;</span>, name, age, height)        <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">`name:<span class="hljs-subst">$&#123;name&#125;</span>, age:<span class="hljs-subst">$&#123;age&#125;</span>, height:<span class="hljs-subst">$&#123;height&#125;</span>`</span>      &#125;)    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//在Category.vue中 created中监听，在unmounted中移出事件</span><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils/event-bus&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">whyEventHandler</span>(<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;whyEvent在category中监听&quot;</span>)    &#125;  &#125;,  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;whyEvent&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">whyEventHandler</span>)  &#125;,  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;category unmounted&quot;</span>)    eventBus.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;whyEvent&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">whyEventHandler</span>)  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//HomeBanner.vue  emit事件</span><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils/event-bus&#x27;</span> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;   <span class="hljs-attr">methods</span>: &#123;     <span class="hljs-title function_">bannerBtnClick</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bannerBtnClick&quot;</span>)       eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;whyEvent&quot;</span>, <span class="hljs-string">&quot;why&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1.88</span>)     &#125;   &#125; &#125;</code></pre></div><p>2.Provide/inject</p><p>provide和inject可以用于跨组件的通信</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//App.vue</span><span class="hljs-comment">// provide一般都是写成函数 也可以写成对象，如果需要使用data中的属性，必须使用函数形式</span>   <span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-keyword">return</span> &#123;       <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,       <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,       <span class="hljs-comment">//默认不是响应式的，如果需要变成响应式的，要使用computed，computed的返回值是一个ref对象，需要使用.value来获取</span>       <span class="hljs-attr">message</span>: <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<span class="hljs-comment">//要写箭头函数，箭头函数的this是由上层作用域来决定的</span>     &#125;   &#125; &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div class=&quot;banner&quot;&gt;    &lt;h2&gt;HomeBanner: &#123;&#123; name &#125;&#125; - &#123;&#123; age &#125;&#125; - &#123;&#123;message.value&#125;&#125;&lt;/h2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    inject: [&quot;name&quot;, &quot;age&quot;, &quot;message&quot;]  &#125;&lt;/script&gt;</code></pre></div><h4 id="60-组件的生命周期"><a href="#60-组件的生命周期" class="headerlink" title="60.组件的生命周期"></a>60.组件的生命周期</h4><p><img src="https://img1.imgtp.com/2022/08/17/Lqxt3NMi.png" alt="lifecycle.16e4c08e.png"></p><p>父子组件的挂载过程</p><p>父组件beforeCreate -&gt;父组件created-&gt;父组件beforemount-&gt;子组件beforeCreate-&gt;子组件created-&gt; 子组件beforeMount-&gt;子组件mounted-&gt;父组件mounted</p><h4 id="61-refs的使用"><a href="#61-refs的使用" class="headerlink" title="61.$refs的使用"></a>61.$refs的使用</h4><p>通过$refs可以获取到子元素或者子组件</p><p>通过<code>this.$refs.refName</code>可以获取到子组件实例，子组件实例是一个Proxy代理，vue组件是一个对象类似于一个class，根据class创建一个组件实例，通过<code>this.$refs.refname.$el</code>可以获取到组件DOM元素。，<code>this.$parent</code>获取到父组件元素，<code>this.$root</code>获取到根组件元素，$ref还可以调用子组件的属性和方法在Vue3中已经移除了$children的属性</p><p>如果template中由多个根，拿到的是第一个node节点</p><p><img src="https://img1.imgtp.com/2022/08/17/RTih8iQq.png" alt="QQ截图20220817150027.png"></p><h4 id="62-动态组件"><a href="#62-动态组件" class="headerlink" title="62.动态组件"></a>62.动态组件</h4><p>is中的组件只能是局部已注册的组件和全局组件</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;why&quot;</span> </span><span class="hljs-tag">                 <span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;18&quot;</span></span><span class="hljs-tag">                 @<span class="hljs-attr">homeClick</span>=<span class="hljs-string">&quot;homeClick&quot;</span></span><span class="hljs-tag">                 <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentTab&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></code></pre></div><h4 id="63-组件缓存keep-alive"><a href="#63-组件缓存keep-alive" class="headerlink" title="63.组件缓存keep-alive"></a>63.组件缓存keep-alive</h4><p>如果组件频繁的切换会造成性能消耗增加，如果需要保存组件切换之前的状态，可以使用keep-alive，他通常和Component动态组件一起使用</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!-- include: 组件的名称来自于组件内部定义时name选项  --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;home,about&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentTab&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h5 id="include-exclude"><a href="#include-exclude" class="headerlink" title="include/exclude"></a>include/exclude</h5><p><code>&lt;KeepAlive&gt;</code> 默认会缓存内部的所有组件实例，但我们可以通过 <code>include</code> 和 <code>exclude</code> prop 来定制该行为。这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 以英文逗号分隔的字符串 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;a,b&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span><span class="hljs-comment">&lt;!-- 正则表达式 (需使用 `v-bind`) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;/a|b/&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span><span class="hljs-comment">&lt;!-- 数组 (需使用 `v-bind`) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span></code></pre></div><p>它会根据组件的 <a href="https://cn.vuejs.org/api/options-misc.html#name"><code>name</code></a> 选项进行匹配，所以组件如果想要条件性地被 <code>KeepAlive</code> 缓存，就必须显式声明一个 <code>name</code> 选项</p><p><em>TIP</em></p><p><em>在 3.2.34 或以上的版本中，使用 <code>&lt;script setup&gt;</code> 的单文件组件会自动根据文件名生成对应的 <code>name</code> 选项，无需再手动声明。</em></p><h5 id="最大缓存实例数-https-cn-vuejs-org-guide-built-ins-keep-alive-html-max-cached-instances"><a href="#最大缓存实例数-https-cn-vuejs-org-guide-built-ins-keep-alive-html-max-cached-instances" class="headerlink" title="最大缓存实例数[#](https://cn.vuejs.org/guide/built-ins/keep-alive.html#max-cached-instances"></a>最大缓存实例数[#](<a href="https://cn.vuejs.org/guide/built-ins/keep-alive.html#max-cached-instances">https://cn.vuejs.org/guide/built-ins/keep-alive.html#max-cached-instances</a></h5><p>我们可以通过传入 <code>max</code> prop 来限制可被缓存的最大组件实例数。<code>&lt;KeepAlive&gt;</code> 的行为在指定了 <code>max</code> 后类似一个 <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">LRU 缓存</a>：如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span> <span class="hljs-attr">:max</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;activeComponent&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span></code></pre></div><p>缓存实例的生命周期</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">activated</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 在首次挂载、</span>    <span class="hljs-comment">// 以及每次从缓存中被重新插入的时候调用</span>  &#125;,  <span class="hljs-title function_">deactivated</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 在从 DOM 上移除、进入缓存</span>    <span class="hljs-comment">// 以及组件卸载时调用</span>  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现可过期的localstorage数据(仅供参考)</title>
    <link href="/2022/08/15/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84localstorage%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/08/15/%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%BF%87%E6%9C%9F%E7%9A%84localstorage%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>localstorage相对于cookie中的问题是不能设置过期时间</p><p>所以我们要自己对localStorage进行二次封装，使得localstorage在适当的时间失效</p><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-keyword">const</span> timeout = <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;key&quot;</span>);&#125;, timeout);</code></pre></div><p>这种方式需要编写多个定时器，维护成本高，不利于代码的复用</p><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><ol><li>用<strong>「localStorage」</strong>存一份{key(键): expire(过期时间)}的映射表</li><li>重写<strong>「localStorage API」</strong>, 对方法进行二次封装</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = &#123;  <span class="hljs-title function_">setExpireMap</span>(<span class="hljs-params">key, expire</span>) &#123;    <span class="hljs-keyword">const</span> expireMap = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;EXPIRE_MAP&quot;</span>) || &#123;&#125;;    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(      <span class="hljs-string">&quot;EXPIRE_MAP&quot;</span>,      <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;        ...expireMap,        [key]: expire,      &#125;)    );  &#125;,  <span class="hljs-title function_">setItem</span>(<span class="hljs-params">key, value, expire</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setExpireMap</span>(key, expire);    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, value);  &#125;,  <span class="hljs-title function_">getItem</span>(<span class="hljs-params">key</span>) &#123;    <span class="hljs-keyword">const</span> expireMap = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;EXPIRE_MAP&quot;</span>))[key];    <span class="hljs-keyword">if</span> (expireMap &amp;&amp; expireMap &gt; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key);    &#125;    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key);    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;,&#125;;</code></pre></div><ul><li>对 <code>store</code> 操作时需要维护2份数据, 并且占用缓存空间</li><li>如果 <code>EXPIRE_MAP</code> 误删除将会导致所有过期时间失效</li><li>对操作过程缺少更灵活的控制(比如操作状态, 操作回调等)</li></ul><h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>惰性删除，只有在下一次取值的时候才删除</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lsc = (<span class="hljs-keyword">function</span> (<span class="hljs-params">self</span>) &#123;    <span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&#x27;one_more_lsc_&#x27;</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加一个键值对数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val 值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expires 过期时间，单位为秒</span><span class="hljs-comment">     */</span>    self.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">key, val, expires</span>) &#123;        key = prefix + key;        val = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<span class="hljs-string">&#x27;val&#x27;</span>: val, <span class="hljs-string">&#x27;expires&#x27;</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() + expires * <span class="hljs-number">1000</span>&#125;);        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, val);    &#125;;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 读取对应键的值数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 键</span><span class="hljs-comment">     * <span class="hljs-doctag">@returns</span> &#123;<span class="hljs-type">null|*</span>&#125; 对应键的值</span><span class="hljs-comment">     */</span>    self.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) &#123;        key = prefix + key;        <span class="hljs-keyword">var</span> val = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key);        <span class="hljs-keyword">if</span> (!val) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        val = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(val);        <span class="hljs-keyword">if</span> (val.<span class="hljs-property">expires</span> &lt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()) &#123;            <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-keyword">return</span> val.<span class="hljs-property">val</span>;    &#125;;    <span class="hljs-keyword">return</span> self;&#125;(lsc || &#123;&#125;));</code></pre></div><p>上述代码通过惰性删除已经实现了可过期的localStorage缓存，但是也有比较明显的缺点：如果一个key一直没有被用到，即使它已经过期了也永远存放在localStorage。为了弥补这样缺点，我们引入另一种清理过期缓存的策略。</p><h4 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h4><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。</p><p>每隔一秒执行一次定时删除，操作如下：</p><ol><li>随机测试20个设置了过期时间的key。</li><li>删除所有发现的已过期的key。</li><li>若删除的key超过5个则重复<strong>步骤1</strong>，直至重复500次。</li></ol><p>具体实现如下：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lsc = (<span class="hljs-keyword">function</span> (<span class="hljs-params">self</span>) &#123;    <span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&#x27;one_more_lsc_&#x27;</span>    <span class="hljs-keyword">var</span> list = [];    <span class="hljs-comment">//初始化list</span>    self.<span class="hljs-property">init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">var</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">localStorage</span>);        <span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;^&#x27;</span> + prefix);        <span class="hljs-keyword">var</span> temp = [];        <span class="hljs-comment">//遍历所有localStorage中的所有key</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-comment">//找出可过期缓存的key</span>            <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(keys[i])) &#123;                temp.<span class="hljs-title function_">push</span>(keys[i]);            &#125;        &#125;        list = temp;    &#125;;    self.<span class="hljs-title function_">init</span>();    self.<span class="hljs-property">check</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">if</span> (!list || list.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">var</span> checkCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (checkCount &lt; <span class="hljs-number">500</span>) &#123;            <span class="hljs-keyword">var</span> expireCount = <span class="hljs-number">0</span>;            <span class="hljs-comment">//随机测试20个设置了过期时间的key</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;                <span class="hljs-keyword">if</span> (list.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">var</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * list.<span class="hljs-property">length</span>);                <span class="hljs-keyword">var</span> key = list[index];                <span class="hljs-keyword">var</span> val = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(list[index]);                <span class="hljs-comment">//从list中删除被惰性删除的key</span>                <span class="hljs-keyword">if</span> (!val) &#123;                    list.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);                    expireCount++;                    <span class="hljs-keyword">continue</span>;                &#125;                val = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(val);                <span class="hljs-comment">//删除所有发现的已过期的key</span>                <span class="hljs-keyword">if</span> (val.<span class="hljs-property">expires</span> &lt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()) &#123;                    list.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);                    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key);                    expireCount++;                &#125;            &#125;            <span class="hljs-comment">//若删除的key不超过5个则跳出循环</span>            <span class="hljs-keyword">if</span> (expireCount &lt;= <span class="hljs-number">5</span> || list.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">break</span>;            &#125;            checkCount++;        &#125;    &#125;    <span class="hljs-comment">//每隔一秒执行一次定时删除</span>    <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setInterval</span>(self.<span class="hljs-property">check</span>, <span class="hljs-number">1000</span>);    <span class="hljs-keyword">return</span> self;&#125;(lsc || &#123;&#125;));</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
      <category>搜集</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端系统课笔记</title>
    <link href="/2022/08/14/%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/14/%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs stata">1.margin-left的值如果是百分比时，相对于他的包含块的宽度的百分比，即他的父元素2.性能优化点：link ref=`dns-prefetch`dns预获取，在资源加载之前获取到真实的ip地址3.rgb R红 <span class="hljs-keyword">G</span>绿 B蓝  \#ff0000 十六进制表示法  rgb(0，0，0) 十进制表示4.image/vedio是行内可替换元素，不是行内块级元素5.<span class="hljs-keyword">line</span>-hight是继承属性6.#表示多个属性是以逗号分隔7.+表示多个属性是以空格分隔8.text-align 时将行内元素相对于父级块元素进行居中例如img 文本 <span class="hljs-keyword">input</span>等9.text-ident和width以em为单位的时候是相对于自身的，font-size可以从父元素继承，如果父元素设置了font-size则会继承下来并相对于自身10.普遍兄弟选择器只能选中下面的所有兄弟元素11.script标签放到html的头部时要加<span class="hljs-keyword">window</span>.onload12.伪类hover,link,visited,active的执行顺序 LVHA13.除了a标签，hover和active也可以用在其他元素上14.a元素没有设置伪类，默认所有伪类都是相同的设置15.::first-<span class="hljs-keyword">line</span>选中首行元素::first-letter选中首字母元素之间的间隙默认是换行符，去掉换行符可以::after&#123;content:url(<span class="hljs-string">&quot;./image/icon.svg&quot;</span>);<span class="hljs-comment">//可以这样来添加图片</span>color:green&#125;&lt;p&gt;这是上面代码的实现&lt;<span class="hljs-keyword">br</span> /&gt;  我们有一些 &lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;collection of words and punctuation&quot;</span>&gt;文字&lt;/span&gt; 有一些  &lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;small popups which also hide again&quot;</span>&gt;提示&lt;/span&gt;。&lt;<span class="hljs-keyword">br</span> /&gt;  把鼠标放上去&lt;span data-<span class="hljs-keyword">descr</span>=<span class="hljs-string">&quot;not to be taken literally&quot;</span>&gt;看看&lt;/span&gt;。&lt;/p&gt;<span class="hljs-comment">//自定义属性</span>::after伪元素，attr()CSS表达式和一个自定义数据属性 data-<span class="hljs-keyword">descr</span> 创建一个纯CSS content: attr(data-<span class="hljs-keyword">descr</span>);   16.怎么画0.5px的线 17.常见的继承属性：font-size,font-weight,font-family,<span class="hljs-keyword">line</span>-height,color,text-align一般和文本有关的 1.  css的权重 important 10000 内联选择器 1000 id选择器 100 类选择器，属性选择器，伪类 10 元素选择器，伪元素 1 通配选择器  019.img，vedio,<span class="hljs-keyword">input</span>是行内替换元素  和其他行内元素在一行显示，可以设置宽高行内非替换元素不可以设置宽高20.伪元素是行内非替换元素，不可以设置宽高，必须转成行内块级元素和块级元素，在使用伪元素过程中必须加content21.不要在p元素里面放块元素22.行内元素不要放块级元素，只能放行内元素23.设置元素不可见的方式1.<span class="hljs-keyword">display</span>:none 不占据任何空间2.visibility:hidden占据空间不可见3.设置颜色透明度4.background:transparent可以是背景颜色透明5.opacity:1,可以设置透明度，但是会使子元素也会变透明，具有穿透性24.padding:10px 20px 30px 写三个值得时候，左边没有值，用右边的替代25.border-radius百分比圆角水平方向是width+border的百分比，圆角垂直方向是height+border的百分比border-radius:50%是个圆，超过百分之50%也是圆，超过50%，无效26.marginmargin的传递 左右margin不传递margin-top的传递 如果块级元素顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top就会传递给父元素margin-bottom如果块级元素的底部线和父元素的底部线出现重叠，且父元素高度为auto时，会传递解决：1.父元素设置border 2.父元素使用padding 3.触发bfc上下margin的折叠 兄弟块元素上下两个margin合并成一个margin，折叠后取较大的值。解决方法只设置一个父子之间折叠，也会出线相同的情况27.outline  外轮廓不占据空间，默认显示在border外面 outlone:none可以去除a元素，<span class="hljs-keyword">input</span>元素focus状态下的默认外轮廓28.box-shadow:offset-x offset-y blur(模糊度) 向外扩散的值 color ，多个阴影以逗号分隔，会叠加29.text-shadow:文字添加阴影27.行内非替换元素的注意事项1.不可以设置width和height2.设置margin-top.margin-bottom不生效，margi-left和margin-right生效3.设置padding-top,padding-bottom会不等高，且不占据空间，设置padding-right和padding-left生效4.设置border和padding给相同效果28.html5语义化标签&lt;header&gt;&lt;nav&gt;&lt;section&gt;&lt;artical&gt;&lt;aside&gt;&lt;footer&gt;29.vedio和audio时行内替换元素   在针对不同的播放格式写法   &lt;vedio src=<span class="hljs-string">&quot;&quot;</span>&gt;   &lt;source src=<span class="hljs-string">&quot;.../....mp4&quot;</span>&gt;&lt;/source&gt;   &lt;source src=<span class="hljs-string">&quot;.avi&quot;</span>&gt;&lt;/source&gt;   &lt;source src=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/source&gt;   &lt;p&gt;该浏览器不支持&lt;/p&gt;   &lt;/vedio&gt;30.data-*自定义属性，可以html和js中进行数据传递31.white-space:normal|nowrap|pre|.....32.text-overflow:clip|esclip text-overflow必须在overflow不是visible才生效33.css函数1.<span class="hljs-keyword">var</span> 定义CSS变量属性名要以--开头html&#123;--main-color:#fffff&#125;div&#123;color:<span class="hljs-keyword">var</span>(--main-color)&#125;2.calc 计算CSS值，3.blur  高斯模糊--毛玻璃效果  blur(radius)可以应用于图片或者元素，radius模糊半径可以和filter一起使用。filter:blur(5px)，会使所有子元素都有高斯模糊图片的高斯模糊也可以在图片上添加一个遮盖层，用定位元素父元素：position:relative.cover&#123;position:absolutetop:0left:0right:0bottom:0background:rgba(0,0,0,.5)<span class="hljs-comment">//透明效果</span>background-filter:blur(5px)<span class="hljs-comment">//高斯模糊</span>&#125;4.gradient 颜色渐变函数 是一种&lt;image&gt;css数据类型的子类型，用于图片颜色的过度转变  liner-gradient 线性渐变 background-image:linear-gradient(to right top ,red,blue)     34.background背景色对也border,padding有效   color前景色对border也是有效的，border没有设置颜色时，会使用color的值  35.浏览器前缀：-o-,-xv-,-ms-,-mso-,0moz-.-webkit-36.bfc 兄弟块元素margin折叠35.媒体查询36.css单位em rempxvw/vh%37.less定义变量 @mainColor:#ffff使用变量 @mainColor兼容css&amp;:hover &amp;::afterless的运算less的混合(Mixins)    .box2(@borderwidth:1px,@borderColor:red)&#123;    border:@borderwidth solid @borderColor    &#125;    .box-size&#123;    width:100px;    height:200px    &#125;.box&#123;<span class="hljs-comment">//混入方式,可以传参</span>.box2(2px,green)width:.box-size[width]<span class="hljs-comment">//混入和映射结合使用</span>&amp;:extend(.box-size) <span class="hljs-comment">//继承</span>&#125;less内置函数.box&#123;color:color(red)<span class="hljs-comment">//将转换成16进制</span>width:convert(100px,<span class="hljs-string">&quot;in&quot;</span>)单位准换，转成英寸<span class="hljs-built_in">floor</span>()向下取整<span class="hljs-built_in">ceil</span>()向上取整&#125;less的作用域：查找一个变量时，会在本地和混入先查找，然后再父级查找less的注释less的导入 import38.移动端适配   视口viewport   布局视口   视觉视口   理想视口   &lt;<span class="hljs-keyword">meta</span> name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=980px&quot;</span>&gt;<span class="hljs-comment">//修改布局视口的宽度，对pc端无效</span>   &lt;<span class="hljs-keyword">meta</span> name=<span class="hljs-string">&quot;viewport&quot;</span> content=&quot;device-width，initial-<span class="hljs-keyword">scal</span>=1.0,user-scalable=<span class="hljs-keyword">no</span>   minimun-<span class="hljs-keyword">scal</span>=1.0,maximun-scale=1.0   &gt;39.css的相对单位em,是相对于自身的font-size来进行定位的，如果自己已经定义了font-size的px，则用自身的font-size,否则就继承自父元素的font-sizerem是基于根元素的字体的大小vw是视窗宽度的1%vh是视窗高度的1%40.再pc端，布局视口和视觉视口是同一个，不用区分默认情况下，一个在PC端的网页在移动端会如何显示呢？ 第一，它会按照宽度为980px来布局一个页面的盒子和内容； 第二，为了显示可以完整的显示在页面中，对整个页面进行缩小我们相对于980px布局的这个视口，称之为布局视口（layout viewport）； 布局视口的默认宽度是980px；视觉视口（visual viewport） 如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用户的可见区域中； 那么显示在可见区域的这个视口，就是视觉视口（visual viewport）41.适配方案 – rem+动态html的font-size   使用该方案有两个问题    问题一：针对不同的屏幕，设置html不同的font-size；     问题二：将原来要设置的尺寸，转化成rem单位；    方案一：媒体查询     可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸；     缺点：    ✓ 1.我们需要针对不同的屏幕编写大量的媒体查询；    ✓ 2.如果动态改变尺寸，不会实时的进行更新；    ◼ 方案二：编写js代码     如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码；     方法：    ✓ 1.根据html的宽度计算出font-size的大小，并且设置到html上；    ✓ 2.监听页面的实时改变，并且重新设置font-size的大小到html上；        rem的单位换算方案一：手动换算方案二：less/scss函数◼ 方案四：VSCode插件 px to rem 的插件，在编写时自动转化◼ 方案四：VSCode插件 px to rem 的插件，在编写时自动转化三：postcss-pxtorem42。<span class="hljs-keyword">meta</span>标签的作用可以在head中定义元信息，例如 比如标题title、样式style、link外部资源等；     <span class="hljs-keyword">meta</span>用于定义那些不能使用其他定元相关（<span class="hljs-keyword">meta</span>-related）元素定义的任何元数据信息；    <span class="hljs-keyword">meta</span> 元素定义的元数据的类型包括以下几种：             如果设置了 charset 属性，<span class="hljs-keyword">meta</span> 元素是一个字符集声明，告诉文档使用哪种字符编码。             如果设置了 http-equiv 属性，<span class="hljs-keyword">meta</span> 元素则是编译指令。             如果设置了 name 属性，<span class="hljs-keyword">meta</span> 元素提供的是文档级别（document-level）的元数据，应用于整个页面。            例如：robots，author，<span class="hljs-keyword">Copyright</span>，description，keywords             43.link图标 &lt;link rel=<span class="hljs-string">&quot;icon&quot;</span> href=<span class="hljs-string">&quot;https:;;;;&quot;</span> /&gt; 也可以直接将该favicon.ico直接置于根目录下，不需要使用link来引入，因为大部分浏览器都可以识别   44.CSS样式的字符编码 开发中推荐在CSS的开头编写@charset指定编码：@import <span class="hljs-string">&quot;utf-8&quot;</span> 45.全局属性data-* data设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到；通常用于HTML和JavaScript数据之间的传递；46.<span class="hljs-string">&quot;&quot;</span>==null <span class="hljs-comment">//false</span>null和undefined不能转换成任何数据类型进行比较47.<span class="hljs-keyword">const</span> obj=&#123;[Symbol.toPrimitive]()&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span>&#125;&#125;48.转换成boolean的方式Boolean(a)!!a49.switch case 是严格匹配===，还要防止case穿透50.npxnpx 是 npm v5.2.0 引入的一条命令（ npx ），是一个 npm 包执行器。我们可以使用 npx 来执行各种命令。主要有以下特点：临时安装可执行依赖包，不用全局安装，不用担心长期的污染。可以执行依赖包中的命令，安装完成自动运行。自动加载 node_modules 中依赖包，不用指定 <span class="hljs-variable">$PATH</span> 。可以指定 node 版本、命令的版本，解决了不同项目使用不同npx 执行流程如下：到 node_modules/.bin 路径检查对应的命令是否存在，找到之后执行；没有找到，就去环境变量 <span class="hljs-variable">$PATH</span> 里面，检查对应命令是否存在，找到之后执行;还是没有找到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。51.函数默认的返回值是undefined52.递归53.斐波那契数列function fibonacci(<span class="hljs-keyword">n</span>)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">n</span>===1||<span class="hljs-keyword">n</span>===2) <span class="hljs-keyword">return</span> 1    <span class="hljs-keyword">return</span> fibonacci(<span class="hljs-keyword">n</span>-1)+fibonacci(<span class="hljs-keyword">n</span>-2)  &#125;54.立即执行函数1.会立即执行2.函数有独立的作用域，可以避免外界访问或者修改内部的变量，3.可以有参数和返回值4.匿名函数多种写法(function()&#123;&#125;)()            <span class="hljs-comment">// 匿名函数多种写法</span>            (function (fn) &#123;              console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;立即执行函数&quot;</span>);            &#125;)();            <span class="hljs-comment">// + - ！都可以，但是不要这样用</span>            +(function foo() &#123;              console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;立即执行函数&quot;</span>);            &#125;)();5.应用：。1.解决命名冲突的问题，防止全局变量的命名冲突2.<span class="hljs-keyword">const</span> btnRtm1 = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = 0; i &lt; btnRtm.length; i++) &#123;  <span class="hljs-keyword">var</span> btn = btnRtm[i];  (function (<span class="hljs-keyword">m</span>) &#123;    btn.onclick = function () &#123;      console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">m</span>);    &#125;;  &#125;)(i);&#125;<span class="hljs-comment">// 打印 4 4 4 4 .....</span><span class="hljs-comment">// 立即执行函数可以解决上述问题还有for循环中有异步代码例如setTimeout，也可以用let解决</span><span class="hljs-comment">// 因为在如下代码中，但执行onclick执行的时候，此时for循环已经执行完，i已经变成btnRtm.length 所以执行代码永远是4 4 4 ，而使用立即执行函数，会每次将i作为参数传入立即执行函数中，尽管i执行完之后已经变成4，但是m存储这0 1 2 3 </span><span class="hljs-keyword">const</span> btnRtm = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = 0; i &lt; btnRtm.length; i++) &#123;  <span class="hljs-keyword">var</span> btn = btnRtm[i];  (function (<span class="hljs-keyword">m</span>) &#123;    btn.onclick = function () &#123;      console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">m</span>);    &#125;;  &#125;)(i);&#125;<span class="hljs-comment">// 打印 1 2 3 4....</span><span class="hljs-keyword">const</span> btnRtm3 = document.querySelectorAll(<span class="hljs-string">&quot;.btn&quot;</span>);<span class="hljs-keyword">for</span> (let i = 0; i &lt; btnRtm.length; i++) &#123;  <span class="hljs-keyword">var</span> btn = btnRtm[i];  btn.onclick = function () &#123;    console.<span class="hljs-built_in">log</span>(i);  &#125;;&#125;<span class="hljs-comment">// 打印1 2 3 4 .....</span>55.js代码规范56.Object的key是字符串57.Object可以使用delete来删除属性，Object.name/Object[<span class="hljs-string">&quot;name&quot;</span>]来获取，或者修改属性，obj[name]是计算属性，name是一个变量58.Object 遍历可以使用forin,或者Object.keys()   59.栈内存和堆内存原始数据类型是在栈内存引用类型实在堆内存60.包装类型，   当有包装类型的原始数据类型可以调用方法，是因为js引擎会将原始类型转换成包装类调用对应的方法   123..<span class="hljs-keyword">toString</span>(2)<span class="hljs-comment">//转换成二进制</span>   toFixed(2)保留两位小数。是四舍五入   parseInt===Number.parseInt     String类   length   str[0]   charAt(0)<span class="hljs-comment">//字符位置</span>   <span class="hljs-keyword">for</span>   <span class="hljs-keyword">for</span>...of   <span class="hljs-keyword">for</span>...<span class="hljs-keyword">in</span>   字符串是不可变的   例如：<span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;name&quot;</span>; str[0] = <span class="hljs-string">&quot;v&quot;</span>; console.<span class="hljs-built_in">log</span>(str);<span class="hljs-comment">//name</span>  <span class="hljs-keyword">var</span> str = str.toUpperCase();console.<span class="hljs-built_in">log</span>(str);<span class="hljs-comment">//这是新的字符串，不是原来的</span>str.indexOf(searchString,fromIndex)<span class="hljs-comment">//返回值是索引值</span>str.includes()str.startsWidth(<span class="hljs-string">&quot;1&quot;</span>)<span class="hljs-comment">//是否以1开头</span>str.endsWidth()str.<span class="hljs-keyword">replace</span>()str.slice()str.substring()str.<span class="hljs-built_in">substr</span>()字符串拼接+，cocat()<span class="hljs-built_in">trim</span>()<span class="hljs-keyword">split</span>()<span class="hljs-keyword">replace</span>()替换，是纯函数61.Arraysplice()<span class="hljs-comment">//添加，删除，替换</span>poppushshiftunshiftarr.length可以获得数组的长度，修改数组的长度，删除数组如果arr.length为6arr.length=2<span class="hljs-comment">//可以删除剩余的元素</span>arr.length=0可以删除所有元素arr.length=8<span class="hljs-comment">//可以扩容</span>arr.slice()arr.join()arr.concat()arr.indexOf()arr.find(arr.find(callback[, thisArg]) callback(element,index,array) <span class="hljs-comment">//会返回匹配到的元素，匹配到多个的时候会返回第一个   find 方法不会改变数组</span>arr.findIndex( )<span class="hljs-comment">//实现find</span>Array.prototype.myFind = function (callback, thisArg) &#123;  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;    <span class="hljs-keyword">if</span> (callback.call(thisArg, this[i], i, this)) &#123;      <span class="hljs-keyword">return</span> this[i];    &#125;  &#125;&#125;;<span class="hljs-comment">//实现forEach</span>Array.prototype.MyForEach = function (callback, thisArg) &#123;  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;    callback.apply(thisArg, [this[i], i, this]);  &#125;&#125;;includes()arr.<span class="hljs-keyword">sort</span>()<span class="hljs-comment">// 默认是降序</span>arr.<span class="hljs-keyword">sort</span>((item1, item2) =&gt; &#123;  <span class="hljs-keyword">return</span> item1.age - item2.age;&#125;);console.<span class="hljs-built_in">log</span>(arr);<span class="hljs-comment">// 升序</span>arr.<span class="hljs-keyword">sort</span>((item1, item2) =&gt; &#123;  <span class="hljs-keyword">return</span> item2.age - item1.age;&#125;);console.<span class="hljs-built_in">log</span>(arr);arr.<span class="hljs-built_in">reverse</span>()arr.filter()Array.prototype.myfilter = function (callback, thisArg) &#123;  let newArr = [];  <span class="hljs-keyword">for</span> (let i = 0; i &lt; this.length; i++) &#123;    <span class="hljs-keyword">if</span> (callback.call(thisArg, this[i], i, this)) &#123;      newArr.push(this[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> newArr;&#125;;arr.map()arr.reduce()Date类型new <span class="hljs-built_in">Date</span>()Date.now()<span class="hljs-comment">//当前事件的时间戳</span>date.getTime()<span class="hljs-comment">//将时间转换成时间戳</span>date.valueOf()<span class="hljs-comment">//也是一样</span>+date<span class="hljs-comment">//也可以</span>将字符串转换成时间戳<span class="hljs-keyword">var</span> dateString = <span class="hljs-string">&quot;2020-5-15&quot;</span>;console.<span class="hljs-built_in">log</span>(new <span class="hljs-built_in">Date</span>(dateString).getTime());console.<span class="hljs-built_in">log</span>(Date.<span class="hljs-keyword">parse</span>(dateString));==================================================================================Dom62.所有节点都继承自EventTarget63.document对象-可以获得整个网页node节点<span class="hljs-keyword">var</span> html=document.documnetElement<span class="hljs-keyword">var</span> body=documnet.bodybody,html,body都是documnet的属性获取所有节点的导航 <span class="hljs-keyword">var</span> bodyEl=document.body获取所有子节点 bodyEl.childNodes  换行符也属于text节点，注释是comment节点获取下一个兄弟节点 bodyEl.nextSibling前兄第节点 preSibling</code></pre></div><p>打印body的子节点</p><p><img src="https://img1.imgtp.com/2022/08/14/ehewKeMN.png" alt="屏幕截图 2022-05-18 100006.png"></p><p><img src="https://img1.imgtp.com/2022/08/14/B3g8Atxi.png" alt="屏幕截图 2022-05-18 100042.png"></p><div class="code-wrapper"><pre><code class="hljs stata">64.获取子元素bodyEl.children65.获取第一个子节点  bodyEl.firstElementChild    bodyEl.children[0]  bodyEl.nextElementSibling66.Document和Element的关系   没有关系。document.body,body是他的属性，不是继承类，body:document.querySelectAll(<span class="hljs-string">&quot;body&quot;</span>) ,所以Documnet和Element不是继承的关系，ELment是body的值67.<span class="hljs-keyword">table</span>和<span class="hljs-keyword">form</span>之间的导航68.document.getElementById(<span class="hljs-string">&quot;&quot;</span>)   documnet.querySelector(<span class="hljs-string">&quot;&quot;</span>)   document.querySlectorAll(<span class="hljs-string">&quot;&quot;</span>)   document.getElementsByName(<span class="hljs-string">&quot;&quot;</span>)   document.getElementsByTagName(<span class="hljs-string">&quot;&quot;</span>)   document.getElementsByClassName(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//这3个是实时的</span>69.NodeList是类数组对象，但是可以用<span class="hljs-keyword">forEach</span>,可以用Array.from()转换成array70.节点类型判断通过childNodes获取的节点判断节点类型用nodeType属性 1.元素节点 3.文本 8，注释节点71.nodeName获取节点名称，tagName元素名72.data用于非元素节点获取数据 innerHTML 获取元素 textContent获取文本设置的时候，innerHTML和innerContent都可以设置文本，innerContent设置元素不会被解析为html元素，会当作普通文本innerHTML 将会删除所有该元素的后代并以给出的 htmlString 替代不是追加73.outerHTML会获取本身及其子元素74.常见全局属性 id style title <span class="hljs-keyword">class</span> hidden:相当于设置<span class="hljs-keyword">display</span>:none<span class="hljs-keyword">on</span>+事件75.attributehtml定义的是标准attribute自定义的属性是非标准attribute所有attribute都支持的方法element.hasAttribute(<span class="hljs-keyword">e</span>)element.getAttribure(<span class="hljs-keyword">e</span>)element.setAttribute(<span class="hljs-keyword">e</span>)element.removeAttribute(<span class="hljs-keyword">e</span>)element.attributes-&gt;like array这些对大小写不敏感，而且返回值都是string76.property对象中的属性称为property元素中的属性称为attribute标准的attribute中在对应的对象模型中都有对用的propertyproperty和attribute会相互影响使用点语法也可以获得元素的属性77.className和classListclassList是可迭代对象78.style在js中要使用驼峰多个样式可以使用style.cssText=<span class="hljs-string">&quot;&quot;</span>这个不用写驼峰，但是会覆盖，不推荐78.style的读取getComputedStyle()，ele.style只能读取内联样式，就是直接在元素上定义的样式，widow.getComputedStyle(ele,[pseudoElt])可以读取所有的css属性，包括外部样式，但是getComputedStyle是只读属性79.data-*80.<span class="hljs-keyword">var</span> el=document.createElement(<span class="hljs-string">&quot;element&quot;</span>)<span class="hljs-comment">//创建元素</span>el.className=<span class="hljs-string">&quot;&quot;</span>el.classList.add(<span class="hljs-string">&quot;&quot;</span>)boxel.<span class="hljs-keyword">append</span>(el)<span class="hljs-comment">//向父元素插入创建的元素，默认是插入最后</span>boxel.prepend(el)<span class="hljs-comment">//添加到父元素的里面的最前面</span>boxel.before(el)<span class="hljs-comment">//添加到元素的前面</span>boxel.after(el)<span class="hljs-comment">//添加到元素后面</span>boxel.replacewith(...node|string)<span class="hljs-comment">//替换元素</span>appendChild,insertbefore这些方法比较旧了81.el.remove()<span class="hljs-comment">//将自己移除</span>82.克隆<span class="hljs-keyword">var</span> newEl=el.cloneNode()<span class="hljs-comment">//默认是不会克隆子节点cloneNode(true)会克隆子节点</span>83.获取元素的宽高 ele.width ele.height84.clientWidth:元素content+padding(不包含滚动条)clientTop:border-top的宽度。clientLeftoffsetWidth:元素的完整宽度content+border+paddingoffsetLeft 距离父元素左边的距离 offsetTopscrollHeight 元素可滚动的高度scrollTop 滚动条滚动的距离85.<span class="hljs-keyword">window</span>的大小和滚动   <span class="hljs-keyword">window</span>.outerWidth<span class="hljs-comment">//</span>   <span class="hljs-keyword">window</span>.innerWidth<span class="hljs-comment">//窗口的宽度，不包括调试窗口和工具栏</span>   document.doeumnetElement.offsetWidth document.doeumnetElement.offsetHeight   <span class="hljs-keyword">window</span>.scrollX  获取x轴的滚动位置 <span class="hljs-keyword">window</span>.scrollY Y轴的滚动位置  也可以用别名pagexOffset  pageYOffset   设置滚动的位置 <span class="hljs-keyword">window</span>.scrollBy(x,y)<span class="hljs-comment">//在原来的位置基础上叠加滚动的位置</span>   <span class="hljs-keyword">window</span>.scrollTo(x,y)<span class="hljs-comment">//滚动到绝对的位置，到了位置不会变</span>   <span class="hljs-keyword">window</span>.onscroll<span class="hljs-comment">//监听滚动</span>   86.事件<span class="hljs-keyword">on</span>+eventele.addEventListener(<span class="hljs-string">&quot;event&quot;</span>,callback)87.事件流事件冒泡事件捕获捕获阶段-》目标阶段-》冒泡阶段88.event常见属性方法event.<span class="hljs-keyword">type</span>:事件类型event.target:目标元素event.currentTarget:绑定事件的元素event.offsetXevent.clientXevent.pageXevent.screenXtarget和currentTarget的区别target事件发生的对象，currentTarget是事件绑定的对象，如果如果绑定事件的元素和触发事件的元素相同时，target===currentTargetevent.preventDefault()event.propagetion()<span class="hljs-keyword">on</span>+event中普通函数中this指向绑定事件的元素。addEentListener()也是一样89.EventTarget类所有节点，元素都继承自eventtarget，<span class="hljs-keyword">window</span>也是eventTarget.removeEventListener(event,callbackName,)eventTarget.dispatchEvent()90.事件委托91.import * from 是否包含export defaultexport &#123;&#125;和export <span class="hljs-keyword">const</span> a ,export <span class="hljs-keyword">const</span> b有区别吗92.&lt;div id=<span class="hljs-string">&quot;box&quot;</span>&gt;&lt;/div&gt;box.click()<span class="hljs-comment">//如果是id，也可以这样写但是不推荐</span>92.常见的鼠标事件onclick <span class="hljs-comment">//只能接受event作为唯一的参数，且不用再调用的时候写</span>oncontextmenuonmousedownonmouseuponmousemove93.mouseover和mouseenter的区别mouseenter和mouseleave不支持冒泡进入子元素依然属于该元素只会触发子元素的mouseenter，父元素没反应mouseover和mouseout支持冒泡94.键盘事件onkeydownonkeypressonkeyupevent.code event.key95.onfocus和onblur96.oninput和onchange99.表单事件 onsubmit onreset100.onload和DOMContentLoaded101.onresize102.定时器setTimeout和setInterval是<span class="hljs-keyword">window</span>的方法103.ontransitioned监听动画的结束后调用104.<span class="hljs-keyword">tab</span>切换中切换.active的方法1.<span class="hljs-keyword">for</span>循环2.使用documnet.queryslector(<span class="hljs-string">&quot;.active&quot;</span>)修改3.使用在外面进行变量记录105.BOM浏览器对象模型106.node:<span class="hljs-keyword">global</span>==lobalThis<span class="hljs-keyword">window</span>:<span class="hljs-keyword">window</span>==globalThis放到<span class="hljs-keyword">window</span>的属性全局都可访问用<span class="hljs-keyword">var</span>申明的全局对象都放到<span class="hljs-keyword">window</span>对像中<span class="hljs-keyword">var</span> openWin=<span class="hljs-keyword">window</span>.<span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;&quot;</span>)<span class="hljs-comment">//打开网址</span><span class="hljs-keyword">window</span>.<span class="hljs-keyword">close</span>()<span class="hljs-comment">//只能关闭通过open()打开的新的窗口</span>107.<span class="hljs-keyword">window</span>常见事件<span class="hljs-keyword">window</span>.onfocus<span class="hljs-keyword">window</span>.onblur<span class="hljs-keyword">window</span>.onhashchange108.location对象属性，用于表示<span class="hljs-keyword">window</span>当前连接url信息location.href<span class="hljs-comment">//完整url</span><span class="hljs-comment">//url信息</span>location.hostnamelocation.hostloaction.protocollocation.portlocation.pathnamelocation.hashloacation.<span class="hljs-keyword">search</span><span class="hljs-comment">//location方法</span>loacation.assign()<span class="hljs-comment">//打开新的网页，是加入历史记录站，可以返回</span>location.<span class="hljs-keyword">replace</span>()<span class="hljs-comment">//替代当前url,不可以返回</span>loaction.reload()<span class="hljs-comment">//重新加载</span>109.URLSearchParams<span class="hljs-keyword">var</span> searchParams=new URLSearchParams(str)<span class="hljs-built_in">get</span>(&quot;name“)<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;zzzz&quot;</span>)has()<span class="hljs-keyword">set</span>()URLSearchParams可以使用<span class="hljs-keyword">for</span>...of中文使用encodeURLComponment和decodeURLComponment进行编解码<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] of searchParams) &#123;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] of searchParams.entries()) &#123;&#125;110.history<span class="hljs-comment">//属性</span>history,lengthhistory.state<span class="hljs-comment">//修改history</span>history.pushState(&#123;name:<span class="hljs-string">&quot;mike&quot;</span>,age:18&#125;)hsitory.back()history.forword()history.go(-2)replacestate()111.json<span class="hljs-keyword">var</span> item=JSON.stringfy(item)<span class="hljs-keyword">var</span> item=JSON.<span class="hljs-keyword">parse</span>(item)json的方法还可以实现深拷贝<span class="hljs-keyword">var</span> obj=JSON.<span class="hljs-keyword">parse</span>(JSON.strigfy(obj1))112.protobuf113.&amp;gt; &amp;lt;114.&lt;button onclick=<span class="hljs-string">&quot;add()&quot;</span>&gt;按钮&lt;/button&gt;<span class="hljs-comment">//再元素上事件的写法</span>115.<span class="hljs-comment">/* 设置图片水平方向和垂直方向上自动居中，随着浏览器大小的变化 */</span>.img_center&#123;  position: relative;  transform: <span class="hljs-keyword">translate</span>(-50%,-%50);  left: 50%;  top:50%;&#125;</code></pre></div><p>116.</p><p><img src="https://img1.imgtp.com/2022/08/14/lwe19xZA.png" alt="屏幕截图 2022-05-25 175414.png"></p><div class="code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-number">117.</span><span class="hljs-keyword">this</span>的指向<span class="hljs-number">1.</span><span class="hljs-keyword">this</span>的指向是由函数调用执行的时候决定的<span class="hljs-number">2.</span><span class="hljs-keyword">this</span>的绑定分为：默认绑定：独立函数调用<span class="hljs-keyword">this</span>是指向window,例如fn()隐式绑定：对象中<span class="hljs-keyword">this</span>的指向是指向调用的对象，例如obj.fn()显示绑定:通过call,apply,bind来进行显示绑定下，<span class="hljs-keyword">this</span>指向绑定的对象new的绑定：通过new创建的对象，<span class="hljs-keyword">this</span>会指向新创建的对象<span class="hljs-number">3.</span><span class="hljs-keyword">this</span>指向的优先级：new&gt;显示绑定&gt;隐式绑定&gt;默认绑定<span class="hljs-number">4.</span>箭头函数是没有<span class="hljs-keyword">this</span>,arguments，是由上层函数作用域来决定，一层一层作用域找注意：<span class="hljs-keyword">var</span> name=<span class="hljs-string">&quot;mike&quot;</span><span class="hljs-keyword">var</span> obj=&#123;foo()&#123;<span class="hljs-keyword">return</span> ()=&gt;&#123;console.log(<span class="hljs-keyword">this</span>.name)&#125;&#125;&#125;<span class="hljs-comment">//this会先去foo中去找，找不到就去全局作用域，对象中没有作用域</span>不可以使用显示绑定改变<span class="hljs-keyword">this</span>的指向<span class="hljs-number">5.</span>显示绑定中如果指向的是一个基本数据类型，如果有包装类型则转换成包装类<span class="hljs-number">6.</span>setTimeout中的<span class="hljs-keyword">this</span>默认指向window<span class="hljs-number">7.</span>forEach中<span class="hljs-keyword">this</span>默认指向window，可以通过第二个参数修改<span class="hljs-number">8.</span>事件绑定中<span class="hljs-keyword">this</span>指向绑定的元素<span class="hljs-number">9.</span>new不可以和apply和call一起使用<span class="hljs-number">10.</span>bind的优先级高于call/apply<span class="hljs-number">11.</span>new的优先级高于bind<span class="hljs-number">12.</span>间接函数引用：<span class="hljs-number">1.</span>(obj1.foo=obj2.foo)()这样直接调用，<span class="hljs-keyword">this</span>是默认绑定指向window<span class="hljs-number">2.</span>(b=person.sauName)()   <span class="hljs-comment">//window</span><span class="hljs-number">13.</span>foo.apply(<span class="hljs-literal">null</span>)/foo.apply(undefined)指向window<span class="hljs-number">14.</span>箭头函数可以替代<span class="hljs-keyword">var</span> _this=<span class="hljs-keyword">this</span>来替代，可以获得上层作用域<span class="hljs-number">118.</span> Array.prototype.slice 来将一个类似于数组的对象（array-like <span class="hljs-keyword">object</span>）转换成一个真正的数组，Aaary.prototye.slice.apply()/bind()<span class="hljs-number">119.</span>html解析过程中，遇到css文件会下载，但是不会阻止html的解析，但会阻塞render的渲染过程<span class="hljs-number">120.</span>回流和重绘<span class="hljs-number">121.</span>scriptdefer js的下载和执行不阻塞Dom tree的构建defer代码执行的时候Dom构建完成，defer会在DomContentLoad以后执行多个defer顺序执行defer推荐放在head中defer仅适用于外部脚本，对script的内容会忽略async 多个async不能保证顺序执行，不会组设Dom渲染。不能保证DOMContentLoaded之前或者之后执行行async用于独立脚本，没有外部依赖<span class="hljs-number">122.</span>函数的执行是在函数执行上下文中执行<span class="hljs-number">123.</span>函数的作用域链再函数创建时就确定了。每个执行上下文都有自己的作用域链</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/hbsvpJ1A.png" alt="屏幕截图 2022-05-29 114030.png"></p><p>当查找变量的时候，函数首先会在local中寻找，找不到再去上层作用作用域寻找，而这个函数的上层作用域是Window</p><p><img src="https://img1.imgtp.com/2022/08/14/YJJTxHz8.png" alt="屏幕截图 2022-05-29 120154.png"></p><p>124.垃圾回收器</p><p>​        1..引用计数</p><p>​                    当一个对象有一个引用指向它时，那么这个对象的引用就+1</p><p>​                    当一个对象的引用为0时，这个对象就可以销毁掉</p><p>​                    这个算法有一个回答的弊端就是会产生循环引用</p><p>​        2.标记清除</p><p>​        3.标记整理</p><p>​        4.分代收集</p><p>​        5.增量收集</p><p>​        6.闲时收集</p><div class="code-wrapper"><pre><code class="hljs 130">125.闭包1.狭义：函数引用外层函数的自由变量就是闭包。2.通过返回一个函数，外部可以通过这个函数访问这个函数所在作用域链的变量，闭包可以突破作用域链126.GUI的渲染和js的执行是在同一个线程，是互斥的127.foo.name,获取函数名foo.length//获取行参个数，不会把剩余参数和默认参数计算在内，arguments//类数组对象，可以通过下标获取值，有length属性，是可迭代对象，但是本身不可以使用数组的方法，可以通过Array.prototype.map.call(arguments)来使用argument转array1.for循环，将argument一个个放到数组中2.Array.from(argumsnets)3.[...arguments]4.var arr=Array.prototype.slice.call/apply(arguments)//会截取整段，并返回新的数组或者var arr=[].slice.call/apply(arguments)箭头函数没有argments,会去上层作用域去找arguments128.剩余参数   剩余参数必须放到最后129.剩余参数和argument的区别剩余参数是数组，可以使用所有数组方法，arguments是类数组剩余参数只包含没有对应形参的实参，arguments包含所有参数130.纯函数相同的输入产生相同的输出，不会产生副作用不依赖外部变量确定输出不能修改外部变量作用：只是单纯的实现自己的业务，不需要关注外部的数据变化131.函数柯里化就是把接受多个函数的函数变成返回接受单一参数的函数var foo=x=&gt;y=&gt;z=&gt;console.log(x+y+z)shiyo132.async默认会返回promiseasync的返回值会被promise包裹，相当于Promise.resolve()await 后面是一个promsie,则会返回Promise.resolve(res)的值如果不是promise，则用Promise.resolve(res)包裹await 使用trycatch捕获异常133.封装自动转化成柯里化函数134.组合函数组合函数的封装135.Function.prototype.name   Function.prototype.length Function.prototype.displayName136.with(obj)&#123;console.log(message)//扩展一个语句的作用域链，它首先会去obj里面去找，找不到再去上层作用域找，但是不推荐使用&#125;137.eval()138.严格模式开启严格模式的方式class和module会自动开启严格模式严格模式的限制1.无法意外创建全局变量2.引起静默模式失败3.不能用with4.this默认指向undefined,this不会装换成包装类139.Object.defineProperty(obj,prop.descriptor)属性描述符的分类1.数据属性描述符：configurable:表示这个属性是否可删除,默认值是false，使用delete不嫩删除，如果设置为false,则不可以配置了，后续其他属性描述符也不可以使用了。就是Configurable:false,后续不可以对这个属性使用Object.defineProperty配置。enumerable:是否可以枚举属性，false:forin,Object.keys()这些都不可以美剧，默认是truewritable:是否可以写入，默认是可以写入，设置为false是只读属性value:&quot;mike&quot;,设置属性值如果使用字面量创建对象，则所有属性描述符都是true,object.defineProperty()设置的属性的value的优先级会比字面量创建的属性设置的值高2.存取属性描述符getsetwiritable,value和get,set不可以同时使用140.Object.defineProperties()//同时设置多个属性描述符141.Object.getOwnPropertyDescriptor(obj, &quot;name1&quot;)//获取某个属性描述符142.Object.getOwnPropertyDescriptors(obj)//获取所有属性描述符143.Object.preventExtensions(obj);//不允许扩展属性144.object.seal(obj)//密封对象，不允许配置和删除属性，增加新的属性145.Object.freeze(obj)//不能修该现有属性，也不能增加新的属性146.原型和原型链__proto__是浏览器加，非标准的，要看各个浏览器如何实现，建议使用Object.getPrototypeOf(obj)来获取对象的原型__proto__隐式原型prototype显式原型所有的对象都有隐式原型，函数有隐式原型和显示原型当对象获取值的时候p1.address如果实例对象没没有这个属性则会到他的原型练上去寻找当对象属性赋值的时候，如果该属性不存在则会在当前对象中新建一个属性赋值，不会修改原型链上的属性的值p1.address=&quot;us&quot;//这样不会对原型链上的该属性进行修改如果要对原型的属性进行修改：Person.prototype.address=&quot;japan&quot;Person.prototype=&#123;message:&quot;章&quot;,info:&#123;&#125;,eating:function()&#123;&#125;,constructor:Person&#125;//修改Person的显示原型指向新的对象p1.__proto_===Object.prototypeconstructor应该是不可以枚举的，要用Object.deineProperty()来修改定义原型链：实例对象在查找某个属性的时候，他先去自己对象寻找，然后再去原型链里面去找，直到找到null为止147.面向对象的特性:封装，继承，多态148.使用new关键字创建对象的过程1.创建一个空对象2.让这个对象的[[prototype]]属性指向该构造函数的prototype对象3.让构造函数的中的this指向新创建的对象4.执行该构造函数5.如果构造函数没有返回一个非空对象，则返回新创建出来的对象149.原型链的继承1.Student.prototype=Person.prototype//这种继承虽然可以继承到Person的方法，但是添加student的方法的时候，会添加到Person原型上，对Person和Student都会有影响2.原型链继承student.prototype=new Person()//改善上面一种方法，不会对Person.prototype上的方法进行干扰但是，如果有和Person相同的属性的时候例如function Student(age,gender,name,weight)&#123;this.age=age;this.gender=gender;this.name=name;this.weight=weigth&#125;age,gender属性在pERson里面也有，这样会有代码重复的问题，但是可以获取到自己的age,gender如果不写，调用的时候是获取到Person的age和gender,多个实例共享相同的属性了3.借用构造函数继承  function Student(age,gender,name,weight)&#123;  Person.call(this,age,gender)  this.name=name;this.weight=weigth  &#125;  使用这个方法可以实现属性的继承  将2，3方法结合起来就是组合继承  student.prototype=new Person(age,gender)//继承父类的方法   function Student(age,gender,name,weight)&#123;  Person.call(this,age,gender)//这样没有调用父类的constructor  this.name=name;this.weight=weigth  &#125;  缺点：new student的时候构造函数会调两次，一次Person,一次student，拥有两份父类属性，父类的静态属性和静态方法也没有继承  4.寄生组合继承  function Student(age,gender,name,weight)&#123;  Person.call(this,age,gender)  this.name=name;this.weight=weigth  &#125;  inhert(Student,Person)  Object.assign(Student, Person);//继承静态属性和方法(或者称为类方法或者类属性)150.原型式继承函数// 使用这个方法来处理Object.create()的兼容性问题        function createObject(o) &#123;          function F() &#123;&#125;          F.prototype = o;          return new F();        &#125;        // 封装工具函数实现继承        function inhert(Subtype, Supertype) &#123;        //Subtype.prototype.__proto__=Supertype.prototype        //Object.setPrototypeOf(Subtype.prototype,Supertype.prototype)          // Subtype.prototype = createObject(Supertype.prototype);          Subtype.prototype = Object.create(Supertype.prototype);//Object.create()不会调用constructor          Object.defineProperty(Subtype, &quot;constructor&quot;, &#123;            configurable: false,            enumerable: false,            value: Subtype,            writable: true,          &#125;);        &#125;    //对象之间的继承  function object(o)&#123;  var obj=&#123;&#125;  obj.__proto__=o.prototype//Object,setPrototypeOf(obj,o.prototype)  return obj  &#125;151.Object是所有类的父类152.obj.hasOwnProperty()、//判断是否在自己身上&quot;name&quot; in obj//判断属性是否在obj的里面或者原型链上for in 遍历原型链可枚举属性和方法instanceOfPerson.protytype.isPrototypeOf(stu)//判断实例是否在莫格原型链上，判断对象之间的继承153.对象具备__proto__属性。函数有__proto__和prototype属性154.Person.run()//这个调用的是类方法，protoytype上面的方法是实例方法155.class定义类class会有默认的constructorclass是的构造函数、原型链的语法糖156.对象中访问器的写法var obj = &#123;  name: &quot;mike&quot;,&#125;;//对象访问器的写法一Object.defineProperty(obj, &quot;name&quot;, &#123;  configurable: true,  enumerable: true,  get() &#123;    return obj.name;  &#125;,  set(value) &#123;    obj.name = value;  &#125;,&#125;);//对象访问器的写法二var obj2 = &#123;  name: &quot;zhang&quot;,  get getName() &#123;    return this.name;  &#125;,  set setName(value) &#123;    this.name = value;  &#125;,&#125;;//三class Person &#123;  constructor(name) &#123;    this._name = name;  &#125;  get name() &#123;    return this._name;  &#125;  set name(value) &#123;    this._name = value;  &#125;&#125;157.类方法/static方法中的this指向类本身158.class的继承 extend159.面向对象的三大特性：封装，继承，多态多态的条件：1。必须实现继承  2.必须有父类引用指向子类对象  3.js中可以说到处是多态160.对象字面量增强：1.属性的增强var name=&quot;why&quot;var obj=&#123;name&#125;2.方法的增强var obj=&#123;eating()&#123;&#125;&#125;3.计算属性名obj=&#123;[name]:&#125;161.数组的解构和对象的解构const [name1,name2,name3]=arrconst &#123;age,name,color&#125;=objconst [name1,name2,...name3]=arr//将剩下的元素放入name3数组中const [name1,name2,name3=&quot;default&quot;]=arr//设置默认值//对象的解构是没有顺序的，根据Key来进行解构//对象解构的重命名  const &#123;age:age1,name:name1&#125;=obj//重命名为age1,name1 //对象解构默认值默认值 const &#123;age:age1=18,...other&#125;=obj1//可以使用剩余运算符和默认值162.手写apply,call,bind163.词法环境词法环境由环境记录和外部词法环境两部分组成一个执行上下文关联两个环境LexicalEnvironment和VariableEnvirmentLexicalEnvironment用于处理let和constVariableEnvirment用于处理var,function164.https://262.ecma-international.org/8.0/165.let和constlet/const不可以重复声明const声明的是引用类型则可以修改const指向的地址的内部的变量，但不可以修改const的指向let/const不会出现变量提升，必须先声明再使用，否则会出现暂时性死区let/const会提前创建出来，但是不可以被访问，只有赋值的时候才可以访问暂时性死区取决于代码执行的顺序，和定义的位置没有关系var定义的全局变量默认会添加到window上。而let/const不会再window添加任何属性var 会被添加到 object environment record而const /let会被添加到decaretive environment record166.块级作用域let/const/function/class声明是有块级作用域的，foo()//在这之前不可以访问&#123;function foo()&#123;&#125;&#125;foo()//这样可以访问浏览器做了特殊处理，可以让块级作用域里面的函数在块级作用域之后被访问167.立即执行函数会形成闭包，形成自己的作用域168.for(let i=0;i&lt;btnEls.length;i++)&#123;var btnEl=btnEls[i]btnEl.onclick=function()&#123;console.log(`点击了$&#123;i&#125;按钮`)&#125;&#125;//会形成4个词法环境，每个词法环境都会保存着自己的i，function引用外层的词法环境，所以执行完外层词法不会被销毁，当需要i的时候，会往上层寻找，因为当前词法环境中保存着i</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/frDfleO9.png" alt="QQ截图20220606172932.png"></p><p><img src="https://img1.imgtp.com/2022/08/14/3FHLdHM8.png" alt="QQ截图2022060617452911.png"></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">169.</span>模板字符串<span class="hljs-number">1.</span>普通模板字符串<span class="hljs-number">2.</span>标签模板字符串<span class="hljs-number">170</span>,函数默认值<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg1,arg2</span>)&#123;arg1=arg1?<span class="hljs-attr">arg1</span>:<span class="hljs-number">0</span>arg1=arg1||<span class="hljs-number">0</span>arg1=(arg===<span class="hljs-literal">null</span>)||(arg1===<span class="hljs-literal">undefined</span>)?<span class="hljs-number">0</span>:arg1<span class="hljs-comment">//es6</span>arg1=arg1??<span class="hljs-string">&quot;我是默认值&quot;</span>&#125;<span class="hljs-title function_">foo</span>(<span class="hljs-params">arg1,arg2=<span class="hljs-string">&quot;why&quot;</span></span>)&#123;&#125;<span class="hljs-comment">//默认参数最好放后面</span>剩余参数也是放在后面，如果两个都有的话，剩余参数放后面<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">&#123;name,age&#125;=&#123;name=<span class="hljs-string">&quot;why&quot;</span>,age=<span class="hljs-number">18</span>&#125;</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age)<span class="hljs-comment">//对传入的对象进行解构赋值，给默认值</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">&#123;name=<span class="hljs-string">&quot;why&quot;</span>,age=<span class="hljs-number">18</span>&#125;=&#123;&#125;</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name,age)<span class="hljs-comment">//对象参数的解构赋值，如果传入的参数</span>中没有该值name,age，则给name,age赋值&#125;默认参数不计算在argument内<span class="hljs-number">171.</span>箭头函数没有显示原型，不可以作为构造函数，不能通过<span class="hljs-keyword">new</span>创建<span class="hljs-number">172.</span>展开运算符<span class="hljs-keyword">var</span> obj=&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;why&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;<span class="hljs-title function_">foo</span>(...obj)<span class="hljs-comment">//这样来用是不可以的，因为函数参数必须是可迭代对象</span><span class="hljs-number">173.</span>浅拷贝：就是将对象里面的内容赋值到新的对象里面，如果对象里面还有对象，则只会复制对象的引用就是浅拷贝只会拷贝第一层对象浅拷贝的方法可以使用展开运算符和<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>()<span class="hljs-number">174.</span>ele.<span class="hljs-title function_">append</span>()和ele.<span class="hljs-title function_">appendChild</span>()的区别append参数可以是node/string appendChild只能是<span class="hljs-title class_">Node</span>,<span class="hljs-title function_">append</span>()没有返回值，appendChild会返回插入值本身，append可以追加多个字符串、node，而appendChild只能加一个节点<span class="hljs-number">175.</span>数值的表示<span class="hljs-number">176.</span><span class="hljs-title class_">Symbol</span><span class="hljs-keyword">const</span> s1=<span class="hljs-title class_">Symbol</span>()<span class="hljs-keyword">const</span> obj=&#123;[s1]:<span class="hljs-string">&quot;aaaa&quot;</span>&#125;<span class="hljs-comment">//对象中key可以是string/Symbol</span>由<span class="hljs-title class_">Symbol</span>()生成是独一无二的<span class="hljs-number">177.</span>set存储任何类型的唯一的值<span class="hljs-keyword">const</span> set=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()set.<span class="hljs-title function_">add</span>(dd)set.<span class="hljs-title function_">has</span>(dd)set.<span class="hljs-property">size</span><span class="hljs-comment">//获取元素数量</span>set.<span class="hljs-title function_">delete</span>(value)<span class="hljs-comment">//删除元素</span><span class="hljs-title function_">clear</span>(set)<span class="hljs-comment">//清空</span>set.<span class="hljs-title function_">forEach</span>()<span class="hljs-comment">//可以用于数组的遍历</span>set.<span class="hljs-title function_">keys</span>()set.<span class="hljs-title function_">values</span>()<span class="hljs-comment">//keys()和values的返回值是相同的</span>set.<span class="hljs-title function_">entry</span>()<span class="hljs-comment">//返回值为[value,value]</span>forof数组去重<span class="hljs-keyword">const</span> newArr=<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr))/[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)]<span class="hljs-title class_">Set</span>中<span class="hljs-title class_">NaN</span>===<span class="hljs-title class_">NaN</span><span class="hljs-number">178.</span><span class="hljs-title class_">WeakSet</span><span class="hljs-title class_">WeakSet</span>是弱引用，可以被垃圾回收器回收weakSet只能存储对象weakSet对对象都是弱引用的，所以不可以遍历<span class="hljs-title class_">WeakSet</span>中由<span class="hljs-title function_">has</span>(),<span class="hljs-title function_">add</span>(),<span class="hljs-title function_">delete</span>()它和 <span class="hljs-title class_">Set</span> 对象的区别有两点：    与<span class="hljs-title class_">Set</span>相比，<span class="hljs-title class_">WeakSet</span> 只能是对象的集合，而不能是任何类型的任意值。    <span class="hljs-title class_">WeakSet</span>持弱引用：集合中对象的引用为弱引用。 如果没有其他的对<span class="hljs-title class_">WeakSet</span>中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 <span class="hljs-title class_">WeakSet</span> 中没有存储当前对象的列表。 正因为这样，<span class="hljs-title class_">WeakSet</span> 是不可枚举的。</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/EzcYmE14.png" alt="QQ截图20220608150415.png"></p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-number">179.</span><span class="hljs-built_in">Map</span><span class="hljs-keyword">map</span>也是可迭代对象<span class="hljs-keyword">map</span>可以使用任何数据类型作为key,而<span class="hljs-built_in">Object</span>只可以使用string、symbol作为key<span class="hljs-keyword">const</span> <span class="hljs-keyword">map</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<span class="hljs-keyword">map</span>.set(info,<span class="hljs-string">&quot;999&quot;</span>)<span class="hljs-keyword">map</span>.<span class="hljs-keyword">delete</span>(info)<span class="hljs-keyword">map</span>.has(info)clear(<span class="hljs-keyword">map</span>)forEach<span class="hljs-keyword">map</span>.get(info)forof<span class="hljs-number">180.</span><span class="hljs-built_in">Map</span>和<span class="hljs-built_in">Object</span>的区别<span class="hljs-number">181.</span><span class="hljs-built_in">WeakMap</span>key只能是对象，对对象的引用是弱引用，如果没有其他引用引用该对象，他就会被GC回收weakMap的key是不可以枚举的，不可以遍历不能使用forof,forEach进行遍历<span class="hljs-keyword">delete</span>(key)get(key)has(key)set(key,value)weakMap可以解决<span class="hljs-built_in">Map</span>可能导致内存泄漏的问题，因为数组会一值引用每一个key,value参考：https:<span class="hljs-regexp">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap</span><span class="hljs-regexp">182.Array.prototype.includes(item)</span><span class="hljs-regexp">183.Math.pow()/**</span><span class="hljs-regexp">184.Object.values(obj)</span><span class="hljs-regexp">185.Object.keys(obj)</span><span class="hljs-regexp">186.Object。entries(obj)//</span>obj可以是对象，数组，字符串获取的数组和forin遍历的顺序是一致的，但是不会遍历原型链上的属性和方法<span class="hljs-number">187.</span><span class="hljs-built_in">String</span>.prototype.padStart(总长度,填充字符串)<span class="hljs-regexp">//字符串填充 会返回新的字符串</span><span class="hljs-regexp">例如隐藏只显示身份证的部分数字，其余部分填充*</span><span class="hljs-regexp">188.Object.getOwnPropertyDescriptors</span><span class="hljs-regexp">189.Array.prototype.flat(number)//</span>将多维数组扁平化<span class="hljs-number">190.</span><span class="hljs-built_in">Array</span>.prototype.flatMap(callback(currval,index,arr))<span class="hljs-regexp">//相当于先使用map再使用flat(1)进行扁平化</span><span class="hljs-regexp">191.数组扁平化的方法</span><span class="hljs-regexp">192.Object.fromEntries(entries)//</span>把entry转换成Obj将queryString转换成对象</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/cVkjgfjQ.png" alt="QQ截图20220608171027.png"></p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-number">193.</span>空值合并运算符 ??<span class="hljs-number">194.</span>str.trim()/trimStart()/trimRight()<span class="hljs-number">195.</span>可选链操作符  ?.可以替代<span class="hljs-keyword">if</span>(obj.friend&amp;&amp;obj.friend.running)&#123;obj.friend.running()&#125;obj?.friend?.running?.()<span class="hljs-number">196.</span>WeakRef//暂时不建议使用<span class="hljs-number">197.</span>逻辑赋值运算符message=message||&quot;默认值&quot;=&gt;message||=&quot;默认值&quot;message??=&quot;默认值&quot;obj&amp;&amp;obj.friend&amp;&amp;obj.friend.running()<span class="hljs-number">198.</span>const <span class="hljs-built_in">new</span>=str.replaceAll()//替换所有匹配到的字符串  原始字符串保持不变。<span class="hljs-number">199.</span>str.at(<span class="hljs-keyword">index</span>)<span class="hljs-number">200.</span><span class="hljs-keyword">Object</span>.hasOwn(obj,propKey)//可以替代obj.hasOwnProperty(prop),因为hasOwnProperty()可能会被使用者重写const <span class="hljs-keyword">info</span>=<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(<span class="hljs-keyword">null</span>)//这样创建的对下个原型指向<span class="hljs-keyword">null</span><span class="hljs-keyword">info</span>.name=&quot;why&quot;<span class="hljs-keyword">info</span>.hasOwnProperty(<span class="hljs-type">name</span>)//由于原型指向<span class="hljs-keyword">null</span>,所以获取不到hasOwnProperty方法需要使用<span class="hljs-keyword">Object</span>.hasOwn()替代<span class="hljs-number">201.</span><span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>()创建一个新对象，使用现有的对象来提提供新创建对象的__proto__<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>(proto,[prppertiesObject])<span class="hljs-number">202.</span><span class="hljs-keyword">Class</span> Person&#123;height=<span class="hljs-number">1.88</span>//在这里写的时候，<span class="hljs-built_in">new</span>创建对象时也会被添加到新的对象里面，再<span class="hljs-keyword">class</span>内部可以通过this来访问constructor(<span class="hljs-type">name</span>,age)&#123;this.name=<span class="hljs-type">name</span>this.age=agethis.address=&quot;广州市&quot;&#125;static &#123;//静态代码块&#125;&#125;<span class="hljs-number">203.</span>proxy<span class="hljs-keyword">Object</span>.defineProperty()的缺点，不可以监听到对象属性的新增和删除操作，新增的属性也没办法监听，只能监听属性，不能监听整个对象</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/EQg1fUBC.png" alt="QQ截图20220609114316.png"></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Proxy</span>是监听整个对象，他有<span class="hljs-number">13</span>个捕获器，这些捕获器可以劫持对象的一些操作用proxy替代obj操作</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/aIkHlWXU.png" alt="QQ截图20220609115247.png"></p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">204.</span><span class="hljs-built_in">Reflect</span>的作用<span class="hljs-built_in">Reflect</span>是为了替代<span class="hljs-built_in">Object</span>中的一些方法</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/KQev7yPJ.png" alt="QQ截图20220609153635.png"></p><p><img src="https://img1.imgtp.com/2022/08/14/0fcGhnc0.png" alt="QQ截图20220609153658.png"></p><p><img src="https://img1.imgtp.com/2022/08/14/MDMfI710.png" alt="QQ截图20220609153711.png"></p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-number">205</span><span class="hljs-selector-class">.Reflect</span>.construct的作用Reflect<span class="hljs-selector-class">.construct</span>(target, argumentsList<span class="hljs-selector-attr">[, newTarget]</span>)</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/BXFFyjjm.png" alt="QQ截图20220609155310.png"></p><p>​    </p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-number">206</span><span class="hljs-selector-class">.new</span><span class="hljs-selector-class">.target</span>作用<span class="hljs-number">207</span><span class="hljs-selector-class">.promise</span>三种状态：pendingfulfilledrejected状态发生改变，就不可以更改<span class="hljs-built_in">resolve</span>(value)<span class="hljs-comment">//value会作为then方法中的回调函数的参数</span><span class="hljs-number">1</span>.普通值则作为参数直接传过去<span class="hljs-number">2</span>.如果传入的是promise,则由promise的中的·resolve参数决定<span class="hljs-number">3</span><span class="hljs-selector-class">.thenable</span>对象则会执行then方法并且由then方法中的reslove的参数决定<span class="hljs-built_in">then</span>()<span class="hljs-comment">//可以传两个参数，成功的回调和失败的回调</span><span class="hljs-built_in">catch</span>()<span class="hljs-comment">//失败的回调</span><span class="hljs-number">208</span><span class="hljs-selector-class">.Window</span><span class="hljs-selector-class">.getComputedStyle</span>(ele,prop?)和Element<span class="hljs-selector-class">.getBoundingClientRect</span>()的区别getComputedStyle是定义在window上的方法，getBoundingClientRect是Element的方法，getComputedStyle返回值是CSS属性值，而getBoundingClientRect返回的是具体的位置信息</code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/OJQOJUb1.png" alt="QQ截图20220611104648.png"></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">209.</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">then</span>()<span class="hljs-comment">//返回值是一个promise,链式调用中，then会等待上一个then的返回值promise的状态来决定</span><span class="hljs-keyword">const</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>)&#125;)promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<span class="hljs-keyword">return</span> res&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)then的返回值<span class="hljs-number">1.</span>普通值则会直接包裹成promise返回<span class="hljs-number">2.</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span> 则有这个promise的状态来决定<span class="hljs-number">3.</span>有thenable方法的对象，则由thenable方法的状态来决定then抛出异常时，就处于reject状态，则会调用后面的<span class="hljs-keyword">catch</span>then <span class="hljs-keyword">return</span> 时处于fulfilledthen没有返回值则不会继续调用then<span class="hljs-number">210.</span><span class="hljs-title class_">Promsie</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">catch</span>()<span class="hljs-keyword">catch</span> 里面调用<span class="hljs-keyword">return</span>的时候默认状态是fuifilled,他的返回值是一个promise和then一样如果向继续链式调用<span class="hljs-keyword">catch</span>，需要抛出异常当promise中调用reject的时候，会调用最近<span class="hljs-keyword">catch</span>没有返回值时不会继续链式调用<span class="hljs-number">211.</span>中断函数的执行<span class="hljs-keyword">return</span><span class="hljs-keyword">throw</span>前两种会直接结束函数的执行<span class="hljs-keyword">yield</span></code></pre></div><p><img src="https://img1.imgtp.com/2022/08/14/ws0WolVm.png" alt="QQ截图20220612095542.png"></p><p>212.Promise.prototype.finally(callback)    </p><p>​        无论Promise对象变成fulfilled还是rejected状态，最终都会执行</p><p>​        finally方法的回调函数参数是不接受参数的</p><ol start="213"><li><p>Promise.resolve()相当于new Promsie()并且执行resolve方法。</p><p>就是希望将变量转换成Promise来使用</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&quot;why&quot;</span>)=<span class="hljs-function">=&gt;</span><span class="hljs-keyword">new</span> Promsise(<span class="hljs-function"><span class="hljs-params">(resolve)</span>=&gt;</span>resolve(<span class="hljs-string">&quot;why&quot;</span>))参数和resolve一样</code></pre></div></li><li><p>Promise.reject() reject方法类似于resolve方法，只是会将Promise对象的状态设置为reject状态</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-string">&quot;why&quot;</span>)=&gt;<span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">_</span>,<span class="hljs-params">reject</span>)</span>=&gt;reject(<span class="hljs-string">&quot;why&quot;</span>))<span class="hljs-comment">//_不传可以这样写</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promsie</span>.</span></span>reject无论传什么参数都是rejected</code></pre></div></li><li><p>Promsie.all([])</p><div class="code-wrapper"><pre><code class="hljs arcade">他的作用是将对各promise,放入到数组中执行，<span class="hljs-built_in">all</span>方法的最终状态是由数组中的所有promisek结果决定的，如果Promise所有状态都是fulfilled状态则Pramise.<span class="hljs-built_in">all</span>的状态为fulfilled，并且将所有数组中的promise的返回值做成一个数组返回如果数组中出现一个promise状态为rejected则<span class="hljs-built_in">all</span>的状态也会变成rejected,并将第一个reject的返回值作为参数Promsie.<span class="hljs-built_in">all</span>([p1,p2,p3]).then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>res).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>err)</code></pre></div></li><li><p>Promise.allSettled([])</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promsie</span>.</span></span>all<span class="hljs-constructor">Settled([<span class="hljs-params">p1</span>,<span class="hljs-params">p2</span>,<span class="hljs-params">p3</span>])</span>.<span class="hljs-keyword">then</span>(res=&gt;res)<span class="hljs-comment">//状态都是fulfilled,会返回一个[&#123;stattus:fulfilled/rejected,value:&quot;&quot;&#125;]</span></code></pre></div></li><li><p>Promsie.race([])</p><div class="code-wrapper"><pre><code class="hljs cpp">rece的状态由[]中的promise那个先完成的状态来决定的</code></pre></div></li><li><p>Promise.any([])</p></li></ol><div class="code-wrapper"><pre><code class="hljs cpp">只要[]中的promise中的第一个变成fulfilled的状态来决定的，返回值也是这个promise返回值如果所有的promsie状态都是rejected则会变成any的状态会变成reject果所有的Promise都是reject的，那么会报一个AggregateError的错误。</code></pre></div><p>219.迭代器</p><p>220.async函数的执行</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">async</span>函数 没有<span class="hljs-keyword">await</span>的话则和普通的函数没有区别，都是会同步执行返回值如果是普通值则会被<span class="hljs-built_in">Promise</span>.resolve()包裹返回值是promsie时，会有promise的状态来决定返回值是thenable对象，则由thenable的状态来决定<span class="hljs-keyword">async</span>函数的执行函数的执行函数想返回reject状态，调用<span class="hljs-keyword">catch</span>,可以使用返回一个promsie 里面用reject(),thenable也是一样，或者使用<span class="hljs-built_in">Promise</span>.reject()还可以用<span class="hljs-keyword">throw</span> 来抛出异常<span class="hljs-keyword">async</span>的异常不会报错，而是会作为<span class="hljs-built_in">Promise</span>.reject来传递<span class="hljs-keyword">await</span>关键字 只能在<span class="hljs-keyword">async</span>里面使用<span class="hljs-keyword">await</span> 之后的代码相当于Promsie.<span class="hljs-keyword">then</span>(),<span class="hljs-keyword">await</span>要捕获错误需要使用<span class="hljs-keyword">try</span>...<span class="hljs-keyword">catch</span><span class="hljs-keyword">await</span> 后面跟的代码是<span class="hljs-built_in">Promise</span>.resolve包裹，会等待promise的返回值<span class="hljs-keyword">await</span>会阻塞代码的执行，等待promise返回值，<span class="hljs-keyword">await</span>之前都是同步的</code></pre></div><p>221.浏览器的事件循环</p><p>​        宏任务队列(marcotask queue)：</p><div class="code-wrapper"><pre><code class="hljs coffeescript">ajax,<span class="hljs-built_in">setTimeout</span>,<span class="hljs-built_in">setInterval</span>,DOM监听，UI Rendering等</code></pre></div><p>​        微任务队列(microtask queue)</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>的<span class="hljs-keyword">then</span>回调，Mutation Obderver API queueMicrotask <span class="hljs-keyword">async</span> <span class="hljs-keyword">await</span></code></pre></div><p>​    执行宏任务之前，会先检查微任务队列是否为空，如果不为空，先执行微任务</p><p>222.错误处理方案</p><p>​        throw 会中断后面代码的执行</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">throw</span> <span class="hljs-title class_">String</span>/<span class="hljs-built_in">number</span>/<span class="hljs-built_in">boolean</span>/<span class="hljs-title class_">Object</span></code></pre></div><p>​        异常的捕获</p><p>​        try..catch..finally</p><p>223.cookie存储是由浏览器自动做的，携带cookie也是由浏览器做的</p><p>224.Storage</p><p>​        localStorage在页面关闭并重新打开时不会被清除，sessionStroage会被清除</p><p>​        在页面内发生跳转不打开新页面时，sessionStorage和localStorage都会被保留</p><p>​        在页面外发生跳转打开新的页面时，sessionStorage不保存，localStorage会保存</p><p>​        sessionStorage只会在本次会话中存储，不会在新页面中获取</p><p>225.cache工具的封装</p><p>226.正则表达式</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> re1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">REgExp</span>(pattern,<span class="hljs-string">&quot;ig&quot;</span>)<span class="hljs-comment">//new 创建</span><span class="hljs-keyword">const</span> re2=<span class="hljs-regexp">/aaaa/ig</span> <span class="hljs-comment">//字面量写法</span>message.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/abc/ig</span>,<span class="hljs-string">&quot;cba&quot;</span>)message.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-regexp">/\d+/ig</span>,<span class="hljs-string">&quot;cba&quot;</span>)message.<span class="hljs-title function_">test</span>(<span class="hljs-regexp">/^abc$/ig</span>)<span class="hljs-comment">//返回值是boolean值</span>message.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/abc/ig</span>)<span class="hljs-comment">//返回匹配到的值的数组结合</span>message.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/abc/ig</span>)<span class="hljs-comment">//必须加g,返回值是迭代器</span>message.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/abc/ig</span>)message.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/abc/i</span>)<span class="hljs-comment">//返回索引，没有则返回-1</span>常见修饰符g 匹配全部i 忽略大小写m 多行匹配规则\d digit 一个数字<span class="hljs-number">0</span>-<span class="hljs-number">9</span>\s space 一个空格字符，换行符,\t,\n\w word 一个拉丁字母或者数字，下划线.  匹配任意字符，除了换行符反向类\D 非数字 除\d以外字符 如字母\S 非空格 \W 非单字字符转义/\./ig 对.进行转义[,],\,^,$,.,|,?,*,+,(,),/  常见的需要进行转义<span class="hljs-keyword">const</span> jsfile=<span class="hljs-regexp">/\.jsx?$/</span>  ?表示前面的字符可选集合匹配到多个字符中的其中之一.用[]/[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]/,<span class="hljs-regexp">/[156]/</span><span class="hljs-keyword">const</span> phone=<span class="hljs-regexp">/^1[3-9]\d&#123;9&#125;$/</span> <span class="hljs-comment">//匹配电话号码</span>排除范围[^...]，不匹配括号里面的量词/a&#123;<span class="hljs-number">5</span>&#125;/ 匹配<span class="hljs-number">5</span>个a /a&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;/匹配<span class="hljs-number">3</span>-<span class="hljs-number">5</span>个a缩写+:一个或者多个,&#123;<span class="hljs-number">1</span>,&#125;?:<span class="hljs-number">0</span>或者<span class="hljs-number">1</span>个 &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;*:<span class="hljs-number">0</span>个或者多个 &#123;<span class="hljs-number">0</span>,&#125;<span class="hljs-keyword">const</span> tag=<span class="hljs-regexp">/&lt;\/?[a-z][a-z0-9]*\/?/ig</span>  匹配多个元素标签贪婪模式和惰性模式<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《.+?》/g</span> 惰性模式<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《.+》/g</span> 贪婪模式捕获组<span class="hljs-keyword">const</span> name=<span class="hljs-regexp">/《(.+?)》/g</span>str.<span class="hljs-title function_">matchAll</span>(name)未学完<span class="hljs-number">227.</span>http 超文本传输协议  默认端口是<span class="hljs-number">80</span>端口，是应用层协议<span class="hljs-number">228.</span><span class="hljs-variable constant_">HTTP</span>组成一次请求包括request和response<span class="hljs-number">229.</span>http版本<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.0</span><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> 添加了持久化连接<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2.0</span><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">3.0</span><span class="hljs-number">230.</span><span class="hljs-variable constant_">HTTP</span>的请求方式<span class="hljs-variable constant_">GET</span><span class="hljs-variable constant_">HEAD</span><span class="hljs-comment">//和get相似,但是没有响应体，例如准备下载一个文件前，先获取文件的大小，再决定是否进行下载</span><span class="hljs-variable constant_">POST</span><span class="hljs-comment">//将实体提交到指定的资源</span><span class="hljs-variable constant_">PUT</span><span class="hljs-comment">//替换所有数据</span><span class="hljs-variable constant_">DELETE</span><span class="hljs-variable constant_">PATCH</span><span class="hljs-comment">//对部分数据进行修改</span><span class="hljs-variable constant_">CONNECT</span><span class="hljs-variable constant_">TRACE</span><span class="hljs-number">231.</span>request headercontent-type是请求携带的数据类型application/x-www-form-urlencoded 表示被编码成以&amp;分隔name=why&amp;age=<span class="hljs-number">18</span>application/json 表示是一种json类型text/plain 表示文本类型application/xmlmultipart/form-data <span class="hljs-comment">//表示文件上传 ，很多浏览器会自动设置</span>content-length 文件长度 不需要设置keep-alive http/<span class="hljs-number">1.1</span> 默认为<span class="hljs-literal">true</span>accept-<span class="hljs-attr">encoding</span>:告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip压缩对应.<span class="hljs-property">gz</span>文件，浏览器会自动解压，这个属性不用配，浏览器会配，在webpack中可以打包成gzip文件<span class="hljs-attr">accept</span>:告诉浏览器，客户端可以接受的文件的格式类型 默认是任何格式都接受user-<span class="hljs-attr">agent</span>:客户端相关的信息<span class="hljs-number">232.</span>http response status<span class="hljs-number">200</span> ok <span class="hljs-number">201</span> create post请求，创建新的资源<span class="hljs-number">301</span> 永久重定向<span class="hljs-number">400</span> bad request 客户端的错误，服务器无法或者不进行处理<span class="hljs-number">401</span> unauthorized 未授权 一般是没有登录的情况下 没有cookie,token或者过期<span class="hljs-number">403</span> forbidden 没有权限<span class="hljs-number">404</span> <span class="hljs-title class_">NOt</span> found 一般是接口不存在，url错误<span class="hljs-number">500</span> 服务器未知错误<span class="hljs-number">503</span> 暂时无法访问<span class="hljs-number">400</span>、<span class="hljs-number">403</span>都是浏览器返回的有些开发所有返回的status都是<span class="hljs-number">200</span>，在数据里面来自定义错误信息<span class="hljs-number">233.</span>xhr<span class="hljs-keyword">const</span> xhr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()xhr.<span class="hljs-property">onload</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//xhr.response   一般使用这个</span><span class="hljs-comment">//xhr.responseText</span><span class="hljs-comment">//xhr.responseXML</span>&#125;xhr.<span class="hljs-property">responseType</span>=<span class="hljs-string">&quot;json&quot;</span><span class="hljs-comment">//默认是text,一般是json</span>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;get&quot;</span>,url)<span class="hljs-comment">//第一个参数是请求类型，第二个参数是url，第三个参数是是否同步，默认是异步</span><span class="hljs-comment">//设置过期时间</span>xhr.<span class="hljs-property">timeout</span>=<span class="hljs-number">3000</span>xhr.<span class="hljs-property">ontimeout</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;xhr.<span class="hljs-title function_">abort</span>()<span class="hljs-comment">//取消请求</span><span class="hljs-comment">//发送网络请求</span>xhr.<span class="hljs-title function_">send</span>()<span class="hljs-number">234.</span>ajax的封装<span class="hljs-number">235.</span><span class="hljs-title class_">Fetch</span> 返回值是promise文件上传地址<span class="hljs-attr">http</span>:<span class="hljs-comment">//123.207.32.32:1888/02_param/upload</span><span class="hljs-number">236.</span>gitgit add .git commit -m <span class="hljs-string">&quot;提交描述&quot;</span>git pushgit pull origin master <span class="hljs-comment">//从远程的某个分支获取</span>git branch --set-upstream-to=origin/master  <span class="hljs-comment">//设置上游分支就可以只写 git pull了</span>git merge --allow-unrelated-histories  <span class="hljs-comment">//强制合并</span>git statusgit clone url<span class="hljs-comment">//克隆代码</span>push到远程仓库git pushgit push origin masterfetch代码git fetch git fetch origin master获取到代码后默认并没有合并，需要mergegit mergeget merge origin/master也可以使用git pull相当于git fetch+git <span class="hljs-title function_">merge</span>(rebase)链接远程仓库geit remote add origin ....git push origin master <span class="hljs-comment">//第一次图送会推送到main分支  第二次推送会被推送到master</span>git push origin <span class="hljs-attr">master</span>:maingit push origin <span class="hljs-attr">head</span>:main  head默认指向main如果要push master默认要这么写git push origin <span class="hljs-attr">master</span>:main  如果想写git push就要这么写配置git push 指向上游路径master，就是配置好的git branch --set-upstream-to=origin/master调用git push 就会push到master,但是这样每个分支都是push到mastergit config push.<span class="hljs-property">default</span> upstream  [--<span class="hljs-variable language_">global</span>]<span class="hljs-comment">//加上global可以全局使用，否则就是当前项目使用</span>git config push.<span class="hljs-property">default</span> current  <span class="hljs-comment">//这个会先去仓库找有没有和本地相同的分支，如果没有就在远程创建一个新的和本地相同的分支</span>push.<span class="hljs-property">default</span> 默认是simple 就是push相同的分支git tag 打标签git tag v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>git tag -a v1<span class="hljs-number">.0</span><span class="hljs-number">.1</span> -m <span class="hljs-string">&quot;注释&quot;</span>默认情况子git tag 不会push到服务器git push origin v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>  推送到远程git push origin --tags 把所有tag都推送上去git tag -d tagname  <span class="hljs-comment">//删除本地的tag</span>git oush origin&lt;在本地定义的远程的名字，默认是origin&gt; -d或者--<span class="hljs-keyword">delete</span> v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>git checkpout v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span> 跳转到目标tag, 回到tag版本代码 不能再当前tag修改代码，需要根据当前的tag,创建新的分支来修改git cat-file -p 00d2  <span class="hljs-comment">//查看.git/objects/00/d2..... 就可以看到文件的内容</span>git cat-file -t 00d2 <span class="hljs-comment">//查看文件内容</span><span class="hljs-comment">//blod 表示文件还没提交的文件</span><span class="hljs-comment">//commit 表示已经提交</span><span class="hljs-comment">//tag 表示是tag</span></code></pre></div><p>237.Git分支</p><p>创建新的分支其实创建一个新的可移动的指针</p><p>git branch 分支  创建分支</p><p>git checkout 分支 切换分支</p><p>git 怎么直到指向那个分支 也是使用HEAD的指针 </p><p>git checkout 分支  就是将head指针指向它</p><p>先使用 git branch 分支 创建分支 然后再使用 git checkout 分支 将切换分支指针指向该分支</p><p>git checkout -b <newbranchname>   //创建新的分支并且切换分支</p><p> 238.git flow </p><p>在项目开发过程中，首先会创建master主分支用于线上发布，可以打上tag作为版本，如果线上出现bug,则从master开辟分支，进行代码的修复，然后合并到master分支，和develop分支。develop分支用于开发，需要上线时会开辟release分支用于测试，并且修复测试遇到的bug,完成测试后就可以合并到master和develop,如果需要开发新的功能，则需要从develop开辟新分支进行开发</p><p>239.git的远程分支</p><p>git remote add origin url</p><p>git fetch origin main  //把main分支拉取</p><p>git branch –set-upstream-to=origin/main  //设置上游分支</p><p>=========================================================</p><p>get merge//默认合并upstream   合并必须要有共同的祖先</p><p>远程分支是也是一种分支结构：  以 remote/branch式命名的</p><p>240.跟踪远程分支</p><p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支</p><p>如果你愿意的话可以设置其他的跟踪分支，可以通过运行 git checkout –track origin/分支名</p><p> 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支</p><div class="code-wrapper"><pre><code class="hljs vim">git checkout --track <span class="hljs-symbol">&lt;remote&gt;</span>/<span class="hljs-symbol">&lt;branch&gt;</span>  相当于git branch --<span class="hljs-keyword">set</span>-upstream-<span class="hljs-keyword">to</span>=origin/main  跟踪origin/main  并且创建和切换mian分支git checkout <span class="hljs-symbol">&lt;branch&gt;</span>  上面的简写他会先检查远程有没有这个分支，然后在跟踪这个分支，并且在本地创建这个分支，在切换到这个分支</code></pre></div><p>241.git checkout -b  develop</p><p>​        git push origin develop</p><p>如果需要创建一个分支，并且推送到远程，远程也会创建相同的分支</p><p>242.git branch -d  分支     删除本地分支</p><p>243.删除远程分支</p><div class="code-wrapper"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --<span class="hljs-built_in">delete</span> &lt;branch&gt;</code></pre></div><p>244.查看git log</p><div class="code-wrapper"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--pretty=oneline</span></code></pre></div><p>245 git rebase</p><div class="code-wrapper"><pre><code class="hljs crmsh">git checkout featuregit rebase <span class="hljs-keyword">master</span><span class="hljs-title">git</span> checkout <span class="hljs-keyword">master</span><span class="hljs-title">git</span> merge  feature//永远不要在主分支上rebase</code></pre></div><p>246.git rebase的原理</p><p>247.rebase和merge的区别</p><p>merge会记录git的所有历史，那么分支的历史错综复杂，也会全部记录下来</p><p>rebase用于简化历史记录，将两个分支的历史简化，整个历史更加简洁</p>]]></content>
    
    
    <categories>
      
      <category>note</category>
      
      <category>前端系统课笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue2和vue3的区别(vue2向vue3迁移)(一)</title>
    <link href="/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/"/>
    <url>/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<ol><li><h3 id="vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。"><a href="#vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。" class="headerlink" title="vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。"></a>vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。</h3></li><li><h3 id="vue3中使用Proxy来实现对数据劫持，vue2中使用Object-defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用-set和-delete方法。"><a href="#vue3中使用Proxy来实现对数据劫持，vue2中使用Object-defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用-set和-delete方法。" class="headerlink" title="vue3中使用Proxy来实现对数据劫持，vue2中使用Object.defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用$set和$delete方法。"></a>vue3中使用Proxy来实现对数据劫持，vue2中使用Object.defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用$set和$delete方法。</h3></li><li><h3 id="vue3删除了-set和-off-once-移除了filter-内敛模板等特性"><a href="#vue3删除了-set和-off-once-移除了filter-内敛模板等特性" class="headerlink" title="vue3删除了$set和$off,$once.移除了filter,内敛模板等特性"></a>vue3删除了$set和$off,$once.移除了filter,内敛模板等特性</h3></li><li><h3 id="在编译方面做了优化：生成Block-tree-Slot编译优化，diff算法优"><a href="#在编译方面做了优化：生成Block-tree-Slot编译优化，diff算法优" class="headerlink" title="在编译方面做了优化：生成Block tree,Slot编译优化，diff算法优"></a>在编译方面做了优化：生成Block tree,Slot编译优化，diff算法优</h3></li><li><h3 id="vue3中已经去掉了事件总线，可以使用mitt"><a href="#vue3中已经去掉了事件总线，可以使用mitt" class="headerlink" title="vue3中已经去掉了事件总线，可以使用mitt"></a>vue3中已经去掉了事件总线，可以使用mitt</h3></li><li><h3 id="vue3中增加了componsition-API"><a href="#vue3中增加了componsition-API" class="headerlink" title="vue3中增加了componsition API"></a>vue3中增加了componsition API</h3></li><li><h3 id="vue3中移除了-children"><a href="#vue3中移除了-children" class="headerlink" title="vue3中移除了$children"></a>vue3中移除了$children</h3></li><li><h3 id="vue3中的推荐的构建工具已经从vue-cli转成vite"><a href="#vue3中的推荐的构建工具已经从vue-cli转成vite" class="headerlink" title="vue3中的推荐的构建工具已经从vue cli转成vite"></a>vue3中的推荐的构建工具已经从vue cli转成vite</h3></li><li><h3 id="vue3中的推荐的状态管理工具已经从vuex转成pinia"><a href="#vue3中的推荐的状态管理工具已经从vuex转成pinia" class="headerlink" title="vue3中的推荐的状态管理工具已经从vuex转成pinia"></a>vue3中的推荐的状态管理工具已经从vuex转成pinia</h3></li><li><h3 id="IDE支持Vetur-gt-Volar"><a href="#IDE支持Vetur-gt-Volar" class="headerlink" title="IDE支持Vetur-&gt;Volar"></a>IDE支持Vetur-&gt;Volar</h3></li><li><h3 id="vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰"><a href="#vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰" class="headerlink" title="vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰"></a>vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰</h3></li><li><h3 id="添加了全新的全局api-createApp-来替代new-Vue-来创建vue实例"><a href="#添加了全新的全局api-createApp-来替代new-Vue-来创建vue实例" class="headerlink" title="添加了全新的全局api :createApp()来替代new Vue()来创建vue实例"></a>添加了全新的全局api :createApp()来替代new Vue()来创建vue实例</h3></li></ol><table><thead><tr><th>2.x Global API</th><th>3.x Instance API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config</td><td>app.config</td></tr><tr><td>Vue.config.productionTip</td><td>删除</td></tr><tr><td>Vue.config.ignoredElements</td><td>app.config.compilerOptions.isCustomElement</td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr><tr><td>Vue.extend</td><td>删除</td></tr></tbody></table><h3 id="13-全局-API-Treeshaking"><a href="#13-全局-API-Treeshaking" class="headerlink" title="13.全局 API Treeshaking"></a>13.全局 API Treeshaking</h3><div class="code-wrapper"><pre><code class="hljs vue">import Vue from &#x27;vue&#x27;Vue.nextTick(() =&gt; &#123;  // something DOM-related&#125;)</code></pre></div><p>在Vue2.X中Vue.nextTick()是一个暴露在单个Vue对象中的全局的api，事实上，实例方法$nextTick()只是一个包装器，为了方便Vue.nextTick()，回调函数的this会自动绑定到当前实例中，但是在vite和webpack中，Vue.nextTick不可以进行treeshaking,所以在Vue3中做了优化，让nextTick可以进行treeShaking,全局的模块只能作为ES模块构建的命名导出来进行访问，</p><div class="code-wrapper"><pre><code class="hljs vue">import &#123; nextTick &#125; from &#x27;vue&#x27;nextTick(() =&gt; &#123;  // something DOM-related&#125;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs vue">import &#123; shallowMount &#125; from &#x27;@vue/test-utils&#x27;import &#123; MyComponent &#125; from &#x27;./MyComponent.vue&#x27;import &#123; nextTick &#125; from &#x27;vue&#x27;test(&#x27;an async feature&#x27;, async () =&gt; &#123;  const wrapper = shallowMount(MyComponent)  // execute some DOM-related tasks  await nextTick()  // run your assertions&#125;)</code></pre></div><p>如果在Vue3中使用Vue.nextTick()会导致臭名昭著的<code>undefined is not a function</code>错误</p><p>通过此更改，如果模块捆绑器支持 tree-shaking，则未在 Vue 应用程序中使用的全局 API 将从最终捆绑包中删除，从而获得最佳文件大小</p><h5 id="以下Vue2的全局QAPI会受到影响"><a href="#以下Vue2的全局QAPI会受到影响" class="headerlink" title="以下Vue2的全局QAPI会受到影响"></a>以下Vue2的全局QAPI会受到影响</h5><ul><li><code>Vue.nextTick</code></li><li><code>Vue.observable</code>（替换为<code>Vue.reactive</code>）</li><li><code>Vue.version</code></li><li><code>Vue.compile</code>（仅在完整版本中）</li><li><code>Vue.set</code>（仅在兼容版本中）//不要使用</li><li><code>Vue.delete</code>（仅在兼容版本中）//不要使用</li></ul><p>除了如上全局API之外，许多内部组件将不再作为默认导入的一部分，需要使用到时再导入，有利于treeShaking,</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;transition&gt;  &lt;div v-show=&quot;ok&quot;&gt;hello&lt;/div&gt;&lt;/transition&gt;</code></pre></div><p>会被编译成</p><div class="code-wrapper"><pre><code class="hljs vue">import &#123; h, Transition, withDirectives, vShow &#125; from &#x27;vue&#x27;export function render() &#123;  return h(Transition, [withDirectives(h(&#x27;div&#x27;, &#x27;hello&#x27;), [[vShow, this.ok]])])&#125;</code></pre></div><p>可以减少包的大小</p><p><strong>notice</strong></p><p><strong>上述内容仅适用于与支持 tree-shaking 的捆绑器一起使用的<a href="https://github.com/vuejs/core/tree/master/packages/vue#which-dist-file-to-use">ES 模块构建</a>- UMD 构建仍然包含所有功能并在 Vue 全局变量上公开所有内容（并且编译器将生成适当的输出以使用全局 API 而不是导入）。</strong></p><p>再插件中使用时</p><p>Vue2.x中使用全局api</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> plugin = &#123;  <span class="hljs-attr">install</span>: <span class="hljs-function"><span class="hljs-params">Vue</span> =&gt;</span> &#123;    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// ...</span>    &#125;)  &#125;&#125;</code></pre></div><p>Vue3.x使用全局API</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">const</span> plugin = &#123;  <span class="hljs-attr">install</span>: <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;    <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// ...</span>    &#125;)  &#125;&#125;</code></pre></div><p>在webpack中如果把上诉代码打包成一个buddle,他会把vue源码也会打包进去，如果要避免这样的发生可以使用externals排除</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-comment">/*...*/</span>  <span class="hljs-attr">externals</span>: &#123;    <span class="hljs-attr">vue</span>: <span class="hljs-string">&#x27;Vue&#x27;</span>  &#125;&#125;</code></pre></div><p>rollUp中的写法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// rollup.config.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">/*...*/</span>  <span class="hljs-attr">external</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>]&#125;</code></pre></div><h3 id="14-v-model"><a href="#14-v-model" class="headerlink" title="14.v-model"></a>14.v-model</h3><p>在组建中使用v-model</p><p>在vue2.x,<code>v-model</code>在组件上使用 a 相当于传递一个<code>value</code>prop 并发出一个<code>input</code>事件：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;</code></pre></div><p>如果想更改属性名和事件的时候，需要使用在组件中添加model选项，</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- ParentComponent.vue --&gt;&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">// ChildComponent.vue</span>export default <span class="hljs-punctuation">&#123;</span>  model<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    prop<span class="hljs-punctuation">:</span> &#x27;title&#x27;<span class="hljs-punctuation">,</span>    event<span class="hljs-punctuation">:</span> &#x27;change&#x27;  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  props<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-comment">// this allows using the `value` prop for a different purpose</span>    value<span class="hljs-punctuation">:</span> String<span class="hljs-punctuation">,</span>    <span class="hljs-comment">// use `title` as the prop which take the place of `value`</span>    title<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>      type<span class="hljs-punctuation">:</span> String<span class="hljs-punctuation">,</span>      default<span class="hljs-punctuation">:</span> &#x27;Default title&#x27;    <span class="hljs-punctuation">&#125;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>所以v-model实际上时这样的</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent :title=&quot;pageTitle&quot; @change=&quot;pageTitle = $event&quot; /&gt;</code></pre></div><h3 id="使用v-bind-sync"><a href="#使用v-bind-sync" class="headerlink" title="使用v-bind.sync#"></a>使用<code>v-bind.sync</code><a href="https://v3-migration.vuejs.org/breaking-changes/v-model.html#using-v-bind-sync">#</a></h3><p>在某些情况下，我们可能需要一个道具的“双向绑定”（有时除了现有<code>v-model</code>的不同道具之外）。为此，我们建议以<code>update:myPropName</code>. 例如，对于<code>ChildComponent</code>上一个带有<code>title</code>prop 的示例，我们可以通过以下方式传达分配新值的意图：</p><div class="code-wrapper"><pre><code class="hljs vue">this.$emit(&#x27;update:title&#x27;, newValue)</code></pre></div><p>然后，如果需要，父级可以侦听该事件并更新本地数据属性。例如：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</code></pre></div><p><code>.sync</code>为方便起见，我们使用修饰符对这种模式进行了简写：</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt;</code></pre></div><p>在Vue3.x中 自定义组件的双向数据绑定时使用modelValue，@update:modelValue来替代</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent  :modelValue=&quot;pageTitle&quot;  @update:modelValue=&quot;pageTitle = $event&quot;/&gt;</code></pre></div><p>如果需要修改model的名称则直接修改</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;ChildComponent v-model:title=&quot;pageTitle&quot; /&gt;&lt;!-- would be shorthand for: --&gt;&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</code></pre></div><p>也可以作为.sync的替代，可以在组件中双向数据绑定多个值</p><div class="code-wrapper"><pre><code class="hljs js">&lt;<span class="hljs-title class_">ChildComponent</span> v-<span class="hljs-attr">model</span>:title=<span class="hljs-string">&quot;pageTitle&quot;</span> v-<span class="hljs-attr">model</span>:content=<span class="hljs-string">&quot;pageContent&quot;</span> /&gt;&lt;!-- would be shorthand <span class="hljs-attr">for</span>: --&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span></span></span><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  @<span class="hljs-attr">update:title</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">:content</span>=<span class="hljs-string">&quot;pageContent&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">  @<span class="hljs-attr">update:content</span>=<span class="hljs-string">&quot;pageContent = $event&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">/&gt;</span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue2和vue3的区别(vue2向vue3迁移)(二)</title>
    <link href="/2022/08/12/Vue3%E5%92%8CVue%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%BA%8C)/"/>
    <url>/2022/08/12/Vue3%E5%92%8CVue%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="15-key属性"><a href="#15-key属性" class="headerlink" title="15.key属性"></a>15.key属性</h3><p>key主要适用于在Vue的虚拟DOM算法中，跟踪节点的，以便重用和修改现有的节点，以及何时修改或者重新排序。</p><p>在Vue2.x中，key也被推荐用于v-if,v-else,v-else-if</p><div class="code-wrapper"><pre><code class="hljs json">&lt;!-- Vue <span class="hljs-number">2.</span>x --&gt;&lt;div v-if=<span class="hljs-string">&quot;condition&quot;</span> key=<span class="hljs-string">&quot;yes&quot;</span>&gt;Yes&lt;/div&gt;&lt;div v-else key=<span class="hljs-string">&quot;no&quot;</span>&gt;No&lt;/div&gt;</code></pre></div><p>在vue3.x中不再要求这么使用，因为vue会自己给他添加一个unique key</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 3.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>如果你确实想添加key,必须保证key唯一</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 2.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- Vue 3.x (recommended solution: remove keys) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- Vue 3.x (alternate solution: make sure the keys are always unique) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;condition&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span>No<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p> <strong><code>&lt;template v-for&gt;</code></strong></p><div class="code-wrapper"><pre><code class="hljs gauss">vue2.x中 &lt;template&gt;标签不能拥有<span class="hljs-built_in">key</span>,只能在他的子元素中设置<span class="hljs-built_in">key</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 2.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;&#x27;heading-&#x27; + item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;&#x27;content-&#x27; + item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p>在vue3.x中，key应该被设置在template上</p><!-- Vue 3.x --><template v-for="item in list" :key="item.id">  <div>...</div>  <span>...</span></template><p>v-for也是一样</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 2.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item.isVisible&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-comment">&lt;!-- Vue 3.x --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item.isVisible&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h3 id="16-v-if-与-v-for-优先级"><a href="#16-v-if-与-v-for-优先级" class="headerlink" title="16.v-if 与 v-for 优先级"></a>16.v-if 与 v-for 优先级</h3><p>在vue2.x中，在相同的元素中v-for的优先级更高</p><p>Vue3.x中，v-if的优先级更高</p><h3 id="17-v-bind"><a href="#17-v-bind" class="headerlink" title="17.v-bind"></a>17.v-bind</h3><p>vue2.x中</p><div class="code-wrapper"><pre><code class="hljs htaccess">&lt;!-- template --&gt;&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;!-- result --&gt;&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;</code></pre></div><p>vue3.x中</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- template --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- result --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- template --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- result --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>对于绑定相同的属性，v2不会覆盖，而v3会被覆盖 v3中绑定有顺序要求</p><h3 id="18-v-on-native已经被移除"><a href="#18-v-on-native已经被移除" class="headerlink" title="18.v-on.native已经被移除"></a>18.v-on.native已经被移除</h3><h3 id="19-函数式组件"><a href="#19-函数式组件" class="headerlink" title="19.函数式组件"></a>19.函数式组件</h3><p>vue2.x中函数式组件主要用于性能优化，他的初始化速度要快于有状态组件，而且可以返回多个根节点，vue3.x中有状态组件的性能优化可以和无状态组件一样，而且还可以有多个跟节点</p><h3 id="20-异步组件"><a href="#20-异步组件" class="headerlink" title="20.异步组件"></a>20.异步组件</h3><p>vue2.x中异步组件的写法是</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncModal</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal.vue&#x27;</span>)</code></pre></div><p>或者可配置</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> asyncModal = &#123;  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal.vue&#x27;</span>),  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,  <span class="hljs-attr">error</span>: <span class="hljs-title class_">ErrorComponent</span>,  <span class="hljs-attr">loading</span>: <span class="hljs-title class_">LoadingComponent</span>&#125;</code></pre></div><p>vue3中添加了一个定义异步组件的方法</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ErrorComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/ErrorComponent.vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">LoadingComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/LoadingComponent.vue&#x27;</span><span class="hljs-comment">// Async component without options</span><span class="hljs-keyword">const</span> asyncModal = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal.vue&#x27;</span>))<span class="hljs-comment">// Async component with options</span><span class="hljs-keyword">const</span> asyncModalWithOptions = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Modal.vue&#x27;</span>),  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>&#125;)</code></pre></div><p>而且vue2.x中的配置选项component变成了loader</p><p>vue3.x不再接受resolve，reject参数，而是返回一个promise</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 2.x version</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">oldAsyncComponent</span> = (<span class="hljs-params">resolve, reject</span>) =&gt; &#123;  <span class="hljs-comment">/* ... */</span>&#125;<span class="hljs-comment">// 3.x version</span><span class="hljs-keyword">const</span> asyncComponent = <span class="hljs-title function_">defineAsyncComponent</span>(  <span class="hljs-function">() =&gt;</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">/* ... */</span>    &#125;))</code></pre></div><h3 id="21-emits-Option"><a href="#21-emits-Option" class="headerlink" title="21.emits Option"></a>21.<code>emits</code> Option</h3><p>vue2.x中不需要声明emits的值</p><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;accepted&#x27;)&quot;</span>&gt;</span>OK<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;text&#x27;</span>]</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>vue3.x中需要定义emits</p><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;accepted&#x27;)&quot;</span>&gt;</span>OK<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;text&#x27;</span>],</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;accepted&#x27;</span>]</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js">下面例子中&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;click&#x27;, $event)&quot;</span>&gt;</span>OK<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">emits</span>: [] <span class="hljs-comment">// without declared event</span></span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><p>在父组件中监听click事件</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-button</span>&gt;</span></code></pre></div><p>click会被触发两次</p><h3 id="22-listener移除"><a href="#22-listener移除" class="headerlink" title="22.$listener移除"></a>22.$listener移除</h3><h3 id="23-attrs中包含class和style"><a href="#23-attrs中包含class和style" class="headerlink" title="23.$attrs中包含class和style"></a>23.$attrs中包含class和style</h3><p>vue2.x中，<code>class</code>和<code>style</code>属性在 Vue 2 虚拟 DOM 实现中得到一些特殊处理。因此，它们<em>不</em>包含在 中<code>$attrs</code>，而所有其他属性都包含在 中。</p><p>使用时会出现这样的副作用<code>inheritAttrs: false</code>：</p><p>这样$attr中的属性不再自动绑定到子组件的根元素上，而是由开发者来决定怎么绑定他们，但是class和style不属于$attr的一部分，任然会应用在根元素上</p><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> /&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span></span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;my-component id=<span class="hljs-string">&quot;my-id&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;my-class&quot;</span>&gt;&lt;/my-component&gt;</code></pre></div><p>真正渲染成的html</p><div class="code-wrapper"><pre><code class="hljs js">&lt;label <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;my-class&quot;</span>&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;my-id&quot;</span> /&gt;</span></span>&lt;/label&gt;</code></pre></div><p>在Vue3.x中则包含这些</p><h3 id="24-v-on不再支持数字的keycode"><a href="#24-v-on不再支持数字的keycode" class="headerlink" title="24.v-on不再支持数字的keycode"></a>24.v-on不再支持数字的keycode</h3><h3 id="25-不在支持-on-off-once"><a href="#25-不在支持-on-off-once" class="headerlink" title="25.不在支持$on,$off,$once"></a>25.不在支持$on,$off,$once</h3><p>vue2.x中支持事件总线</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// eventBus.js</span><span class="hljs-keyword">const</span> eventBus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> eventBus</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ChildComponent.vue</span><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// adding eventBus listener</span>    eventBus.$on(<span class="hljs-string">&#x27;custom-event&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Custom event triggered!&#x27;</span>)    &#125;)  &#125;,  <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// removing eventBus listener</span>    eventBus.$off(<span class="hljs-string">&#x27;custom-event&#x27;</span>)  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ParentComponent.vue</span><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">methods</span>: &#123;    <span class="hljs-title function_">callGlobalCustomEvent</span>(<span class="hljs-params"></span>) &#123;      eventBus.$emit(<span class="hljs-string">&#x27;custom-event&#x27;</span>) <span class="hljs-comment">// if ChildComponent is mounted, we will have a message in the console</span>    &#125;  &#125;&#125;</code></pre></div><p>vue3.x中事件总线可以使用第三方的库来实现，例如<a href="https://github.com/developit/mitt">mitt</a>或<a href="https://github.com/scottcorgan/tiny-emitter">tiny-emitter</a></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// eventBus.js</span><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;tiny-emitter/instance&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">$on</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> emitter.<span class="hljs-title function_">on</span>(...args),  <span class="hljs-attr">$once</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> emitter.<span class="hljs-title function_">once</span>(...args),  <span class="hljs-attr">$off</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> emitter.<span class="hljs-title function_">off</span>(...args),  <span class="hljs-attr">$emit</span>: <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> emitter.<span class="hljs-title function_">emit</span>(...args)&#125;</code></pre></div><h3 id="26-filters"><a href="#26-filters" class="headerlink" title="26.filters"></a>26.filters</h3><p>vue3.x移除了过滤器，可以使用methods和computed来替代</p><p>全局的过滤器可以使用如下方式来在vue3中定义</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$filters</span> = &#123;  <span class="hljs-title function_">currencyUSD</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;$&#x27;</span> + value  &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Bank Account Balance<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; $filters.currencyUSD(accountBalance) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>&lt;/template&gt;</code></pre></div><h3 id="27-删除了inline-template"><a href="#27-删除了inline-template" class="headerlink" title="27.删除了inline-template"></a>27.删除了inline-template</h3><h3 id="28-删除了-children"><a href="#28-删除了-children" class="headerlink" title="28.删除了$children"></a>28.删除了$children</h3><p>vue2.x可以使用$children来访问直接子组件，vue3.x使用refs来替代就可以了</p><h3 id="29-自定义指令"><a href="#29-自定义指令" class="headerlink" title="29.自定义指令"></a>29.自定义指令</h3><p>指令的钩子函数已经重新命名，更好的和组件的生命周期配合，此外，<code>expression</code>字符串不再作为<code>binding</code>对象的一部分传递</p><p>vue2.x中的directive的可选项</p><p>bind  指令只绑定一次到元素中</p><p>inserted  元素只被插入父元素中一次</p><p>update  该hook表示当元素更新时，children还没有更新</p><p>componentUpdated  表示组件和子元素都更新完毕</p><p>unbind 表示解绑</p><p>vue2.x的自定义指令</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-highlight</span>=<span class="hljs-string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>Highlight this text bright yellow<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java">Vue.directive(<span class="hljs-string">&#x27;highlight&#x27;</span>, &#123;  bind(el, binding, vnode) &#123;    el.style.background = binding.value  &#125;&#125;)</code></pre></div><p>vue3.x中新增了created    这个声明周期是在元素的属性和事件被应用之前</p><p>bind -&gt;beforeMount</p><p>inserted -&gt;mounted</p><p>beforeUpdate 类似于组件的beforeUpdate</p><p>update被移除</p><p>componentUpdated → <strong>updated</strong></p><p><strong>beforeUnmount</strong>: new! Similar to component lifecycle hooks, this will be called right before an element is unmounted</p><p>unbind -&gt; <strong>unmounted</strong></p><div class="code-wrapper"><pre><code class="hljs html">const MyDirective = &#123;  created(el, binding, vnode, prevVnode) &#123;&#125;, // new  beforeMount() &#123;&#125;,  mounted() &#123;&#125;,  beforeUpdate() &#123;&#125;, // new  updated() &#123;&#125;,  beforeUnmount() &#123;&#125;, // new  unmounted() &#123;&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-highlight</span>=<span class="hljs-string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>Highlight this text bright yellow<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs html">const app = Vue.createApp(&#123;&#125;)app.directive(&#x27;highlight&#x27;, &#123;  beforeMount(el, binding, vnode) &#123;    el.style.background = binding.value  &#125;&#125;)</code></pre></div><h3 id="30-data-option"><a href="#30-data-option" class="headerlink" title="30.data option"></a>30.data option</h3><p>vue2.x中还可以使用对象作为data的值。vue3.x不可以使用对象作为data,必须使用function</p><h3 id="31-元素的挂载"><a href="#31-元素的挂载" class="headerlink" title="31.元素的挂载"></a>31.元素的挂载</h3><p>在vue2.x中当挂载的元素是一个templayte的时候，渲染的内容会替换掉需要挂载的元素，在vue3.x中，需要被渲染的内容会添加到元素的children中，替代元素的innerHTML</p><p>vue2.x中</p><div class="code-wrapper"><pre><code class="hljs html">new Vue(&#123;  el: &#x27;#app&#x27;,  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  `&#125;)// orconst app = new Vue(&#123;  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  `&#125;)app.$mount(&#x27;#app&#x27;)</code></pre></div><p>挂载到对应的元素上</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    Some app content  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>最终渲染的效果</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>Hello Vue!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>vue3.x中的效果</p><div class="code-wrapper"><pre><code class="hljs html">const app = Vue.createApp(&#123;  data() &#123;    return &#123;      message: &#x27;Hello Vue!&#x27;    &#125;  &#125;,  template: `    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  `&#125;)app.mount(&#x27;#app&#x27;)</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">data-v-app</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;rendered&quot;</span>&gt;</span>Hello Vue!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h3 id="32-transition的变化"><a href="#32-transition的变化" class="headerlink" title="32.transition的变化"></a>32.transition的变化</h3><p>.v-enter已被替换成.v-enter-from</p><h3 id="33-vNode-生命周期事件"><a href="#33-vNode-生命周期事件" class="headerlink" title="33.vNode 生命周期事件"></a>33.vNode 生命周期事件</h3><p>在vue2.x中，可以使用事件来监听组件生命周期处于哪个阶段，这些事件的前缀是hook:,在 Vue 3 中，此前缀已更改为<code>vue:</code>. 此外，这些事件现在可用于 HTML 元素和组件</p><p>vue2.x </p><p>hook:后面跟的是生命周期函数的名称</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> @<span class="hljs-attr">hook:updated</span>=<span class="hljs-string">&quot;onUpdated&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p>vue3.x中</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> @<span class="hljs-attr">vue:updated</span>=<span class="hljs-string">&quot;onUpdated&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><h3 id="34-数组的监听"><a href="#34-数组的监听" class="headerlink" title="34.数组的监听"></a>34.数组的监听</h3><p>vue3.x中，数组的监听需要加上deep</p><div class="code-wrapper"><pre><code class="hljs html">watch: &#123;  bookList: &#123;    handler(val, oldVal) &#123;      console.log(&#x27;book list changed&#x27;)    &#125;,    deep: true  &#125;,&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>typescript笔记</title>
    <link href="/2022/08/05/typescript%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/05/typescript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="1-在定义一个变量时，基本数据类型可以用类型推断，不用定义类型"><a href="#1-在定义一个变量时，基本数据类型可以用类型推断，不用定义类型" class="headerlink" title="1.在定义一个变量时，基本数据类型可以用类型推断，不用定义类型"></a>1.在定义一个变量时，基本数据类型可以用类型推断，不用定义类型</h4><div class="code-wrapper"><pre><code class="hljs abnf">let msg <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello there!&quot;</span><span class="hljs-comment">;</span></code></pre></div><h4 id="2-ts的常用的数据类型"><a href="#2-ts的常用的数据类型" class="headerlink" title="2.ts的常用的数据类型"></a>2.ts的常用的数据类型</h4><div class="code-wrapper"><pre><code class="hljs pgsql">string,number,<span class="hljs-type">boolean</span>,arrays,<span class="hljs-keyword">any</span>,<span class="hljs-keyword">function</span>,<span class="hljs-keyword">object</span>,<span class="hljs-keyword">union</span> <span class="hljs-keyword">type</span>,<span class="hljs-keyword">Type</span> Aliases,Interfaces，<span class="hljs-keyword">Type</span> Assertions，<span class="hljs-type">bigint</span>，symbol,<span class="hljs-keyword">Type</span> Assertions,.Literal <span class="hljs-keyword">Types</span>,Enums ,<span class="hljs-keyword">null</span>,undefined,<span class="hljs-keyword">any</span>,<span class="hljs-type">unknown</span>,<span class="hljs-type">void</span>,never ,Tuple</code></pre></div><h4 id="3-interface和type-aliases的区别"><a href="#3-interface和type-aliases的区别" class="headerlink" title="3.interface和type aliases的区别"></a>3.interface和type aliases的区别</h4><div class="code-wrapper"><pre><code class="hljs typescript">实现继承的方式不同<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bear</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-attr">honey</span>: <span class="hljs-built_in">boolean</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">Animal</span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">Bear</span> = <span class="hljs-title class_">Animal</span> &amp; &#123;   <span class="hljs-attr">honey</span>: <span class="hljs-built_in">boolean</span> &#125;添加新的字段<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Window</span> &#123;  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Window</span> &#123;  <span class="hljs-attr">ts</span>: <span class="hljs-title class_">TypeScriptAPI</span>&#125;类型别名不能够修改已经创建的字段<span class="hljs-keyword">type</span> <span class="hljs-title class_">Window</span> = &#123;  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">Window</span> = &#123;  <span class="hljs-attr">ts</span>: <span class="hljs-title class_">TypeScriptAPI</span>&#125; <span class="hljs-comment">// Error: Duplicate identifier &#x27;Window&#x27;.</span><span class="hljs-keyword">const</span> src = <span class="hljs-string">&#x27;const a = &quot;Hello World&quot;&#x27;</span>;<span class="hljs-variable language_">window</span>.<span class="hljs-property">ts</span>.<span class="hljs-title function_">transpileModule</span>(src, &#123;&#125;);接口只能声明对象，不能够重命名原语类型别名不能够声明合并，但是接口可以如果是定义非对象类型，通常推荐使用<span class="hljs-keyword">type</span>如果是定义对象类型，那么他们是有区别的：<span class="hljs-keyword">interface</span> 可以重复的对某个接口来定义属性和方法；而type定义的是别名，别名是不能重复的</code></pre></div><h4 id="4-Type-Assertions类型断言"><a href="#4-Type-Assertions类型断言" class="headerlink" title="4.Type Assertions类型断言"></a>4.Type Assertions类型断言</h4><div class="code-wrapper"><pre><code class="hljs nim"><span class="hljs-type">TypeScript</span> 只允许类型断言转换为更具体或更不具体的类型版本，而不可以转成没有关系的类型<span class="hljs-keyword">const</span> a = (<span class="hljs-type">expr</span> <span class="hljs-keyword">as</span> <span class="hljs-type">any</span>) <span class="hljs-keyword">as</span> T;  可以将两种不相关的类型进行转换时，要进行两次断言，先断雁城<span class="hljs-type">any</span>或者unknown</code></pre></div><h4 id="5-Literal-Types-文本类型"><a href="#5-Literal-Types-文本类型" class="headerlink" title="5.Literal Types 文本类型"></a>5.Literal Types 文本类型</h4><div class="code-wrapper"><pre><code class="hljs reasonml">const constantString = <span class="hljs-string">&quot;Hello World&quot;</span>;<span class="hljs-comment">//使用const定义的常量类型</span><span class="hljs-keyword">function</span> print<span class="hljs-constructor">Text(<span class="hljs-params">s</span>: <span class="hljs-params">string</span>, <span class="hljs-params">alignment</span>: <span class="hljs-string">&quot;left&quot;</span> | <span class="hljs-string">&quot;right&quot;</span> | <span class="hljs-string">&quot;center&quot;</span>)</span> &#123;  <span class="hljs-comment">// ...</span>&#125;您可以使用 <span class="hljs-keyword">as</span> const 将整个对象转换为类型文字：const req = &#123; url: <span class="hljs-string">&quot;https://example.com&quot;</span>, <span class="hljs-keyword">method</span>: <span class="hljs-string">&quot;GET&quot;</span> &#125; <span class="hljs-keyword">as</span> const;handle<span class="hljs-constructor">Request(<span class="hljs-params">req</span>.<span class="hljs-params">url</span>, <span class="hljs-params">req</span>.<span class="hljs-params">method</span>)</span>;</code></pre></div><h4 id="6-Enums-枚举"><a href="#6-Enums-枚举" class="headerlink" title="6.Enums 枚举"></a>6.Enums 枚举</h4><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// 定义枚举类型</span><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;  <span class="hljs-variable constant_">LEFT</span>,  <span class="hljs-variable constant_">RIGHT</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-attr">d1</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">LEFT</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">turnDirection</span>(<span class="hljs-params">direction: Direction</span>) &#123;  <span class="hljs-keyword">switch</span>(direction) &#123;    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Direction</span>.<span class="hljs-property">LEFT</span>:      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;角色向左移动一个格子&quot;</span>)      <span class="hljs-keyword">break</span>    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Direction</span>.<span class="hljs-property">RIGHT</span>:      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;角色向右移动一个格子&quot;</span>)      <span class="hljs-keyword">break</span>  &#125;&#125;<span class="hljs-comment">// 监听键盘的点击</span><span class="hljs-title function_">turnDirection</span>(<span class="hljs-title class_">Direction</span>.<span class="hljs-property">LEFT</span>)<span class="hljs-keyword">export</span> &#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;  <span class="hljs-variable constant_">LEFT</span> = <span class="hljs-string">&quot;LEFT&quot;</span>,  <span class="hljs-variable constant_">RIGHT</span> = <span class="hljs-string">&quot;RIGHT&quot;</span>&#125;<span class="hljs-keyword">enum</span> <span class="hljs-title class_">Operation</span> &#123;  <span class="hljs-title class_">Read</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,<span class="hljs-comment">//位运算符</span>  <span class="hljs-title class_">Write</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,  foo = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-attr">d1</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-title class_">Direction</span>.<span class="hljs-property">LEFT</span></code></pre></div><h4 id="7-ts的运行环境"><a href="#7-ts的运行环境" class="headerlink" title="7.ts的运行环境"></a>7.ts的运行环境</h4><div class="code-wrapper"><pre><code class="hljs crmsh">方式一：tsc math.ts   <span class="hljs-keyword">node</span> <span class="hljs-title">math</span>.js  这种方式会比较麻烦方式二：webpack中配置本地的运行环境  使用ts-loader方式三：使用ts-<span class="hljs-keyword">node</span><span class="hljs-title">npm</span> install ts-<span class="hljs-keyword">node</span> <span class="hljs-title">-g</span>npm install tslib @types/<span class="hljs-keyword">node</span> <span class="hljs-title">-g</span>ts-<span class="hljs-keyword">node</span> <span class="hljs-title">math</span>.ts</code></pre></div><h4 id="8-unkonwn类型和any类型的区别"><a href="#8-unkonwn类型和any类型的区别" class="headerlink" title="8.unkonwn类型和any类型的区别"></a>8.unkonwn类型和any类型的区别</h4><p>任何类型都可以是any类型,ts不会对any类型的变量进行类型检测，任何类型也是可以赋值给unknown,但是使用这个变量必须进行类型检查，否则就会报错</p><p><img src="https://img1.imgtp.com/2022/08/05/Lt1elC2b.png" alt="QQ截图20220715095600.png"></p><h4 id="9-Tuple类型-元组"><a href="#9-Tuple类型-元组" class="headerlink" title="9.Tuple类型(元组)"></a>9.Tuple类型(元组)</h4><p>元组类型就是不同类型的数组的集合</p><p><img src="https://img1.imgtp.com/2022/08/05/PyfvKidj.png" alt="QQ截图20220715101013.png"></p><h4 id="10-Never类型"><a href="#10-Never类型" class="headerlink" title="10.Never类型"></a>10.Never类型</h4><h5 id="Never类型指永不存在的类型。-例如，never-类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型"><a href="#Never类型指永不存在的类型。-例如，never-类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型" class="headerlink" title="Never类型指永不存在的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型"></a>Never类型指永不存在的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</h5><h4 id="11-函数参数"><a href="#11-函数参数" class="headerlink" title="11.函数参数"></a>11.函数参数</h4><p><img src="https://img1.imgtp.com/2022/08/05/8e9QZ1fu.png" alt="QQ截图20220715111132.png"></p><h4 id="12-匿名函数的参数类型"><a href="#12-匿名函数的参数类型" class="headerlink" title="12.匿名函数的参数类型"></a>12.匿名函数的参数类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/UiMI6HEs.png" alt="QQ截图20220715111344.png"></p><h4 id="13-函数参数的对象类型"><a href="#13-函数参数的对象类型" class="headerlink" title="13.函数参数的对象类型"></a>13.函数参数的对象类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/Itu8eHI1.png" alt="QQ截图20220715112229.png"></p><h4 id="14-函数参数对象可选参数"><a href="#14-函数参数对象可选参数" class="headerlink" title="14.函数参数对象可选参数"></a>14.函数参数对象可选参数</h4><p><img src="https://img1.imgtp.com/2022/08/05/4knXfTJ1.png" alt="QQ截图20220715112745.png"></p><h4 id="15-联合类型"><a href="#15-联合类型" class="headerlink" title="15.联合类型"></a>15.联合类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/xI0aQEuD.png" alt="QQ截图20220715114922.png"></p><h4 id="16-一个参数一个可选类型的时候-它其实类似于是这个参数是-类型-undefined-的联合类型"><a href="#16-一个参数一个可选类型的时候-它其实类似于是这个参数是-类型-undefined-的联合类型" class="headerlink" title="16.一个参数一个可选类型的时候, 它其实类似于是这个参数是 类型|undefined 的联合类型"></a>16.一个参数一个可选类型的时候, 它其实类似于是这个参数是 类型|undefined 的联合类型</h4><h4 id="17-非空类型断言"><a href="#17-非空类型断言" class="headerlink" title="17.非空类型断言!"></a>17.非空类型断言!</h4><p><img src="https://img1.imgtp.com/2022/08/05/T6LzBxdD.png" alt="QQ截图20220715142334.png"></p><h4 id="18-可选链操作"><a href="#18-可选链操作" class="headerlink" title="18.可选链操作"></a>18.可选链操作</h4><p><img src="https://img1.imgtp.com/2022/08/05/TaGoHMzn.png" alt="QQ截图20220715151237.png"></p><h4 id="19-运算符"><a href="#19-运算符" class="headerlink" title="19.!!运算符"></a>19.!!运算符</h4><p>可以将其他数据类型转换成boolean</p><h4 id="20-操作符-空值合并操作符"><a href="#20-操作符-空值合并操作符" class="headerlink" title="20.??操作符  空值合并操作符"></a>20.??操作符  空值合并操作符</h4><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> messgae1 = <span class="hljs-string">&quot;1111&quot;</span>;<span class="hljs-keyword">const</span> content = messgae1 ?? <span class="hljs-string">&quot;你好&quot;</span>;如果message1是<span class="hljs-literal">null</span>或者<span class="hljs-literal">undefined</span>,content就会使用后面的值，message是空字符串不生效</code></pre></div><h4 id="21-类型缩小-Type-Narrowing"><a href="#21-类型缩小-Type-Narrowing" class="headerlink" title="21.类型缩小  Type Narrowing"></a>21.类型缩小  Type Narrowing</h4><p>类型缩小就是将例如联合类型进行精确到具体的类型</p><p>常见的类型保护有</p><p>typeof</p><p>===，！==</p><p>instanceof</p><p>in</p><p>…..</p><p><img src="https://img1.imgtp.com/2022/08/05/xmoxhxl5.png" alt="QQ截图20220716003305.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/DnVQP9fW.png" alt="QQ截图20220716003335.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/ECM7n6A2.png" alt="QQ截图20220716003417"></p><p><img src="https://img1.imgtp.com/2022/08/05/eDTnB12m.png" alt="QQ截图20220716003433"></p><p><img src="https://img1.imgtp.com/2022/08/05/s38SLBN0.png" alt="QQ截图20220716003446"></p><h4 id="22-函数类型定义"><a href="#22-函数类型定义" class="headerlink" title="22.函数类型定义"></a>22.函数类型定义</h4><p><img src="https://img1.imgtp.com/2022/08/05/E4FrxA0i.png"></p><h4 id="23-参数的可选类型"><a href="#23-参数的可选类型" class="headerlink" title="23.参数的可选类型"></a>23.参数的可选类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/5GU46enS.png"></p><h4 id="24-参数的默认值"><a href="#24-参数的默认值" class="headerlink" title="24.参数的默认值"></a>24.参数的默认值</h4><p><img src="https://img1.imgtp.com/2022/08/05/0pGV9IBH.png"></p><h4 id="25-剩余参数"><a href="#25-剩余参数" class="headerlink" title="25.剩余参数"></a>25.剩余参数</h4><p><img src="https://img1.imgtp.com/2022/08/05/b2Gi65SO.png"></p><h4 id="26-指定this的绑定"><a href="#26-指定this的绑定" class="headerlink" title="26.指定this的绑定"></a>26.指定this的绑定</h4><p><img src="https://img1.imgtp.com/2022/08/05/PLXzyda7.png"></p><h4 id="27-函数的重载"><a href="#27-函数的重载" class="headerlink" title="27.函数的重载"></a>27.函数的重载</h4><p>通过联合类型的有两个缺点：</p><p> 1.需要进行很多类型逻辑判断</p><p> 2.返回值类型不能判定</p><p><img src="https://img1.imgtp.com/2022/08/05/Xl0sI2DM.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/obc6YOcv.png"></p><h4 id="27-类的定义"><a href="#27-类的定义" class="headerlink" title="27.类的定义"></a>27.类的定义</h4><p><img src="https://img1.imgtp.com/2022/08/05/GQd3h5pF.png"></p><h4 id="28-类的继承"><a href="#28-类的继承" class="headerlink" title="28.类的继承"></a>28.类的继承</h4><p><img src="https://img1.imgtp.com/2022/08/05/NwBuKZH2.png"></p><h4 id="29-类的多态"><a href="#29-类的多态" class="headerlink" title="29.类的多态"></a>29.类的多态</h4><p><img src="https://img1.imgtp.com/2022/08/05/95zR2UQ2.png"></p><h4 id="30-类的成员修饰符"><a href="#30-类的成员修饰符" class="headerlink" title="30.类的成员修饰符"></a>30.类的成员修饰符</h4><p>private 修饰的属性和方法只能在该类内部使用</p><p>protected修饰的属性和方法只能在类本身及其子类内部使用</p><p>public是默认的成员修饰符，可以在外部，类，子类使用</p><p><img src="https://img1.imgtp.com/2022/08/05/Pw02xjP0.png"></p><h4 id="31-readonly修饰符"><a href="#31-readonly修饰符" class="headerlink" title="31.readonly修饰符"></a>31.readonly修饰符</h4><p><img src="https://img1.imgtp.com/2022/08/05/KrYErakm.png"></p><h4 id="32-访问器setter-getter"><a href="#32-访问器setter-getter" class="headerlink" title="32.访问器setter/getter"></a>32.访问器setter/getter</h4><p><img src="https://img1.imgtp.com/2022/08/05/eVx6dPgv.png"></p><h4 id="33-类的静态成员"><a href="#33-类的静态成员" class="headerlink" title="33.类的静态成员"></a>33.类的静态成员</h4><p><img src="https://img1.imgtp.com/2022/08/05/ESG5cMLo.png"></p><h4 id="34-抽象类abstract"><a href="#34-抽象类abstract" class="headerlink" title="34.抽象类abstract"></a>34.抽象类abstract</h4><p>什么是 抽象方法? 在TypeScript中没有具体实现的方法(没有方法体)，就是抽象方法</p><p>抽象方法，必须存在于抽象类中</p><p>抽象类是使用abstract声明的类</p><p><img src="https://img1.imgtp.com/2022/08/05/XmcOILgK.png"></p><h4 id="35-类本身也可以作为另外一变量的类型"><a href="#35-类本身也可以作为另外一变量的类型" class="headerlink" title="35.类本身也可以作为另外一变量的类型"></a>35.类本身也可以作为另外一变量的类型</h4><h4 id="36-接口的声明"><a href="#36-接口的声明" class="headerlink" title="36.接口的声明"></a>36.接口的声明</h4><p> <img src="https://img1.imgtp.com/2022/08/05/3ANVJqpG.png"></p><h4 id="37-接口的索引类型"><a href="#37-接口的索引类型" class="headerlink" title="37.接口的索引类型"></a>37.接口的索引类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/1pM1SZre.png"></p><h4 id="38-函数类型"><a href="#38-函数类型" class="headerlink" title="38.函数类型"></a>38.函数类型</h4><p>interface也可以定义函数，建议使用类型别名列定义函数</p><p><img src="https://img1.imgtp.com/2022/08/05/xVRVoVov.png"></p><h4 id="39-接口的继承"><a href="#39-接口的继承" class="headerlink" title="39.接口的继承"></a>39.接口的继承</h4><p><img src="https://img1.imgtp.com/2022/08/05/VlVrCRbV.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/gvacaNKp.png"></p><h4 id="40-交叉类型"><a href="#40-交叉类型" class="headerlink" title="40.交叉类型"></a>40.交叉类型</h4><p><img src="https://img1.imgtp.com/2022/08/05/kExwu85c.png"></p><h4 id="41-字面量赋值"><a href="#41-字面量赋值" class="headerlink" title="41.字面量赋值"></a>41.字面量赋值</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://img1.imgtp.com/2022/08/05/LVx7kzYn.png"></h4><p><img src="https://img1.imgtp.com/2022/08/05/UxFV3w0L.png" alt="QQ截图20220716171033.png"></p><h4 id="42-枚举类型"><a href="#42-枚举类型" class="headerlink" title="42.枚举类型"></a>42.枚举类型</h4><p>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型； </p><p>枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型</p><p><img src="https://img1.imgtp.com/2022/08/05/JUcGQCK2.png" alt="QQ截图20220716172406.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/i4HcVm8N.png" alt="QQ截图20220716172417.png"></p><h4 id="43-泛型"><a href="#43-泛型" class="headerlink" title="43.泛型"></a>43.泛型</h4><p><img src="https://img1.imgtp.com/2022/08/05/A6dtGWoy.png" alt="QQ截图20220717020140.png"></p><p><img src="https://img1.imgtp.com/2022/08/05/A6dtGWoy.png" alt="QQ截图20220717020140.png"></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title class_">Foo</span>&lt;T,E&gt;(<span class="hljs-attr">a</span>:T,<span class="hljs-attr">b</span>:E)&#123;&#125;</code></pre></div><p>还可以传入多个类型</p><p>常见范型的缩写</p><p>T：是type的缩写。代表类型</p><p>K,V:是key和value的缩写</p><p>E：是element的缩写</p><p>O：是Object的缩写</p><h4 id="44-泛型接口的定义"><a href="#44-泛型接口的定义" class="headerlink" title="44.泛型接口的定义"></a>44.泛型接口的定义</h4><p><img src="https://img1.imgtp.com/2022/08/05/2ZbKkBg2.png" alt="QQ截图20220717020609.png"></p><h4 id="45-泛型作为类"><a href="#45-泛型作为类" class="headerlink" title="45.泛型作为类"></a>45.泛型作为类</h4><p><img src="https://img1.imgtp.com/2022/08/05/c0ucka5e.png" alt="QQ截图20220717092242.png"></p><h4 id="46-泛型约束"><a href="#46-泛型约束" class="headerlink" title="46.泛型约束"></a>46.泛型约束</h4><p><img src="https://img1.imgtp.com/2022/08/05/A9jQ0E9R.png" alt="QQ截图20220717092443.png"></p><p>在范型参数使用约束</p><p><strong>举个栗子：我们希望获取一个对象给定属性名的值</strong></p><p>我们需要确保我们不会获取 obj 上不存在的属性；</p><p>所以我们在两个类型之间建立一个约束；</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 传入的key类型, obj当中key的其中之一</span>interface <span class="hljs-title class_">IKun</span> &#123;  <span class="hljs-attr">name</span>: string  <span class="hljs-attr">age</span>: number&#125;type <span class="hljs-title class_">IKunKeys</span> = keyof <span class="hljs-title class_">IKun</span> <span class="hljs-comment">// &quot;name&quot;|&quot;age&quot;</span><span class="hljs-comment">//keyof 可以获取key的联合类型</span><span class="hljs-keyword">function</span> getObjectProperty&lt;O, K <span class="hljs-keyword">extends</span> keyof O&gt;(<span class="hljs-attr">obj</span>: O, <span class="hljs-attr">key</span>: K)&#123;  <span class="hljs-keyword">return</span> obj[key]&#125;<span class="hljs-keyword">const</span> info = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>&#125;</code></pre></div><h4 id="47-映射类型（Mapped-Types）"><a href="#47-映射类型（Mapped-Types）" class="headerlink" title="47.映射类型（Mapped Types）"></a>47.<strong>映射类型（Mapped Types）</strong></h4><p><strong>有的时候，一个类型需要基于另外一个类型，但是你又不想拷贝一份，这个时候可以考虑使用映射类型</strong>，而且可以改变属性的特性，例如可以改变属性的readonly，是否可选</p><p>大部分内置的工具都是通过映射类型来实现的；</p><p>大多数类型体操的题目也是通过映射类型完成的</p><p><strong>映射类型建立在索引签名的语法上：</strong></p><p>映射类型，就是使用了 PropertyKeys 联合类型的泛型；</p><p>其中 PropertyKeys 多是通过 keyof 创建，然后循环遍历键名创建一个类型</p><div class="code-wrapper"><pre><code class="hljs tsx"><span class="hljs-comment">// TypeScript提供了映射类型: 函数</span><span class="hljs-comment">// 映射类型不能使用interface定义</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapPerson</span>&lt;<span class="hljs-title class_">Type</span>&gt; = &#123;  <span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Type</span>]?: <span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Property</span>]<span class="hljs-comment">//readonly可以将属性转成只读属性 ？可以转成可选属性</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>  <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>  <span class="hljs-attr">address</span>: <span class="hljs-built_in">string</span>&#125;<span class="hljs-keyword">type</span> <span class="hljs-title class_">IPersonOptional</span> = <span class="hljs-title class_">MapPerson</span>&lt;<span class="hljs-title class_">IPerson</span>&gt;<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">IPersonOptional</span> = &#123;&#125;</code></pre></div><h4 id="48-映射修饰符（Mapping-Modifiers）"><a href="#48-映射修饰符（Mapping-Modifiers）" class="headerlink" title="48.映射修饰符（Mapping Modifiers）"></a>48.<strong>映射修饰符（Mapping Modifiers）</strong></h4><p><strong>在使用映射类型时，有两个额外的修饰符可能会用到：</strong></p><p>一个是 readonly，用于设置属性只读；</p><p> 一个是 ? ，用于设置属性可选；</p><p><strong>你可以通过前缀 - 或者 + 删除或者添加这些修饰符，如果没有写前缀，相当于使用了 + 前缀</strong></p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapPerson</span>&lt;<span class="hljs-title class_">Type</span>&gt; = &#123;  -<span class="hljs-keyword">readonly</span> [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-title class_">Type</span>]-?: <span class="hljs-title class_">Type</span>[<span class="hljs-title class_">Property</span>]<span class="hljs-comment">//- 表示删除readonly和？+表示添加</span>&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>  age?: <span class="hljs-built_in">number</span>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>  address?: <span class="hljs-built_in">string</span>&#125;<span class="hljs-comment">// </span><span class="hljs-keyword">type</span> <span class="hljs-title class_">IPersonRequired</span> = <span class="hljs-title class_">MapPerson</span>&lt;<span class="hljs-title class_">IPerson</span>&gt;<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">IPersonRequired</span> = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,  <span class="hljs-attr">height</span>: <span class="hljs-number">1.88</span>,  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;广州市&quot;</span>&#125;</code></pre></div><h4 id="49-内置工具和类型体操"><a href="#49-内置工具和类型体操" class="headerlink" title="49.内置工具和类型体操"></a>49.<strong>内置工具和类型体操</strong></h4><p><strong>类型系统其实在很多语言里面都是有的，比如Java、Swift、C++等等，但是相对来说TypeScript的类型非常灵活：</strong></p><p> 这是因为TypeScript的目的是为JavaScript添加一套类型校验系统，因为JavaScript本身的灵活性，也让TypeScript类型系统</p><p>不得不增加更附加的功能以适配JavaScript的灵活性；</p><p> 所以TypeScript是一种可以支持类型编程的类型系统； </p><p>◼ <strong>这种类型编程系统为TypeScript增加了很大的灵活度，同时也增加了它的难度：</strong></p><p> 如果你不仅仅在开发业务的时候为自己的JavaScript代码增加上类型约束，那么基本不需要太多的类型编程能力；</p><p> 但是如果你在开发一些框架、库，或者通用性的工具，为了考虑各种适配的情况，就需要使用类型编程； </p><p>◼ <strong>TypeScript本身为我们提供了类型工具，帮助我们辅助进行类型转换（前面有用过关于this的类型工具）。</strong></p><p>◼ <strong>很多开发者为了进一步增强自己的TypeScript编程能力，还会专门去做一些类型体操的题目：</strong></p><p> <a href="https://github.com/type-challenges/type-challenges">https://github.com/type-challenges/type-challenges</a></p><p> <a href="https://ghaiklor.github.io/type-challenges-solutions/en/">https://ghaiklor.github.io/type-challenges-solutions/en/</a></p><p>◼ <strong>我们课堂上会学习TypeScript的编程能力的语法，并且通过学习内置工具来练习一些类型体操的题目</strong></p><h4 id="49-namespace"><a href="#49-namespace" class="headerlink" title="49.namespace"></a>49.namespace</h4><p><strong>命名空间不再建议使用，使用模块替代</strong></p><p>namespace会形成独立的空间，里面的内容需要使用export，外部才可以使用，否则外部无法访问</p><p><img src="https://img1.imgtp.com/2022/08/05/qr2xvkmZ.png" alt="QQ截图20220717174941.png"><br><img src="https://img1.imgtp.com/2022/08/05/Eq2OIARP.png" alt="QQ截图20220717175005.png"><br>48.命名空间的拆分</p><p>可以将命名空间的内容拆分到多个文件中</p><h4 id="50-d-ts文件-类型声明文件"><a href="#50-d-ts文件-类型声明文件" class="headerlink" title="50..d.ts文件  类型声明文件"></a>50..d.ts文件  类型声明文件</h4><p>它仅仅用来做类型检测，告知typescript我们有哪 些类型,他和普通的ts文件的区别是，他只能做类型盛名，不可以写业务代码，而且不需要使用export导出，他是全局的</p><p>那么typescript会在哪里查找我们的类型声明呢？</p><p>内置类型声明；</p><p>外部定义类型声明；</p><p>自己定义类型声明；</p><p>类型声明文件主要适用于外部类库，例如引入的npm包没有做类型声明，则需要自己写类型声明文件</p><h4 id="51-内置类型声明"><a href="#51-内置类型声明" class="headerlink" title="51.内置类型声明"></a>51.内置类型声明</h4><p>内置类型声明是typescript自带的、帮助我们内置了JavaScript运行时的一些标准化API的声明文件。包括比如Math、Date等内置类型，也包括DOM API，比如Window、Document等； 内置类型声明通常在我们安装typescript的环境中会带有的；</p><p><a href="https://github.com/microsoft/TypeScript/tree/main/lib">https://github.com/microsoft/TypeScript/tree/main/lib</a></p><p><strong>TypeScript 使用模式命名这些声明文件lib.[something].d.ts</strong></p><p><strong>内置声明的环境</strong></p><p><strong>我们可以通过target和lib来决定哪些内置类型声明是可以使用的：</strong></p><p>例如，startsWith字符串方法只能从称为ECMAScript 6的 JavaScript 版本开始使用；</p><p><strong>我们可以通过target的编译选项来配置：TypeScript通过lib根据您的target设置更改默认包含的文件来帮助解决此问题。</strong></p><p><a href="https://www.typescriptlang.org/tsconfig#lib">https://www.typescriptlang.org/tsconfig#lib</a></p><h4 id="52-外部定义类型声明和自定义声明"><a href="#52-外部定义类型声明和自定义声明" class="headerlink" title="52.外部定义类型声明和自定义声明"></a>52.外部定义类型声明和自定义声明</h4><p>外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明</p><p>这些库通常有两种类型声明方式：</p><p> 方式一：在自己库中进行类型声明（编写.d.ts文件），比如axios</p><p>方式二：通过社区的一个公有库DefinitelyTyped存放类型声明文件</p><p>该库的GitHub地址：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/">https://github.com/DefinitelyTyped/DefinitelyTyped/</a></p><p>该库查找声明安装方式的地址：<a href="https://www.typescriptlang.org/dt/search?search">https://www.typescriptlang.org/dt/search?search</a>=</p><p>比如我们安装react的类型声明： npm i @types/react –save-dev</p><p> 什么情况下需要自己来定义声明文件呢？</p><p>情况一：我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</p><p>情况二：我们给自己的代码中声明一些类型，方便在其他地方直接进行使用；</p><p>​                原则上所有类型声明都可以写在.d.ts文件上，一般建议在d.ts文件中定义全局的变量，函数，文件类型声明，或者类</p><p>例如在全局定义变量</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>TSDemo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js</span></span><span class="hljs-string"><span class="hljs-tag">  &quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">const</span> whyName = <span class="hljs-string">&quot;why&quot;</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> whyAge = <span class="hljs-number">18</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> whyHeight = <span class="hljs-number">1.88</span></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">bar</span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>在ts文件下访问的时候报错，找不到这个变量或者函数，需要在.d.ts文件中声明变量</p><div class="code-wrapper"><pre><code class="hljs ts"><span class="hljs-comment">//第三方库使用js编写的文件，在ts中使用的时候需要自己声明这个库，例如如下这种声明方式</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;lodash&quot;</span> &#123;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">join</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-built_in">any</span>&#125;<span class="hljs-comment">// 为自己的 变量/函数/类 定义类型声明</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">whyName</span>: <span class="hljs-built_in">string</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">whyAge</span>: <span class="hljs-built_in">number</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">whyHeight</span>: <span class="hljs-built_in">number</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">bar: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">public</span> age: <span class="hljs-built_in">number</span></span>)&#125;<span class="hljs-comment">// 作为一个第三方库为其他开发者提供类型声明文件 .d.ts =&gt; axios.d.ts</span><span class="hljs-comment">// 声明文件模块，引入某些模块的时候，ts不支持这些模块，所以需要声明</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.png&quot;</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.jpg&quot;</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.jpeg&quot;</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.svg&quot;</span><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;*.vue&quot;</span><span class="hljs-comment">//当使用cdn的方式引入一个包的时候</span><span class="hljs-comment">//一种方式 声明成模块(不合适)因为没有导入</span><span class="hljs-comment">// 另一种方式 声明命名空间</span><span class="hljs-comment">//例如声明jquery&#x27;</span><span class="hljs-keyword">declare</span> <span class="hljs-keyword">namespace</span> $ &#123;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">settings: <span class="hljs-built_in">any</span></span>): <span class="hljs-built_in">any</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>typescript</category>
      
      <category>note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试问题记录</title>
    <link href="/2022/08/04/interview02/"/>
    <url>/2022/08/04/interview02/</url>
    
    <content type="html"><![CDATA[<h3 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h3><h3 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h3><h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别"></a>请描述一下 <code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别</h3><h3 id="WEB标准以及W3C标准是什么"><a href="#WEB标准以及W3C标准是什么" class="headerlink" title="WEB标准以及W3C标准是什么"></a>WEB标准以及W3C标准是什么</h3><h3 id="HTTP-request报文结构是怎样的"><a href="#HTTP-request报文结构是怎样的" class="headerlink" title="HTTP request报文结构是怎样的"></a>HTTP request报文结构是怎样的</h3><h3 id="HTTP-response报文结构是怎样的"><a href="#HTTP-response报文结构是怎样的" class="headerlink" title="HTTP response报文结构是怎样的"></a>HTTP response报文结构是怎样的</h3><h3 id="如何垂直居中一个浮动元素"><a href="#如何垂直居中一个浮动元素" class="headerlink" title="如何垂直居中一个浮动元素"></a>如何垂直居中一个浮动元素</h3><h3 id="css中可以让文字在垂直和水平方向上重叠的两个属性是什么"><a href="#css中可以让文字在垂直和水平方向上重叠的两个属性是什么" class="headerlink" title="css中可以让文字在垂直和水平方向上重叠的两个属性是什么"></a>css中可以让文字在垂直和水平方向上重叠的两个属性是什么</h3><p>面试总结</p><p>css动画</p><p>从左上角到右下角</p><p>jsonp如何实现跨域</p><p>tcp三次握手四次挥手</p><p>正则表达式</p><p>首屏加载优化</p><p>promise实现</p><p>promise.all实现</p><p>并发多条请求，等所有成功后在响应</p><p>自己做过哪些缓存</p><p>eventBus</p><p>如何实现跨域</p><p>设计模式</p><p>中英文切换：前端国际化</p><p>自己webpack搭建项目</p><p>哪些数据需要缓存</p><p>前端数据可视化</p><p>vue-cli搭建</p><p>vue3了解</p><p>数据请求接口拦截</p><p>有没有做过重构</p><p>v-for和v-show区别</p><p>v-for为什么不可以和v-if一起用</p><p>自定义命令v-**有没有用过，设置优先级</p><p>用过哪些缓存</p><p>$nexttrick使用场景</p><p>用过哪些钩子函数</p><p>visual Dom</p><p>vue中router实现原理</p><p>如何减少回流重绘</p><p>用过哪些设计模式，前端模块分层 ts中有进行模块的分层</p><p>v-model和sync区别</p><p>浏览器渲染线程是异步还是同步的</p><p>vue中加载外部js文件和vue中js的执行顺序</p><p>vue中如何进行跨多个组件传递信息</p><p>移动端安卓和ios的兼容性问题，pc端兼容性问题</p><p>页面嵌入到app中如何区分是是外部页面还是app页面</p><h5 id="http2-http3的区别"><a href="#http2-http3的区别" class="headerlink" title="http2/http3的区别"></a>http2/http3的区别</h5><h5 id="一百万条数据中查询一条数据"><a href="#一百万条数据中查询一条数据" class="headerlink" title="一百万条数据中查询一条数据"></a>一百万条数据中查询一条数据</h5><h5 id="如何根据电脑系统的亮度来调整background"><a href="#如何根据电脑系统的亮度来调整background" class="headerlink" title="如何根据电脑系统的亮度来调整background"></a>如何根据电脑系统的亮度来调整background</h5><h5 id="如果出现页面出现大面积空白解决方案"><a href="#如果出现页面出现大面积空白解决方案" class="headerlink" title="如果出现页面出现大面积空白解决方案"></a>如果出现页面出现大面积空白解决方案</h5><h5 id="scroll-behavior的值，及其作用"><a href="#scroll-behavior的值，及其作用" class="headerlink" title="scroll-behavior的值，及其作用"></a>scroll-behavior的值，及其作用</h5><h5 id="DOCTYPE的作用"><a href="#DOCTYPE的作用" class="headerlink" title="DOCTYPE的作用"></a>DOCTYPE的作用</h5><h5 id="JS如何上传多张png格式的图片"><a href="#JS如何上传多张png格式的图片" class="headerlink" title="JS如何上传多张png格式的图片"></a>JS如何上传多张png格式的图片</h5>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客网收集面试题答案</title>
    <link href="/2022/08/04/interview01/"/>
    <url>/2022/08/04/interview01/</url>
    
    <content type="html"><![CDATA[<h4 id="1-说一说cookie-sessionStorage-localStorage-区别？"><a href="#1-说一说cookie-sessionStorage-localStorage-区别？" class="headerlink" title="1.说一说cookie sessionStorage localStorage 区别？"></a>1.说一说cookie sessionStorage localStorage 区别？</h4><p><strong>我的回答：</strong>cookie的大小只有4k,cookie是在浏览器中存储的，分为两种，内存cookie和硬盘cookie,默认的cookie就是内存cookie,没有设置过期时间，默认情况下就是浏览器关闭，cookie就会被浏览器删除，硬盘cookie是有设置过期时间，在过期时间之前，浏览器关闭，cookie不会被删除。把过期时间设置为负数或者0，可以删除cookie。</p><p>sessionStorage和localStorage不会自动存储，需要手动的存储数据，存储的数据量会比cookie大。sessionStorage只会在本次会话中存储，不会在新的页面中被获取。localStorage在页面关闭并且重新打开时不会被清除，sessionStorage会被清除。在页面内发生跳转不打开新的页面的时候，sessionStorage和localstorage不会被删除，在页面中跳转打开新的页面的时候，sessionStorage不保存，localstorage会保存</p><p><strong>参考答案：</strong>得分点 数据存储位置，生命周期，存储大小，写入方式，数据共享，发送请求是否携带，应用场景。相同点Cookie,SessionStorage，LocalStorage都是存储在浏览器本地的，不同点，cookie默认是浏览器关闭时候会被删除，可以设置过期时间，在过期时间内浏览器关闭，cookie不会删除。cookie一般是由服务端写入的，SessionStorage和LocalStorage是在客户端写入的，cookie的生命周期是由服务端设置好的，而LocalStorage是永远存在的，如果没有手动删除。SessionStorage页面关闭会被清除。sessionStorage只会在本次会话中存储，不会在新的页面中被获取，页面内发生跳转不打开新的页面时候，sessionStorage不会被清除，cookie的存储大小为4k,sessionStorage和localStorage存储大小为5M。cookie，sessionStorage,localStorage数据共享都是遵循同源策略原则，SessionStorage还必须限制在同一个页面。前端向后端发送数据的时候，cookie会自动携带，而localStorage和sessionStorage中的数据必须手动添加。应用场景：cookie可以存储登录的验证信息SessionId和token,localStorage通常存储不易变动的数据来减轻服务器的压力，SessionStorage可以用来检测用户是否刷新进入页面，像音乐播放器恢复播放进度条的功能</p><h4 id="2-说一说JS数据类型有哪些-区别是什么？"><a href="#2-说一说JS数据类型有哪些-区别是什么？" class="headerlink" title="2.说一说JS数据类型有哪些,区别是什么？"></a>2.说一说JS数据类型有哪些,区别是什么？</h4><p>数据类型有Null,undefined,Boolean,Number.String,Symbol,Bigint,Object8种数据类型</p><p>基本数据类型有null,undefined,boolean,number,string,symbol,bigint,引用数据类型包括普通的object，数组，正则，Date对象，Math内置对象，Function对象，包括ES6新增的Map和Set对象</p><p>基本数据类型是存储在栈中，引用数据类型存储在堆中的，引用数据类型在栈中存储了指针，该指针指向存储数据所在的堆内存的起始地址。</p><p>Symbol是ES6中新增的基本数据类型，可以产生一个独一无二的值，作为Object的key。Symbol创建的值具有唯一性，Symbol(key)!==Symbol(key),要获取对象中用symbol作为key的属性，必须通过Object.getOwnPropertySymbols(obj)</p><p>Bigint也是ES6新增的基本数据类型，来代表超出最大或者最小Number可以表示的值，不可以和Number混用</p><p>判断基本数据类型可以使用typeof 来判断，但是typeof null ===object typeof function===’function’</p><p>无法判断其他引用数据类型，必须使用instanceof来判断</p><h4 id="3-说一说你对闭包的理解？"><a href="#3-说一说你对闭包的理解？" class="headerlink" title="3.说一说你对闭包的理解？"></a>3.说一说你对闭包的理解？</h4><p>闭包就是内部函数访问外部环境的自由变量，外部变量可以引用另一个函数的内部函数，通过这个内部函数的引用来访问他的上层作用域，如果这个外部变量依然引用着这个函数，所以不会被垃圾回收器回收，而导致内存泄露。闭包可以模仿块级作用域，能够实现函数柯里化，在构造函数中使用特权方法，Vue中数据响应式Observer使用了闭包</p><h4 id="4-说一说promise是什么与使用方法？"><a href="#4-说一说promise是什么与使用方法？" class="headerlink" title="4.说一说promise是什么与使用方法？"></a>4.说一说promise是什么与使用方法？</h4><p>Promise是异步微任务，new Promise是同步执行，new Promise().then()是异步的，promise解决了异步多层嵌套回调，造成回调地狱的问题，让代码的可读性增加，更加容易维护。</p><p>promise的使用：通过new Promise()创建一个实例，传入一个包含resolve,reject作为参数的函调函数，执行成功是使用resolve(),执行失败是使用reject,promsie有三种状态，padding ,rejected,fulfilled,当状态发生改变的时候，就不会再更改，所以fulfilled状态执行resolve，rejected状态执行reject,然后会调用实例方法then(),then是异步调用，有两个回调函数，第一个是成功的回调，另外一个是失败的回调，失败的回调也可以链式调用使用catch传入失败的回调，promise.finally()不管成功还是失败都会执行，promsie中的类方法，Promsie.resolve()转换成fulfilled状态，并将参数传给then,Promise.reject()转换从rejected状态，并将给定的失败的信息传递给catch,any()方法会传入一个promise数组，只要有一个promise为fulfilled状态，则any也是fulfilled,只有全部为rejected则为rejected,allSettled()状态只有fulfilled状态，race()谁先改变状态就是使用谁的状态,all()只有全部为fulfilled才是fulfilled，有一个为reject则为reject</p><h4 id="5-说一说跨域是什么？如何解决跨域问题？"><a href="#5-说一说跨域是什么？如何解决跨域问题？" class="headerlink" title="5.说一说跨域是什么？如何解决跨域问题？"></a>5.说一说跨域是什么？如何解决跨域问题？</h4><p>由于同源策略，当出现请求页面的地址和当前页面地址协议，域名，端口号有一个不一致就会出现跨域。</p><p>解决跨域的方法</p><p>使用jsonp进行请求数据，并且通过回调函数来携带返回的数据</p><p>cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。<br>res.setHeader(‘Access-Control-Allow-Origin’, ‘*’);<br>res.setHeader(“Access-Control-Allow-Methods”, “GET, PUT, OPTIONS, POST”);</p><p>node中间件、nginx反向代理：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制</p><p>JSONP：利用的原理是script标签可以跨域请求资源，将回调函数作为参数拼接在url中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成javascript。</p><p>postmessage：H5新增API，通过发送和接收API实现跨域通信。</p><p>webpack中配置devServer中的proxy实现跨域</p><h4 id="6-说一说BFC"><a href="#6-说一说BFC" class="headerlink" title="6.说一说BFC"></a>6.说一说BFC</h4><p>BFC就是块级格式化上下文。他会形成一块独立的区域，不会影响边界以外的元素</p><p>BFC产生的条件</p><ol><li>根元素</li><li>浮动元素（float:left/float:right）</li><li>绝对定位元素(position:absolute,fixed)</li><li>行内块元素 display:inline-block</li><li>表格单元格 display:table-cell 表格的单元格默认就是</li><li>匿名表格单元格元素</li><li>overflow计算值不是visible的块元素</li><li>display:flex/inline-flex的直接子元素</li><li>display:grid或者inline-grid的直接子元素</li><li>display:flow-root元素</li></ol><p>作用</p><p>​    解决同一个BFC相邻两个box的margin会折叠的问题</p><p>​    解决浮动高度塌陷的问题，可以实现清除浮动的效果。通常是overflow:hidden</p><p>​        解决高度塌陷要满足以下条件</p><p>​            浮动元素的父元素触发BFC，形成BFC</p><p>​            浮动元素的父元素的高度是auto</p><p>​    BFC的高度是auto的情况下，高度的计算</p><p>​            如果只有inline-level 是行高的顶部和底部的距离</p><p>​            如果是block-level,是由最顶层块的上边缘到最底层块的下边缘之间距离</p><p>​            如果有绝对定位元素，将忽略</p><p>​            如果有浮动元素，则会增加高度包含浮动元素的下边缘</p><h4 id="7-说一说Vuex是什么，每个属性是干嘛的，如何使用-？"><a href="#7-说一说Vuex是什么，每个属性是干嘛的，如何使用-？" class="headerlink" title="7.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？"></a>7.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？</h4><p>VueX是全局状态管理的工具。vuex的属性有state,getter,mutations,action,module，state属性用来存储公共管理的数据，mutations属性定义可以修改state中的数据，是同步修改的，所以不要在mutation中书写ajax代码，这样数据不可追踪，getters属性可以认为是定义store的计算属性。getter的返回值会根据他的依赖被缓存起来，且只有当他的依赖发生了改变才会被重新计算，action中进行异步操作，可以操作mutation来修改数据，mutation是修改数据的唯一方法。module可以将store分为多个模块，每个模块都有自己的mutation，state,getter,action,module。通过store.state可以获取state,可以用计算属性中的mapState,store.commit来提交mutation,可以使用mapMutation来映射多个mutation,store,dispatch来分发action,可以使用mapAction来映射多个action  ,获取getter可以使用store,getter,可以使用maGetter来映射多个getter</p><h4 id="8-说一说JavaScript有几种方法判断变量的类型？"><a href="#8-说一说JavaScript有几种方法判断变量的类型？" class="headerlink" title="8.说一说JavaScript有几种方法判断变量的类型？"></a>8.说一说JavaScript有几种方法判断变量的类型？</h4><p>typeof 可以用来判断基本数据类型  还可以判断Function ,其他引用数据类型都是返回Object,null也是返回object</p><p>constructor可以判断引用数据类型 就是判断instance.<strong>proto</strong>.constructor=Function</p><p>instanceOf也可以判断引用数据类型 单数不能判断基本数据类型，就是运用原型链，判断右边的原型是否在左边的原型链上</p><p>Object.prototype.toString.call也可以用来判断引用数据类型</p><h4 id="9-说一说样式优先级的规则是什么？"><a href="#9-说一说样式优先级的规则是什么？" class="headerlink" title="9.说一说样式优先级的规则是什么？"></a>9.说一说样式优先级的规则是什么？</h4><p>样式的优先级应该分为4大类</p><p>第一类 !important的优先级最高，无论是什么引用方式，什么选择器</p><p>第二类是引用方式  行内样式优先级高于嵌入样式和外部样式，如果嵌入样式和外部样式使用相同的选择器，则看他们谁后引入，被覆盖</p><p>第三类是选择器</p><p>id选择器&gt;类选择器，属性选择器，伪类选择器&gt;元素选择器，伪元素选择器&gt;通配符选择器</p><p>第四类是默认样式</p><p> important 10000<br> 内联选择器 1000<br> id选择器 100<br> 类选择器，属性选择器，伪类 10<br> 元素选择器，伪元素 1<br> 通配选择器  0</p><h4 id="10-说一说JS实现异步的方法？"><a href="#10-说一说JS实现异步的方法？" class="headerlink" title="10.说一说JS实现异步的方法？"></a>10.说一说JS实现异步的方法？</h4><p>得分点 回调函数、事件监听、setTimeout、Promise、生成器Generators/yield、async/await,</p><p>所有的异步代码都会在同步代码执行完后，从异步队列中取出依次执行。回调函数是最基本的异步函数，例如ajax请求，回调函数的有点是简单，容易理解和实现，缺点是不利于代码的阅读和理解，各个部分耦合度高，使得程序结构混乱，流程难以追踪(尤其是多个回调函数嵌套的情况，容易出现回调地狱)，而且每个任务只能指定一个回调函数，回调函数不能使用try..catch来捕获错误，不能直接·return  ,Promise包装了一个异步调用并且生成了一个promise实例，promise不经可以捕获错误，而且可以很好的解决回调地狱的问题，缺点是没办法取消promise,错误需要使用回调函数来捕获。generator函数是ES6提供的异步编程的解决方案，generator是一个状态机，封装了多个内部状态，可以暂停函数，yield可以暂停执行，next可以继续执行,每次返回都是yield的结果。优点是语义清晰，但是需要手动调用。async/await是基于Promises实现的，await会阻塞后面的代码的执行。如果多个异步代码没有依赖性却使用了await会降低性能</p><h4 id="11-说一说Vue2-0-双向绑定的原理与缺陷？"><a href="#11-说一说Vue2-0-双向绑定的原理与缺陷？" class="headerlink" title="11.说一说Vue2.0 双向绑定的原理与缺陷？"></a>11.说一说Vue2.0 双向绑定的原理与缺陷？</h4><p>Vue的响应式原理：采用数据劫持和发布者-订阅者模式相结合的方式，遍历对象中的属性使用Object.defineProperty劫持各个属性的getter和setter方法，在数据发生变化的时候，触发setter,进而调用对应的notify方法执行依赖该属性的函数，进而更新页面的DOM。读取该属性的时候会触发getter，使用Object.defineProperty不能够监听对象的新增属性和删除属性。不可以监听通过数组索引来修改数据，不能够修改length,而监听到变化</p><h4 id="12-说一说数组去重都有哪些方法？"><a href="#12-说一说数组去重都有哪些方法？" class="headerlink" title="12.说一说数组去重都有哪些方法？"></a>12.说一说数组去重都有哪些方法？</h4><p>方式一：使用new Set(arr)进行去重，然后再使用Array.from()或者扩展运算符转成数组</p><p>方式二:    使用filter+indexOf来去重</p><p>方式三:   使用双重for循环+splice来进行去重</p><p>方式四:   使用[]+indexOf来去重</p><p>方式五:   使用sort去重，先进行排序，然后再进行当前索引和下一个索引值进行比较，push进新的数组</p><p>方式六:   使用对象属性不能相同的特点去重，以数组每一个item作为object的key,通过for循环判断obj[arr[i]]是否存在，如果不存在则push,并且obj[arr[i]]=1,否则就是obj[arr[i]]++</p><p>方式七：使用includes来去重，可以区别Nan,可以判断新的数组中是否包含这个值，不包含就push</p><p>方式八：使用hasOwnProperty来去重</p><p>方式九：先进行排序，然后在进行递归，splices删除重复数据</p><p>方式十：使用Map数据结构来去重，通过has判断，如果为false就push，并且set值，</p><p>方式十一：使用reduce+includes来去重，判断pre中是否存在</p><h4 id="13-说一说null-和-undefined-的区别，如何让一个属性变为null"><a href="#13-说一说null-和-undefined-的区别，如何让一个属性变为null" class="headerlink" title="13.说一说null 和 undefined 的区别，如何让一个属性变为null"></a>13.说一说null 和 undefined 的区别，如何让一个属性变为null</h4><p><strong>得分点 操作的变量没有被赋值、全局对象的一个属性、函数没有return返回值、值 <code>null</code> 特指对象的值未设置 undefined == null、undefined !== null</strong> </p><p>一个变量定义了，但是没有进行初始化，那他的值就是undefined。函数没有指定return的值，默认就是undefined。对象中某个属性不存在就是undefined，函数定义了形参，但是没有定义默认参数，实参就是undefined,undefined可以通过typeof 来判断是否undefined,undefined==undefined,undefined===undefined。null就是对象的值未设置，一个对象没有设置指针地址就是null,null通过typeof判断类型是object,null==null,null===null,null==undefined,null!==undeined,undefined表示未设置值的默认状态，null表示手动设置为空对象，儿不是默认状态，在实际使用过程中，变量不需要手动的赋值undefined,如果需要手动的释放对象，可以赋值null,typeof会判断为object,是因为js数据类型在底层都是以二进制的形式表示的，二进制的前三位为0会被typeof判断为objet,而null的二进制全是0，当对象被赋值为0以后就会被垃圾回收器择机回收并且释放内存</p><h4 id="14-说一下浮动"><a href="#14-说一下浮动" class="headerlink" title="14.说一下浮动"></a>14.说一下浮动</h4><p>float属性可以指定一个元素向左或者向右浮动，浮动元素会脱离标准流</p><p>浮动规则一</p><p>​    元素一旦浮动后，脱离标准流</p><p>​            朝着向左或者向右方向移动，直到自己的边界紧贴者包含块(一般是父元素)或者其他浮动元素的边界为止</p><p>​            定位元素会层叠在浮动元素上面</p><p>浮动规则二</p><p>​    如果元素是向左或者向右浮动，浮动的元素的左右边界不能超过包含快的左右边界</p><p>浮动规则三</p><p>​    浮动元素之间不能够层叠，如果一个元素浮动，后面的元素会紧挨着前面的浮动元素排列，如果剩下的空间不够放下一个浮动元素则会向下移动，找到可以放下的空间</p><p>浮动规则四</p><p>​    浮动元素不能与行内级内容层叠，行内级内容会被推出去</p><p>浮动规则五</p><p>​    行内级元素，inline-block元素浮动后，其顶部将与所在行的顶部对齐</p><p>浮动的问题</p><p>​    由于浮动的元素脱离了标准流·，变成了脱标元素，所以不在向父元素汇报高度，父元素计算高度的时候不计算浮动元素的高度，所以会造成内容塌陷</p><p>解决高度塌陷的方法</p><p>​    方法一，给父元素设置固定高度。扩展性不好</p><p>​    方法二，给父元素最后添加一个空的块级元素，并且设置为clear:both。这样会增加无意义的空标签，维护麻烦，违反了结构与样式分离的原则</p><p>​    方式三，给父元素添加一个伪元素，::after,设置content:””,display:block，overflow:hidden,clear:both,visibility:hidden,height:0,   为了兼容IE6/7还要加上*zoom:1</p><h4 id="15-说一说es6中箭头函数？"><a href="#15-说一说es6中箭头函数？" class="headerlink" title="15.说一说es6中箭头函数？"></a>15.说一说es6中箭头函数？</h4><p>箭头函数中没有this,箭头函数中的this指向是由上层作用域的中非箭头函数this决定的，箭头函数中没有arguments,如果箭头函数中出现arguments，则由上层作用域非箭头函数的arguments决定，箭头函数中arguments可以使用rest参数替代，箭头函数不可以作为构造函数，没有super()和原型,箭头函数不可以使用call,apply,bind显示绑定来改变this的指向，箭头函数不可以作为generator函数。箭头函数不能作为事件绑定的回调函数，如果使用了this，该this不会指向触发事件的元素，而是指向window。箭头函数适用于需要引用上层作用域的this,可以替代var _this=this,或者没有使用到this的函数</p><h4 id="16-说一说call-apply-bind的作用和区别？"><a href="#16-说一说call-apply-bind的作用和区别？" class="headerlink" title="16.说一说call apply bind的作用和区别？"></a>16.说一说call apply bind的作用和区别？</h4><p>call,apply,bind可以显示进行this的绑定，call可以传多个参数，并且立即执行函数，apply第二个参数传的是函数，也是会立即执行，bind可以传多个参数，并且会返回新的函数，call,apply还可以用于函数的执行。call,apply可以用于对象的继承，将伪数组转成真数组，进行原型链方法的借调，等等，bind可以用于react中this的绑定</p><h4 id="17-说一说this指向（普通函数、箭头函数）？"><a href="#17-说一说this指向（普通函数、箭头函数）？" class="headerlink" title="17.说一说this指向（普通函数、箭头函数）？"></a>17.说一说this指向（普通函数、箭头函数）？</h4><p>默认绑定this是指向全局window，普通函数的调用</p><p>隐式绑定this是指向调用的对象，对象调用方法时</p><p>显示绑定this指向绑定的值</p><p>new绑定this指向新创建的对象</p><p>箭头函数中没有this,this是由上层作用域中非箭头函数决定的</p><p>在严格模式下，this默认是undefined</p><p>默认绑定的优先级最低</p><p>显示绑定的优先级高于隐式绑定</p><p>new绑定的优先级高于bind</p><p>new绑定优先级高于隐式绑定</p><p>bind的优先级高于call/apply</p><p>new不可以和call/apply一起使用</p><p>setTimeout中this默认指向window</p><p>事件绑定中this指向绑定的元素</p><h4 id="18-说一说CSS尺寸设置的单位"><a href="#18-说一说CSS尺寸设置的单位" class="headerlink" title="18.说一说CSS尺寸设置的单位"></a>18.说一说CSS尺寸设置的单位</h4><p>px是绝对长度单位，em,rem,vw/vh是相对长度单位</p><p>em是在font-size中默认使用相对于父元素的字体大小,如果自己定义了font-size,则根据自身的font-size进行定义，其他属性也是相对于自身的font-size,</p><h4 id="19-说一说HTML语义化？"><a href="#19-说一说HTML语义化？" class="headerlink" title="19.说一说HTML语义化？"></a>19.说一说HTML语义化？</h4><h4 id="20-说几个未知宽高元素水平垂直居中方法"><a href="#20-说几个未知宽高元素水平垂直居中方法" class="headerlink" title="20.说几个未知宽高元素水平垂直居中方法"></a>20.说几个未知宽高元素水平垂直居中方法</h4><h4 id="21-说一说JS变量提升？"><a href="#21-说一说JS变量提升？" class="headerlink" title="21.说一说JS变量提升？"></a>21.说一说JS变量提升？</h4><p>函数和var 声明的变量在代码编译阶段会提升到最前面，但此时var声明的变量还没有赋值，所以此时访问是undefined,而函数可以在函数定义之前被调用，因为函数是一等公民，函数声明的提升优先级会比变量提升高，let,const不会出现变量提升，let const在定义以前访问会出现暂时性死区</p><h4 id="22-说一说-HashRouter-和-HistoryRouter的区别和原理？"><a href="#22-说一说-HashRouter-和-HistoryRouter的区别和原理？" class="headerlink" title="22.说一说 HashRouter 和 HistoryRouter的区别和原理？"></a>22.说一说 HashRouter 和 HistoryRouter的区别和原理？</h4><p>HashRouter  和 HistoryRouter都是利用浏览器的两种特性来实现前端路由的，根据这两种特性，可以实现不需要刷新页面的去修改内容。HashRouter就是利用通过监听window.onhashchange根据location.hash的变化来修改Dom,url中hashRouter和historyRouter的不同是，hash会在url中有#这样的hash值，而history没有。historyRouter是根据h5新增的历史调用栈API来实现的，他有六种模式来改变url而不会重新刷新页面</p><p>history.replaceState():替换原来的路径</p><p>history.pushState() 使用新的路径</p><p>history.popState()  路径的回退</p><p>history.back() 向后改变路径</p><p>history.go() 跳转至那个路径</p><p>通过window.onpopState来监听浏览器的前进和后退，pushState和replaceState都是可以携带参数，hash可以兼容低版本的浏览器，如果想传递任意类型的数据到记录栈可以使用history,history需要后端配合，如果后端不配合，就会出现404，而hash不需要</p><h4 id="23-说一说map-和-forEach-的区别？"><a href="#23-说一说map-和-forEach-的区别？" class="headerlink" title="23.说一说map 和 forEach 的区别？"></a>23.说一说map 和 forEach 的区别？</h4><p>得分点 map创建新数组、map返回处理后的值、forEach()不修改原数组、forEach()方法返回undefined</p><p>map会返回新的数组，forEach不会修改原来的数组，map需要return foreach不需要return,foreach中return是无效的，map中this默认指向undefined,foreach中this默认指向window,forEach不能终端执行，只能够抛出异常来终止执行。forEach没有返回值新的数组所以不能够进行链式调用，map的处理数组比foreach快</p><h4 id="24-说一说事件循环Event-loop，宏任务与微任务？"><a href="#24-说一说事件循环Event-loop，宏任务与微任务？" class="headerlink" title="24.说一说事件循环Event loop，宏任务与微任务？"></a>24.说一说事件循环Event loop，宏任务与微任务？</h4><p>js代码执行过程中，同步代码先执行，要到定时器，就会先将定时器先挂起，继续向下执行，执行到异步代码，就会将异步代码进入事件队列，宏任务就会进入宏任务队列，微任务就是进入微任务事件队列，同步代码执行完后，就会从事件队列中取出异步代码，进入执行上下文调用栈，微任务先执行，执行完后在执行宏任务，等定时器到期之后也会加入到事件队列，就这样不断的循环往复执行，就是事件循环，事件循环包括浏览器的事件循环和Node的事件循环，浏览器的事件循环中宏任务包括定时器，ajax请求，window.postmessage,setImmediate,UI render,Dom监听，微任务包括promise的then回调，async/await,Mutation Obderver，queueMicrotask。Node的事件循环中微任务为process.nexttick,promise的then回调，queueMicrotask,宏任务队列包括，定时器，ID事件，setImmediate,close事件</p><h4 id="25-说一说Vue3-0-实现数据双向绑定的方法-？"><a href="#25-说一说Vue3-0-实现数据双向绑定的方法-？" class="headerlink" title="25.说一说Vue3.0 实现数据双向绑定的方法 ？"></a>25.说一说Vue3.0 实现数据双向绑定的方法 ？</h4><p>vue3中实现数据双向绑定采用new Proxy来替代Object.defineProperty实现，proxy可以监听整个对象，使用new proxy()将需要监听的对象作为参数传递，并且有13中拦截器，可以对对象以及函数进行监听，例如监听对象属性的getter,setter,delete操作,in操作，defineProperty操作等，可以解决object.defineproperty不可以监听对象属性的新增和删除操作，不可以监听数组通过索引赋值，和手动给length赋值等操作</p><h4 id="26-说一下Diff算法？"><a href="#26-说一下Diff算法？" class="headerlink" title="26.说一下Diff算法？"></a>26.说一下Diff算法？</h4><p>得分点 patch、patchVnode、updateChildren、vue优化时间复杂度为O(n) </p><p>diff算法中的比较过程，第一步：patch函数首先会对新旧节点进行比较，如果旧的节点存在且和新的节点类型不同，则会销毁旧的节点。如果旧节点存在，如果新旧节点类型相同时，然后对新的节点的类型进行判断，如果是文本节点，则直接替换成文本节点，如果是注释节点也是直接的插入。处理静态节点，处理fragment组件节点等，然后就是处理普通的Dom元素和组件节点等等，在处理普通元素的时候，他会先判断旧节点是否存在，不存在则直接挂在。否则调用patchElement函数。在执行patchElement的时候首先处理props的情况，先将新的节点的props全部挂载到el上，判断旧节点的props是否不需要在新的节点上，如果不需要，那么删除对应的属性。然后通过调用patchChildren来对比子元素，如果新的节点是一个字符串类型，则直接调用el.textContent=newChildren,如果新节点不是字符串类型，旧节点是字符串类型，那么直接遍历新的节点，挂载到el上，如果新旧节点都是数组，则会分为有key和没有key两种，有key则调用patchKeyedChildren方法，没有key则调用patchUnkeyedChildren方法。调用patchUnkeyedChildren方法时，会获取到长度最小的那个节点，for循环依次进行patch，patch完之后，剩下的节点，如果旧的长度大于新的，则移除这些节点，如果新的长度大于旧的长度则创建新的节点，如果有key则会调用patchKeyedChildren方法，首先节点会从头部开始比较，如果两个节点相同则会调用patch,并且i++,如果节点不同则会跳出循环，然后再从尾部进行比较，重复相同的步骤，并且e1–,e2–,如果i&gt;e1而且i&lt;e2,就是旧的节点遍历完了，依然有新的节点，则进行挂载，如果新的节点遍历完，旧的节点还有则移除旧的节点。对于剩下的未知的序列，就是无须的序列，首先会根据key建立map索引图， 遍历剩下的旧节点, 新旧对比, 移除不使用的旧节点，oldIndex = 0 是一个特殊值，表示新节点没有对应的旧节点。用于确定最长稳定子序列，建立新的vnode的key的位置在旧的vnode的映射，然后for遍历旧节点中还没有被对比的节点，如果该节点已经被patch过，则卸载掉，如果在旧的vnode中key存在，在获取相同的key在新vnode的位置，如果存在，则新节点在旧节点的映射中设置所以旧节点的索引位置，然后进行新旧节点的patch,如果在旧node中key不存在，试图定位一个相同类型的没有key的节点的位置，准备用这个替换成新的值，从新结点中找到类型相同，且在旧节点没有对应映射的节点，设置进去，如果在新的vnode中没有对应的映射，就是在新的vnode中不存在这个key了，就卸载掉</p><h4 id="27-说一说三栏布局的实现方案"><a href="#27-说一说三栏布局的实现方案" class="headerlink" title="27.说一说三栏布局的实现方案"></a>27.说一说三栏布局的实现方案</h4><p>圣杯布局，双飞翼布局</p><h4 id="28-说一下浏览器垃圾回收机制？"><a href="#28-说一下浏览器垃圾回收机制？" class="headerlink" title="28.说一下浏览器垃圾回收机制？"></a>28.说一下浏览器垃圾回收机制？</h4><h4 id="29-说一说-vue-的-keep-alive-？"><a href="#29-说一说-vue-的-keep-alive-？" class="headerlink" title="29.说一说 vue 的 keep-alive ？"></a>29.说一说 vue 的 keep-alive ？</h4><h4 id="30-CSRF攻击是什么？"><a href="#30-CSRF攻击是什么？" class="headerlink" title="30.CSRF攻击是什么？"></a>30.CSRF攻击是什么？</h4><h4 id="31-XSS攻击是什么？"><a href="#31-XSS攻击是什么？" class="headerlink" title="31.XSS攻击是什么？"></a>31.XSS攻击是什么？</h4><h4 id="32-说一说js继承的方法和优缺点？"><a href="#32-说一说js继承的方法和优缺点？" class="headerlink" title="32.说一说js继承的方法和优缺点？"></a>32.说一说js继承的方法和优缺点？</h4><h4 id="33-说一说defer和async区别？"><a href="#33-说一说defer和async区别？" class="headerlink" title="33.说一说defer和async区别？"></a>33.说一说defer和async区别？</h4><p>默认情况下浏览器下载完js代码会立即执行，如果js需要操作dom,则会阻塞页面的渲染，async属性可以使加载js文档和dom树的构建同时进行，当js加载完成，js代码执行，会阻塞html的渲染，defer会等到dom构建完成以后再加载js代码。</p><p>defer是js的下载和执行不阻塞DOM tree的构建，defer中的js代码执行的时候Dom构建完成，defer会在DomcontenLoad之后执行，多个设置defer的script会按顺序加载，defer仅适用于外部脚本，对script的内容会忽略。而async不能保证顺序执行，不会阻塞DOM渲染，不能保证DOMContentLoaded之前或者之后执行，async用于独立脚本执行，就是那些不需要依赖外部文件的脚本</p><p>加分项：阻塞的原因：由于js是可以操作dom的，如果在修改这些元素的时候同时渲染界面即js线程和ui线程同时运行，那么渲染线程前后获得的数据可能不一致，因此为了防止渲染出现不可以预测的效果，所以浏览器设置GUI渲染线程和js引擎为互斥的关系当浏览器执行js代码的时候渲染线程就会被保存在一个队列中，直到js程序执行完成才会接着执行。如果js执行事件过长，就会造成渲染界面过程不连贯，导致页面渲染加载阻塞的感觉</p><h4 id="34-说一下浏览器如何渲染页面的"><a href="#34-说一下浏览器如何渲染页面的" class="headerlink" title="34.说一下浏览器如何渲染页面的"></a>34.说一下浏览器如何渲染页面的</h4><p>浏览器首先会解析页面，把html构建成DOM树，css构建成cssom树，css的加载不会阻塞dom树的构建，然后将dom树和cssom树整合成render树，如果加载到script标签，会阻塞页面的渲染进程，所以需要把script放在底部，然后执行js代码，经过布局和绘制，最终渲染到屏幕上</p><h4 id="35-说一说vue-computed和watch的区别？"><a href="#35-说一说vue-computed和watch的区别？" class="headerlink" title="35.说一说vue computed和watch的区别？"></a>35.说一说vue computed和watch的区别？</h4><p>当需要依赖其他状态来产生新的状态的时候，可以使用computed,computed适用于计算比较多的场景。computed依赖于其他状态，computed是同步的，而且有缓存，如果依赖的状态没有发生变化，他不会重新计算，computed默认是调用getter方法，也可以修改数据调用setter方法，watch是作为侦听器，可以监听data，props,emit等属性的变化，也是有惰性的，watch在数据初始化的时候不会执行，只有在数据变化的时候才会执行，可以设置immediate:true来让watch立即执行一次，watch默认不能够监听对象的属性的变化，可以设置deep:true,对对象进行深度监听</p><h4 id="36-说一说-Vue-中-nextTick-作用与原理？"><a href="#36-说一说-Vue-中-nextTick-作用与原理？" class="headerlink" title="36.说一说 Vue 中 $nextTick 作用与原理？"></a>36.说一说 Vue 中 $nextTick 作用与原理？</h4><p>得分点 异步渲染、获取DOM、Promise </p><p>将回调延迟到下一次DOM更新循环之后执行，在修改数据之后立即执行它，然后等待DOM更新</p><p>ue更新DOM是异步执行的，在修改数据后，视图不会立刻更新，而是等待同一事件循环中所有数据变化之后，同意更新视图，所以修改完数据，立刻获得的是未修改的dom,nextTrick就可以在DOM更新之后执行回调函数，解决异步渲染不可以获取到更新之后的DOM的问题，nextTick会返回一个promise,所以可以使用async/await</p><p>应用场景：在钩子函数created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中</p><h4 id="37-说一说new会发生什么？"><a href="#37-说一说new会发生什么？" class="headerlink" title="37.说一说new会发生什么？"></a>37.说一说new会发生什么？</h4><ol><li>创建一个空对象</li><li>让这个空对象的[[prototype]]属性指向构造函数的prototype</li><li>让构造函数中的this指向新创建的对象</li><li>执行该构造函数</li><li>如果构造函数没有返回对象则返回新创建的对象</li></ol><h4 id="38-说一下token-能放在cookie中吗？"><a href="#38-说一下token-能放在cookie中吗？" class="headerlink" title="38.说一下token 能放在cookie中吗？"></a>38.说一下token 能放在cookie中吗？</h4><p>得分点 能、不设置cookie有效期、重新登录重写cookie覆盖原来的cookie </p><p>token一般用来判断用户是否登录，它内部包含的信息包括uid(用户唯一的身份标识)，time(当前的时间戳)，sign(签名，token的前几位是以哈希算法压缩成的一定长度地十六进制字符串)，token可以存放在cookie，token是否过期由后端决定，所以token存储在cookie中只要不设置cookie的过期时间就可以，如果token失效，只要返回固定状态表示token失效，需要重新登录，重新设置cookie中的token就可以了，</p><h4 id="39-说一下浏览器输入URL发生了什么？"><a href="#39-说一下浏览器输入URL发生了什么？" class="headerlink" title="39.说一下浏览器输入URL发生了什么？"></a>39.说一下浏览器输入URL发生了什么？</h4><h4 id="40-说一说组件通信的方式？"><a href="#40-说一说组件通信的方式？" class="headerlink" title="40.说一说组件通信的方式？"></a>40.说一说组件通信的方式？</h4><h4 id="41-说一说-v-if-和-v-show区别？"><a href="#41-说一说-v-if-和-v-show区别？" class="headerlink" title="41.说一说 v-if 和 v-show区别？"></a>41.说一说 v-if 和 v-show区别？</h4><p>v-if是条件渲染，是惰性的，只有在条件判断为true的时候才会渲染到页面中去，v-show相当于设置display来进行切换，所有v-if有更高的切换开销，v-show有更高的切换开销，如果需要频繁切换，需要使用v-show，v-else和template不可以用于v-show，v-show无论如何它的DOM实际上都是存在的，只是通过CSS来切换display属性，当v-if当条件为false时，其对应的元素不会渲染到DOM中</p><h4 id="42-React生命周期的各个阶段是什么？"><a href="#42-React生命周期的各个阶段是什么？" class="headerlink" title="42.React生命周期的各个阶段是什么？"></a>42.React生命周期的各个阶段是什么？</h4><h4 id="43-React组件间传值的方法有哪些？"><a href="#43-React组件间传值的方法有哪些？" class="headerlink" title="43.React组件间传值的方法有哪些？"></a>43.React组件间传值的方法有哪些？</h4><p>父组件向子组件传值是使用props进行传递，</p><p>子组件向父组件传值，可以使用回调函数，父组件向子组件传递回调函数，子组件执行回调函数并传递参数</p><p>子孙组件之间的传递可以使用createContext()</p><p>兄弟组件间的数据传递可以使用事件总线来传递</p><p>还可以使用redux进行全局状态管理</p><h4 id="44-说一说盒模型？"><a href="#44-说一说盒模型？" class="headerlink" title="44.说一说盒模型？"></a>44.说一说盒模型？</h4><p>盒模型分为IE的盒模型和W3C的盒模型，W3C的盒模型指的是content的宽高，IE的盒模型是将content,padding,margin包含在宽度和高度之内，可以使用css ,box-sizing:border-box来将W3C的盒模型转换成IE盒模型，默认是content-box</p><h4 id="45-说一说伪数组和数组的区别？"><a href="#45-说一说伪数组和数组的区别？" class="headerlink" title="45.说一说伪数组和数组的区别？"></a>45.说一说伪数组和数组的区别？</h4><p>得分点 类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历</p><p>数组的类型是Array,类数组的类型是object,类数组可以使用length查看长度，可以使用索引来获得值，但是不可以修改length,不能使用array的方法，可以使用forin进行遍历，类数组常用的场景：函数参数argumenrs,NodeList等，类数组转成数组方法，Array.from(arr),Array.prototype.slice.call(arr),索引不连续时会自动补位</p><h4 id="46-说一说如何实现可过期的localstorage数据？"><a href="#46-说一说如何实现可过期的localstorage数据？" class="headerlink" title="46.说一说如何实现可过期的localstorage数据？"></a>46.说一说如何实现可过期的localstorage数据？</h4><h4 id="47-说一说axios的拦截器原理及应用？"><a href="#47-说一说axios的拦截器原理及应用？" class="headerlink" title="47.说一说axios的拦截器原理及应用？"></a>47.说一说axios的拦截器原理及应用？</h4><h4 id="48-说一说创建ajax过程？"><a href="#48-说一说创建ajax过程？" class="headerlink" title="48.说一说创建ajax过程？"></a>48.说一说创建ajax过程？</h4><h4 id="49-说一下fetch-请求方式？"><a href="#49-说一下fetch-请求方式？" class="headerlink" title="49.说一下fetch 请求方式？"></a>49.说一下fetch 请求方式？</h4><h4 id="50-说一下有什么方法可以保持前后端实时通信？"><a href="#50-说一下有什么方法可以保持前后端实时通信？" class="headerlink" title="50.说一下有什么方法可以保持前后端实时通信？"></a>50.说一下有什么方法可以保持前后端实时通信？</h4><h4 id="51-说一下重绘、回流区别如何避免？"><a href="#51-说一下重绘、回流区别如何避免？" class="headerlink" title="51.说一下重绘、回流区别如何避免？"></a>51.说一下重绘、回流区别如何避免？</h4><p>对节点的大小，位置的修改重新计算被称为回流，例如DOM结构的改变(添加新的节点或者删除节点)</p><p>改变布局，例如修改了width,height,padding,font-size等值</p><p>窗口resize、(修改了窗口的尺寸)</p><p>调用getComputedStyle方法获取尺寸，位置信息等</p><p>修改背景色，字体颜色，边框颜色，边框样式等，</p><p>回流一定会引起重绘，重绘不一定会引起回流，所以应该减少回流</p><p>1.修改样式尽量一次性修改，例如通过cssText,classList,class来修改</p><p>2.避免频繁的操作DOM，可以是用document.documentFragment批量修改片段</p><p>3.避免使用getComputedStyle频繁获取计算值，如果需要，可以将计算值存储起来</p><p>4.修改DOM可以先设置diaplay:none，是他不存在render树，再进行修改，修改完成后再加入render树中</p><p>5.对某些元素使用position:absolute,fixed使其脱离标准流，这样开销会比较小</p><p>6.默认情况下，标准流中的内容都会被绘制在同一个图层上，利用一些属性创建一个新的合成图层，这些layer可以使用GPU加速绘制，因为这些图层都是单独渲染，减少了回流和重绘，例如3d transform,vedio,canvas,iframe,opacity动画转换，position:fixed,animation或者transition设置了opacity,transorm.分层确实可以提高性能，但是不要过度使用，她是以内存为代价的</p><h4 id="52-说一说-Vue-列表为什么加-key？"><a href="#52-说一说-Vue-列表为什么加-key？" class="headerlink" title="52.说一说 Vue 列表为什么加 key？"></a>52.说一说 Vue 列表为什么加 key？</h4><p>得分点 性能优化、diff算法节点比对、key不能是index</p><p>key属性主要时用在Vue的虚拟DOM算法，在新旧Vnode对比时辨识vnodes,如果不使用key,vue会使用一种最大限度减少动态元素并且尽可能减少的尝试就地修改/复用相同类型元素的算法，而使用key，他会基于key的变化重新排列元素顺序，并且移除或者销毁不需要的元素</p><p>相同的父元素的子元素的key必须唯一，如果有重复的可以会渲染错误</p><p>如果使用index作为key,没有优化效果，因为index会改变</p><p>它也可以用于强制替换元素或者组件而不是重复使用它时。当你遇到如下场景时它可能会很有用：</p><ul><li><p>完整地触发组件的生命周期钩子</p></li><li><p>触发过渡</p></li></ul><h4 id="53-说一说vue-router-实现懒加载的方法？"><a href="#53-说一说vue-router-实现懒加载的方法？" class="headerlink" title="53.说一说vue-router 实现懒加载的方法？"></a>53.说一说vue-router 实现懒加载的方法？</h4><div class="code-wrapper"><pre><code class="hljs livescript">vue实现懒加载的两种方法component：resolve=&gt;<span class="hljs-built_in">require</span>([<span class="hljs-string">&quot;./app.vue&quot;</span>],resolve)component:()i=&gt;<span class="hljs-keyword">import</span>(<span class="hljs-comment">/*webpackChunkName:app*/</span><span class="hljs-string">&quot;./app.vue&quot;</span>)webpackChunkName可以不写不要在路由中使用异步组件。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。webpack会进行代码分隔，进行独立打包，当使用道德时候才会加载，vue-router只会第一次加载时获取，以后都会使用缓存</code></pre></div><h4 id="55-ReactRouter基本用法是什么？"><a href="#55-ReactRouter基本用法是什么？" class="headerlink" title="55.ReactRouter基本用法是什么？"></a>55.ReactRouter基本用法是什么？</h4><h4 id="56-setState是同步还是异步的？"><a href="#56-setState是同步还是异步的？" class="headerlink" title="56.setState是同步还是异步的？"></a>56.setState是同步还是异步的？</h4><p>setState在组件生命周期或者react合成事件中，setState是异步的</p><p>在原生的dom事件中，setTimeout中，setState是同步的</p><p>setState设计为异步，可以显著提升性能，如果每次调用setState都进行更新，那么意味着render函数会被频繁的调用，页面会重新渲染，这样效率很低，最好的办法因该是活得多个更新，然后进行批量更新，</p><p>如果同步进行更新state,但是还没有执行render函数，那么state,props不能保持同步，state和props不一致，在开发中会产生很多问题</p><h4 id="57-React事件绑定原理"><a href="#57-React事件绑定原理" class="headerlink" title="57.React事件绑定原理"></a>57.React事件绑定原理</h4><p>得分点 非原生事件、SyntheticBaseEvent </p><p>React中的事件不是原生的事件，而是对原生的event进行封装的新类SyntheticBaseEvent，模拟处DOM事件的所有功能,通过event.nativeEvent可以获得原生事件，react将所有的事件都绑定在root根组件上，之前都是绑定在document上的，react中的事件和DOM事件不一样，和vue也不一样，react并不是将click事件绑定在该div的真实DOM上，而是在root处监听所有支持的事件，当事件发生并冒泡到root处时，react将事件内容封装并交给真正的处理函数运行，这样的方式不仅减少了内存的消耗，还能再组件挂载销毁时统一订阅和移除事件，另外冒泡到root上的事件也不是原生浏览器事件，而是React自己实现的合成事件(SyntheticBaseEvent),因此我们如果不想要事件冒泡的话，调用event.stopPropagation是无效的，应该调用event.preventDefault</p><h4 id="58-React中hooks的优缺点是什么？"><a href="#58-React中hooks的优缺点是什么？" class="headerlink" title="58.React中hooks的优缺点是什么？"></a>58.React中hooks的优缺点是什么？</h4><h4 id="59-说一说前端性能优化手段？"><a href="#59-说一说前端性能优化手段？" class="headerlink" title="59.说一说前端性能优化手段？"></a>59.说一说前端性能优化手段？</h4><h4 id="60-说一说性能优化有哪些性能指标，如何量化？"><a href="#60-说一说性能优化有哪些性能指标，如何量化？" class="headerlink" title="60.说一说性能优化有哪些性能指标，如何量化？"></a>60.说一说性能优化有哪些性能指标，如何量化？</h4><h4 id="61-说一说服务端渲染？"><a href="#61-说一说服务端渲染？" class="headerlink" title="61.说一说服务端渲染？"></a>61.说一说服务端渲染？</h4><h4 id="62-事件扩展符用过吗-…-，什么场景下？"><a href="#62-事件扩展符用过吗-…-，什么场景下？" class="headerlink" title="62.事件扩展符用过吗(…)，什么场景下？"></a>62.事件扩展符用过吗(…)，什么场景下？</h4><p>1.在数组调用时可以替代数组的apply方法</p><p>2.用于合并数组</p><p>3.与解构赋值相结合，生成新的数组</p><p>4.将字符串转成数组</p><p>5.任何iterator对象，都可以通过展开运算符转成数组</p><p>6.用于数组的浅拷贝</p><p>7.构造字面量对象可以使用展开语法</p><p>8.在 new 表达式中应用，使用 <code>new</code> 关键字来调用构造函数时，不能<strong>直接</strong>使用数组 + <code>apply</code> 的方式（<code>apply</code> 执行的是调用 <code>[[Call]]</code> , 而不是构造 <code>[[Construct]]</code>），可以使用展开语法替代</p><h4 id="63-说一说vue钩子函数？"><a href="#63-说一说vue钩子函数？" class="headerlink" title="63.说一说vue钩子函数？"></a>63.说一说vue钩子函数？</h4><p>组件从创建，挂载，更新，销毁的全过程就是vue的声明周期，包括beforeCreate,created,beforemount,mounted,beforeUpdate,updated,beforeumount,umouted,</p><p>beforeCreate钩子函数会在实例初始化之后，进行数据侦听和事件/侦听器的配置之前同步调用，</p><p>created钩子函数会在组件实例被创完成后被立即同步调用，此时$watch,computed,method,data等属性可以被调用，但是挂载阶段还没开始，所以$el属性还不可以使用，</p><p>beforeMount钩子函数被调用时，该钩子函数会在挂载前调用，render函数首次被调用，在服务器端渲染期间不会被调用</p><p>mounted钩子函数被调用时，在实例挂载完成后调用，这时候传给app.mount的元素已经被新创建的vm.$el替换，mounted不会保证所有子组件都被挂载完成。如果想执行在这个视图渲染完毕后执行代码，可以在mounted内部使用vm.$nextTick</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 仅在整个视图都被渲染之后才会运行的代码</span>  &#125;)&#125;</code></pre></div><p>该钩子函数不会再服务端渲染时调用</p><p>beforeUpdate钩子函数是在数据发生变化之后DOM更新之前调用，适合在DOM更新之前访问它，例如移除手动添加的事件监听器。<strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。</strong></p><p>updated钩子函数会在数据更新之后虚拟DOM重新渲染完毕之后被调用，此时DOM已经更新完毕可以进行DOM操作，但是不建议下该狗子中进行状态的改变，通常使用watch或者computed来进行状态监听，updated不能保证子组件已经挂载完成，如果想要在组件完全渲染以后操作可以使用vm.$nextTick.该钩子函数不能用于服务端。</p><p>activited钩子函数</p><p>该钩子会被keep-alive缓存的组件激活时调用，该钩子在服务器管渲染期间不被调用</p><p>deactivated钩子函数会在被keep-alive缓存的组件失活时调用，在服务端不可用</p><p>beforeMount钩子函数会在组件卸载之前调用，在这个时候1可以解除对事件的监听，<strong>该钩子在服务器端渲染期间不被调用。</strong></p><p>mounted钩子函数调用时，组件已经卸载完成，指令和监听器都卸载完成，<strong>该钩子在服务器端渲染期间不被调用。</strong></p><p>父子组件的声明周期</p><p>挂载阶段</p><p>父beforeCreate-&gt;父created-&gt;父beforMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p>更新阶段</p><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p>销毁阶段</p><p>父beforeDestory-&gt;子deforeDestory-&gt;子destoryed-&gt;父destoryed</p><h4 id="64-vue生命周期的源码实现"><a href="#64-vue生命周期的源码实现" class="headerlink" title="64.vue生命周期的源码实现"></a>64.vue生命周期的源码实现</h4><h4 id="65-nexttick源码"><a href="#65-nexttick源码" class="headerlink" title="65.nexttick源码"></a>65.nexttick源码</h4><h4 id="66-v8垃圾回收"><a href="#66-v8垃圾回收" class="headerlink" title="66.v8垃圾回收"></a>66.v8垃圾回收</h4><h4 id="68-计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？"><a href="#68-计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？" class="headerlink" title="68.计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？"></a>68.计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？</h4><h4 id="69-进程与线程的区别？（暂定）"><a href="#69-进程与线程的区别？（暂定）" class="headerlink" title="69.进程与线程的区别？（暂定）"></a>69.进程与线程的区别？（暂定）</h4><ol><li>一个线程属于一个进程，而一个进程可以有多个线程，但至少有一个线程，线程依赖进程的存在</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存</li><li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li><li>进程的切换开销远大于线程的切换开销</li><li>进程间的通信IPC，线程间可以直接写进数据段(如全局变量)来进行通信–需要进程同步和互斥手段的辅助，以保证数据的一致性</li><li>进程编程调试简单可靠性高，但是创建销毁开销大，线程正好相反，开销小，切换速度快，但是编程调试相对复杂</li><li>进程间不会相互影响，一个线程挂掉会导致整个进程挂掉</li><li>进程适合多核，多机分布，线程适用于多核</li></ol><p>进程：我们可以认为，启动一个应用程序，就会默认启动一个进程(也可能是多个进程)</p><p>线程：每一个进程中，都会启动至少一个线程用来执行程序中的代码，这就主线程，所以说进程是线程的容器</p><p>操作系统类似于一个大工厂，工厂中有很多车间，这个车间就是进程，每个车间有可能有一盒以上的工人在工厂，这个工人就是线程</p><p>js是单线程的，js线程有自己的容器进程，浏览器或者node</p><h4 id="70-基本数据类型之间的转换"><a href="#70-基本数据类型之间的转换" class="headerlink" title="70.基本数据类型之间的转换"></a>70.基本数据类型之间的转换</h4><p>1.console.log(null==undefined)//true<br>2.非空字符串通过Boolean()转成true,空字符串转成false，对于Number类型，非0数字都会转成true,0,NaN会转成false,对象都会被转成true,undefined会被转成false，if条件判断会自动转成boolean进行判断，使用!!也可以进行隐式转换<br>3.数值类型的转换，可以通过Number(),parseInt(),parseFloat()三个函数显示的进行转换，Number()可以用于任何数据类型，parseInt和parseFloat主要用于字符串，Number()进行类型转换时，<br>boolean值false会转成0，true会转成1，null会转成0，undefined会返回NaN,对于字符串的转换，如果字符串中只包含数字则会转换成十进制的数字，如果字符串中包含浮点数，则会转成浮点数，如果包含十六进制的字符串则会转成十进制的数字，如果是空字符串则会转成0，如果字符串中包含其字符，则会转成NaN。对象会先调用valueOf按照上述方式进行转换，如果是NaN则会再调用toString再进行上述的转换。<br>使用parseInt进行类型转换时，他会从第一个非空格的字符进行转换，如果第一个字符不是加减，数字字符，则会转成NaN,空字符串也会转成NaN,如果第一个字符时加减，数字则会一直到非数字字符位置，parseInt会进行截断字符，如果是浮点数字符串，则会遇到.就会截断<br>parseFloat只能解析十进制，会忽略第二个.他会忽略字符转以0开头的值<br>4.转成字符串，+””就可以变成字符串，也可以调用toString来转换，除了null和undefined都可以toString，使用String()也可以转成字符转，有toString则会调用这个方法，null则会装成”null”,undefined=&gt;’undefined’</p><h4 id="71-webpack-的-plugin-和-loader-的区别和原理"><a href="#71-webpack-的-plugin-和-loader-的区别和原理" class="headerlink" title="71.webpack 的 plugin 和 loader 的区别和原理"></a>71.webpack 的 plugin 和 loader 的区别和原理</h4><h4 id="72-静态资源一般采取什么缓存策略？"><a href="#72-静态资源一般采取什么缓存策略？" class="headerlink" title="72.静态资源一般采取什么缓存策略？"></a>72.静态资源一般采取什么缓存策略？</h4><p>强缓存和协商缓存</p><h4 id="73-移动端300ms的延迟问题，问什么会有这个问题"><a href="#73-移动端300ms的延迟问题，问什么会有这个问题" class="headerlink" title="73.移动端300ms的延迟问题，问什么会有这个问题"></a>73.移动端300ms的延迟问题，问什么会有这个问题</h4><h4 id="74-vue模版编译都有哪些阶段"><a href="#74-vue模版编译都有哪些阶段" class="headerlink" title="74.vue模版编译都有哪些阶段"></a>74.vue模版编译都有哪些阶段</h4><h4 id="75-vue虚拟dom怎么生成的"><a href="#75-vue虚拟dom怎么生成的" class="headerlink" title="75.vue虚拟dom怎么生成的"></a>75.vue虚拟dom怎么生成的</h4><h4 id="76-Vue2-3区别"><a href="#76-Vue2-3区别" class="headerlink" title="76.Vue2 3区别"></a>76.Vue2 3区别</h4><h4 id="77-手写防抖节流"><a href="#77-手写防抖节流" class="headerlink" title="77.手写防抖节流"></a>77.手写防抖节流</h4><h4 id="78-手写dom树转js对象"><a href="#78-手写dom树转js对象" class="headerlink" title="78.手写dom树转js对象"></a>78.手写dom树转js对象</h4><h4 id="79-给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端"><a href="#79-给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端" class="headerlink" title="79.给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端"></a>79.给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端</h4><h4 id="80-如果一个页面打开很慢，可能是哪些原因，怎么进行优化"><a href="#80-如果一个页面打开很慢，可能是哪些原因，怎么进行优化" class="headerlink" title="80.如果一个页面打开很慢，可能是哪些原因，怎么进行优化"></a>80.如果一个页面打开很慢，可能是哪些原因，怎么进行优化</h4><h4 id="81-TCP的三次握手，以及每次的作用"><a href="#81-TCP的三次握手，以及每次的作用" class="headerlink" title="81.TCP的三次握手，以及每次的作用"></a>81.TCP的三次握手，以及每次的作用</h4><h4 id="82-TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理"><a href="#82-TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理" class="headerlink" title="82.TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理"></a>82.TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理</h4><h4 id="83-Vue的响应式原理"><a href="#83-Vue的响应式原理" class="headerlink" title="83.Vue的响应式原理"></a>83.Vue的响应式原理</h4><h4 id="84-Vue中computed和data里的值的联系，computed的特点以及响应式变化"><a href="#84-Vue中computed和data里的值的联系，computed的特点以及响应式变化" class="headerlink" title="84.Vue中computed和data里的值的联系，computed的特点以及响应式变化"></a>84.Vue中computed和data里的值的联系，computed的特点以及响应式变化</h4><h4 id="85-Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy-和-defineProperty-的比较"><a href="#85-Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy-和-defineProperty-的比较" class="headerlink" title="85.Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy 和 defineProperty 的比较"></a>85.Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy 和 defineProperty 的比较</h4><p>详情请看vue3和vue2区别</p><p>vue2中重写数组中的方法，主要分为这几步</p><ol><li>获取到Array原型链上的方法，因为拦截后还需要调用原生的方法进行操作</li><li>使用object.defineproperty拦截数组的操作</li><li>再把array的实例原型指向修改后的实例原型</li></ol><p>proxy和defineproperty的区别</p><p>defineproperty的作用主要不是用来监听对象属性的变化，defineproperty不可以监听数组的变化，必须重写数组的方法，会对对象进行修改，不能够监听对象属性的修改和删除，不可以监听数组手动修改length和通过数组下标修改值，proxy代理，可以代理对象，不需要修改元素组，而且有十三中捕获器，还可以配合reflect来使用</p><h4 id="86-webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等"><a href="#86-webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等" class="headerlink" title="86.webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等"></a>86.webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等</h4><h4 id="87-window-onload和DOMContentLoaded的区别"><a href="#87-window-onload和DOMContentLoaded的区别" class="headerlink" title="87.window.onload和DOMContentLoaded的区别"></a>87.window.onload和DOMContentLoaded的区别</h4><h4 id="88-了解http2"><a href="#88-了解http2" class="headerlink" title="88.了解http2"></a>88.了解http2</h4><h4 id="89-网页布局的方式有哪些"><a href="#89-网页布局的方式有哪些" class="headerlink" title="89.网页布局的方式有哪些"></a>89.网页布局的方式有哪些</h4><h4 id="90-使用promise封装ajax"><a href="#90-使用promise封装ajax" class="headerlink" title="90.使用promise封装ajax"></a>90.使用promise封装ajax</h4><h4 id="91-写一个vue的自定义指令"><a href="#91-写一个vue的自定义指令" class="headerlink" title="91.写一个vue的自定义指令"></a>91.写一个vue的自定义指令</h4><h4 id="92-vuex的原理，数据存储在哪里"><a href="#92-vuex的原理，数据存储在哪里" class="headerlink" title="92.vuex的原理，数据存储在哪里"></a>92.vuex的原理，数据存储在哪里</h4><h4 id="93-说一下href和src的区别"><a href="#93-说一下href和src的区别" class="headerlink" title="93.说一下href和src的区别"></a>93.说一下href和src的区别</h4><h4 id="94-说一下你知道的webpack打包构建的优化"><a href="#94-说一下你知道的webpack打包构建的优化" class="headerlink" title="94.说一下你知道的webpack打包构建的优化"></a>94.说一下你知道的webpack打包构建的优化</h4><h4 id="95-说一下你了解的plugin和loader-以及如何去写一个plugin和loader"><a href="#95-说一下你了解的plugin和loader-以及如何去写一个plugin和loader" class="headerlink" title="95.说一下你了解的plugin和loader,以及如何去写一个plugin和loader"></a>95.说一下你了解的plugin和loader,以及如何去写一个plugin和loader</h4><h4 id="96-说一下transform的原理-先平移再旋转和先旋转再平移有什么区别"><a href="#96-说一下transform的原理-先平移再旋转和先旋转再平移有什么区别" class="headerlink" title="96.说一下transform的原理(先平移再旋转和先旋转再平移有什么区别)"></a>96.说一下transform的原理(先平移再旋转和先旋转再平移有什么区别)</h4><h4 id="97-函数和对象及其上下文存储在哪里"><a href="#97-函数和对象及其上下文存储在哪里" class="headerlink" title="97.函数和对象及其上下文存储在哪里"></a>97.函数和对象及其上下文存储在哪里</h4><h4 id="98-手写虚拟dom转换成真实的dom"><a href="#98-手写虚拟dom转换成真实的dom" class="headerlink" title="98.手写虚拟dom转换成真实的dom"></a>98.手写虚拟dom转换成真实的dom</h4><h4 id="99-为什么一个网站的资源会存储在多个域名中"><a href="#99-为什么一个网站的资源会存储在多个域名中" class="headerlink" title="99.为什么一个网站的资源会存储在多个域名中"></a>99.为什么一个网站的资源会存储在多个域名中</h4><h4 id="100-如何实现前端的权限控制"><a href="#100-如何实现前端的权限控制" class="headerlink" title="100.如何实现前端的权限控制"></a>100.如何实现前端的权限控制</h4><h4 id="101-说一下vue3相对于vue2的优化"><a href="#101-说一下vue3相对于vue2的优化" class="headerlink" title="101.说一下vue3相对于vue2的优化"></a>101.说一下vue3相对于vue2的优化</h4><h4 id="102-说一下vite相对于webpack的优化"><a href="#102-说一下vite相对于webpack的优化" class="headerlink" title="102.说一下vite相对于webpack的优化"></a>102.说一下vite相对于webpack的优化</h4><h4 id="103-实现vue中template生成虚拟dom"><a href="#103-实现vue中template生成虚拟dom" class="headerlink" title="103.实现vue中template生成虚拟dom"></a>103.实现vue中template生成虚拟dom</h4><h4 id="104-知道http499是什么"><a href="#104-知道http499是什么" class="headerlink" title="104.知道http499是什么"></a>104.知道http499是什么</h4><p>表示客户端主动关闭连接，即HTTP 499 Client Closed Request,HTTP 499 表示nginx使用非标准状态码。表明当nginx正在处理请求时，客户端关闭了连接</p><h4 id="105-说一说mata标签的作用"><a href="#105-说一说mata标签的作用" class="headerlink" title="105.说一说mata标签的作用"></a>105.说一说mata标签的作用</h4><p>meta元素用来定义元数据的，meta标签用于定义不能用其他元数据元素定义的元数据信息，header中定义元数据的标签有style,link,title等，不能用这些标签定义的数据，就写在meta中。</p><p>meta元素定义的元数据的类型包括以下几类</p><p>如果设置了charset meta元素就是一个字符集声明，告诉文档使用那种字符编码</p><p>如果设置了http-equiv属性，meta元素则是编译指令  主要是做兼容性处理，告诉IE浏览器去模仿那个浏览器的行为，IE模仿edge的行为，chrome使用1</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;IE=edge,chrome=1&quot;</span>&gt;</code></pre></div><p>如果设置了name属性，meta元素提供的是文档级别的元数据，应用于整个页面</p><h4 id="106-说一下css的优先级，important的缺点"><a href="#106-说一下css的优先级，important的缺点" class="headerlink" title="106.说一下css的优先级，important的缺点"></a>106.说一下css的优先级，important的缺点</h4><p>css的优先级是按照css的权重来叠加的，</p><p>！important  10000</p><p>内联样式 1000</p><p>id选择器 100</p><p>类选择器，属性选择权，伪类  10</p><p>元素选择器，伪元素 1</p><p>通配符 0</p><p>通过各项叠加来计算css的优先级</p><p>important的优先级最高，在全局和组件中要谨慎使用，在对一些继承属性使用important，在修改这个属性的时候需要再次添加important，可能会造成混乱</p><h4 id="107-说一下响应式布局"><a href="#107-说一下响应式布局" class="headerlink" title="107.说一下响应式布局"></a>107.说一下响应式布局</h4><h4 id="108-写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"><a href="#108-写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名" class="headerlink" title="108.写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"></a>108.写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名</h4><h4 id="109-说一下js的事件循环和node事件循环的区别"><a href="#109-说一下js的事件循环和node事件循环的区别" class="headerlink" title="109.说一下js的事件循环和node事件循环的区别"></a>109.说一下js的事件循环和node事件循环的区别</h4><p>js的事件循环是运行在浏览器环境中的，node事件循环是运行在node环境中的</p><p>浏览器的事件循环是一个我们编写的javascript代码和浏览器api调用(setTimeout/ajax/事件监听)的桥梁，桥梁之间他们用回调函数进行沟通</p><p>node事件循环是一个我们编写的javascript代码和系统调用(file syatem network)之间的桥梁，桥梁之间通过回调函数进行沟通</p><p>浏览器的事件循环：</p><p>​    首先会在函数执行调用栈中执行同步代码，如果执行到定时器会先将定时器挂起，继续向下执行执行到微任务代码，则先进入微任务队列，执行到宏任务，则进入宏任务队列，同步代码执行完成后，则会开始执行异步队列中的代码，先执行微任务队列，微任务队列之星完后在执行宏任务队列，等定时器执行完后，则进入宏任务队列执行，如此往复直到执行完成</p><p>宏任务队列：ajax，setTimeout ，setInterval，DOM监听，UIrendering等</p><p>微任务队列：Promise的then回调，Mutation observer api queueMicrotask() async/await等</p><p>node的事件循环是由libuv来实现的，libuv采用的就是非阻塞异步IO的调用方式</p><p>node事件循环分成很多个阶段</p><p>定时器(Timer):setTimeOut ，setIterval</p><p>待定回调（pending callback） 对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到 ECONNREFUSED</p><p>idle,prepare:进内部使用</p><p>轮询：检索新的I/O事件，执行与IO有关的回调</p><p>检测：setImmediate()回调函数在这里执行</p><p>关闭回调函数:一些关闭的回调函数，如socket.on(‘close’,)</p><p>node的事件的循环更加复杂，他也分为微任务和宏任务</p><p>宏任务：setTimeout,setInterval,IO事件，setImmediate,close事件</p><p>微任务：promise.then,async/awiat,process.nextTick,queueMicrotask</p><p>Node中的事件循环不只是 微任务队列和 宏任务队列：</p><p>​    微任务队列： </p><p>​        next tick queue：process.nextTick； </p><p>​        other queue：Promise的then回调、queueMicrotask；</p><p>​    宏任务队列： </p><p>​         timer queue：setTimeout、setInterval； </p><p>​        poll queue：IO事件；</p><p>​        check queue：setImmediate； ü close queue：close事件</p><p>执行宏任务的时候都必须先判断微任务队列是否有值</p><h4 id="110-实现一个柯里化函数（写代码）"><a href="#110-实现一个柯里化函数（写代码）" class="headerlink" title="110.实现一个柯里化函数（写代码）"></a>110.实现一个柯里化函数（写代码）</h4><h4 id="111-实现函数的链式调用（写代码，compose函数）"><a href="#111-实现函数的链式调用（写代码，compose函数）" class="headerlink" title="111.实现函数的链式调用（写代码，compose函数）"></a>111.实现函数的链式调用（写代码，compose函数）</h4><h4 id="112-如何配置less文件的loader"><a href="#112-如何配置less文件的loader" class="headerlink" title="112.如何配置less文件的loader"></a>112.如何配置less文件的loader</h4><div class="code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">test</span>:/\.<span class="hljs-keyword">less</span>$/,use:[style-loader,css-loader,postcss-loader,<span class="hljs-keyword">less</span>-loader]</code></pre></div><h4 id="113-webpack是如何做到一步步处理loader文件的"><a href="#113-webpack是如何做到一步步处理loader文件的" class="headerlink" title="113.webpack是如何做到一步步处理loader文件的"></a>113.webpack是如何做到一步步处理loader文件的</h4><h4 id="114-为什么webpack是自上而下执行的"><a href="#114-为什么webpack是自上而下执行的" class="headerlink" title="114.为什么webpack是自上而下执行的"></a>114.为什么webpack是自上而下执行的</h4><h4 id="115-实现防抖和节流函数（写代码）"><a href="#115-实现防抖和节流函数（写代码）" class="headerlink" title="115.实现防抖和节流函数（写代码）"></a>115.实现防抖和节流函数（写代码）</h4><h4 id="116-如何用css实现两栏布局"><a href="#116-如何用css实现两栏布局" class="headerlink" title="116.如何用css实现两栏布局"></a>116.如何用css实现两栏布局</h4><h4 id="117-说一下css的position定位"><a href="#117-说一下css的position定位" class="headerlink" title="117.说一下css的position定位"></a>117.说一下css的position定位</h4><p>运用position进行定位，常取得5个值是：    static relative absolute fixed  sticky</p><p>position的默认值就是static</p><p>使用其他属性值可以让position变成定位元素</p><p>relative:会按照标准文档流进行布局，可以通过left right top bottom 来进行定位，参照对象是元素原来的位置</p><p>fixed：元素会脱离标准流，可以通过left，right，top，bottom进行定位，参照对象是视口。例如画布滚动时，元素不动</p><p>absolute：元素会脱离文档流，可以通过left，right，top，bottom进行定位，参照对象是最近定位（position不为static的元素）的祖先元素，否则就会相对于视口进行定位</p><h4 id="118-说一下js的作用域"><a href="#118-说一下js的作用域" class="headerlink" title="118.说一下js的作用域"></a>118.说一下js的作用域</h4><p>js的作用域有全局作用域，函数作用域，eval作用域，块级作用域</p><p>全局作用域就是最顶层的作用域，所有变量都可以访问到，函数作用域就是每个函数内部的作用域，eval作用域就是eval函数内部的作用域，es6新增了块级作用域，块级作用域是函数作用域的子集</p><h4 id="119-说一下js的import和node的require的区别"><a href="#119-说一下js的import和node的require的区别" class="headerlink" title="119.说一下js的import和node的require的区别"></a>119.说一下js的import和node的require的区别</h4><h4 id="120-说一下你了解的js的数组的常用方法"><a href="#120-说一下你了解的js的数组的常用方法" class="headerlink" title="120.说一下你了解的js的数组的常用方法"></a>120.说一下你了解的js的数组的常用方法</h4><p>数组常用的方法有</p><p>Array.prototype.join()</p><p>Array.prototype.concat()</p><p>Array.prototype.slice()</p><p>Array.prototype.splice()</p><p>Array.prototype.push()</p><p>Array.prototype.shift()</p><p>Array.prototype.unshift()</p><p>Array.isArray()</p><p>Array.prototype.pop()</p><p>Array.prototype.map()</p><p>Array.prototype.forEach()</p><p>Array.prototype.reduce()</p><p>Array.prototype.sort()</p><p>Array.prototype.some()</p><p>Array.prototype.every()</p><p>Array.prototype.entry()</p><p>Array.prototype.find()</p><p>Array.prototype.findIndex()</p><p>Array.prototype.flat()/flatMap()</p><p>Array.prototype.indexOf()</p><p>Array.prototype.includes()</p><p>Array.from()</p><p>Array.of()</p><p>Array.prototype.toString()</p><p>Array.prototype.values()</p><h4 id="121-说一下GET和POST的区别"><a href="#121-说一下GET和POST的区别" class="headerlink" title="121.说一下GET和POST的区别"></a>121.说一下GET和POST的区别</h4><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置</li><li>GET请求参数会被完整保留在浏览器的历史记录里，而POST中的参数不会被保留</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制</li><li>GET参数通过URL传递，POST放在Request body中</li><li>GET请求只能进行 url 编码，而POST支持多种编码方式</li><li>GET产生的URL地址可以被收藏，而POST不可以</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li></ul><h4 id="123-说一下px，rem，em的区别和联系"><a href="#123-说一下px，rem，em的区别和联系" class="headerlink" title="123.说一下px，rem，em的区别和联系"></a>123.说一下px，rem，em的区别和联系</h4><p>px是绝对长度单位，rem，em是相对长度单位，em是相对于元素本身的font-size来进行定位的，如果本身没有font-size则会继承自父元素的font-size，rem是根据根元素的font-size</p><h4 id="124-说一下instanceof的原理"><a href="#124-说一下instanceof的原理" class="headerlink" title="124.说一下instanceof的原理"></a>124.说一下instanceof的原理</h4><p>通过判断instance的[[prototype]]是否和原型链上的原型是否匹配</p><h4 id="125-说一下this的指向有几种方式"><a href="#125-说一下this的指向有几种方式" class="headerlink" title="125.说一下this的指向有几种方式"></a>125.说一下this的指向有几种方式</h4><p>1.默认绑定  this默认是指向全局，浏览器中this指向window,node中this指向global  在由于兼容性考虑可以使用globalThis  在函数声明中，this就是默认绑定</p><p>2.隐式绑定  在对象中this是指向调用的变量</p><p>3.显示绑定   可以使用call ,apply ,bind来指定this的指向</p><p>4.new绑定   使用new创建的对象，构造函数中的this会指向新创建的对象</p><h4 id="126-说一下v-model的原理"><a href="#126-说一下v-model的原理" class="headerlink" title="126.说一下v-model的原理"></a>126.说一下v-model的原理</h4><p>v-model就是如下的语糖</p><p>对于input，textarea元素</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;input  :<span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;text&quot;</span>  @<span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;event =&gt; text = event.target.value&quot;</span>&gt;</code></pre></div><p>对于文本元素text，textarea会绑定value property监听input事件，checkbox和radio会绑定checked property 监听change事件，select属性会绑定value属性，监听change事件</p><h4 id="127-如何封装一个弹窗组件，需要考虑那些问题"><a href="#127-如何封装一个弹窗组件，需要考虑那些问题" class="headerlink" title="127.如何封装一个弹窗组件，需要考虑那些问题"></a>127.如何封装一个弹窗组件，需要考虑那些问题</h4><h4 id="128-说一下keep-alive的原理，以及如果超出缓存长度，如何处理"><a href="#128-说一下keep-alive的原理，以及如果超出缓存长度，如何处理" class="headerlink" title="128.说一下keep-alive的原理，以及如果超出缓存长度，如何处理"></a>128.说一下keep-alive的原理，以及如果超出缓存长度，如何处理</h4><h4 id="129-说一下你对jwt认证机制的理解，它的优缺点"><a href="#129-说一下你对jwt认证机制的理解，它的优缺点" class="headerlink" title="129.说一下你对jwt认证机制的理解，它的优缺点"></a>129.说一下你对jwt认证机制的理解，它的优缺点</h4><h4 id="130-说一下new创建实例的时候都做了什么"><a href="#130-说一下new创建实例的时候都做了什么" class="headerlink" title="130.说一下new创建实例的时候都做了什么"></a>130.说一下new创建实例的时候都做了什么</h4><p>new创建实例的过程</p><ol><li>创建一个空对象</li><li>新创建的对象的[[prototype]]指向构造函数的prototype</li><li>构造函数的this指向新创建的对象</li><li>执行构造函数</li><li>如果构造函数没有返回值，则返回新创建的对象</li></ol><h4 id="131-说一下你对闭包的理解"><a href="#131-说一下你对闭包的理解" class="headerlink" title="131.说一下你对闭包的理解"></a>131.说一下你对闭包的理解</h4><h4 id="132-说一下你对flex布局的理解，以及其中属性的默认值-未完待续"><a href="#132-说一下你对flex布局的理解，以及其中属性的默认值-未完待续" class="headerlink" title="132.说一下你对flex布局的理解，以及其中属性的默认值(未完待续)"></a>132.说一下你对flex布局的理解，以及其中属性的默认值(未完待续)</h4><p>flex是用于按行或者按列布局元素的一维布局方法，元素可以通过膨胀以填充额外的空间以适应更小的空间。flex布局可以解决原来布局的一些痛点，例如垂直居中块元素，例如使容器的所有子项等分可用宽度，而不用管具体的宽高，在多列布局中所有列都采用相同的高度，即使他们包含的内容量不同。</p><p>开启了flex布局的元素叫flex item</p><p>flex container 里面的直接子元素叫做flex item</p><p>当flex conteainer中的子元素变成flex item时，具备以下特点：</p><p>​    flex item的布局将受flex container属性的设置来来控制和布局</p><p>​    flex item不再严格区分块级元素和行内级元素</p><p>​    flex item 默认情况下是包裹内容的，但是可以设置宽度和高度</p><p>display：flex或者inline-flex可以变成 flex-container</p><p>flex container的css属性有</p><p>​    flex-flow</p><p>​    flex-direction</p><p>​    flex-wrap</p><p>​    flex-flow</p><p>​    justify-content</p><p>​    align-items</p><p>​    align-content</p><p>应用在flex items上的c s s属性</p><p>​    flex-grow</p><p>​    flex-basis</p><p>​    flex-shrink</p><p>​    order</p><p>​    align-self</p><p>​    flex</p><h4 id="133-说一下ES6的块级作用域（待补充）"><a href="#133-说一下ES6的块级作用域（待补充）" class="headerlink" title="133.说一下ES6的块级作用域（待补充）"></a>133.说一下ES6的块级作用域（待补充）</h4><p>let const function class声明都会形成块级作用域，块级作用域可以让变量必须先声明再访问，否则会出现暂时性死区。块级作用域不会出现变量提升。例如在setTimeOut中的通过递归获取dom节点，可以使用该特性来代替立即执行函数</p><h4 id="134-说一下async和await的原理，generator用来做什么"><a href="#134-说一下async和await的原理，generator用来做什么" class="headerlink" title="134.说一下async和await的原理，generator用来做什么"></a>134.说一下async和await的原理，generator用来做什么</h4><p>async和await就是generator和promise.then的语法糖</p><h4 id="135-如何用ES5实现ES6的class的static和private"><a href="#135-如何用ES5实现ES6的class的static和private" class="headerlink" title="135.如何用ES5实现ES6的class的static和private"></a>135.如何用ES5实现ES6的class的static和private</h4><p>static:ES5中是直接在构造函数中添加</p><p>private:默认使用_来替代，并且定义get set方法</p><h4 id="136-用promise封装实现readfile和writefile的同步请求（写代码）"><a href="#136-用promise封装实现readfile和writefile的同步请求（写代码）" class="headerlink" title="136.用promise封装实现readfile和writefile的同步请求（写代码）"></a>136.用promise封装实现readfile和writefile的同步请求（写代码）</h4><h4 id="137-手写ES6的模板字符串（写代码"><a href="#137-手写ES6的模板字符串（写代码" class="headerlink" title="137.手写ES6的模板字符串（写代码"></a>137.手写ES6的模板字符串（写代码</h4>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
      <category>daily</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
