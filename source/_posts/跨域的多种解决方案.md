---
title: 跨域的多种解决方案
date: 2023-04-08 19:45:24
tags:
- [javascript]
categories:
- [javascript]
---

# 什么是跨域？

### 要想理解跨域，要先理解浏览器的同源策略：

- 同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
- 如果两个 URL 的 protocol、port (en-US) (如果有指定的话) 和 host 都相同的话，则这两个 URL 是同源。 
- 这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。

### 事实上跨域的产生和前端分离的发展有很大的关系：

- 早期的服务器端渲染的时候，是没有跨域的问题的；
- 但是随着前后端的分离，目前前端开发的代码和服务器开发的API接口往往是分离的，甚至部署在不同的服务器上的；

### 这个时候我们就会发现，访问 静态资源服务器 和 API接口服务器 很有可能不是同一个服务器或者不是同一个端口。

- 浏览器发现静态资源和API接口（XHR、Fetch）请求不是来自同一个地方时（同源策略），就产生了跨域。

### 所以，在静态资源服务器和API服务器（其他资源类同）是同一台服务器时，是没有跨域问题的。

# 跨域和不跨域的不同访问策略

当静态资源和api接口服务器在同一个服务器上时，不会有跨域问题

静态资源

client/index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>网易云音乐</title>
  </head>
  <body>
    <h1>网易云音乐项目</h1>

    <script>
      // 1.XHR网络请求
      const xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          console.log(JSON.parse(xhr.responseText));
        }
      };
      xhr.open("get", "http://localhost:8000/users/list");
      xhr.send();

      // 2.fetch网络请求
      fetch("http://localhost:8000/users/list").then(async (res) => {
        const result = await res.json();
        console.log(result);
      });
    </script>
  </body>
</html>
```

服务器

src/index.js

```js
const Koa = require("koa");
const KoaRouter = require("@koa/router");
const static = require("koa-static");

const app = new Koa();

/**
 * 安装koa-static 可以将页面部署到同一台服务器上，./client 是相对于根目录的
 */
app.use(static("./client"));

const userRouter = new KoaRouter({ prefix: "/users" });
userRouter.get("/list", (ctx, next) => {
  ctx.body = [
    { id: 111, name: "why", age: 18 },
    { id: 112, name: "kobe", age: 18 },
    { id: 113, name: "james", age: 25 },
    { id: 114, name: "curry", age: 30 },
  ];
});
app.use(userRouter.routes());
app.use(userRouter.allowedMethods());

app.listen(8000, () => {
  console.log("koa服务器启动成功~");
});
```

使用nodemon进行启动

访问localhost:8000可以访问到页面，并且可以获取到接口，不会有跨域问题

# 跨域的解决方案总结

### 那么跨域问题如何解决呢？

所以跨域的解决方案几乎都和服务器有关系，单独的前端基本解决不了跨域（虽然网上也能看到各种方案，都是实际开发基本不会使用）。

你说：老师，不对丫，我明明和配置前端的webpack就可以解决跨域问题了。

webpack配置的本质也是在webpack-server的服务器中配置了代理。

### 跨域常见的解决方案：

方案一：静态资源和API服务器部署在同一个服务器中；

方案二：CORS， 即是指跨域资源共享；

方案三：node代理服务器（webpack中就是它）；

方案四：Nginx反向代理；

### 不常见的方案：

jsonp：现在很少使用了（曾经流行过一段时间）；

postMessage：有兴趣了解一下吧；

websocket：为了解决跨域，所有的接口都变成socket通信？

....

### CORS

**跨源资源共享（CORS， Cross-Origin Resource Sharing跨域资源共享）：**

它是一种基于http header的机制；

该机制通过允许服务器标示除了它自己以外的其它源（域、协议和端口），使得浏览器允许这些 origin 访问加载自己的资源。

**浏览器将 CORS 请求分成两类：简单请求和非简单请求。**

**只要同时满足以下两大条件，就属于简单请求（不满足就属于非简单请求）**

请求方法是以下是三种方法之一：

- HEAD
- GET
- POST

HTTP 的头信息不超出以下几种字段：

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain

请求接口的前端页面

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>网易云音乐</title>
</head>
<body>
  <h1>网易云音乐项目</h1>
  
  <script>
    // 1.XHR网络请求
    const xhr = new XMLHttpRequest()
    xhr.onreadystatechange = function() {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        console.log(JSON.parse(xhr.responseText))
      }
    }
    xhr.open('get', 'http://localhost:8000/users/list')
    xhr.send()


    // 2.fetch网络请求
    fetch('http://localhost:8000/users/list').then(async res => {
      const result = await res.json()
      console.log(result)
    })
  </script>
</body>
</html>
```

后端接口

```js
const Koa = require("koa");
const KoaRouter = require("@koa/router");
const static = require("koa-static");

const app = new Koa();

/**
 * 安装koa-static 可以将页面部署到同一台服务器上，./client 是相对于根目录的
 */
// app.use(static("./client"));

// 中间件
app.use(async (ctx, next) => {
  // 1.允许简单请求开启CORS，* 表示所有域都可以访问，或者设置具体的域，表示那些可以访问
  ctx.set("Access-Control-Allow-Origin", "*");
  // 2.非简单请求开启下面的设置
  ctx.set(
    "Access-Control-Allow-Headers",
    "Accept, AcceptEncoding, Connection, Host, Origin"
  );
  ctx.set("Access-Control-Allow-Credentials", true); // 允许携带cookie
  ctx.set(
    "Access-Control-Allow-Methods",
    "PUT, POST, GET, DELETE, PATCH, OPTIONS"
  ); //允许那些请求方式
  // 3.发起的是一个options请求
  if (ctx.method === "OPTIONS") {
    ctx.status = 204;
  } else {
    await next();
  }
});

const userRouter = new KoaRouter({ prefix: "/users" });
userRouter.get("/list", (ctx, next) => {
  ctx.body = [
    { id: 111, name: "why", age: 18 },
    { id: 112, name: "kobe", age: 18 },
    { id: 113, name: "james", age: 25 },
    { id: 114, name: "curry", age: 30 },
  ];
});
app.use(userRouter.routes());
app.use(userRouter.allowedMethods());

app.listen(8000, () => {
  console.log("koa服务器启动成功~");
});

```

### Node代理服务器

node服务器代理的方式是在开发模式下比较常用的一种模式，例如webpack.devServer中配置的模式

```js
// node服务器代理 1.部署在同一台服务器当中，2.开启CORS
// webpack => webpack-dev-server
const express = require("express");
//在webpack中也是使用这种插件
const { createProxyMiddleware } = require("http-proxy-middleware");

const app = express();

app.use(express.static("./client")); //这个也是放在同一个服务器里，node代理可以使用，或者使用cors

app.use(
  "/api",
  createProxyMiddleware({
    target: "http://localhost:8000", //代理转发到这个地址
    pathRewrite: {
      //路径重写
      "^/api": "",
    },
    changeOrigin:true,//有些后端服务器不允许代理发送请求，所以需要代理到和后端服务器同一个服务器下
  })
);

app.listen(9000, () => {
  console.log("express proxy服务器开启成功");
});
```

而在代理转发的服务中也是要开启CORS的，后端服务器不开启cors，也不能进行跨域访问

```js
const Koa = require("koa");
const KoaRouter = require("@koa/router");
const static = require("koa-static");

const app = new Koa();

/**
 * 安装koa-static 可以将页面部署到同一台服务器上，./client 是相对于根目录的
 */
// app.use(static("./client"));

// 中间件
app.use(async (ctx, next) => {
  // 1.允许简单请求开启CORS，* 表示所有域都可以访问，或者设置具体的域，表示那些可以访问
  ctx.set("Access-Control-Allow-Origin", "*");
  // 2.非简单请求开启下面的设置
  ctx.set(
    "Access-Control-Allow-Headers",
    "Accept, AcceptEncoding, Connection, Host, Origin"
  );
  ctx.set("Access-Control-Allow-Credentials", true); // 允许携带cookie
  ctx.set(
    "Access-Control-Allow-Methods",
    "PUT, POST, GET, DELETE, PATCH, OPTIONS"
  ); //允许那些请求方式
  // 3.发起的是一个options请求
  if (ctx.method === "OPTIONS") {
    ctx.status = 204;
  } else {
    await next();
  }
});

const userRouter = new KoaRouter({ prefix: "/users" });
userRouter.get("/list", (ctx, next) => {
  ctx.body = [
    { id: 111, name: "why", age: 18 },
    { id: 112, name: "kobe", age: 18 },
    { id: 113, name: "james", age: 25 },
    { id: 114, name: "curry", age: 30 },
  ];
});
app.use(userRouter.routes());
app.use(userRouter.allowedMethods());

app.listen(8000, () => {
  console.log("koa服务器启动成功~");
});
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>网易云音乐</title>
</head>
<body>
  <h1>网易云音乐项目</h1>
  
  <script>
    // 1.XHR网络请求
    const xhr = new XMLHttpRequest()
    xhr.onreadystatechange = function() {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        console.log(JSON.parse(xhr.responseText))
      }
    }
    xhr.open('get', 'http://localhost:8000/users/list')
    xhr.send()


    // 2.fetch网络请求
    fetch('http://localhost:8000/users/list').then(async res => {
      const result = await res.json()
      console.log(result)
    })
  </script>
</body>
</html>
```

### Nginx反向代理

使用nginx反向代理和node代理差不多，是生产环境中比较多使用的一种方式，他也需要配置cors

修改nginx.conf配置文件/opt/homebrew/etc/nginx/nginx.conf

```
 location / {
            # root   html;
            # index  index.html index.htm;
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Headers "Accept, AcceptEncoding, Connection, Host, Origin";
            add_header Access-Control-Allow-Credentials true;
            add_header Access-Control-Allow-Methods "PUT, POST, GET, DELETE, PATCH, OPTIONS";
            if ($request_method = "OPTIONS"){
              return 204;
            }
            proxy_pass http://localhost:8000;
        }

```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>网易云音乐</title>
  </head>
  <body>
    <h1>网易云音乐项目</h1>

    <script>
      // 1.XHR网络请求
      const xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function () {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          console.log(JSON.parse(xhr.responseText));
        }
      };
      //nginx的默认端口号是8080
      xhr.open("get", "http://localhost:8080/users/list");
      xhr.send();

      // 2.fetch网络请求
      fetch("http://localhost:8080/users/list").then(async (res) => {
        const result = await res.json();
        console.log(result);
      });
    </script>
  </body>
</html>

```

```js
const Koa = require("koa");
const KoaRouter = require("@koa/router");

const app = new Koa();

const userRouter = new KoaRouter({ prefix: "/users" });
userRouter.get("/list", (ctx, next) => {
  ctx.body = [
    { id: 111, name: "why", age: 18 },
    { id: 112, name: "kobe", age: 18 },
    { id: 113, name: "james", age: 25 },
    { id: 114, name: "curry", age: 30 },
  ];
});
app.use(userRouter.routes());
app.use(userRouter.allowedMethods());

app.listen(8000, () => {
  console.log("koa服务器启动成功~");
});
```

