<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/14/%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-08-14T00:48:18.000Z" itemprop="datePublished">2022-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/%E5%89%8D%E7%AB%AF%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%AC%94%E8%AE%B0/">前端系统课笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/14/%E7%AC%94%E8%AE%B0/">前端系统课笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br></pre></td><td class="code"><pre><span class="line">1.margin-left的值如果是百分比时，相对于他的包含块的宽度的百分比，即他的父元素</span><br><span class="line"></span><br><span class="line">2.性能优化点：link ref=`dns-prefetch`dns预获取，在资源加载之前获取到真实的ip地址</span><br><span class="line"></span><br><span class="line">3.rgb R红 G绿 B蓝  \#ff0000 十六进制表示法  rgb(0，0，0) 十进制表示</span><br><span class="line"></span><br><span class="line">4.image/vedio是行内可替换元素，不是行内块级元素</span><br><span class="line"></span><br><span class="line">5.line-hight是继承属性</span><br><span class="line"></span><br><span class="line">6.#表示多个属性是以逗号分隔</span><br><span class="line"></span><br><span class="line">7.+表示多个属性是以空格分隔</span><br><span class="line"></span><br><span class="line">8.text-align 时将行内元素相对于父级块元素进行居中例如img 文本 input等</span><br><span class="line"></span><br><span class="line">9.text-ident和width以em为单位的时候是相对于自身的，font-size可以从父元素继承，如果父元素设置了font-size则会继承下来并相对于自身</span><br><span class="line"></span><br><span class="line">10.普遍兄弟选择器只能选中下面的所有兄弟元素</span><br><span class="line"></span><br><span class="line">11.script标签放到html的头部时要加window.onload</span><br><span class="line"></span><br><span class="line">12.伪类hover,link,visited,active的执行顺序 LVHA</span><br><span class="line"></span><br><span class="line">13.除了a标签，hover和active也可以用在其他元素上</span><br><span class="line"></span><br><span class="line">14.a元素没有设置伪类，默认所有伪类都是相同的设置</span><br><span class="line"></span><br><span class="line">15.::first-line选中首行元素</span><br><span class="line">::first-letter选中首字母</span><br><span class="line">元素之间的间隙默认是换行符，去掉换行符可以</span><br><span class="line"></span><br><span class="line">::after&#123;</span><br><span class="line">content:url(&quot;./image/icon.svg&quot;);//可以这样来添加图片</span><br><span class="line">color:green</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;这是上面代码的实现&lt;br /&gt;</span><br><span class="line">  我们有一些 &lt;span data-descr=&quot;collection of words and punctuation&quot;&gt;文字&lt;/span&gt; 有一些</span><br><span class="line">  &lt;span data-descr=&quot;small popups which also hide again&quot;&gt;提示&lt;/span&gt;。&lt;br /&gt;</span><br><span class="line">  把鼠标放上去&lt;span data-descr=&quot;not to be taken literally&quot;&gt;看看&lt;/span&gt;。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">//自定义属性</span><br><span class="line">::after伪元素，attr()CSS表达式和一个自定义数据属性 data-descr 创建一个纯CSS</span><br><span class="line"> content: attr(data-descr);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 16.怎么画0.5px的线</span><br><span class="line"> 17.常见的继承属性：font-size,font-weight,font-family,line-height,color,text-align一般和文本有关的</span><br><span class="line"> </span><br><span class="line">1.  css的权重</span><br><span class="line"> important 10000</span><br><span class="line"> 内联选择器 1000</span><br><span class="line"> id选择器 100</span><br><span class="line"> 类选择器，属性选择器，伪类 10</span><br><span class="line"> 元素选择器，伪元素 1</span><br><span class="line"> 通配选择器  0</span><br><span class="line">19.img，vedio,input是行内替换元素  和其他行内元素在一行显示，可以设置宽高</span><br><span class="line">	行内非替换元素不可以设置宽高</span><br><span class="line">20.伪元素是行内非替换元素，不可以设置宽高，必须转成行内块级元素和块级元素，在使用伪元素过程中必须加content</span><br><span class="line">21.不要在p元素里面放块元素</span><br><span class="line">22.行内元素不要放块级元素，只能放行内元素</span><br><span class="line">23.设置元素不可见的方式</span><br><span class="line">	1.display:none 不占据任何空间</span><br><span class="line">	2.visibility:hidden占据空间不可见</span><br><span class="line">	3.设置颜色透明度</span><br><span class="line">	4.background:transparent可以是背景颜色透明</span><br><span class="line">	5.opacity:1,可以设置透明度，但是会使子元素也会变透明，具有穿透性</span><br><span class="line">24.padding:10px 20px 30px 写三个值得时候，左边没有值，用右边的替代</span><br><span class="line">25.border-radius百分比圆角水平方向是width+border的百分比，圆角垂直方向是height+border的百分比</span><br><span class="line">	border-radius:50%是个圆，超过百分之50%也是圆，超过50%，无效</span><br><span class="line">26.margin</span><br><span class="line">	margin的传递 左右margin不传递</span><br><span class="line">	margin-top的传递 如果块级元素顶部线和父元素的顶部线重叠，那么这个块级元素的margin-top就会传递给父元素</span><br><span class="line">	margin-bottom</span><br><span class="line">	如果块级元素的底部线和父元素的底部线出现重叠，且父元素高度为auto时，会传递</span><br><span class="line">	解决：1.父元素设置border</span><br><span class="line">		 2.父元素使用padding</span><br><span class="line">		 3.触发bfc</span><br><span class="line">	上下margin的折叠 </span><br><span class="line">	兄弟块元素上下两个margin合并成一个margin，折叠后取较大的值。解决方法只设置一个</span><br><span class="line">	父子之间折叠，也会出线相同的情况</span><br><span class="line">27.outline  外轮廓不占据空间，默认显示在border外面 outlone:none		可以去除a元素，input元素focus状态下的默认外轮廓	</span><br><span class="line">28.box-shadow:offset-x offset-y blur(模糊度) 向外扩散的值 color ，多个阴影以逗号分隔，会叠加</span><br><span class="line">29.text-shadow:文字添加阴影</span><br><span class="line">27.行内非替换元素的注意事项</span><br><span class="line">	1.不可以设置width和height</span><br><span class="line">	2.设置margin-top.margin-bottom不生效，margi-left和margin-right生效</span><br><span class="line">	3.设置padding-top,padding-bottom会不等高，且不占据空间，设置padding-right和padding-left生效</span><br><span class="line">	4.设置border和padding给相同效果</span><br><span class="line">28.html5语义化标签</span><br><span class="line">	&lt;header&gt;</span><br><span class="line">	&lt;nav&gt;</span><br><span class="line">	&lt;section&gt;</span><br><span class="line">	&lt;artical&gt;</span><br><span class="line">	&lt;aside&gt;</span><br><span class="line">	&lt;footer&gt;</span><br><span class="line">29.vedio和audio时行内替换元素</span><br><span class="line">   在针对不同的播放格式写法</span><br><span class="line">   &lt;vedio src=&quot;&quot;&gt;</span><br><span class="line">   		&lt;source src=&quot;.../....mp4&quot;&gt;&lt;/source&gt;</span><br><span class="line">   		&lt;source src=&quot;.avi&quot;&gt;&lt;/source&gt;</span><br><span class="line">   		&lt;source src=&quot;&quot;&gt;&lt;/source&gt;</span><br><span class="line">   		&lt;p&gt;该浏览器不支持&lt;/p&gt;</span><br><span class="line">   &lt;/vedio&gt;</span><br><span class="line">30.data-*自定义属性，可以html和js中进行数据传递</span><br><span class="line">31.white-space:normal|nowrap|pre|.....</span><br><span class="line">32.text-overflow:clip|esclip text-overflow必须在overflow不是visible才生效</span><br><span class="line">33.css函数</span><br><span class="line">	1.var 定义CSS变量</span><br><span class="line">		属性名要以--开头</span><br><span class="line">		html&#123;</span><br><span class="line">			--main-color:#fffff</span><br><span class="line">		&#125;</span><br><span class="line">		div&#123;</span><br><span class="line">			color:var(--main-color)</span><br><span class="line">		&#125;</span><br><span class="line">	2.calc 计算CSS值，</span><br><span class="line">	3.blur  高斯模糊--毛玻璃效果  blur(radius)可以应用于图片或者元素，radius模糊半径</span><br><span class="line">			可以和filter一起使用。filter:blur(5px)，会使所有子元素都有高斯模糊</span><br><span class="line">			图片的高斯模糊也可以在图片上添加一个遮盖层，用定位元素</span><br><span class="line">			父元素：position:relative</span><br><span class="line">			.cover&#123;</span><br><span class="line">				position:absolute</span><br><span class="line">				top:0</span><br><span class="line">				left:0</span><br><span class="line">				right:0</span><br><span class="line">				bottom:0</span><br><span class="line">				background:rgba(0,0,0,.5)//透明效果</span><br><span class="line">				background-filter:blur(5px)//高斯模糊</span><br><span class="line">			&#125;</span><br><span class="line">	4.gradient 颜色渐变函数 是一种&lt;image&gt;css数据类型的子类型，用于图片颜色的过度转变</span><br><span class="line">	  liner-gradient 线性渐变 background-image:linear-gradient(to right top ,red,blue)     </span><br><span class="line">34.background背景色对也border,padding有效</span><br><span class="line">   color前景色对border也是有效的，border没有设置颜色时，会使用color的值</span><br><span class="line">  35.浏览器前缀：-o-,-xv-,-ms-,-mso-,0moz-.-webkit-</span><br><span class="line">36.bfc 兄弟块元素margin折叠</span><br><span class="line">35.媒体查询</span><br><span class="line">36.css单位</span><br><span class="line">	em </span><br><span class="line">	rem</span><br><span class="line">	px</span><br><span class="line">	vw/vh</span><br><span class="line">	%</span><br><span class="line">37.less</span><br><span class="line">	定义变量 @mainColor:#ffff</span><br><span class="line">	使用变量 @mainColor</span><br><span class="line">	兼容css</span><br><span class="line">	</span><br><span class="line">	&amp;:hover &amp;::after</span><br><span class="line">	less的运算</span><br><span class="line">	less的混合(Mixins)</span><br><span class="line">	    .box2(@borderwidth:1px,@borderColor:red)&#123;</span><br><span class="line">	    	border:@borderwidth solid @borderColor</span><br><span class="line">	    &#125;</span><br><span class="line">	    .box-size&#123;</span><br><span class="line">	    	width:100px;</span><br><span class="line">	    	height:200px</span><br><span class="line">	    &#125;</span><br><span class="line">		.box&#123;</span><br><span class="line">		//混入方式,可以传参</span><br><span class="line">			.box2(2px,green)</span><br><span class="line">			width:.box-size[width]//混入和映射结合使用</span><br><span class="line">			&amp;:extend(.box-size) //继承</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	less内置函数</span><br><span class="line">		.box&#123;</span><br><span class="line">			color:color(red)//将转换成16进制</span><br><span class="line">			width:convert(100px,&quot;in&quot;)单位准换，转成英寸</span><br><span class="line">			floor()向下取整</span><br><span class="line">			ceil()向上取整</span><br><span class="line">		&#125;</span><br><span class="line">	less的作用域：查找一个变量时，会在本地和混入先查找，然后再父级查找</span><br><span class="line">	less的注释</span><br><span class="line">	less的导入 import</span><br><span class="line">	</span><br><span class="line">38.移动端适配</span><br><span class="line">   视口viewport</span><br><span class="line">   	布局视口</span><br><span class="line">   	视觉视口</span><br><span class="line">   	理想视口</span><br><span class="line">   	&lt;meta name=&quot;viewport&quot; content=&quot;width=980px&quot;&gt;//修改布局视口的宽度，对pc端无效</span><br><span class="line">   	&lt;meta name=&quot;viewport&quot; content=&quot;device-width，initial-scal=1.0,user-scalable=no</span><br><span class="line">   	minimun-scal=1.0,maximun-scale=1.0</span><br><span class="line">   	&gt;</span><br><span class="line">39.	css的相对单位em,是相对于自身的font-size来进行定位的，如果自己已经定义了font-size的px，则用自身的font-size,否则就继承自父元素的font-size</span><br><span class="line">	rem是基于根元素的字体的大小</span><br><span class="line">	vw是视窗宽度的1%</span><br><span class="line">	vh是视窗高度的1%</span><br><span class="line">40.再pc端，布局视口和视觉视口是同一个，不用区分</span><br><span class="line">	默认情况下，一个在PC端的网页在移动端会如何显示呢？</span><br><span class="line"> 第一，它会按照宽度为980px来布局一个页面的盒子和内容；</span><br><span class="line"> 第二，为了显示可以完整的显示在页面中，对整个页面进行缩小</span><br><span class="line">我们相对于980px布局的这个视口，称之为布局视口（layout </span><br><span class="line">viewport）；</span><br><span class="line"> 布局视口的默认宽度是980px；</span><br><span class="line">	视觉视口（visual viewport）</span><br><span class="line"> 如果默认情况下，我们按照980px显示内容，那么右侧有一部分区域</span><br><span class="line">就会无法显示，所以手机端浏览器会默认对页面进行缩放以显示到用</span><br><span class="line">户的可见区域中；</span><br><span class="line"> 那么显示在可见区域的这个视口，就是视觉视口（visual viewport）</span><br><span class="line">41.适配方案 – rem+动态html的font-size</span><br><span class="line">   使用该方案有两个问题</span><br><span class="line">   	 问题一：针对不同的屏幕，设置html不同的font-size；</span><br><span class="line">     问题二：将原来要设置的尺寸，转化成rem单位；</span><br><span class="line">    方案一：媒体查询</span><br><span class="line">     可以通过媒体查询来设置不同尺寸范围内的屏幕html的font-size尺寸；</span><br><span class="line">     缺点：</span><br><span class="line">    ✓ 1.我们需要针对不同的屏幕编写大量的媒体查询；</span><br><span class="line">    ✓ 2.如果动态改变尺寸，不会实时的进行更新；</span><br><span class="line">    ◼ 方案二：编写js代码</span><br><span class="line">     如果希望实时改变屏幕尺寸时，font-size也可以实时更改，可以通过js代码；</span><br><span class="line">     方法：</span><br><span class="line">    ✓ 1.根据html的宽度计算出font-size的大小，并且设置到html上；</span><br><span class="line">    ✓ 2.监听页面的实时改变，并且重新设置font-size的大小到html上；</span><br><span class="line">    </span><br><span class="line">    rem的单位换算</span><br><span class="line">	方案一：手动换算</span><br><span class="line">	方案二：less/scss函数</span><br><span class="line">	◼ 方案四：VSCode插件</span><br><span class="line">	 px to rem 的插件，在编写时自动转化</span><br><span class="line">	◼ 方案四：VSCode插件</span><br><span class="line">	 px to rem 的插件，在编写时自动转化三：postcss-pxtorem</span><br><span class="line">	</span><br><span class="line">42。meta标签的作用</span><br><span class="line">	可以在head中定义元信息，例如 比如标题title、样式style、link外部资源等；</span><br><span class="line">     meta用于定义那些不能使用其他定元相关（meta-related）元素定义的任何元数据信息；</span><br><span class="line">    	meta 元素定义的元数据的类型包括以下几种：</span><br><span class="line">             如果设置了 charset 属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。</span><br><span class="line">             如果设置了 http-equiv 属性，meta 元素则是编译指令。</span><br><span class="line">             如果设置了 name 属性，meta 元素提供的是文档级别（document-level）的元数据，应用于整个页面。</span><br><span class="line">            	例如：robots，author，Copyright，description，keywords</span><br><span class="line">            	</span><br><span class="line"> 43.link图标</span><br><span class="line"> 	&lt;link rel=&quot;icon&quot; href=&quot;https:;;;;&quot; /&gt;</span><br><span class="line"> 	也可以直接将该favicon.ico直接置于根目录下，不需要使用link来引入，因为大部分浏览器都可以识别</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 44.CSS样式的字符编码</span><br><span class="line"> 	开发中推荐在CSS的开头编写@charset指定编码：@import &quot;utf-8&quot;</span><br><span class="line"> 45.全局属性data-*</span><br><span class="line"> 	data设置的属性可以在JavaScript的DOM操作中通过dataset轻松获取到；</span><br><span class="line">	通常用于HTML和JavaScript数据之间的传递；</span><br><span class="line">46.&quot;&quot;==null //false</span><br><span class="line">	null和undefined不能转换成任何数据类型进行比较</span><br><span class="line">	</span><br><span class="line">47.const obj=&#123;</span><br><span class="line">	[Symbol.toPrimitive]()&#123;</span><br><span class="line">	return &quot;123&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">48.转换成boolean的方式</span><br><span class="line">	Boolean(a)</span><br><span class="line">	!!a</span><br><span class="line">49.switch case 是严格匹配===，还要防止case穿透</span><br><span class="line"></span><br><span class="line">50.npx</span><br><span class="line">npx 是 npm v5.2.0 引入的一条命令（ npx ），是一个 npm 包执行器。我们可以使用 npx 来执行各种命令。</span><br><span class="line"></span><br><span class="line">主要有以下特点：</span><br><span class="line"></span><br><span class="line">临时安装可执行依赖包，不用全局安装，不用担心长期的污染。</span><br><span class="line"></span><br><span class="line">可以执行依赖包中的命令，安装完成自动运行。</span><br><span class="line"></span><br><span class="line">自动加载 node_modules 中依赖包，不用指定 $PATH 。</span><br><span class="line"></span><br><span class="line">可以指定 node 版本、命令的版本，解决了不同项目使用不同</span><br><span class="line"></span><br><span class="line">npx 执行流程如下：</span><br><span class="line"></span><br><span class="line">到 node_modules/.bin 路径检查对应的命令是否存在，找到之后执行；</span><br><span class="line"></span><br><span class="line">没有找到，就去环境变量 $PATH 里面，检查对应命令是否存在，找到之后执行;</span><br><span class="line"></span><br><span class="line">还是没有找到，自动下载一个临时的依赖包最新版本在一个临时目录，然后再运行命令，运行完之后删除，不污染全局环境。</span><br><span class="line">51.函数默认的返回值是undefined</span><br><span class="line">52.递归</span><br><span class="line">53.斐波那契数列</span><br><span class="line">	function fibonacci(n)&#123;</span><br><span class="line">    if(n===1||n===2) return 1</span><br><span class="line">    return fibonacci(n-1)+fibonacci(n-2)</span><br><span class="line">  &#125;</span><br><span class="line">54.立即执行函数</span><br><span class="line">	1.会立即执行</span><br><span class="line">	2.函数有独立的作用域，可以避免外界访问或者修改内部的变量，</span><br><span class="line">	3.可以有参数和返回值</span><br><span class="line">	4.匿名函数多种写法</span><br><span class="line">			(function()&#123;</span><br><span class="line">			</span><br><span class="line">			&#125;)()</span><br><span class="line">            // 匿名函数多种写法</span><br><span class="line">            (function (fn) &#123;</span><br><span class="line">              console.log(&quot;立即执行函数&quot;);</span><br><span class="line">            &#125;)();</span><br><span class="line"></span><br><span class="line">            // + - ！都可以，但是不要这样用</span><br><span class="line">            +(function foo() &#123;</span><br><span class="line">              console.log(&quot;立即执行函数&quot;);</span><br><span class="line">            &#125;)();</span><br><span class="line">	5.应用：。</span><br><span class="line">		1.解决命名冲突的问题，防止全局变量的命名冲突</span><br><span class="line">		2.const btnRtm1 = document.querySelectorAll(&quot;.btn&quot;);</span><br><span class="line">for (var i = 0; i &lt; btnRtm.length; i++) &#123;</span><br><span class="line">  var btn = btnRtm[i];</span><br><span class="line">  (function (m) &#123;</span><br><span class="line">    btn.onclick = function () &#123;</span><br><span class="line">      console.log(m);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">// 打印 4 4 4 4 .....</span><br><span class="line">// 立即执行函数可以解决上述问题还有for循环中有异步代码例如setTimeout，也可以用let解决</span><br><span class="line">// 因为在如下代码中，但执行onclick执行的时候，此时for循环已经执行完，i已经变成btnRtm.length 所以执行代码永远是4 4 4 ，而使用立即执行函数，会每次将i作为参数传入立即执行函数中，尽管i执行完之后已经变成4，但是m存储这0 1 2 3 </span><br><span class="line">const btnRtm = document.querySelectorAll(&quot;.btn&quot;);</span><br><span class="line">for (var i = 0; i &lt; btnRtm.length; i++) &#123;</span><br><span class="line">  var btn = btnRtm[i];</span><br><span class="line">  (function (m) &#123;</span><br><span class="line">    btn.onclick = function () &#123;</span><br><span class="line">      console.log(m);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">// 打印 1 2 3 4....</span><br><span class="line">const btnRtm3 = document.querySelectorAll(&quot;.btn&quot;);</span><br><span class="line">for (let i = 0; i &lt; btnRtm.length; i++) &#123;</span><br><span class="line">  var btn = btnRtm[i];</span><br><span class="line"></span><br><span class="line">  btn.onclick = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 打印1 2 3 4 .....</span><br><span class="line"></span><br><span class="line">55.js代码规范</span><br><span class="line">56.Object的key是字符串</span><br><span class="line">57.Object可以使用delete来删除属性，Object.name/Object[&quot;name&quot;]来获取，或者修改属性，obj[name]是计算属性，name是一个变量</span><br><span class="line">58.Object 遍历可以使用forin,或者Object.keys()   </span><br><span class="line">59.栈内存和堆内存</span><br><span class="line">	原始数据类型是在栈内存</span><br><span class="line">	引用类型实在堆内存</span><br><span class="line">60.包装类型，</span><br><span class="line">   当有包装类型的原始数据类型可以调用方法，是因为js引擎会将原始类型转换成包装类调用对应的方法</span><br><span class="line">   123..toString(2)//转换成二进制</span><br><span class="line">   toFixed(2)保留两位小数。是四舍五入</span><br><span class="line">   parseInt===Number.parseInt</span><br><span class="line">  </span><br><span class="line">   String类</span><br><span class="line">   length</span><br><span class="line">   str[0]</span><br><span class="line">   charAt(0)//字符位置</span><br><span class="line">   for</span><br><span class="line">   for...of</span><br><span class="line">   for...in</span><br><span class="line">   字符串是不可变的</span><br><span class="line">   	例如：var str = &quot;name&quot;;</span><br><span class="line">		 str[0] = &quot;v&quot;;</span><br><span class="line">		 console.log(str);//name</span><br><span class="line">		 </span><br><span class="line">		 var str = str.toUpperCase();</span><br><span class="line">			console.log(str);//这是新的字符串，不是原来的</span><br><span class="line">	str.indexOf(searchString,fromIndex)//返回值是索引值</span><br><span class="line">	str.includes()</span><br><span class="line">	str.startsWidth(&quot;1&quot;)//是否以1开头</span><br><span class="line">	str.endsWidth()</span><br><span class="line">	str.replace()</span><br><span class="line">	str.slice()</span><br><span class="line">	str.substring()</span><br><span class="line">	str.substr()</span><br><span class="line">	字符串拼接+，cocat()</span><br><span class="line">	trim()</span><br><span class="line">	split()</span><br><span class="line">	replace()替换，是纯函数</span><br><span class="line">61.Array</span><br><span class="line">	splice()//添加，删除，替换</span><br><span class="line">	pop</span><br><span class="line">	push</span><br><span class="line">	shift</span><br><span class="line">	unshift</span><br><span class="line">	arr.length可以获得数组的长度，修改数组的长度，删除数组</span><br><span class="line">	如果arr.length为6</span><br><span class="line">	arr.length=2//可以删除剩余的元素</span><br><span class="line">	arr.length=0可以删除所有元素</span><br><span class="line">	arr.length=8//可以扩容</span><br><span class="line">	</span><br><span class="line">	arr.slice()</span><br><span class="line">	arr.join()</span><br><span class="line">	arr.concat()</span><br><span class="line">	arr.indexOf()</span><br><span class="line">	arr.find(arr.find(callback[, thisArg]) callback(element,index,array) //会返回匹配到的元素，匹配到多个的时候会返回第一个   find 方法不会改变数组</span><br><span class="line">	arr.findIndex( 	)</span><br><span class="line">	//实现find</span><br><span class="line">	Array.prototype.myFind = function (callback, thisArg) &#123;</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    if (callback.call(thisArg, this[i], i, this)) &#123;</span><br><span class="line">      return this[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//实现forEach</span><br><span class="line">	Array.prototype.MyForEach = function (callback, thisArg) &#123;</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    callback.apply(thisArg, [this[i], i, this]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">includes()</span><br><span class="line">arr.sort()</span><br><span class="line">// 默认是降序</span><br><span class="line">arr.sort((item1, item2) =&gt; &#123;</span><br><span class="line">  return item1.age - item2.age;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br><span class="line">// 升序</span><br><span class="line">arr.sort((item1, item2) =&gt; &#123;</span><br><span class="line">  return item2.age - item1.age;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr.reverse()</span><br><span class="line"></span><br><span class="line">arr.filter()</span><br><span class="line">Array.prototype.myfilter = function (callback, thisArg) &#123;</span><br><span class="line">  let newArr = [];</span><br><span class="line">  for (let i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">    if (callback.call(thisArg, this[i], i, this)) &#123;</span><br><span class="line">      newArr.push(this[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newArr;</span><br><span class="line">&#125;;</span><br><span class="line">arr.map()</span><br><span class="line">arr.reduce()</span><br><span class="line"></span><br><span class="line">Date类型</span><br><span class="line">new Date()</span><br><span class="line">Date.now()//当前事件的时间戳</span><br><span class="line">date.getTime()//将时间转换成时间戳</span><br><span class="line">date.valueOf()//也是一样</span><br><span class="line">+date//也可以</span><br><span class="line"></span><br><span class="line">将字符串转换成时间戳</span><br><span class="line">var dateString = &quot;2020-5-15&quot;;</span><br><span class="line">console.log(new Date(dateString).getTime());</span><br><span class="line">console.log(Date.parse(dateString));</span><br><span class="line">==================================================================================</span><br><span class="line">Dom</span><br><span class="line">62.所有节点都继承自EventTarget</span><br><span class="line">63.document对象-可以获得整个网页node节点</span><br><span class="line">	var html=document.documnetElement</span><br><span class="line">	var body=documnet.body</span><br><span class="line">	body,html,body都是documnet的属性</span><br><span class="line">	获取所有节点的导航 var bodyEl=document.body</span><br><span class="line">	获取所有子节点 bodyEl.childNodes  换行符也属于text节点，注释是comment节点</span><br><span class="line">	获取下一个兄弟节点 bodyEl.nextSibling</span><br><span class="line">	前兄第节点 preSibling</span><br></pre></td></tr></table></figure>

<p>打印body的子节点</p>
<p><img src="https://img1.imgtp.com/2022/08/14/ehewKeMN.png" alt="屏幕截图 2022-05-18 100006.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/14/B3g8Atxi.png" alt="屏幕截图 2022-05-18 100042.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">64.获取子元素</span><br><span class="line">	bodyEl.children</span><br><span class="line">65.获取第一个子节点  bodyEl.firstElementChild    bodyEl.children[0]  </span><br><span class="line">	bodyEl.nextElementSibling</span><br><span class="line">66.Document和Element的关系</span><br><span class="line">   没有关系。document.body,body是他的属性，不是继承类，body:document.querySelectAll(&quot;body&quot;) ,所以Documnet和Element不是继承的关系，ELment是body的值</span><br><span class="line">67.table和form之间的导航</span><br><span class="line">68.document.getElementById(&quot;&quot;)</span><br><span class="line">   documnet.querySelector(&quot;&quot;)</span><br><span class="line">   document.querySlectorAll(&quot;&quot;)</span><br><span class="line">   document.getElementsByName(&quot;&quot;)</span><br><span class="line">   document.getElementsByTagName(&quot;&quot;)</span><br><span class="line">   document.getElementsByClassName(&quot;&quot;)//这3个是实时的</span><br><span class="line">69.NodeList是类数组对象，但是可以用forEach,可以用Array.from()转换成array</span><br><span class="line">70.节点类型判断</span><br><span class="line">	通过childNodes获取的节点判断节点类型用nodeType属性 1.元素节点 3.文本 8，注释节点</span><br><span class="line">71.nodeName获取节点名称，tagName元素名</span><br><span class="line">72.data用于非元素节点获取数据 innerHTML 获取元素 textContent获取文本</span><br><span class="line">	设置的时候，innerHTML和innerContent都可以设置文本，innerContent设置元素不会被解析为html元素，会当作普通文本</span><br><span class="line">	innerHTML 将会删除所有该元素的后代并以给出的 htmlString 替代</span><br><span class="line">	不是追加</span><br><span class="line">73.outerHTML会获取本身及其子元素</span><br><span class="line">74.常见全局属性 id style title class hidden:相当于设置display:none</span><br><span class="line">	on+事件</span><br><span class="line">75.attribute</span><br><span class="line">	html定义的是标准attribute</span><br><span class="line">	自定义的属性是非标准attribute</span><br><span class="line">		所有attribute都支持的方法</span><br><span class="line">			element.hasAttribute(e)</span><br><span class="line">			element.getAttribure(e)</span><br><span class="line">			element.setAttribute(e)</span><br><span class="line">			element.removeAttribute(e)</span><br><span class="line">			element.attributes-&gt;like array</span><br><span class="line">			</span><br><span class="line">			这些对大小写不敏感，而且返回值都是string</span><br><span class="line">76.property</span><br><span class="line">对象中的属性称为property</span><br><span class="line">元素中的属性称为attribute</span><br><span class="line">标准的attribute中在对应的对象模型中都有对用的property</span><br><span class="line">property和attribute会相互影响</span><br><span class="line">使用点语法也可以获得元素的属性</span><br><span class="line">77.className和classList</span><br><span class="line">	classList是可迭代对象</span><br><span class="line">78.style在js中要使用驼峰</span><br><span class="line">	多个样式可以使用style.cssText=&quot;&quot;这个不用写驼峰，但是会覆盖，不推荐</span><br><span class="line">78.style的读取getComputedStyle()，ele.style只能读取内联样式，就是直接在元素上定义的样式，</span><br><span class="line">widow.getComputedStyle(ele,[pseudoElt])可以读取所有的css属性，包括外部样式，但是getComputedStyle是只读属性</span><br><span class="line">79.data-*</span><br><span class="line">80.var el=document.createElement(&quot;element&quot;)//创建元素</span><br><span class="line">	el.className=&quot;&quot;</span><br><span class="line">	el.classList.add(&quot;&quot;)</span><br><span class="line">	boxel.append(el)//向父元素插入创建的元素，默认是插入最后</span><br><span class="line">	boxel.prepend(el)//添加到父元素的里面的最前面</span><br><span class="line">	boxel.before(el)//添加到元素的前面</span><br><span class="line">	boxel.after(el)//添加到元素后面</span><br><span class="line">	boxel.replacewith(...node|string)//替换元素</span><br><span class="line">	appendChild,insertbefore这些方法比较旧了</span><br><span class="line">81.el.remove()//将自己移除</span><br><span class="line">82.克隆var newEl=el.cloneNode()//默认是不会克隆子节点cloneNode(true)会克隆子节点</span><br><span class="line">83.获取元素的宽高 ele.width ele.height</span><br><span class="line">84.clientWidth:元素content+padding(不包含滚动条)</span><br><span class="line">	clientTop:border-top的宽度。clientLeft</span><br><span class="line">	offsetWidth:元素的完整宽度content+border+padding</span><br><span class="line">	offsetLeft 距离父元素左边的距离 offsetTop</span><br><span class="line">	scrollHeight 元素可滚动的高度</span><br><span class="line">	scrollTop 滚动条滚动的距离</span><br><span class="line">85.window的大小和滚动</span><br><span class="line">   window.outerWidth//</span><br><span class="line">   window.innerWidth//窗口的宽度，不包括调试窗口和工具栏</span><br><span class="line">   document.doeumnetElement.offsetWidth document.doeumnetElement.offsetHeight</span><br><span class="line">   window.scrollX  获取x轴的滚动位置 window.scrollY Y轴的滚动位置  也可以用别名pagexOffset  pageYOffset</span><br><span class="line">   设置滚动的位置 window.scrollBy(x,y)//在原来的位置基础上叠加滚动的位置</span><br><span class="line">   	window.scrollTo(x,y)//滚动到绝对的位置，到了位置不会变</span><br><span class="line">   	window.onscroll//监听滚动</span><br><span class="line">   	</span><br><span class="line">86.事件</span><br><span class="line">	on+event</span><br><span class="line">	ele.addEventListener(&quot;event&quot;,callback)</span><br><span class="line">87.事件流</span><br><span class="line">	事件冒泡</span><br><span class="line">	事件捕获</span><br><span class="line">	捕获阶段-》目标阶段-》冒泡阶段</span><br><span class="line">88.event常见属性方法</span><br><span class="line">	event.type:事件类型</span><br><span class="line">	event.target:目标元素</span><br><span class="line">	event.currentTarget:绑定事件的元素</span><br><span class="line">	event.offsetX</span><br><span class="line">	event.clientX</span><br><span class="line">	event.pageX</span><br><span class="line">	event.screenX</span><br><span class="line">	target和currentTarget的区别</span><br><span class="line">		target事件发生的对象，currentTarget是事件绑定的对象，如果</span><br><span class="line">		如果绑定事件的元素和触发事件的元素相同时，target===currentTarget</span><br><span class="line">	event.preventDefault()</span><br><span class="line">	event.propagetion()</span><br><span class="line">	</span><br><span class="line">	on+event中普通函数中this指向绑定事件的元素。addEentListener()也是一样</span><br><span class="line">89.EventTarget类</span><br><span class="line">	所有节点，元素都继承自eventtarget，window也是</span><br><span class="line">	eventTarget.removeEventListener(event,callbackName,)</span><br><span class="line">	eventTarget.dispatchEvent()</span><br><span class="line">90.事件委托</span><br><span class="line">91.import * from 是否包含export default</span><br><span class="line">	export &#123;&#125;和export const a ,export const b有区别吗</span><br><span class="line">92.&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">	box.click()//如果是id，也可以这样写但是不推荐</span><br><span class="line">92.常见的鼠标事件</span><br><span class="line">	onclick //只能接受event作为唯一的参数，且不用再调用的时候写</span><br><span class="line">	oncontextmenu</span><br><span class="line">	onmousedown</span><br><span class="line">	onmouseup</span><br><span class="line">	onmousemove</span><br><span class="line">93.mouseover和mouseenter的区别</span><br><span class="line">	mouseenter和mouseleave</span><br><span class="line">	不支持冒泡</span><br><span class="line">	进入子元素依然属于该元素只会触发子元素的mouseenter，父元素没反应</span><br><span class="line">	mouseover和mouseout</span><br><span class="line">	支持冒泡</span><br><span class="line">94.键盘事件</span><br><span class="line">	onkeydown</span><br><span class="line">	onkeypress</span><br><span class="line">	onkeyup</span><br><span class="line">	</span><br><span class="line">	event.code </span><br><span class="line">	event.key</span><br><span class="line">95.onfocus和onblur</span><br><span class="line">96.oninput和onchange</span><br><span class="line">99.表单事件 onsubmit onreset</span><br><span class="line">100.onload和DOMContentLoaded</span><br><span class="line">101.onresize</span><br><span class="line">102.定时器</span><br><span class="line">	setTimeout和setInterval是window的方法</span><br><span class="line">103.ontransitioned监听动画的结束后调用</span><br><span class="line">104.tab切换中切换.active的方法</span><br><span class="line">	1.for循环</span><br><span class="line">	2.使用documnet.queryslector(&quot;.active&quot;)修改</span><br><span class="line">	3.使用在外面进行变量记录</span><br><span class="line">105.BOM浏览器对象模型</span><br><span class="line">106.node:global==lobalThis</span><br><span class="line">	window:window==globalThis</span><br><span class="line">	放到window的属性全局都可访问</span><br><span class="line">	用var申明的全局对象都放到window对像中</span><br><span class="line">	var openWin=window.open(&quot;&quot;)//打开网址</span><br><span class="line">	window.close()//只能关闭通过open()打开的新的窗口</span><br><span class="line">107.window常见事件</span><br><span class="line">	window.onfocus</span><br><span class="line">	window.onblur</span><br><span class="line">	window.onhashchange</span><br><span class="line">108.location对象属性，用于表示window当前连接url信息</span><br><span class="line">	location.href//完整url</span><br><span class="line">	//url信息</span><br><span class="line">	location.hostname</span><br><span class="line">	location.host</span><br><span class="line">	loaction.protocol</span><br><span class="line">	location.port</span><br><span class="line">	location.pathname</span><br><span class="line">	location.hash</span><br><span class="line">	loacation.search</span><br><span class="line">	//location方法</span><br><span class="line">	loacation.assign()//打开新的网页，是加入历史记录站，可以返回</span><br><span class="line">	location.replace()//替代当前url,不可以返回</span><br><span class="line">	loaction.reload()//重新加载</span><br><span class="line">109.URLSearchParams</span><br><span class="line">	var searchParams=new URLSearchParams(str)</span><br><span class="line">	get(&quot;name“)</span><br><span class="line">	append(&quot;address&quot;,&quot;zzzz&quot;)</span><br><span class="line">	has()</span><br><span class="line">	set()</span><br><span class="line">	URLSearchParams可以使用for...of</span><br><span class="line">	中文使用encodeURLComponment和decodeURLComponment进行编解码</span><br><span class="line">	for (const [key, value] of searchParams) &#123;&#125;</span><br><span class="line">	for (const [key, value] of searchParams.entries()) &#123;&#125;</span><br><span class="line">110.history</span><br><span class="line">//属性</span><br><span class="line">	history,length</span><br><span class="line">	history.state</span><br><span class="line">//修改history</span><br><span class="line">	history.pushState(&#123;name:&quot;mike&quot;,age:18&#125;)</span><br><span class="line">	hsitory.back()</span><br><span class="line">	history.forword()</span><br><span class="line">	history.go(-2)</span><br><span class="line">	replacestate()</span><br><span class="line">111.json</span><br><span class="line">	var item=JSON.stringfy(item)</span><br><span class="line">	var item=JSON.parse(item)</span><br><span class="line">	json的方法还可以实现深拷贝var obj=JSON.parse(JSON.strigfy(obj1))</span><br><span class="line">112.protobuf</span><br><span class="line">113.&amp;gt; &amp;lt;</span><br><span class="line">114.&lt;button onclick=&quot;add()&quot;&gt;按钮&lt;/button&gt;//再元素上事件的写法</span><br><span class="line">115./* 设置图片水平方向和垂直方向上自动居中，随着浏览器大小的变化 */</span><br><span class="line">.img_center&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  transform: translate(-50%,-%50);</span><br><span class="line">  left: 50%;</span><br><span class="line">  top:50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>116.</p>
<p><img src="https://img1.imgtp.com/2022/08/14/lwe19xZA.png" alt="屏幕截图 2022-05-25 175414.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">117.this的指向</span><br><span class="line">	1.this的指向是由函数调用执行的时候决定的</span><br><span class="line">	2.this的绑定分为：默认绑定：独立函数调用this是指向window,例如fn()</span><br><span class="line">					隐式绑定：对象中this的指向是指向调用的对象，例如obj.fn()</span><br><span class="line">					显示绑定:通过call,apply,bind来进行显示绑定下，this指向绑定的对象</span><br><span class="line">					new的绑定：通过new创建的对象，this会指向新创建的对象</span><br><span class="line">	3.this指向的优先级：new&gt;显示绑定&gt;隐式绑定&gt;默认绑定</span><br><span class="line">	4.箭头函数是没有this,arguments，是由上层函数作用域来决定，一层一层作用域找</span><br><span class="line">		注意：</span><br><span class="line">		var name=&quot;mike&quot;</span><br><span class="line">		var obj=&#123;</span><br><span class="line">			</span><br><span class="line">			foo()&#123;</span><br><span class="line">				return ()=&gt;&#123;</span><br><span class="line">					console.log(this.name)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;//this会先去foo中去找，找不到就去全局作用域，对象中没有作用域</span><br><span class="line">		不可以使用显示绑定改变this的指向</span><br><span class="line">	5.显示绑定中如果指向的是一个基本数据类型，如果有包装类型则转换成包装类</span><br><span class="line">	6.setTimeout中的this默认指向window</span><br><span class="line">	7.forEach中this默认指向window，可以通过第二个参数修改</span><br><span class="line">	8.事件绑定中this指向绑定的元素</span><br><span class="line">	9.new不可以和apply和call一起使用</span><br><span class="line">	10.bind的优先级高于call/apply</span><br><span class="line">	11.new的优先级高于bind</span><br><span class="line">	12.间接函数引用：</span><br><span class="line">		1.(obj1.foo=obj2.foo)()这样直接调用，this是默认绑定指向window</span><br><span class="line">		2.(b=person.sauName)()   //window</span><br><span class="line">	13.foo.apply(null)/foo.apply(undefined)指向window</span><br><span class="line">		</span><br><span class="line">	14.箭头函数可以替代var _this=this来替代，可以获得上层作用域</span><br><span class="line">118. Array.prototype.slice 来将一个类似于数组的对象（array-like object）转换成一个真正的数组，Aaary.prototye.slice.apply()/bind()</span><br><span class="line">119.html解析过程中，遇到css文件会下载，但是不会阻止html的解析，但会阻塞render的渲染过程</span><br><span class="line">120.回流和重绘</span><br><span class="line">121.script</span><br><span class="line">	defer js的下载和执行不阻塞Dom tree的构建</span><br><span class="line">	defer代码执行的时候Dom构建完成，defer会在DomContentLoad以后执行</span><br><span class="line">	多个defer顺序执行</span><br><span class="line">	defer推荐放在head中</span><br><span class="line">	defer仅适用于外部脚本，对script的内容会忽略</span><br><span class="line">	</span><br><span class="line">	async 多个async不能保证顺序执行，不会组设Dom渲染。不能保证DOMContentLoaded之前或者之后执行行</span><br><span class="line">	async用于独立脚本，没有外部依赖</span><br><span class="line">122.函数的执行是在函数执行上下文中执行</span><br><span class="line">123.函数的作用域链再函数创建时就确定了。每个执行上下文都有自己的作用域链</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/hbsvpJ1A.png" alt="屏幕截图 2022-05-29 114030.png"></p>
<p>当查找变量的时候，函数首先会在local中寻找，找不到再去上层作用作用域寻找，而这个函数的上层作用域是Window</p>
<p><img src="https://img1.imgtp.com/2022/08/14/YJJTxHz8.png" alt="屏幕截图 2022-05-29 120154.png"></p>
<p>124.垃圾回收器</p>
<p>​        1..引用计数</p>
<p>​                    当一个对象有一个引用指向它时，那么这个对象的引用就+1</p>
<p>​                    当一个对象的引用为0时，这个对象就可以销毁掉</p>
<p>​                    这个算法有一个回答的弊端就是会产生循环引用</p>
<p>​        2.标记清除</p>
<p>​        3.标记整理</p>
<p>​        4.分代收集</p>
<p>​        5.增量收集</p>
<p>​        6.闲时收集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><span class="line">125.闭包</span><br><span class="line">	1.狭义：函数引用外层函数的自由变量就是闭包。</span><br><span class="line">	2.通过返回一个函数，外部可以通过这个函数访问这个函数所在作用域链的变量，闭包可以突破作用域链</span><br><span class="line">126.GUI的渲染和js的执行是在同一个线程，是互斥的</span><br><span class="line">127.foo.name,获取函数名</span><br><span class="line">	foo.length//获取行参个数，不会把剩余参数和默认参数计算在内，</span><br><span class="line">	arguments//类数组对象，可以通过下标获取值，有length属性，是可迭代对象，但是本身不可以使用数组的方法，可以通过Array.prototype.map.call(arguments)来使用</span><br><span class="line">	argument转array</span><br><span class="line">	1.for循环，将argument一个个放到数组中</span><br><span class="line">	2.Array.from(argumsnets)</span><br><span class="line">	3.[...arguments]</span><br><span class="line">	4.var arr=Array.prototype.slice.call/apply(arguments)//会截取整段，并返回新的数组</span><br><span class="line">		或者var arr=[].slice.call/apply(arguments)</span><br><span class="line">		箭头函数没有argments,会去上层作用域去找arguments</span><br><span class="line">128.剩余参数   剩余参数必须放到最后</span><br><span class="line">129.剩余参数和argument的区别</span><br><span class="line">	剩余参数是数组，可以使用所有数组方法，arguments是类数组</span><br><span class="line">	剩余参数只包含没有对应形参的实参，arguments包含所有参数</span><br><span class="line">130.纯函数</span><br><span class="line">	相同的输入产生相同的输出，</span><br><span class="line">	不会产生副作用</span><br><span class="line">	不依赖外部变量</span><br><span class="line">	确定输出</span><br><span class="line">	不能修改外部变量</span><br><span class="line">	作用：</span><br><span class="line">		只是单纯的实现自己的业务，不需要关注外部的数据变化</span><br><span class="line">131.函数柯里化</span><br><span class="line">	就是把接受多个函数的函数变成返回接受单一参数的函数</span><br><span class="line">	</span><br><span class="line">	var foo=x=&gt;y=&gt;z=&gt;console.log(x+y+z)shiyo</span><br><span class="line">132.async默认会返回promise</span><br><span class="line">	async的返回值会被promise包裹，相当于Promise.resolve()</span><br><span class="line">	await 后面是一个promsie,则会返回Promise.resolve(res)的值</span><br><span class="line">	如果不是promise，则用Promise.resolve(res)包裹</span><br><span class="line">	await 使用trycatch捕获异常	</span><br><span class="line">133.封装自动转化成柯里化函数</span><br><span class="line">134.组合函数</span><br><span class="line">	组合函数的封装</span><br><span class="line">135.Function.prototype.name   Function.prototype.length Function.prototype.displayName</span><br><span class="line">136.with(obj)&#123;</span><br><span class="line">	console.log(message)//扩展一个语句的作用域链，它首先会去obj里面去找，找不到再去上层作用域找，但是不推荐使用</span><br><span class="line">&#125;</span><br><span class="line">137.eval()</span><br><span class="line">138.严格模式</span><br><span class="line">	开启严格模式的方式</span><br><span class="line">	class和module会自动开启严格模式</span><br><span class="line">	严格模式的限制</span><br><span class="line">		1.无法意外创建全局变量</span><br><span class="line">		2.引起静默模式失败</span><br><span class="line">		3.不能用with</span><br><span class="line">		4.this默认指向undefined,this不会装换成包装类</span><br><span class="line">139.Object.defineProperty(obj,prop.descriptor)</span><br><span class="line">	属性描述符的分类</span><br><span class="line">		1.数据属性描述符：configurable:表示这个属性是否可删除,默认值是false，使用delete不嫩删除，如果设置为false,则不可以配置了，后续其他属性描述符也不可以使用了。就是Configurable:false,后续不可以对这个属性使用Object.defineProperty配置。</span><br><span class="line">		enumerable:是否可以枚举属性，false:forin,Object.keys()这些都不可以美剧，默认是true</span><br><span class="line">		writable:是否可以写入，默认是可以写入，设置为false是只读属性</span><br><span class="line">		value:&quot;mike&quot;,设置属性值</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		如果使用字面量创建对象，则所有属性描述符都是true,object.defineProperty()设置的属性的value</span><br><span class="line">		的优先级会比字面量创建的属性设置的值高</span><br><span class="line">		2.存取属性描述符</span><br><span class="line">		get</span><br><span class="line">		set</span><br><span class="line">		</span><br><span class="line">		wiritable,value和get,set不可以同时使用</span><br><span class="line">140.Object.defineProperties()//同时设置多个属性描述符</span><br><span class="line">141.Object.getOwnPropertyDescriptor(obj, &quot;name1&quot;)//获取某个属性描述符</span><br><span class="line">142.Object.getOwnPropertyDescriptors(obj)//获取所有属性描述符</span><br><span class="line">143.Object.preventExtensions(obj);//不允许扩展属性</span><br><span class="line">144.object.seal(obj)//密封对象，不允许配置和删除属性，增加新的属性</span><br><span class="line">145.Object.freeze(obj)//不能修该现有属性，也不能增加新的属性</span><br><span class="line">146.原型和原型链</span><br><span class="line">	__proto__是浏览器加，非标准的，要看各个浏览器如何实现，建议使用Object.getPrototypeOf(obj)来获取对象的原型</span><br><span class="line">	__proto__隐式原型</span><br><span class="line">	prototype显式原型</span><br><span class="line">	所有的对象都有隐式原型，函数有隐式原型和显示原型</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	当对象获取值的时候p1.address如果实例对象没没有这个属性则会到他的原型练上去寻找</span><br><span class="line">	当对象属性赋值的时候，如果该属性不存在则会在当前对象中新建一个属性赋值，不会修改原型链上的属性的值</span><br><span class="line">	p1.address=&quot;us&quot;//这样不会对原型链上的该属性进行修改</span><br><span class="line">	如果要对原型的属性进行修改：Person.prototype.address=&quot;japan&quot;</span><br><span class="line">	Person.prototype=&#123;</span><br><span class="line">		message:&quot;章&quot;,</span><br><span class="line">		info:&#123;&#125;,</span><br><span class="line">		eating:function()&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;,</span><br><span class="line">		constructor:Person</span><br><span class="line">	&#125;//修改Person的显示原型指向新的对象</span><br><span class="line">	p1.__proto_===Object.prototype</span><br><span class="line">	constructor应该是不可以枚举的，要用Object.deineProperty()来修改定义</span><br><span class="line">	原型链：实例对象在查找某个属性的时候，他先去自己对象寻找，然后再去原型链里面去找，直到找到null为止</span><br><span class="line">147.面向对象的特性:封装，继承，多态</span><br><span class="line">148.使用new关键字创建对象的过程</span><br><span class="line">	1.创建一个空对象</span><br><span class="line">	2.让这个对象的[[prototype]]属性指向该构造函数的prototype对象</span><br><span class="line">	3.让构造函数的中的this指向新创建的对象</span><br><span class="line">	4.执行该构造函数</span><br><span class="line">	5.如果构造函数没有返回一个非空对象，则返回新创建出来的对象</span><br><span class="line">149.原型链的继承</span><br><span class="line"></span><br><span class="line">	1.Student.prototype=Person.prototype//这种继承虽然可以继承到Person的方法，但是添加student的方法的时候，会添加到Person原型上，对Person和Student都会有影响</span><br><span class="line">	2.原型链继承</span><br><span class="line">	student.prototype=new Person()//改善上面一种方法，不会对Person.prototype上的方法进行干扰</span><br><span class="line">	但是，如果有和Person相同的属性的时候例如</span><br><span class="line">	function Student(age,gender,name,weight)&#123;</span><br><span class="line">		this.age=age;</span><br><span class="line">		this.gender=gender;</span><br><span class="line">		this.name=name;</span><br><span class="line">		this.weight=weigth</span><br><span class="line">	&#125;</span><br><span class="line">	age,gender属性在pERson里面也有，这样会有代码重复的问题，但是可以获取到自己的age,gender</span><br><span class="line">	如果不写，调用的时候是获取到Person的age和gender,多个实例共享相同的属性了</span><br><span class="line">	3.借用构造函数继承</span><br><span class="line">	  function Student(age,gender,name,weight)&#123;</span><br><span class="line">	  	Person.call(this,age,gender)</span><br><span class="line">	  	this.name=name;</span><br><span class="line">		this.weight=weigth</span><br><span class="line">	  &#125;</span><br><span class="line">	  使用这个方法可以实现属性的继承</span><br><span class="line">	  将2，3方法结合起来就是组合继承</span><br><span class="line">	  student.prototype=new Person(age,gender)//继承父类的方法</span><br><span class="line">	   function Student(age,gender,name,weight)&#123;</span><br><span class="line">	  	Person.call(this,age,gender)//这样没有调用父类的constructor</span><br><span class="line">	  	this.name=name;</span><br><span class="line">		this.weight=weigth</span><br><span class="line">	  &#125;</span><br><span class="line">	  缺点：new student的时候构造函数会调两次，一次Person,一次student，拥有两份父类属性，父类的静态属性和静态方法也没有继承</span><br><span class="line">	  4.寄生组合继承</span><br><span class="line">	  function Student(age,gender,name,weight)&#123;</span><br><span class="line">	  	Person.call(this,age,gender)</span><br><span class="line">	  	this.name=name;</span><br><span class="line">		this.weight=weigth</span><br><span class="line">	  &#125;</span><br><span class="line">	  inhert(Student,Person)</span><br><span class="line">	  Object.assign(Student, Person);//继承静态属性和方法(或者称为类方法或者类属性)</span><br><span class="line">150.原型式继承函数</span><br><span class="line">		// 使用这个方法来处理Object.create()的兼容性问题</span><br><span class="line">        function createObject(o) &#123;</span><br><span class="line">          function F() &#123;&#125;</span><br><span class="line">          F.prototype = o;</span><br><span class="line">          return new F();</span><br><span class="line">        &#125;</span><br><span class="line">        // 封装工具函数实现继承</span><br><span class="line">        function inhert(Subtype, Supertype) &#123;</span><br><span class="line">        	//Subtype.prototype.__proto__=Supertype.prototype</span><br><span class="line">        	//Object.setPrototypeOf(Subtype.prototype,Supertype.prototype)</span><br><span class="line">          // Subtype.prototype = createObject(Supertype.prototype);</span><br><span class="line">          Subtype.prototype = Object.create(Supertype.prototype);//Object.create()不会调用constructor</span><br><span class="line">          Object.defineProperty(Subtype, &quot;constructor&quot;, &#123;</span><br><span class="line">            configurable: false,</span><br><span class="line">            enumerable: false,</span><br><span class="line">            value: Subtype,</span><br><span class="line">            writable: true,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">	  </span><br><span class="line">	  //对象之间的继承</span><br><span class="line">	  	function object(o)&#123;</span><br><span class="line">	  		var obj=&#123;&#125;</span><br><span class="line">	  		obj.__proto__=o.prototype//Object,setPrototypeOf(obj,o.prototype)</span><br><span class="line">	  		return obj</span><br><span class="line">	  	&#125;</span><br><span class="line">151.Object是所有类的父类</span><br><span class="line">152.obj.hasOwnProperty()、//判断是否在自己身上</span><br><span class="line">	&quot;name&quot; in obj//判断属性是否在obj的里面或者原型链上</span><br><span class="line">	for in 遍历原型链可枚举属性和方法</span><br><span class="line">	instanceOf</span><br><span class="line">	Person.protytype.isPrototypeOf(stu)//判断实例是否在莫格原型链上，判断对象之间的继承</span><br><span class="line">153.对象具备__proto__属性。函数有__proto__和prototype属性</span><br><span class="line">154.Person.run()//这个调用的是类方法，protoytype上面的方法是实例方法</span><br><span class="line">155.class定义类</span><br><span class="line">	class会有默认的constructor</span><br><span class="line">	class是的构造函数、原型链的语法糖</span><br><span class="line">156.对象中访问器的写法</span><br><span class="line">	var obj = &#123;</span><br><span class="line">  name: &quot;mike&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">//对象访问器的写法一</span><br><span class="line">Object.defineProperty(obj, &quot;name&quot;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  get() &#123;</span><br><span class="line">    return obj.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(value) &#123;</span><br><span class="line">    obj.name = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//对象访问器的写法二</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  name: &quot;zhang&quot;,</span><br><span class="line">  get getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  set setName(value) &#123;</span><br><span class="line">    this.name = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">//三</span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this._name;</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    this._name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">157.类方法/static方法中的this指向类本身</span><br><span class="line">158.class的继承 extend</span><br><span class="line">159.面向对象的三大特性：封装，继承，多态</span><br><span class="line">	多态的条件：1。必须实现继承</span><br><span class="line">			  2.必须有父类引用指向子类对象</span><br><span class="line">			  3.js中可以说到处是多态</span><br><span class="line">160.对象字面量增强：</span><br><span class="line">	1.属性的增强</span><br><span class="line">		var name=&quot;why&quot;</span><br><span class="line">		var obj=&#123;</span><br><span class="line">			name</span><br><span class="line">		&#125;</span><br><span class="line">	2.方法的增强</span><br><span class="line">		var obj=&#123;</span><br><span class="line">			eating()&#123;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	3.计算属性名</span><br><span class="line">		obj=&#123;</span><br><span class="line">			[name]:</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">161.数组的解构和对象的解构</span><br><span class="line">	const [name1,name2,name3]=arr</span><br><span class="line">	const &#123;age,name,color&#125;=obj</span><br><span class="line">	</span><br><span class="line">	const [name1,name2,...name3]=arr//将剩下的元素放入name3数组中</span><br><span class="line">	</span><br><span class="line">	const [name1,name2,name3=&quot;default&quot;]=arr//设置默认值</span><br><span class="line">	</span><br><span class="line">	//对象的解构是没有顺序的，根据Key来进行解构</span><br><span class="line">	//对象解构的重命名</span><br><span class="line">	  const &#123;age:age1,name:name1&#125;=obj//重命名为age1,name1</span><br><span class="line">	 //对象解构默认值默认值</span><br><span class="line">	 const &#123;age:age1=18,...other&#125;=obj1//可以使用剩余运算符和默认值</span><br><span class="line">162.手写apply,call,bind</span><br><span class="line">163.词法环境</span><br><span class="line">	词法环境由环境记录和外部词法环境两部分组成</span><br><span class="line">	一个执行上下文关联两个环境</span><br><span class="line">		LexicalEnvironment和VariableEnvirment</span><br><span class="line">		LexicalEnvironment用于处理let和const</span><br><span class="line">		VariableEnvirment用于处理var,function</span><br><span class="line">164.https://262.ecma-international.org/8.0/</span><br><span class="line">165.let和const</span><br><span class="line">	let/const不可以重复声明</span><br><span class="line">	const声明的是引用类型则可以修改const指向的地址的内部的变量，但不可以修改const的指向</span><br><span class="line">	let/const不会出现变量提升，必须先声明再使用，否则会出现暂时性死区</span><br><span class="line">	let/const会提前创建出来，但是不可以被访问，只有赋值的时候才可以访问</span><br><span class="line">	暂时性死区取决于代码执行的顺序，和定义的位置没有关系</span><br><span class="line">	</span><br><span class="line">	var定义的全局变量默认会添加到window上。而let/const不会再window添加任何属性</span><br><span class="line">	var 会被添加到 object environment record而const /let会被添加到decaretive environment record</span><br><span class="line">166.块级作用域</span><br><span class="line">	let/const/function/class声明是有块级作用域的，</span><br><span class="line">	foo()//在这之前不可以访问</span><br><span class="line">	&#123;</span><br><span class="line">		function foo()&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	foo()//这样可以访问</span><br><span class="line">	浏览器做了特殊处理，可以让块级作用域里面的函数在块级作用域之后被访问</span><br><span class="line">167.立即执行函数会形成闭包，形成自己的作用域</span><br><span class="line">168.for(let i=0;i&lt;btnEls.length;i++)&#123;</span><br><span class="line">	var btnEl=btnEls[i]</span><br><span class="line">	btnEl.onclick=function()&#123;</span><br><span class="line">	console.log(`点击了$&#123;i&#125;按钮`)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;//会形成4个词法环境，每个词法环境都会保存着自己的i，function引用外层的词法环境，所以执行完外层词法不会被销毁，当需要i的时候，会往上层寻找，因为当前词法环境中保存着i</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/frDfleO9.png" alt="QQ截图20220606172932.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/14/3FHLdHM8.png" alt="QQ截图2022060617452911.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">169.模板字符串</span><br><span class="line">	1.普通模板字符串</span><br><span class="line">	2.标签模板字符串</span><br><span class="line">170,函数默认值</span><br><span class="line">	function foo(arg1,arg2)&#123;</span><br><span class="line">		arg1=arg1?arg1:0</span><br><span class="line">		arg1=arg1||0</span><br><span class="line">		arg1=(arg===null)||(arg1===undefined)?0:arg1</span><br><span class="line">		//es6</span><br><span class="line">		arg1=arg1??&quot;我是默认值&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	foo(arg1,arg2=&quot;why&quot;)&#123;&#125;//默认参数最好放后面</span><br><span class="line">	剩余参数也是放在后面，如果两个都有的话，剩余参数放后面</span><br><span class="line">	function foo(&#123;name,age&#125;=&#123;name=&quot;why&quot;,age=18&#125;)&#123;</span><br><span class="line">	console.log(name,age)//对传入的对象进行解构赋值，给默认值</span><br><span class="line">	&#125;</span><br><span class="line">	function foo(&#123;name=&quot;why&quot;,age=18&#125;=&#123;&#125;)&#123;</span><br><span class="line">		console.log(name,age)//对象参数的解构赋值，如果传入的参数</span><br><span class="line">		中没有该值name,age，则给name,age赋值</span><br><span class="line">	&#125;</span><br><span class="line">	默认参数不计算在argument内</span><br><span class="line">171.箭头函数没有显示原型，不可以作为构造函数，不能通过new创建</span><br><span class="line">172.展开运算符</span><br><span class="line">	var obj=&#123;</span><br><span class="line">		name:&quot;why&quot;,</span><br><span class="line">		age:18</span><br><span class="line">	&#125;</span><br><span class="line">	foo(...obj)//这样来用是不可以的，因为函数参数必须是可迭代对象</span><br><span class="line">173.浅拷贝：就是将对象里面的内容赋值到新的对象里面，如果对象里面还有对象，则只会复制对象的引用</span><br><span class="line">			就是浅拷贝只会拷贝第一层对象</span><br><span class="line">			浅拷贝的方法可以使用展开运算符和Object.assign()</span><br><span class="line">			</span><br><span class="line">174.ele.append()和ele.appendChild()的区别</span><br><span class="line">	append参数可以是node/string appendChild只能是Node,append()没有返回值，appendChild会返回插入值本身，append可以追加多个字符串、node，而appendChild只能加一个节点</span><br><span class="line">175.数值的表示</span><br><span class="line">176.Symbol</span><br><span class="line">	const s1=Symbol()</span><br><span class="line">	const obj=&#123;</span><br><span class="line">		[s1]:&quot;aaaa&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	//对象中key可以是string/Symbol</span><br><span class="line">	由Symbol()生成是独一无二的</span><br><span class="line">177.set</span><br><span class="line">	存储任何类型的唯一的值</span><br><span class="line">	const set=new Set()</span><br><span class="line">	set.add(dd)</span><br><span class="line">	set.has(dd)</span><br><span class="line">	set.size//获取元素数量</span><br><span class="line">	set.delete(value)//删除元素</span><br><span class="line">	clear(set)//清空</span><br><span class="line">	set.forEach()//可以用于数组的遍历</span><br><span class="line">	set.keys()</span><br><span class="line">	set.values()//keys()和values的返回值是相同的</span><br><span class="line">	set.entry()//返回值为[value,value]</span><br><span class="line">	forof</span><br><span class="line">	数组去重</span><br><span class="line">	const newArr=Array.from(new Set(arr))/[...new Set(arr)]</span><br><span class="line">	Set中NaN===NaN</span><br><span class="line">	</span><br><span class="line">178.WeakSet</span><br><span class="line">	WeakSet是弱引用，可以被垃圾回收器回收</span><br><span class="line">	weakSet只能存储对象</span><br><span class="line">	weakSet对对象都是弱引用的，所以不可以遍历</span><br><span class="line">	WeakSet中由has(),add(),delete()</span><br><span class="line">	它和 Set 对象的区别有两点：</span><br><span class="line">    与Set相比，WeakSet 只能是对象的集合，而不能是任何类型的任意值。</span><br><span class="line">    WeakSet持弱引用：集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 WeakSet 中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/EzcYmE14.png" alt="QQ截图20220608150415.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">179.Map</span><br><span class="line">map也是可迭代对象</span><br><span class="line">map可以使用任何数据类型作为key,而Object只可以使用string、symbol作为key</span><br><span class="line">const map=new Map()</span><br><span class="line">map.set(info,&quot;999&quot;)</span><br><span class="line">map.delete(info)</span><br><span class="line">map.has(info)</span><br><span class="line">clear(map)</span><br><span class="line">forEach</span><br><span class="line">map.get(info)</span><br><span class="line">forof</span><br><span class="line">180.Map和Object的区别</span><br><span class="line">181.WeakMap</span><br><span class="line">	key只能是对象，对对象的引用是弱引用，如果没有其他引用引用该对象，他就会被GC回收</span><br><span class="line">	weakMap的key是不可以枚举的，不可以遍历</span><br><span class="line">	不能使用forof,forEach进行遍历</span><br><span class="line">	delete(key)</span><br><span class="line">	get(key)</span><br><span class="line">	has(key)</span><br><span class="line">	set(key,value)</span><br><span class="line">	</span><br><span class="line">	weakMap可以解决Map可能导致内存泄漏的问题，因为数组会一值引用每一个key,value</span><br><span class="line">	参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap</span><br><span class="line">182.Array.prototype.includes(item)</span><br><span class="line">183.Math.pow()/**</span><br><span class="line">184.Object.values(obj)</span><br><span class="line">185.Object.keys(obj)</span><br><span class="line">186.Object。entries(obj)//obj可以是对象，数组，字符串</span><br><span class="line">	获取的数组和forin遍历的顺序是一致的，但是不会遍历原型链上的属性和方法</span><br><span class="line">187.String.prototype.padStart(总长度,填充字符串)//字符串填充 会返回新的字符串</span><br><span class="line">	例如隐藏只显示身份证的部分数字，其余部分填充*</span><br><span class="line">188.Object.getOwnPropertyDescriptors</span><br><span class="line">189.Array.prototype.flat(number)//将多维数组扁平化</span><br><span class="line">190.Array.prototype.flatMap(callback(currval,index,arr))//相当于先使用map再使用flat(1)进行扁平化</span><br><span class="line">191.数组扁平化的方法</span><br><span class="line">192.Object.fromEntries(entries)//把entry转换成Obj</span><br><span class="line">	将queryString转换成对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/cVkjgfjQ.png" alt="QQ截图20220608171027.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">193.空值合并运算符 ??</span><br><span class="line">194.str.trim()/trimStart()/trimRight()</span><br><span class="line">195.可选链操作符  ?.</span><br><span class="line">	可以替代</span><br><span class="line">	if(obj.friend&amp;&amp;obj.friend.running)&#123;</span><br><span class="line">	obj.friend.running()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	obj?.friend?.running?.()</span><br><span class="line">196.WeakRef//暂时不建议使用</span><br><span class="line">197.逻辑赋值运算符</span><br><span class="line">	message=message||&quot;默认值&quot;=&gt;message||=&quot;默认值&quot;</span><br><span class="line">	message??=&quot;默认值&quot;</span><br><span class="line">	obj&amp;&amp;obj.friend&amp;&amp;obj.friend.running()</span><br><span class="line">198.const new=str.replaceAll()//替换所有匹配到的字符串  原始字符串保持不变。</span><br><span class="line">199.str.at(index)</span><br><span class="line">200.Object.hasOwn(obj,propKey)</span><br><span class="line">//可以替代obj.hasOwnProperty(prop),因为hasOwnProperty()可能会被使用者重写</span><br><span class="line">const info=Object.create(null)//这样创建的对下个原型指向null</span><br><span class="line">info.name=&quot;why&quot;</span><br><span class="line">info.hasOwnProperty(name)//由于原型指向null,所以获取不到hasOwnProperty方法</span><br><span class="line">需要使用Object.hasOwn()替代</span><br><span class="line">201.Object.create()</span><br><span class="line">	创建一个新对象，使用现有的对象来提提供新创建对象的__proto__</span><br><span class="line">	Object.create(proto,[prppertiesObject])</span><br><span class="line">202.Class Person&#123;</span><br><span class="line">	height=1.88//在这里写的时候，new创建对象时也会被添加到新的对象里面，再class内部可以通过					this来访问</span><br><span class="line">	constructor(name,age)&#123;</span><br><span class="line">	this.name=name</span><br><span class="line">	this.age=age</span><br><span class="line">	this.address=&quot;广州市&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static &#123;</span><br><span class="line">		//静态代码块</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line">203.proxy</span><br><span class="line">	Object.defineProperty()的缺点，不可以监听到对象属性的新增和删除操作，新增的属性也没办法监听，只能监听属性，不能监听整个对象</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/EQg1fUBC.png" alt="QQ截图20220609114316.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy是监听整个对象，他有13个捕获器，这些捕获器可以劫持对象的一些操作用proxy替代obj操作</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/aIkHlWXU.png" alt="QQ截图20220609115247.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">204.Reflect的作用</span><br><span class="line">Reflect是为了替代Object中的一些方法</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/KQev7yPJ.png" alt="QQ截图20220609153635.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/14/0fcGhnc0.png" alt="QQ截图20220609153658.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/14/MDMfI710.png" alt="QQ截图20220609153711.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">205.Reflect.construct的作用</span><br><span class="line">Reflect.construct(target, argumentsList[, newTarget])</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/BXFFyjjm.png" alt="QQ截图20220609155310.png"></p>
<p>​    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">206.new.target作用</span><br><span class="line">207.promise</span><br><span class="line">	三种状态：</span><br><span class="line">		pending</span><br><span class="line">		fulfilled</span><br><span class="line">		rejected</span><br><span class="line">		状态发生改变，就不可以更改</span><br><span class="line">		</span><br><span class="line">		resolve(value)//value会作为then方法中的回调函数的参数</span><br><span class="line">		1.普通值则作为参数直接传过去</span><br><span class="line">		2.如果传入的是promise,则由promise的中的·resolve参数决定</span><br><span class="line">		3.thenable对象则会执行then方法并且由then方法中的reslove的参数决定</span><br><span class="line">		</span><br><span class="line">		then()//可以传两个参数，成功的回调和失败的回调</span><br><span class="line">		catch()//失败的回调</span><br><span class="line">208.Window.getComputedStyle(ele,prop?)和Element.getBoundingClientRect()的区别</span><br><span class="line">	getComputedStyle是定义在window上的方法，getBoundingClientRect是Element的方法，getComputedStyle返回值是CSS属性值，而getBoundingClientRect返回的是具体的位置信息</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/OJQOJUb1.png" alt="QQ截图20220611104648.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">209.Promise.prototype.then()//返回值是一个promise,链式调用中，then会等待上一个then的返回值promise的状态来决定</span><br><span class="line">	const promise=new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">		resolve(111)</span><br><span class="line">	&#125;)</span><br><span class="line">	promise.then(res=&gt;&#123;</span><br><span class="line">		return res</span><br><span class="line">	&#125;).then(res=&gt;&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;)</span><br><span class="line">	then的返回值</span><br><span class="line">		1.普通值则会直接包裹成promise返回</span><br><span class="line">		2. new Promise 则有这个promise的状态来决定</span><br><span class="line">		3.有thenable方法的对象，则由thenable方法的状态来决定</span><br><span class="line">	then抛出异常时，就处于reject状态，则会调用后面的catch</span><br><span class="line">	then return 时处于fulfilled</span><br><span class="line">	then没有返回值则不会继续调用then</span><br><span class="line">210.Promsie.prototype.catch()</span><br><span class="line">	catch 里面调用return的时候默认状态是fuifilled,他的返回值是一个promise</span><br><span class="line">	和then一样</span><br><span class="line">	如果向继续链式调用catch，需要抛出异常</span><br><span class="line">	当promise中调用reject的时候，会调用最近catch</span><br><span class="line">	没有返回值时不会继续链式调用</span><br><span class="line">211.中断函数的执行</span><br><span class="line">		return</span><br><span class="line">		throw</span><br><span class="line">		前两种会直接结束函数的执行</span><br><span class="line">		yield</span><br></pre></td></tr></table></figure>

<p><img src="https://img1.imgtp.com/2022/08/14/ws0WolVm.png" alt="QQ截图20220612095542.png"></p>
<p>212.Promise.prototype.finally(callback)    </p>
<p>​        无论Promise对象变成fulfilled还是rejected状态，最终都会执行</p>
<p>​        finally方法的回调函数参数是不接受参数的</p>
<ol start="213">
<li><p>Promise.resolve()相当于new Promsie()并且执行resolve方法。</p>
<p>就是希望将变量转换成Promise来使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&quot;why&quot;)==&gt;new Promsise((resolve)=&gt;resolve(&quot;why&quot;))</span><br><span class="line">参数和resolve一样</span><br></pre></td></tr></table></figure></li>
<li><p>Promise.reject() reject方法类似于resolve方法，只是会将Promise对象的状态设置为reject状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&quot;why&quot;)=&gt;new Promise((_,reject)=&gt;reject(&quot;why&quot;))//_不传可以这样写</span><br><span class="line">Promsie.reject无论传什么参数都是rejected</span><br></pre></td></tr></table></figure></li>
<li><p>Promsie.all([])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">他的作用是将对各promise,放入到数组中执行，all方法的最终状态是由数组中的所有promisek结果决定的，如果Promise所有状态都是fulfilled状态则Pramise.all的状态为fulfilled，并且将所有数组中的promise的返回值做成一个数组返回</span><br><span class="line">如果数组中出现一个promise状态为rejected则all的状态也会变成rejected,并将第一个reject的返回值作为参数</span><br><span class="line">Promsie.all([p1,p2,p3]).then(res=&gt;res).catch(err=&gt;err)</span><br></pre></td></tr></table></figure></li>
<li><p>Promise.allSettled([])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promsie.allSettled([p1,p2,p3]).then(res=&gt;res)</span><br><span class="line">//状态都是fulfilled,会返回一个[&#123;stattus:fulfilled/rejected,value:&quot;&quot;&#125;]</span><br></pre></td></tr></table></figure></li>
<li><p>Promsie.race([])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rece的状态由[]中的promise那个先完成的状态来决定的</span><br></pre></td></tr></table></figure></li>
<li><p>Promise.any([])</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只要[]中的promise中的第一个变成fulfilled的状态来决定的，返回值也是这个promise返回值</span><br><span class="line">如果所有的promsie状态都是rejected则会变成any的状态会变成reject</span><br><span class="line">果所有的Promise都是reject的，那么会报一个AggregateError的错误。</span><br></pre></td></tr></table></figure>

<p>219.迭代器</p>
<p>220.async函数的执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">async函数 没有await的话则和普通的函数没有区别，都是会同步执行</span><br><span class="line"></span><br><span class="line">返回值如果是普通值则会被Promise.resolve()包裹</span><br><span class="line">返回值是promsie时，会有promise的状态来决定</span><br><span class="line">返回值是thenable对象，则由thenable的状态来决定</span><br><span class="line"></span><br><span class="line">async函数的执行函数的执行函数想返回reject状态，调用catch,可以使用返回一个promsie 里面用reject(),thenable也是一样，或者使用Promise.reject()</span><br><span class="line">还可以用throw 来抛出异常</span><br><span class="line"></span><br><span class="line">async的异常不会报错，而是会作为Promise.reject来传递</span><br><span class="line"></span><br><span class="line">await关键字 只能在async里面使用</span><br><span class="line">await 之后的代码相当于Promsie.then(),await要捕获错误需要使用try...catch	</span><br><span class="line">await 后面跟的代码是Promise.resolve包裹，会等待promise的返回值</span><br><span class="line">await会阻塞代码的执行，等待promise返回值，await之前都是同步的</span><br></pre></td></tr></table></figure>

<p>221.浏览器的事件循环</p>
<p>​        宏任务队列(marcotask queue)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax,setTimeout,setInterval,DOM监听，UI Rendering等</span><br></pre></td></tr></table></figure>

<p>​        微任务队列(microtask queue)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise的then回调，Mutation Obderver API queueMicrotask async await</span><br></pre></td></tr></table></figure>

<p>​    执行宏任务之前，会先检查微任务队列是否为空，如果不为空，先执行微任务</p>
<p>222.错误处理方案</p>
<p>​        throw 会中断后面代码的执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw String/number/boolean/Object</span><br></pre></td></tr></table></figure>

<p>​        异常的捕获</p>
<p>​        try..catch..finally</p>
<p>223.cookie存储是由浏览器自动做的，携带cookie也是由浏览器做的</p>
<p>224.Storage</p>
<p>​        localStorage在页面关闭并重新打开时不会被清除，sessionStroage会被清除</p>
<p>​        在页面内发生跳转不打开新页面时，sessionStorage和localStorage都会被保留</p>
<p>​        在页面外发生跳转打开新的页面时，sessionStorage不保存，localStorage会保存</p>
<p>​        sessionStorage只会在本次会话中存储，不会在新页面中获取</p>
<p>225.cache工具的封装</p>
<p>226.正则表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">const re1=new REgExp(pattern,&quot;ig&quot;)//new 创建</span><br><span class="line">const re2=/aaaa/ig //字面量写法</span><br><span class="line"></span><br><span class="line">message.replaceAll(/abc/ig,&quot;cba&quot;)</span><br><span class="line"></span><br><span class="line">message.replaceAll(/\d+/ig,&quot;cba&quot;)</span><br><span class="line"></span><br><span class="line">message.test(/^abc$/ig)//返回值是boolean值</span><br><span class="line"></span><br><span class="line">message.match(/abc/ig)//返回匹配到的值的数组结合</span><br><span class="line">message.matchAll(/abc/ig)//必须加g,返回值是迭代器</span><br><span class="line">message.split(/abc/ig)</span><br><span class="line"></span><br><span class="line">message.search(/abc/i)//返回索引，没有则返回-1</span><br><span class="line"></span><br><span class="line">常见修饰符</span><br><span class="line">	g 匹配全部</span><br><span class="line">	i 忽略大小写</span><br><span class="line">	m 多行匹配</span><br><span class="line">	</span><br><span class="line">规则</span><br><span class="line">	\d digit 一个数字0-9</span><br><span class="line">	\s space 一个空格字符，换行符,\t,\n</span><br><span class="line">	\w word 一个拉丁字母或者数字，下划线</span><br><span class="line">	.  匹配任意字符，除了换行符</span><br><span class="line">	</span><br><span class="line">	反向类</span><br><span class="line">	\D 非数字 除\d以外字符 如字母</span><br><span class="line">	\S 非空格 </span><br><span class="line">	\W 非单字字符</span><br><span class="line">	</span><br><span class="line">	转义</span><br><span class="line">	/\./ig 对.进行转义</span><br><span class="line">	[,],\,^,$,.,|,?,*,+,(,),/  常见的需要进行转义</span><br><span class="line">	</span><br><span class="line">	const jsfile=/\.jsx?$/  ?表示前面的字符可选</span><br><span class="line">	</span><br><span class="line">	集合</span><br><span class="line">		匹配到多个字符中的其中之一.用[]</span><br><span class="line">		/[0-9]/,/[156]/</span><br><span class="line">		const phone=/^1[3-9]\d&#123;9&#125;$/ //匹配电话号码</span><br><span class="line">		</span><br><span class="line">		排除范围[^...]，不匹配括号里面的</span><br><span class="line">	量词</span><br><span class="line">		/a&#123;5&#125;/ 匹配5个a /a&#123;3,5&#125;/匹配3-5个a</span><br><span class="line">		缩写</span><br><span class="line">			+:一个或者多个,&#123;1,&#125;</span><br><span class="line">			?:0或者1个 &#123;0,1&#125;</span><br><span class="line">			*:0个或者多个 &#123;0,&#125;</span><br><span class="line">			</span><br><span class="line">			const tag=/&lt;\/?[a-z][a-z0-9]*\/?/ig  匹配多个元素标签</span><br><span class="line">			</span><br><span class="line">			贪婪模式和惰性模式</span><br><span class="line">			const name=/《.+?》/g 惰性模式</span><br><span class="line">			const name=/《.+》/g 贪婪模式</span><br><span class="line">			</span><br><span class="line">	捕获组</span><br><span class="line">			const name=/《(.+?)》/g</span><br><span class="line">			str.matchAll(name)</span><br><span class="line">			</span><br><span class="line">			未学完</span><br><span class="line">			</span><br><span class="line">227.http 超文本传输协议  </span><br><span class="line">	默认端口是80端口，是应用层协议</span><br><span class="line">228.HTTP组成</span><br><span class="line">	一次请求包括request和response</span><br><span class="line">229.http版本</span><br><span class="line">	HTTP/1.0</span><br><span class="line">	HTTP/1.1 添加了持久化连接</span><br><span class="line">	HTTP/2.0</span><br><span class="line">	HTTP/3.0</span><br><span class="line">230.HTTP的请求方式</span><br><span class="line">	GET</span><br><span class="line">	HEAD//和get相似,但是没有响应体，例如准备下载一个文件前，先获取文件的大小，再决定是否进行下载</span><br><span class="line">	POST//将实体提交到指定的资源</span><br><span class="line">	PUT//替换所有数据</span><br><span class="line">	DELETE</span><br><span class="line">	PATCH//对部分数据进行修改</span><br><span class="line">	CONNECT</span><br><span class="line">	TRACE</span><br><span class="line">231.request header</span><br><span class="line">	content-type是请求携带的数据类型</span><br><span class="line">		application/x-www-form-urlencoded 表示被编码成以&amp;分隔name=why&amp;age=18</span><br><span class="line">		application/json 表示是一种json类型</span><br><span class="line">		text/plain 表示文本类型</span><br><span class="line">		application/xml</span><br><span class="line">		multipart/form-data //表示文件上传 ，很多浏览器会自动设置</span><br><span class="line">	content-length 文件长度 不需要设置</span><br><span class="line">	keep-alive http/1.1 默认为true</span><br><span class="line">	accept-encoding:告知服务器，客户端支持的文件压缩格式，比如js文件可以使用gzip压缩</span><br><span class="line">对应.gz文件，浏览器会自动解压，这个属性不用配，浏览器会配，在webpack中可以打包成gzip文件</span><br><span class="line">	accept:告诉浏览器，客户端可以接受的文件的格式类型 默认是任何格式都接受</span><br><span class="line">	user-agent:客户端相关的信息</span><br><span class="line">232.http response status</span><br><span class="line">	200 ok </span><br><span class="line">	201 create post请求，创建新的资源</span><br><span class="line">	301 永久重定向</span><br><span class="line">	400 bad request 客户端的错误，服务器无法或者不进行处理</span><br><span class="line">	401 unauthorized 未授权 一般是没有登录的情况下 没有cookie,token或者过期</span><br><span class="line">	403 forbidden 没有权限</span><br><span class="line">	404 NOt found 一般是接口不存在，url错误</span><br><span class="line">	500 服务器未知错误</span><br><span class="line">	503 暂时无法访问</span><br><span class="line">	</span><br><span class="line">	400、403都是浏览器返回的</span><br><span class="line">	有些开发所有返回的status都是200，在数据里面来自定义错误信息</span><br><span class="line">233.xhr</span><br><span class="line">	const xhr=new XMLHttpRequest()</span><br><span class="line">	xhr.onload=function()&#123;</span><br><span class="line">		//xhr.response   一般使用这个</span><br><span class="line">		//xhr.responseText</span><br><span class="line">		//xhr.responseXML</span><br><span class="line">	&#125;</span><br><span class="line">	xhr.responseType=&quot;json&quot;//默认是text,一般是json</span><br><span class="line">	</span><br><span class="line">	xhr.open(&quot;get&quot;,url)//第一个参数是请求类型，第二个参数是url，第三个参数是是否同步，默认是异步</span><br><span class="line">	//设置过期时间</span><br><span class="line">	xhr.timeout=3000</span><br><span class="line">	xhr.ontimeout=function()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	xhr.abort()//取消请求</span><br><span class="line">	//发送网络请求</span><br><span class="line">	xhr.send()</span><br><span class="line">234.ajax的封装</span><br><span class="line">235.Fetch </span><br><span class="line">	返回值是promise</span><br><span class="line">	文件上传地址http://123.207.32.32:1888/02_param/upload</span><br><span class="line">236.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;提交描述&quot;</span><br><span class="line">git push</span><br><span class="line">git pull origin master //从远程的某个分支获取</span><br><span class="line">git branch --set-upstream-to=origin/master  //设置上游分支就可以只写 git pull了</span><br><span class="line">git merge --allow-unrelated-histories  //强制合并</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git clone url//克隆代码</span><br><span class="line"></span><br><span class="line">push到远程仓库</span><br><span class="line">git push</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">fetch代码</span><br><span class="line">git fetch </span><br><span class="line">git fetch origin master</span><br><span class="line"></span><br><span class="line">获取到代码后默认并没有合并，需要merge</span><br><span class="line">git merge</span><br><span class="line"></span><br><span class="line">get merge origin/master</span><br><span class="line"></span><br><span class="line">也可以使用</span><br><span class="line">git pull</span><br><span class="line">相当于</span><br><span class="line">git fetch+git merge(rebase)</span><br><span class="line"></span><br><span class="line">链接远程仓库</span><br><span class="line">geit remote add origin ....</span><br><span class="line"></span><br><span class="line">git push origin master //第一次图送会推送到main分支  第二次推送会被推送到master</span><br><span class="line">git push origin master:main</span><br><span class="line"></span><br><span class="line">git push origin head:main  head默认指向main</span><br><span class="line">如果要push master默认要这么写git push origin master:main  如果想写git push就要这么写</span><br><span class="line">配置git push 指向上游路径master，就是配置好的git branch --set-upstream-to=origin/master</span><br><span class="line">调用git push 就会push到master,但是这样每个分支都是push到master</span><br><span class="line">git config push.default upstream  [--global]//加上global可以全局使用，否则就是当前项目使用</span><br><span class="line"></span><br><span class="line">git config push.default current  //这个会先去仓库找有没有和本地相同的分支，如果没有就在远程创建一个新的和本地相同的分支</span><br><span class="line"></span><br><span class="line">push.default 默认是simple 就是push相同的分支</span><br><span class="line"></span><br><span class="line">git tag 打标签</span><br><span class="line">git tag v1.0.0</span><br><span class="line">git tag -a v1.0.1 -m &quot;注释&quot;</span><br><span class="line">默认情况子git tag 不会push到服务器</span><br><span class="line">git push origin v1.0.0  推送到远程</span><br><span class="line">git push origin --tags 把所有tag都推送上去</span><br><span class="line">git tag -d tagname  //删除本地的tag</span><br><span class="line">git oush origin&lt;在本地定义的远程的名字，默认是origin&gt; -d或者--delete v1.0.0</span><br><span class="line">git checkpout v1.0.0 跳转到目标tag, 回到tag版本代码 不能再当前tag修改代码，需要根据当前的tag,创建新的分支来修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git cat-file -p 00d2  //查看.git/objects/00/d2..... 就可以看到文件的内容</span><br><span class="line"></span><br><span class="line">git cat-file -t 00d2 //查看文件内容</span><br><span class="line">//blod 表示文件还没提交的文件</span><br><span class="line">//commit 表示已经提交</span><br><span class="line">//tag 表示是tag</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>237.Git分支</p>
<p>创建新的分支其实创建一个新的可移动的指针</p>
<p>git branch 分支  创建分支</p>
<p>git checkout 分支 切换分支</p>
<p>git 怎么直到指向那个分支 也是使用HEAD的指针 </p>
<p>git checkout 分支  就是将head指针指向它</p>
<p>先使用 git branch 分支 创建分支 然后再使用 git checkout 分支 将切换分支指针指向该分支</p>
<p>git checkout -b <newbranchname>   //创建新的分支并且切换分支</p>
<p> 238.git flow </p>
<p>在项目开发过程中，首先会创建master主分支用于线上发布，可以打上tag作为版本，如果线上出现bug,则从master开辟分支，进行代码的修复，然后合并到master分支，和develop分支。develop分支用于开发，需要上线时会开辟release分支用于测试，并且修复测试遇到的bug,完成测试后就可以合并到master和develop,如果需要开发新的功能，则需要从develop开辟新分支进行开发</p>
<p>239.git的远程分支</p>
<p>git remote add origin url</p>
<p>git fetch origin main  //把main分支拉取</p>
<p>git branch –set-upstream-to=origin/main  //设置上游分支</p>
<p>=========================================================</p>
<p>get merge//默认合并upstream   合并必须要有共同的祖先</p>
<p>远程分支是也是一种分支结构：  以 remote/branch式命名的</p>
<p>240.跟踪远程分支</p>
<p>当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支</p>
<p>如果你愿意的话可以设置其他的跟踪分支，可以通过运行 git checkout –track origin/分支名</p>
<p> 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track &lt;remote&gt;/&lt;branch&gt;  </span><br><span class="line"></span><br><span class="line">相当于git branch --set-upstream-to=origin/main  跟踪origin/main  并且创建和切换mian分支</span><br><span class="line"></span><br><span class="line">git checkout &lt;branch&gt;  上面的简写</span><br><span class="line">他会先检查远程有没有这个分支，然后在跟踪这个分支，并且在本地创建这个分支，在切换到这个分支</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>241.git checkout -b  develop</p>
<p>​        git push origin develop</p>
<p>如果需要创建一个分支，并且推送到远程，远程也会创建相同的分支</p>
<p>242.git branch -d  分支     删除本地分支</p>
<p>243.删除远程分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>244.查看git log</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>

<p>245 git rebase</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br><span class="line">git checkout master</span><br><span class="line">git merge  feature</span><br><span class="line"></span><br><span class="line">//永远不要在主分支上rebase</span><br></pre></td></tr></table></figure>

<p>246.git rebase的原理</p>
<p>247.rebase和merge的区别</p>
<p>merge会记录git的所有历史，那么分支的历史错综复杂，也会全部记录下来</p>
<p>rebase用于简化历史记录，将两个分支的历史简化，整个历史更加简洁</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/14/%E7%AC%94%E8%AE%B0/" data-id="cl9770wq3007bk2oo9gjd8536" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-VUE3和VUE2的区别(一)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/" class="article-date">
  <time datetime="2022-08-12T11:35:32.000Z" itemprop="datePublished">2022-08-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>►<a class="article-category-link" href="/categories/vue/daily/">daily</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/">vue2和vue3的区别(vue2向vue3迁移)(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><h3 id="vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。"><a href="#vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。" class="headerlink" title="vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。"></a>vue2的源码使用Flow进行类型检测的，vue3使用Typescript进行重构，比vue2更好的对typescript进行支持。</h3></li>
<li><h3 id="vue3中使用Proxy来实现对数据劫持，vue2中使用Object-defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用-set和-delete方法。"><a href="#vue3中使用Proxy来实现对数据劫持，vue2中使用Object-defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用-set和-delete方法。" class="headerlink" title="vue3中使用Proxy来实现对数据劫持，vue2中使用Object.defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用$set和$delete方法。"></a>vue3中使用Proxy来实现对数据劫持，vue2中使用Object.defineProperty来劫持数据的getter和setter方法的，这这种方式存在缺点就是在给对象添加和删除属性的时候，是无法劫持和监听的。所以必须使用$set和$delete方法。</h3></li>
<li><h3 id="vue3删除了-set和-off-once-移除了filter-内敛模板等特性"><a href="#vue3删除了-set和-off-once-移除了filter-内敛模板等特性" class="headerlink" title="vue3删除了$set和$off,$once.移除了filter,内敛模板等特性"></a>vue3删除了$set和$off,$once.移除了filter,内敛模板等特性</h3></li>
<li><h3 id="在编译方面做了优化：生成Block-tree-Slot编译优化，diff算法优"><a href="#在编译方面做了优化：生成Block-tree-Slot编译优化，diff算法优" class="headerlink" title="在编译方面做了优化：生成Block tree,Slot编译优化，diff算法优"></a>在编译方面做了优化：生成Block tree,Slot编译优化，diff算法优</h3></li>
<li><h3 id="vue3中已经去掉了事件总线，可以使用mitt"><a href="#vue3中已经去掉了事件总线，可以使用mitt" class="headerlink" title="vue3中已经去掉了事件总线，可以使用mitt"></a>vue3中已经去掉了事件总线，可以使用mitt</h3></li>
<li><h3 id="vue3中增加了componsition-API"><a href="#vue3中增加了componsition-API" class="headerlink" title="vue3中增加了componsition API"></a>vue3中增加了componsition API</h3></li>
<li><h3 id="vue3中移除了-children"><a href="#vue3中移除了-children" class="headerlink" title="vue3中移除了$children"></a>vue3中移除了$children</h3></li>
<li><h3 id="vue3中的推荐的构建工具已经从vue-cli转成vite"><a href="#vue3中的推荐的构建工具已经从vue-cli转成vite" class="headerlink" title="vue3中的推荐的构建工具已经从vue cli转成vite"></a>vue3中的推荐的构建工具已经从vue cli转成vite</h3></li>
<li><h3 id="vue3中的推荐的状态管理工具已经从vuex转成pinia"><a href="#vue3中的推荐的状态管理工具已经从vuex转成pinia" class="headerlink" title="vue3中的推荐的状态管理工具已经从vuex转成pinia"></a>vue3中的推荐的状态管理工具已经从vuex转成pinia</h3></li>
<li><h3 id="IDE支持Vetur-gt-Volar"><a href="#IDE支持Vetur-gt-Volar" class="headerlink" title="IDE支持Vetur-&gt;Volar"></a>IDE支持Vetur-&gt;Volar</h3></li>
<li><h3 id="vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰"><a href="#vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰" class="headerlink" title="vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰"></a>vue3的响应式是使用了proxy，proxy不支持IE，所以vue3也不支持IE，目前IE已经不再进行更新，已经被淘汰</h3></li>
<li><h3 id="添加了全新的全局api-createApp-来替代new-Vue-来创建vue实例"><a href="#添加了全新的全局api-createApp-来替代new-Vue-来创建vue实例" class="headerlink" title="添加了全新的全局api :createApp()来替代new Vue()来创建vue实例"></a>添加了全新的全局api :createApp()来替代new Vue()来创建vue实例</h3></li>
</ol>
<table>
<thead>
<tr>
<th>2.x Global API</th>
<th>3.x Instance API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config</td>
<td>app.config</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td>删除</td>
</tr>
<tr>
<td>Vue.config.ignoredElements</td>
<td>app.config.compilerOptions.isCustomElement</td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
<tr>
<td>Vue.extend</td>
<td>删除</td>
</tr>
</tbody></table>
<h3 id="13-全局-API-Treeshaking"><a href="#13-全局-API-Treeshaking" class="headerlink" title="13.全局 API Treeshaking"></a>13.全局 API Treeshaking</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">Vue.nextTick(() =&gt; &#123;</span><br><span class="line">  // something DOM-related</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在Vue2.X中Vue.nextTick()是一个暴露在单个Vue对象中的全局的api，事实上，实例方法$nextTick()只是一个包装器，为了方便Vue.nextTick()，回调函数的this会自动绑定到当前实例中，但是在vite和webpack中，Vue.nextTick不可以进行treeshaking,所以在Vue3中做了优化，让nextTick可以进行treeShaking,全局的模块只能作为ES模块构建的命名导出来进行访问，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; nextTick &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">nextTick(() =&gt; &#123;</span><br><span class="line">  // something DOM-related</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; shallowMount &#125; from &#x27;@vue/test-utils&#x27;</span><br><span class="line">import &#123; MyComponent &#125; from &#x27;./MyComponent.vue&#x27;</span><br><span class="line">import &#123; nextTick &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">test(&#x27;an async feature&#x27;, async () =&gt; &#123;</span><br><span class="line">  const wrapper = shallowMount(MyComponent)</span><br><span class="line"></span><br><span class="line">  // execute some DOM-related tasks</span><br><span class="line"></span><br><span class="line">  await nextTick()</span><br><span class="line"></span><br><span class="line">  // run your assertions</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果在Vue3中使用Vue.nextTick()会导致臭名昭著的<code>undefined is not a function</code>错误</p>
<p>通过此更改，如果模块捆绑器支持 tree-shaking，则未在 Vue 应用程序中使用的全局 API 将从最终捆绑包中删除，从而获得最佳文件大小</p>
<h5 id="以下Vue2的全局QAPI会受到影响"><a href="#以下Vue2的全局QAPI会受到影响" class="headerlink" title="以下Vue2的全局QAPI会受到影响"></a>以下Vue2的全局QAPI会受到影响</h5><ul>
<li><code>Vue.nextTick</code></li>
<li><code>Vue.observable</code>（替换为<code>Vue.reactive</code>）</li>
<li><code>Vue.version</code></li>
<li><code>Vue.compile</code>（仅在完整版本中）</li>
<li><code>Vue.set</code>（仅在兼容版本中）//不要使用</li>
<li><code>Vue.delete</code>（仅在兼容版本中）//不要使用</li>
</ul>
<p>除了如上全局API之外，许多内部组件将不再作为默认导入的一部分，需要使用到时再导入，有利于treeShaking,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;div v-show=&quot;ok&quot;&gt;hello&lt;/div&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>会被编译成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; h, Transition, withDirectives, vShow &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export function render() &#123;</span><br><span class="line">  return h(Transition, [withDirectives(h(&#x27;div&#x27;, &#x27;hello&#x27;), [[vShow, this.ok]])])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以减少包的大小</p>
<p><strong>notice</strong></p>
<p><strong>上述内容仅适用于与支持 tree-shaking 的捆绑器一起使用的<a target="_blank" rel="noopener" href="https://github.com/vuejs/core/tree/master/packages/vue#which-dist-file-to-use">ES 模块构建</a>- UMD 构建仍然包含所有功能并在 Vue 全局变量上公开所有内容（并且编译器将生成适当的输出以使用全局 API 而不是导入）。</strong></p>
<p>再插件中使用时</p>
<p>Vue2.x中使用全局api</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plugin = &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function"><span class="params">Vue</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Vue3.x使用全局API</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugin = &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在webpack中如果把上诉代码打包成一个buddle,他会把vue源码也会打包进去，如果要避免这样的发生可以使用externals排除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="attr">externals</span>: &#123;</span><br><span class="line">    <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rollUp中的写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  <span class="attr">external</span>: [<span class="string">&#x27;vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-v-model"><a href="#14-v-model" class="headerlink" title="14.v-model"></a>14.v-model</h3><p>在组建中使用v-model</p>
<p>在vue2.x,<code>v-model</code>在组件上使用 a 相当于传递一个<code>value</code>prop 并发出一个<code>input</code>事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- would be shorthand for: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent :value=&quot;pageTitle&quot; @input=&quot;pageTitle = $event&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果想更改属性名和事件的时候，需要使用在组件中添加model选项，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ParentComponent.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChildComponent.vue</span></span><br><span class="line"></span><br><span class="line">export default <span class="punctuation">&#123;</span></span><br><span class="line">  model<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    prop<span class="punctuation">:</span> &#x27;title&#x27;<span class="punctuation">,</span></span><br><span class="line">    event<span class="punctuation">:</span> &#x27;change&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  props<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// this allows using the `value` prop for a different purpose</span></span><br><span class="line">    value<span class="punctuation">:</span> String<span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// use `title` as the prop which take the place of `value`</span></span><br><span class="line">    title<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      type<span class="punctuation">:</span> String<span class="punctuation">,</span></span><br><span class="line">      default<span class="punctuation">:</span> &#x27;Default title&#x27;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以v-model实际上时这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @change=&quot;pageTitle = $event&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用v-bind-sync"><a href="#使用v-bind-sync" class="headerlink" title="使用v-bind.sync#"></a>使用<code>v-bind.sync</code><a target="_blank" rel="noopener" href="https://v3-migration.vuejs.org/breaking-changes/v-model.html#using-v-bind-sync">#</a></h3><p>在某些情况下，我们可能需要一个道具的“双向绑定”（有时除了现有<code>v-model</code>的不同道具之外）。为此，我们建议以<code>update:myPropName</code>. 例如，对于<code>ChildComponent</code>上一个带有<code>title</code>prop 的示例，我们可以通过以下方式传达分配新值的意图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;update:title&#x27;, newValue)</span><br></pre></td></tr></table></figure>

<p>然后，如果需要，父级可以侦听该事件并更新本地数据属性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><code>.sync</code>为方便起见，我们使用修饰符对这种模式进行了简写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent :title.sync=&quot;pageTitle&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>在Vue3.x中 自定义组件的双向数据绑定时使用modelValue，@update:modelValue来替代</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- would be shorthand for: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :modelValue=&quot;pageTitle&quot;</span><br><span class="line">  @update:modelValue=&quot;pageTitle = $event&quot;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果需要修改model的名称则直接修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model:title=&quot;pageTitle&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- would be shorthand for: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以作为.sync的替代，可以在组件中双向数据绑定多个值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ChildComponent</span> v-<span class="attr">model</span>:title=<span class="string">&quot;pageTitle&quot;</span> v-<span class="attr">model</span>:content=<span class="string">&quot;pageContent&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- would be shorthand <span class="attr">for</span>: --&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ChildComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">:title</span>=<span class="string">&quot;pageTitle&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  @<span class="attr">update:title</span>=<span class="string">&quot;pageTitle = $event&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">:content</span>=<span class="string">&quot;pageContent&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  @<span class="attr">update:content</span>=<span class="string">&quot;pageContent = $event&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/12/VUE3%E5%92%8CVUE2%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%B8%80)/" data-id="cl9770wlo0007k2oo7wdz0fda" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue3和Vue的区别(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/12/Vue3%E5%92%8CVue%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%BA%8C)/" class="article-date">
  <time datetime="2022-08-12T11:35:32.000Z" itemprop="datePublished">2022-08-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>►<a class="article-category-link" href="/categories/vue/daily/">daily</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/12/Vue3%E5%92%8CVue%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%BA%8C)/">vue2和vue3的区别(vue2向vue3迁移)(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="15-key属性"><a href="#15-key属性" class="headerlink" title="15.key属性"></a>15.key属性</h3><p>key主要适用于在Vue的虚拟DOM算法中，跟踪节点的，以便重用和修改现有的节点，以及何时修改或者重新排序。</p>
<p>在Vue2.x中，key也被推荐用于v-if,v-else,v-else-if</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Vue <span class="number">2.</span>x --&gt;</span><br><span class="line">&lt;div v-if=<span class="string">&quot;condition&quot;</span> key=<span class="string">&quot;yes&quot;</span>&gt;Yes&lt;/div&gt;</span><br><span class="line">&lt;div v-else key=<span class="string">&quot;no&quot;</span>&gt;No&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在vue3.x中不再要求这么使用，因为vue会自己给他添加一个unique key</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 3.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;condition&quot;</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你确实想添加key,必须保证key唯一</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;condition&quot;</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue 3.x (recommended solution: remove keys) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;condition&quot;</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue 3.x (alternate solution: make sure the keys are always unique) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;condition&quot;</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>No<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong><code>&lt;template v-for&gt;</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue2.x中 &lt;template&gt;标签不能拥有key,只能在他的子元素中设置key</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:key</span>=<span class="string">&quot;&#x27;heading-&#x27; + item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">&quot;&#x27;content-&#x27; + item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在vue3.x中，key应该被设置在template上</p>
<!-- Vue 3.x -->

<template v-for="item in list" :key="item.id">
  <div>...</div>
  <span>...</span>
</template>


<p>v-for也是一样</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;item.isVisible&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue 3.x --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;item.isVisible&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="16-v-if-与-v-for-优先级"><a href="#16-v-if-与-v-for-优先级" class="headerlink" title="16.v-if 与 v-for 优先级"></a>16.v-if 与 v-for 优先级</h3><p>在vue2.x中，在相同的元素中v-for的优先级更高</p>
<p>Vue3.x中，v-if的优先级更高</p>
<h3 id="17-v-bind"><a href="#17-v-bind" class="headerlink" title="17.v-bind"></a>17.v-bind</h3><p>vue2.x中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- template --&gt;</span><br><span class="line">&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- result --&gt;</span><br><span class="line">&lt;div id=&quot;red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>vue3.x中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于绑定相同的属性，v2不会覆盖，而v3会被覆盖 v3中绑定有顺序要求</p>
<h3 id="18-v-on-native已经被移除"><a href="#18-v-on-native已经被移除" class="headerlink" title="18.v-on.native已经被移除"></a>18.v-on.native已经被移除</h3><h3 id="19-函数式组件"><a href="#19-函数式组件" class="headerlink" title="19.函数式组件"></a>19.函数式组件</h3><p>vue2.x中函数式组件主要用于性能优化，他的初始化速度要快于有状态组件，而且可以返回多个根节点，vue3.x中有状态组件的性能优化可以和无状态组件一样，而且还可以有多个跟节点</p>
<h3 id="20-异步组件"><a href="#20-异步组件" class="headerlink" title="20.异步组件"></a>20.异步组件</h3><p>vue2.x中异步组件的写法是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">asyncModal</span> = (<span class="params"></span>) =&gt; <span class="title function_">import</span>(<span class="string">&#x27;./Modal.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>或者可配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncModal = &#123;</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./Modal.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">error</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line">  <span class="attr">loading</span>: <span class="title class_">LoadingComponent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vue3中添加了一个定义异步组件的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./components/ErrorComponent.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">LoadingComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./components/LoadingComponent.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Async component without options</span></span><br><span class="line"><span class="keyword">const</span> asyncModal = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./Modal.vue&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async component with options</span></span><br><span class="line"><span class="keyword">const</span> asyncModalWithOptions = <span class="title function_">defineAsyncComponent</span>(&#123;</span><br><span class="line">  <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./Modal.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span>,</span><br><span class="line">  <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line">  <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而且vue2.x中的配置选项component变成了loader</p>
<p>vue3.x不再接受resolve，reject参数，而是返回一个promise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.x version</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">oldAsyncComponent</span> = (<span class="params">resolve, reject</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.x version</span></span><br><span class="line"><span class="keyword">const</span> asyncComponent = <span class="title function_">defineAsyncComponent</span>(</span><br><span class="line">  <span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="21-emits-Option"><a href="#21-emits-Option" class="headerlink" title="21.emits Option"></a>21.<code>emits</code> Option</h3><p>vue2.x中不需要声明emits的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;accepted&#x27;)&quot;</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: [<span class="string">&#x27;text&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>vue3.x中需要定义emits</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;accepted&#x27;)&quot;</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: [<span class="string">&#x27;text&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">emits</span>: [<span class="string">&#x27;accepted&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下面例子中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;click&#x27;, $event)&quot;</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">emits</span>: [] <span class="comment">// without declared event</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在父组件中监听click事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>click会被触发两次</p>
<h3 id="22-listener移除"><a href="#22-listener移除" class="headerlink" title="22.$listener移除"></a>22.$listener移除</h3><h3 id="23-attrs中包含class和style"><a href="#23-attrs中包含class和style" class="headerlink" title="23.$attrs中包含class和style"></a>23.$attrs中包含class和style</h3><p>vue2.x中，<code>class</code>和<code>style</code>属性在 Vue 2 虚拟 DOM 实现中得到一些特殊处理。因此，它们<em>不</em>包含在 中<code>$attrs</code>，而所有其他属性都包含在 中。</p>
<p>使用时会出现这样的副作用<code>inheritAttrs: false</code>：</p>
<p>这样$attr中的属性不再自动绑定到子组件的根元素上，而是由开发者来决定怎么绑定他们，但是class和style不属于$attr的一部分，任然会应用在根元素上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">inheritAttrs</span>: <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component id=<span class="string">&quot;my-id&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;my-class&quot;</span>&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<p>真正渲染成的html</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="keyword">class</span>=<span class="string">&quot;my-class&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;my-id&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<p>在Vue3.x中则包含这些</p>
<h3 id="24-v-on不再支持数字的keycode"><a href="#24-v-on不再支持数字的keycode" class="headerlink" title="24.v-on不再支持数字的keycode"></a>24.v-on不再支持数字的keycode</h3><h3 id="25-不在支持-on-off-once"><a href="#25-不在支持-on-off-once" class="headerlink" title="25.不在支持$on,$off,$once"></a>25.不在支持$on,$off,$once</h3><p>vue2.x中支持事件总线</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChildComponent.vue</span></span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./eventBus&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// adding eventBus listener</span></span><br><span class="line">    eventBus.$on(<span class="string">&#x27;custom-event&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Custom event triggered!&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// removing eventBus listener</span></span><br><span class="line">    eventBus.$off(<span class="string">&#x27;custom-event&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParentComponent.vue</span></span><br><span class="line"><span class="keyword">import</span> eventBus <span class="keyword">from</span> <span class="string">&#x27;./eventBus&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">callGlobalCustomEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">      eventBus.$emit(<span class="string">&#x27;custom-event&#x27;</span>) <span class="comment">// if ChildComponent is mounted, we will have a message in the console</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vue3.x中事件总线可以使用第三方的库来实现，例如<a target="_blank" rel="noopener" href="https://github.com/developit/mitt">mitt</a>或<a target="_blank" rel="noopener" href="https://github.com/scottcorgan/tiny-emitter">tiny-emitter</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eventBus.js</span></span><br><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&#x27;tiny-emitter/instance&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">$on</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> emitter.<span class="title function_">on</span>(...args),</span><br><span class="line">  <span class="attr">$once</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> emitter.<span class="title function_">once</span>(...args),</span><br><span class="line">  <span class="attr">$off</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> emitter.<span class="title function_">off</span>(...args),</span><br><span class="line">  <span class="attr">$emit</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> emitter.<span class="title function_">emit</span>(...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="26-filters"><a href="#26-filters" class="headerlink" title="26.filters"></a>26.filters</h3><p>vue3.x移除了过滤器，可以使用methods和computed来替代</p>
<p>全局的过滤器可以使用如下方式来在vue3中定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$filters</span> = &#123;</span><br><span class="line">  <span class="title function_">currencyUSD</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;$&#x27;</span> + value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Bank Account Balance<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; $filters.currencyUSD(accountBalance) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="27-删除了inline-template"><a href="#27-删除了inline-template" class="headerlink" title="27.删除了inline-template"></a>27.删除了inline-template</h3><h3 id="28-删除了-children"><a href="#28-删除了-children" class="headerlink" title="28.删除了$children"></a>28.删除了$children</h3><p>vue2.x可以使用$children来访问直接子组件，vue3.x使用refs来替代就可以了</p>
<h3 id="29-自定义指令"><a href="#29-自定义指令" class="headerlink" title="29.自定义指令"></a>29.自定义指令</h3><p>指令的钩子函数已经重新命名，更好的和组件的生命周期配合，此外，<code>expression</code>字符串不再作为<code>binding</code>对象的一部分传递</p>
<p>vue2.x中的directive的可选项</p>
<p>bind  指令只绑定一次到元素中</p>
<p>inserted  元素只被插入父元素中一次</p>
<p>update  该hook表示当元素更新时，children还没有更新</p>
<p>componentUpdated  表示组件和子元素都更新完毕</p>
<p>unbind 表示解绑</p>
<p>vue2.x的自定义指令</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-highlight</span>=<span class="string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>Highlight this text bright yellow<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;highlight&#x27;</span>, &#123;</span><br><span class="line">  bind(el, binding, vnode) &#123;</span><br><span class="line">    el.style.background = binding.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vue3.x中新增了created    这个声明周期是在元素的属性和事件被应用之前</p>
<p>bind -&gt;beforeMount</p>
<p>inserted -&gt;mounted</p>
<p>beforeUpdate 类似于组件的beforeUpdate</p>
<p>update被移除</p>
<p>componentUpdated → <strong>updated</strong></p>
<p><strong>beforeUnmount</strong>: new! Similar to component lifecycle hooks, this will be called right before an element is unmounted</p>
<p>unbind -&gt; <strong>unmounted</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const MyDirective = &#123;</span><br><span class="line">  created(el, binding, vnode, prevVnode) &#123;&#125;, // new</span><br><span class="line">  beforeMount() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;,</span><br><span class="line">  beforeUpdate() &#123;&#125;, // new</span><br><span class="line">  updated() &#123;&#125;,</span><br><span class="line">  beforeUnmount() &#123;&#125;, // new</span><br><span class="line">  unmounted() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-highlight</span>=<span class="string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>Highlight this text bright yellow<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.directive(&#x27;highlight&#x27;, &#123;</span><br><span class="line">  beforeMount(el, binding, vnode) &#123;</span><br><span class="line">    el.style.background = binding.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="30-data-option"><a href="#30-data-option" class="headerlink" title="30.data option"></a>30.data option</h3><p>vue2.x中还可以使用对象作为data的值。vue3.x不可以使用对象作为data,必须使用function</p>
<h3 id="31-元素的挂载"><a href="#31-元素的挂载" class="headerlink" title="31.元素的挂载"></a>31.元素的挂载</h3><p>在vue2.x中当挂载的元素是一个templayte的时候，渲染的内容会替换掉需要挂载的元素，在vue3.x中，需要被渲染的内容会添加到元素的children中，替代元素的innerHTML</p>
<p>vue2.x中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello Vue!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello Vue!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<p>挂载到对应的元素上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    Some app content</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终渲染的效果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;rendered&quot;</span>&gt;</span>Hello Vue!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue3.x中的效果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.createApp(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;Hello Vue!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;rendered&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">data-v-app</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;rendered&quot;</span>&gt;</span>Hello Vue!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="32-transition的变化"><a href="#32-transition的变化" class="headerlink" title="32.transition的变化"></a>32.transition的变化</h3><p>.v-enter已被替换成.v-enter-from</p>
<h3 id="33-vNode-生命周期事件"><a href="#33-vNode-生命周期事件" class="headerlink" title="33.vNode 生命周期事件"></a>33.vNode 生命周期事件</h3><p>在vue2.x中，可以使用事件来监听组件生命周期处于哪个阶段，这些事件的前缀是hook:,在 Vue 3 中，此前缀已更改为<code>vue:</code>. 此外，这些事件现在可用于 HTML 元素和组件</p>
<p>vue2.x </p>
<p>hook:后面跟的是生命周期函数的名称</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-component</span> @<span class="attr">hook:updated</span>=<span class="string">&quot;onUpdated&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue3.x中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child-component</span> @<span class="attr">vue:updated</span>=<span class="string">&quot;onUpdated&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="34-数组的监听"><a href="#34-数组的监听" class="headerlink" title="34.数组的监听"></a>34.数组的监听</h3><p>vue3.x中，数组的监听需要加上deep</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  bookList: &#123;</span><br><span class="line">    handler(val, oldVal) &#123;</span><br><span class="line">      console.log(&#x27;book list changed&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/12/Vue3%E5%92%8CVue%E7%9A%84%E5%8C%BA%E5%88%AB(%E4%BA%8C)/" data-id="cl9770wlp0008k2oo6q7pa4p0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-typescript笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/05/typescript%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-08-05T10:57:32.000Z" itemprop="datePublished">2022-08-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/typescript/">typescript</a>►<a class="article-category-link" href="/categories/typescript/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/05/typescript%E7%AC%94%E8%AE%B0/">typescript笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.在定义一个变量时，基本数据类型可以用类型推断，不用定义类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let msg = &quot;hello there!&quot;;</span><br></pre></td></tr></table></figure>

<p>2.ts的常用的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string,number,boolean,arrays,any,function,object,union type,Type Aliases,Interfaces，Type Assertions，bigint，symbol,Type Assertions,.Literal Types,Enums ,null,undefined,any,unknown,void,never ,Tuple</span><br></pre></td></tr></table></figure>

<p>3.interface和type aliases的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">实现继承的方式不同</span><br><span class="line">interface Animal &#123;</span><br><span class="line">  name: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Bear extends Animal &#123;</span><br><span class="line">  honey: boolean</span><br><span class="line">&#125;</span><br><span class="line">type Animal = &#123;</span><br><span class="line">  name: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Bear = Animal &amp; &#123; </span><br><span class="line">  honey: boolean </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">添加新的字段</span><br><span class="line">interface Window &#123;</span><br><span class="line">  title: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Window &#123;</span><br><span class="line">  ts: TypeScriptAPI</span><br><span class="line">&#125;</span><br><span class="line">类型别名不能够修改已经创建的字段</span><br><span class="line">type Window = &#123;</span><br><span class="line">  title: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Window = &#123;</span><br><span class="line">  ts: TypeScriptAPI</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> // Error: Duplicate identifier &#x27;Window&#x27;.</span><br><span class="line">const src = &#x27;const a = &quot;Hello World&quot;&#x27;;</span><br><span class="line">window.ts.transpileModule(src, &#123;&#125;);</span><br><span class="line">接口只能声明对象，不能够重命名原语</span><br><span class="line">类型别名不能够声明合并，但是接口可以</span><br><span class="line"></span><br><span class="line">如果是定义非对象类型，通常推荐使用type</span><br><span class="line">如果是定义对象类型，那么他们是有区别的：</span><br><span class="line">interface 可以重复的对某个接口来定义属性和方法；</span><br><span class="line">而type定义的是别名，别名是不能重复的</span><br></pre></td></tr></table></figure>

<p>4.Type Assertions类型断言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeScript 只允许类型断言转换为更具体或更不具体的类型版本，而不可以转成没有关系的类型</span><br><span class="line"></span><br><span class="line">const a = (expr as any) as T;  可以将两种不相关的类型进行转换时，要进行两次断言，先断雁城any或者unknown</span><br></pre></td></tr></table></figure>

<p>5.Literal Types 文本类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const constantString = &quot;Hello World&quot;;//使用const定义的常量类型</span><br><span class="line"></span><br><span class="line">function printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">您可以使用 as const 将整个对象转换为类型文字：</span><br><span class="line">const req = &#123; url: &quot;https://example.com&quot;, method: &quot;GET&quot; &#125; as const;</span><br><span class="line">handleRequest(req.url, req.method);</span><br></pre></td></tr></table></figure>

<p>.Enums 枚举</p>
<p>7.ts的运行环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方式一：tsc math.ts   node math.js  这种方式会比较麻烦</span><br><span class="line">方式二：webpack中配置本地的运行环境  使用ts-loader</span><br><span class="line">方式三：使用ts-node</span><br><span class="line">npm install ts-node -g</span><br><span class="line">npm install tslib @types/node -g</span><br><span class="line">ts-node math.ts</span><br></pre></td></tr></table></figure>

<p>8.unkonwn类型和any类型的区别</p>
<p>任何类型都可以是any类型,ts不会对any类型的变量进行类型检测，任何类型也是可以赋值给unknown,但是使用这个变量必须进行类型检查，否则就会报错</p>
<p><img src="https://img1.imgtp.com/2022/08/05/Lt1elC2b.png" alt="QQ截图20220715095600.png"></p>
<p>9.Tuple类型(元组)</p>
<p>元组类型就是不同类型的数组的集合</p>
<p><img src="https://img1.imgtp.com/2022/08/05/PyfvKidj.png" alt="QQ截图20220715101013.png"></p>
<p>10.Never类型</p>
<h5 id="Never类型指永不存在的类型。-例如，never-类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型"><a href="#Never类型指永不存在的类型。-例如，never-类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型" class="headerlink" title="Never类型指永不存在的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型"></a>Never类型指永不存在的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</h5><p>11.函数参数</p>
<p><img src="https://img1.imgtp.com/2022/08/05/8e9QZ1fu.png" alt="QQ截图20220715111132.png"></p>
<ol start="12">
<li>匿名函数的参数类型</li>
</ol>
<p><img src="https://img1.imgtp.com/2022/08/05/UiMI6HEs.png" alt="QQ截图20220715111344.png"></p>
<p>13.函数参数的对象类型</p>
<p><img src="https://img1.imgtp.com/2022/08/05/Itu8eHI1.png" alt="QQ截图20220715112229.png"></p>
<p>14.函数参数对象可选参数</p>
<p><img src="https://img1.imgtp.com/2022/08/05/4knXfTJ1.png" alt="QQ截图20220715112745.png"></p>
<p>15.联合类型</p>
<p><img src="https://img1.imgtp.com/2022/08/05/xI0aQEuD.png" alt="QQ截图20220715114922.png"></p>
<p>16.一个参数一个可选类型的时候, 它其实类似于是这个参数是 类型|undefined 的联合类型</p>
<p>17.非空类型断言!</p>
<p><img src="https://img1.imgtp.com/2022/08/05/T6LzBxdD.png" alt="QQ截图20220715142334.png"></p>
<p>18.可选链操作</p>
<p><img src="https://img1.imgtp.com/2022/08/05/TaGoHMzn.png" alt="QQ截图20220715151237.png"><br>19.!!运算符</p>
<p>可以将其他数据类型转换成boolean</p>
<p>20.??操作符  空值合并操作符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const messgae1 = &quot;1111&quot;;</span><br><span class="line">const content = messgae1 ?? &quot;你好&quot;;</span><br><span class="line">如果message1是null或者undefined,content就会使用后面的值，message是空字符串不生效</span><br></pre></td></tr></table></figure>

<p>21.类型缩小  Type Narrowing</p>
<p>类型缩小就是将例如联合类型进行精确到具体的类型</p>
<p>常见的类型保护有</p>
<p>typeof</p>
<p>===，！==</p>
<p>instanceof</p>
<p>in</p>
<p>…..</p>
<p><img src="https://img1.imgtp.com/2022/08/05/xmoxhxl5.png" alt="QQ截图20220716003305.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/DnVQP9fW.png" alt="QQ截图20220716003335.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/ECM7n6A2.png" alt="QQ截图20220716003417"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/eDTnB12m.png" alt="QQ截图20220716003433"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/s38SLBN0.png" alt="QQ截图20220716003446"></p>
<p>22.函数类型定义</p>
<p><img src="https://img1.imgtp.com/2022/08/05/E4FrxA0i.png"></p>
<p>23.参数的可选类型</p>
<p><img src="https://img1.imgtp.com/2022/08/05/5GU46enS.png"></p>
<p>24.参数的默认值</p>
<p><img src="https://img1.imgtp.com/2022/08/05/0pGV9IBH.png"></p>
<p>25.剩余参数</p>
<p><img src="https://img1.imgtp.com/2022/08/05/b2Gi65SO.png"></p>
<p>26.指定this的绑定</p>
<p><img src="https://img1.imgtp.com/2022/08/05/PLXzyda7.png"></p>
<p>27.函数的重载</p>
<p>通过联合类型的有两个缺点：</p>
<p>​ 1.需要进行很多类型逻辑判断</p>
<p>​ 2.返回值类型不能判定</p>
<p><img src="https://img1.imgtp.com/2022/08/05/Xl0sI2DM.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/obc6YOcv.png"></p>
<p>27.类的定义</p>
<p><img src="https://img1.imgtp.com/2022/08/05/GQd3h5pF.png"></p>
<p>28.类的继承</p>
<p><img src="https://img1.imgtp.com/2022/08/05/NwBuKZH2.png"></p>
<p>29.类的多态</p>
<p><img src="https://img1.imgtp.com/2022/08/05/95zR2UQ2.png"></p>
<p>30.类的成员修饰符</p>
<p>private 修饰的属性和方法只能在该类内部使用</p>
<p>protected修饰的属性和方法只能在类本身及其子类内部使用</p>
<p>public是默认的成员修饰符，可以在外部，类，子类使用</p>
<p><img src="https://img1.imgtp.com/2022/08/05/Pw02xjP0.png"></p>
<p>31.readonly修饰符</p>
<p><img src="https://img1.imgtp.com/2022/08/05/KrYErakm.png"></p>
<p>32.访问器setter/getter</p>
<p><img src="https://img1.imgtp.com/2022/08/05/eVx6dPgv.png"></p>
<p>33.类的静态成员</p>
<p><img src="https://img1.imgtp.com/2022/08/05/ESG5cMLo.png"></p>
<p>34.抽象类abstract</p>
<p>什么是 抽象方法? 在TypeScript中没有具体实现的方法(没有方法体)，就是抽象方法</p>
<p>抽象方法，必须存在于抽象类中</p>
<p>抽象类是使用abstract声明的类</p>
<p><img src="https://img1.imgtp.com/2022/08/05/XmcOILgK.png"></p>
<p>35.类本身也可以作为另外一变量的类型</p>
<p>36.接口的声明</p>
<p>​ <img src="https://img1.imgtp.com/2022/08/05/3ANVJqpG.png"></p>
<p>37.接口的索引类型</p>
<p><img src="https://img1.imgtp.com/2022/08/05/1pM1SZre.png"></p>
<p>38.函数类型</p>
<p>interface也可以定义函数，建议使用类型别名列定义函数</p>
<p><img src="https://img1.imgtp.com/2022/08/05/xVRVoVov.png"></p>
<p>39.接口的继承</p>
<p><img src="https://img1.imgtp.com/2022/08/05/VlVrCRbV.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/gvacaNKp.png"></p>
<p>40.交叉类型</p>
<p><img src="https://img1.imgtp.com/2022/08/05/kExwu85c.png"></p>
<p>41.字面量赋值</p>
<p><img src="https://img1.imgtp.com/2022/08/05/LVx7kzYn.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/UxFV3w0L.png" alt="QQ截图20220716171033.png"></p>
<p>42.枚举类型</p>
<p>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型； p枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型</p>
<p><img src="https://img1.imgtp.com/2022/08/05/JUcGQCK2.png" alt="QQ截图20220716172406.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/i4HcVm8N.png" alt="QQ截图20220716172417.png"></p>
<p>43.泛型</p>
<p><img src="https://img1.imgtp.com/2022/08/05/A6dtGWoy.png" alt="QQ截图20220717020140.png"></p>
<p><img src="https://img1.imgtp.com/2022/08/05/A6dtGWoy.png" alt="QQ截图20220717020140.png"></p>
<p>44.泛型接口的定义</p>
<p><img src="https://img1.imgtp.com/2022/08/05/2ZbKkBg2.png" alt="QQ截图20220717020609.png"></p>
<p>45.泛型作为类</p>
<p><img src="https://img1.imgtp.com/2022/08/05/c0ucka5e.png" alt="QQ截图20220717092242.png"></p>
<p>46.泛型约束</p>
<p><img src="https://img1.imgtp.com/2022/08/05/A9jQ0E9R.png" alt="QQ截图20220717092443.png"></p>
<p>47.namespace</p>
<p>namespace会形成独立的空间，里面的内容需要使用export，外部才可以使用，否则外部无法访问</p>
<p><img src="https://img1.imgtp.com/2022/08/05/qr2xvkmZ.png" alt="QQ截图20220717174941.png"><br><img src="https://img1.imgtp.com/2022/08/05/Eq2OIARP.png" alt="QQ截图20220717175005.png"><br>48.命名空间的拆分</p>
<p>可以将命名空间的内容拆分到多个文件中</p>
<p>49..d.ts文件  类型声明文件</p>
<p>它仅仅用来做类型检测，告知typescript我们有哪 些类型</p>
<p>那么typescript会在哪里查找我们的类型声明呢？</p>
<p>内置类型声明；</p>
<p>外部定义类型声明；</p>
<p>自己定义类型声明；</p>
<p>类型声明文件主要适用于外部类库，例如引入的npm包没有做类型声明，则需要自己写类型声明文件</p>
<p>50.内置类型声明</p>
<p>内置类型声明是typescript自带的、帮助我们内置了JavaScript运行时的一些标准化API的声明文件。包括比如Math、Date等内置类型，也包括DOM API，比如Window、Document等； 内置类型声明通常在我们安装typescript的环境中会带有的；</p>
<p>51.外部定义类型声明和自定义声明</p>
<p>外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明</p>
<p>这些库通常有两种类型声明方式：</p>
<p> 方式一：在自己库中进行类型声明（编写.d.ts文件），比如axios</p>
<p>方式二：通过社区的一个公有库DefinitelyTyped存放类型声明文件</p>
<p>该库的GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped/">https://github.com/DefinitelyTyped/DefinitelyTyped/</a></p>
<p>该库查找声明安装方式的地址：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/dt/search?search">https://www.typescriptlang.org/dt/search?search</a>=</p>
<p>比如我们安装react的类型声明： npm i @types/react –save-dev</p>
<p> 什么情况下需要自己来定义声明文件呢？</p>
<p>情况一：我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件；比如lodash</p>
<p>情况二：我们给自己的代码中声明一些类型，方便在其他地方直接进行使用；</p>
<p>52.tsconfig.js文件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/05/typescript%E7%AC%94%E8%AE%B0/" data-id="cl9770wmq0016k2oo35nzhjo4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-interview02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/04/interview02/" class="article-date">
  <time datetime="2022-08-04T14:33:16.000Z" itemprop="datePublished">2022-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/interview/">interview</a>►<a class="article-category-link" href="/categories/interview/daily/">daily</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/04/interview02/">面试问题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h3><h3 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h3><h3 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别"></a>请描述一下 <code>cookies</code>，<code>sessionStorage</code> 和 <code>localStorage</code> 的区别</h3><h3 id="WEB标准以及W3C标准是什么"><a href="#WEB标准以及W3C标准是什么" class="headerlink" title="WEB标准以及W3C标准是什么"></a>WEB标准以及W3C标准是什么</h3><h3 id="HTTP-request报文结构是怎样的"><a href="#HTTP-request报文结构是怎样的" class="headerlink" title="HTTP request报文结构是怎样的"></a>HTTP request报文结构是怎样的</h3><h3 id="HTTP-response报文结构是怎样的"><a href="#HTTP-response报文结构是怎样的" class="headerlink" title="HTTP response报文结构是怎样的"></a>HTTP response报文结构是怎样的</h3><h3 id="如何垂直居中一个浮动元素"><a href="#如何垂直居中一个浮动元素" class="headerlink" title="如何垂直居中一个浮动元素"></a>如何垂直居中一个浮动元素</h3><h3 id="css中可以让文字在垂直和水平方向上重叠的两个属性是什么"><a href="#css中可以让文字在垂直和水平方向上重叠的两个属性是什么" class="headerlink" title="css中可以让文字在垂直和水平方向上重叠的两个属性是什么"></a>css中可以让文字在垂直和水平方向上重叠的两个属性是什么</h3><p>面试总结</p>
<p>css动画</p>
<p>从左上角到右下角</p>
<p>jsonp如何实现跨域</p>
<p>tcp三次握手四次挥手</p>
<p>正则表达式</p>
<p>首屏加载优化</p>
<p>promise实现</p>
<p>promise.all实现</p>
<p>并发多条请求，等所有成功后在响应</p>
<p>自己做过哪些缓存</p>
<p>eventBus</p>
<p>如何实现跨域</p>
<p>设计模式</p>
<p>中英文切换：前端国际化</p>
<p>自己webpack搭建项目</p>
<p>哪些数据需要缓存</p>
<p>前端数据可视化</p>
<p>vue-cli搭建</p>
<p>vue3了解</p>
<p>数据请求接口拦截</p>
<p>有没有做过重构</p>
<p>v-for和v-show区别</p>
<p>v-for为什么不可以和v-if一起用</p>
<p>自定义命令v-**有没有用过，设置优先级</p>
<p>用过哪些缓存</p>
<p>$nexttrick使用场景</p>
<p>用过哪些钩子函数</p>
<p>visual Dom</p>
<p>vue中router实现原理</p>
<p>如何减少回流重绘</p>
<p>用过哪些设计模式，前端模块分层 ts中有进行模块的分层</p>
<p>v-model和sync区别</p>
<p>浏览器渲染线程是异步还是同步的</p>
<p>vue中加载外部js文件和vue中js的执行顺序</p>
<p>vue中如何进行跨多个组件传递信息</p>
<p>移动端安卓和ios的兼容性问题，pc端兼容性问题</p>
<p>页面嵌入到app中如何区分是是外部页面还是app页面</p>
<h5 id="http2-http3的区别"><a href="#http2-http3的区别" class="headerlink" title="http2/http3的区别"></a>http2/http3的区别</h5><h5 id="一百万条数据中查询一条数据"><a href="#一百万条数据中查询一条数据" class="headerlink" title="一百万条数据中查询一条数据"></a>一百万条数据中查询一条数据</h5><h5 id="如何根据电脑系统的亮度来调整background"><a href="#如何根据电脑系统的亮度来调整background" class="headerlink" title="如何根据电脑系统的亮度来调整background"></a>如何根据电脑系统的亮度来调整background</h5><h5 id="如果出现页面出现大面积空白解决方案"><a href="#如果出现页面出现大面积空白解决方案" class="headerlink" title="如果出现页面出现大面积空白解决方案"></a>如果出现页面出现大面积空白解决方案</h5><h5 id="scroll-behavior的值，及其作用"><a href="#scroll-behavior的值，及其作用" class="headerlink" title="scroll-behavior的值，及其作用"></a>scroll-behavior的值，及其作用</h5><h5 id="DOCTYPE的作用"><a href="#DOCTYPE的作用" class="headerlink" title="DOCTYPE的作用"></a>DOCTYPE的作用</h5><h5 id="JS如何上传多张png格式的图片"><a href="#JS如何上传多张png格式的图片" class="headerlink" title="JS如何上传多张png格式的图片"></a>JS如何上传多张png格式的图片</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/04/interview02/" data-id="cl9770wme000qk2oo820jg1qc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-interview01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/04/interview01/" class="article-date">
  <time datetime="2022-08-04T11:46:19.000Z" itemprop="datePublished">2022-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/interview/">interview</a>►<a class="article-category-link" href="/categories/interview/daily/">daily</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/04/interview01/">牛客网收集面试题答案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-说一说cookie-sessionStorage-localStorage-区别？"><a href="#1-说一说cookie-sessionStorage-localStorage-区别？" class="headerlink" title="1.说一说cookie sessionStorage localStorage 区别？"></a>1.说一说cookie sessionStorage localStorage 区别？</h4><p><strong>我的回答：</strong>cookie的大小只有4k,cookie是在浏览器中存储的，分为两种，内存cookie和硬盘cookie,默认的cookie就是内存cookie,没有设置过期时间，默认情况下就是浏览器关闭，cookie就会被浏览器删除，硬盘cookie是有设置过期时间，在过期时间之前，浏览器关闭，cookie不会被删除。把过期时间设置为负数或者0，可以删除cookie。</p>
<p>sessionStorage和localStorage不会自动存储，需要手动的存储数据，存储的数据量会比cookie大。sessionStorage只会在本次会话中存储，不会在新的页面中被获取。localStorage在页面关闭并且重新打开时不会被清除，sessionStorage会被清除。在页面内发生跳转不打开新的页面的时候，sessionStorage和localstorage不会被删除，在页面中跳转打开新的页面的时候，sessionStorage不保存，localstorage会保存</p>
<p><strong>参考答案：</strong>得分点 数据存储位置，生命周期，存储大小，写入方式，数据共享，发送请求是否携带，应用场景。相同点Cookie,SessionStorage，LocalStorage都是存储在浏览器本地的，不同点，cookie默认是浏览器关闭时候会被删除，可以设置过期时间，在过期时间内浏览器关闭，cookie不会删除。cookie一般是由服务端写入的，SessionStorage和LocalStorage是在客户端写入的，cookie的生命周期是由服务端设置好的，而LocalStorage是永远存在的，如果没有手动删除。SessionStorage页面关闭会被清除。sessionStorage只会在本次会话中存储，不会在新的页面中被获取，页面内发生跳转不打开新的页面时候，sessionStorage不会被清除，cookie的存储大小为4k,sessionStorage和localStorage存储大小为5M。cookie，sessionStorage,localStorage数据共享都是遵循同源策略原则，SessionStorage还必须限制在同一个页面。前端向后端发送数据的时候，cookie会自动携带，而localStorage和sessionStorage中的数据必须手动添加。应用场景：cookie可以存储登录的验证信息SessionId和token,localStorage通常存储不易变动的数据来减轻服务器的压力，SessionStorage可以用来检测用户是否刷新进入页面，像音乐播放器恢复播放进度条的功能</p>
<h4 id="2-说一说JS数据类型有哪些-区别是什么？"><a href="#2-说一说JS数据类型有哪些-区别是什么？" class="headerlink" title="2.说一说JS数据类型有哪些,区别是什么？"></a>2.说一说JS数据类型有哪些,区别是什么？</h4><p>数据类型有Null,undefined,Boolean,Number.String,Symbol,Bigint,Object8种数据类型</p>
<p>基本数据类型有null,undefined,boolean,number,string,symbol,bigint,引用数据类型包括普通的object，数组，正则，Date对象，Math内置对象，Function对象，包括ES6新增的Map和Set对象</p>
<p>基本数据类型是存储在栈中，引用数据类型存储在堆中的，引用数据类型在栈中存储了指针，该指针指向存储数据所在的堆内存的起始地址。</p>
<p>Symbol是ES6中新增的基本数据类型，可以产生一个独一无二的值，作为Object的key。Symbol创建的值具有唯一性，Symbol(key)!==Symbol(key),要获取对象中用symbol作为key的属性，必须通过Object.getOwnPropertySymbols(obj)</p>
<p>Bigint也是ES6新增的基本数据类型，来代表超出最大或者最小Number可以表示的值，不可以和Number混用</p>
<p>判断基本数据类型可以使用typeof 来判断，但是typeof null ===object typeof function===’function’</p>
<p>无法判断其他引用数据类型，必须使用instanceof来判断</p>
<h4 id="3-说一说你对闭包的理解？"><a href="#3-说一说你对闭包的理解？" class="headerlink" title="3.说一说你对闭包的理解？"></a>3.说一说你对闭包的理解？</h4><p>闭包就是内部函数访问外部环境的自由变量，外部变量可以引用另一个函数的内部函数，通过这个内部函数的引用来访问他的上层作用域，如果这个外部变量依然引用着这个函数，所以不会被垃圾回收器回收，而导致内存泄露。闭包可以模仿块级作用域，能够实现函数柯里化，在构造函数中使用特权方法，Vue中数据响应式Observer使用了闭包</p>
<h4 id="4-说一说promise是什么与使用方法？"><a href="#4-说一说promise是什么与使用方法？" class="headerlink" title="4.说一说promise是什么与使用方法？"></a>4.说一说promise是什么与使用方法？</h4><p>Promise是异步微任务，new Promise是同步执行，new Promise().then()是异步的，promise解决了异步多层嵌套回调，造成回调地狱的问题，让代码的可读性增加，更加容易维护。</p>
<p>promise的使用：通过new Promise()创建一个实例，传入一个包含resolve,reject作为参数的函调函数，执行成功是使用resolve(),执行失败是使用reject,promsie有三种状态，padding ,rejected,fulfilled,当状态发生改变的时候，就不会再更改，所以fulfilled状态执行resolve，rejected状态执行reject,然后会调用实例方法then(),then是异步调用，有两个回调函数，第一个是成功的回调，另外一个是失败的回调，失败的回调也可以链式调用使用catch传入失败的回调，promise.finally()不管成功还是失败都会执行，promsie中的类方法，Promsie.resolve()转换成fulfilled状态，并将参数传给then,Promise.reject()转换从rejected状态，并将给定的失败的信息传递给catch,any()方法会传入一个promise数组，只要有一个promise为fulfilled状态，则any也是fulfilled,只有全部为rejected则为rejected,allSettled()状态只有fulfilled状态，race()谁先改变状态就是使用谁的状态,all()只有全部为fulfilled才是fulfilled，有一个为reject则为reject</p>
<h4 id="5-说一说跨域是什么？如何解决跨域问题？"><a href="#5-说一说跨域是什么？如何解决跨域问题？" class="headerlink" title="5.说一说跨域是什么？如何解决跨域问题？"></a>5.说一说跨域是什么？如何解决跨域问题？</h4><p>由于同源策略，当出现请求页面的地址和当前页面地址协议，域名，端口号有一个不一致就会出现跨域。</p>
<p>解决跨域的方法</p>
<p>使用jsonp进行请求数据，并且通过回调函数来携带返回的数据</p>
<p>cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。<br>res.setHeader(‘Access-Control-Allow-Origin’, ‘*’);<br>res.setHeader(“Access-Control-Allow-Methods”, “GET, PUT, OPTIONS, POST”);</p>
<p>node中间件、nginx反向代理：跨域限制的时候浏览器不能跨域访问服务器，node中间件和nginx反向代理，都是让请求发给代理服务器，静态页面面和代理服务器是同源的，然后代理服务器再向后端服务器发请求，服务器和服务器之间不存在同源限制</p>
<p>JSONP：利用的原理是script标签可以跨域请求资源，将回调函数作为参数拼接在url中。后端收到请求，调用该回调函数，并将数据作为参数返回去，注意设置响应头返回文档类型，应该设置成javascript。</p>
<p>postmessage：H5新增API，通过发送和接收API实现跨域通信。</p>
<p>webpack中配置devServer中的proxy实现跨域</p>
<h4 id="6-说一说BFC"><a href="#6-说一说BFC" class="headerlink" title="6.说一说BFC"></a>6.说一说BFC</h4><p>BFC就是块级格式化上下文。他会形成一块独立的区域，不会影响边界以外的元素</p>
<p>BFC产生的条件</p>
<ol>
<li>根元素</li>
<li>浮动元素（float:left/float:right）</li>
<li>绝对定位元素(position:absolute,fixed)</li>
<li>行内块元素 display:inline-block</li>
<li>表格单元格 display:table-cell 表格的单元格默认就是</li>
<li>匿名表格单元格元素</li>
<li>overflow计算值不是visible的块元素</li>
<li>display:flex/inline-flex的直接子元素</li>
<li>display:grid或者inline-grid的直接子元素</li>
<li>display:flow-root元素</li>
</ol>
<p>作用</p>
<p>​    解决同一个BFC相邻两个box的margin会折叠的问题</p>
<p>​    解决浮动高度塌陷的问题，可以实现清除浮动的效果。通常是overflow:hidden</p>
<p>​        解决高度塌陷要满足以下条件</p>
<p>​            浮动元素的父元素触发BFC，形成BFC</p>
<p>​            浮动元素的父元素的高度是auto</p>
<p>​    BFC的高度是auto的情况下，高度的计算</p>
<p>​            如果只有inline-level 是行高的顶部和底部的距离</p>
<p>​            如果是block-level,是由最顶层块的上边缘到最底层块的下边缘之间距离</p>
<p>​            如果有绝对定位元素，将忽略</p>
<p>​            如果有浮动元素，则会增加高度包含浮动元素的下边缘</p>
<h4 id="7-说一说Vuex是什么，每个属性是干嘛的，如何使用-？"><a href="#7-说一说Vuex是什么，每个属性是干嘛的，如何使用-？" class="headerlink" title="7.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？"></a>7.说一说Vuex是什么，每个属性是干嘛的，如何使用 ？</h4><p>VueX是全局状态管理的工具。vuex的属性有state,getter,mutations,action,module，state属性用来存储公共管理的数据，mutations属性定义可以修改state中的数据，是同步修改的，所以不要在mutation中书写ajax代码，这样数据不可追踪，getters属性可以认为是定义store的计算属性。getter的返回值会根据他的依赖被缓存起来，且只有当他的依赖发生了改变才会被重新计算，action中进行异步操作，可以操作mutation来修改数据，mutation是修改数据的唯一方法。module可以将store分为多个模块，每个模块都有自己的mutation，state,getter,action,module。通过store.state可以获取state,可以用计算属性中的mapState,store.commit来提交mutation,可以使用mapMutation来映射多个mutation,store,dispatch来分发action,可以使用mapAction来映射多个action  ,获取getter可以使用store,getter,可以使用maGetter来映射多个getter</p>
<h4 id="8-说一说JavaScript有几种方法判断变量的类型？"><a href="#8-说一说JavaScript有几种方法判断变量的类型？" class="headerlink" title="8.说一说JavaScript有几种方法判断变量的类型？"></a>8.说一说JavaScript有几种方法判断变量的类型？</h4><p>typeof 可以用来判断基本数据类型  还可以判断Function ,其他引用数据类型都是返回Object,null也是返回object</p>
<p>constructor可以判断引用数据类型 就是判断instance.<strong>proto</strong>.constructor=Function</p>
<p>instanceOf也可以判断引用数据类型 单数不能判断基本数据类型，就是运用原型链，判断右边的原型是否在左边的原型链上</p>
<p>Object.prototype.toString.call也可以用来判断引用数据类型</p>
<h4 id="9-说一说样式优先级的规则是什么？"><a href="#9-说一说样式优先级的规则是什么？" class="headerlink" title="9.说一说样式优先级的规则是什么？"></a>9.说一说样式优先级的规则是什么？</h4><p>样式的优先级应该分为4大类</p>
<p>第一类 !important的优先级最高，无论是什么引用方式，什么选择器</p>
<p>第二类是引用方式  行内样式优先级高于嵌入样式和外部样式，如果嵌入样式和外部样式使用相同的选择器，则看他们谁后引入，被覆盖</p>
<p>第三类是选择器</p>
<p>id选择器&gt;类选择器，属性选择器，伪类选择器&gt;元素选择器，伪元素选择器&gt;通配符选择器</p>
<p>第四类是默认样式</p>
<p> important 10000<br> 内联选择器 1000<br> id选择器 100<br> 类选择器，属性选择器，伪类 10<br> 元素选择器，伪元素 1<br> 通配选择器  0</p>
<h4 id="10-说一说JS实现异步的方法？"><a href="#10-说一说JS实现异步的方法？" class="headerlink" title="10.说一说JS实现异步的方法？"></a>10.说一说JS实现异步的方法？</h4><p>得分点 回调函数、事件监听、setTimeout、Promise、生成器Generators/yield、async/await,</p>
<p>所有的异步代码都会在同步代码执行完后，从异步队列中取出依次执行。回调函数是最基本的异步函数，例如ajax请求，回调函数的有点是简单，容易理解和实现，缺点是不利于代码的阅读和理解，各个部分耦合度高，使得程序结构混乱，流程难以追踪(尤其是多个回调函数嵌套的情况，容易出现回调地狱)，而且每个任务只能指定一个回调函数，回调函数不能使用try..catch来捕获错误，不能直接·return  ,Promise包装了一个异步调用并且生成了一个promise实例，promise不经可以捕获错误，而且可以很好的解决回调地狱的问题，缺点是没办法取消promise,错误需要使用回调函数来捕获。generator函数是ES6提供的异步编程的解决方案，generator是一个状态机，封装了多个内部状态，可以暂停函数，yield可以暂停执行，next可以继续执行,每次返回都是yield的结果。优点是语义清晰，但是需要手动调用。async/await是基于Promises实现的，await会阻塞后面的代码的执行。如果多个异步代码没有依赖性却使用了await会降低性能</p>
<h4 id="11-说一说Vue2-0-双向绑定的原理与缺陷？"><a href="#11-说一说Vue2-0-双向绑定的原理与缺陷？" class="headerlink" title="11.说一说Vue2.0 双向绑定的原理与缺陷？"></a>11.说一说Vue2.0 双向绑定的原理与缺陷？</h4><p>Vue的响应式原理：采用数据劫持和发布者-订阅者模式相结合的方式，遍历对象中的属性使用Object.defineProperty劫持各个属性的getter和setter方法，在数据发生变化的时候，触发setter,进而调用对应的notify方法执行依赖该属性的函数，进而更新页面的DOM。读取该属性的时候会触发getter，使用Object.defineProperty不能够监听对象的新增属性和删除属性。不可以监听通过数组索引来修改数据，不能够修改length,而监听到变化</p>
<h4 id="12-说一说数组去重都有哪些方法？"><a href="#12-说一说数组去重都有哪些方法？" class="headerlink" title="12.说一说数组去重都有哪些方法？"></a>12.说一说数组去重都有哪些方法？</h4><p>方式一：使用new Set(arr)进行去重，然后再使用Array.from()或者扩展运算符转成数组</p>
<p>方式二:    使用filter+indexOf来去重</p>
<p>方式三:   使用双重for循环+splice来进行去重</p>
<p>方式四:   使用[]+indexOf来去重</p>
<p>方式五:   使用sort去重，先进行排序，然后再进行当前索引和下一个索引值进行比较，push进新的数组</p>
<p>方式六:   使用对象属性不能相同的特点去重，以数组每一个item作为object的key,通过for循环判断obj[arr[i]]是否存在，如果不存在则push,并且obj[arr[i]]=1,否则就是obj[arr[i]]++</p>
<p>方式七：使用includes来去重，可以区别Nan,可以判断新的数组中是否包含这个值，不包含就push</p>
<p>方式八：使用hasOwnProperty来去重</p>
<p>方式九：先进行排序，然后在进行递归，splices删除重复数据</p>
<p>方式十：使用Map数据结构来去重，通过has判断，如果为false就push，并且set值，</p>
<p>方式十一：使用reduce+includes来去重，判断pre中是否存在</p>
<h4 id="13-说一说null-和-undefined-的区别，如何让一个属性变为null"><a href="#13-说一说null-和-undefined-的区别，如何让一个属性变为null" class="headerlink" title="13.说一说null 和 undefined 的区别，如何让一个属性变为null"></a>13.说一说null 和 undefined 的区别，如何让一个属性变为null</h4><p><strong>得分点 操作的变量没有被赋值、全局对象的一个属性、函数没有return返回值、值 <code>null</code> 特指对象的值未设置 undefined == null、undefined !== null</strong> </p>
<p>一个变量定义了，但是没有进行初始化，那他的值就是undefined。函数没有指定return的值，默认就是undefined。对象中某个属性不存在就是undefined，函数定义了形参，但是没有定义默认参数，实参就是undefined,undefined可以通过typeof 来判断是否undefined,undefined==undefined,undefined===undefined。null就是对象的值未设置，一个对象没有设置指针地址就是null,null通过typeof判断类型是object,null==null,null===null,null==undefined,null!==undeined,undefined表示未设置值的默认状态，null表示手动设置为空对象，儿不是默认状态，在实际使用过程中，变量不需要手动的赋值undefined,如果需要手动的释放对象，可以赋值null,typeof会判断为object,是因为js数据类型在底层都是以二进制的形式表示的，二进制的前三位为0会被typeof判断为objet,而null的二进制全是0，当对象被赋值为0以后就会被垃圾回收器择机回收并且释放内存</p>
<h4 id="14-说一下浮动"><a href="#14-说一下浮动" class="headerlink" title="14.说一下浮动"></a>14.说一下浮动</h4><p>float属性可以指定一个元素向左或者向右浮动，浮动元素会脱离标准流</p>
<p>浮动规则一</p>
<p>​    元素一旦浮动后，脱离标准流</p>
<p>​            朝着向左或者向右方向移动，直到自己的边界紧贴者包含块(一般是父元素)或者其他浮动元素的边界为止</p>
<p>​            定位元素会层叠在浮动元素上面</p>
<p>浮动规则二</p>
<p>​    如果元素是向左或者向右浮动，浮动的元素的左右边界不能超过包含快的左右边界</p>
<p>浮动规则三</p>
<p>​    浮动元素之间不能够层叠，如果一个元素浮动，后面的元素会紧挨着前面的浮动元素排列，如果剩下的空间不够放下一个浮动元素则会向下移动，找到可以放下的空间</p>
<p>浮动规则四</p>
<p>​    浮动元素不能与行内级内容层叠，行内级内容会被推出去</p>
<p>浮动规则五</p>
<p>​    行内级元素，inline-block元素浮动后，其顶部将与所在行的顶部对齐</p>
<p>浮动的问题</p>
<p>​    由于浮动的元素脱离了标准流·，变成了脱标元素，所以不在向父元素汇报高度，父元素计算高度的时候不计算浮动元素的高度，所以会造成内容塌陷</p>
<p>解决高度塌陷的方法</p>
<p>​    方法一，给父元素设置固定高度。扩展性不好</p>
<p>​    方法二，给父元素最后添加一个空的块级元素，并且设置为clear:both。这样会增加无意义的空标签，维护麻烦，违反了结构与样式分离的原则</p>
<p>​    方式三，给父元素添加一个伪元素，::after,设置content:””,display:block，overflow:hidden,clear:both,visibility:hidden,height:0,   为了兼容IE6/7还要加上*zoom:1</p>
<h4 id="15-说一说es6中箭头函数？"><a href="#15-说一说es6中箭头函数？" class="headerlink" title="15.说一说es6中箭头函数？"></a>15.说一说es6中箭头函数？</h4><p>箭头函数中没有this,箭头函数中的this指向是由上层作用域的中非箭头函数this决定的，箭头函数中没有arguments,如果箭头函数中出现arguments，则由上层作用域非箭头函数的arguments决定，箭头函数中arguments可以使用rest参数替代，箭头函数不可以作为构造函数，没有super()和原型,箭头函数不可以使用call,apply,bind显示绑定来改变this的指向，箭头函数不可以作为generator函数。箭头函数不能作为事件绑定的回调函数，如果使用了this，该this不会指向触发事件的元素，而是指向window。箭头函数适用于需要引用上层作用域的this,可以替代var _this=this,或者没有使用到this的函数</p>
<h4 id="16-说一说call-apply-bind的作用和区别？"><a href="#16-说一说call-apply-bind的作用和区别？" class="headerlink" title="16.说一说call apply bind的作用和区别？"></a>16.说一说call apply bind的作用和区别？</h4><p>call,apply,bind可以显示进行this的绑定，call可以传多个参数，并且立即执行函数，apply第二个参数传的是函数，也是会立即执行，bind可以传多个参数，并且会返回新的函数，call,apply还可以用于函数的执行。call,apply可以用于对象的继承，将伪数组转成真数组，进行原型链方法的借调，等等，bind可以用于react中this的绑定</p>
<h4 id="17-说一说this指向（普通函数、箭头函数）？"><a href="#17-说一说this指向（普通函数、箭头函数）？" class="headerlink" title="17.说一说this指向（普通函数、箭头函数）？"></a>17.说一说this指向（普通函数、箭头函数）？</h4><p>默认绑定this是指向全局window，普通函数的调用</p>
<p>隐式绑定this是指向调用的对象，对象调用方法时</p>
<p>显示绑定this指向绑定的值</p>
<p>new绑定this指向新创建的对象</p>
<p>箭头函数中没有this,this是由上层作用域中非箭头函数决定的</p>
<p>在严格模式下，this默认是undefined</p>
<p>默认绑定的优先级最低</p>
<p>显示绑定的优先级高于隐式绑定</p>
<p>new绑定的优先级高于bind</p>
<p>new绑定优先级高于隐式绑定</p>
<p>bind的优先级高于call/apply</p>
<p>new不可以和call/apply一起使用</p>
<p>setTimeout中this默认指向window</p>
<p>事件绑定中this指向绑定的元素</p>
<h4 id="18-说一说CSS尺寸设置的单位"><a href="#18-说一说CSS尺寸设置的单位" class="headerlink" title="18.说一说CSS尺寸设置的单位"></a>18.说一说CSS尺寸设置的单位</h4><p>px是绝对长度单位，em,rem,vw/vh是相对长度单位</p>
<p>em是在font-size中默认使用相对于父元素的字体大小,如果自己定义了font-size,则根据自身的font-size进行定义，其他属性也是相对于自身的font-size,</p>
<h4 id="19-说一说HTML语义化？"><a href="#19-说一说HTML语义化？" class="headerlink" title="19.说一说HTML语义化？"></a>19.说一说HTML语义化？</h4><h4 id="20-说几个未知宽高元素水平垂直居中方法"><a href="#20-说几个未知宽高元素水平垂直居中方法" class="headerlink" title="20.说几个未知宽高元素水平垂直居中方法"></a>20.说几个未知宽高元素水平垂直居中方法</h4><h4 id="21-说一说JS变量提升？"><a href="#21-说一说JS变量提升？" class="headerlink" title="21.说一说JS变量提升？"></a>21.说一说JS变量提升？</h4><p>函数和var 声明的变量在代码编译阶段会提升到最前面，但此时var声明的变量还没有赋值，所以此时访问是undefined,而函数可以在函数定义之前被调用，因为函数是一等公民，函数声明的提升优先级会比变量提升高，let,const不会出现变量提升，let const在定义以前访问会出现暂时性死区</p>
<h4 id="22-说一说-HashRouter-和-HistoryRouter的区别和原理？"><a href="#22-说一说-HashRouter-和-HistoryRouter的区别和原理？" class="headerlink" title="22.说一说 HashRouter 和 HistoryRouter的区别和原理？"></a>22.说一说 HashRouter 和 HistoryRouter的区别和原理？</h4><p>HashRouter  和 HistoryRouter都是利用浏览器的两种特性来实现前端路由的，根据这两种特性，可以实现不需要刷新页面的去修改内容。HashRouter就是利用通过监听window.onhashchange根据location.hash的变化来修改Dom,url中hashRouter和historyRouter的不同是，hash会在url中有#这样的hash值，而history没有。historyRouter是根据h5新增的历史调用栈API来实现的，他有六种模式来改变url而不会重新刷新页面</p>
<p>history.replaceState():替换原来的路径</p>
<p>history.pushState() 使用新的路径</p>
<p>history.popState()  路径的回退</p>
<p>history.back() 向后改变路径</p>
<p>history.go() 跳转至那个路径</p>
<p>通过window.onpopState来监听浏览器的前进和后退，pushState和replaceState都是可以携带参数，hash可以兼容低版本的浏览器，如果想传递任意类型的数据到记录栈可以使用history,history需要后端配合，如果后端不配合，就会出现404，而hash不需要</p>
<h4 id="23-说一说map-和-forEach-的区别？"><a href="#23-说一说map-和-forEach-的区别？" class="headerlink" title="23.说一说map 和 forEach 的区别？"></a>23.说一说map 和 forEach 的区别？</h4><p>得分点 map创建新数组、map返回处理后的值、forEach()不修改原数组、forEach()方法返回undefined</p>
<p>map会返回新的数组，forEach不会修改原来的数组，map需要return foreach不需要return,foreach中return是无效的，map中this默认指向undefined,foreach中this默认指向window,forEach不能终端执行，只能够抛出异常来终止执行。forEach没有返回值新的数组所以不能够进行链式调用，map的处理数组比foreach快</p>
<h4 id="24-说一说事件循环Event-loop，宏任务与微任务？"><a href="#24-说一说事件循环Event-loop，宏任务与微任务？" class="headerlink" title="24.说一说事件循环Event loop，宏任务与微任务？"></a>24.说一说事件循环Event loop，宏任务与微任务？</h4><p>js代码执行过程中，同步代码先执行，要到定时器，就会先将定时器先挂起，继续向下执行，执行到异步代码，就会将异步代码进入事件队列，宏任务就会进入宏任务队列，微任务就是进入微任务事件队列，同步代码执行完后，就会从事件队列中取出异步代码，进入执行上下文调用栈，微任务先执行，执行完后在执行宏任务，等定时器到期之后也会加入到事件队列，就这样不断的循环往复执行，就是事件循环，事件循环包括浏览器的事件循环和Node的事件循环，浏览器的事件循环中宏任务包括定时器，ajax请求，window.postmessage,setImmediate,UI render,Dom监听，微任务包括promise的then回调，async/await,Mutation Obderver，queueMicrotask。Node的事件循环中微任务为process.nexttick,promise的then回调，queueMicrotask,宏任务队列包括，定时器，ID事件，setImmediate,close事件</p>
<h4 id="25-说一说Vue3-0-实现数据双向绑定的方法-？"><a href="#25-说一说Vue3-0-实现数据双向绑定的方法-？" class="headerlink" title="25.说一说Vue3.0 实现数据双向绑定的方法 ？"></a>25.说一说Vue3.0 实现数据双向绑定的方法 ？</h4><p>vue3中实现数据双向绑定采用new Proxy来替代Object.defineProperty实现，proxy可以监听整个对象，使用new proxy()将需要监听的对象作为参数传递，并且有13中拦截器，可以对对象以及函数进行监听，例如监听对象属性的getter,setter,delete操作,in操作，defineProperty操作等，可以解决object.defineproperty不可以监听对象属性的新增和删除操作，不可以监听数组通过索引赋值，和手动给length赋值等操作</p>
<h4 id="26-说一下Diff算法？"><a href="#26-说一下Diff算法？" class="headerlink" title="26.说一下Diff算法？"></a>26.说一下Diff算法？</h4><p>得分点 patch、patchVnode、updateChildren、vue优化时间复杂度为O(n) </p>
<p>diff算法中的比较过程，第一步：patch函数首先会对新旧节点进行比较，如果旧的节点存在且和新的节点类型不同，则会销毁旧的节点。如果旧节点存在，如果新旧节点类型相同时，然后对新的节点的类型进行判断，如果是文本节点，则直接替换成文本节点，如果是注释节点也是直接的插入。处理静态节点，处理fragment组件节点等，然后就是处理普通的Dom元素和组件节点等等，在处理普通元素的时候，他会先判断旧节点是否存在，不存在则直接挂在。否则调用patchElement函数。在执行patchElement的时候首先处理props的情况，先将新的节点的props全部挂载到el上，判断旧节点的props是否不需要在新的节点上，如果不需要，那么删除对应的属性。然后通过调用patchChildren来对比子元素，如果新的节点是一个字符串类型，则直接调用el.textContent=newChildren,如果新节点不是字符串类型，旧节点是字符串类型，那么直接遍历新的节点，挂载到el上，如果新旧节点都是数组，则会分为有key和没有key两种，有key则调用patchKeyedChildren方法，没有key则调用patchUnkeyedChildren方法。调用patchUnkeyedChildren方法时，会获取到长度最小的那个节点，for循环依次进行patch，patch完之后，剩下的节点，如果旧的长度大于新的，则移除这些节点，如果新的长度大于旧的长度则创建新的节点，如果有key则会调用patchKeyedChildren方法，首先节点会从头部开始比较，如果两个节点相同则会调用patch,并且i++,如果节点不同则会跳出循环，然后再从尾部进行比较，重复相同的步骤，并且e1–,e2–,如果i&gt;e1而且i&lt;e2,就是旧的节点遍历完了，依然有新的节点，则进行挂载，如果新的节点遍历完，旧的节点还有则移除旧的节点。对于剩下的未知的序列，就是无须的序列，首先会根据key建立map索引图， 遍历剩下的旧节点, 新旧对比, 移除不使用的旧节点，oldIndex = 0 是一个特殊值，表示新节点没有对应的旧节点。用于确定最长稳定子序列，建立新的vnode的key的位置在旧的vnode的映射，然后for遍历旧节点中还没有被对比的节点，如果该节点已经被patch过，则卸载掉，如果在旧的vnode中key存在，在获取相同的key在新vnode的位置，如果存在，则新节点在旧节点的映射中设置所以旧节点的索引位置，然后进行新旧节点的patch,如果在旧node中key不存在，试图定位一个相同类型的没有key的节点的位置，准备用这个替换成新的值，从新结点中找到类型相同，且在旧节点没有对应映射的节点，设置进去，如果在新的vnode中没有对应的映射，就是在新的vnode中不存在这个key了，就卸载掉</p>
<h4 id="27-说一说三栏布局的实现方案"><a href="#27-说一说三栏布局的实现方案" class="headerlink" title="27.说一说三栏布局的实现方案"></a>27.说一说三栏布局的实现方案</h4><p>圣杯布局，双飞翼布局</p>
<h4 id="28-说一下浏览器垃圾回收机制？"><a href="#28-说一下浏览器垃圾回收机制？" class="headerlink" title="28.说一下浏览器垃圾回收机制？"></a>28.说一下浏览器垃圾回收机制？</h4><h4 id="29-说一说-vue-的-keep-alive-？"><a href="#29-说一说-vue-的-keep-alive-？" class="headerlink" title="29.说一说 vue 的 keep-alive ？"></a>29.说一说 vue 的 keep-alive ？</h4><h4 id="30-CSRF攻击是什么？"><a href="#30-CSRF攻击是什么？" class="headerlink" title="30.CSRF攻击是什么？"></a>30.CSRF攻击是什么？</h4><h4 id="31-XSS攻击是什么？"><a href="#31-XSS攻击是什么？" class="headerlink" title="31.XSS攻击是什么？"></a>31.XSS攻击是什么？</h4><h4 id="32-说一说js继承的方法和优缺点？"><a href="#32-说一说js继承的方法和优缺点？" class="headerlink" title="32.说一说js继承的方法和优缺点？"></a>32.说一说js继承的方法和优缺点？</h4><h4 id="33-说一说defer和async区别？"><a href="#33-说一说defer和async区别？" class="headerlink" title="33.说一说defer和async区别？"></a>33.说一说defer和async区别？</h4><p>默认情况下浏览器下载完js代码会立即执行，如果js需要操作dom,则会阻塞页面的渲染，async属性可以使加载js文档和dom树的构建同时进行，当js加载完成，js代码执行，会阻塞html的渲染，defer会等到dom构建完成以后再加载js代码。</p>
<p>defer是js的下载和执行不阻塞DOM tree的构建，defer中的js代码执行的时候Dom构建完成，defer会在DomcontenLoad之后执行，多个设置defer的script会按顺序加载，defer仅适用于外部脚本，对script的内容会忽略。而async不能保证顺序执行，不会阻塞DOM渲染，不能保证DOMContentLoaded之前或者之后执行，async用于独立脚本执行，就是那些不需要依赖外部文件的脚本</p>
<p>加分项：阻塞的原因：由于js是可以操作dom的，如果在修改这些元素的时候同时渲染界面即js线程和ui线程同时运行，那么渲染线程前后获得的数据可能不一致，因此为了防止渲染出现不可以预测的效果，所以浏览器设置GUI渲染线程和js引擎为互斥的关系当浏览器执行js代码的时候渲染线程就会被保存在一个队列中，直到js程序执行完成才会接着执行。如果js执行事件过长，就会造成渲染界面过程不连贯，导致页面渲染加载阻塞的感觉</p>
<h4 id="34-说一下浏览器如何渲染页面的"><a href="#34-说一下浏览器如何渲染页面的" class="headerlink" title="34.说一下浏览器如何渲染页面的"></a>34.说一下浏览器如何渲染页面的</h4><p>浏览器首先会解析页面，把html构建成DOM树，css构建成cssom树，css的加载不会阻塞dom树的构建，然后将dom树和cssom树整合成render树，如果加载到script标签，会阻塞页面的渲染进程，所以需要把script放在底部，然后执行js代码，经过布局和绘制，最终渲染到屏幕上</p>
<h4 id="35-说一说vue-computed和watch的区别？"><a href="#35-说一说vue-computed和watch的区别？" class="headerlink" title="35.说一说vue computed和watch的区别？"></a>35.说一说vue computed和watch的区别？</h4><p>当需要依赖其他状态来产生新的状态的时候，可以使用computed,computed适用于计算比较多的场景。computed依赖于其他状态，computed是同步的，而且有缓存，如果依赖的状态没有发生变化，他不会重新计算，computed默认是调用getter方法，也可以修改数据调用setter方法，watch是作为侦听器，可以监听data，props,emit等属性的变化，也是有惰性的，watch在数据初始化的时候不会执行，只有在数据变化的时候才会执行，可以设置immediate:true来让watch立即执行一次，watch默认不能够监听对象的属性的变化，可以设置deep:true,对对象进行深度监听</p>
<h4 id="36-说一说-Vue-中-nextTick-作用与原理？"><a href="#36-说一说-Vue-中-nextTick-作用与原理？" class="headerlink" title="36.说一说 Vue 中 $nextTick 作用与原理？"></a>36.说一说 Vue 中 $nextTick 作用与原理？</h4><p>得分点 异步渲染、获取DOM、Promise </p>
<p>将回调延迟到下一次DOM更新循环之后执行，在修改数据之后立即执行它，然后等待DOM更新</p>
<p>ue更新DOM是异步执行的，在修改数据后，视图不会立刻更新，而是等待同一事件循环中所有数据变化之后，同意更新视图，所以修改完数据，立刻获得的是未修改的dom,nextTrick就可以在DOM更新之后执行回调函数，解决异步渲染不可以获取到更新之后的DOM的问题，nextTick会返回一个promise,所以可以使用async/await</p>
<p>应用场景：在钩子函数created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中</p>
<h4 id="37-说一说new会发生什么？"><a href="#37-说一说new会发生什么？" class="headerlink" title="37.说一说new会发生什么？"></a>37.说一说new会发生什么？</h4><ol>
<li>创建一个空对象</li>
<li>让这个空对象的[[prototype]]属性指向构造函数的prototype</li>
<li>让构造函数中的this指向新创建的对象</li>
<li>执行该构造函数</li>
<li>如果构造函数没有返回对象则返回新创建的对象</li>
</ol>
<h4 id="38-说一下token-能放在cookie中吗？"><a href="#38-说一下token-能放在cookie中吗？" class="headerlink" title="38.说一下token 能放在cookie中吗？"></a>38.说一下token 能放在cookie中吗？</h4><p>得分点 能、不设置cookie有效期、重新登录重写cookie覆盖原来的cookie </p>
<p>token一般用来判断用户是否登录，它内部包含的信息包括uid(用户唯一的身份标识)，time(当前的时间戳)，sign(签名，token的前几位是以哈希算法压缩成的一定长度地十六进制字符串)，token可以存放在cookie，token是否过期由后端决定，所以token存储在cookie中只要不设置cookie的过期时间就可以，如果token失效，只要返回固定状态表示token失效，需要重新登录，重新设置cookie中的token就可以了，</p>
<h4 id="39-说一下浏览器输入URL发生了什么？"><a href="#39-说一下浏览器输入URL发生了什么？" class="headerlink" title="39.说一下浏览器输入URL发生了什么？"></a>39.说一下浏览器输入URL发生了什么？</h4><h4 id="40-说一说组件通信的方式？"><a href="#40-说一说组件通信的方式？" class="headerlink" title="40.说一说组件通信的方式？"></a>40.说一说组件通信的方式？</h4><h4 id="41-说一说-v-if-和-v-show区别？"><a href="#41-说一说-v-if-和-v-show区别？" class="headerlink" title="41.说一说 v-if 和 v-show区别？"></a>41.说一说 v-if 和 v-show区别？</h4><p>v-if是条件渲染，是惰性的，只有在条件判断为true的时候才会渲染到页面中去，v-show相当于设置display来进行切换，所有v-if有更高的切换开销，v-show有更高的切换开销，如果需要频繁切换，需要使用v-show，v-else和template不可以用于v-show，v-show无论如何它的DOM实际上都是存在的，只是通过CSS来切换display属性，当v-if当条件为false时，其对应的元素不会渲染到DOM中</p>
<h4 id="42-React生命周期的各个阶段是什么？"><a href="#42-React生命周期的各个阶段是什么？" class="headerlink" title="42.React生命周期的各个阶段是什么？"></a>42.React生命周期的各个阶段是什么？</h4><h4 id="43-React组件间传值的方法有哪些？"><a href="#43-React组件间传值的方法有哪些？" class="headerlink" title="43.React组件间传值的方法有哪些？"></a>43.React组件间传值的方法有哪些？</h4><p>父组件向子组件传值是使用props进行传递，</p>
<p>子组件向父组件传值，可以使用回调函数，父组件向子组件传递回调函数，子组件执行回调函数并传递参数</p>
<p>子孙组件之间的传递可以使用createContext()</p>
<p>兄弟组件间的数据传递可以使用事件总线来传递</p>
<p>还可以使用redux进行全局状态管理</p>
<h4 id="44-说一说盒模型？"><a href="#44-说一说盒模型？" class="headerlink" title="44.说一说盒模型？"></a>44.说一说盒模型？</h4><p>盒模型分为IE的盒模型和W3C的盒模型，W3C的盒模型指的是content的宽高，IE的盒模型是将content,padding,margin包含在宽度和高度之内，可以使用css ,box-sizing:border-box来将W3C的盒模型转换成IE盒模型，默认是content-box</p>
<h4 id="45-说一说伪数组和数组的区别？"><a href="#45-说一说伪数组和数组的区别？" class="headerlink" title="45.说一说伪数组和数组的区别？"></a>45.说一说伪数组和数组的区别？</h4><p>得分点 类型是object、不能使用数组方法、可以获取长度、可以使用for in遍历</p>
<p>数组的类型是Array,类数组的类型是object,类数组可以使用length查看长度，可以使用索引来获得值，但是不可以修改length,不能使用array的方法，可以使用forin进行遍历，类数组常用的场景：函数参数argumenrs,NodeList等，类数组转成数组方法，Array.from(arr),Array.prototype.slice.call(arr),索引不连续时会自动补位</p>
<h4 id="46-说一说如何实现可过期的localstorage数据？"><a href="#46-说一说如何实现可过期的localstorage数据？" class="headerlink" title="46.说一说如何实现可过期的localstorage数据？"></a>46.说一说如何实现可过期的localstorage数据？</h4><h4 id="47-说一说axios的拦截器原理及应用？"><a href="#47-说一说axios的拦截器原理及应用？" class="headerlink" title="47.说一说axios的拦截器原理及应用？"></a>47.说一说axios的拦截器原理及应用？</h4><h4 id="48-说一说创建ajax过程？"><a href="#48-说一说创建ajax过程？" class="headerlink" title="48.说一说创建ajax过程？"></a>48.说一说创建ajax过程？</h4><h4 id="49-说一下fetch-请求方式？"><a href="#49-说一下fetch-请求方式？" class="headerlink" title="49.说一下fetch 请求方式？"></a>49.说一下fetch 请求方式？</h4><h4 id="50-说一下有什么方法可以保持前后端实时通信？"><a href="#50-说一下有什么方法可以保持前后端实时通信？" class="headerlink" title="50.说一下有什么方法可以保持前后端实时通信？"></a>50.说一下有什么方法可以保持前后端实时通信？</h4><h4 id="51-说一下重绘、回流区别如何避免？"><a href="#51-说一下重绘、回流区别如何避免？" class="headerlink" title="51.说一下重绘、回流区别如何避免？"></a>51.说一下重绘、回流区别如何避免？</h4><p>对节点的大小，位置的修改重新计算被称为回流，例如DOM结构的改变(添加新的节点或者删除节点)</p>
<p>改变布局，例如修改了width,height,padding,font-size等值</p>
<p>窗口resize、(修改了窗口的尺寸)</p>
<p>调用getComputedStyle方法获取尺寸，位置信息等</p>
<p>修改背景色，字体颜色，边框颜色，边框样式等，</p>
<p>回流一定会引起重绘，重绘不一定会引起回流，所以应该减少回流</p>
<p>1.修改样式尽量一次性修改，例如通过cssText,classList,class来修改</p>
<p>2.避免频繁的操作DOM，可以是用document.documentFragment批量修改片段</p>
<p>3.避免使用getComputedStyle频繁获取计算值，如果需要，可以将计算值存储起来</p>
<p>4.修改DOM可以先设置diaplay:none，是他不存在render树，再进行修改，修改完成后再加入render树中</p>
<p>5.对某些元素使用position:absolute,fixed使其脱离标准流，这样开销会比较小</p>
<p>6.默认情况下，标准流中的内容都会被绘制在同一个图层上，利用一些属性创建一个新的合成图层，这些layer可以使用GPU加速绘制，因为这些图层都是单独渲染，减少了回流和重绘，例如3d transform,vedio,canvas,iframe,opacity动画转换，position:fixed,animation或者transition设置了opacity,transorm.分层确实可以提高性能，但是不要过度使用，她是以内存为代价的</p>
<h4 id="52-说一说-Vue-列表为什么加-key？"><a href="#52-说一说-Vue-列表为什么加-key？" class="headerlink" title="52.说一说 Vue 列表为什么加 key？"></a>52.说一说 Vue 列表为什么加 key？</h4><p>得分点 性能优化、diff算法节点比对、key不能是index</p>
<p>key属性主要时用在Vue的虚拟DOM算法，在新旧Vnode对比时辨识vnodes,如果不使用key,vue会使用一种最大限度减少动态元素并且尽可能减少的尝试就地修改/复用相同类型元素的算法，而使用key，他会基于key的变化重新排列元素顺序，并且移除或者销毁不需要的元素</p>
<p>相同的父元素的子元素的key必须唯一，如果有重复的可以会渲染错误</p>
<p>如果使用index作为key,没有优化效果，因为index会改变</p>
<p>它也可以用于强制替换元素或者组件而不是重复使用它时。当你遇到如下场景时它可能会很有用：</p>
<ul>
<li><p>完整地触发组件的生命周期钩子</p>
</li>
<li><p>触发过渡</p>
</li>
</ul>
<h4 id="53-说一说vue-router-实现懒加载的方法？"><a href="#53-说一说vue-router-实现懒加载的方法？" class="headerlink" title="53.说一说vue-router 实现懒加载的方法？"></a>53.说一说vue-router 实现懒加载的方法？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vue实现懒加载的两种方法</span><br><span class="line">component：resolve=&gt;require([&quot;./app.vue&quot;],resolve)</span><br><span class="line">component:()i=&gt;import(/*webpackChunkName:app*/&quot;./app.vue&quot;)</span><br><span class="line"></span><br><span class="line">webpackChunkName可以不写</span><br><span class="line">不要在路由中使用异步组件。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。</span><br><span class="line">webpack会进行代码分隔，进行独立打包，当使用道德时候才会加载，vue-router只会第一次加载时获取，以后都会使用缓存</span><br></pre></td></tr></table></figure>

<h4 id="55-ReactRouter基本用法是什么？"><a href="#55-ReactRouter基本用法是什么？" class="headerlink" title="55.ReactRouter基本用法是什么？"></a>55.ReactRouter基本用法是什么？</h4><h4 id="56-setState是同步还是异步的？"><a href="#56-setState是同步还是异步的？" class="headerlink" title="56.setState是同步还是异步的？"></a>56.setState是同步还是异步的？</h4><p>setState在组件生命周期或者react合成事件中，setState是异步的</p>
<p>在原生的dom事件中，setTimeout中，setState是同步的</p>
<p>setState设计为异步，可以显著提升性能，如果每次调用setState都进行更新，那么意味着render函数会被频繁的调用，页面会重新渲染，这样效率很低，最好的办法因该是活得多个更新，然后进行批量更新，</p>
<p>如果同步进行更新state,但是还没有执行render函数，那么state,props不能保持同步，state和props不一致，在开发中会产生很多问题</p>
<h4 id="57-React事件绑定原理"><a href="#57-React事件绑定原理" class="headerlink" title="57.React事件绑定原理"></a>57.React事件绑定原理</h4><p>得分点 非原生事件、SyntheticBaseEvent </p>
<p>React中的事件不是原生的事件，而是对原生的event进行封装的新类SyntheticBaseEvent，模拟处DOM事件的所有功能,通过event.nativeEvent可以获得原生事件，react将所有的事件都绑定在root根组件上，之前都是绑定在document上的，react中的事件和DOM事件不一样，和vue也不一样，react并不是将click事件绑定在该div的真实DOM上，而是在root处监听所有支持的事件，当事件发生并冒泡到root处时，react将事件内容封装并交给真正的处理函数运行，这样的方式不仅减少了内存的消耗，还能再组件挂载销毁时统一订阅和移除事件，另外冒泡到root上的事件也不是原生浏览器事件，而是React自己实现的合成事件(SyntheticBaseEvent),因此我们如果不想要事件冒泡的话，调用event.stopPropagation是无效的，应该调用event.preventDefault</p>
<h4 id="58-React中hooks的优缺点是什么？"><a href="#58-React中hooks的优缺点是什么？" class="headerlink" title="58.React中hooks的优缺点是什么？"></a>58.React中hooks的优缺点是什么？</h4><h4 id="59-说一说前端性能优化手段？"><a href="#59-说一说前端性能优化手段？" class="headerlink" title="59.说一说前端性能优化手段？"></a>59.说一说前端性能优化手段？</h4><h4 id="60-说一说性能优化有哪些性能指标，如何量化？"><a href="#60-说一说性能优化有哪些性能指标，如何量化？" class="headerlink" title="60.说一说性能优化有哪些性能指标，如何量化？"></a>60.说一说性能优化有哪些性能指标，如何量化？</h4><h4 id="61-说一说服务端渲染？"><a href="#61-说一说服务端渲染？" class="headerlink" title="61.说一说服务端渲染？"></a>61.说一说服务端渲染？</h4><h4 id="62-事件扩展符用过吗-…-，什么场景下？"><a href="#62-事件扩展符用过吗-…-，什么场景下？" class="headerlink" title="62.事件扩展符用过吗(…)，什么场景下？"></a>62.事件扩展符用过吗(…)，什么场景下？</h4><p>1.在数组调用时可以替代数组的apply方法</p>
<p>2.用于合并数组</p>
<p>3.与解构赋值相结合，生成新的数组</p>
<p>4.将字符串转成数组</p>
<p>5.任何iterator对象，都可以通过展开运算符转成数组</p>
<p>6.用于数组的浅拷贝</p>
<p>7.构造字面量对象可以使用展开语法</p>
<p>8.在 new 表达式中应用，使用 <code>new</code> 关键字来调用构造函数时，不能<strong>直接</strong>使用数组 + <code>apply</code> 的方式（<code>apply</code> 执行的是调用 <code>[[Call]]</code> , 而不是构造 <code>[[Construct]]</code>），可以使用展开语法替代</p>
<h4 id="63-说一说vue钩子函数？"><a href="#63-说一说vue钩子函数？" class="headerlink" title="63.说一说vue钩子函数？"></a>63.说一说vue钩子函数？</h4><p>组件从创建，挂载，更新，销毁的全过程就是vue的声明周期，包括beforeCreate,created,beforemount,mounted,beforeUpdate,updated,beforeumount,umouted,</p>
<p>beforeCreate钩子函数会在实例初始化之后，进行数据侦听和事件/侦听器的配置之前同步调用，</p>
<p>created钩子函数会在组件实例被创完成后被立即同步调用，此时$watch,computed,method,data等属性可以被调用，但是挂载阶段还没开始，所以$el属性还不可以使用，</p>
<p>beforeMount钩子函数被调用时，该钩子函数会在挂载前调用，render函数首次被调用，在服务器端渲染期间不会被调用</p>
<p>mounted钩子函数被调用时，在实例挂载完成后调用，这时候传给app.mount的元素已经被新创建的vm.$el替换，mounted不会保证所有子组件都被挂载完成。如果想执行在这个视图渲染完毕后执行代码，可以在mounted内部使用vm.$nextTick</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 仅在整个视图都被渲染之后才会运行的代码</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该钩子函数不会再服务端渲染时调用</p>
<p>beforeUpdate钩子函数是在数据发生变化之后DOM更新之前调用，适合在DOM更新之前访问它，例如移除手动添加的事件监听器。<strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。</strong></p>
<p>updated钩子函数会在数据更新之后虚拟DOM重新渲染完毕之后被调用，此时DOM已经更新完毕可以进行DOM操作，但是不建议下该狗子中进行状态的改变，通常使用watch或者computed来进行状态监听，updated不能保证子组件已经挂载完成，如果想要在组件完全渲染以后操作可以使用vm.$nextTick.该钩子函数不能用于服务端。</p>
<p>activited钩子函数</p>
<p>该钩子会被keep-alive缓存的组件激活时调用，该钩子在服务器管渲染期间不被调用</p>
<p>deactivated钩子函数会在被keep-alive缓存的组件失活时调用，在服务端不可用</p>
<p>beforeMount钩子函数会在组件卸载之前调用，在这个时候1可以解除对事件的监听，<strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<p>mounted钩子函数调用时，组件已经卸载完成，指令和监听器都卸载完成，<strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<p>父子组件的声明周期</p>
<p>挂载阶段</p>
<p>父beforeCreate-&gt;父created-&gt;父beforMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p>
<p>更新阶段</p>
<p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p>
<p>销毁阶段</p>
<p>父beforeDestory-&gt;子deforeDestory-&gt;子destoryed-&gt;父destoryed</p>
<h4 id="64-vue生命周期的源码实现"><a href="#64-vue生命周期的源码实现" class="headerlink" title="64.vue生命周期的源码实现"></a>64.vue生命周期的源码实现</h4><h4 id="65-nexttick源码"><a href="#65-nexttick源码" class="headerlink" title="65.nexttick源码"></a>65.nexttick源码</h4><h4 id="66-v8垃圾回收"><a href="#66-v8垃圾回收" class="headerlink" title="66.v8垃圾回收"></a>66.v8垃圾回收</h4><h4 id="68-计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？"><a href="#68-计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？" class="headerlink" title="68.计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？"></a>68.计算机网络模型有哪些？具体每一层干什么的，传输的数据是什么，有哪些协议？</h4><h4 id="69-进程与线程的区别？（暂定）"><a href="#69-进程与线程的区别？（暂定）" class="headerlink" title="69.进程与线程的区别？（暂定）"></a>69.进程与线程的区别？（暂定）</h4><ol>
<li>一个线程属于一个进程，而一个进程可以有多个线程，但至少有一个线程，线程依赖进程的存在</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存</li>
<li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li>
<li>进程的切换开销远大于线程的切换开销</li>
<li>进程间的通信IPC，线程间可以直接写进数据段(如全局变量)来进行通信–需要进程同步和互斥手段的辅助，以保证数据的一致性</li>
<li>进程编程调试简单可靠性高，但是创建销毁开销大，线程正好相反，开销小，切换速度快，但是编程调试相对复杂</li>
<li>进程间不会相互影响，一个线程挂掉会导致整个进程挂掉</li>
<li>进程适合多核，多机分布，线程适用于多核</li>
</ol>
<p>进程：我们可以认为，启动一个应用程序，就会默认启动一个进程(也可能是多个进程)</p>
<p>线程：每一个进程中，都会启动至少一个线程用来执行程序中的代码，这就主线程，所以说进程是线程的容器</p>
<p>操作系统类似于一个大工厂，工厂中有很多车间，这个车间就是进程，每个车间有可能有一盒以上的工人在工厂，这个工人就是线程</p>
<p>js是单线程的，js线程有自己的容器进程，浏览器或者node</p>
<h4 id="70-基本数据类型之间的转换"><a href="#70-基本数据类型之间的转换" class="headerlink" title="70.基本数据类型之间的转换"></a>70.基本数据类型之间的转换</h4><p>1.console.log(null==undefined)//true<br>2.非空字符串通过Boolean()转成true,空字符串转成false，对于Number类型，非0数字都会转成true,0,NaN会转成false,对象都会被转成true,undefined会被转成false，if条件判断会自动转成boolean进行判断，使用!!也可以进行隐式转换<br>3.数值类型的转换，可以通过Number(),parseInt(),parseFloat()三个函数显示的进行转换，Number()可以用于任何数据类型，parseInt和parseFloat主要用于字符串，Number()进行类型转换时，<br>boolean值false会转成0，true会转成1，null会转成0，undefined会返回NaN,对于字符串的转换，如果字符串中只包含数字则会转换成十进制的数字，如果字符串中包含浮点数，则会转成浮点数，如果包含十六进制的字符串则会转成十进制的数字，如果是空字符串则会转成0，如果字符串中包含其字符，则会转成NaN。对象会先调用valueOf按照上述方式进行转换，如果是NaN则会再调用toString再进行上述的转换。<br>使用parseInt进行类型转换时，他会从第一个非空格的字符进行转换，如果第一个字符不是加减，数字字符，则会转成NaN,空字符串也会转成NaN,如果第一个字符时加减，数字则会一直到非数字字符位置，parseInt会进行截断字符，如果是浮点数字符串，则会遇到.就会截断<br>parseFloat只能解析十进制，会忽略第二个.他会忽略字符转以0开头的值<br>4.转成字符串，+””就可以变成字符串，也可以调用toString来转换，除了null和undefined都可以toString，使用String()也可以转成字符转，有toString则会调用这个方法，null则会装成”null”,undefined=&gt;’undefined’</p>
<h4 id="71-webpack-的-plugin-和-loader-的区别和原理"><a href="#71-webpack-的-plugin-和-loader-的区别和原理" class="headerlink" title="71.webpack 的 plugin 和 loader 的区别和原理"></a>71.webpack 的 plugin 和 loader 的区别和原理</h4><h4 id="72-静态资源一般采取什么缓存策略？"><a href="#72-静态资源一般采取什么缓存策略？" class="headerlink" title="72.静态资源一般采取什么缓存策略？"></a>72.静态资源一般采取什么缓存策略？</h4><p>强缓存和协商缓存</p>
<h4 id="73-移动端300ms的延迟问题，问什么会有这个问题"><a href="#73-移动端300ms的延迟问题，问什么会有这个问题" class="headerlink" title="73.移动端300ms的延迟问题，问什么会有这个问题"></a>73.移动端300ms的延迟问题，问什么会有这个问题</h4><h4 id="74-vue模版编译都有哪些阶段"><a href="#74-vue模版编译都有哪些阶段" class="headerlink" title="74.vue模版编译都有哪些阶段"></a>74.vue模版编译都有哪些阶段</h4><h4 id="75-vue虚拟dom怎么生成的"><a href="#75-vue虚拟dom怎么生成的" class="headerlink" title="75.vue虚拟dom怎么生成的"></a>75.vue虚拟dom怎么生成的</h4><h4 id="76-Vue2-3区别"><a href="#76-Vue2-3区别" class="headerlink" title="76.Vue2 3区别"></a>76.Vue2 3区别</h4><h4 id="77-手写防抖节流"><a href="#77-手写防抖节流" class="headerlink" title="77.手写防抖节流"></a>77.手写防抖节流</h4><h4 id="78-手写dom树转js对象"><a href="#78-手写dom树转js对象" class="headerlink" title="78.手写dom树转js对象"></a>78.手写dom树转js对象</h4><h4 id="79-给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端"><a href="#79-给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端" class="headerlink" title="79.给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端"></a>79.给一张上下颠倒的照片前端如何将图片位置旋转矫正发送给后端</h4><h4 id="80-如果一个页面打开很慢，可能是哪些原因，怎么进行优化"><a href="#80-如果一个页面打开很慢，可能是哪些原因，怎么进行优化" class="headerlink" title="80.如果一个页面打开很慢，可能是哪些原因，怎么进行优化"></a>80.如果一个页面打开很慢，可能是哪些原因，怎么进行优化</h4><h4 id="81-TCP的三次握手，以及每次的作用"><a href="#81-TCP的三次握手，以及每次的作用" class="headerlink" title="81.TCP的三次握手，以及每次的作用"></a>81.TCP的三次握手，以及每次的作用</h4><h4 id="82-TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理"><a href="#82-TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理" class="headerlink" title="82.TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理"></a>82.TCP和UDP的区别，TCP的可靠性如何保证，粘包如何处理，流量控制，滑动窗口原理</h4><h4 id="83-Vue的响应式原理"><a href="#83-Vue的响应式原理" class="headerlink" title="83.Vue的响应式原理"></a>83.Vue的响应式原理</h4><h4 id="84-Vue中computed和data里的值的联系，computed的特点以及响应式变化"><a href="#84-Vue中computed和data里的值的联系，computed的特点以及响应式变化" class="headerlink" title="84.Vue中computed和data里的值的联系，computed的特点以及响应式变化"></a>84.Vue中computed和data里的值的联系，computed的特点以及响应式变化</h4><h4 id="85-Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy-和-defineProperty-的比较"><a href="#85-Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy-和-defineProperty-的比较" class="headerlink" title="85.Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy 和 defineProperty 的比较"></a>85.Vue3与Vue2相比有哪些变化，Vue2中怎么监听数组变化，proxy 和 defineProperty 的比较</h4><p>详情请看vue3和vue2区别</p>
<p>vue2中重写数组中的方法，主要分为这几步</p>
<ol>
<li>获取到Array原型链上的方法，因为拦截后还需要调用原生的方法进行操作</li>
<li>使用object.defineproperty拦截数组的操作</li>
<li>再把array的实例原型指向修改后的实例原型</li>
</ol>
<p>proxy和defineproperty的区别</p>
<p>defineproperty的作用主要不是用来监听对象属性的变化，defineproperty不可以监听数组的变化，必须重写数组的方法，会对对象进行修改，不能够监听对象属性的修改和删除，不可以监听数组手动修改length和通过数组下标修改值，proxy代理，可以代理对象，不需要修改元素组，而且有十三中捕获器，还可以配合reflect来使用</p>
<h4 id="86-webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等"><a href="#86-webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等" class="headerlink" title="86.webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等"></a>86.webpack的打包过程，loader和plugin的区别，怎么对打包体积进行优化等</h4><h4 id="87-window-onload和DOMContentLoaded的区别"><a href="#87-window-onload和DOMContentLoaded的区别" class="headerlink" title="87.window.onload和DOMContentLoaded的区别"></a>87.window.onload和DOMContentLoaded的区别</h4><h4 id="88-了解http2"><a href="#88-了解http2" class="headerlink" title="88.了解http2"></a>88.了解http2</h4><h4 id="89-网页布局的方式有哪些"><a href="#89-网页布局的方式有哪些" class="headerlink" title="89.网页布局的方式有哪些"></a>89.网页布局的方式有哪些</h4><h4 id="90-使用promise封装ajax"><a href="#90-使用promise封装ajax" class="headerlink" title="90.使用promise封装ajax"></a>90.使用promise封装ajax</h4><h4 id="91-写一个vue的自定义指令"><a href="#91-写一个vue的自定义指令" class="headerlink" title="91.写一个vue的自定义指令"></a>91.写一个vue的自定义指令</h4><h4 id="92-vuex的原理，数据存储在哪里"><a href="#92-vuex的原理，数据存储在哪里" class="headerlink" title="92.vuex的原理，数据存储在哪里"></a>92.vuex的原理，数据存储在哪里</h4><h4 id="93-说一下href和src的区别"><a href="#93-说一下href和src的区别" class="headerlink" title="93.说一下href和src的区别"></a>93.说一下href和src的区别</h4><h4 id="94-说一下你知道的webpack打包构建的优化"><a href="#94-说一下你知道的webpack打包构建的优化" class="headerlink" title="94.说一下你知道的webpack打包构建的优化"></a>94.说一下你知道的webpack打包构建的优化</h4><h4 id="95-说一下你了解的plugin和loader-以及如何去写一个plugin和loader"><a href="#95-说一下你了解的plugin和loader-以及如何去写一个plugin和loader" class="headerlink" title="95.说一下你了解的plugin和loader,以及如何去写一个plugin和loader"></a>95.说一下你了解的plugin和loader,以及如何去写一个plugin和loader</h4><h4 id="96-说一下transform的原理-先平移再旋转和先旋转再平移有什么区别"><a href="#96-说一下transform的原理-先平移再旋转和先旋转再平移有什么区别" class="headerlink" title="96.说一下transform的原理(先平移再旋转和先旋转再平移有什么区别)"></a>96.说一下transform的原理(先平移再旋转和先旋转再平移有什么区别)</h4><h4 id="97-函数和对象及其上下文存储在哪里"><a href="#97-函数和对象及其上下文存储在哪里" class="headerlink" title="97.函数和对象及其上下文存储在哪里"></a>97.函数和对象及其上下文存储在哪里</h4><h4 id="98-手写虚拟dom转换成真实的dom"><a href="#98-手写虚拟dom转换成真实的dom" class="headerlink" title="98.手写虚拟dom转换成真实的dom"></a>98.手写虚拟dom转换成真实的dom</h4><h4 id="99-为什么一个网站的资源会存储在多个域名中"><a href="#99-为什么一个网站的资源会存储在多个域名中" class="headerlink" title="99.为什么一个网站的资源会存储在多个域名中"></a>99.为什么一个网站的资源会存储在多个域名中</h4><h4 id="100-如何实现前端的权限控制"><a href="#100-如何实现前端的权限控制" class="headerlink" title="100.如何实现前端的权限控制"></a>100.如何实现前端的权限控制</h4><h4 id="101-说一下vue3相对于vue2的优化"><a href="#101-说一下vue3相对于vue2的优化" class="headerlink" title="101.说一下vue3相对于vue2的优化"></a>101.说一下vue3相对于vue2的优化</h4><h4 id="102-说一下vite相对于webpack的优化"><a href="#102-说一下vite相对于webpack的优化" class="headerlink" title="102.说一下vite相对于webpack的优化"></a>102.说一下vite相对于webpack的优化</h4><h4 id="103-实现vue中template生成虚拟dom"><a href="#103-实现vue中template生成虚拟dom" class="headerlink" title="103.实现vue中template生成虚拟dom"></a>103.实现vue中template生成虚拟dom</h4><h4 id="104-知道http499是什么"><a href="#104-知道http499是什么" class="headerlink" title="104.知道http499是什么"></a>104.知道http499是什么</h4><p>表示客户端主动关闭连接，即HTTP 499 Client Closed Request,HTTP 499 表示nginx使用非标准状态码。表明当nginx正在处理请求时，客户端关闭了连接</p>
<h4 id="105-说一说mata标签的作用"><a href="#105-说一说mata标签的作用" class="headerlink" title="105.说一说mata标签的作用"></a>105.说一说mata标签的作用</h4><p>meta元素用来定义元数据的，meta标签用于定义不能用其他元数据元素定义的元数据信息，header中定义元数据的标签有style,link,title等，不能用这些标签定义的数据，就写在meta中。</p>
<p>meta元素定义的元数据的类型包括以下几类</p>
<p>如果设置了charset meta元素就是一个字符集声明，告诉文档使用那种字符编码</p>
<p>如果设置了http-equiv属性，meta元素则是编译指令  主要是做兼容性处理，告诉IE浏览器去模仿那个浏览器的行为，IE模仿edge的行为，chrome使用1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>如果设置了name属性，meta元素提供的是文档级别的元数据，应用于整个页面</p>
<h4 id="106-说一下css的优先级，important的缺点"><a href="#106-说一下css的优先级，important的缺点" class="headerlink" title="106.说一下css的优先级，important的缺点"></a>106.说一下css的优先级，important的缺点</h4><p>css的优先级是按照css的权重来叠加的，</p>
<p>！important  10000</p>
<p>内联样式 1000</p>
<p>id选择器 100</p>
<p>类选择器，属性选择权，伪类  10</p>
<p>元素选择器，伪元素 1</p>
<p>通配符 0</p>
<p>通过各项叠加来计算css的优先级</p>
<p>important的优先级最高，在全局和组件中要谨慎使用，在对一些继承属性使用important，在修改这个属性的时候需要再次添加important，可能会造成混乱</p>
<h4 id="107-说一下响应式布局"><a href="#107-说一下响应式布局" class="headerlink" title="107.说一下响应式布局"></a>107.说一下响应式布局</h4><h4 id="108-写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"><a href="#108-写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名" class="headerlink" title="108.写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名"></a>108.写一个返回数据类型的函数，要求自定义的类实例化的对象返回定义的类名</h4><h4 id="109-说一下js的事件循环和node事件循环的区别"><a href="#109-说一下js的事件循环和node事件循环的区别" class="headerlink" title="109.说一下js的事件循环和node事件循环的区别"></a>109.说一下js的事件循环和node事件循环的区别</h4><p>js的事件循环是运行在浏览器环境中的，node事件循环是运行在node环境中的</p>
<p>浏览器的事件循环是一个我们编写的javascript代码和浏览器api调用(setTimeout/ajax/事件监听)的桥梁，桥梁之间他们用回调函数进行沟通</p>
<p>node事件循环是一个我们编写的javascript代码和系统调用(file syatem network)之间的桥梁，桥梁之间通过回调函数进行沟通</p>
<p>浏览器的事件循环：</p>
<p>​    首先会在函数执行调用栈中执行同步代码，如果执行到定时器会先将定时器挂起，继续向下执行执行到微任务代码，则先进入微任务队列，执行到宏任务，则进入宏任务队列，同步代码执行完成后，则会开始执行异步队列中的代码，先执行微任务队列，微任务队列之星完后在执行宏任务队列，等定时器执行完后，则进入宏任务队列执行，如此往复直到执行完成</p>
<p>宏任务队列：ajax，setTimeout ，setInterval，DOM监听，UIrendering等</p>
<p>微任务队列：Promise的then回调，Mutation observer api queueMicrotask() async/await等</p>
<p>node的事件循环是由libuv来实现的，libuv采用的就是非阻塞异步IO的调用方式</p>
<p>node事件循环分成很多个阶段</p>
<p>定时器(Timer):setTimeOut ，setIterval</p>
<p>待定回调（pending callback） 对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到 ECONNREFUSED</p>
<p>idle,prepare:进内部使用</p>
<p>轮询：检索新的I/O事件，执行与IO有关的回调</p>
<p>检测：setImmediate()回调函数在这里执行</p>
<p>关闭回调函数:一些关闭的回调函数，如socket.on(‘close’,)</p>
<p>node的事件的循环更加复杂，他也分为微任务和宏任务</p>
<p>宏任务：setTimeout,setInterval,IO事件，setImmediate,close事件</p>
<p>微任务：promise.then,async/awiat,process.nextTick,queueMicrotask</p>
<p>Node中的事件循环不只是 微任务队列和 宏任务队列：</p>
<p>​    微任务队列： </p>
<p>​        next tick queue：process.nextTick； </p>
<p>​        other queue：Promise的then回调、queueMicrotask；</p>
<p>​    宏任务队列： </p>
<p>​         timer queue：setTimeout、setInterval； </p>
<p>​        poll queue：IO事件；</p>
<p>​        check queue：setImmediate； ü close queue：close事件</p>
<p>执行宏任务的时候都必须先判断微任务队列是否有值</p>
<h4 id="110-实现一个柯里化函数（写代码）"><a href="#110-实现一个柯里化函数（写代码）" class="headerlink" title="110.实现一个柯里化函数（写代码）"></a>110.实现一个柯里化函数（写代码）</h4><h4 id="111-实现函数的链式调用（写代码，compose函数）"><a href="#111-实现函数的链式调用（写代码，compose函数）" class="headerlink" title="111.实现函数的链式调用（写代码，compose函数）"></a>111.实现函数的链式调用（写代码，compose函数）</h4><h4 id="112-如何配置less文件的loader"><a href="#112-如何配置less文件的loader" class="headerlink" title="112.如何配置less文件的loader"></a>112.如何配置less文件的loader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test:/\.less$/,</span><br><span class="line">use:[</span><br><span class="line">style-loader,css-loader,postcss-loader,less-loader</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h4 id="113-webpack是如何做到一步步处理loader文件的"><a href="#113-webpack是如何做到一步步处理loader文件的" class="headerlink" title="113.webpack是如何做到一步步处理loader文件的"></a>113.webpack是如何做到一步步处理loader文件的</h4><h4 id="114-为什么webpack是自上而下执行的"><a href="#114-为什么webpack是自上而下执行的" class="headerlink" title="114.为什么webpack是自上而下执行的"></a>114.为什么webpack是自上而下执行的</h4><h4 id="115-实现防抖和节流函数（写代码）"><a href="#115-实现防抖和节流函数（写代码）" class="headerlink" title="115.实现防抖和节流函数（写代码）"></a>115.实现防抖和节流函数（写代码）</h4><h4 id="116-如何用css实现两栏布局"><a href="#116-如何用css实现两栏布局" class="headerlink" title="116.如何用css实现两栏布局"></a>116.如何用css实现两栏布局</h4><h4 id="117-说一下css的position定位"><a href="#117-说一下css的position定位" class="headerlink" title="117.说一下css的position定位"></a>117.说一下css的position定位</h4><p>运用position进行定位，常取得5个值是：    static relative absolute fixed  sticky</p>
<p>position的默认值就是static</p>
<p>使用其他属性值可以让position变成定位元素</p>
<p>relative:会按照标准文档流进行布局，可以通过left right top bottom 来进行定位，参照对象是元素原来的位置</p>
<p>fixed：元素会脱离标准流，可以通过left，right，top，bottom进行定位，参照对象是视口。例如画布滚动时，元素不动</p>
<p>absolute：元素会脱离文档流，可以通过left，right，top，bottom进行定位，参照对象是最近定位（position不为static的元素）的祖先元素，否则就会相对于视口进行定位</p>
<h4 id="118-说一下js的作用域"><a href="#118-说一下js的作用域" class="headerlink" title="118.说一下js的作用域"></a>118.说一下js的作用域</h4><p>js的作用域有全局作用域，函数作用域，eval作用域，块级作用域</p>
<p>全局作用域就是最顶层的作用域，所有变量都可以访问到，函数作用域就是每个函数内部的作用域，eval作用域就是eval函数内部的作用域，es6新增了块级作用域，块级作用域是函数作用域的子集</p>
<h4 id="119-说一下js的import和node的require的区别"><a href="#119-说一下js的import和node的require的区别" class="headerlink" title="119.说一下js的import和node的require的区别"></a>119.说一下js的import和node的require的区别</h4><h4 id="120-说一下你了解的js的数组的常用方法"><a href="#120-说一下你了解的js的数组的常用方法" class="headerlink" title="120.说一下你了解的js的数组的常用方法"></a>120.说一下你了解的js的数组的常用方法</h4><p>数组常用的方法有</p>
<p>Array.prototype.join()</p>
<p>Array.prototype.concat()</p>
<p>Array.prototype.slice()</p>
<p>Array.prototype.splice()</p>
<p>Array.prototype.push()</p>
<p>Array.prototype.shift()</p>
<p>Array.prototype.unshift()</p>
<p>Array.isArray()</p>
<p>Array.prototype.pop()</p>
<p>Array.prototype.map()</p>
<p>Array.prototype.forEach()</p>
<p>Array.prototype.reduce()</p>
<p>Array.prototype.sort()</p>
<p>Array.prototype.some()</p>
<p>Array.prototype.every()</p>
<p>Array.prototype.entry()</p>
<p>Array.prototype.find()</p>
<p>Array.prototype.findIndex()</p>
<p>Array.prototype.flat()/flatMap()</p>
<p>Array.prototype.indexOf()</p>
<p>Array.prototype.includes()</p>
<p>Array.from()</p>
<p>Array.of()</p>
<p>Array.prototype.toString()</p>
<p>Array.prototype.values()</p>
<h4 id="121-说一下GET和POST的区别"><a href="#121-说一下GET和POST的区别" class="headerlink" title="121.说一下GET和POST的区别"></a>121.说一下GET和POST的区别</h4><ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求</li>
<li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置</li>
<li>GET请求参数会被完整保留在浏览器的历史记录里，而POST中的参数不会被保留</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有限制</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
<li>GET请求只能进行 url 编码，而POST支持多种编码方式</li>
<li>GET产生的URL地址可以被收藏，而POST不可以</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li>
</ul>
<h4 id="123-说一下px，rem，em的区别和联系"><a href="#123-说一下px，rem，em的区别和联系" class="headerlink" title="123.说一下px，rem，em的区别和联系"></a>123.说一下px，rem，em的区别和联系</h4><p>px是绝对长度单位，rem，em是相对长度单位，em是相对于元素本身的font-size来进行定位的，如果本身没有font-size则会继承自父元素的font-size，rem是根据根元素的font-size</p>
<h4 id="124-说一下instanceof的原理"><a href="#124-说一下instanceof的原理" class="headerlink" title="124.说一下instanceof的原理"></a>124.说一下instanceof的原理</h4><p>通过判断instance的[[prototype]]是否和原型链上的原型是否匹配</p>
<h4 id="125-说一下this的指向有几种方式"><a href="#125-说一下this的指向有几种方式" class="headerlink" title="125.说一下this的指向有几种方式"></a>125.说一下this的指向有几种方式</h4><p>1.默认绑定  this默认是指向全局，浏览器中this指向window,node中this指向global  在由于兼容性考虑可以使用globalThis  在函数声明中，this就是默认绑定</p>
<p>2.隐式绑定  在对象中this是指向调用的变量</p>
<p>3.显示绑定   可以使用call ,apply ,bind来指定this的指向</p>
<p>4.new绑定   使用new创建的对象，构造函数中的this会指向新创建的对象</p>
<h4 id="126-说一下v-model的原理"><a href="#126-说一下v-model的原理" class="headerlink" title="126.说一下v-model的原理"></a>126.说一下v-model的原理</h4><p>v-model就是如下的语糖</p>
<p>对于input，textarea元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  :value=&quot;text&quot;</span><br><span class="line">  @input=&quot;event =&gt; text = event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>对于文本元素text，textarea会绑定value property监听input事件，checkbox和radio会绑定checked property 监听change事件，select属性会绑定value属性，监听change事件</p>
<h4 id="127-如何封装一个弹窗组件，需要考虑那些问题"><a href="#127-如何封装一个弹窗组件，需要考虑那些问题" class="headerlink" title="127.如何封装一个弹窗组件，需要考虑那些问题"></a>127.如何封装一个弹窗组件，需要考虑那些问题</h4><h4 id="128-说一下keep-alive的原理，以及如果超出缓存长度，如何处理"><a href="#128-说一下keep-alive的原理，以及如果超出缓存长度，如何处理" class="headerlink" title="128.说一下keep-alive的原理，以及如果超出缓存长度，如何处理"></a>128.说一下keep-alive的原理，以及如果超出缓存长度，如何处理</h4><h4 id="129-说一下你对jwt认证机制的理解，它的优缺点"><a href="#129-说一下你对jwt认证机制的理解，它的优缺点" class="headerlink" title="129.说一下你对jwt认证机制的理解，它的优缺点"></a>129.说一下你对jwt认证机制的理解，它的优缺点</h4><h4 id="130-说一下new创建实例的时候都做了什么"><a href="#130-说一下new创建实例的时候都做了什么" class="headerlink" title="130.说一下new创建实例的时候都做了什么"></a>130.说一下new创建实例的时候都做了什么</h4><p>new创建实例的过程</p>
<ol>
<li>创建一个空对象</li>
<li>新创建的对象的[[prototype]]指向构造函数的prototype</li>
<li>构造函数的this指向新创建的对象</li>
<li>执行构造函数</li>
<li>如果构造函数没有返回值，则返回新创建的对象</li>
</ol>
<h4 id="131-说一下你对闭包的理解"><a href="#131-说一下你对闭包的理解" class="headerlink" title="131.说一下你对闭包的理解"></a>131.说一下你对闭包的理解</h4><h4 id="132-说一下你对flex布局的理解，以及其中属性的默认值-未完待续"><a href="#132-说一下你对flex布局的理解，以及其中属性的默认值-未完待续" class="headerlink" title="132.说一下你对flex布局的理解，以及其中属性的默认值(未完待续)"></a>132.说一下你对flex布局的理解，以及其中属性的默认值(未完待续)</h4><p>flex是用于按行或者按列布局元素的一维布局方法，元素可以通过膨胀以填充额外的空间以适应更小的空间。flex布局可以解决原来布局的一些痛点，例如垂直居中块元素，例如使容器的所有子项等分可用宽度，而不用管具体的宽高，在多列布局中所有列都采用相同的高度，即使他们包含的内容量不同。</p>
<p>开启了flex布局的元素叫flex item</p>
<p>flex container 里面的直接子元素叫做flex item</p>
<p>当flex conteainer中的子元素变成flex item时，具备以下特点：</p>
<p>​    flex item的布局将受flex container属性的设置来来控制和布局</p>
<p>​    flex item不再严格区分块级元素和行内级元素</p>
<p>​    flex item 默认情况下是包裹内容的，但是可以设置宽度和高度</p>
<p>display：flex或者inline-flex可以变成 flex-container</p>
<p>flex container的css属性有</p>
<p>​    flex-flow</p>
<p>​    flex-direction</p>
<p>​    flex-wrap</p>
<p>​    flex-flow</p>
<p>​    justify-content</p>
<p>​    align-items</p>
<p>​    align-content</p>
<p>应用在flex items上的c s s属性</p>
<p>​    flex-grow</p>
<p>​    flex-basis</p>
<p>​    flex-shrink</p>
<p>​    order</p>
<p>​    align-self</p>
<p>​    flex</p>
<h4 id="133-说一下ES6的块级作用域（待补充）"><a href="#133-说一下ES6的块级作用域（待补充）" class="headerlink" title="133.说一下ES6的块级作用域（待补充）"></a>133.说一下ES6的块级作用域（待补充）</h4><p>let const function class声明都会形成块级作用域，块级作用域可以让变量必须先声明再访问，否则会出现暂时性死区。块级作用域不会出现变量提升。例如在setTimeOut中的通过递归获取dom节点，可以使用该特性来代替立即执行函数</p>
<h4 id="134-说一下async和await的原理，generator用来做什么"><a href="#134-说一下async和await的原理，generator用来做什么" class="headerlink" title="134.说一下async和await的原理，generator用来做什么"></a>134.说一下async和await的原理，generator用来做什么</h4><p>async和await就是generator和promise.then的语法糖</p>
<h4 id="135-如何用ES5实现ES6的class的static和private"><a href="#135-如何用ES5实现ES6的class的static和private" class="headerlink" title="135.如何用ES5实现ES6的class的static和private"></a>135.如何用ES5实现ES6的class的static和private</h4><p>static:ES5中是直接在构造函数中添加</p>
<p>private:默认使用_来替代，并且定义get set方法</p>
<h4 id="136-用promise封装实现readfile和writefile的同步请求（写代码）"><a href="#136-用promise封装实现readfile和writefile的同步请求（写代码）" class="headerlink" title="136.用promise封装实现readfile和writefile的同步请求（写代码）"></a>136.用promise封装实现readfile和writefile的同步请求（写代码）</h4><h4 id="137-手写ES6的模板字符串（写代码"><a href="#137-手写ES6的模板字符串（写代码" class="headerlink" title="137.手写ES6的模板字符串（写代码"></a>137.手写ES6的模板字符串（写代码</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/04/interview01/" data-id="cl9770wq10079k2oo1rvy5nv2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/note/">note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/">Electron</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Electron/note/">note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Puppeteer/">Puppeteer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/git/note/">note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/interview/">interview</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/interview/daily/">daily</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/%E5%8E%9F%E7%90%86/">原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/%E6%90%9C%E9%9B%86/">搜集</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/node/note/">note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E5%89%8D%E7%AB%AF%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%AC%94%E8%AE%B0/">前端系统课笔记</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/react/Typescript/">Typescript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/mobx/">mobx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/note/">note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/typescript/">typescript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/typescript/note/">note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/vue/daily/">daily</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/note/">note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/">前端八股文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/Enzyme/">Enzyme</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/jest/">jest</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/">常用构建工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/glup/">glup</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/rollup/">rollup</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/vite/">vite</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/webpack/">webpack</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/note/">note</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Ajax/">Ajax</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/axios/">axios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/fetch/">fetch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/websocket/">websocket</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/08/Puppeteer/">什么是Puppeteer</a>
          </li>
        
          <li>
            <a href="/2022/10/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/10/12/canvas%E7%AC%94%E8%AE%B0/">canvas笔记</a>
          </li>
        
          <li>
            <a href="/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%89/">mobx的使用3⃣️</a>
          </li>
        
          <li>
            <a href="/2022/10/08/mobx%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BA%8C/">mobx的使用二</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>