

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="类型内置类型• 空值（null） • 未定义（undefined） • 布尔值（ boolean） • 数字（number） • 字符串（string） • 对象（object） • 符号（symbol，ES6 中新增） • bigInt 我们可以用 typeof 运算符来查看值的类型，它返回的是类型的字符串值。有意思的是，这几种类型和它们的字符串值并不一一对应： typeof undefined">
<meta property="og:type" content="article">
<meta property="og:title" content="你不知道的JavaScript（中卷）">
<meta property="og:url" content="http://example.com/2023/01/19/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="类型内置类型• 空值（null） • 未定义（undefined） • 布尔值（ boolean） • 数字（number） • 字符串（string） • 对象（object） • 符号（symbol，ES6 中新增） • bigInt 我们可以用 typeof 运算符来查看值的类型，它返回的是类型的字符串值。有意思的是，这几种类型和它们的字符串值并不一一对应： typeof undefined">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/yangzeng-cell/blog-images/master/%E6%88%AA%E5%B1%8F2023-01-27%2014.44.30.png">
<meta property="article:published_time" content="2023-01-19T23:33:29.000Z">
<meta property="article:modified_time" content="2023-04-01T17:14:05.676Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="你不知道的JavaScript">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/yangzeng-cell/blog-images/master/%E6%88%AA%E5%B1%8F2023-01-27%2014.44.30.png">
  
  
  
  <title>你不知道的JavaScript（中卷） - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Piggy的记录版</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="你不知道的JavaScript（中卷）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-19 23:33" pubdate>
          2023年1月19日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          50k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          420 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">你不知道的JavaScript（中卷）</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>• 空值（null）</p>
<p>• 未定义（undefined）</p>
<p>• 布尔值（ boolean）</p>
<p>• 数字（number）</p>
<p>• 字符串（string）</p>
<p>• 对象（object）</p>
<p>• 符号（symbol，ES6 中新增）</p>
<p>• bigInt</p>
<p>我们可以用 typeof 运算符来查看值的类型，它返回的是类型的字符串值。有意思的是，这几种类型和它们的字符串值并不一一对应：</p>
<div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">typeof</span> undefined === <span class="hljs-string">&quot;undefined&quot;</span>; <span class="hljs-comment">// true</span>

<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> === <span class="hljs-string">&quot;boolean&quot;</span>; <span class="hljs-comment">// true</span>

<span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span> === <span class="hljs-string">&quot;number&quot;</span>; <span class="hljs-comment">// true</span>

<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;42&quot;</span> === <span class="hljs-string">&quot;string&quot;</span>; <span class="hljs-comment">// true</span>

<span class="hljs-keyword">typeof</span> &#123; life: <span class="hljs-number">42</span> &#125; === <span class="hljs-string">&quot;object&quot;</span>; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// ES6中新加入的类型</span>

<span class="hljs-function"><span class="hljs-keyword">typeof</span> <span class="hljs-title">Symbol</span>()</span> === <span class="hljs-string">&quot;symbol&quot;</span>; <span class="hljs-comment">// true</span></code></pre></div>

<p>null的类型判断不同</p>
<div class="code-wrapper"><pre><code class="hljs abnf">typeof null <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;object&quot;</span><span class="hljs-comment">; // true</span></code></pre></div>

<p>我们需要使用复合条件来检测 null 值的类型：</p>
<div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;
(!a &amp;&amp; <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&quot;object&quot;</span>); <span class="hljs-comment">// true</span></code></pre></div>

<p>null 是基本类型中唯一的一个“假值”（falsy 或者 false-like）类型，typeof对它的返回值为 “object</p>
<p>还有一种情况：</p>
<div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">/* .. */</span> &#125; === <span class="hljs-string">&quot;function&quot;</span>; <span class="hljs-comment">// true</span></code></pre></div>

<p>这样看来，function（函数）也是 JavaScript 的一个内置类型。然而查阅规范就会知道，它实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属性 [[Call]]，该属性使其可以被调用。</p>
<p>函数不仅是对象，还可以拥有属性。例如：</p>
<p>function a(b,c) {</p>
<p> /* .. */</p>
<p>}</p>
<p>函数对象的 length 属性是其声明的参数的个数：a.length; // 2 因为该函数声明了两个命名参数，b 和 c，所以其 length 值为 2再来看看数组。JavaScript 支持数组，那么它是否也是一个特殊类型？typeof [1,2,3] === “object”; // true不，数组也是对象。确切地说，它也是 object 的一个“子类型”，数组的元素按数字顺序来进行索引（而非普通像对象那样通过字符串键值），其 length 属性是元素的个数。</p>
<h2 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h2><p>JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值</p>
<p>换个角度来理解就是，JavaScript 不做“类型强制”；也就是说，语言引擎不要求变量总是持有与其初始值同类型的值。一个变量可以现在被赋值为字符串类型值，随后又被赋值为数字类型值。</p>
<p>42 的类型为 number，并且无法更改。而 “42” 的类型为 string。数字 42 可以通过强制类型转换（coercion）为字符串 “42”</p>
<p>在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为 JavaScript 中的变量没有类型。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;number&quot;</span>
a = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;boolean</span></code></pre></div>

<p>typeof 运算符总是会返回一个字符串：</p>
<h3 id="undefined-和-undeclared"><a href="#undefined-和-undeclared" class="headerlink" title="undefined 和 undeclared"></a>undefined 和 undeclared</h3><p>变量在未持有值的时候为 undefined。此时 typeof 返回 “undefined”</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;
<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;undefined&quot;</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-number">42</span>;
<span class="hljs-keyword">var</span> c;
<span class="hljs-comment">// later</span>
b = c;
<span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &quot;undefined&quot;</span>
<span class="hljs-keyword">typeof</span> c; <span class="hljs-comment">// &quot;undefined&quot;</span></code></pre></div>

<p>js中undefined和undeclared是不相等的</p>
<p>已在作用域中声明但还没有赋值的变量，是 undefifined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</p>
<p>typeof不区分undefined 和 undeclared</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript 有 七 种 内 置 类 型：null、undefined、boolean、number、string、object 和symbol，可以使用 typeof 运算符来查看。</p>
<p>变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。</p>
<p>很多开发人员将 undefifined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。</p>
<p>undefined 是值的一种。undeclared 则表示变量还没有被声明过。</p>
<p>遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问 “undeclared” 变量时这样报错：ReferenceError: a is not defifined，并且 typeof 对 undefifined 和 undeclared 变量都返回”undefined”。</p>
<p>然而，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的办法。</p>
<h1 id="值"><a href="#值" class="headerlink" title="值"></a>值</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>和其他强类型语言不同，在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组就是通过这种方式来实现的）：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">1</span>, <span class="hljs-string">&quot;2&quot;</span>, [<span class="hljs-number">3</span>] ];
a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span>
a[<span class="hljs-number">0</span>] === <span class="hljs-number">1</span>; <span class="hljs-comment">// true</span>
a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] === <span class="hljs-number">3</span>; <span class="hljs-comment">// true</span></code></pre></div>

<p>对数组声明后即可向其中加入值，不需要预先设定大小</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ ];
a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 0</span>
a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;2&quot;</span>;
a[<span class="hljs-number">2</span>] = [ <span class="hljs-number">3</span> ];
a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span></code></pre></div>

<p>使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数组的 length 属性并不会发生变化</p>
<p>在创建“稀疏”数组（sparse array，即含有空白或空缺单元的数组）时要特别注意：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ ];
a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
<span class="hljs-comment">// 此处没有设置a[1]单元</span>
a[<span class="hljs-number">2</span>] = [ <span class="hljs-number">3</span> ];
a[<span class="hljs-number">1</span>]; <span class="hljs-comment">// undefined</span>
a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span></code></pre></div>

<p>上面的代码可以正常运行，但其中的“空白单元”（empty slot）可能会导致出人意料的结果。a[1] 的值为 undefined，但这与将其显式赋值为 undefined（a[1] = undefined）还是有所区别</p>
<p>数组通过数字进行索引，但有趣的是它们也是对象，所以也可以包含字符串键值和属性（但这些并不计算在数组长度内）：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [];
a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
a[<span class="hljs-string">&quot;foobar&quot;</span>] = <span class="hljs-number">2</span>;
a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 1</span>
a[<span class="hljs-string">&quot;foobar&quot;</span>]; <span class="hljs-comment">// 2</span>
a.<span class="hljs-property">foobar</span>; <span class="hljs-comment">// 2</span></code></pre></div>

<p>如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ ];
a[<span class="hljs-string">&quot;13&quot;</span>] = <span class="hljs-number">42</span>;
a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 14</span></code></pre></div>

<p>在数组中加入字符串键值 / 属性并不是一个好主意。建议使用对象来存放键值 / 属性值，用数组来存放数字索引值</p>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>有时需要将类数组（一组通过数字索引的值）转换为真正的数组，这一般通过数组工具函数（如 indexOf(..)、concat(..)、forEach(..) 等）来实现例如，一些 DOM 查询操作会返回 DOM 元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过 arguments 对象（类数组）将函数的参数当作列表来访问（从ES6 开始已废止）。</p>
<p>工具函数 slice(..) 经常被用于这类转换：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">var</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);
  arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;bam&quot;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);
&#125;
<span class="hljs-title function_">foo</span>(<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>); <span class="hljs-comment">// [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;]</span></code></pre></div>

<p>用 ES6 中的内置工具函数 Array.from(..) 也能实现同样的功能</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串经常被当成字符数组。字符串的内部实现究竟有没有使用数组并不好说，但JavaScript 中的字符串和字符数组并不是一回事，最多只是看上去相似而已。</p>
<div class="code-wrapper"><pre><code class="hljs awk">a[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;O&quot;</span>;
b[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;O&quot;</span>;
a; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;foo&quot;</span>
b; <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]</code></pre></div>

<p>JavaScript 中字符串是不可变的，而数组是可变的。并且 a[1] 在 JavaScript 中并非总是合法语法，在老版本的 IE 中就不被允许（现在可以了）。正确的方法应该是 a.charAt(1)。</p>
<p>字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</p>
<div class="code-wrapper"><pre><code class="hljs js">c = a.<span class="hljs-title function_">toUpperCase</span>();
a === c; <span class="hljs-comment">// false</span>
a; <span class="hljs-comment">// &quot;foo&quot;</span>
c; <span class="hljs-comment">// &quot;FOO&quot;</span>
b.<span class="hljs-title function_">push</span>( <span class="hljs-string">&quot;!&quot;</span> );
b; <span class="hljs-comment">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</span></code></pre></div>

<p>许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数组的非变更方法来处理字符串：</p>
<div class="code-wrapper"><pre><code class="hljs js">a.<span class="hljs-property">join</span>; <span class="hljs-comment">// undefined</span>
a.<span class="hljs-property">map</span>; <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">var</span> c = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">join</span>.<span class="hljs-title function_">call</span>( a, <span class="hljs-string">&quot;-&quot;</span> );
<span class="hljs-keyword">var</span> d = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">call</span>( a, <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)&#123;
 <span class="hljs-keyword">return</span> v.<span class="hljs-title function_">toUpperCase</span>() + <span class="hljs-string">&quot;.&quot;</span>;
&#125; ).<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot;&quot;</span> );
c; <span class="hljs-comment">// &quot;f-o-o&quot;</span>
d; <span class="hljs-comment">// &quot;F.O.O.&quot;</span></code></pre></div>

<p>另一个不同点在于字符串反转（JavaScript 面试常见问题）。数组有一个字符串没有的可变更成员函数 reverse()：</p>
<div class="code-wrapper"><pre><code class="hljs js">a.<span class="hljs-property">reverse</span>; <span class="hljs-comment">// undefined</span>
b.<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// [&quot;!&quot;,&quot;o&quot;,&quot;O&quot;,&quot;f&quot;]</span>
b; <span class="hljs-comment">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</span></code></pre></div>

<p>可惜我们无法“借用”数组的可变更成员函数，因为字符串是不可变的：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">reverse</span>.<span class="hljs-title function_">call</span>( a );
<span class="hljs-comment">// 返回值仍然是字符串&quot;foo&quot;的一个封装对象</span></code></pre></div>

<p>一个变通（破解）的办法是先将字符串转换为数组，待处理完后再将结果转换回字符串</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = a
  <span class="hljs-comment">// 将a的值转换为字符数组</span>
  .<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>)
  <span class="hljs-comment">// 将数组中的字符进行倒转</span>
  .<span class="hljs-title function_">reverse</span>()
  <span class="hljs-comment">// 将数组中的字符拼接回字符串</span>
  .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);
c; <span class="hljs-comment">// &quot;oof&quot;</span></code></pre></div>

<p>请注意！上述方法对于包含复杂字符（Unicode，如星号、多字节字符等）的字符串并不适用。这时则需要功能更加完备、能够处理 Unicode 的工具库。可以参考 Mathias Bynen 的 Esrever（<a target="_blank" rel="noopener" href="https://github.com/mathiasbynents/esrever%EF%BC%89">https://github.com/mathiasbynents/esrever）</a></p>
<p>如果需要经常以字符数组的方式来处理字符串的话，倒不如直接使用数组。这样就不用在字符串和数组之间来回折腾。可以在需要时使用 join(“”) 将字符数组转换为字符串。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>js只有数字类型，不区分整数还是小数</p>
<p>JavaScript 中的“整数”就是没有小数的十进制数。所以 42.0 即等同于“整数”42</p>
<p>与大部分现代编程语言（包括几乎所有的脚本语言）一样，JavaScript 中的数字类型是基于 IEEE 754 标准来实现的，该标准通常也被称为“浮点数”。JavaScript 使用的是“双精度”格式（即 64 位二进制）。</p>
<p>特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同</p>
<p>由于数字值可以使用 Number 对象进行封装（参见第 3 章），因此数字值可以调用 Numberprototype 中的方法（参见第 3 章）。例如，tofixed(..) 方法可指定小数部分的显示位数</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42.59</span>;
a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">0</span> ); <span class="hljs-comment">// &quot;43&quot;</span>
a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;42.6&quot;</span>
a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// &quot;42.59&quot;</span>
a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;42.590&quot;</span>
a.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">4</span> ); <span class="hljs-comment">// &quot;42.5900&quot;</span></code></pre></div>

<p>位数多于实际位会用0补齐</p>
<p>toPrecision(..) 方法用来指定有效数位的显示位数：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42.59</span>;
a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;4e+1&quot;</span>
a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// &quot;43&quot;</span>
a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;42.6&quot;</span>
a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">4</span> ); <span class="hljs-comment">// &quot;42.59&quot;</span>
a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">5</span> ); <span class="hljs-comment">// &quot;42.590&quot;</span>
a.<span class="hljs-title function_">toPrecision</span>( <span class="hljs-number">6</span> ); <span class="hljs-comment">// &quot;42.5900&quot;</span></code></pre></div>

<p>上面的方法不仅适用于数字变量，也适用于数字常量。不过对于 . 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 无效语法：</span>
<span class="hljs-number">42.</span><span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// SyntaxError</span>
<span class="hljs-comment">// 下面的语法都有效：</span>
(<span class="hljs-number">42</span>).<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;42.000&quot;</span>
<span class="hljs-number">0.42</span>.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;0.420&quot;</span>
<span class="hljs-number">42.</span>.<span class="hljs-title function_">toFixed</span>( <span class="hljs-number">3</span> ); <span class="hljs-comment">// &quot;42.000&quot;</span></code></pre></div>

<p>42.tofixed(3) 是无效语法，因为 . 被视为常量 42. 的一部分（如前所述），所以没有 . 属性访问运算符来调用 tofixed 方法。</p>
<p>42..tofixed(3) 则没有问题，因为第一个 . 被视为 number 的一部分，第二个 . 是属性访问运算符。只是这样看着奇怪，实际情况中也很少见。在基本类型值上直接调用的方法并不多见，不过这并不代表不好或不对。</p>
<p>下面的语法也是有效的（请注意其中的空格）：</p>
<p>42 .toFixed(3); // “42.000”</p>
<p>然而对数字常量而言，这样的语法很容易引起误会，不建议使用。</p>
<p>较大数的表示方式</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> onethousand = <span class="hljs-number">1</span>E3; // 即 <span class="hljs-number">1</span> * <span class="hljs-number">10</span>^<span class="hljs-number">3</span>

<span class="hljs-attribute">var</span> onemilliononehundredthousand = <span class="hljs-number">1</span>.<span class="hljs-number">1</span>E6; // 即 <span class="hljs-number">1</span>.<span class="hljs-number">1</span> * <span class="hljs-number">10</span>^<span class="hljs-number">6</span></code></pre></div>

<p>数字常量还可以使用二进制，八进制，十六进制来表示</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-number">0xf3</span>; <span class="hljs-comment">// 243的十六进制</span>
<span class="hljs-number">0Xf3</span>; <span class="hljs-comment">// 同上</span>
<span class="hljs-number">0363</span>; <span class="hljs-comment">// 243的八进制</span></code></pre></div>

<p>ES6开始，严格模式不支持0363这种八进制表示方式</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">ES6</span> 支持以下新格式：
<span class="hljs-number">0o363</span>; <span class="hljs-comment">// 243的八进制</span>
<span class="hljs-number">0O363</span>; <span class="hljs-comment">// 同上</span>
<span class="hljs-number">0b11110011</span>; <span class="hljs-comment">// 243的二进制</span>
<span class="hljs-number">0B11110011</span>; <span class="hljs-comment">// 同上</span></code></pre></div>

<p>要使用小写的o不要使用大写的O，容易混淆</p>
<h3 id="较小的数值"><a href="#较小的数值" class="headerlink" title="较小的数值"></a>较小的数值</h3><p>二进制浮点数最大的问题（不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此），是</p>
<p>会出现如下情况：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span> === <span class="hljs-number">0</span>.<span class="hljs-number">3</span>; // false</code></pre></div>

<p>简单来说，二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于0.3，而是一个比较接近的数字 0.30000000000000004，所以条件判断结果为 false。</p>
<p>那么应该怎样来判断 0.1 + 0.2 和 0.3 是否相等呢？</p>
<p>最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。</p>
<p>从 ES6 开始，该值定义在 Number.EPSILON 中，我们可以直接拿来用，也可以为 ES6 之前的版本写 polyfifill：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>) &#123;
 <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,-<span class="hljs-number">52</span>);
&#125;</code></pre></div>

<p>可以使用 Number.EPSILON 来比较两个数字是否相等（在指定的误差范围内）：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numbersCloseEnoughToEqual</span>(<span class="hljs-params">n1,n2</span>) &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>( n1 - n2 ) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;
&#125;
<span class="hljs-keyword">var</span> a = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">0.3</span>;
<span class="hljs-title function_">numbersCloseEnoughToEqual</span>( a, b ); <span class="hljs-comment">// true</span>
<span class="hljs-title function_">numbersCloseEnoughToEqual</span>( <span class="hljs-number">0.0000001</span>, <span class="hljs-number">0.0000002</span> ); <span class="hljs-comment">// false</span></code></pre></div>

<p>能够呈现的最大浮点数大约是 1.798e+308（这是一个相当大的数字），它定义在 Number.MAX_VALUE 中。最小浮点数定义在 Number.MIN_VALUE 中，大约是 5e-324，它不是负数，但无限接近于 0 ！</p>
<h3 id="整数的安全范围"><a href="#整数的安全范围" class="headerlink" title="整数的安全范围"></a>整数的安全范围</h3><p>能够被“安全”呈现的最大整数是 2^53 - 1，即 9007199254740991，在 ES6 中被定义为Number.MAX_SAFE_INTEGER。最小整数是 -9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。</p>
<p>可以使用bigInt来处理</p>
<h3 id="整数检测"><a href="#整数检测" class="headerlink" title="整数检测"></a>整数检测</h3><p>要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>( <span class="hljs-number">42</span> ); <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>( <span class="hljs-number">42.000</span> ); <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>( <span class="hljs-number">42.3</span> ); <span class="hljs-comment">// false</span></code></pre></div>

<p>也可以为 ES6 之前的版本 polyfifill Number.isInteger(..) 方法：</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Number</span>.isInteger) &#123;
  <span class="hljs-built_in">Number</span>.isInteger = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">typeof</span> num == <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; num % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>;
  &#125;;
&#125;</code></pre></div>

<p>要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>( <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span> ); <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>( <span class="hljs-number">2</span>, <span class="hljs-number">53</span> ) ); <span class="hljs-comment">// false</span>
<span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isSafeInteger</span>( <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>( <span class="hljs-number">2</span>, <span class="hljs-number">53</span> ) - <span class="hljs-number">1</span> ); <span class="hljs-comment">// true</span></code></pre></div>

<p>可以为 ES6 之前的版本 polyfifill Number.isSafeInteger(..) 方法：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-property">isSafeInteger</span>) &#123;
  <span class="hljs-title class_">Number</span>.<span class="hljs-property">isSafeInteger</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>.<span class="hljs-title function_">isInteger</span>(num) &amp;&amp; <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(num) &lt;= <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;
  &#125;;
&#125;</code></pre></div>

<h3 id="32-位有符号整数"><a href="#32-位有符号整数" class="headerlink" title="32 位有符号整数"></a>32 位有符号整数</h3><p>虽然整数最大能够达到 53 位，但是有些数字操作（如数位操作）只适用于 32 位数字，所以这些操作中数字的安全范围就要小很多，变成从 Math.pow(-2,31)（-2147483648， 约－21 亿）到 Math.pow(2,31) - 1（2147483647，约 21 亿）</p>
<p>a | 0 可以将变量 a 中的数值转换为 32 位有符号整数，因为数位运算符 | 只适用于 32 位整数（它只关心 32 位以内的值，其他的数位将被忽略）。因此与 0 进行操作即可截取 a 中 的 32 位数位。</p>
<h2 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h2><h3 id="不是值的值"><a href="#不是值的值" class="headerlink" title="不是值的值"></a>不是值的值</h3><p>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名称既是类型也是值</p>
<p>undefined 和 null 常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别。例如：</p>
<p>• null 指空值（empty value）</p>
<p>• undefined 指没有值（missing value）</p>
<p>或者：</p>
<p>• undefined 指从未赋值</p>
<p>• null 指曾赋过值，但是目前没有值</p>
<p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而undefined 却是一个标识符，可以被当作变量来使用和赋值。</p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>在非严格模式下，我们可以为全局标识符 undefined 赋值</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 非常糟糕的做法！</span>
&#125;
<span class="hljs-title function_">foo</span>();
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-string">&quot;use strict&quot;</span>;
  <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// TypeError!</span>
&#125;
<span class="hljs-title function_">foo</span>();</code></pre></div>

<p>在非严格和严格两种模式下，我们可以声明一个名为 undefined 的局部变量。再次强调最好不要这样做！</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-string">&quot;use strict&quot;</span>;
 <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span> = <span class="hljs-number">2</span>;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// 2</span>
&#125;
<span class="hljs-title function_">foo</span>();</code></pre></div>

<p><strong>void 运算符</strong></p>
<p>undefined 是一个内置标识符（除非被重新定义，见前面的介绍），它的值为 undefined，通过 void 运算符即可得到该值。</p>
<p>表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值：</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( <span class="hljs-keyword">void</span> a, a ); <span class="hljs-comment">// undefined 42</span></code></pre></div>

<p>按惯例我们用 void 0 来获得 undefined（这主要源自 C 语言，当然使用 void true 或其他void 表达式也是可以的）。void 0、void 1 和 undefined 之间并没有实质上的区别</p>
<h3 id="特殊的数字"><a href="#特殊的数字" class="headerlink" title="特殊的数字"></a>特殊的数字</h3><p>NaN</p>
<p>可以使用内建的全局工具函数 isNaN(..) 来判断一个值是否是 NaN</p>
<p>然而操作起来并非这么容易。isNaN(..) 有一个严重的缺陷，它的检查方式过于死板，就是“检查参数是否不是 NaN，也不是数字”。但是这样做的结果并不太准确：</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> / <span class="hljs-string">&quot;foo&quot;</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;foo&quot;</span>;
a; <span class="hljs-comment">// NaN</span>
b; <span class="hljs-string">&quot;foo&quot;</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-built_in">isNaN</span>( a ); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-built_in">isNaN</span>( b ); <span class="hljs-comment">// true——晕！</span></code></pre></div>

<p>很明显 “foo” 不是一个数字，但是它也不是 NaN</p>
<p>ES6 开始我们可以使用工具函数 Number.isNaN(..)。ES6 之前的浏览器的 polyfifill 如下：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span>) &#123;
 <span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;
 <span class="hljs-keyword">return</span> (
 <span class="hljs-keyword">typeof</span> n === <span class="hljs-string">&quot;number&quot;</span> &amp;&amp;
 <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">isNaN</span>( n )
 ); 
 &#125;;
&#125;
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> / <span class="hljs-string">&quot;foo&quot;</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;foo&quot;</span>;
<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>( a ); <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Number</span>.<span class="hljs-built_in">isNaN</span>( b ); <span class="hljs-comment">// false——好！</span></code></pre></div>

<p>实际上还有一个更简单的方法，即利用 NaN 不等于自身这个特点。NaN 是 JavaScript 中唯 一一个不等于自身的值。</p>
<p>用判断自己是否等于自己来判断是否是NaN</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span>) &#123;
 <span class="hljs-title class_">Number</span>.<span class="hljs-property">isNaN</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;
 <span class="hljs-keyword">return</span> n !== n;
 &#125;;
&#125;</code></pre></div>

<p>无穷数</p>
<div class="code-wrapper"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span><span class="hljs-comment">; // Infinity  Number.POSITIVE_INfiNITY</span>
var b <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> / <span class="hljs-number">0</span><span class="hljs-comment">; // -Infinity Number.NEGATIVE_INfiNITY</span></code></pre></div>

<p>在js和数学运算中，无穷/无穷是未定式</p>
<p>Infinity/Infinity 是一个未定义操作，结果为 NaN。</p>
<p>零值</p>
<p>在JS中存在+0和-0两种表示</p>
<p>-0 除了可以用作常量以外，也可以是某些数学运算的返回值。例如：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> a = <span class="hljs-number">0</span> / -<span class="hljs-number">3</span>; // -<span class="hljs-number">0</span>
<span class="hljs-attribute">var</span> b = <span class="hljs-number">0</span> * -<span class="hljs-number">3</span>; // -<span class="hljs-number">0</span></code></pre></div>

<p>加法和减法运算不会得到负零（negative zero）。</p>
<p>负零在开发调试控制台中通常显示为 -0，但在一些老版本的浏览器中仍然会显示为 0</p>
<p>根据规范，对负零进行字符串化会返回 “0”：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span> / -<span class="hljs-number">3</span>;
<span class="hljs-comment">// 至少在某些浏览器的控制台中显示是正确的</span>
a; <span class="hljs-comment">// -0</span>
<span class="hljs-comment">// 但是规范定义的返回结果是这样！</span>
a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;0&quot;</span>
a + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// &quot;0&quot;</span>
<span class="hljs-title class_">String</span>( a ); <span class="hljs-comment">// &quot;0&quot;</span>
<span class="hljs-comment">// JSON也如此，很奇怪</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a )</code></pre></div>

<p>有意思的是，如果反过来将其从字符串转换为数字，得到的结果是准确的：</p>
<div class="code-wrapper"><pre><code class="hljs js">+<span class="hljs-string">&quot;-0&quot;</span>; <span class="hljs-comment">// -0</span>
<span class="hljs-title class_">Number</span>( <span class="hljs-string">&quot;-0&quot;</span> ); <span class="hljs-comment">// -0</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>( <span class="hljs-string">&quot;-0&quot;</span> ); <span class="hljs-comment">// -0</span></code></pre></div>

<p>JSON.stringify(-0) 返回 “0”，而 JSON.parse(“-0”) 返回 -0</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">0</span> / -<span class="hljs-number">3</span>;
a == b; <span class="hljs-comment">// true</span>
-<span class="hljs-number">0</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
a === b; <span class="hljs-comment">// true</span>
-<span class="hljs-number">0</span> === <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
<span class="hljs-number">0</span> &gt; -<span class="hljs-number">0</span>; <span class="hljs-comment">// false </span>
a &gt; b; <span class="hljs-comment">// false</span></code></pre></div>

<p>要区分 -0 和 0，不能仅仅依赖开发调试窗口的显示结果，还需要做一些特殊处理：</p>
<div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> is<span class="hljs-constructor">NegZero(<span class="hljs-params">n</span>)</span> &#123;
 n = <span class="hljs-constructor">Number( <span class="hljs-params">n</span> )</span>;
 return (n<span class="hljs-operator"> === </span><span class="hljs-number">0</span>)<span class="hljs-operator"> &amp;&amp; </span>(<span class="hljs-number">1</span><span class="hljs-operator"> / </span>n<span class="hljs-operator"> === </span>-Infinity);
&#125;
is<span class="hljs-constructor">NegZero( -0 )</span>; <span class="hljs-comment">// true</span>
is<span class="hljs-constructor">NegZero( 0 <span class="hljs-operator">/</span> -3 )</span>; <span class="hljs-comment">// true</span>
is<span class="hljs-constructor">NegZero( 0 )</span>; <span class="hljs-comment">// false</span></code></pre></div>

<p><strong>我们为什么需要负零呢</strong></p>
<p>有些应用程序中的数据需要以级数形式来表示（比如动画帧的移动速度），数字的符号位（sign）用来代表其他信息（比如移动的方向）。此时如果一个值为 0 的变量失去了它的符号位，它的方向信息就会丢失。所以保留 0 值的符号位可以防止这类情况发生</p>
<h2 id="特殊等式"><a href="#特殊等式" class="headerlink" title="特殊等式"></a>特殊等式</h2><p>NaN和自身不相等，-0！==0</p>
<p>ES6 中新加入了一个工具方法 Object.is(..) 来判断两个值是否绝对相等，可以用来处理</p>
<p>上述所有的特殊情况：</p>
<div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> / <span class="hljs-string">&quot;foo&quot;</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">-3</span> * <span class="hljs-number">0</span>;
<span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>( a, NaN ); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>( b, <span class="hljs-number">-0</span> ); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>( b, <span class="hljs-number">0</span> ); <span class="hljs-comment">// false</span></code></pre></div>

<p>对于 ES6 之前的版本，Object.is(..) 有一个简单的 polyfifill：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span>) &#123;
 <span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">v1, v2</span>) &#123;
 <span class="hljs-comment">// 判断是否是-0</span>
 <span class="hljs-keyword">if</span> (v1 === <span class="hljs-number">0</span> &amp;&amp; v2 === <span class="hljs-number">0</span>) &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / v1 === <span class="hljs-number">1</span> / v2;
 &#125;
 <span class="hljs-comment">// 判断是否是NaN</span>
 <span class="hljs-keyword">if</span> (v1 !== v1) &#123;
 <span class="hljs-keyword">return</span> v2 !== v2;
 &#125;
 <span class="hljs-comment">// 其他情况</span>
 <span class="hljs-keyword">return</span> v1 === v2;
 &#125;;
&#125;</code></pre></div>

<p>能使用 == 和 ===时就尽量不要使用 Object.is(..)，因为前者效率更高、更为通用。Object.is(..) 主要用来处理那些特殊的相等比较</p>
<h2 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h2><p>在许多编程语言中，赋值和参数传递可以通过值复制（value-copy）或者引用复制（reference-copy）来完成，这取决于我们使用什么语法</p>
<p>例如，在 C++ 中如果要向函数传递一个数字并在函数中更改它的值，就可以这样来声明参数 int&amp; myNum，即如果传递的变量是 x，myNum 就是指向 x 的引用。引用就像一种特殊的指针，是来指向变量的指针（别名）。如果参数不声明为引用的话，参数值总是通过值复制的方式传递，即便对复杂的对象值也是如此。</p>
<p>JavaScript 中没有指针，引用的工作机制也不尽相同。在 JavaScript 中变量不可能成为指向另一个变量的引用。</p>
<p>JavaScript 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用 / 指向关系</p>
<p>JavaScript 对值和引用的赋值 / 传递在语法上没有区别，完全根据值的类型来决定</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-keyword">var</span> b = a; <span class="hljs-comment">// b是a的值的一个副本</span>
b++;
a; <span class="hljs-comment">// 2</span>
b; <span class="hljs-comment">// 3</span>
<span class="hljs-keyword">var</span> c = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> d = c; <span class="hljs-comment">// d是[1,2,3]的一个引用</span>
d.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> );
c; <span class="hljs-comment">// [1,2,3,4]</span>
d; <span class="hljs-comment">// [1,2,3,4]</span></code></pre></div>

<p>简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值 / 传递，包括null、undefined、字符串、数字、布尔和 ES6 中的 symbol</p>
<p>复合值（compound value）——对象（包括数组和封装对象）和函数，则总 是通过引用复制的方式来赋值 / 传递</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;
 x.<span class="hljs-title function_">push</span>( <span class="hljs-number">4</span> );
 x; <span class="hljs-comment">// [1,2,3,4]</span>
 <span class="hljs-comment">// 然后</span>
 x = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];
 x.<span class="hljs-title function_">push</span>( <span class="hljs-number">7</span> );
 x; <span class="hljs-comment">// [4,5,6,7]</span>
&#125;
<span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-title function_">foo</span>( a );
a; <span class="hljs-comment">// 是[1,2,3,4]，不是[4,5,6,7]</span></code></pre></div>

<p>函数的参数传递是值拷贝</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;
 x = x + <span class="hljs-number">1</span>;
 x; <span class="hljs-comment">// 3 </span>
&#125;
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>( a ); <span class="hljs-comment">// Object(a)也一样</span>
foo( b );
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( b ); <span class="hljs-comment">// 是2，不是3</span></code></pre></div>

<p>原因是标量基本类型值是不可更改的（字符串和布尔也是如此）。如果一个数字对象的标量基本类型值是 2，那么该值就不能更改，除非创建一个包含新值的数字对象</p>
<p>x = x + 1 中，x 中的标量基本类型值 2 从数字对象中拆封（或者提取）出来后，x 就神不知鬼不觉地从引用变成了数字对象，它的值为 2 + 1 等于 3。然而函数外的 b 仍然指向原来那个值为 2 的数字对象。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>JavaScript 中的数组是通过数字索引的一组任意类型的值。字符串和数组类似，但是它们的行为特征不同，在将字符作为数组来处理时需要特别小心。JavaScript 中的数字包括“整数”和“浮点型”。</p>
<p>基本类型中定义了几个特殊的值。</p>
<p>null 类型只有一个值 null，undefined 类型也只有一个值 undefined。所有变量在赋值之前默认值都是 undefined。void 运算符返回 undefined。</p>
<p>数 字 类 型 有 几 个 特 殊 值， 包 括 NaN（ 意 指“not a number”， 更 确 切 地 说 是“invalid number”）、+Infinity、-Infinity 和 -0。简单标量基本类型值（字符串和数字等）通过值复制来赋值 / 传递，而复合值（对象等）</p>
<p>通过引用复制来赋值 / 传递。JavaScript 中的引用和其他语言中的引用 / 指针不同，它们不能指向别的变量 / 引用，只能指向值。</p>
<h1 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h1><p>常用的原生函数有：</p>
<p>• String()</p>
<p>• Number()</p>
<p>• Boolean()</p>
<p>• Array()</p>
<p>• Object()</p>
<p>• Function()</p>
<p>• RegExp()</p>
<p>• Date()</p>
<p>• Error()</p>
<p>• Symbol()——ES6 中新加入的！</p>
<p>这些都是内建函数</p>
<p>原生函数可以被当作构造函数来使用，但其构造出来的对象可能会和我们设想的有所出入：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);
<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// 是&quot;object&quot;，不是&quot;String&quot;</span>
a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(a); <span class="hljs-comment">// &quot;[object String]&quot;</span></code></pre></div>

<p>通过构造函数（如 new String(“abc”)）创建出来的是封装了基本类型值（如 “abc”）的封装对象。</p>
<p>请注意：typeof 在这里返回的是对象类型的子类型。</p>
<h2 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性 [[Class]]"></a>内部属性 [[Class]]</h2><p>所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] );
<span class="hljs-comment">// &quot;[object Array]&quot;</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-regexp">/regex-literal/i</span> );
<span class="hljs-comment">// &quot;[object RegExp]&quot;</span></code></pre></div>

<p>上例中，数组的内部 [[Class]] 属性值是 “Array”，正则表达式的值是 “RegExp”。多数情况下，对象的内部 [[Class]] 属性和创建该对象的内建原生构造函数相对应（如下），但并非总是如此。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-literal">null</span> );
<span class="hljs-comment">// &quot;[object Null]&quot;</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-literal">undefined</span> );
<span class="hljs-comment">// &quot;[object Undefined]&quot;</span></code></pre></div>

<p>虽然 Null() 和 Undefined() 这样的原生构造函数并不存在，但是内部 [[Class]] 属性值仍然是 “Null” 和 “Undefined”。</p>
<p>其他基本类型值（如字符串、数字和布尔）的情况有所不同，通常称为“包装”（boxing</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-string">&quot;abc&quot;</span> );
<span class="hljs-comment">// &quot;[object String]&quot;</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-number">42</span> );
<span class="hljs-comment">// &quot;[object Number]&quot;</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-literal">true</span> );
<span class="hljs-comment">// &quot;[object Boolean]&quot;</span></code></pre></div>

<p>上例中基本类型值被各自的封装对象自动包装，所以它们的内部 [[Class]] 属性值分别为”String”、”Number” 和 “Boolean”。</p>
<h2 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h2><p>封 装 对 象（object wrapper） 扮 演 着 十 分 重 要 的 角 色。 由 于 基 本 类 型 值 没 有 .length和 .toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为基本类型值包装（box 或者 wrap）一个封装对象：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;abc&quot;</span>;
a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span>
a.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// &quot;ABC&quot;</span></code></pre></div>

<p>封装类型不要经常使用，这样可能会降低执行效率，应该由js引擎自己决定，应该用基本类型</p>
<h3 id="封装对象释疑"><a href="#封装对象释疑" class="headerlink" title="封装对象释疑"></a>封装对象释疑</h3><p>封装对象时要注意使用：</p>
<div class="code-wrapper"><pre><code class="hljs arcade">比如 <span class="hljs-built_in">Boolean</span>：
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>( <span class="hljs-literal">false</span> );
<span class="hljs-keyword">if</span> (!a) &#123;
 <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> ); <span class="hljs-comment">// 执行不到这里</span>
&#125;</code></pre></div>

<p>这里变成了封装对象，所以而对象属于truthly，所以永远会返回true</p>
<p>如果想要自行封装基本类型值，可以使用 Object(..) 函数（不带 new 关键字）：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;abc&quot;</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( a );
<span class="hljs-keyword">var</span> c = <span class="hljs-title class_">Object</span>( a );
<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;string&quot;</span>
<span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &quot;object&quot;</span>
<span class="hljs-keyword">typeof</span> c; <span class="hljs-comment">// &quot;object&quot;</span>
b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span>
c <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>; <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( b ); <span class="hljs-comment">// &quot;[object String]&quot;</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( c ); <span class="hljs-comment">// &quot;[object String]&quot;</span></code></pre></div>

<p>尽量不要使用封装类型</p>
<h2 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h2><p>如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( <span class="hljs-string">&quot;abc&quot;</span> );
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>( <span class="hljs-number">42</span> );
<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>( <span class="hljs-literal">true</span> );
a.<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// &quot;abc&quot;</span>
b.<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// 42</span>
c.<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// true</span></code></pre></div>

<p>在需要用到封装对象中的基本类型值的地方会发生隐式拆封。具体过程（即强制类型转换）</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>( <span class="hljs-string">&quot;abc&quot;</span> );
<span class="hljs-keyword">var</span> b = a + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// b的值为&quot;abc&quot;</span>
<span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// &quot;object&quot;</span>
<span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &quot;string</span></code></pre></div>

<h2 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h2><p>尽量避免使用原生函数作为构造函数</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array(..)"></a>Array(..)</h3><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> );
a; <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-keyword">var</span> b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
b; <span class="hljs-comment">// [1, 2, 3]</span></code></pre></div>

<p>构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的。</p>
<p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素</p>
<p>如若一个数组没有任何单元，但它的 length 属性中却显示有单元数量，这样奇特的数据结构会导致一些怪异的行为</p>
<p>我们将包含至少一个“空单元”的数组称为“稀疏数组”。</p>
<p>但是永远不要创建和使用空数组</p>
<h3 id="Object-、Function-和-RegExp"><a href="#Object-、Function-和-RegExp" class="headerlink" title="Object(..)、Function(..) 和 RegExp(..)"></a>Object(..)、Function(..) 和 RegExp(..)</h3><p>除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..)</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
c.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;
c; <span class="hljs-comment">// &#123; foo: &quot;bar&quot; &#125;</span>
<span class="hljs-keyword">var</span> d = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span> &#125;;
d; <span class="hljs-comment">// &#123; foo: &quot;bar&quot; &#125;</span>
<span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>( <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;return a * 2;&quot;</span> );
<span class="hljs-keyword">var</span> f = <span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-keyword">return</span> a * <span class="hljs-number">2</span>; &#125;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">a</span>) &#123; <span class="hljs-keyword">return</span> a * <span class="hljs-number">2</span>; &#125;
<span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>( <span class="hljs-string">&quot;^a*b+&quot;</span>, <span class="hljs-string">&quot;g&quot;</span> );
<span class="hljs-keyword">var</span> i = <span class="hljs-regexp">/^a*b+/g</span>;</code></pre></div>

<p>在实际情况中没有必要使用 new Object() 来创建对象，因为这样就无法像常量形式那样一次设定多个属性，而必须逐一设定</p>
<p>构造函数 Function 只在极少数情况下很有用，比如动态定义函数参数和函数体的时候。不要把 Function(..) 当作 eval(..) 的替代品，你基本上不会通过这种方式来定义函数。</p>
<p>强烈建议使用常量形式（如 /^a*b+/g）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript 引擎在代码执行前会对它们进行预编译和缓存。与前面的构造函数不同，RegExp(..) 有时还是很有用的，比如动态定义正则表达式时：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Kyle&quot;</span>;
<span class="hljs-keyword">var</span> namePattern = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>( <span class="hljs-string">&quot;\\b(?:&quot;</span> + name + <span class="hljs-string">&quot;)+\\b&quot;</span>, <span class="hljs-string">&quot;ig&quot;</span> );
<span class="hljs-keyword">var</span> matches = someText.<span class="hljs-title function_">match</span>( namePattern );</code></pre></div>

<p>上述情况在 JavaScript 编程中时有发生，这时 new RegExp(“pattern”,”flags”) 就能派上用场。</p>
<h3 id="Date-和-Error"><a href="#Date-和-Error" class="headerlink" title="Date(..) 和 Error(..)"></a>Date(..) 和 Error(..)</h3><p>相较于其他原生构造函数，Date(..) 和 Error(..) 的用处要大很多，因为没有对应的常量形式来作为它们的替代。</p>
<p>创建日期对象必须使用 new Date()。Date(..) 可以带参数，用来指定日期和时间，而不带参数的话则使用当前的日期和时间。</p>
<p>Date(..) 主要用来获得当前的 Unix 时间戳（从 1970 年 1 月 1 日开始计算，以秒为单位）。该值可以通过日期对象中的 getTime() 来获得。</p>
<p>从 ES5 开始引入了一个更简单的方法，即静态函数 Date.now()。对 ES5 之前的版本我们可以使用下面的 polyfifill：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span>) &#123;
 <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
 <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">getTime</span>();
 &#125;;
&#125;</code></pre></div>

<p>如果调用 Date() 时不带 new 关键字，则会得到当前日期的字符串值。其具体格式规范没有规定，浏览器使用 “Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)”这样的格式来显示。</p>
<p>构造函数 Error(..)（与前面的 Array() 类似）带不带 new 关键字都可。</p>
<p>创建错误对象（error object）主要是为了获得当前运行栈的上下文（大部分 JavaScript 引擎通过只读属性 .stack 来访问）。栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。</p>
<p>错误对象通常与 throw 一起使用：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;
 <span class="hljs-keyword">if</span> (!x) &#123;
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>( <span class="hljs-string">&quot;x wasn’t provided&quot;</span> );
 &#125;
 <span class="hljs-comment">// .. </span>
&#125;</code></pre></div>

<p>通常错误对象至少包含一个 message 属性，有时也不乏其他属性（必须作为只读属性访问），如 type。除了访问 stack 属性以外，最好的办法是调用（显式调用或者通过强制类型转换隐式调用）toString() 来获得经过格式化的便于阅读的错误信息。</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol(..)"></a>Symbol(..)</h3><p>ES6 中新加入了一个基本数据类型 ——符号（Symbol）。符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名。该类型的引入主要源于 ES6 的一些特殊构造，此外符号也可以自行定义。</p>
<p>符号可以用作属性名，但无论是在代码还是开发控制台中都无法查看和访问它的值，只会显示为诸如 Symbol(Symbol.create) 这样的值</p>
<p>ES6 中有一些预定义符号，以 Symbol 的静态属性形式出现，如 Symbol.create、Symbol.iterator 等，可以这样来使用：</p>
<div class="code-wrapper"><pre><code class="hljs js">obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">/*..*/</span> &#125;;</code></pre></div>

<p>我们可以使用 Symbol(..) 原生构造函数来自定义符号。但它比较特殊，不能带 new 关键字，否则会出错：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mysym = <span class="hljs-title class_">Symbol</span>( <span class="hljs-string">&quot;my own symbol&quot;</span> );
mysym; <span class="hljs-comment">// Symbol(my own symbol)</span>
mysym.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;Symbol(my own symbol)&quot;</span>
<span class="hljs-keyword">typeof</span> mysym; <span class="hljs-comment">// &quot;symbol&quot;</span>
<span class="hljs-keyword">var</span> a = &#123; &#125;;
a[mysym] = <span class="hljs-string">&quot;foobar&quot;</span>;
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>( a );
<span class="hljs-comment">// [ Symbol(my own symbol) ]</span></code></pre></div>

<p>虽然符号实际上并非私有属性（通过 Object.getOwnPropertySymbols(..) 便可以公开获得对象中的所有符号），但它却主要用于私有或特殊属性。很多开发人员喜欢用它来替代有下划线（_）前缀的属性，而下划线前缀通常用于命名私有或特殊属性。</p>
<p>符号并非对象，而是一种简单标量基本类型</p>
<h3 id="原生原型"><a href="#原生原型" class="headerlink" title="原生原型"></a>原生原型</h3><p>原生构造函数有自己的 .prototype 对象，如 Array.prototype、String.prototype 等。</p>
<p>• String.prototype.indexOf(..)</p>
<p>在字符串中找到指定子字符串的位置。</p>
<p>• String.prototype.charAt(..)</p>
<p>获得字符串指定位置上的字符。</p>
<p>• String.prototype.substr(..)、String.prototype.substring(..) 和 String.prototype.slice(..)</p>
<p>获得字符串的指定部分。 </p>
<p>• String.prototype.toUpperCase() 和 String.prototype.toLowerCase()</p>
<p>将字符串转换为大写或小写。</p>
<p>• String.prototype.trim()</p>
<p>去掉字符串前后的空格，返回新的字符串。</p>
<p>以上方法并不改变原字符串的值，而是返回一个新字符串,所有字符串都可以访问这些方法其他构造函数的原型包含它们各自类型所特有的行为特征，比如 Number.prototype.tofixed(..)（将数字转换为指定长度的整数字符串）和 Array.prototype.concat(..)（合并数组）。所有的函数都可以调用 Function.prototype 中的 apply(..)、call(..) 和 bind(..)</p>
<p>然而，有些原生原型（native prototype）并非普通对象那么简单：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// &quot;function&quot;</span>
<span class="hljs-title class_">Function</span>.<span class="hljs-title function_">prototype</span>(); <span class="hljs-comment">// 空函数！</span>
<span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;/(?:)/&quot;——空正则表达式</span>
<span class="hljs-string">&quot;abc&quot;</span>.<span class="hljs-title function_">match</span>( <span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <span class="hljs-comment">// [&quot;&quot;]</span></code></pre></div>

<p>更糟糕的是，我们甚至可以修改它们（而不仅仅是添加属性）：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>( <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> ); <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">push</span>( <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ); <span class="hljs-comment">// 3</span>
<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// [1,2,3]</span>
<span class="hljs-comment">// 需要将Array.prototype设置回空，否则会导致问题！</span>
<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;</code></pre></div>

<p>这里，Function.prototype 是一个函数，RegExp.prototype 是一个正则表达式，而 Array. prototype 是一个数组。是不是很有意思？</p>
<p><strong>将原型作为默认值</strong></p>
<p>Function.prototype 是一个空函数，RegExp.prototype 是一个“空”的正则表达式（无任何匹配），而 Array.prototype 是一个空数组。对未赋值的变量来说，它们是很好的默认值。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isThisCool</span>(<span class="hljs-params">vals,fn,rx</span>) &#123;
 vals = vals || <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
 fn = fn || <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
 rx = rx || <span class="hljs-title class_">RegExp</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
 <span class="hljs-keyword">return</span> rx.<span class="hljs-title function_">test</span>(
 vals.<span class="hljs-title function_">map</span>( fn ).<span class="hljs-title function_">join</span>( <span class="hljs-string">&quot;&quot;</span> )
 ); 
&#125;
<span class="hljs-title function_">isThisCool</span>(); <span class="hljs-comment">// true</span>
<span class="hljs-title function_">isThisCool</span>(
 [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],
 <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)&#123; <span class="hljs-keyword">return</span> v.<span class="hljs-title function_">toUpperCase</span>(); &#125;,
 <span class="hljs-regexp">/D/</span>
); <span class="hljs-comment">// false</span></code></pre></div>

<p>这种方法的一个好处是 .prototypes 已被创建并且仅创建一次。相反，如果将 []、function(){} 和 /(?:)/ 作为默认值，则每次调用 isThisCool(..) 时它们都会被创建一次（具体创建与否取决于 JavaScript 引擎，稍后它们可能会被垃圾回收），这样无疑会造成内存和 CPU 资源的浪费。</p>
<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><h2 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h2><p>将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。</p>
<p>类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）然而在 JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicit coercion）来区分。二者的区别显而易见：我们能够从代码中看出哪些地方是显式强制类型转换，而隐式强制类型转换则不那么明显，通常是某些操作产生的副作用。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
<span class="hljs-keyword">var</span> b = a + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 隐式强制类型转换</span>
<span class="hljs-keyword">var</span> c = <span class="hljs-title class_">String</span>( a ); <span class="hljs-comment">// 显式强制类型转换</span></code></pre></div>

<h2 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h2><h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h3><p>它负责处理非字符串到字符串的强制类型转换</p>
<p>基本类型值的字符串化规则为：null 转换为 “null”，undefined 转换为 “undefined”，true转换为 “true”。数字的字符串化则遵循通用规则那些极小和极大的数字使用指数形式：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1.07 连续乘以七个 1000</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1.07</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;
<span class="hljs-comment">// 七个1000一共21位数字</span>
a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1.07e21&quot;</span></code></pre></div>

<p>对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回内部属性 [[Class]] 的值，如 “[object Object]”。</p>
<p>将对象强制类型转换为 string 是通过 ToPrimitive 抽象操作来完成的</p>
<p>数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接起来</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1,2,3&quot;</span></code></pre></div>

<p>toString() 可以被显式调用，或者在需要字符串化时自动调用。</p>
<h4 id="JSON-字符串化"><a href="#JSON-字符串化" class="headerlink" title="JSON 字符串化"></a>JSON 字符串化</h4><p>工具函数 JSON.stringify(..) 在将 JSON 对象序列化为字符串时也用到了 ToString。但是json的序列化并不是严格的显示类型转换</p>
<p>对大多数简单值来说，JSON 字符串化和 toString() 的效果基本相同，只不过序列化的结果总是字符串：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-number">42</span> ); <span class="hljs-comment">// &quot;42&quot;</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-string">&quot;42&quot;</span> ); <span class="hljs-comment">// &quot;&quot;42&quot;&quot; （含有双引号的字符串）</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// &quot;null&quot;</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-literal">true</span> ); <span class="hljs-comment">// &quot;true&quot;</span></code></pre></div>

<p>所有安全的 JSON 值（JSON-safe）都可以使用 JSON.stringify(..) 字符串化。安全的JSON 值是指能够呈现为有效 JSON 格式的值。</p>
<p>为了简单起见，我们来看看什么是不安全的 JSON 值。undefined、function、symbol（ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合 JSON结构标准，支持 JSON 的语言无法处理它们。</p>
<p>JSON.stringify(..) 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// undefined</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; ); <span class="hljs-comment">// undefined</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(
 [<span class="hljs-number">1</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;,<span class="hljs-number">4</span>]
); <span class="hljs-comment">// &quot;[1,null,null,4]&quot;</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(
 &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">b</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; &#125;
); <span class="hljs-comment">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></code></pre></div>

<p>对包含循环引用的对象执行 JSON.stringify(..) 会出错。</p>
<p>如果对象中定义了 toJSON() 方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化。如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的 JSON 值。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;&#125;;
<span class="hljs-keyword">var</span> a = &#123;
  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">c</span>: o,
  <span class="hljs-attr">d</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,
&#125;;
<span class="hljs-comment">// 在a中创建一个循环引用</span>
o.<span class="hljs-property">e</span> = a;
<span class="hljs-comment">// 循环引用在这里会产生错误</span>
<span class="hljs-comment">// JSON.stringify( a );</span>
<span class="hljs-comment">// 自定义的JSON序列化</span>
a.<span class="hljs-property">toJSON</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
  <span class="hljs-comment">// 序列化仅包含b</span>
  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">b</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> &#125;;
&#125;;
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a); <span class="hljs-comment">// &quot;&#123;&quot;b&quot;:42&#125;&quot;</span></code></pre></div>

<p>toJSON() 应该“返回一个能够被字符串化的安全的 JSON 值”，而不是“返回一个 JSON 字符串”。</p>
<div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-attr">val</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],
 <span class="hljs-comment">// 可能是我们想要的结果！</span>
 <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
 <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span>.<span class="hljs-title function_">slice</span>( <span class="hljs-number">1</span> );
 &#125;
&#125;;
<span class="hljs-keyword">var</span> b = &#123;
 <span class="hljs-attr">val</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],
 <span class="hljs-comment">// 可能不是我们想要的结果！</span>
 <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;
 <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span> +
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span>.<span class="hljs-title function_">slice</span>( <span class="hljs-number">1</span> ).<span class="hljs-title function_">join</span>() +
 <span class="hljs-string">&quot;]&quot;</span>; 
 &#125;
&#125;;
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a ); <span class="hljs-comment">// &quot;[2,3]&quot;</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( b ); <span class="hljs-comment">// &quot;&quot;[2,3]&quot;&quot;</span></code></pre></div>

<p>我们可以向 JSON.stringify(..) 传递一个可选参数 replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON() 很像。</p>
<p>如果 replacer 是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。</p>
<p>如果 replacer 是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined，否则返回指定的值。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; 
 <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,
 <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;42&quot;</span>,
 <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 
&#125;;
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a, [<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>] ); <span class="hljs-comment">// &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot;</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a, <span class="hljs-keyword">function</span>(<span class="hljs-params">k,v</span>)&#123;
 <span class="hljs-keyword">if</span> (k !== <span class="hljs-string">&quot;c&quot;</span>) <span class="hljs-keyword">return</span> v;
&#125; );
<span class="hljs-comment">// &quot;&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;</span></code></pre></div>

<p>JSON.string 还有一个可选参数 space，用来指定输出的缩进格式。space 为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; 
 <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,
 <span class="hljs-attr">c</span>: <span class="hljs-string">&quot;42&quot;</span>,
 <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 
&#125;;
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span> );
<span class="hljs-comment">// &quot;&#123;</span>
<span class="hljs-comment">// &quot;b&quot;: 42,</span>
<span class="hljs-comment">// &quot;c&quot;: &quot;42&quot;,</span>
<span class="hljs-comment">// &quot;d&quot;: [</span>
<span class="hljs-comment">// 1, </span>
<span class="hljs-comment">// 2,</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">// &#125;</span>
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>( a, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;-----&quot;</span> );
<span class="hljs-comment">// &quot;&#123;</span>
<span class="hljs-comment">// -----&quot;b&quot;: 42,</span>
<span class="hljs-comment">// -----&quot;c&quot;: &quot;42&quot;,</span>
<span class="hljs-comment">// -----&quot;d&quot;: [</span>
<span class="hljs-comment">// ----------1,</span>
<span class="hljs-comment">// ----------2,</span>
<span class="hljs-comment">// ----------3</span>
<span class="hljs-comment">// -----]</span>
<span class="hljs-comment">// &#125;&quot;</span></code></pre></div>

<p>请记住，JSON.stringify(..) 并不是强制类型转换。在这里介绍是因为它涉及 ToString 强制类型转换，具体表现在以下两点。</p>
<p>(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。</p>
<p>(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。</p>
<h3 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h3><p>ToNumber 对以 0 开头的十六进制数并不按十六进制处理（而是按十进制</p>
<p>true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0</p>
<p>对象在调用toNumber的时候，首先会调用ToPrimitive，通过内部操作 DefaultValue，检查该值是否有 valueOf() 方法，如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString()的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。从 ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换</p>
<p>对象调用tonumber会先将其转成基本数据类型再进行操作</p>
<h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><h4 id="假值（falsy-value）"><a href="#假值（falsy-value）" class="headerlink" title="假值（falsy value）"></a>假值（falsy value）</h4><p>JavaScript 中的值可以分为以下两类：</p>
<p>(1) 可以被强制类型转换为 false 的值</p>
<p>(2) 其他（被强制类型转换为 true 的值）</p>
<p>以下这些是假值：</p>
<p>• undefined</p>
<p>• null</p>
<p>• false</p>
<p>• +0、-0 和 NaN</p>
<p>• “”</p>
<p>假值的布尔强制类型转换结果为 false</p>
<h4 id="真值（truthy-value）"><a href="#真值（truthy-value）" class="headerlink" title="真值（truthy value）"></a>真值（truthy value）</h4><p>除了假值之外的都是真值</p>
<h2 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h2><h3 id="字符串和数字之间的显式转换"><a href="#字符串和数字之间的显式转换" class="headerlink" title="字符串和数字之间的显式转换"></a>字符串和数字之间的显式转换</h3><p>字符串和数字之间的转换是通过 String(..) 和 Number(..) 这两个内建函数（原生构造函数）来实现的，请注意它们前面没有 new 关键字，并不创建封装对象。</p>
<p>在 JavaScript 开源社区中，一元运算 + 被普遍认为是显式强制类型转换</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = <span class="hljs-string">&quot;3.14&quot;</span>;
<span class="hljs-keyword">var</span> d = <span class="hljs-number">5</span>+ +c;
d; <span class="hljs-comment">// 8.14</span></code></pre></div>

<p>运算符的一元和二元形式的组合你也许能够想到很多种情况，下面是一个疯狂的例子：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1</span> + - + + + - + <span class="hljs-number">1</span>; <span class="hljs-comment">// 2</span></code></pre></div>

<p>尽量不要把一元运算符 +（还有 -）和其他运算符放在一起使用。上面的代码可以运行，但非常糟糕。此外 d = +c（还有 d =+ c）也容易和 d += c 搞混，两者天壤之别。</p>
<h5 id="日期显式转换为数字"><a href="#日期显式转换为数字" class="headerlink" title="日期显式转换为数字"></a>日期显式转换为数字</h5><p>一元运算符 + 的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为Unix 时间戳，以微秒为单位（从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间）：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>( <span class="hljs-string">&quot;Mon, 18 Aug 2014 08:53:06 CDT&quot;</span> );
+d; <span class="hljs-comment">// 1408369986000</span></code></pre></div>

<p>我们常用下面的方法来获得当前的时间戳，例如：</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">timestamp</span> = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</code></pre></div>

<p>JavaScript 有一处奇特的语法，即构造函数没有参数时可以不用带 ()。于是我们可能会碰到 var timestamp = +new Date; 这样的写法。这样能否提高代码可读性还存在争议，因为这仅用于 new fn()，对一般的函数调用 fn() 并不适用。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> timestamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();
<span class="hljs-comment">// var timestamp = (new Date()).getTime();</span>
<span class="hljs-comment">// var timestamp = (new Date).getTime();</span>
<span class="hljs-keyword">var</span> timestamp = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<span class="hljs-comment">//ES5 中新加入的静态方法 Date.now()</span>
<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span>) &#123;<span class="hljs-comment">//老版本浏览器提供 Date.now() 的 polyfill</span>
 <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">return</span> +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
 &#125;;
&#125;</code></pre></div>

<p>不建议对日期类型使用强制类型转换，应该使用 Date.now() 来获得当前的时间戳，使用 new Date(..).getTime() 来获得指定时间的时间戳</p>
<h4 id="奇特的-运算符"><a href="#奇特的-运算符" class="headerlink" title="奇特的 ~ 运算符"></a>奇特的 ~ 运算符</h4><p>字位运算符只适用于 32 位整数，运算符会强制操作数使用 32 位格式。这是通过抽象操作 ToInt32 来实现的</p>
<p>虽然严格说来并非强制类型转换（因为返回值类型并没有发生变化），但字位运算符（如 | 和 ~）和某些特殊数字一起使用时会产生类似强制类型转换的效果，返回另外一个数字</p>
<p>例如 | 运算符（字位操作“或”）的空操作（no-op）0 | x，它仅执行 ToInt32 转换</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-number">0</span> | -<span class="hljs-number">0</span>; <span class="hljs-comment">// 0</span>
<span class="hljs-number">0</span> | <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// 0</span>
<span class="hljs-number">0</span> | <span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">// 0</span>
<span class="hljs-number">0</span> | -<span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">// 0</span></code></pre></div>

<p>以上这些特殊数字无法以 32 位格式呈现（因为它们来自 64 位 IEEE 754 标准，参见第 2章），因此 ToInt32 返回 0。</p>
<p>关于 0 | ___ 是显式还是隐式仍存在争议。从规范的角度来说它无疑是显式的，但如果对字位运算符没有这样深入的理解，它可能就是隐式的。为了前后保持一致，我们这里将其视为显式。再回到 ~。它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”（对每一个字位进行反转）。</p>
<p>字位反转是个很晦涩的主题，JavaScript 开发人员一般很少需要关心到字位级别。</p>
<p>对 ~ 还可以有另外一种诠释，源自早期的计算机科学和离散数学：~ 返回 2 的补码。这样一来问题就清楚多了！</p>
<p>~x 大致等同于 -(x+1)。很奇怪，但相对更容易说明问题：</p>
<p>~42; // -(42+1) ==&gt; -43</p>
<p>也许你还是没有完全弄明白 ~ 到底是什么玩意？为什么把它放在强制类型转换一章中介绍？稍安勿躁。</p>
<p>在 -(x+1) 中唯一能够得到 0（或者严格说是 -0）的 x 值是 -1。也就是说如果 x 为 -1 时，~和一些数字值在一起会返回假值 0，其他情况则返回真值。</p>
<p>然而这与我们讨论的内容有什么关系呢？</p>
<p>-1 是一个“哨位值”，哨位值是那些在各个类型中（这里是数字）被赋予了特殊含义的值。在 C 语言中我们用 -1 来代表函数执行失败，用大于等于 0 的值来代表函数执行成功。</p>
<p>JavaScript 中字符串的 indexOf(..) 方法也遵循这一惯例，该方法在字符串中搜索指定的子字符串，如果找到就返回子字符串所在的位置（从 0 开始），否则返回 -1。</p>
<p>indexOf(..) 不仅能够得到子字符串的位置，还可以用来检查字符串中是否包含指定的子字符串，相当于一个条件判断。例如：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;Hello World&quot;</span>;
<span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;lo&quot;</span> ) &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// true</span>
 <span class="hljs-comment">// 找到匹配！</span>
&#125;
<span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;lo&quot;</span> ) != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// true</span>
 <span class="hljs-comment">// 找到匹配！</span>
&#125;
<span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> ) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// true</span>
 <span class="hljs-comment">// 没有找到匹配！</span>
&#125;
<span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> ) == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// true</span>
 <span class="hljs-comment">// 没有找到匹配！</span>
&#125;</code></pre></div>

<p>&gt;= 0 和 == -1 这样的写法不是很好，称为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，这里是指用 -1 作为失败时的返回值，这些细节应该被屏蔽掉。</p>
<p>现在我们终于明白 ~ 有什么用处了！ ~ 和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;Hello World&quot;</span>;
~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;lo&quot;</span> ); <span class="hljs-comment">// -4 &lt;-- 真值!</span>
<span class="hljs-keyword">if</span> (~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;lo&quot;</span> )) &#123; <span class="hljs-comment">// true</span>
 <span class="hljs-comment">// 找到匹配！</span>
&#125;
~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> ); <span class="hljs-comment">// 0 &lt;-- 假值!</span>
!~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> ); <span class="hljs-comment">// true</span>
<span class="hljs-keyword">if</span> (!~a.<span class="hljs-title function_">indexOf</span>( <span class="hljs-string">&quot;ol&quot;</span> )) &#123; <span class="hljs-comment">// true</span>
 <span class="hljs-comment">// 没有找到匹配！</span>
&#125;</code></pre></div>

<p>如果 indexOf(..) 返回 -1，~ 将其转换为假值 0，其他情况一律转换为真值。</p>
<p>由 -(x+1) 推断 <del>-1 的结果应该是 -0，然而实际上结果是 0，因为它是字位操作而非数学运算。从技术角度来说，if (</del>a.indexOf(..)) 仍然是对 indexOf(..) 的返回结果进行隐式强制类型转换，0 转换为 false，其他情况转换为 true。但我觉得 ~ 更像显式强制类型转换，前提是我对它有充分的理解。个人认为 ~ 比 &gt;= 0 和 == -1 更简洁。</p>
<h4 id="字位截除"><a href="#字位截除" class="headerlink" title="字位截除"></a>字位截除</h4><p>一些开发人员使用 ~~ 来截除数字值的小数部分，以为这和 Math.floor(..) 的效果一样，实际上并非如此</p>
<p>~~ 中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。~~ 和 !! 很相似。</p>
<p>对 ~~ 我们要多加注意。首先它只适用于 32 位数字，更重要的是它对负数的处理与 Math.floor(..) 不同。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>( -<span class="hljs-number">49.6</span> ); <span class="hljs-comment">// -50</span>
~~-<span class="hljs-number">49.6</span>; <span class="hljs-comment">// -49</span></code></pre></div>

<p>~~x 能将值截除为一个 32 位整数，x | 0 也可以，而且看起来还更简洁</p>
<p>出于对运算符优先级（详见第 5 章）的考虑，我们可能更倾向于使用 ~~x：</p>
<div class="code-wrapper"><pre><code class="hljs js">~~<span class="hljs-number">1E20</span> / <span class="hljs-number">10</span>; <span class="hljs-comment">// 166199296</span>
<span class="hljs-number">1E20</span> | <span class="hljs-number">0</span> / <span class="hljs-number">10</span>; <span class="hljs-comment">// 1661992960</span>
(<span class="hljs-number">1E20</span> | <span class="hljs-number">0</span>) / <span class="hljs-number">10</span>; <span class="hljs-comment">// 166199296</span></code></pre></div>

<h3 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h3><p>解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;42&quot;</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;42px&quot;</span>;
<span class="hljs-title class_">Number</span>( a ); <span class="hljs-comment">// 42</span>
<span class="hljs-built_in">parseInt</span>( a ); <span class="hljs-comment">// 42</span>
<span class="hljs-title class_">Number</span>( b ); <span class="hljs-comment">// NaN</span>
<span class="hljs-built_in">parseInt</span>( b ); <span class="hljs-comment">// 42</span></code></pre></div>

<p>解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回 NaN。</p>
<p>解析和转换之间不是相互替代的关系。它们虽然类似，但各有各的用途。如果字符串右边的非数字字符不影响结果，就可以使用解析。而转换要求字符串中所有的字符都是数字，像 “42px” 这样的字符串就不行。</p>
<p>解析字符串中的浮点数可以使用 parseFloat(..) 函数</p>
<p>不要忘了 parseInt(..) 针对的是字符串值。向 parseInt(..) 传递数字和其他类型的参数是没有用的，比如 true、function(){…} 和 [1,2,3]。非字符串参数会首先被强制类型转换为字符串，依赖这样的隐式强制类型转换并非上策，应该避免向 parseInt(..) 传递非字符串参数。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>( <span class="hljs-number">0.000008</span> ); <span class="hljs-comment">// 0 (&quot;0&quot; 来自于 &quot;0.000008&quot;)</span>
<span class="hljs-built_in">parseInt</span>( <span class="hljs-number">0.0000008</span> ); <span class="hljs-comment">// 8 (&quot;8&quot; 来自于 &quot;8e-7&quot;)</span>
<span class="hljs-built_in">parseInt</span>( <span class="hljs-literal">false</span>, <span class="hljs-number">16</span> ); <span class="hljs-comment">// 250 (&quot;fa&quot; 来自于 &quot;false&quot;)</span>
<span class="hljs-built_in">parseInt</span>( <span class="hljs-built_in">parseInt</span>, <span class="hljs-number">16</span> ); <span class="hljs-comment">// 15 (&quot;f&quot; 来自于 &quot;function..&quot;)</span>
<span class="hljs-built_in">parseInt</span>( <span class="hljs-string">&quot;0x10&quot;</span> ); <span class="hljs-comment">// 16</span>
<span class="hljs-built_in">parseInt</span>( <span class="hljs-string">&quot;103&quot;</span>, <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">parseInt</span>( <span class="hljs-number">1</span>/<span class="hljs-number">0</span>, <span class="hljs-number">19</span> ); <span class="hljs-comment">// 18 1/0回先转成字符串Infinity，i对应19进制的18，后面的不是数字，所以会被截取</span></code></pre></div>

<h3 id="显式转换为布尔值"><a href="#显式转换为布尔值" class="headerlink" title="显式转换为布尔值"></a>显式转换为布尔值</h3><p>显示的使用Boolean来将非boolean类型转成boolean类型比较少使用</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;0&quot;</span>;
<span class="hljs-keyword">var</span> b = [];
<span class="hljs-keyword">var</span> c = &#123;&#125;;
<span class="hljs-keyword">var</span> d = <span class="hljs-string">&quot;&quot;</span>;
<span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> f = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> g;
<span class="hljs-title class_">Boolean</span>( a ); <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Boolean</span>( b ); <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Boolean</span>( c ); <span class="hljs-comment">// true</span>
<span class="hljs-title class_">Boolean</span>( d ); <span class="hljs-comment">// false</span>
<span class="hljs-title class_">Boolean</span>( e ); <span class="hljs-comment">// false</span>
<span class="hljs-title class_">Boolean</span>( f ); <span class="hljs-comment">// false</span>
<span class="hljs-title class_">Boolean</span>( g ); <span class="hljs-comment">// false</span></code></pre></div>

<p>一元运算符 ! 显式地将值强制类型转换为布尔值。但是它同时还将真值反转为假值（或者将假值反转为真值）所以显式强制类型转换为布尔值最常用的方法是 !!，因为第二个 ! 会将结果反转回原值：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;0&quot;</span>;
<span class="hljs-keyword">var</span> b = [];
<span class="hljs-keyword">var</span> c = &#123;&#125;;
<span class="hljs-keyword">var</span> d = <span class="hljs-string">&quot;&quot;</span>;
<span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> f = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> g;
!!a; <span class="hljs-comment">// true</span>
!!b; <span class="hljs-comment">// true</span>
!!c; <span class="hljs-comment">// true</span>
!!d; <span class="hljs-comment">// false</span>
!!e; <span class="hljs-comment">// false</span>
!!f; <span class="hljs-comment">// false</span>
!!g; <span class="hljs-comment">// false</span></code></pre></div>

<p>if(..).. 这样的布尔值上下文中，如果没有使用 Boolean(..) 和 !!，就会自动隐式地进行 ToBoolean 转换。建议使用 Boolean(..) 和 !! 来进行显式转换以便让代码更清晰易读。</p>
<h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><p>隐式强制类型转换的作用是减少冗余，让代码更简洁</p>
<h3 id="字符串和数字之间的隐式强制类型转换"><a href="#字符串和数字之间的隐式强制类型转换" class="headerlink" title="字符串和数字之间的隐式强制类型转换"></a>字符串和数字之间的隐式强制类型转换</h3><p>a + “”（隐式）和前面的 String(a)（显式）之间有一个细微的差别需要注意。根据ToPrimitive 抽象操作规则，a + “” 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString()。它们最后返回的都是字符串，但如果 a 是对象而非数字结果可能会不一样</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;
 <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;,
 <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>; &#125;
&#125;;
a + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// &quot;42&quot;</span>
<span class="hljs-title class_">String</span>( a ); <span class="hljs-comment">// &quot;4&quot;</span></code></pre></div>

<p>再来看看从字符串强制类型转换为数字的情况。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;3.14&quot;</span>;
<span class="hljs-keyword">var</span> b = a - <span class="hljs-number">0</span>;
b; <span class="hljs-comment">// 3.14</span></code></pre></div>

<p>- 是数字减法运算符，因此 a - 0 会将 a 强制类型转换为数字。也可以使用 a * 1 和 a / 1，因为这两个运算符也只适用于数字，只不过这样的用法不太常见。</p>
<p>对象的 - 操作与 + 类似：</p>
<div class="code-wrapper"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> [<span class="hljs-number">3</span>]<span class="hljs-comment">;</span>
var b <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<span class="hljs-comment">;</span>
a - b<span class="hljs-comment">; // 2</span></code></pre></div>

<p>为了执行减法运算，a 和 b 都需要被转换为数字，它们首先被转换为字符串（通过toString()），然后再转换为数字。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onlyOne</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;
 <span class="hljs-comment">// 跳过假值，和处理0一样，但是避免了NaN</span>
 <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[i]) &#123;
 sum += <span class="hljs-variable language_">arguments</span>[i];<span class="hljs-comment">//这一步进行了隐式强制类型转换，将true转成1</span>
 &#125;
 &#125;
 <span class="hljs-keyword">return</span> sum == <span class="hljs-number">1</span>;
&#125;
<span class="hljs-keyword">var</span> a = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-literal">false</span>;
<span class="hljs-title function_">onlyOne</span>( b, a ); <span class="hljs-comment">// true</span>
<span class="hljs-title function_">onlyOne</span>( b, a, b, b, b ); <span class="hljs-comment">// true</span>
<span class="hljs-title function_">onlyOne</span>( b, b ); <span class="hljs-comment">// false</span>
<span class="hljs-title function_">onlyOne</span>( b, a, b, b, b, a ); <span class="hljs-comment">// false</span></code></pre></div>

<h3 id="隐式强制类型转换为布尔值"><a href="#隐式强制类型转换为布尔值" class="headerlink" title="隐式强制类型转换为布尔值"></a>隐式强制类型转换为布尔值</h3><p>(1) if (..) 语句中的条件判断表达式。</p>
<p>(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</p>
<p>(3) while (..) 和 do..while(..) 循环中的条件判断表达式。</p>
<p>(4) ? : 中的条件判断表达式。</p>
<p>(5) 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p>
<p>以上情况中，非布尔值会被隐式强制类型转换为布尔值，遵循前面介绍过的 ToBoolean 抽象操作规则。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;abc&quot;</span>;
<span class="hljs-keyword">var</span> c;
<span class="hljs-keyword">var</span> d = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">if</span> (a) &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;yep&quot;</span> ); <span class="hljs-comment">// yep</span>
&#125;
<span class="hljs-keyword">while</span> (c) &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;nope, never runs&quot;</span> );
&#125;
c = d ? a : b; 
c; <span class="hljs-comment">// &quot;abc&quot;</span>
<span class="hljs-keyword">if</span> ((a &amp;&amp; d) || c) &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;yep&quot;</span> ); <span class="hljs-comment">// yep</span>
&#125;</code></pre></div>

<h3 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h3><p>JavaScript 中它们返回的并不是布尔值</p>
<p>它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;abc&quot;</span>;
<span class="hljs-keyword">var</span> c = <span class="hljs-literal">null</span>;
a || b; <span class="hljs-comment">// 42 </span>
a &amp;&amp; b; <span class="hljs-comment">// &quot;abc&quot;</span>
c || b; <span class="hljs-comment">// &quot;abc&quot; </span>
c &amp;&amp; b; <span class="hljs-comment">// null</span></code></pre></div>

<p>在 C 和 PHP 中，上例的结果是 true 或 false，在 JavaScript（以及 Python 和 Ruby）中却是某个操作数的值。</p>
<p>|| 和 &amp;&amp; 首先会对第一个操作数（a 和 c）执行条件判断，如果其不是布尔值（如上例）就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p>
<p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数（a 和 c）的值，如果为false 就返回第二个操作数（b）的值。</p>
<p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数（b）的值，如果为 false 就返回第一个操作数（a 和 c）的值。</p>
<p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果（其中可能涉及强制类型转换）。c &amp;&amp; b 中 c 为 null，是一个假值，因此 &amp;&amp; 表达式的结果是 null（即 c 的值），而非条件判断的结果 false。</p>
<h3 id="符号的强制类型转换"><a href="#符号的强制类型转换" class="headerlink" title="符号的强制类型转换"></a>符号的强制类型转换</h3><p>Symbol只能进行显示的强制类型转换，而不能进行隐式的强制类型转换</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-title class_">Symbol</span>( <span class="hljs-string">&quot;cool&quot;</span> );
<span class="hljs-title class_">String</span>( s1 ); <span class="hljs-comment">// &quot;Symbol(cool)&quot;</span>
<span class="hljs-keyword">var</span> s2 = <span class="hljs-title class_">Symbol</span>( <span class="hljs-string">&quot;not cool&quot;</span> );
s2 + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// TypeError</span></code></pre></div>

<p>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true）。由于规则缺乏一致性，我们要对 ES6 中符号的强制类型转换多加小心。</p>
<h2 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h2><p>宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。</p>
<p>常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”。听起来蛮有道理，然而还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。</p>
<p>正确的解释是：“== 允许在相等比较中进行强制类型转换，而 === 不允许。”</p>
<h3 id="相等比较操作的性能"><a href="#相等比较操作的性能" class="headerlink" title="相等比较操作的性能"></a>相等比较操作的性能</h3><p>如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎实现上的细微差别之外，它们之间并没有什么不同。</p>
<p>如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 ==，没有就用 ===，不用在乎性能。</p>
<p>== 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。</p>
<p>在==进行强制类型转换时，</p>
<p>x==y</p>
<p>(1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。</p>
<p>(2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。</p>
<p>如果比较的双方有一个是boolean，可以先转成数组，再进行比较，如果两个类型还不一致，再进行转换</p>
<p>(1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果；</p>
<p>(2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;42&quot;</span>;
<span class="hljs-comment">// 不要这样用，条件判断不成立：</span>
<span class="hljs-keyword">if</span> (a == <span class="hljs-literal">true</span>) &#123;
 <span class="hljs-comment">// .. </span>
&#125;
<span class="hljs-comment">// 也不要这样用，条件判断不成立：</span>
<span class="hljs-keyword">if</span> (a === <span class="hljs-literal">true</span>) &#123;
 <span class="hljs-comment">// .. </span>
&#125;
<span class="hljs-comment">// 这样的显式用法没问题：</span>
<span class="hljs-keyword">if</span> (a) &#123;
 <span class="hljs-comment">// ..</span>
&#125;
<span class="hljs-comment">// 这样的显式用法更好：</span>
<span class="hljs-keyword">if</span> (!!a) &#123;
 <span class="hljs-comment">// .. </span>
&#125;
<span class="hljs-comment">// 这样的显式用法也很好：</span>
<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Boolean</span>( a )) &#123;
 <span class="hljs-comment">// .. </span>
&#125;</code></pre></div>

<p>null 和 undefined 之间的相等比较</p>
<p>null 和 undefined 之间的 == 也涉及隐式强制类型转换</p>
<p>(1) 如果 x 为 null，y 为 undefined，则结果为 true。</p>
<p>(2) 如果 x 为 undefined，y 为 null，则结果为 true。</p>
<p>在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">var</span> b;
a == b; <span class="hljs-comment">// true</span>
a == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>
b == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>
a == <span class="hljs-literal">false</span>; <span class="hljs-comment">// false</span>
b == <span class="hljs-literal">false</span>; <span class="hljs-comment">// false</span>
a == <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// false</span>
b == <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// false</span>
a == <span class="hljs-number">0</span>; <span class="hljs-comment">// false</span>
b == <span class="hljs-number">0</span>; <span class="hljs-comment">// false</span></code></pre></div>

<p>只能null==undefined才是true，其他情况下包括falde，“”，0，这些假值在==中和undefiend，null比较都是false</p>
<p>对象和非对象之间的相等比较</p>
<p>关于对象（对象 / 函数 / 数组）和标量基本类型（字符串 / 数字 / 布尔值）之间的相等比较，ES5 规范 11.9.3.8-9 做如下规定：</p>
<p>(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；</p>
<p>(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p>
<p>这里只提到了字符串和数字，没有布尔值。原因是我们之前介绍过 11.9.3.6-7中规定了布尔值会先被强制类型转换为数字。</p>
<h3 id="比较少见的情况"><a href="#比较少见的情况" class="headerlink" title="比较少见的情况"></a>比较少见的情况</h3><h4 id="返回其他数字"><a href="#返回其他数字" class="headerlink" title="返回其他数字"></a>返回其他数字</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
&#125;;
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>( <span class="hljs-number">2</span> ) == <span class="hljs-number">3</span>; <span class="hljs-comment">// true</span></code></pre></div>

<p>还有更奇怪的情况：</p>
<div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">if</span> <span class="hljs-params">(<span class="hljs-attr">a</span> == 2 &amp;&amp; <span class="hljs-attr">a</span> == 3)</span> &#123;

 <span class="hljs-string">//</span> <span class="hljs-string">..</span>

&#125;</code></pre></div>

<p>你也许觉得这不可能，因为 a 不会同时等于 2 和 3。但“同时”一词并不准确，因为 a == 2 在 a == 3 之前执行。</p>
<p>如果让 a.valueOf() 每次调用都产生副作用，比如第一次返回 2，第二次返回 3，就会出现这样的情况。这实现起来很简单：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> i = <span class="hljs-number">2</span>;
<span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">return</span> i++;
&#125;;
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>( <span class="hljs-number">42</span> );
<span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>) &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Yep, this happened.&quot;</span> );
&#125;</code></pre></div>

<h4 id="假值的相等比较"><a href="#假值的相等比较" class="headerlink" title="假值的相等比较"></a>假值的相等比较</h4><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span>
<span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>
<span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-literal">false</span>; <span class="hljs-comment">// true -- 晕！</span>
<span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span>
<span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
<span class="hljs-string">&quot;0&quot;</span> == <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// false</span>
<span class="hljs-literal">false</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span>
<span class="hljs-literal">false</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>
<span class="hljs-literal">false</span> == <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span>
<span class="hljs-literal">false</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true -- 晕！</span>
<span class="hljs-literal">false</span> == <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// true -- 晕！</span>
<span class="hljs-literal">false</span> == []; <span class="hljs-comment">// true -- 晕！</span>
<span class="hljs-literal">false</span> == &#123;&#125;; <span class="hljs-comment">// false</span>
<span class="hljs-string">&quot;&quot;</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span>
<span class="hljs-string">&quot;&quot;</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>
<span class="hljs-string">&quot;&quot;</span> == <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span>
<span class="hljs-string">&quot;&quot;</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true -- 晕！</span>
<span class="hljs-string">&quot;&quot;</span> == []; <span class="hljs-comment">// true -- 晕！</span>
<span class="hljs-string">&quot;&quot;</span> == &#123;&#125;; <span class="hljs-comment">// false</span>
<span class="hljs-number">0</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// false</span>
<span class="hljs-number">0</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// false</span>
<span class="hljs-number">0</span> == <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span>
<span class="hljs-number">0</span> == []; <span class="hljs-comment">// true -- 晕！</span>
<span class="hljs-number">0</span> == &#123;&#125;; <span class="hljs-comment">// false</span></code></pre></div>

<h4 id="极端情况"><a href="#极端情况" class="headerlink" title="极端情况"></a>极端情况</h4><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[]</span> == !<span class="hljs-selector-attr">[]</span> <span class="hljs-comment">// true</span></code></pre></div>

<p>根据 ToBoolean 规则，它会进行布尔值的显式强制类型转换（同时反转奇偶校验位）。所以 [] == ![] 变成了 [] == false。前面我们讲过 false == []，最后的结果就顺理成章了。</p>
<div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>== [<span class="hljs-number">2</span>]; // true
<span class="hljs-string">&quot;&quot;</span> == [null]; // true</code></pre></div>

<p>== 右边的值 [2] 和 [null] 会进行 ToPrimitive 强制类型转换，以便能够和左边的基本类型值（2 和 “”）进行比较。因为数组的 valueOf() 返回数组本身，所以强制类型转换过程中数组会进行字符串化。</p>
<p>第一行中的 [2] 会转换为 “2”，然后通过 ToNumber 转换为 2。第二行中的 [null] 会直接转换为 “”。所以最后的结果就是 2 == 2 和 “” == “”。</p>
<div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>== <span class="hljs-string">&quot;\n&quot;</span>; // true</code></pre></div>

<p>“”、”\n”（或者 “ “ 等其他空格组合）等空字符串被 ToNumber 强制类型转换为 0</p>
<h4 id="安全运用隐式强制类型转换"><a href="#安全运用隐式强制类型转换" class="headerlink" title="安全运用隐式强制类型转换"></a>安全运用隐式强制类型转换</h4><p>我们要对 == 两边的值认真推敲，以下两个原则可以让我们有效地避免出错。</p>
<p>• 如果两边的值中有 true 或者 false，千万不要使用 ==。</p>
<p>• 如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。</p>
<p>这时最好用 === 来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。</p>
<p>有一种情况下强制类型转换是绝对安全的，那就是 typeof 操作。typeof 总是返回七个字符串之一（参见第 1 章），其中没有空字符串。所以在类型检查过程中不会发生隐式强制类型转换。typeof x == “function” 是 100% 安全的，和 typeof x === “function” 一样。事实上两者在规范中是一回事。所以既不要盲目听命于代码工具每一处都用 ===，更不要对这个问题置若罔闻。我们要对自己的代码负责。</p>
<p>Alex Dorey（GitHub 用户名 @dorey）在 GitHub 上制作了一张图表，列出了各种相等比较的情况</p>
<p><a target="_blank" rel="noopener" href="https://dorey.github.io/JavaScript-Equality-Table/unified/">https://dorey.github.io/JavaScript-Equality-Table/unified/</a></p>
<p><img src="https://raw.githubusercontent.com/yangzeng-cell/blog-images/master/%E6%88%AA%E5%B1%8F2023-01-27%2014.44.30.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="抽象关系比较"><a href="#抽象关系比较" class="headerlink" title="抽象关系比较"></a>抽象关系比较</h2><p>a &lt; b 中涉及的隐式强制类型转换</p>
<p>比较双方首先调用 ToPrimitive，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">42</span> ];
<span class="hljs-keyword">var</span> b = [ <span class="hljs-string">&quot;43&quot;</span> ];
a &lt; b; <span class="hljs-comment">// true</span>
b &lt; a; <span class="hljs-comment">// false</span></code></pre></div>

<p>如果比较双方都是字符串，则按字母顺序来进行比较：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-string">&quot;42&quot;</span> ];
<span class="hljs-keyword">var</span> b = [ <span class="hljs-string">&quot;043&quot;</span> ];
a &lt; b; <span class="hljs-comment">// false</span></code></pre></div>

<p>a 和 b 并没有被转换为数字，因为 ToPrimitive 返回的是字符串，所以这里比较的是 “42” 和 “043” 两个字符串，它们分别以 “4” 和 “0” 开头。因为 “0” 在字母顺序上小于 “4”，所以最后结果为 false。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">4</span>, <span class="hljs-number">2</span> ];
<span class="hljs-keyword">var</span> b = [ <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span> ];
a &lt; b; <span class="hljs-comment">// false</span></code></pre></div>

<p>a 转换为 “4, 2”，b 转换为 “0, 4, 3”，同样是按字母顺序进行比较。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">42</span> &#125;;
<span class="hljs-keyword">var</span> b = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">43</span> &#125;;
a &lt; b; <span class="hljs-comment">// ??</span></code></pre></div>

<p>结果还是 false，因为 a 是 [object Object]，b 也是 [object Object]，所以按照字母顺序a &lt; b 并不成立。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">42</span> &#125;;
<span class="hljs-keyword">var</span> b = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">43</span> &#125;;
a &lt; b; <span class="hljs-comment">// false</span>
a == b; <span class="hljs-comment">// false</span>
a &gt; b; <span class="hljs-comment">// false</span>
a &lt;= b; <span class="hljs-comment">// true</span>
a &gt;= b; <span class="hljs-comment">// true</span></code></pre></div>

<p>是如果 a &lt; b 和 a == b 结果为 false，为什么 a &lt;= b 和 a &gt;= b 的结果会是 true 呢？</p>
<p>因为根据规范 a &lt;= b 被处理为 b &lt; a，然后将结果反转。因为 b &lt; a 的结果是 false，所以 a &lt;= b 的结果是 true。这可能与我们设想的大相径庭,即 &lt;= 应该是“小于或者等于”。实际上 JavaScript 中 &lt;= 是“不大于”的意思（即 !(a &gt; b)，处理为 !(b &lt; a)）。同理 a &gt;= b 处理为 b &lt;= a。</p>
<p>与 == 和 === 的完整性检查一样，我们应该在必要和安全的情况下使用强制类型转换，如：42 &lt; “43”。换句话说就是为了保证安全，应该对关系比较中的值进行显式强制类型转换：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [ <span class="hljs-number">42</span> ];
<span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;043&quot;</span>;
a &lt; b; <span class="hljs-comment">// false -- 字符串比较！</span>
<span class="hljs-title class_">Number</span>( a ) &lt; <span class="hljs-title class_">Number</span>( b ); <span class="hljs-comment">// true -- 数字比较！</span></code></pre></div>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h2><p>很多人不知道，语句都有一个结果值（statement completion value，undefined 也算）</p>
<p>获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示所执行的最后一条语句的结果值。</p>
<p>ES5 规 范 12.2 节中的变量声明（VariableDeclaration）算法实际上有一个返回值（是一个包含所声明变量名称的字符串，很奇特吧？），但是这个值被变量语句（VariableStatement）算法屏蔽掉了（for..in 循环除外），最后返回结果为空（undefined）。</p>
<p>比如代码块 { .. } 的结果值是其最后一个语句 / 表达式的结果。</p>
<div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">var</span> b;
<span class="hljs-attribute">if</span> (<span class="hljs-literal">true</span>) &#123;
 <span class="hljs-attribute">b</span> = <span class="hljs-number">4</span> + <span class="hljs-number">38</span>;
&#125;</code></pre></div>

<p>在控制台 /REPL 中输入以上代码应该会显示 42，即最后一个语句 / 表达式 b = 4 + 38 的结果值。换句话说，代码块的结果值就如同一个隐式的返回，即返回最后一个语句的结果值。</p>
<p>但下面这样的代码无法运行：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b;
a = <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;
 b = <span class="hljs-number">4</span> + <span class="hljs-number">38</span>;
&#125;;</code></pre></div>

<p>因为语法不允许我们获得语句的结果值并将其赋值给另一个变量（至少目前不行）</p>
<p>可以使用万恶的 eval(..)（又读作“evil”）来获得结果值：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b;
a = <span class="hljs-built_in">eval</span>( <span class="hljs-string">&quot;if (true) &#123; b = 4 + 38; &#125;&quot;</span> );
a; <span class="hljs-comment">// 42</span></code></pre></div>

<p>ES7 规范有一项“do 表达式”（do expression）提案，类似下面这样：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b;
a = <span class="hljs-keyword">do</span> &#123;
 <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;
 b = <span class="hljs-number">4</span> + <span class="hljs-number">38</span>; 
 &#125;
&#125;;
a; <span class="hljs-comment">// 42</span></code></pre></div>

<p>上例中，do { .. } 表达式执行一个代码块（包含一个或多个语句），并且返回其中最后一个语句的结果值，然后赋值给变量 a</p>
<h3 id="表达式的副作用"><a href="#表达式的副作用" class="headerlink" title="表达式的副作用"></a>表达式的副作用</h3><p>最常见的有副作用（也可能没有）的表达式是函数调用：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
 a = a + <span class="hljs-number">1</span>;
&#125;
<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 结果值：undefined。副作用：a的值被改变</span></code></pre></div>

<p>其他一些表达式也有副作用，比如：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
a++; <span class="hljs-comment">// 42</span>
a; <span class="hljs-comment">// 43</span>
++a; <span class="hljs-comment">// 44</span>
a; <span class="hljs-comment">// 44</span></code></pre></div>

<p>除了赋值之外，还会自增。自增就是副作用</p>
<p>++a,它的副作用（将 a 递增）产生在表达式返回结果值之前，而 a++ 的副作用则产生在之后。</p>
<p>++a++ 会产生 ReferenceError 错误，因为运算符需要将产生的副作用赋值给一个变量。以 ++a++ 为例，它首先执行 a++（根据运算符优先级，如下），返回 42，然后执行 ++42，这时会产生 ReferenceError 错误，因为 ++ 无法直接在 42 这样的值上产生副作用。</p>
<p>常有人误以为可以用括号 ( ) 将 a++ 的副作用封装起来，例如：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
<span class="hljs-keyword">var</span> b = (a++);
a; <span class="hljs-comment">// 43</span>
b; <span class="hljs-comment">// 42</span></code></pre></div>

<p>事实并非如此。( ) 本身并不是一个封装表达式，不会在表达式 a++ 产生副作用之后执行。即便可以，a++ 会首先返回 42，除非有表达式在 ++ 之后再次对 a 进行运算，否则还是不会得到 43，也就不能将 43 赋值给 b。</p>
<p>但也不是没有办法，可以使用 , 语句系列逗号运算符（statement-series comma operator）将多个独立的表达式语句串联成一个语句：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>, b;
b = ( a++, a );
a; <span class="hljs-comment">// 43</span>
b; <span class="hljs-comment">// 43</span></code></pre></div>

<p>再如 delete 运算符。delete 用来删除对象中的属性和数组中的单元。它通</p>
<p>常以单独一个语句的形式出现：</p>
<div class="code-wrapper"><pre><code class="hljs awk">var obj = &#123;

 a: <span class="hljs-number">42</span>

&#125;;

obj.a; <span class="hljs-regexp">//</span> <span class="hljs-number">42</span>

<span class="hljs-keyword">delete</span> obj.a; <span class="hljs-regexp">//</span> true

obj.a; <span class="hljs-regexp">//</span> undefined</code></pre></div>

<p>如果操作成功，delete 返回 true，否则返回 false。其副作用是属性被从对象中删除（或者单元从 array 中删除）</p>
<p>另一个有趣的例子是 = 赋值运算符。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;
a = <span class="hljs-number">42</span>; <span class="hljs-comment">// 42</span>
a; <span class="hljs-comment">// 42</span></code></pre></div>

<p>a = 42 中的 = 运算符看起来没有副作用，实际上它的结果值是 42，它的副作用是将 42 赋值给 a。</p>
<h3 id="上下文规则"><a href="#上下文规则" class="headerlink" title="上下文规则"></a>上下文规则</h3><div class="code-wrapper"><pre><code class="hljs awk">[] + &#123;&#125;; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;[object Object]&quot;</span>

&#123;&#125; + []; <span class="hljs-regexp">//</span> <span class="hljs-number">0</span></code></pre></div>

<p>表面上看 + 运算符根据第一个操作数（[] 或 {}）的不同会产生不同的结果，实则不然。第一行代码中，{} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。 [] 会被强制类型转换为 “”，而 {} 会被强制类型转换为 “[object Object]”。但在第二行代码中，{} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为 0。</p>
<p><strong>对象解构</strong></p>
<p>{ .. } 还可以用作函数命名参数（named function argument）的对象解构（object destructuring），方便隐式地用对象属性赋值：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">&#123; a, b, c &#125;</span>) &#123;
 <span class="hljs-comment">// 不再需要这样:</span>
 <span class="hljs-comment">// var a = obj.a, b = obj.b, c = obj.c</span>
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a, b, c );
&#125;
<span class="hljs-title function_">foo</span>( &#123;
 <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],
 <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>,
 <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;foo&quot;</span>
&#125; ); <span class="hljs-comment">// 42 &quot;foo&quot; [1, 2, 3]</span></code></pre></div>

<p>else if <strong>和可选代码块</strong></p>
<p>很多人误以为 JavaScript 中有 else if，因为我们可以这样来写代码：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (a) &#123; 
 <span class="hljs-comment">// ..</span>
&#125;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b) &#123;
 <span class="hljs-comment">// .. </span>
&#125;
<span class="hljs-keyword">else</span> &#123; 
 <span class="hljs-comment">// ..</span>
&#125;</code></pre></div>

<p>事实上 JavaScript 没有 else if，但 if 和 else 只包含单条语句的时候可以省略代码块的x{ }。下面的代码你一定不会陌生：</p>
<div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (a) <span class="hljs-keyword">do</span><span class="hljs-constructor">Something( <span class="hljs-params">a</span> )</span>;</code></pre></div>

<p>很多 JavaScript 代码检查工具建议对单条语句也应该加上 { }，如：</p>
<div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (a) &#123; <span class="hljs-keyword">do</span><span class="hljs-constructor">Something( <span class="hljs-params">a</span> )</span>; &#125;</code></pre></div>

<p>else 也是如此，所以我们经常用到的 else if 实际上是这样的：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (a) &#123; 
 <span class="hljs-comment">// ..</span>
&#125; 
<span class="hljs-keyword">else</span> &#123;
 <span class="hljs-keyword">if</span> (b) &#123; 
 <span class="hljs-comment">// ..</span>
 &#125; 
 <span class="hljs-keyword">else</span> &#123;
 <span class="hljs-comment">// .. </span>
 &#125;</code></pre></div>

<p>if (b) { .. } else { .. } 实际上是跟在 else 后面的一个单独的语句，所以带不带 { } 都可以。换句话说，else if 不符合前面介绍的编码规范，else 中是一个单独的 if 语句。</p>
<p>else if 极为常见，能省掉一层代码缩进，所以很受青睐。但这只是我们自己发明的用法，切勿想当然地认为这些都属于 JavaScript 语法的范畴。</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>mdn运算符优先级列表：</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p>
<h3 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h3><p>对 &amp;&amp; 和 || 来说，如果从左边的操作数能够得出结果，就可以忽略右边的操作数。我们将这种现象称为“短路”（即执行最短路径）。</p>
<p>以 a &amp;&amp; b 为例，如果 a 是一个假值，足以决定 &amp;&amp; 的结果，就没有必要再判断 b 的值。同样对于 a || b，如果 a 是一个真值，也足以决定 || 的结果，也就没有必要再判断 b 的值。</p>
<p>“短路”很方便，也很常用，如：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">opts</span>) &#123;
 <span class="hljs-keyword">if</span> (opts &amp;&amp; opts.<span class="hljs-property">cool</span>) &#123;
 <span class="hljs-comment">// .. </span>
 &#125;
&#125;</code></pre></div>

<p>opts &amp;&amp; opts.cool 中的 opts 条件判断如同一道安全保护，因为如果 opts 未赋值（或者不是一个对象），表达式 opts.cool 会出错。通过使用短路特性，opts 条件判断未通过时opts.cool 就不会执行，也就不会产生错误！</p>
<p>|| 运算符也一样：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">opts</span>) &#123;
 <span class="hljs-keyword">if</span> (opts.<span class="hljs-property">cache</span> || <span class="hljs-title function_">primeCache</span>()) &#123;
 <span class="hljs-comment">// .. </span>
 &#125;
&#125;</code></pre></div>

<p>这里首先判断 opts.cache 是否存在，如果是则无需调用 primeCache() 函数，这样可以避免执行不必要的代码。</p>
<p>a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a=&gt;(a &amp;&amp; b || c) ? (c || b) ? a : (c &amp;&amp; b) : a</p>
<p>为 &amp;&amp; 运算符的优先级高于 ||，而 || 的优先级又高于 ? :。</p>
<h2 id="自动分号"><a href="#自动分号" class="headerlink" title="自动分号"></a>自动分号</h2><p>有时 JavaScript 会自动为代码行补上缺失的分号，即自动分号插入（Automatic Semicolon Insertion，ASI）。</p>
<p>因为如果缺失了必要的 ;，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的 ;。请注意，ASI 只在换行符处起作用，而不会在代码行的中间插入分号</p>
<p>如果 JavaScript 解析器发现代码行可能因为缺失分号而导致错误，那么它就会自动补上分号。并且，只有在代码行末尾与换行符之间除了空格和注释之外没有别的内容时，它才会这样做。</p>
<p>例如：</p>
<div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">var a</span> = 42, b 
c;</code></pre></div>

<p>如果 b 和 c 之间出现 a , 的话（即使另起一行），c 会被作为 var 语句的一部分来处理。在上例中，JavaScript 判断 b 之后应该有 ;，所以 c; 被处理为一个独立的表达式语句。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>, b = <span class="hljs-string">&quot;foo&quot;</span>;
a
b <span class="hljs-comment">// &quot;foo&quot;</span></code></pre></div>

<p>上述代码同样合法，不会产生错误，因为 ASI 也适用于表达式语句。</p>
<p>ASI 在某些情况下很有用，比如：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
<span class="hljs-keyword">do</span> &#123;
 <span class="hljs-comment">// ..</span>
&#125; <span class="hljs-keyword">while</span> (a) <span class="hljs-comment">// &lt;-- 这里应该有;</span>
a;</code></pre></div>

<p>语法规定 do..while 循环后面必须带 ;，而 while 和 for 循环后则不需要。大多数开发人员都不记得这一点，此时 ASI 就会自动补上分号。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
<span class="hljs-keyword">while</span> (a) &#123;
 <span class="hljs-comment">// ..</span>
&#125; <span class="hljs-comment">// &lt;-- 这里可以没有;</span>
a;</code></pre></div>

<p>其他涉及 ASI 的情况是 break、continue、return 和 yield（ES6）等关键字：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;
 <span class="hljs-keyword">if</span> (!a) <span class="hljs-keyword">return</span>
 a *= <span class="hljs-number">2</span>;
 <span class="hljs-comment">// .. </span>
&#125;</code></pre></div>

<p>由于 ASI 会在 return 后面自动加上 ;，所以这里 return 语句并不包括第二行的 a *= 2。return 语句的跨度可以是多行，但是其后必须有换行符以外的代码：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;
 <span class="hljs-keyword">return</span> (
 a * <span class="hljs-number">2</span> + <span class="hljs-number">3</span> / <span class="hljs-number">12</span> 
 );
&#125;</code></pre></div>

<p>上述规则对 break、continue 和 yield 也同样适用。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><h3 id="提前使用变量"><a href="#提前使用变量" class="headerlink" title="提前使用变量"></a>提前使用变量</h3><p>ES6 规范定义了一个新概念，叫作 TDZ（Temporal Dead Zone，暂时性死区）。</p>
<p>TDZ 指的是由于代码中的变量还没有初始化而不能被引用的情况。</p>
<p>对此，最直观的例子是 ES6 规范中的 let 块作用域：</p>
<div class="code-wrapper"><pre><code class="hljs js">&#123;
 a = <span class="hljs-number">2</span>; <span class="hljs-comment">// ReferenceError!</span>
 <span class="hljs-keyword">let</span> a; 
&#125;</code></pre></div>

<p>a = 2 试图在 let a 初始化 a 之前使用该变量（其作用域在 { .. } 内），这里就是 a 的TDZ，会产生错误。</p>
<p>对未声明变量使用 typeof 不会产生错误，但在 TDZ 中却会报错：</p>
<div class="code-wrapper"><pre><code class="hljs js">&#123;
 <span class="hljs-keyword">typeof</span> a; <span class="hljs-comment">// undefined</span>
 <span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// ReferenceError! (TDZ)</span>
 <span class="hljs-keyword">let</span> b;
&#125;</code></pre></div>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>另一个 TDZ 违规的例子是 ES6 中的参数默认值</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"> a = <span class="hljs-number">42</span>, b = a + b + <span class="hljs-number">5</span> </span>) &#123;
 <span class="hljs-comment">// ..</span>
&#125;</code></pre></div>

<p>b = a + b + 5 在参数 b（= 右边的 b，而不是函数外的那个）的 TDZ 中访问 b，所以会出错。而访问 a 却没有问题，因为此时刚好跨出了参数 a 的 TDZ。</p>
<p>对 ES6 中的参数默认值而言，参数被省略或被赋值为 undefined 效果都一样，都是取该参数的默认值。然而某些情况下，它们之间还是有区别的：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"> a = <span class="hljs-number">42</span>, b = a + <span class="hljs-number">1</span> </span>) &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
 <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>, a, b,
 <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]
 );
&#125;
<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 0 42 43 undefined undefined</span>
<span class="hljs-title function_">foo</span>( <span class="hljs-number">10</span> ); <span class="hljs-comment">// 1 10 11 10 undefined</span>
<span class="hljs-title function_">foo</span>( <span class="hljs-number">10</span>, <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// 2 10 11 10 undefined</span>
<span class="hljs-title function_">foo</span>( <span class="hljs-number">10</span>, <span class="hljs-literal">null</span> ); <span class="hljs-comment">// 2 10 null 10 null</span></code></pre></div>

<p>虽然参数 a 和 b 都有默认值，但是函数不带参数时，arguments 数组为空,相反，如果向函数传递 undefined 值，则 arguments 数组中会出现一个值为 undefined 的单元，而不是默认值。</p>
<p>ES6 参数默认值会导致 arguments 数组和相对应的命名参数之间出现偏差，ES5 也会出现这种情况：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;
 a = <span class="hljs-number">42</span>;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] );
&#125;
<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 42 (linked)</span>
<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// undefined (not linked)</span></code></pre></div>

<p>向函数传递参数时，arguments 数组中的对应单元会和命名参数建立关联（linkage）以得到相同的值。相反，不传递参数就不会建立关联。</p>
<p>但是，在严格模式中并没有建立关联这一说：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;
 <span class="hljs-string">&quot;use strict&quot;</span>;
 a = <span class="hljs-number">42</span>;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] );
&#125;
<span class="hljs-title function_">foo</span>( <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2 (not linked)</span>
<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// undefined (not linked)</span></code></pre></div>

<p>因此，在开发中不要依赖这种关联机制。实际上，它是 JavaScript 语言引擎底层实现的一个抽象泄漏（leaky abstraction），并不是语言本身的特性。</p>
<p>在 ES6 之前，获得函数所有参数的唯一途径就是 arguments 数组。此外，即使将命名参数和 arguments 数组混用也不会出错，只需遵守一个原则，即不要同时访问命名参数和其对应的 arguments 数组单元。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a + <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 安全! &#125;</span>
<span class="hljs-title function_">foo</span>( <span class="hljs-number">10</span>, <span class="hljs-number">32</span> ); <span class="hljs-comment">// 42</span></code></pre></div>

<h2 id="try-finally"><a href="#try-finally" class="headerlink" title="try..finally"></a>try..finally</h2><p>finally 中的代码总是会在 try 之后执行，如果有 catch 的话则在 catch 之后执行。也可以将 finally 中的代码看作一个回调函数，即无论出现什么情况最后一定会被调用。</p>
<p>如果 try 中有 return 语句会出现什么情况呢？ return 会返回一个值，那么调用该函数得到返回值的代码是在 finally 之前还是之后执行呢？</p>
<div class="code-wrapper"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
 &#125; 
 <span class="hljs-keyword">finally</span> &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Hello&quot;</span> );
 &#125;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;never runs&quot;</span> );
&#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">foo</span>() );
<span class="hljs-comment">// Hello</span>
<span class="hljs-comment">// 42</span></code></pre></div>

<p>这里 return 42 先执行，并将 foo() 函数的返回值设置为 42。然后 try 执行完毕，接着执行 finally。最后 foo() 函数执行完毕，console.log(..) 显示返回值。</p>
<p>try 中的 throw 也是如此</p>
<div class="code-wrapper"><pre><code class="hljs js"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-keyword">throw</span> <span class="hljs-number">42</span>; 
 &#125;
 <span class="hljs-keyword">finally</span> &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Hello&quot;</span> );
 &#125;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;never runs&quot;</span> );
&#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">foo</span>() );
<span class="hljs-comment">// Hello</span>
<span class="hljs-comment">// Uncaught Exception: 42</span></code></pre></div>

<p>如果 finally 中抛出异常（无论是有意还是无意），函数就会在此处终止。如果此前 try 中已经有 return 设置了返回值，则该值会被丢弃：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
 &#125; 
 <span class="hljs-keyword">finally</span> &#123;
 <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Oops!&quot;</span>;
 &#125;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;never runs&quot;</span> );
&#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">foo</span>() );
<span class="hljs-comment">// Uncaught Exception: Oops!</span></code></pre></div>

<p>continue 和 break 等控制语句也是如此</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-keyword">continue</span>; 
 &#125;
 <span class="hljs-keyword">finally</span> &#123;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( i );
 &#125;
&#125;
<span class="hljs-comment">// 0 1 2 3 4 5 6 7 8 9</span></code></pre></div>

<p>continue 在每次循环之后，会在 i++ 执行之前执行 console.log(i)，所以结果是 0..9 而非1..10。</p>
<p>ES6 中新加入了 yield，可以将其视为return 的中间版本。然而与 return 不同的是，yield 在 generator（ES6 的另一个新特性）重新开始时才结束，这意味着 try { .. yield .. } 并未结束，因此 finally 不会在 yield 之后立即执行。</p>
<p>finally 中的 return 会覆盖 try 和 catch 中 return 的返回值：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
 &#125; 
 <span class="hljs-keyword">finally</span> &#123;
 <span class="hljs-comment">// 没有返回语句，所以没有覆盖</span>
 &#125; 
&#125;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
 &#125;
 <span class="hljs-keyword">finally</span> &#123;
 <span class="hljs-comment">// 覆盖前面的 return 42</span>
 <span class="hljs-keyword">return</span>; 
 &#125;
&#125;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
 &#125; 
 <span class="hljs-keyword">finally</span> &#123;
 <span class="hljs-comment">// 覆盖前面的 return 42</span>
 <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;
 &#125;
&#125;
<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 42</span>
<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// undefined</span>
<span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// Hello</span></code></pre></div>

<p>通常来说，在函数中省略 return 的结果和 return; 及 return undefined; 是一样的，但是在 finally 中省略 return 则会返回前面的 return 设定的返回值。</p>
<p>事实上，还可以将 finally 和带标签的 break 混合使用</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
 <span class="hljs-attr">bar</span>: &#123;
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
 &#125; 
 <span class="hljs-keyword">finally</span> &#123;
 <span class="hljs-comment">// 跳出标签为bar的代码块</span>
 <span class="hljs-keyword">break</span> bar;
 &#125;
 &#125;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Crazy&quot;</span> );
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;
&#125;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">foo</span>() );
<span class="hljs-comment">// Crazy</span>
<span class="hljs-comment">// Hello</span></code></pre></div>

<p>但切勿这样操作。利用 finally 加带标签的 break 来跳过 return 只会让代码变得晦涩难懂，即使加上注释也是如此</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (a) &#123;
 <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
 <span class="hljs-comment">// 执行一些代码</span>
 <span class="hljs-keyword">break</span>;
 <span class="hljs-keyword">case</span> <span class="hljs-number">42</span>:
 <span class="hljs-comment">// 执行另外一些代码</span>
 <span class="hljs-keyword">break</span>;
 <span class="hljs-attr">default</span>:
 <span class="hljs-comment">// 执行缺省代码</span>
&#125;</code></pre></div>

<p>首先，a 和 case 表达式的匹配算法与 ===相同。通常 case 语句中的 switch都是简单值</p>
<p>有时候需要使用强制类型转换，就是需要使用==进行比较，需要特殊处理</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;42&quot;</span>;
<span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) &#123;
 <span class="hljs-keyword">case</span> a == <span class="hljs-number">10</span>:
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;10 or &#x27;10&#x27;&quot;</span> );
 <span class="hljs-keyword">break</span>;
 <span class="hljs-keyword">case</span> a == <span class="hljs-number">42</span>;
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;42 or &#x27;42&#x27;&quot;</span> );
 <span class="hljs-keyword">break</span>;
 <span class="hljs-attr">default</span>:
 <span class="hljs-comment">// 永远执行不到这里</span>
&#125;
<span class="hljs-comment">// 42 or &#x27;42&#x27;</span></code></pre></div>

<p>除简单值以外，case 中还可以出现各种表达式，它会将表达式的结果值和 true 进行比较。因为 a == 42 的结果为 true，所以条件成立。</p>
<p>尽管可以使用 ==，但 switch 中 true 和 true 之间仍然是严格相等比较。即如果 case 表达式的结果为真值，但不是严格意义上的 true，则条件不成立。所以，在这里使用 || 和 &amp;&amp; 等逻辑运算符就很容易掉进坑里：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;hello world&quot;</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;
<span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) &#123;
 <span class="hljs-keyword">case</span> (a || b == <span class="hljs-number">10</span>):
 <span class="hljs-comment">// 永远执行不到这里</span>
 <span class="hljs-keyword">break</span>;
 <span class="hljs-attr">default</span>:
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> );
&#125;
<span class="hljs-comment">// Oops</span></code></pre></div>

<p>因为 (a || b == 10) 的结果是 “hello world” 而非 true，所以严格相等比较不成立。此时可以通过强制表达式返回 true 或 false，如 case !!(a || b == 10)</p>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="分块的程序"><a href="#分块的程序" class="headerlink" title="分块的程序"></a>分块的程序</h2><h3 id="异步控制台"><a href="#异步控制台" class="headerlink" title="异步控制台"></a>异步控制台</h3><p>并没有什么规范或一组需求指定 console.* 方法族如何工作——它们并不是 JavaScript 正式的一部分，而是由宿主环境添加到 JavaScript 中的。因此，不同的浏览器和 JavaScript 环境可以按照自己的意愿来实现，有时候这会引起混淆。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>那么，什么是事件循环？</p>
<p>先通过一段伪代码了解一下这个概念 :</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// eventLoop是一个用作队列的数组</span>
<span class="hljs-comment">// （先进，先出）</span>
<span class="hljs-keyword">var</span> eventLoop = [ ];
<span class="hljs-keyword">var</span> event;
<span class="hljs-comment">// “永远”执行</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;
 <span class="hljs-comment">// 一次tick</span>
 <span class="hljs-keyword">if</span> (eventLoop.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;
 <span class="hljs-comment">// 拿到队列中的下一个事件</span>
 event = eventLoop.<span class="hljs-title function_">shift</span>();
 <span class="hljs-comment">// 现在，执行下一个事件</span>
 <span class="hljs-keyword">try</span> &#123;
 <span class="hljs-title function_">event</span>();
 &#125;
 <span class="hljs-keyword">catch</span> (err) &#123;
 <span class="hljs-title function_">reportError</span>(err);
   &#125;
 &#125;
&#125;</code></pre></div>

<p>这当然是一段极度简化的伪代码，只用来说明概念。不过它应该足以用来帮助大家有更好的理解。</p>
<p>你可以看到，有一个用 while 循环实现的持续运行的循环，循环的每一轮称为一个 tick。对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这些事件就是你的回调函数。</p>
<p>一定要清楚，setTimeout(..) 并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 tick 会摘下并执行这个回调。</p>
<p>如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么setTimeout(..) 定时器的精度可能不高。大体说来，只能确保你的回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，要根据事件队列的状态而定。</p>
<p>所以换句话说就是，程序通常分成了很多小块，在事件循环队列中一个接一个地执行。严格地说，和你的程序不直接相关的其他事件也可能会插入到队列中</p>
<h2 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h2><p>术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。记住，异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情</p>
<p>并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。</p>
<p>与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。</p>
<p>并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">later</span>(<span class="hljs-params"></span>) &#123; 
 answer = answer * <span class="hljs-number">2</span>; 
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Meaning of life:&quot;</span>, answer ); 
&#125;</code></pre></div>

<p>尽管 later() 的所有内容被看作单独的一个事件循环队列表项，但如果考虑到这段代码是运行在一个线程中，实际上可能有很多个不同的底层运算。比如，answer = answer * 2 需要先加载 answer 的当前值，然后把 2 放到某处并执行乘法，取得结果之后保存回 answer 中。</p>
<p>在单线程环境中，线程队列中的这些项目是底层运算确实是无所谓的，因为线程本身不会被中断。但如果是在并行系统中，同一个程序中可能有两个不同的线程在运转，这时很可能就会得到不确定的结果。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; 
 a = a + <span class="hljs-number">1</span>; 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123; 
 a = a * <span class="hljs-number">2</span>; 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div>

<p>根据 JavaScript 的单线程运行特性，如果 foo() 运行在 bar() 之前，a 的结果是 42，而如果bar() 运行在 foo() 之前的话，a 的结果就是 41。</p>
<p>如果共享同一数据的 JavaScript 事件并行执行的话，那么问题就变得更加微妙了。考虑foo() 和 bar() 中代码运行的线程分别执行的是以下两段伪代码任务，然后思考一下如果它们恰好同时运行的话会出现什么情况。</p>
<p>线程 1（X 和 Y 是临时内存地址）：</p>
<div class="code-wrapper"><pre><code class="hljs tp">foo(): 
 a. 把a的值加载到<span class="hljs-keyword">X</span> 
 b. 把<span class="hljs-number">1</span>保存在<span class="hljs-keyword">Y</span> 
 c. 执行<span class="hljs-keyword">X</span>加<span class="hljs-keyword">Y</span>，结果保存在<span class="hljs-keyword">X</span> 
 d. 把<span class="hljs-keyword">X</span>的值保存在a</code></pre></div>

<p>线程 2（X 和 Y 是临时内存地址）：</p>
<div class="code-wrapper"><pre><code class="hljs tp">bar(): 
 a. 把a的值加载到<span class="hljs-keyword">X</span> 
 b. 把<span class="hljs-number">2</span>保存在<span class="hljs-keyword">Y</span> 
 c. 执行<span class="hljs-keyword">X</span>乘<span class="hljs-keyword">Y</span>，结果保存在<span class="hljs-keyword">X</span> 
 d. 把<span class="hljs-keyword">X</span>的值保存在a</code></pre></div>

<p>现在，假设两个线程并行执行。你可能已经发现了这个程序的问题，是吧？它们在临时步骤中使用了共享的内存地址 X 和 Y。</p>
<p>如果按照以下步骤执行，最终结果将会是什么样呢？</p>
<div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-number">1</span>a (把a的值加载到X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) 
<span class="hljs-number">2</span>a (把a的值加载到X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) 
<span class="hljs-number">1</span>b (把<span class="hljs-number">1</span>保存在Y <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">1</span>) 
<span class="hljs-number">2</span>b (把<span class="hljs-number">2</span>保存在Y <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">2</span>) 
<span class="hljs-number">1</span>c (执行X加Y，结果保存在X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">22</span>) 
<span class="hljs-number">1</span>d (把X的值保存在a <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">22</span>) 
<span class="hljs-number">2</span>c (执行X乘Y，结果保存在X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">44</span>) 
<span class="hljs-number">2</span>d (把X的值保存在a <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">44</span>)</code></pre></div>

<p>a 的结果将是 44。但如果按照以下顺序执行呢？</p>
<div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-number">1</span>a (把a的值加载到X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) 
<span class="hljs-number">2</span>a (把a的值加载到X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) 
<span class="hljs-number">2</span>b (把<span class="hljs-number">2</span>保存在Y <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">2</span>) 
<span class="hljs-number">1</span>b (把<span class="hljs-number">1</span>保存在Y <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">1</span>) 
<span class="hljs-number">2</span>c (执行X乘Y，结果保存在X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">20</span>) 
<span class="hljs-number">1</span>c (执行X加Y，结果保存在X <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">21</span>) 
<span class="hljs-number">1</span>d (把X的值保存在a <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">21</span>) 
<span class="hljs-number">2</span>d (把X的值保存在a <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; <span class="hljs-number">21</span>)</code></pre></div>

<p>a 的结果将是 21。</p>
<p>所以，多线程编程是非常复杂的。因为如果不通过特殊的步骤来防止这种中断和交错运行的话，可能会得到出乎意料的、不确定的行为，通常这很让人头疼。</p>
<p>JavaScript 从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。但是这并不意味着 JavaScript 总是确定性的。回忆一下前面提到的，foo() 和 bar() 的相对顺序改变可能会导致不同结果（41 或 42）。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>单线程事件循环是并发的一种形式</p>
<h3 id="非交互"><a href="#非交互" class="headerlink" title="非交互"></a>非交互</h3><p>两个或多个“进程”在同一个程序内并发地交替运行它们的步骤 / 事件时，如果这些任务彼此不相关，就不一定需要交互。如果进程间没有相互影响的话，不确定性是完全可以接受的。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = &#123;&#125;; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">results</span>) &#123; 
 res.<span class="hljs-property">foo</span> = results; 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">results</span>) &#123; 
 res.<span class="hljs-property">bar</span> = results; 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库提供的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div>

<p>foo() 和 bar() 是两个并发执行的“进程”，按照什么顺序执行是不确定的。但是，我们构建程序的方式使得无论按哪种顺序执行都无所谓，因为它们是独立运行的，不会相互影响。</p>
<p>这并不是竞态条件 bug，因为不管顺序如何，代码总会正常工作。</p>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>更常见的情况是，并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。正如前面介绍的，如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = []; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">data</span>) &#123; 
 res.<span class="hljs-title function_">push</span>( data ); 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, response ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, response );</code></pre></div>

<p>这里的并发“进程”是这两个用来处理 Ajax 响应的 response() 调用。它们可能以任意顺序运行。</p>
<p>我们假定期望的行为是 res[0] 中放调用 “<a target="_blank" rel="noopener" href="http://some.url.1&quot;/">http://some.url.1&quot;</a> 的结果，res[1] 中放调用”<a target="_blank" rel="noopener" href="http://some.url.2&quot;/">http://some.url.2&quot;</a> 的结果。有时候可能是这样，但有时候却恰好相反，这要视哪个调用先完成而定。</p>
<p>这种不确定性很有可能就是一个竞态条件 bug</p>
<p>所以，可以协调交互顺序来处理这样的竞态条件：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = []; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">data</span>) &#123; 
 <span class="hljs-keyword">if</span> (data.<span class="hljs-property">url</span> == <span class="hljs-string">&quot;http://some.url.1&quot;</span>) &#123; 
 res[<span class="hljs-number">0</span>] = data; 
 &#125; 
 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.<span class="hljs-property">url</span> == <span class="hljs-string">&quot;http://some.url.2&quot;</span>) &#123; 
 res[<span class="hljs-number">1</span>] = data; 
 &#125; 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, response ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, response );</code></pre></div>

<p>不管哪一个 Ajax 响应先返回，我们都要通过查看 data.url（当然，假定从服务器总会返回一个！）判断应该把响应数据放在 res 数组中的什么位置上。res[0] 总是包含 “<a target="_blank" rel="noopener" href="http://some.url.1&quot;/">http://some.url.1&quot;</a> 的结果，res[1] 总是包含 “<a target="_blank" rel="noopener" href="http://some.url.2&quot;/">http://some.url.2&quot;</a> 的结果。通过简单的协调，就避免了竞态条件引起的不确定性。</p>
<p>从这个场景推出的方法也可以应用于多个并发函数调用通过共享 DOM 彼此之间交互的情况，比如一个函数调用更新某个 <div> 的内容，另外一个更新这个 <div> 的风格或属性（比如使这个 DOM 元素一有内容就显示出来）。可能你并不想在这个 DOM 元素在拿到内容之前显示出来，所以这种协调必须要保证正确的交互顺序。</p>
<p>有些并发场景如果不做协调，就总是（并非偶尔）会出错。考虑：</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a, b; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;
 a = x * <span class="hljs-number">2</span>; 
 baz(); 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">y</span>) &#123; 
 b = y * <span class="hljs-number">2</span>; 
 baz(); 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; 
 <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a + b); 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中的某个Ajax函数</span>
ajax( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); 
ajax( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div>

<p>在这个例子中，无论 foo() 和 bar() 哪一个先被触发，总会使 baz() 过早运行（a 或者 b 仍处于未定义状态）；但对 baz() 的第二次调用就没有问题，因为这时候 a 和 b 都已经可用了</p>
<p>要解决这个问题有多种方法。这里给出了一种简单方法：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123; 
 a = x * <span class="hljs-number">2</span>; 
 <span class="hljs-keyword">if</span> (a &amp;&amp; b) &#123; 
 <span class="hljs-title function_">baz</span>(); 
 &#125; 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">y</span>) &#123; 
 b = y * <span class="hljs-number">2</span>; 
 <span class="hljs-keyword">if</span> (a &amp;&amp; b) &#123; 
 <span class="hljs-title function_">baz</span>(); 
 &#125; 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; 
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a + b ); 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div>

<p>包裹 baz() 调用的条件判断 if (a &amp;&amp; b) 传统上称为门（gate），我们虽然不能确定 a 和 b到达的顺序，但是会等到它们两个都准备好再进一步打开门（调用 baz()）。</p>
<p>另一种可能遇到的并发交互条件有时称为竞态（race），但是更精确的叫法是门闩（latch）。它的特性可以描述为“只有第一名取胜”。在这里，不确定性是可以接受的，因为它明确指出了这一点是可以接受的：需要“竞争”到终点，且只有唯一的胜利者</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123; 
 a = x * <span class="hljs-number">2</span>; 
 <span class="hljs-title function_">baz</span>(); 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x</span>) &#123; 
 a = x / <span class="hljs-number">2</span>; 
 <span class="hljs-title function_">baz</span>(); 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; 
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div>

<p>不管哪一个（foo() 或 bar()）后被触发，都不仅会覆盖另外一个给 a 赋的值，也会重复调用 baz()（很可能并不是想要的结果）。</p>
<p>所以，可以通过一个简单的门闩协调这个交互过程，只让第一个通过：</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123; 
 <span class="hljs-keyword">if</span> (!a) &#123; 
 a = x * <span class="hljs-number">2</span>; 
 <span class="hljs-title function_">baz</span>(); 
 &#125; 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x</span>) &#123; 
 <span class="hljs-keyword">if</span> (!a) &#123; 
 a = x / <span class="hljs-number">2</span>; 
 <span class="hljs-title function_">baz</span>(); 
 &#125; 
&#125; 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; 
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( a ); 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, foo ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, bar );</code></pre></div>

<p>条件判断 if (!a) 使得只有 foo() 和 bar() 中的第一个可以通过，第二个（实际上是任何后续的）调用会被忽略。也就是说，第二名没有任何意义！</p>
<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>还有一种并发合作方式，称为并发协作（cooperative concurrency）。这里的重点不再是通过共享作用域中的值进行交互（尽管显然这也是允许的！）。这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = []; 
<span class="hljs-comment">// response(..)从Ajax调用中取得结果数组</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">data</span>) &#123; 
 <span class="hljs-comment">// 添加到已有的res数组</span>
 res = res.<span class="hljs-title function_">concat</span>( 
 <span class="hljs-comment">// 创建一个新的变换数组把所有data值加倍</span>
 data.<span class="hljs-title function_">map</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123; 
 <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>; 
 &#125; ) 
 ); 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, response ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, response )</code></pre></div>

<p>如果 “<a target="_blank" rel="noopener" href="http://some.url.1&quot;/">http://some.url.1&quot;</a> 首先取得结果，那么整个列表会立刻映射到 res 中。如果记录有几千条或更少，这不算什么。但是如果有像 1000 万条记录的话，就可能需要运行相当一段时间了（在高性能笔记本上需要几秒钟，在移动设备上需要更长时间，等等）。</p>
<p>这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的 response(..)调用或 UI 刷新，甚至是像滚动、输入、按钮点击这样的用户事件。这是相当痛苦的</p>
<p>所以，要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，你可以异步地批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> res = []; 
<span class="hljs-comment">// response(..)从Ajax调用中取得结果数组</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">data</span>) &#123; 
 <span class="hljs-comment">// 一次处理1000个</span>
 <span class="hljs-keyword">var</span> chunk = data.<span class="hljs-title function_">splice</span>( <span class="hljs-number">0</span>, <span class="hljs-number">1000</span> ); 
 <span class="hljs-comment">// 添加到已有的res组</span>
 res = res.<span class="hljs-title function_">concat</span>( 
 <span class="hljs-comment">// 创建一个新的数组把chunk中所有值加倍</span>
 chunk.<span class="hljs-title function_">map</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123; 
 <span class="hljs-keyword">return</span> val * <span class="hljs-number">2</span>; 
 &#125; ) 
 ); 
 <span class="hljs-comment">// 还有剩下的需要处理吗？</span>
 <span class="hljs-keyword">if</span> (data.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123; 
 <span class="hljs-comment">// 异步调度下一次批处理</span>
 <span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; 
 <span class="hljs-title function_">response</span>( data ); 
 &#125;, <span class="hljs-number">0</span> ); 
 &#125; 
&#125; 
<span class="hljs-comment">// ajax(..)是某个库中提供的某个Ajax函数</span>
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.1&quot;</span>, response ); 
<span class="hljs-title function_">ajax</span>( <span class="hljs-string">&quot;http://some.url.2&quot;</span>, response );</code></pre></div>

<p>我们把数据集合放在最多包含 1000 条项目的块中。这样，我们就确保了“进程”运行时间会很短，即使这意味着需要更多的后续“进程”，因为事件循环队列的交替运行会提高站点 /App 的响应（性能）。</p>
<p>这里使用 setTimeout(..0)（hack）进行异步调度，基本上它的意思就是“把这个函数插入到当前事件循环队列的结尾处”。</p>
<p>严格说来，setTimeout(..0) 并不直接把项目插入到事件循环队列。定时器会在有机会的时候插入事件。举例来说，两个连续的 setTimeout(..0) 调用不能保证会严格按照调用顺序处理，所以各种情况都有可能出现，比如定时器漂移，在这种情况下，这些事件的顺序就不可预测。在 Node.js 中，类似的方法是 process.nextTick(..)。尽管它们使用方便（通常性能也更高），但并没有（至少到目前为止）直接的方法可以适应所有环境来确保异步事件的顺序</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/javascript/" class="category-chain-item">javascript</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/">#你不知道的JavaScript</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>你不知道的JavaScript（中卷）</div>
      <div>http://example.com/2023/01/19/你不知道的JavaScript（中卷）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/02/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89/" title="你不知道的JavaScript（下卷）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">你不知道的JavaScript（下卷）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/08/%E8%8B%B1%E8%AF%AD/" title="英语">
                        <span class="hidden-mobile">英语</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
