

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="函数探幽C++内联函数编译过程的最终产品是可执行程序——由一组机器语言指令组成。 运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环或分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在">
<meta property="og:type" content="article">
<meta property="og:title" content="C-Primer-Plus2">
<meta property="og:url" content="http://example.com/2023/03/04/C-Primer-Plus2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="函数探幽C++内联函数编译过程的最终产品是可执行程序——由一组机器语言指令组成。 运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环或分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-04%2020.41.35.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-05%2010.01.02.png">
<meta property="article:published_time" content="2023-03-04T17:25:36.000Z">
<meta property="article:modified_time" content="2023-03-05T15:50:20.241Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-04%2020.41.35.png">
  
  
  
  <title>C-Primer-Plus2 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Piggy的记录版</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C-Primer-Plus2"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-04 17:25" pubdate>
          2023年3月4日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          165 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C-Primer-Plus2</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h1><h2 id="C-内联函数"><a href="#C-内联函数" class="headerlink" title="C++内联函数"></a>C++内联函数</h2><p>编译过程的最终产品是可执行程序——由一组机器语言指令组成。 运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环或分支语句时），将跳过一些指令，向前或向后跳到特定地址。常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。下面更详细地介绍这一过程的典型实现。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 </p>
<p>C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数 调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本</p>
<p>应有选择地使用内联函数。如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。如果代 码执行时间很短，则内联调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程相当快，因此尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。</p>
<img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-04%2020.41.35.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>要使用这项特性，必须采取下述措施之一：</p>
<ul>
<li>在函数声明前加上关键字inline； </li>
<li>在函数定义前加上关键字inline。</li>
</ul>
<p>通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。</p>
<p>程序员请求将函数作为内联函数时，编译器并不一定会满足这种要求。它可能认为该函数过大或注意到函数调用了自己（内联函数不能递 归），因此不将其作为内联函数；而有些编译器没有启用或实现这种特性。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// inline.cpp -- using an inline function</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// an inline function definition</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-type">double</span> a, b;
    <span class="hljs-type">double</span> c = <span class="hljs-number">13.0</span>;

    a = <span class="hljs-built_in">square</span>(<span class="hljs-number">5.0</span>);
    b = <span class="hljs-built_in">square</span>(<span class="hljs-number">4.5</span> + <span class="hljs-number">7.5</span>);   <span class="hljs-comment">// can pass expressions</span>
    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c;
    cout &lt;&lt; <span class="hljs-string">&quot;, c squared = &quot;</span> &lt;&lt; <span class="hljs-built_in">square</span>(c++) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;Now c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;
    <span class="hljs-comment">// cin.get();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><p>C++新增了一种复合类型——引用变量。引用是已定义的变量的别 名（另一个名称）引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。</p>
<h3 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h3><p>前面讲过，C和C++使用&amp;符号来指示变量的地址。C++给&amp;符号赋予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量 的别名，可以这样做： </p>
<div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> rats;
<span class="hljs-built_in">int</span> &amp; rodents = rats <span class="hljs-comment">//make rodents an alias for rats</span></code></pre></div>

<p>其中，&amp;不是地址运算符，而是类型标识符的一部分。就像声明中的char*指的是指向char的指针一样，int &amp;指的是指向int的引用。上述引用声明允许将rats和rodents互换——它们指向相同的值和内存单元，</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// firstref.cpp -- defining and using a reference</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-type">int</span> rats = <span class="hljs-number">101</span>;
    <span class="hljs-type">int</span> &amp; rodents = rats;   <span class="hljs-comment">// rodents is a reference</span>

    cout &lt;&lt; <span class="hljs-string">&quot;rats = &quot;</span> &lt;&lt; rats;
    cout &lt;&lt; <span class="hljs-string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;
    rodents++;
    cout &lt;&lt; <span class="hljs-string">&quot;rats = &quot;</span> &lt;&lt; rats;
    cout &lt;&lt; <span class="hljs-string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;

<span class="hljs-comment">// some implementations require type casting the following</span>
<span class="hljs-comment">// addresses to type unsigned</span>
    cout &lt;&lt; <span class="hljs-string">&quot;rats address = &quot;</span> &lt;&lt; &amp;rats;
    cout &lt;&lt; <span class="hljs-string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;
    <span class="hljs-comment">// cin.get();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
<span class="hljs-comment">//rats = 101, rodents = 101</span>
<span class="hljs-comment">//rats = 102, rodents = 102</span>
<span class="hljs-comment">//rats address = 0x16faef738, rodents address = 0x16faef738</span></code></pre></div>

<p>请注意，下述语句中的&amp;运算符不是地址运算符，而是将rodents的类型声明为int &amp;，即指向int变量的引用：  </p>
<div class="code-wrapper"><pre><code class="hljs 1c">int <span class="hljs-meta">&amp; rodents = rats;   <span class="hljs-comment">// rodents is a reference</span></span></code></pre></div>

<p>但下述语句中的&amp;运算符是地址运算符，其中&amp;rodents表示rodents引用的变量的地址：</p>
<div class="code-wrapper"><pre><code class="hljs 1c">cout &lt;&lt; <span class="hljs-string">&quot;, rodents address = &quot;</span> &lt;&lt; <span class="hljs-meta">&amp;rodents &lt;&lt; endl;</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>rats = <span class="hljs-number">101</span>, rodents = <span class="hljs-number">101</span>
<span class="hljs-regexp">//</span>rats = <span class="hljs-number">102</span>, rodents = <span class="hljs-number">102</span>
<span class="hljs-regexp">//</span>rats address = <span class="hljs-number">0</span>x16faef738, rodents address = <span class="hljs-number">0</span>x16faef738</code></pre></div>

<p>从中可知，rats和rodents的值和地址都相同（具体的地址和显示格式随系统而异）。将rodents加1将影响这两个变量。更准确地说， rodents++操作将一个有两个名称的变量加1。</p>
<p>必须在声明引用变量时进行初始化。</p>
<p>引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。也就是说：</p>
<div class="code-wrapper"><pre><code class="hljs 1c">int <span class="hljs-meta">&amp; rodents  = rats;</span></code></pre></div>

<p>实际上是下述代码的伪装表示：</p>
<div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> * <span class="hljs-keyword">const</span> pr = &amp;rats;</code></pre></div>

<p>其中，引用rodents扮演的角色与表达式*pr相同。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// secref.cpp -- defining and using a reference</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-type">int</span> rats = <span class="hljs-number">101</span>;
    <span class="hljs-type">int</span> &amp; rodents = rats;   <span class="hljs-comment">// rodents is a reference</span>

    cout &lt;&lt; <span class="hljs-string">&quot;rats = &quot;</span> &lt;&lt; rats;
    cout &lt;&lt; <span class="hljs-string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;

    cout &lt;&lt; <span class="hljs-string">&quot;rats address = &quot;</span> &lt;&lt; &amp;rats;
    cout &lt;&lt; <span class="hljs-string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;

    <span class="hljs-type">int</span> bunnies = <span class="hljs-number">50</span>;
    rodents = bunnies;       <span class="hljs-comment">// can we change the reference?</span>
    cout &lt;&lt; <span class="hljs-string">&quot;bunnies = &quot;</span> &lt;&lt; bunnies;
    cout &lt;&lt; <span class="hljs-string">&quot;, rats = &quot;</span> &lt;&lt; rats;
    cout &lt;&lt; <span class="hljs-string">&quot;, rodents = &quot;</span> &lt;&lt; rodents &lt;&lt; endl;

    cout &lt;&lt; <span class="hljs-string">&quot;bunnies address = &quot;</span> &lt;&lt; &amp;bunnies;
    cout &lt;&lt; <span class="hljs-string">&quot;, rodents address = &quot;</span> &lt;&lt; &amp;rodents &lt;&lt; endl;
    <span class="hljs-comment">// cin.get();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
rats = <span class="hljs-number">101</span>, rodents = <span class="hljs-number">101</span>
rats address = <span class="hljs-number">0x16d5a7738</span>, rodents address = <span class="hljs-number">0x16d5a7738</span>
bunnies = <span class="hljs-number">50</span>, rats = <span class="hljs-number">50</span>, rodents = <span class="hljs-number">50</span>
bunnies address = <span class="hljs-number">0x16d5a772c</span>, rodents address = <span class="hljs-number">0x16d5a7738</span></code></pre></div>

<p>最初，rodents引用的是rats，但随后程序试图将rodents作为bunnies的引用：</p>
<div class="code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">rodents</span> <span class="hljs-operator">=</span> bunnies<span class="hljs-comment">;</span></code></pre></div>

<p>咋一看，这种意图暂时是成功的，因为rodents的值从101变为了50。但仔细研究将发现，rats也变成了50，同时rats和rodents的地址相 同，而该地址与bunnies的地址不同。由于rodents是rats的别名，因此上述赋值语句与下面的语句等效： </p>
<div class="code-wrapper"><pre><code class="hljs cpp">rats = bunnies;</code></pre></div>

<p>也就是说，这意味着“将bunnies变量的值赋给rat变量”。简而言之，可以通过初始化声明来设置引用，但不能通过赋值来设置。 </p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> rats = <span class="hljs-number">101</span>;
<span class="hljs-type">int</span> *pt =&amp;rats;
<span class="hljs-type">int</span> &amp; rodents = *pt;
<span class="hljs-type">int</span> bunnies = <span class="hljs-number">50</span>;
pt = &amp;bunnies;</code></pre></div>

<p>将rodents初始化为*pt使得rodents指向rats。接下来将pt改为指向bunnies，并不能改变这样的事实，即rodents引用的是rats。 </p>
<h3 id="将引用用作函数参数"><a href="#将引用用作函数参数" class="headerlink" title="将引用用作函数参数"></a>将引用用作函数参数</h3><p>引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被 调用的函数能够访问调用函数中的变量。C++新增的这项特性是对C语言的超越，C语言只能按值传递。按值传递导致被调用函数使用调用程序的值的拷贝（参见图8.2）。当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。</p>
<img src="https://raw.githubusercontent.com/yangzeng-cell/blogimage2/master/%E6%88%AA%E5%B1%8F2023-03-05%2010.01.02.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>现在我们通过一个常见的的计算机问题——交换两个变量的值，对使用引用和使用指针做一下比较。交换函数必须能够修改调用程序中的 变量的值。这意味着按值传递变量将不管用，因为函数将交换原始变量副本的内容，而不是变量本身的内容。但传递引用时，函数将可以使用原始数据。另一种方法是，传递指针来访问原始数据。程序清单8.4演示了这三种方法，其中包括一种不可行的方法，以便您能对这些方法进行比较</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// swaps.cpp -- swapping with references and with pointers</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapr</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a, <span class="hljs-type">int</span> &amp; b)</span></span>;   <span class="hljs-comment">// a, b are aliases for ints</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapp</span><span class="hljs-params">(<span class="hljs-type">int</span> * p, <span class="hljs-type">int</span> * q)</span></span>;   <span class="hljs-comment">// p, q are addresses of ints</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;       <span class="hljs-comment">// a, b are new variables</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-type">int</span> wallet1 = <span class="hljs-number">300</span>;
    <span class="hljs-type">int</span> wallet2 = <span class="hljs-number">350</span>;

    cout &lt;&lt; <span class="hljs-string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;
    cout &lt;&lt; <span class="hljs-string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;

    cout &lt;&lt; <span class="hljs-string">&quot;Using references to swap contents:\n&quot;</span>;
    <span class="hljs-built_in">swapr</span>(wallet1, wallet2);   <span class="hljs-comment">// pass variables</span>
    cout &lt;&lt; <span class="hljs-string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;
    cout &lt;&lt; <span class="hljs-string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;

    cout &lt;&lt; <span class="hljs-string">&quot;Using pointers to swap contents again:\n&quot;</span>;
    <span class="hljs-built_in">swapp</span>(&amp;wallet1, &amp;wallet2); <span class="hljs-comment">// pass addresses of variables</span>
    cout &lt;&lt; <span class="hljs-string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;
    cout &lt;&lt; <span class="hljs-string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;

    cout &lt;&lt; <span class="hljs-string">&quot;Trying to use passing by value:\n&quot;</span>;
    <span class="hljs-built_in">swapv</span>(wallet1, wallet2);   <span class="hljs-comment">// pass values of variables</span>
    cout &lt;&lt; <span class="hljs-string">&quot;wallet1 = $&quot;</span> &lt;&lt; wallet1;
    cout &lt;&lt; <span class="hljs-string">&quot; wallet2 = $&quot;</span> &lt;&lt; wallet2 &lt;&lt; endl;
    <span class="hljs-comment">// cin.get();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapr</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a, <span class="hljs-type">int</span> &amp; b)</span>    <span class="hljs-comment">// use references</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> temp;

    temp = a;       <span class="hljs-comment">// use a, b for values of variables</span>
    a = b;
    b = temp;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapp</span><span class="hljs-params">(<span class="hljs-type">int</span> * p, <span class="hljs-type">int</span> * q)</span>    <span class="hljs-comment">// use pointers</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> temp;

    temp = *p;      <span class="hljs-comment">// use *p, *q for values of variables</span>
    *p = *q;
    *q = temp;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapv</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>        <span class="hljs-comment">// try using values</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> temp;

    temp = a;      <span class="hljs-comment">// use a, b for values of variables</span>
    a = b;
    b = temp;
&#125;
<span class="hljs-comment">//wallet1 = $300 wallet2 = $350</span>
<span class="hljs-comment">//Using references to swap contents:</span>
<span class="hljs-comment">//wallet1 = $350 wallet2 = $300</span>
<span class="hljs-comment">//Using pointers to swap contents again:</span>
<span class="hljs-comment">//wallet1 = $300 wallet2 = $350</span>
<span class="hljs-comment">//Trying to use passing by value:</span>
<span class="hljs-comment">//wallet1 = $300 wallet2 = $350</span></code></pre></div>

<p>引用和指针方法都成功地交换了两个钱夹（wallet）中的内容，而按值传递的方法没能完成这项任务。</p>
<p>按引用传递（swapr(wallet1, wallet2)）和按值传递（swapv(wallet1, waller2)）看起来相同。只能通过原型或函数定义才能知道swapr( )是按 引用传递的。然而，地址运算符（&amp;）使得按地址传递 （swapp(&amp;wallet1, &amp;wallet2)）一目了然（类型声明int * p表明，p是一 个int指针，因此与p对应的参数应为地址，如&amp;wallet1）。</p>
<p>接下来，比较函数swapr( )（按引用传递）和swapv( )（按值传递）的代码，唯一的外在区别是声明函数参数的方式不同：</p>
<div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">swapr</span>(wallet1, wallet2);   <span class="hljs-comment">// pass variables</span>
<span class="hljs-built_in">swapv</span>(wallet1, wallet2);   <span class="hljs-comment">// pass values of variables</span></code></pre></div>

<p>当然还有内在区别：在swapr( )中，变量a和b是wallet1和wallet2的别名，所以交换a和b的值相当于交换wallet1和wallet2的值；但在swapv( )中，变量a和b是复制了wallet1和waller2的值的新变量，因此交换a和b的,值并不会影响wallet1和wallet2的值。</p>
<p>最后，比较函数swapr( )（传递引用）和swapp( )（传递指针）。第一个区别是声明函数参数的方式不同：</p>
<div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapr</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a, <span class="hljs-type">int</span> &amp; b)</span></span>;   <span class="hljs-comment">// a, b are aliases for ints</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapp</span><span class="hljs-params">(<span class="hljs-type">int</span> * p, <span class="hljs-type">int</span> * q)</span></span>;   <span class="hljs-comment">// p, q are addresses of ints</span></code></pre></div>

<p>另一个区别是指针版本需要在函数使用p和q的整个过程中使用解除引用运算符*。</p>
<p>前面说过，应在定义引用变量时对其进行初始化。函数调用使用实参初始化形参，因此函数的引用参数被初始化为函数调用传递的实参。 也就是说，下面的函数调用将形参a和b分别初始化为wallet1和wallet2：</p>
<div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">swapr</span>(wallet1, wallet2);</code></pre></div>

<h3 id="引用的属性和特别之处"><a href="#引用的属性和特别之处" class="headerlink" title="引用的属性和特别之处"></a>引用的属性和特别之处</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// cubes.cpp -- regular and reference arguments</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span>;
<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">refcube</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;ra)</span></span>;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
    <span class="hljs-type">double</span> x = <span class="hljs-number">3.0</span>;

    cout &lt;&lt; <span class="hljs-built_in">cube</span>(x);
    cout &lt;&lt; <span class="hljs-string">&quot; = cube of &quot;</span> &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-built_in">refcube</span>(x);
    cout &lt;&lt; <span class="hljs-string">&quot; = cube of &quot;</span> &lt;&lt; x &lt;&lt; endl;
    <span class="hljs-comment">// cin.get();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cube</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span>
<span class="hljs-function"></span>&#123;
    a *= a * a;
    <span class="hljs-keyword">return</span> a;
&#125;

<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">refcube</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;ra)</span></span>
<span class="hljs-function"></span>&#123;
    ra *= ra * ra;
    <span class="hljs-keyword">return</span> ra;
&#125;
<span class="hljs-comment">//27 = cube of 3</span>
<span class="hljs-comment">//27 = cube of 27</span></code></pre></div>

<p>refcube( )函数修改了main( )中的x值，而cube( )没有，这提醒我们为何通常按值传递。变量a位于cube( )中，它被初始化为x的值，但修改a并不会影响x。但由于refcube( )使用了引用参数，因此修改ra实际上就是修改x。如果程序员的意图是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用。例如，在这个例子中，应在函数原型和函数头中使用const： </p>
<div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> <span class="hljs-built_in">ref</span>cube(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> &amp;ra);</code></pre></div>

<p>如果这样做，当编译器发现代码修改了ra的值时，将生成错误消息</p>
<p>顺便说一句，如果要编写类似于上述示例的函数（即使用基本数值类型），应采用按值传递的方式，而不要采用按引用传递的方式。当数 据比较大（如结构和类）时，引用参数将很有用</p>
<p>按值传递的函数，如程序清单8.5中的函数cube( )，可使用多种类型的实参。例如，下面的调用都是合法的：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">double</span> z = cube(x+<span class="hljs-number">2</span>.<span class="hljs-number">0</span>);
<span class="hljs-attribute">z</span> = cube(<span class="hljs-number">8</span>.<span class="hljs-number">0</span>);
<span class="hljs-attribute">int</span> k = <span class="hljs-number">10</span>;
<span class="hljs-attribute">z</span> = cube(k);
<span class="hljs-attribute">double</span> yo[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>.<span class="hljs-number">2</span>,<span class="hljs-number">3</span>.<span class="hljs-number">3</span>,<span class="hljs-number">4</span>.<span class="hljs-number">4</span>&#125;;
<span class="hljs-attribute">z</span> = cube(yo[<span class="hljs-number">2</span>]);</code></pre></div>

<p>如果将与上面类似的参数传递给接受引用参数的函数，将会发现，传递引用的限制更严格。毕竟，如果ra是一个变量的别名，则实参应是 该变量。下面的代码不合理，因为表达式x + 3.0并不是变量：</p>
<div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> z = <span class="hljs-built_in">ref</span>cube(x+<span class="hljs-number">3.0</span>);</code></pre></div>

<p>例如，不能将值赋给该表达式：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>+<span class="hljs-number">3</span>.<span class="hljs-number">0</span> = <span class="hljs-number">5</span>.<span class="hljs-number">0</span>;</code></pre></div>

<p>如果试图使用像refcube(x + 3.0)这样的函数调用，将发生什么情况呢？在现代的C++中，这是错误的，大多数编译器都将指出这一点；</p>
<p>之所以做出这种比较温和的反应是由于早期的C++确实允许将表达式传递给引用变量。有些情况下，仍然是这样做的。这样做的结果如 下：由于x + 3.0不是double类型的变量，因此程序将创建一个临时的无名变量，并将其初始化为表达式x + 3.0的值。然后，ra将成为该临时变量的引用。下面详细讨论这种临时变量，看看什么时候创建它们，什么时候不创建</p>
<p>临时变量、引用参数和<strong>const</strong> </p>
<p>如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这样做，但以前不是这样。下面来看看何 种情况下，C++将生成临时变量，以及为何对const引用的限制是合理的。</p>
<p>首先，什么时候将创建临时变量呢？如果引用参数是const，则编译器将在下面两种情况下生成临时变量：</p>
<ul>
<li>实参的类型正确，但不是左值； </li>
<li>实参的类型不正确，但可以转换为正确的类型。</li>
</ul>
<p>左值是什么呢？左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面 常量（用引号括起的字符串除外，它们由其地址表示）和包含多项的表达式。在C语言中，左值最初指的是可出现在赋值语句左边的实体，但这是引入关键字const之前的情况。现在，常规变量和const变量都可视为左值，因为可通过地址访问它们。但常规变量属于可修改的左值，而const变量属于不可修改的左值。 </p>
<p>回到前面的示例。假设重新定义了refcube( )，使其接受一个常量引用参数：</p>
<div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> <span class="hljs-built_in">ref</span>cube(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> &amp;ra)
&#123;
    <span class="hljs-keyword">return</span> ra*ra * ra;;
&#125;</code></pre></div>

<p>现在考虑下面的代码： </p>
<div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> side = <span class="hljs-number">3.0</span>;
<span class="hljs-built_in">double</span> * pd = &amp;side;
<span class="hljs-built_in">double</span> &amp; rd = side
long edge = side;
<span class="hljs-built_in">double</span> lens[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">2.0</span>,<span class="hljs-number">5.0</span>,<span class="hljs-number">10.0</span>,<span class="hljs-number">12.0</span>&#125;;
<span class="hljs-built_in">double</span> c1 = <span class="hljs-built_in">ref</span>cube(side);
<span class="hljs-built_in">double</span> c2 = <span class="hljs-built_in">ref</span>cube(lens[<span class="hljs-number">2</span>]);
<span class="hljs-built_in">double</span> c3 = <span class="hljs-built_in">ref</span>cube(rd);
<span class="hljs-built_in">double</span> c4 = <span class="hljs-built_in">ref</span>cube(*pd);
<span class="hljs-built_in">double</span> c5 = <span class="hljs-built_in">ref</span>cube(edge);
<span class="hljs-built_in">double</span> c6 = <span class="hljs-built_in">ref</span>cube(<span class="hljs-number">7.0</span>);
<span class="hljs-built_in">double</span> c7 = <span class="hljs-built_in">ref</span>cube(side + <span class="hljs-number">10.0</span>);</code></pre></div>

<p>参数side、lens[2]、rd和*pd都是有名称的、double类型的数据对象，因此可以为其创建引用，而不需要临时变量（还记得吗，数组元素 的行为与同类型的变量类似）。然而，edge虽然是变量，类型却不正确，double引用不能指向long。另一方面，参数7.0和side + 10.0的类型都正确，但没有名称，在这些情况下，编译器都将生成一个临时匿名变量，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器便可以随意将其删除。 </p>
<p>那么为什么对于常量引用，这种行为是可行的，其他情况下却不行的呢？对于程序清单8.4中的函数swapr( )：</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapr</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; a, <span class="hljs-type">int</span> &amp; b)</span>    <span class="hljs-comment">// use references</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-type">int</span> temp;

    temp = a;       <span class="hljs-comment">// use a, b for values of variables</span>
    a = b;
    b = temp;
&#125;</code></pre></div>

<p>如果在早期C++较宽松的规则下，执行下面的操作将发生什么情况呢？</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">long</span> a = <span class="hljs-number">3</span>,b = <span class="hljs-number">5</span>;
<span class="hljs-attribute">swapr</span>(a,b);</code></pre></div>

<p>这里的类型不匹配，因此编译器将创建两个临时int变量，将它们初始化为3和5，然后交换临时变量的内容，而a和b保持不变。 </p>
<p>简而言之，如果接受引用参数的函数的意图是修改作为参数传递的变量，则创建临时变量将阻止这种意图的实现。解决方法是，禁止创建 临时变量，现在的C++标准正是这样做的（然而，在默认情况下，有些编译器仍将发出警告，而不是错误消息，因此如果看到了有关临时变量的警告，请不要忽略）。 </p>
<p>现在来看refcube( )函数。该函数的目的只是使用传递的值，而不是修改它们，因此临时变量不会造成任何不利的影响，反而会使函数在可处理的参数种类方面更通用。因此，如果声明将引用指定为const，C++将在必要时生成临时变量。实际上，对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值。 </p>
<p>如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数来引用该变量。</p>
<p>将引用参数声明为常量数据的引用的理由有三个： </p>
<ul>
<li>使用const可以避免无意中修改数据的编程错误； </li>
<li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据； </li>
<li>使用const引用使函数能够正确生成并使用临时变量。</li>
</ul>
<p>C++11新增了另一种引用——右值引用（rvalue reference）。这种引用可指向右值，是使用&amp;&amp;声明的： </p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">double</span> &amp;&amp; rref = std::<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">36.00</span>); <span class="hljs-comment">//not allowed for double &amp;</span>
<span class="hljs-type">double</span> j =<span class="hljs-number">15.0</span>;
<span class="hljs-type">double</span> &amp;&amp; jref = <span class="hljs-number">2.0</span>*j + <span class="hljs-number">18.5</span>;
std::cout &lt;&lt; rref &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
std::cout &lt;&lt; jref &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;</code></pre></div>

<p>新增右值引用的主要目的是，让库设计人员能够提供有些操作的更有效实现。</p>
<h3 id="将引用用于结构"><a href="#将引用用于结构" class="headerlink" title="将引用用于结构"></a>将引用用于结构</h3><p>引用非常适合用于结构和类（C++的用户定义类型）。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。 </p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//strc_ref.cpp -- using structure references</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">free_throws</span>
&#123;
    std::string name;
    <span class="hljs-type">int</span> made;
    <span class="hljs-type">int</span> attempts;
    <span class="hljs-type">float</span> percent;
&#125;;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> free_throws &amp; ft)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_pc</span><span class="hljs-params">(free_throws &amp; ft)</span></span>;
<span class="hljs-function">free_throws &amp; <span class="hljs-title">accumulate</span><span class="hljs-params">(free_throws &amp;target, <span class="hljs-type">const</span> free_throws &amp;source)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    free_throws one = &#123;<span class="hljs-string">&quot;Ifelsa Branch&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>&#125;;
    free_throws two = &#123;<span class="hljs-string">&quot;Andor Knott&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">16</span>&#125;;
    free_throws three = &#123;<span class="hljs-string">&quot;Minnie Max&quot;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;
    free_throws four = &#123;<span class="hljs-string">&quot;Whily Looper&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;
    free_throws five = &#123;<span class="hljs-string">&quot;Long Long&quot;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">14</span>&#125;;
    free_throws team = &#123;<span class="hljs-string">&quot;Throwgoods&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;
    free_throws dup;
    <span class="hljs-built_in">set_pc</span>(one);
    <span class="hljs-built_in">display</span>(one);
    <span class="hljs-built_in">accumulate</span>(team, one);
    <span class="hljs-built_in">display</span>(team);
<span class="hljs-comment">// use return value as argument</span>
    <span class="hljs-built_in">display</span>(<span class="hljs-built_in">accumulate</span>(team, two));
    <span class="hljs-built_in">accumulate</span>(<span class="hljs-built_in">accumulate</span>(team, three), four);
    <span class="hljs-built_in">display</span>(team);
<span class="hljs-comment">// use return value in assignment</span>
    dup = <span class="hljs-built_in">accumulate</span>(team,five);
    std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying team:\n&quot;</span>;
    <span class="hljs-built_in">display</span>(team);
    std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying dup after assignment:\n&quot;</span>;
    <span class="hljs-built_in">display</span>(dup);
    <span class="hljs-built_in">set_pc</span>(four);
<span class="hljs-comment">// ill-advised assignment</span>
    <span class="hljs-built_in">accumulate</span>(dup,five) = four;
    std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying dup after ill-advised assignment:\n&quot;</span>;
    <span class="hljs-built_in">display</span>(dup);
    <span class="hljs-comment">// std::cin.get();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> free_throws &amp; ft)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">using</span> std::cout;
    cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; ft.name &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;  Made: &quot;</span> &lt;&lt; ft.made &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;Attempts: &quot;</span> &lt;&lt; ft.attempts &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;
    cout &lt;&lt; <span class="hljs-string">&quot;Percent: &quot;</span> &lt;&lt; ft.percent &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
&#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_pc</span><span class="hljs-params">(free_throws &amp; ft)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (ft.attempts != <span class="hljs-number">0</span>)
        ft.percent = <span class="hljs-number">100.0f</span> *<span class="hljs-built_in">float</span>(ft.made)/<span class="hljs-built_in">float</span>(ft.attempts);
    <span class="hljs-keyword">else</span>
        ft.percent = <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function">free_throws &amp; <span class="hljs-title">accumulate</span><span class="hljs-params">(free_throws &amp; target, <span class="hljs-type">const</span> free_throws &amp; source)</span></span>
<span class="hljs-function"></span>&#123;
    target.attempts += source.attempts;
    target.made += source.made;
    <span class="hljs-built_in">set_pc</span>(target);
    <span class="hljs-keyword">return</span> target;
&#125;</code></pre></div>

<p>该程序首先初始化了多个结构对象。本书前面说过，如果指定的初始值比成员少，余下的成员（这里只有percent）将被设置为零。第一个函数调用如下： </p>
<div class="code-wrapper"><pre><code class="hljs reasonml">set<span class="hljs-constructor">_pc(<span class="hljs-params">one</span>)</span>;</code></pre></div>

<p>由于函数set_pc()的形参ft为引用，因此ft指向one，函数set_pc()的代码设置成员one.percent。就这里而言，按值传递不可行，因此这将导致设置的是one的临时拷贝的成员percent。根据前一章介绍的知识，另一种方法是使用指针参数并传递地址，但要复杂些：</p>
<div class="code-wrapper"><pre><code class="hljs xl">set_prop(&amp;one)

void set_prop(free_throws * one)&#123;
	<span class="hljs-function"><span class="hljs-title">if</span>(pt-&gt;</span>attempts！=<span class="hljs-number">0</span>)
		<span class="hljs-function"><span class="hljs-title">pt</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">percent</span> = 100.0f*float(pt-&gt;</span><span class="hljs-function"><span class="hljs-title">made</span>)/float(pt-&gt;</span>attempts);
	<span class="hljs-keyword">else</span>
		<span class="hljs-function"><span class="hljs-title">pt</span>-&gt;</span>percent = <span class="hljs-number">0</span>;
&#125;</code></pre></div>

<div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">display</span><span class="hljs-params">(one)</span></span></code></pre></div>

<p>由于display()显示结构的内容，而不修改它，因此这个函数使用了一个const引用参数。就这个函数而言，也可按值传递结构，但与复制原始结构的拷贝相比，使用引用可节省时间和内存。</p>
<div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">accumulate</span>(team, one);</code></pre></div>

<p>函数accumulate()接收两个结构参数，并将第二个结构的成员attempts和made的数据添加到第一个结构的相应成员中。只修改了第一 个结构，因此第一个参数为引用，而第二个参数为const引用：</p>
<div class="code-wrapper"><pre><code class="hljs ceylon">free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; accumulate(free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; target, const free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; source)</code></pre></div>

<p>返回值呢？当前讨论的函数调用没有使用它；就目前而言，原本可以将返回值声明为void，但请看下述函数调用： </p>
<div class="code-wrapper"><pre><code class="hljs lisp">display(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>, two))<span class="hljs-comment">;</span></code></pre></div>

<p>首先，将结构对象team作为第一个参数传递给了accumulate()。这意味着在函数accumulate()中，target指向的是 team。函数accumulate()修改team，再返回指向它的引用</p>
<div class="code-wrapper"><pre><code class="hljs ceylon">free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; accumulate(free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; target, const free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; source)</code></pre></div>

<p>如果返回类型被声明为free_throws而不是free_throws &amp;，上述返回语句将返回target（也就是team）的拷贝。但返回类型为引用，这意味着返回的是最初传递给accumulate()的team对象。 </p>
<p>接下来，将accumulate()的返回值作为参数传递给了display()，这意味着将team传递给了display()。display()的参数为引用，这意味着函数display()中的ft指向的是team，因此将显示team的内容。所以，下述代码：</p>
<div class="code-wrapper"><pre><code class="hljs lisp">display(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>, two))<span class="hljs-comment">;</span></code></pre></div>

<p>与下面的代码等效： </p>
<div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">accumulate</span><span class="hljs-params">(team, two)</span></span>
<span class="hljs-function"><span class="hljs-title">diaplay</span><span class="hljs-params">(team)</span></span></code></pre></div>

<p>上述逻辑也适用于如下语句：</p>
<div class="code-wrapper"><pre><code class="hljs lisp">accumulate(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>, three), four)<span class="hljs-comment">;</span></code></pre></div>

<p>因此，该语句与下面的语句等效： </p>
<div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">accumulate</span>(team, three);
<span class="hljs-built_in">accumulate</span>(team, four);</code></pre></div>

<p>接下来，程序使用了一条赋值语句：</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">dup</span> = accumulate(team,five)<span class="hljs-comment">;</span></code></pre></div>

<p>正如您预期的，这条语句将team中的值复制到dup中。 </p>
<p>最后，程序以独特的方式使用了accumulate()：</p>
<div class="code-wrapper"><pre><code class="hljs fix"><span class="hljs-attr">accumulate(dup,five) </span>=<span class="hljs-string"> four;</span></code></pre></div>

<p>这条语句将值赋给函数调用，这是可行的，因为函数的返回值是一个引用。如果函数accumulate()按值返回，这条语句将不能通过编译。 由于返回的是指向dup的引用，因此上述代码与下面的代码等效</p>
<div class="code-wrapper"><pre><code class="hljs hsp">accumulate(<span class="hljs-keyword">dup</span>,five)<span class="hljs-comment">;</span>
<span class="hljs-keyword">dup</span> = four<span class="hljs-comment">;</span></code></pre></div>

<p>其中第二条语句消除了第一条语句所做的工作，因此在原始赋值语句使用accumulate()的方式并不好。 </p>
<h4 id="为何要返回引用"><a href="#为何要返回引用" class="headerlink" title="为何要返回引用"></a>为何要返回引用</h4><p>下面更深入地讨论返回引用与传统返回机制的不同之处。传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将 结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而调用程序将使用这个值。请看下面的代码：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">double</span> m = sqrt(<span class="hljs-number">16</span>.<span class="hljs-number">0</span>);
<span class="hljs-attribute">cout</span> &lt;&lt; sqrt(<span class="hljs-number">25</span>.<span class="hljs-number">0</span>);</code></pre></div>

<p>在第一条语句中，值4.0被复制到一个临时位置，然后被复制给m。在第二条语句中，值5.0被复制到一个临时位置，然后被传递给cout（这里理论上的描述，实际上，编译器可能合并某些步骤）。 </p>
<p>现在来看下面的语句：</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">dup</span> = accumulate(team,five)<span class="hljs-comment">;</span></code></pre></div>

<p>如果accumulate()返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给dup。但在返回值为 引用时，将直接把team复制到dup，其效率更高。 </p>
<p>返回引用的函数实际上是被引用的变量的别名。 </p>
<h4 id="返回引用时需要注意的问题"><a href="#返回引用时需要注意的问题" class="headerlink" title="返回引用时需要注意的问题"></a>返回引用时需要注意的问题</h4><p>返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。您应避免编写下面这样的代码：</p>
<div class="code-wrapper"><pre><code class="hljs haxe">const free_throws &amp; clone2(free_throws &amp; ft)&#123;
	free_throws <span class="hljs-keyword">new</span><span class="hljs-type">guy</span>;
	<span class="hljs-keyword">new</span><span class="hljs-type">guy</span> = ft;
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">guy</span>;
&#125;</code></pre></div>

<p>该函数返回一个指向临时变量（newguy）的引用，函数运行完毕后它将不再存在。第9章将讨论各种变量的持续性。同样，也应避免返回 指向临时变量的指针。</p>
<p>为避免这种问题，最简单的方法是，返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用 也将指向这些数据。程序清单8.6中的accumulate()正是这样做的。 </p>
<p>另一种方法是用new来分配新的存储空间。前面见过这样的函数，它使用new为字符串分配内存空间，并返回指向该内存空间的指针。下 面是使用引用来完成类似工作的方法：</p>
<div class="code-wrapper"><pre><code class="hljs ceylon">const free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; clone(free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> &amp; ft)&#123;
	free<span class="hljs-number">_</span><span class="hljs-meta">throws</span> * pt;
	*pt = ft;
	<span class="hljs-keyword">return</span> *pt;
&#125;</code></pre></div>

<p>第一条语句创建一个无名的free_throws结构，并让指针pt指向该结构，因此*pt就是该结构。上述代码似乎会返回该结构，但函数声明表 明，该函数实际上将返回这个结构的引用。这样，便可以这样使用该函数：</p>
<div class="code-wrapper"><pre><code class="hljs 1c">free_throws <span class="hljs-meta">&amp; jolly = clone(three);</span></code></pre></div>

<p>这使得jolly成为新结构的引用。这种方法存在一个问题：在不再需要new分配的内存时，应使用delete来释放它们。调用clone( )隐藏了对new的调用，这使得以后很容易忘记使用delete来释放内存。第16章讨论的auto_ptr模板以及C++11新增的unique_ptr可帮助程序员自动完成释放工作。</p>
<h4 id="为何将const用于引用返回类型"><a href="#为何将const用于引用返回类型" class="headerlink" title="为何将const用于引用返回类型"></a>为何将const用于引用返回类型</h4><div class="code-wrapper"><pre><code class="hljs fix"><span class="hljs-attr">accumulate(dup,five) </span>=<span class="hljs-string"> four;</span></code></pre></div>

<p>其效果如下：首先将five的数据添加到dup中，再使用four的内容覆盖dup的内容。这条语句为何能够通过编译呢？在赋值语句中，左边必须是可修改的左值。也就是说，在赋值表达式中，左边的子表达式必须标识一个可修改的内存块。在这里，函数返回指向dup的引用，它确实标识的是一个这样的内存块，因此这条语句是合法的。 </p>
<p>另一方面，常规（非引用）返回类型是右值——不能通过地址访问的值。这种表达式可出现在赋值语句的右边，但不能出现在左边。其他 右值包括字面值（如10.0）和表达式（如x + y）。显然，获取字面值（如10.0）的地址没有意义，但为何常规函数返回值是右值呢？这是因为这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在。</p>
<p>假设您要使用引用返回值，但又不允许执行像给accumulate()赋值这样的操作，只需将返回类型声明为const引用： </p>
<div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">const</span> free_throws &amp; <span class="hljs-title">accumlate</span><span class="hljs-params">(free_throws &amp; target,<span class="hljs-type">const</span> free_throws &amp; source)</span></span>;</code></pre></div>

<p>现在返回类型为const，是不可修改的左值，因此下面的赋值语句不合法：</p>
<div class="code-wrapper"><pre><code class="hljs livecodeserver">accumlate(dup,<span class="hljs-literal">five</span>) = <span class="hljs-literal">four</span><span class="hljs-comment">;//not allowed for const reference return</span></code></pre></div>

<p>该程序中的其他函数调用又如何呢？返回类型为const引用后，下面的语句仍合法：</p>
<div class="code-wrapper"><pre><code class="hljs lisp">display(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>,two))<span class="hljs-comment">;</span></code></pre></div>

<p>这是因为display()的形参也是const free_throws &amp;类型。但下面的语句不合法，因此accumulate()的第一个形参不是const： </p>
<div class="code-wrapper"><pre><code class="hljs lisp">accumulate(<span class="hljs-name">accumulate</span>(<span class="hljs-name">team</span>,three),four)<span class="hljs-comment">;</span></code></pre></div>

<p>这影响大吗？就这里而言不大，因为您仍可以这样做：</p>
<div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-built_in">accumulate</span>(team,three);
<span class="hljs-built_in">accumulate</span>(team,four);</code></pre></div>

<p>另外，您仍可以在赋值语句右边使用accumulate()。 </p>
<p>通过省略const，可以编写更简短代码，但其含义也更模糊,通常，应避免在设计中添加模糊的特性，因为模糊特性增加了犯错 的机会。将返回类型声明为const引用，可避免您犯糊涂。然而，有时候省略const确实有道理，第11章将讨论的重载运算符&lt;&lt;就是一个这样的例子</p>
<h3 id="将引用用于类对象"><a href="#将引用用于类对象" class="headerlink" title="将引用用于类对象"></a>将引用用于类对象</h3><p>将类对象传递给函数时，C++通常的做法是使用引用</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// strquote.cpp  -- different designs</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function">string <span class="hljs-title">version1</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span></span>;
<span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version2</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span></span>;  <span class="hljs-comment">// has side effect</span>
<span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version3</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span></span>;  <span class="hljs-comment">// bad design</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    string input;
    string copy;
    string result;

    cout &lt;&lt; <span class="hljs-string">&quot;Enter a string: &quot;</span>;
    <span class="hljs-built_in">getline</span>(cin, input);
    copy = input;
    cout &lt;&lt; <span class="hljs-string">&quot;Your string as entered: &quot;</span> &lt;&lt; input &lt;&lt; endl;
    result = <span class="hljs-built_in">version1</span>(input, <span class="hljs-string">&quot;***&quot;</span>);
    cout &lt;&lt; <span class="hljs-string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;

    result = <span class="hljs-built_in">version2</span>(input, <span class="hljs-string">&quot;###&quot;</span>);
    cout &lt;&lt; <span class="hljs-string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;

    cout &lt;&lt; <span class="hljs-string">&quot;Resetting original string.\n&quot;</span>;
    input = copy;
    result = <span class="hljs-built_in">version3</span>(input, <span class="hljs-string">&quot;@@@&quot;</span>);
    cout &lt;&lt; <span class="hljs-string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;
    cout &lt;&lt; <span class="hljs-string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;
    <span class="hljs-comment">// cin.get();</span>
    <span class="hljs-comment">// cin.get();</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function">string <span class="hljs-title">version1</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span></span>
<span class="hljs-function"></span>&#123;
    string temp;

    temp = s2 + s1 + s2;
    <span class="hljs-keyword">return</span> temp;
&#125;

<span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version2</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span>   <span class="hljs-comment">// has side effect</span></span>
<span class="hljs-function"></span>&#123;
    s1 = s2 + s1 + s2;
<span class="hljs-comment">// safe to return reference passed to function</span>
    <span class="hljs-keyword">return</span> s1;
&#125;

<span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version3</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span>   <span class="hljs-comment">// bad design</span></span>
<span class="hljs-function"></span>&#123;
    string temp;

    temp = s2 + s1 + s2;
<span class="hljs-comment">// unsafe to return reference to local variable</span>
    <span class="hljs-keyword">return</span> temp;
&#125;</code></pre></div>



<div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-built_in">string</span> <span class="hljs-title function_">version1</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; s1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; s2</span>)
&#123;
    <span class="hljs-built_in">string</span> temp;

    temp = s2 + s1 + s2;
    <span class="hljs-keyword">return</span> temp;
&#125;</code></pre></div>

<p>它接受两个string参数，并使用string类的相加功能来创建一个满足要求的新字符串。这两个函数参数都是const引用。如果使用string对象作为参数，最终结果将不变： </p>
<div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">version4</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s1,<span class="hljs-built_in">string</span> s2</span>)</span>;</code></pre></div>

<p>在这种情况下，s1和s2将为string对象。使用引用的效率更高，因为函数不需要创建新的string对象，并将原来对象中的数据复制到新对象中。限定符const指出，该函数将使用原来的string对象，但不会修改它。</p>
<p>temp是一个新的string对象，只在函数version1( )中有效，该函数执行完毕后，它将不再存在。因此，返回指向temp的引用不可行，因此该 函数的返回类型为string，这意味着temp的内容将被复制到一个临时存储单元中，然后在main( )中，该存储单元的内容被复制到一个名为result的string中： </p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = version1(input, <span class="hljs-string">&quot;***&quot;</span>)<span class="hljs-comment">;</span></code></pre></div>

<p>对于函数version1( )，您可能注意到了很有趣的一点：该函数的两个形参（s1和s2）的类型都是const string &amp;，但实参（input和“***”）的类型分别是string和const char *。由于input的类型为string，因此让s1指向它没有任何问题。然而，程序怎么能够接受将char指针赋给string引用呢？</p>
<p>这里有两点需要说明。首先，string类定义了一种char *到string的转换功能，这使得可以 使用C-风格字符串来初始化string对象。其次是本章前面讨论过的类型为const引用的形参的一 个属性。假设实参的类型与引用参数类型不匹配，但可被转换为引用类型，程序将创建一个 正确类型的临时变量，使用转换后的实参值来初始化它，然后传递一个指向该临时变量的引 用。例如，在本章前面，将int实参传递给const double &amp;形参时，就是以这种方式进行处理 的。同样，也可以将实参char *或const char *传递给形参const string &amp;。</p>
<p>这种属性的结果是，如果形参类型为const string &amp;，在调用函数时，使用的实参可以是string对象或C-风格字符串，如用引号括起的字符串字面量、以空字符结尾的char数组或指向char的指针变量。因此，下面的代码是可行的：</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = version1(input, <span class="hljs-string">&quot;***&quot;</span>)<span class="hljs-comment">;</span></code></pre></div>

<p>函数version2( )不创建临时string对象，而是直接修改原来的string对象：</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">const</span> string &amp; version2(string &amp; <span class="hljs-built_in">s1</span>, const string &amp; <span class="hljs-built_in">s2</span>)   <span class="hljs-comment">// has side effect</span>
&#123;
    <span class="hljs-built_in">s1</span> = <span class="hljs-built_in">s2</span> + <span class="hljs-built_in">s1</span> + <span class="hljs-built_in">s2</span><span class="hljs-comment">;</span>
<span class="hljs-comment">// safe to return reference passed to function</span>
    return <span class="hljs-built_in">s1</span><span class="hljs-comment">;</span>
&#125;</code></pre></div>

<p>该函数可以修改s1，因为不同于s2，s1没有被声明为const。 </p>
<p>由于s1是指向main( )中一个对象（input）的引用，因此将s1最为引用返回是安全的。由于s1是指向input的引用，因此，下面一行代码：</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = version2(input, <span class="hljs-string">&quot;###&quot;</span>)<span class="hljs-comment">;</span></code></pre></div>

<p>等价于</p>
<div class="code-wrapper"><pre><code class="hljs hsp">version2(<span class="hljs-keyword">input</span>, <span class="hljs-string">&quot;###&quot;</span>)<span class="hljs-comment">;</span>
result = <span class="hljs-keyword">input</span></code></pre></div>

<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">version3</span><span class="hljs-params">(string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)</span>   <span class="hljs-comment">// bad design</span></span>
<span class="hljs-function"></span>&#123;
    string temp;

    temp = s2 + s1 + s2;
<span class="hljs-comment">// unsafe to return reference to local variable</span>
    <span class="hljs-keyword">return</span> temp;
&#125;</code></pre></div>

<p>它存在一个致命的缺陷：返回一个指向version3( )中声明的变量的引用。这个函数能够通过编译（但编译器会发出警告），但当程序试图 执行该函数时将崩溃。具体地说，问题是由下面的赋值语句引发的：</p>
<div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = version3(input, <span class="hljs-string">&quot;@@@&quot;</span>)<span class="hljs-comment">;</span></code></pre></div>

<p>程序试图引用已经释放的内存。</p>
<h3 id="对象、继承和引用"><a href="#对象、继承和引用" class="headerlink" title="对象、继承和引用"></a>对象、继承和引用</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/c/" class="category-chain-item">c++</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/c/">#c++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C-Primer-Plus2</div>
      <div>http://example.com/2023/03/04/C-Primer-Plus2/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月4日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/05/hello-world/" title="Hello World">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/26/Effective-Typescript/" title="Effective Typescript">
                        <span class="hidden-mobile">Effective Typescript</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
